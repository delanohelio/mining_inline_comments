{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1NTAxMjE5", "number": 18056, "title": "ChangeFeed pull model and switching CF processor to FeedRange", "bodyText": "Scope of this PR:\n\nIntroducing ChangeFeed pull model (as Beta)\nIntroducing ChangeFeed full fidelity (as Beta) in pull model\nIntroducing capability to use FeedRange filtering on ChangeFeed\n\nToDos for subsequent PRs:\n\nAdding test coverage for Split-proof of ChangeFeed pull model (should work, but needs to get tested)\nAllowing customers to opt-into new Lease contract version in ChangeFeedProcessor - this would mean using FeedRange instead of PKRangeId as identifier - json-serialized ChangeFeedStateV1 would be used as lease token. This has to be opt-in because it would mean instances still using older SDK version wouldn't be able to read the new lease documents anymore. This is a pre-requisit for making ChangeFeedProcessor merge-proof\nMaking ChangeFeed pull model and processor merge-proof and adding test coverage", "createdAt": "2020-12-09T22:21:14Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056", "merged": true, "mergeCommit": {"oid": "bfab23f99eedeeae3255e9f30e3e6604cf381ead"}, "closed": true, "closedAt": "2021-01-26T09:03:52Z", "author": {"login": "FabianMeiswinkel"}, "timelineItems": {"totalCount": 153, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdxthVqAH2gAyNTM1NTAxMjE5OjYzOTJmOWFhYTMwZmU5NmYxODY3YjM1OTU4YzVhZjYyZDVjMWMxN2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABemAbA4gFqTY5Njc3NzE1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6392f9aaa30fe96f1867b35958c5af62d5c1c17b", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6392f9aaa30fe96f1867b35958c5af62d5c1c17b", "committedDate": "2021-01-19T16:01:40Z", "message": "Update FeedRange.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29c0719aa828a6b2ac81f717eff81f12f03adfbf", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/29c0719aa828a6b2ac81f717eff81f12f03adfbf", "committedDate": "2021-01-19T17:57:45Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0804d1617b2c39f0ac7c8a84c578657e6cfe8437", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0804d1617b2c39f0ac7c8a84c578657e6cfe8437", "committedDate": "2021-01-19T19:34:36Z", "message": "Fixing typos in comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1d565ee192c924299c3053b7cdc1c47aed4fef3", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c1d565ee192c924299c3053b7cdc1c47aed4fef3", "committedDate": "2021-01-19T23:30:31Z", "message": "Fixing Duration in ChangeFeedPolicy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7148a3a58d5334f9aee023968db55ef1def39747", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7148a3a58d5334f9aee023968db55ef1def39747", "committedDate": "2021-01-20T00:43:04Z", "message": "Changing the encoding of FeedRange and ChangeFeedState to be base64-encoded Json vs. Json"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8ed9937dd19a74448cb2884155ee06f208dc00e", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b8ed9937dd19a74448cb2884155ee06f208dc00e", "committedDate": "2021-01-20T01:24:57Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "268e467ada8b7ad5846fc30cedfa4e12bc5a0129", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/268e467ada8b7ad5846fc30cedfa4e12bc5a0129", "committedDate": "2021-01-20T02:06:30Z", "message": "Fixing spotbug issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7718b241b6c5f7c91afc9fd5696cba0f48dda0de", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7718b241b6c5f7c91afc9fd5696cba0f48dda0de", "committedDate": "2021-01-20T09:25:44Z", "message": "Fixing test issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4db657eebb17287f4b572ea92d3355e856c314cb", "committedDate": "2021-01-20T18:30:01Z", "message": "Switching deserializer registration to annotation based approach"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjgwOTg2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572680986", "createdAt": "2021-01-20T21:52:26Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMTo1MjoyN1rOIXU75g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMTo1MjoyN1rOIXU75g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMzMTE3NA==", "bodyText": "CosmosDB.Emulator.exe -> Microsoft.Azure.Cosmos.Emulator.exe", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561331174", "createdAt": "2021-01-20T21:52:27Z", "author": {"login": "milismsft"}, "path": "eng/common/pipelines/templates/steps/cosmos-emulator.yml", "diffHunk": "@@ -9,8 +9,92 @@ steps:\n       Write-Host \"Target Dir: $targetDir\"\n       msiexec /a ${{ parameters.EmulatorMsiUrl }} TARGETDIR=$targetDir /qn | wait-process\n     displayName: Download and Extract Public Cosmos DB Emulator\n+  - powershell: |\n+      Write-Host \"Deleting Cosmos DB Emulator data\"\n+      if (Test-Path $Env:LOCALAPPDATA\\CosmosDbEmulator) { Remove-Item -Recurse -Force $Env:LOCALAPPDATA\\CosmosDbEmulator }\n+    displayName: Delete Cosmos DB Emulator data\n+  - powershell: |\n+      Write-Host \"Getting Cosmos DB Emulator Version\"\n+      $ProductName = \"Azure Cosmos DB Emulator\"\n+      $Emulator = (Join-Path $env:temp (Join-Path $ProductName \"CosmosDB.Emulator.exe\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjgxNzI2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572681726", "createdAt": "2021-01-20T21:53:30Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMTo1MzozMFrOIXU98A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMTo1MzozMFrOIXU98A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMzMTY5Ng==", "bodyText": "CosmosDB.Emulator.exe -> Microsoft.Azure.Cosmos.Emulator.exe", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561331696", "createdAt": "2021-01-20T21:53:30Z", "author": {"login": "milismsft"}, "path": "eng/common/pipelines/templates/steps/cosmos-emulator.yml", "diffHunk": "@@ -9,8 +9,92 @@ steps:\n       Write-Host \"Target Dir: $targetDir\"\n       msiexec /a ${{ parameters.EmulatorMsiUrl }} TARGETDIR=$targetDir /qn | wait-process\n     displayName: Download and Extract Public Cosmos DB Emulator\n+  - powershell: |\n+      Write-Host \"Deleting Cosmos DB Emulator data\"\n+      if (Test-Path $Env:LOCALAPPDATA\\CosmosDbEmulator) { Remove-Item -Recurse -Force $Env:LOCALAPPDATA\\CosmosDbEmulator }\n+    displayName: Delete Cosmos DB Emulator data\n+  - powershell: |\n+      Write-Host \"Getting Cosmos DB Emulator Version\"\n+      $ProductName = \"Azure Cosmos DB Emulator\"\n+      $Emulator = (Join-Path $env:temp (Join-Path $ProductName \"CosmosDB.Emulator.exe\"))\n+      $fileVersion = Get-ChildItem $Emulator\n+      Write-Host $Emulator $fileVersion.VersionInfo\n+    displayName: Get Cosmos DB Emulator Version\n   - powershell: |\n       Write-Host \"Launching Cosmos DB Emulator\"\n-      Import-Module \"$env:temp\\Azure Cosmos DB Emulator\\PSModules\\Microsoft.Azure.CosmosDB.Emulator\"\n-      Start-CosmosDbEmulator -NoUI ${{ parameters.StartParameters }}\n+      $ProductName = \"Azure Cosmos DB Emulator\"\n+      $Emulator = (Join-Path $env:temp (Join-Path $ProductName \"CosmosDB.Emulator.exe\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjgyODQ1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572682845", "createdAt": "2021-01-20T21:55:11Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMTo1NToxMVrOIXVBeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMTo1NToxMVrOIXVBeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMzMjYwMg==", "bodyText": "\"Packages\\DataExplorer\\versionInfo.json\" contains the full version info", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561332602", "createdAt": "2021-01-20T21:55:11Z", "author": {"login": "milismsft"}, "path": "eng/common/pipelines/templates/steps/cosmos-emulator.yml", "diffHunk": "@@ -9,8 +9,92 @@ steps:\n       Write-Host \"Target Dir: $targetDir\"\n       msiexec /a ${{ parameters.EmulatorMsiUrl }} TARGETDIR=$targetDir /qn | wait-process\n     displayName: Download and Extract Public Cosmos DB Emulator\n+  - powershell: |\n+      Write-Host \"Deleting Cosmos DB Emulator data\"\n+      if (Test-Path $Env:LOCALAPPDATA\\CosmosDbEmulator) { Remove-Item -Recurse -Force $Env:LOCALAPPDATA\\CosmosDbEmulator }\n+    displayName: Delete Cosmos DB Emulator data\n+  - powershell: |\n+      Write-Host \"Getting Cosmos DB Emulator Version\"\n+      $ProductName = \"Azure Cosmos DB Emulator\"\n+      $Emulator = (Join-Path $env:temp (Join-Path $ProductName \"CosmosDB.Emulator.exe\"))\n+      $fileVersion = Get-ChildItem $Emulator\n+      Write-Host $Emulator $fileVersion.VersionInfo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjkxNjY1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572691665", "createdAt": "2021-01-20T22:08:55Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjowODo1NVrOIXVczA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjowODo1NVrOIXVczA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMzOTU5Ng==", "bodyText": "useEtagAsContinuation... why etag?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561339596", "createdAt": "2021-01-20T22:08:55Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -565,8 +597,11 @@ ItemDeserializer getItemDeserializer() {\n         );\n     }\n \n-    private <T> Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> queryDecryptionTransformer(Class<T> classType,\n-                                                                                                   Function<CosmosPagedFluxOptions, Flux<FeedResponse<JsonNode>>> func) {\n+    private <T> Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> queryDecryptionTransformer(\n+        Class<T> classType,\n+        Function<CosmosPagedFluxOptions, Flux<FeedResponse<JsonNode>>> func,\n+        boolean useEtagAsContinuation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjk1ODgy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572695882", "createdAt": "2021-01-20T22:15:37Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoxNTozN1rOIXVpXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoxNTozN1rOIXVpXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MjgxMg==", "bodyText": "we will change these to real versions, right? :-)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561342812", "createdAt": "2021-01-20T22:15:37Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -471,14 +476,94 @@ public String getId() {\n \n                 return getDatabase().getDocClientWrapper()\n                              .queryDocuments(CosmosAsyncContainer.this.getLink(), sqlQuerySpec, cosmosQueryRequestOptions)\n-                             .map(response -> prepareFeedResponse(response, classType));\n+                             .map(response -> prepareFeedResponse(response, false, classType));\n         });\n \n         return pagedFluxOptionsFluxFunction;\n     }\n \n-    private <T> FeedResponse<T> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType) {\n+    /**\n+     * Query for items in the change feed of the current container using the {@link CosmosChangeFeedRequestOptions}.\n+     * <p>\n+     * After subscription the operation will be performed. The {@link Flux} will\n+     * contain one or several feed response of the obtained items. In case of\n+     * failure the {@link CosmosPagedFlux} will error.\n+     *\n+     * @param <T> the type parameter.\n+     * @param options the change feed request options.\n+     * @param classType the class type.\n+     * @return a {@link CosmosPagedFlux} containing one or several feed response pages of the obtained\n+     * items or an error.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNjk2ODc2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572696876", "createdAt": "2021-01-20T22:17:16Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoxNzoxNlrOIXVstQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjoxNzoxNlrOIXVstQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MzY2OQ==", "bodyText": "same here", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561343669", "createdAt": "2021-01-20T22:17:16Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -338,6 +359,33 @@ private TransactionalBatchResponse blockBatchResponse(Mono<TransactionalBatchRes\n         return getCosmosPagedIterable(this.asyncContainer.queryItems(querySpec, options, classType));\n     }\n \n+    /**\n+     * Query for items in the change feed of the current container using the {@link CosmosChangeFeedRequestOptions}.\n+     * <p>\n+     * The next page can be retrieved by calling queryChangeFeed again with a new instance of\n+     * {@link CosmosChangeFeedRequestOptions} created from the continuation token of the previously returned\n+     * {@link FeedResponse} instance.\n+     *\n+     * @param <T> the type parameter.\n+     * @param options the change feed request options.\n+     * @param classType the class type.\n+     * @return a {@link CosmosPagedFlux} containing one feed response page\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNzEzOTc3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572713977", "createdAt": "2021-01-20T22:46:34Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjo0NjozNFrOIXWjkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMjo0NjozNFrOIXWjkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM1NzcxMw==", "bodyText": "curious, what's the point of this and why we could not extract the self link directly from the CosmosAsyncContainer param?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561357713", "createdAt": "2021-01-20T22:46:34Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedContextClientImpl.java", "diffHunk": "@@ -83,20 +79,40 @@ public ChangeFeedContextClientImpl(CosmosAsyncContainer cosmosContainer, Schedul\n     }\n \n     @Override\n-    public Flux<FeedResponse<JsonNode>> createDocumentChangeFeedQuery(CosmosAsyncContainer collectionLink,\n-                                                                      ChangeFeedOptions feedOptions) {\n+    public Flux<FeedResponse<JsonNode>> createDocumentChangeFeedQuery(\n+        CosmosAsyncContainer collectionLink,\n+        CosmosChangeFeedRequestOptions requestOptions) {\n+\n         AsyncDocumentClient clientWrapper =\n             CosmosBridgeInternal.getAsyncDocumentClient(collectionLink.getDatabase());\n         Flux<FeedResponse<JsonNode>> feedResponseFlux =\n-            clientWrapper.queryDocumentChangeFeed(BridgeInternal.extractContainerSelfLink(collectionLink), feedOptions)\n-                                                                    .map(response -> {\n-                                                                        List<JsonNode> results = response.getResults()\n-                                                                                                                     .stream()\n-                                                                                                                     .map(document ->\n-                                                                                                                         ModelBridgeInternal.toObjectFromJsonSerializable(document, JsonNode.class))\n-                                                                                                                     .collect(Collectors.toList());\n-                                                                        return BridgeInternal.toFeedResponsePage(results, response.getResponseHeaders(), false);\n-                                                                    });\n+            clientWrapper\n+                .getCollectionCache()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNzI2Mjk1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572726295", "createdAt": "2021-01-20T23:04:20Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMzowNDoyMFrOIXXCWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMzowNDoyMFrOIXXCWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM2NTU5Mw==", "bodyText": "The initial intent was to make these settings configurable at some point. However we've been running with these defaults for a while now without any issues and no requests from customers to change them.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561365593", "createdAt": "2021-01-20T23:04:20Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedProcessorBuilderImpl.java", "diffHunk": "@@ -72,16 +67,13 @@\n     private static final String PK_RANGE_ID_SEPARATOR = \":\";\n     private static final String SEGMENT_SEPARATOR = \"#\";\n     private static final String PROPERTY_NAME_LSN = \"_lsn\";\n-    private static final String PROPERTY_NAME_TS = \"_ts\";\n \n     private final Logger logger = LoggerFactory.getLogger(ChangeFeedProcessorBuilderImpl.class);\n-    private static final long DefaultUnhealthinessDuration = Duration.ofMinutes(15).toMillis();\n     private final Duration sleepTime = Duration.ofSeconds(15);\n     private final Duration lockTime = Duration.ofSeconds(30);\n-    private static final int DefaultQueryPartitionsMaxBatchSize = 100;\n+    private static final int DEFAULT_QUERY_PARTITIONS_MAX_BATCH_SIZE = 100;\n \n-    private int queryPartitionsMaxBatchSize = DefaultQueryPartitionsMaxBatchSize;\n-    private int degreeOfParallelism = 25; // default\n+    private final static int DEFAULT_DEGREE_OF_PARALLELISM = 25; // default", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNzQzMTk4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572743198", "createdAt": "2021-01-20T23:13:13Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMzoxMzoxM1rOIXXQgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMzoxMzoxM1rOIXXQgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM2OTIxNg==", "bodyText": "nit: start with a non-zero value", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561369216", "createdAt": "2021-01-20T23:13:13Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedStateVersions.java", "diffHunk": "@@ -0,0 +1,7 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+public class ChangeFeedStateVersions {\n+    public final static int V1 = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNzc1Mjg5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-572775289", "createdAt": "2021-01-20T23:30:22Z", "commit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMzozMDoyMlrOIXXsiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQyMzozMDoyMlrOIXXsiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM3NjM5NQ==", "bodyText": "We need to add a public facing configuration setting to toggle between full fidelity and incremental.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561376395", "createdAt": "2021-01-20T23:30:22Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorFactoryImpl.java", "diffHunk": "@@ -60,20 +93,24 @@ public PartitionProcessor create(Lease lease, ChangeFeedObserver observer) {\n             throw new IllegalArgumentException(\"lease\");\n         }\n \n-        String startContinuation = lease.getContinuationToken();\n-\n-        if (startContinuation == null || startContinuation.isEmpty()) {\n-            startContinuation = this.changeFeedProcessorOptions.getStartContinuation();\n+        FeedRangeInternal feedRange = new FeedRangePartitionKeyRangeImpl(lease.getLeaseToken());\n+        ChangeFeedState state;\n+        if (Strings.isNullOrWhiteSpace(lease.getContinuationToken())) {\n+            state = new ChangeFeedStateV1(\n+                BridgeInternal.extractContainerSelfLink(this.collectionSelfLink),\n+                new FeedRangePartitionKeyRangeImpl(lease.getLeaseToken()),\n+                ChangeFeedMode.INCREMENTAL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb"}, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "681d994d01c7dcffb4860f1a79bc332490de10f4", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/681d994d01c7dcffb4860f1a79bc332490de10f4", "committedDate": "2021-01-21T10:56:39Z", "message": "Reacting to code review feedback from Milis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "964c2da8f5c7754994e9018d2a3d16718bbb1e99", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/964c2da8f5c7754994e9018d2a3d16718bbb1e99", "committedDate": "2021-01-21T10:59:35Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ab94708a0a2691d871a030d7b27691c41a639e36", "committedDate": "2021-01-21T13:37:09Z", "message": "Fixing Test issues after changing ChangeFeedStateVersion from 0 to 1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNTMwMzg1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-573530385", "createdAt": "2021-01-21T16:49:09Z", "commit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNjo0OTowOVrOIX_7Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNjo0OTowOVrOIX_7Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAzNTUxOA==", "bodyText": "Unrelated to current PR (just about emulator)\nConvention of \"-\" and \"/\": are these two separate conventions supported?\nIf not won;t it break existing flows?\n/cc: @milismsft", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562035518", "createdAt": "2021-01-21T16:49:09Z", "author": {"login": "kirankumarkolli"}, "path": "eng/pipelines/templates/stages/cosmos-sdk-client.yml", "diffHunk": "@@ -133,7 +133,7 @@ stages:\n         PreRunSteps:\n         - template: /eng/common/pipelines/templates/steps/cosmos-emulator.yml\n           parameters:\n-            StartParameters: '-EnableAadAuthentication -PartitionCount 50 -Consistency Strong -Timeout 600 -EnablePreview'\n+            StartParameters: '/noexplorer /noui /enablepreview /disableratelimiting /enableaadauthentication /partitioncount=50 /consistency=Strong'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNTMxNjM3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-573531637", "createdAt": "2021-01-21T16:50:22Z", "commit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNjo1MDoyM1rOIX_-6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNjo1MDoyM1rOIX_-6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAzNjQ1Ng==", "bodyText": "Are these possible to put as style guides like in VS?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562036456", "createdAt": "2021-01-21T16:50:23Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -89,7 +92,7 @@\n                 if (decryptResponse) {\n                     return setByteArrayContent(rsp,\n                         EncryptionProcessor.decrypt(EncryptionModelBridgeInternal.getByteArrayContent(rsp),\n-                            this.encryptor).map(pair -> pair.getLeft()).publishOn(encryptionScheduler));\n+                            this.encryptor).map(Pair::getLeft).publishOn(encryptionScheduler));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNTQ4Njg0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-573548684", "createdAt": "2021-01-21T17:08:06Z", "commit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNzowODowNlrOIYAxow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNzowODowNlrOIYAxow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA0OTQ0Mw==", "bodyText": "Does casing matters or just as convention?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562049443", "createdAt": "2021-01-21T17:08:06Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/HttpConstants.java", "diffHunk": "@@ -38,7 +38,7 @@\n         public static final String USER_AGENT = \"User-Agent\";\n         public static final String IF_MODIFIED_SINCE = \"If-Modified-Since\";\n         public static final String IF_MATCH = \"If-Match\";\n-        public static final String IF_NONE_MATCH = \"If-NONE-Match\";\n+        public static final String IF_NONE_MATCH = \"If-None-Match\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTczNTUwMTYw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-573550160", "createdAt": "2021-01-21T17:09:38Z", "commit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNzowOTozOFrOIYA16A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNzowOTozOFrOIYA16A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA1MDUzNg==", "bodyText": "nit: naming, how does RETRY_NOW sound?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562050536", "createdAt": "2021-01-21T17:09:38Z", "author": {"login": "kirankumarkolli"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ShouldRetryResult.java", "diffHunk": "@@ -5,6 +5,11 @@\n import java.time.Duration;\n \n public class ShouldRetryResult {\n+    public final static ShouldRetryResult NO_RETRY =\n+        ShouldRetryResult.noRetry();\n+    public final static ShouldRetryResult RETRY_IMMEDIATELY =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9401ab27837cf750ee7a5789dbe84cb793630db", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e9401ab27837cf750ee7a5789dbe84cb793630db", "committedDate": "2021-01-21T20:23:12Z", "message": "Fix test issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df78ea01bf3c9fb78b1990b709dcdd0ad998d1b5", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/df78ea01bf3c9fb78b1990b709dcdd0ad998d1b5", "committedDate": "2021-01-21T20:50:09Z", "message": "Renaming ShouldretryResult.RETRY_IMMEDIATELY to RETRY_NOW"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "committedDate": "2021-01-21T23:53:36Z", "message": "Adding Status code to JavaDoc description when processing FF CF outside retention"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NDM3OTYx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-574437961", "createdAt": "2021-01-22T16:51:44Z", "commit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNjo1MTo0NVrOIYsemg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNjo1OTo1N1rOIYszQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc2NTQ2Ng==", "bodyText": "This existed in .NET because originally, we also used this for normal ReadFeed, probably not worth it here", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562765466", "createdAt": "2021-01-22T16:51:45Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeCompositeContinuationImpl.java", "diffHunk": "@@ -303,14 +320,14 @@ private static CompositeContinuationToken createCompositeContinuationTokenForRan\n \n     private void moveToNextToken() {\n         final CompositeContinuationToken recentToken = this.compositeContinuationTokens.poll();\n-        if (recentToken.getToken() != null) {\n+        // TODO fabianm remove if (recentToken.getToken() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc2ODU2OQ==", "bodyText": "nit: We don't let users create FeedRanges in .NET other than the PartitionKey, the APIs to create the state take FeedRange optionally, so the user only needs to understand the FeedRange concept in the case they want to parallelize work (if they are reading the complete container, they never deal with it).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562768569", "createdAt": "2021-01-22T16:56:38Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/FeedRange.java", "diffHunk": "@@ -16,9 +18,38 @@\n      * @param json A string representation of a feed range\n      * @return A feed range\n      */\n-    public static FeedRange fromJsonString(String json) {\n-        return FeedRangeInternal.fromJsonString(json);\n+    @Beta(value = Beta.SinceVersion.V4_9_0, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static FeedRange fromString(String json) {\n+        return FeedRangeInternal.fromBase64EncodedJsonString(json);\n     }\n \n-    public String toJsonString();\n+    /**\n+     * Gets a json representation of the feed range - the returned json string can be used\n+     * to create a new feed range instance from it - (use factory method fromJsonString to do so)\n+     * @return a JSON string representing the feed range\n+     */\n+    @Beta(value = Beta.SinceVersion.V4_9_0, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public String toString();\n+\n+    /**\n+     * Creates a range for a certain logical partition\n+     * @param partitionKey the logical partition key value\n+     * @return A feed range for a certain logical partition\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static FeedRange forLogicalPartition(PartitionKey partitionKey) {\n+        checkNotNull(partitionKey, \"Argument 'partitionKey' must not be null.\");\n+\n+        return new FeedRangePartitionKeyImpl(\n+            ModelBridgeInternal.getPartitionKeyInternal(partitionKey));\n+    }\n+\n+    /**\n+     * Creates a range for an entire container\n+     * @return A feed range for an entire container\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static FeedRange forFullRange() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3MDc1NA==", "bodyText": "If the new query is split proof, how does the PARTITION_SPLIT error bubble up?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562770754", "createdAt": "2021-01-22T16:59:57Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorImpl.java", "diffHunk": "@@ -123,8 +121,8 @@ public PartitionProcessorImpl(ChangeFeedObserver observer, ChangeFeedContextClie\n                 if (throwable instanceof CosmosException) {\n \n                     CosmosException clientException = (CosmosException) throwable;\n-                    logger.warn(\"CosmosException: partition {} from thread {}\",\n-                        this.settings.getPartitionKeyRangeId(), Thread.currentThread().getId(), clientException);\n+                    logger.warn(\"CosmosException: FeedRange {} from thread {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NTUxNzIz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-574551723", "createdAt": "2021-01-22T19:22:33Z", "commit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxOToyMjozNFrOIYyBGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxOTo0NTowMFrOIYyufw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1NjIxNw==", "bodyText": "I agree, some of these are related to personal coding styles as well, for example I like to change things to lambda with method reference, like done above, but not everyone follows this syntax. And I don't think it will be any helpful to force these style changes.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562856217", "createdAt": "2021-01-22T19:22:34Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -89,7 +92,7 @@\n                 if (decryptResponse) {\n                     return setByteArrayContent(rsp,\n                         EncryptionProcessor.decrypt(EncryptionModelBridgeInternal.getByteArrayContent(rsp),\n-                            this.encryptor).map(pair -> pair.getLeft()).publishOn(encryptionScheduler));\n+                            this.encryptor).map(Pair::getLeft).publishOn(encryptionScheduler));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAzNjQ1Ng=="}, "originalCommit": {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg2NzQ2Nw==", "bodyText": "Is this API being used anywhere ?\nAlso, what is the reason of using blockFirst() and not blockLast()?\nIf there is only single element in this Flux, why not use Mono<FeedResponse<T>> ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562867467", "createdAt": "2021-01-22T19:44:13Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -259,6 +261,25 @@ public ThroughputResponse readThroughput() {\n         }\n     }\n \n+    /**\n+     * Block on first feed response.\n+     *\n+     * @param feedResponseFlux the feed response flux mono.\n+     * @return the cosmos item response.\n+     */\n+    <T> FeedResponse<T> blockFirstFeedResponse(Flux<FeedResponse<T>> feedResponseFlux) {\n+        try {\n+            return feedResponseFlux.blockFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg2NzgzOQ==", "bodyText": "At other places, I noticed we are also checking notNull for classType, any specific reason we are not doing it here ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562867839", "createdAt": "2021-01-22T19:45:00Z", "author": {"login": "kushagraThapar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -338,6 +359,33 @@ private TransactionalBatchResponse blockBatchResponse(Mono<TransactionalBatchRes\n         return getCosmosPagedIterable(this.asyncContainer.queryItems(querySpec, options, classType));\n     }\n \n+    /**\n+     * Query for items in the change feed of the current container using the {@link CosmosChangeFeedRequestOptions}.\n+     * <p>\n+     * The next page can be retrieved by calling queryChangeFeed again with a new instance of\n+     * {@link CosmosChangeFeedRequestOptions} created from the continuation token of the previously returned\n+     * {@link FeedResponse} instance.\n+     *\n+     * @param <T> the type parameter.\n+     * @param options the change feed request options.\n+     * @param classType the class type.\n+     * @return a {@link CosmosPagedFlux} containing one feed response page\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public <T> CosmosPagedIterable<T> queryChangeFeed(\n+        CosmosChangeFeedRequestOptions options,\n+        Class<T> classType) {\n+\n+        checkNotNull(options, \"Argument 'options' must not be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0NDg3NDI3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-574487427", "createdAt": "2021-01-22T17:54:38Z", "commit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "state": "APPROVED", "comments": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzo1NDozOFrOIYu1ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQyMjowMDoxNlrOIY3BVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNDA5MQ==", "bodyText": "why maxItemCount can't be primitive?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562804091", "createdAt": "2021-01-22T17:54:38Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,380 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final Integer DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private Integer maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(Integer maxItemCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNDI1OQ==", "bodyText": "why return value can't be primitive?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562804259", "createdAt": "2021-01-22T17:54:56Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,380 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final Integer DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private Integer maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(Integer maxItemCount) {\n+        this.maxItemCount = maxItemCount != null ? maxItemCount : DEFAULT_MAX_ITEM_COUNT;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxPrefetchPageCount() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNTE5Nw==", "bodyText": "any reason maxPrefetchPageCount can't be primitive?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562805197", "createdAt": "2021-01-22T17:56:22Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,380 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final Integer DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private Integer maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(Integer maxItemCount) {\n+        this.maxItemCount = maxItemCount != null ? maxItemCount : DEFAULT_MAX_ITEM_COUNT;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxPrefetchPageCount() {\n+        return this.maxPrefetchPageCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @param maxPrefetchPageCount the max number of pages that will be prefetched from the backend\n+     *                             asynchronously in the background\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxPrefetchPageCount(Integer maxPrefetchPageCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNTY2MQ==", "bodyText": "nit: please remove the empty line.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562805661", "createdAt": "2021-01-22T17:57:10Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,380 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final Integer DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private Integer maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxMTA3OA==", "bodyText": "is this high timeout value needed? do you see test timeout?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562811078", "createdAt": "2021-01-22T18:05:00Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ChangeFeedTest.java", "diffHunk": "@@ -24,24 +32,29 @@\n import org.testng.annotations.AfterMethod;\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Ignore;\n import org.testng.annotations.Test;\n+import org.testng.xml.dom.Tag;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n \n import java.lang.reflect.Method;\n+import java.time.Duration;\n import java.time.Instant;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.UUID;\n+import java.util.stream.Collectors;\n \n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n import static org.assertj.core.api.Assertions.assertThat;\n \n //TODO: change to use external TestSuiteBase\n public class ChangeFeedTest extends TestSuiteBase {\n \n     private static final int SETUP_TIMEOUT = 40000;\n-    private static final int TIMEOUT = 30000;\n+    private static final int TIMEOUT = 30000000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxODY4MQ==", "bodyText": "nit: any apis in the java interface by default is public. hence you don't need to add explicit public.\nIntellj suggests dropping public from methods introduced in interface.\nplease see this:\nhttps://stackoverflow.com/questions/161633/should-methods-in-a-java-interface-be-declared-with-or-without-a-public-access-m\nsame for the other methods in the interface.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562818681", "createdAt": "2021-01-22T18:14:20Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/FeedRange.java", "diffHunk": "@@ -16,9 +18,38 @@\n      * @param json A string representation of a feed range\n      * @return A feed range\n      */\n-    public static FeedRange fromJsonString(String json) {\n-        return FeedRangeInternal.fromJsonString(json);\n+    @Beta(value = Beta.SinceVersion.V4_9_0, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static FeedRange fromString(String json) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgyMTU4NA==", "bodyText": "should we have an error case when pkRangeHolder.v == null?\nMono<List<String>> getPartitionKeyRanges() is expected to always return a Mono of List of size 1.\nis there any scenario where here pkRangeHolder.v == null can be and needs validation?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562821584", "createdAt": "2021-01-22T18:19:32Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyImpl.java", "diffHunk": "@@ -30,112 +37,152 @@ public PartitionKeyInternal getPartitionKeyInternal() {\n     }\n \n     @Override\n-    public void accept(FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyImpl that = (FeedRangePartitionKeyImpl)o;\n+        return Objects.equals(this.partitionKey, that.partitionKey);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKey);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n+    public Mono<Range<String>> getEffectiveRange(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n \n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        Range<String> range = Range.getPointRange(effectivePartitionKey);\n-        ArrayList<Range<String>> rangeList = new ArrayList<>();\n-        rangeList.add(range);\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n \n-        return Mono.just((UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(rangeList));\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n+\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                Range<String> range = Range.getPointRange(effectivePartitionKey);\n+                return Mono.just(range);\n+            });\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n+    public Mono<List<String>> getPartitionKeyRanges(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                Range.getPointRange(effectivePartitionKey),\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    String rangeId = pkRangeHolder.v.get(0).getId();\n-                    rangeList.add(rangeId);\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        Range.getPointRange(effectivePartitionKey),\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        ArrayList<String> rangeList = new ArrayList<>(1);\n+\n+                        if (pkRangeHolder.v != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgyMzk2OA==", "bodyText": "I see that ChangeFeedState and FeedRangeInternal are extending JsonSerializable.\nJsonSerializable is not thread-safe. just wondering the way we are passing ChangeFeedState and FeedRangeInternal are we ensuring thread safety in the code which handles them?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562823968", "createdAt": "2021-01-22T18:23:52Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -39,112 +43,141 @@ public PartitionKeyRangeIdentity getPartitionKeyRangeIdentity() {\n     }\n \n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyRangeImpl that = (FeedRangePartitionKeyRangeImpl)o;\n+        return Objects.equals(this.partitionKeyRangeId, that.partitionKeyRangeId);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKeyRangeId);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        final Mono<ValueHolder<PartitionKeyRange>> getPkRangeTask = routingMapProvider\n-            .tryGetPartitionKeyRangeByIdAsync(\n-                null,\n-                containerRid,\n-                partitionKeyRangeId,\n-                false,\n-                null)\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n-                        null,\n-                        containerRid,\n-                        partitionKeyRangeId,\n-                        true,\n-                        null);\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n-            })\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return Mono.error(\n-                        new PartitionKeyRangeGoneException(\n-                            String.format(\n-                                \"The PartitionKeyRangeId: \\\"%s\\\" is not valid for the current \" +\n-                                    \"container %s .\",\n+\n+                return routingMapProvider\n+                    .tryGetPartitionKeyRangeByIdAsync(\n+                        metadataDiagnosticsCtx,\n+                        collection.getResourceId(),\n+                        this.partitionKeyRangeId,\n+                        false,\n+                        null)\n+                    .flatMap((pkRangeHolder) -> {\n+                        if (pkRangeHolder.v == null) {\n+                            return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n+                                null,\n+                                collection.getResourceId(),\n                                 partitionKeyRangeId,\n-                                containerRid)\n-                        ));\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n-                }\n+                                true,\n+                                null);\n+                        } else {\n+                            return Mono.just(pkRangeHolder);\n+                        }\n+                    })\n+                    .flatMap((pkRangeHolder) -> {\n+                        if (pkRangeHolder.v == null) {\n+                            return Mono.error(\n+                                new PartitionKeyRangeGoneException(\n+                                    String.format(\n+                                        \"The PartitionKeyRangeId: \\\"%s\\\" is not valid for the \" +\n+                                            \"current \" +\n+                                            \"container %s .\",\n+                                        partitionKeyRangeId,\n+                                        collection.getResourceId())\n+                                ));\n+                        } else {\n+                            return Mono.just(pkRangeHolder.v.toRange());\n+                        }\n+                    });\n             });\n-\n-        return getPkRangeTask.flatMap((pkRangeHolder) -> {\n-            final ArrayList<Range<String>> temp = new ArrayList<>();\n-            if (pkRangeHolder != null) {\n-                temp.add(pkRangeHolder.v.toRange());\n-            }\n-\n-            return Mono.just((UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp));\n-        });\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n         final ArrayList<String> temp = new ArrayList<>();\n         temp.add(this.partitionKeyRangeId);\n \n         return Mono.just(\n-            (UnmodifiableList<String>)UnmodifiableList.unmodifiableList(temp));\n+            UnmodifiableList.unmodifiableList(temp));\n     }\n \n-    public void populatePropertyBag() {\n-        super.populatePropertyBag();\n+    @Override\n+    public Mono<RxDocumentServiceRequest> populateFeedRangeFilteringHeaders(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        if (this.partitionKeyRangeId != null) {\n-            setProperty(\n-                this,\n-                Constants.Properties.FEED_RANGE_PARTITION_KEY_RANGE_ID,\n-                this.partitionKeyRangeId);\n-        }\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+\n+        request.routeTo(this.partitionKeyRangeIdentity);\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return this\n+            .getEffectiveRange(routingMapProvider, metadataDiagnosticsCtx, collectionResolutionMono)\n+            .map(effectiveRange -> {\n+                request.setEffectiveRange(effectiveRange);\n+\n+                return request;\n+            });\n     }\n \n     @Override\n-    public String toString() {\n-        return this.partitionKeyRangeId;\n+    public void populatePropertyBag() {\n+        super.populatePropertyBag();\n+        setProperties(this, false);\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        FeedRangePartitionKeyRangeImpl that = (FeedRangePartitionKeyRangeImpl) o;\n-        return Objects.equals(this.partitionKeyRangeId, that.partitionKeyRangeId);\n+    public void removeProperties(JsonSerializable serializable) {\n+        checkNotNull(serializable, \"Argument 'serializable' must not be null.\");\n+        serializable.remove(Constants.Properties.FEED_RANGE_PARTITION_KEY_RANGE_ID);\n     }\n \n     @Override\n-    public int hashCode() {\n-        return Objects.hash(partitionKeyRangeId);\n+    public void setProperties(JsonSerializable serializable, boolean populateProperties) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgyNTQ2MA==", "bodyText": "we are not passing diagnostics context here. is this intentional?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562825460", "createdAt": "2021-01-22T18:26:23Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -39,112 +43,141 @@ public PartitionKeyRangeIdentity getPartitionKeyRangeIdentity() {\n     }\n \n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyRangeImpl that = (FeedRangePartitionKeyRangeImpl)o;\n+        return Objects.equals(this.partitionKeyRangeId, that.partitionKeyRangeId);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKeyRangeId);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        final Mono<ValueHolder<PartitionKeyRange>> getPkRangeTask = routingMapProvider\n-            .tryGetPartitionKeyRangeByIdAsync(\n-                null,\n-                containerRid,\n-                partitionKeyRangeId,\n-                false,\n-                null)\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n-                        null,\n-                        containerRid,\n-                        partitionKeyRangeId,\n-                        true,\n-                        null);\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n-            })\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return Mono.error(\n-                        new PartitionKeyRangeGoneException(\n-                            String.format(\n-                                \"The PartitionKeyRangeId: \\\"%s\\\" is not valid for the current \" +\n-                                    \"container %s .\",\n+\n+                return routingMapProvider\n+                    .tryGetPartitionKeyRangeByIdAsync(\n+                        metadataDiagnosticsCtx,\n+                        collection.getResourceId(),\n+                        this.partitionKeyRangeId,\n+                        false,\n+                        null)\n+                    .flatMap((pkRangeHolder) -> {\n+                        if (pkRangeHolder.v == null) {\n+                            return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n+                                null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgyNjU1NQ==", "bodyText": "true why do we need to do a force refresh here?\nPartitionKeyRangeGoneException should be handled by GoneAndRetryPolicy. can't we rely on the retry-policy for this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562826555", "createdAt": "2021-01-22T18:28:14Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -39,112 +43,141 @@ public PartitionKeyRangeIdentity getPartitionKeyRangeIdentity() {\n     }\n \n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyRangeImpl that = (FeedRangePartitionKeyRangeImpl)o;\n+        return Objects.equals(this.partitionKeyRangeId, that.partitionKeyRangeId);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKeyRangeId);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        final Mono<ValueHolder<PartitionKeyRange>> getPkRangeTask = routingMapProvider\n-            .tryGetPartitionKeyRangeByIdAsync(\n-                null,\n-                containerRid,\n-                partitionKeyRangeId,\n-                false,\n-                null)\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n-                        null,\n-                        containerRid,\n-                        partitionKeyRangeId,\n-                        true,\n-                        null);\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n-            })\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return Mono.error(\n-                        new PartitionKeyRangeGoneException(\n-                            String.format(\n-                                \"The PartitionKeyRangeId: \\\"%s\\\" is not valid for the current \" +\n-                                    \"container %s .\",\n+\n+                return routingMapProvider\n+                    .tryGetPartitionKeyRangeByIdAsync(\n+                        metadataDiagnosticsCtx,\n+                        collection.getResourceId(),\n+                        this.partitionKeyRangeId,\n+                        false,\n+                        null)\n+                    .flatMap((pkRangeHolder) -> {\n+                        if (pkRangeHolder.v == null) {\n+                            return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n+                                null,\n+                                collection.getResourceId(),\n                                 partitionKeyRangeId,\n-                                containerRid)\n-                        ));\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n-                }\n+                                true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzMDI0Mw==", "bodyText": "this serializes the FeedRange to String and then we deserialize.\nas future optimization,\nAs there are only a few types extending FeedRange, I wonder if we can avoid the intermediate string serialization step and directly translate FeedRange to FeedRangeInternal. is that possible?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562830243", "createdAt": "2021-01-22T18:35:05Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeInternal.java", "diffHunk": "@@ -3,52 +3,54 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n-import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n import com.azure.cosmos.implementation.Utils;\n-import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n-import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.FeedRange;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n-import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import reactor.core.publisher.Mono;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.List;\n \n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n+@JsonDeserialize(using = FeedRangeInternalDeserializer.class)\n public abstract class FeedRangeInternal extends JsonSerializable implements FeedRange {\n     private final static Logger LOGGER = LoggerFactory.getLogger(FeedRangeInternal.class);\n \n-    public abstract void accept(FeedRangeVisitor visitor);\n-\n-    public abstract <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input);\n-\n-    public abstract <T> Mono<T> accept(FeedRangeAsyncVisitor<T> visitor);\n-\n     public static FeedRangeInternal convert(final FeedRange feedRange) {\n         checkNotNull(feedRange, \"Argument 'feedRange' must not be null\");\n         if (feedRange instanceof FeedRangeInternal) {\n             return (FeedRangeInternal)feedRange;\n         }\n \n-        String json = feedRange.toJsonString();\n-        return fromJsonString(json);\n+        String json = feedRange.toString();\n+        return fromBase64EncodedJsonString(json);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzMjcwNQ==", "bodyText": "can this happen on the happy path? if parsing the string fails, shouldn't we throw and log error?\nin which scenario we reach here?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562832705", "createdAt": "2021-01-22T18:39:31Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuation.java", "diffHunk": "@@ -34,25 +51,75 @@ public FeedRangeInternal getFeedRange() {\n         return this.feedRange;\n     }\n \n-    public abstract String getContinuation();\n+    public abstract CompositeContinuationToken getCurrentContinuationToken();\n \n     public abstract void replaceContinuation(String continuationToken);\n \n     public abstract boolean isDone();\n \n     public abstract void validateContainer(String containerRid);\n \n-    /* TODO fabianm - infinite recursion\n-    public static FeedRangeContinuation tryParse(String toStringValue) {\n-        return FeedRangeCompositeContinuationImpl.tryParse(toStringValue);\n-    }*/\n+    public void populatePropertyBag() {\n+        super.populatePropertyBag();\n+    }\n+\n+    private static FeedRangeContinuation tryParse(String jsonString) {\n+        if (jsonString == null) {\n+            return null;\n+        }\n+\n+        try\n+        {\n+            return FeedRangeCompositeContinuationImpl.parse(jsonString);\n+        }\n+        catch (final IOException ioError) {\n+            LOGGER.debug(\n+                \"Failed to parse feed range continuation JSON {}\",\n+                jsonString,\n+                ioError);\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNDIxMQ==", "bodyText": "nit: java style for '{' on the same line as try", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562834211", "createdAt": "2021-01-22T18:42:18Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuation.java", "diffHunk": "@@ -34,25 +51,75 @@ public FeedRangeInternal getFeedRange() {\n         return this.feedRange;\n     }\n \n-    public abstract String getContinuation();\n+    public abstract CompositeContinuationToken getCurrentContinuationToken();\n \n     public abstract void replaceContinuation(String continuationToken);\n \n     public abstract boolean isDone();\n \n     public abstract void validateContainer(String containerRid);\n \n-    /* TODO fabianm - infinite recursion\n-    public static FeedRangeContinuation tryParse(String toStringValue) {\n-        return FeedRangeCompositeContinuationImpl.tryParse(toStringValue);\n-    }*/\n+    public void populatePropertyBag() {\n+        super.populatePropertyBag();\n+    }\n+\n+    private static FeedRangeContinuation tryParse(String jsonString) {\n+        if (jsonString == null) {\n+            return null;\n+        }\n+\n+        try\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNTE0NQ==", "bodyText": "please fix header format to be consistent with other files:\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562835145", "createdAt": "2021-01-22T18:44:04Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosContainerChangeFeedTest.java", "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNjEzOA==", "bodyText": "we have TestSuiteBase.safeDeleteCollection which does something similar.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562836138", "createdAt": "2021-01-22T18:45:52Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosContainerTest.java", "diffHunk": "@@ -53,12 +60,31 @@ public void afterClass() {\n         safeCloseSyncClient(client);\n     }\n \n+    @BeforeMethod(groups = { \"emulator\" })\n+    public void beforeTest() throws Exception {\n+        this.createdContainer = null;\n+    }\n+\n+    @AfterMethod(groups = { \"emulator\" })\n+    public void afterTest() throws Exception {\n+        if (this.createdContainer != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNzQ0Ng==", "bodyText": "safeDeleteCollection(createdContainer) ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562837446", "createdAt": "2021-01-22T18:48:05Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosContainerChangeFeedTest.java", "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ *\n+ */\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeEpkImpl;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.guava25.collect.ArrayListMultimap;\n+import com.azure.cosmos.implementation.guava25.collect.Multimap;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.ChangeFeedPolicy;\n+import com.azure.cosmos.models.CosmosChangeFeedRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosContainerResponse;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.FeedRange;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertThrows;\n+\n+public class CosmosContainerChangeFeedTest extends TestSuiteBase {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private static final String PARTITION_KEY_FIELD_NAME = \"mypk\";\n+    private CosmosClient client;\n+    private CosmosAsyncContainer createdAsyncContainer;\n+    private CosmosAsyncDatabase createdAsyncDatabase;\n+    private CosmosContainer createdContainer;\n+    private CosmosDatabase createdDatabase;\n+    private final Multimap<String, ObjectNode> partitionKeyToDocuments = ArrayListMultimap.create();\n+    private final String preExistingDatabaseId = CosmosDatabaseForTest.generateId();\n+\n+    @Factory(dataProvider = \"clientBuilders\")\n+    public CosmosContainerChangeFeedTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @AfterClass(groups = { \"emulator\" }, timeOut = 3 * SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        logger.info(\"starting ....\");\n+        safeDeleteSyncDatabase(createdDatabase);\n+        safeCloseSyncClient(client);\n+    }\n+\n+    @AfterMethod(groups = { \"emulator\" })\n+    public void afterTest() throws Exception {\n+        if (this.createdContainer != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg0MTM0Mw==", "bodyText": "I think in FeedRange tests the number of partitions the container contains is important.\nIf you run the tests against emulator, based on the emulator configuration we may get different number of partitions.\nThere are some configs of emulator which always will result in a cosmos-container to be created with only one single partition regardless of the RU throughput you assign when creating the cosmos-container.\nPlease verify the emulator config. also it is worth for future proofing if you have a validation on the minimum number of partitions expected for this test to be meaningful.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562841343", "createdAt": "2021-01-22T18:55:19Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosContainerChangeFeedTest.java", "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ *\n+ */\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeEpkImpl;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.guava25.collect.ArrayListMultimap;\n+import com.azure.cosmos.implementation.guava25.collect.Multimap;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.ChangeFeedPolicy;\n+import com.azure.cosmos.models.CosmosChangeFeedRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosContainerResponse;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.FeedRange;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertThrows;\n+\n+public class CosmosContainerChangeFeedTest extends TestSuiteBase {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private static final String PARTITION_KEY_FIELD_NAME = \"mypk\";\n+    private CosmosClient client;\n+    private CosmosAsyncContainer createdAsyncContainer;\n+    private CosmosAsyncDatabase createdAsyncDatabase;\n+    private CosmosContainer createdContainer;\n+    private CosmosDatabase createdDatabase;\n+    private final Multimap<String, ObjectNode> partitionKeyToDocuments = ArrayListMultimap.create();\n+    private final String preExistingDatabaseId = CosmosDatabaseForTest.generateId();\n+\n+    @Factory(dataProvider = \"clientBuilders\")\n+    public CosmosContainerChangeFeedTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @AfterClass(groups = { \"emulator\" }, timeOut = 3 * SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        logger.info(\"starting ....\");\n+        safeDeleteSyncDatabase(createdDatabase);\n+        safeCloseSyncClient(client);\n+    }\n+\n+    @AfterMethod(groups = { \"emulator\" })\n+    public void afterTest() throws Exception {\n+        if (this.createdContainer != null) {\n+            try {\n+                this.createdContainer.delete();\n+            } catch (CosmosException error) {\n+                if (error.getStatusCode() != 404) {\n+                    throw error;\n+                }\n+            }\n+        }\n+    }\n+\n+    @BeforeMethod(groups = { \"emulator\" })\n+    public void beforeTest() throws Exception {\n+        this.createdContainer = null;\n+        this.createdAsyncContainer = null;\n+        this.partitionKeyToDocuments.clear();\n+    }\n+\n+    @BeforeClass(groups = { \"emulator\" }, timeOut = SETUP_TIMEOUT)\n+    public void before_CosmosContainerTest() {\n+        client = getClientBuilder().buildClient();\n+        createdDatabase = createSyncDatabase(client, preExistingDatabaseId);\n+        createdAsyncDatabase = client.asyncClient().getDatabase(createdDatabase.getId());\n+    }\n+\n+    @Test(groups = { \"emulator\" }, timeOut = TIMEOUT * 5)\n+    public void asyncChangeFeed_fromBeginning_incremental_forFullRange() throws Exception {\n+        this.createContainer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg0Mzg3NQ==", "bodyText": "stale documentation.\n8 -> Duration.ofMinutes(8)", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562843875", "createdAt": "2021-01-22T18:59:36Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ChangeFeedPolicy.java", "diffHunk": "@@ -0,0 +1,195 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+import java.time.Duration;\n+\n+/**\n+ * Represents the change feed policy configuration for the container in the Azure Cosmos DB service.\n+ *\n+ * <p>\n+ * The example below creates a new container with a change feed policy for full fidelity change feed with a\n+ * retention window of 8 minutes - so intermediary snapshots of changes as well as deleted documents would be\n+ * available for processing for 8 minutes before they vanish. Processing the change feed with full fidelity mode will\n+ * only be able within this retention window - if you attempt to process a change feed after more\n+ * than the retention window (8 minutes in this sample) an error (Status Code 400) will be returned. It would\n+ * still be possible to process changes using Incremental mode even when configuring a full fidelity change\n+ * feed policy with retention window on the container and when using Incremental mode it doesn't matter whether\n+ * your are out of the retention window or not.\n+ *\n+ * <pre>{@code\n+ *\n+ * CosmosContainerProperties containerProperties =\n+ *      new CosmosContainerProperties(\"ContainerName\", \"/somePartitionKeyProperty\");\n+ * containerProperties.setChangeFeedPolicy(ChangeFeedPolicy.createFullFidelityPolicy(8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1MDY0Mg==", "bodyText": "majority of Query components, top, orderby, etc need to use false, false param.\nI think it might be easier to fork this method into two new methods one for query and the other for changefeed.\ncustomization helps to reduce the number of params.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562850642", "createdAt": "2021-01-22T19:12:12Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -147,11 +147,21 @@ public static StoredProcedureResponse toStoredProcedureResponse(RxDocumentServic\n     }\n \n     @Warning(value = INTERNAL_USE_ONLY_WARNING)\n-    public static <T> FeedResponse<T> createFeedResponseWithQueryMetrics(List<T> results,\n-                                                                         Map<String, String> headers,\n-                                                                         ConcurrentMap<String, QueryMetrics> queryMetricsMap,\n-                                                                         QueryInfo.QueryPlanDiagnosticsContext diagnosticsContext) {\n-        return ModelBridgeInternal.createFeedResponseWithQueryMetrics(results, headers, queryMetricsMap, diagnosticsContext);\n+    public static <T> FeedResponse<T> createFeedResponseWithQueryMetrics(\n+        List<T> results,\n+        Map<String, String> headers,\n+        ConcurrentMap<String, QueryMetrics> queryMetricsMap,\n+        QueryInfo.QueryPlanDiagnosticsContext diagnosticsContext,\n+        boolean useEtagAsContinuation,\n+        boolean isNoChangesResponse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1MTAwMg==", "bodyText": "majority of Query components, top, orderby, etc need to use false, false param for BridgeInternal.createFeedResponseWithQueryMetrics\nI think it might be easier to fork createFeedResponseWithQueryMetrics method into two new methods one for query and the other for changefeed.\ncustomization helps to reduce the number of params.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562851002", "createdAt": "2021-01-22T19:12:58Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/TopDocumentQueryExecutionContext.java", "diffHunk": "@@ -112,7 +112,9 @@ public boolean test(FeedResponse<T> frp) {\n                     return BridgeInternal.createFeedResponseWithQueryMetrics(t.getResults(),\n                         headers,\n                         BridgeInternal.queryMetricsFromFeedResponse(t),\n-                        ModelBridgeInternal.getQueryPlanDiagnosticsContext(t));\n+                        ModelBridgeInternal.getQueryPlanDiagnosticsContext(t),\n+                        false,\n+                        false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1MTk5Nw==", "bodyText": "majority of Query components, top, orderby, etc need to use false, false param for BridgeInternal.createFeedResponseWithQueryMetrics\nI think it might be easier to fork createFeedResponseWithQueryMetrics method into two new methods one for query and the other for changefeed.\ncustomization helps to reduce the number of params.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562851997", "createdAt": "2021-01-22T19:15:08Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/GroupByDocumentQueryExecutionContext.java", "diffHunk": "@@ -122,7 +122,13 @@\n         if (this.groupingTable != null) {\n             HashMap<String, String> headers = new HashMap<>();\n             headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double.toString(requestCharge));\n-            FeedResponse<Document> frp = BridgeInternal.createFeedResponseWithQueryMetrics(groupByResults, headers, queryMetrics, null);\n+            FeedResponse<Document> frp = BridgeInternal.createFeedResponseWithQueryMetrics(\n+                groupByResults,\n+                headers,\n+                queryMetrics,\n+                null,\n+                false,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1NDk3Nw==", "bodyText": "majority of Query components, top, orderby, etc need to use false, false param for ModelBridgeInternal.createFeedResponseWithQueryMetrics\nI think it might be easier to fork createFeedResponseWithQueryMetrics method into two new methods one for query and the other for changefeed.\ncustomization helps to reduce the number of params.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562854977", "createdAt": "2021-01-22T19:20:16Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ModelBridgeInternal.java", "diffHunk": "@@ -348,12 +351,21 @@ public static CosmosQueryRequestOptions partitionKeyRangeIdInternal(CosmosQueryR\n     }\n \n     @Warning(value = INTERNAL_USE_ONLY_WARNING)\n-    public static <T> FeedResponse<T> createFeedResponseWithQueryMetrics(List<T> results,\n-                                                                         Map<String,\n-                                                                         String> headers,\n-                                                                         ConcurrentMap<String, QueryMetrics> queryMetricsMap,\n-                                                                         QueryInfo.QueryPlanDiagnosticsContext diagnosticsContext) {\n-        FeedResponse<T> feedResponse = new FeedResponse<>(results, headers, queryMetricsMap);\n+    public static <T> FeedResponse<T> createFeedResponseWithQueryMetrics(\n+        List<T> results,\n+        Map<String,\n+        String> headers,\n+        ConcurrentMap<String, QueryMetrics> queryMetricsMap,\n+        QueryInfo.QueryPlanDiagnosticsContext diagnosticsContext,\n+        boolean useEtagAsContinuation,\n+        boolean isNoChanges) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1NjE4Ng==", "bodyText": "nit: codestyle { on the same line as if", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562856186", "createdAt": "2021-01-22T19:22:31Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorFactoryImpl.java", "diffHunk": "@@ -44,10 +50,37 @@ public PartitionProcessorFactoryImpl(\n             throw new IllegalArgumentException(\"collectionSelfLink\");\n         }\n \n+        if (collectionResourceId == null) {\n+            throw new IllegalArgumentException(\"collectionResourceId\");\n+        }\n+\n         this.documentClient = documentClient;\n         this.changeFeedProcessorOptions = changeFeedProcessorOptions;\n         this.leaseCheckpointer = leaseCheckpointer;\n         this.collectionSelfLink = collectionSelfLink;\n+        this.collectionResourceId = collectionResourceId;\n+    }\n+\n+    private static ChangeFeedStartFromInternal getStartFromSettings(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedProcessorOptions processorOptions) {\n+\n+        if (!Strings.isNullOrWhiteSpace(processorOptions.getStartContinuation()))\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg4OTA3Mg==", "bodyText": "diagnostics is null, please add a TODO to wire diagnostics later after this PR.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562889072", "createdAt": "2021-01-22T20:27:00Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -471,14 +476,94 @@ public String getId() {\n \n                 return getDatabase().getDocClientWrapper()\n                              .queryDocuments(CosmosAsyncContainer.this.getLink(), sqlQuerySpec, cosmosQueryRequestOptions)\n-                             .map(response -> prepareFeedResponse(response, classType));\n+                             .map(response -> prepareFeedResponse(response, false, classType));\n         });\n \n         return pagedFluxOptionsFluxFunction;\n     }\n \n-    private <T> FeedResponse<T> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType) {\n+    /**\n+     * Query for items in the change feed of the current container using the {@link CosmosChangeFeedRequestOptions}.\n+     * <p>\n+     * After subscription the operation will be performed. The {@link Flux} will\n+     * contain one or several feed response of the obtained items. In case of\n+     * failure the {@link CosmosPagedFlux} will error.\n+     *\n+     * @param <T> the type parameter.\n+     * @param options the change feed request options.\n+     * @param classType the class type.\n+     * @return a {@link CosmosPagedFlux} containing one or several feed response pages of the obtained\n+     * items or an error.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public <T> CosmosPagedFlux<T> queryChangeFeed(CosmosChangeFeedRequestOptions options, Class<T> classType) {\n+        checkNotNull(options, \"Argument 'options' must not be null.\");\n+        checkNotNull(classType, \"Argument 'classType' must not be null.\");\n+\n+        return queryChangeFeedInternal(options, classType);\n+    }\n+\n+    <T> CosmosPagedFlux<T> queryChangeFeedInternal(\n+        CosmosChangeFeedRequestOptions cosmosChangeFeedRequestOptions,\n+        Class<T> classType) {\n+\n+        return UtilBridgeInternal.createCosmosPagedFlux(\n+            queryChangeFeedInternalFunc(cosmosChangeFeedRequestOptions, classType));\n+    }\n+\n+    <T> Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> queryChangeFeedInternalFunc(\n+        CosmosChangeFeedRequestOptions cosmosChangeFeedRequestOptions,\n+        Class<T> classType) {\n+\n+        checkNotNull(\n+            cosmosChangeFeedRequestOptions,\n+            \"Argument 'cosmosChangeFeedRequestOptions' must not be null.\");\n+\n+        Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction = (pagedFluxOptions -> {\n+\n+            checkNotNull(\n+                pagedFluxOptions,\n+                \"Argument 'pagedFluxOptions' must not be null.\");\n+\n+            String spanName = this.queryChangeFeedSpanName;\n+            pagedFluxOptions.setTracerAndTelemetryInformation(spanName, database.getId(),\n+                this.getId(), OperationType.ReadFeed, ResourceType.Document, this.getDatabase().getClient());\n+            getEffectiveCosmosChangeFeedRequestOptions(pagedFluxOptions, cosmosChangeFeedRequestOptions);\n+\n+            final AsyncDocumentClient clientWrapper = this.database.getDocClientWrapper();\n+            return clientWrapper\n+                .getCollectionCache()\n+                .resolveByNameAsync(\n+                    null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkxNzI5Mw==", "bodyText": "nit: java code style { on the same line as if", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562917293", "createdAt": "2021-01-22T21:20:32Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedStartFromPointInTimeImpl.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n+\n+import java.time.Instant;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+class ChangeFeedStartFromPointInTimeImpl extends ChangeFeedStartFromInternal {\n+    private final Instant pointInTime;\n+\n+    public ChangeFeedStartFromPointInTimeImpl(Instant pointInTime) {\n+        super();\n+\n+        if (pointInTime == null) {\n+            throw new NullPointerException(\"pointInTime\");\n+        }\n+\n+        this.pointInTime = pointInTime;\n+    }\n+\n+    public Instant getPointInTime() {\n+        return this.pointInTime;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof ChangeFeedStartFromPointInTimeImpl)) {\n+            return false;\n+        }\n+\n+        ChangeFeedStartFromPointInTimeImpl otherStartFrom = (ChangeFeedStartFromPointInTimeImpl)obj;\n+        return this.pointInTime.equals(otherStartFrom.pointInTime);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return this.pointInTime.hashCode();\n+    }\n+\n+    @Override\n+    public void populatePropertyBag() {\n+\n+        super.populatePropertyBag();\n+\n+        setProperty(\n+            this,\n+            com.azure.cosmos.implementation.Constants.Properties.CHANGE_FEED_START_FROM_TYPE,\n+            ChangeFeedStartFromTypes.POINT_IN_TIME);\n+\n+        setProperty(\n+            this,\n+            Constants.Properties.CHANGE_FEED_START_FROM_POINT_IN_TIME_MS,\n+            this.pointInTime.toEpochMilli());\n+    }\n+\n+    @Override\n+    public void populateRequest(RxDocumentServiceRequest request) {\n+        checkNotNull(request, \"Argument 'request' must not be null.\");\n+\n+        // Our current public contract for ChangeFeedProcessor uses DateTime.MinValue.ToUniversalTime as beginning.\n+        // We need to add a special case here, otherwise it would send it as normal StartTime.\n+        // The problem is Multi master accounts do not support StartTime header on ReadFeed, and thus,\n+        // it would break multi master Change Feed Processor users using Start From Beginning semantics.\n+        // It's also an optimization, since the backend won't have to binary search for the value.\n+        Instant pointInTime = this.getPointInTime();\n+        if (pointInTime != START_FROM_BEGINNING_TIME)\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkyNTYwNA==", "bodyText": "great documentation for the cases. thanks.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562925604", "createdAt": "2021-01-22T21:31:39Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeEpkImpl.java", "diffHunk": "@@ -3,125 +3,250 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n+import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.HttpConstants;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.NotFoundException;\n import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ReadFeedKeyType;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n import com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.ModelBridgeInternal;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n import static com.azure.cosmos.BridgeInternal.setProperty;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n-final class FeedRangeEpkImpl extends FeedRangeInternal {\n+public final class FeedRangeEpkImpl extends FeedRangeInternal {\n     private static final FeedRangeEpkImpl fullRangeEPK =\n         new FeedRangeEpkImpl(PartitionKeyInternalHelper.FullRange);\n \n     private final Range<String> range;\n-    private final UnmodifiableList<Range<String>> rangeList;\n \n     public FeedRangeEpkImpl(final Range<String> range) {\n         checkNotNull(range, \"Argument 'range' must not be null\");\n         this.range = range;\n-        final ArrayList<Range<String>> temp = new ArrayList<>();\n-        temp.add(range);\n-\n-        this.rangeList = (UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp);\n     }\n \n     public Range<String> getRange() {\n         return this.range;\n     }\n \n-    public static FeedRangeEpkImpl forFullRange() {\n-        return fullRangeEPK;\n-    }\n-\n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangeEpkImpl that = (FeedRangeEpkImpl)o;\n+        return Objects.equals(this.range, that.range);\n     }\n \n     @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public int hashCode() {\n+        return Objects.hash(range);\n     }\n \n-    @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public static FeedRangeEpkImpl forFullRange() {\n+        return fullRangeEPK;\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        return Mono.just(this.rangeList);\n+        return Mono.just(this.range);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                this.range,\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                final ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n-                    for (final PartitionKeyRange pkRange : pkRanges) {\n-                        rangeList.add(pkRange.getId());\n-                    }\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        final ArrayList<String> rangeList = new ArrayList<>();\n+\n+                        if (pkRangeHolder.v != null) {\n+                            final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n+                            for (final PartitionKeyRange pkRange : pkRanges) {\n+                                rangeList.add(pkRange.getId());\n+                            }\n+                        }\n+\n+                        return Mono.just(UnmodifiableList.unmodifiableList(rangeList));\n+                    });\n             });\n     }\n \n     @Override\n-    public String toString() {\n-        return this.range.toString();\n-    }\n+    public Mono<RxDocumentServiceRequest> populateFeedRangeFilteringHeaders(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n \n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        FeedRangeEpkImpl that = (FeedRangeEpkImpl) o;\n-        return Objects.equals(this.range, that.range);\n+                final String containerRid = collection.getResourceId();\n+                request.setEffectiveRange(this.range);\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        if (pkRangeHolder == null) {\n+                            return Mono.error(new NotFoundException(\n+                                String.format(\"Stale cache for collection rid '%s'.\",\n+                                    containerRid)));\n+                        }\n+\n+                        final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n+                        if (pkRanges == null || pkRanges.size() == 0) {\n+                            return Mono.error(new NotFoundException(\n+                                String.format(\"Stale cache for collection rid '%s'.\",\n+                                    containerRid)));\n+                        }\n+\n+                        // For epk range filtering we can end up in one of 3 cases:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkyOTUxNw==", "bodyText": "as we are changing this class. please do a perf test on query to ensure we don't have query perf regression.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562929517", "createdAt": "2021-01-22T21:40:09Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/Fetcher.java", "diffHunk": "@@ -3,42 +3,39 @@\n \n package com.azure.cosmos.implementation.query;\n \n-import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.models.FeedResponse;\n import com.azure.cosmos.implementation.Resource;\n import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n-import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import reactor.core.publisher.Mono;\n \n-import java.util.function.BiFunction;\n import java.util.function.Function;\n \n-class Fetcher<T extends Resource> {\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+abstract class Fetcher<T extends Resource> {\n     private final static Logger logger = LoggerFactory.getLogger(Fetcher.class);\n \n-    private final BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc;\n     private final Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc;\n     private final boolean isChangeFeed;\n \n     private volatile boolean shouldFetchMore;\n     private volatile int maxItemCount;\n     private volatile int top;\n-    private volatile String continuationToken;\n \n-    public Fetcher(BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-                   Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n-                   String continuationToken,\n-                   boolean isChangeFeed,\n-                   int top,\n-                   int maxItemCount) {\n+    public Fetcher(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzMjYxMQ==", "bodyText": "is this a change? what was the previous value prior to this PR?\nas reactive-stream default is Queues.XS_BUFFER_SIZE does that mean prior to this PR we were implicitly using Queues.XS_BUFFER_SIZE as the default prefetch?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562932611", "createdAt": "2021-01-22T21:47:08Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/Paginator.java", "diffHunk": "@@ -48,33 +45,84 @@\n     public static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n             String continuationToken,\n             BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc, Class<T> resourceType,\n-            int top, int maxPageSize) {\n-        return getPaginatedQueryResultAsObservable(continuationToken, createRequestFunc, executeFunc, resourceType,\n-                top, maxPageSize, false);\n+            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+            Class<T> resourceType,\n+            int top,\n+            int maxPageSize) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            continuationToken,\n+            createRequestFunc,\n+            executeFunc,\n+            resourceType,\n+            top,\n+            maxPageSize,\n+            false);\n+    }\n+\n+    public static <T extends Resource> Flux<FeedResponse<T>> getChangeFeedQueryResultAsObservable(\n+        RxDocumentClientImpl client,\n+        ChangeFeedState changeFeedState,\n+        Supplier<RxDocumentServiceRequest> createRequestFunc,\n+        Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+        Class<T> resourceType,\n+        int top,\n+        int maxPageSize,\n+        int preFetchCount) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            () -> new ChangeFeedFetcher<>(\n+                client,\n+                createRequestFunc,\n+                executeFunc,\n+                changeFeedState,\n+                top,\n+                maxPageSize),\n+            preFetchCount);\n     }\n \n     private static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n-            String continuationToken,\n-            BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc, Class<T> resourceType,\n-            int top, int maxPageSize, boolean isChangeFeed) {\n+        Supplier<Fetcher<T>> fetcherFactory,\n+        int preFetchCount) {\n \n         return Flux.defer(() -> {\n-            Flux<Flux<FeedResponse<T>>> generate = Flux.generate(() ->\n-                    new Fetcher<>(createRequestFunc, executeFunc, continuationToken, isChangeFeed, top, maxPageSize),\n-                    (tFetcher, sink) -> {\n-                        if (tFetcher.shouldFetchMore()) {\n-                            Mono<FeedResponse<T>> nextPage = tFetcher.nextPage();\n-                            sink.next(nextPage.flux());\n-                        } else {\n-                            logger.debug(\"No more results\");\n-                            sink.complete();\n-                        }\n-                        return tFetcher;\n-            });\n+            Flux<Flux<FeedResponse<T>>> generate = Flux.generate(\n+                fetcherFactory::get,\n+                (tFetcher, sink) -> {\n+                    if (tFetcher.shouldFetchMore()) {\n+                        Mono<FeedResponse<T>> nextPage = tFetcher.nextPage();\n+                        sink.next(nextPage.flux());\n+                    } else {\n+                        logger.debug(\"No more results\");\n+                        sink.complete();\n+                    }\n+                    return tFetcher;\n+                });\n \n-            return generate.flatMapSequential(feedResponseFlux -> feedResponseFlux, 1);\n+            return generate.flatMapSequential(\n+                feedResponseFlux -> feedResponseFlux,\n+                1,\n+                preFetchCount);\n         });\n     }\n+\n+    private static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n+            String continuationToken,\n+            BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n+            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+            Class<T> resourceType,\n+            int top,\n+            int maxPageSize,\n+            boolean isChangeFeed) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            () -> new ServerSideOnlyContinuationFetcherImpl<>(\n+                createRequestFunc,\n+                executeFunc,\n+                continuationToken,\n+                isChangeFeed,\n+                top,\n+                maxPageSize),\n+                Queues.XS_BUFFER_SIZE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzMzg0Ng==", "bodyText": "we have guards in BackPressureCrossPartitionTest for query  to ensure not more than certain number of pages will be pre-fetched.\nPlease add similar tests for change feed query there.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562933846", "createdAt": "2021-01-22T21:50:05Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/Paginator.java", "diffHunk": "@@ -48,33 +45,84 @@\n     public static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n             String continuationToken,\n             BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc, Class<T> resourceType,\n-            int top, int maxPageSize) {\n-        return getPaginatedQueryResultAsObservable(continuationToken, createRequestFunc, executeFunc, resourceType,\n-                top, maxPageSize, false);\n+            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+            Class<T> resourceType,\n+            int top,\n+            int maxPageSize) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            continuationToken,\n+            createRequestFunc,\n+            executeFunc,\n+            resourceType,\n+            top,\n+            maxPageSize,\n+            false);\n+    }\n+\n+    public static <T extends Resource> Flux<FeedResponse<T>> getChangeFeedQueryResultAsObservable(\n+        RxDocumentClientImpl client,\n+        ChangeFeedState changeFeedState,\n+        Supplier<RxDocumentServiceRequest> createRequestFunc,\n+        Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+        Class<T> resourceType,\n+        int top,\n+        int maxPageSize,\n+        int preFetchCount) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            () -> new ChangeFeedFetcher<>(\n+                client,\n+                createRequestFunc,\n+                executeFunc,\n+                changeFeedState,\n+                top,\n+                maxPageSize),\n+            preFetchCount);\n     }\n \n     private static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n-            String continuationToken,\n-            BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc, Class<T> resourceType,\n-            int top, int maxPageSize, boolean isChangeFeed) {\n+        Supplier<Fetcher<T>> fetcherFactory,\n+        int preFetchCount) {\n \n         return Flux.defer(() -> {\n-            Flux<Flux<FeedResponse<T>>> generate = Flux.generate(() ->\n-                    new Fetcher<>(createRequestFunc, executeFunc, continuationToken, isChangeFeed, top, maxPageSize),\n-                    (tFetcher, sink) -> {\n-                        if (tFetcher.shouldFetchMore()) {\n-                            Mono<FeedResponse<T>> nextPage = tFetcher.nextPage();\n-                            sink.next(nextPage.flux());\n-                        } else {\n-                            logger.debug(\"No more results\");\n-                            sink.complete();\n-                        }\n-                        return tFetcher;\n-            });\n+            Flux<Flux<FeedResponse<T>>> generate = Flux.generate(\n+                fetcherFactory::get,\n+                (tFetcher, sink) -> {\n+                    if (tFetcher.shouldFetchMore()) {\n+                        Mono<FeedResponse<T>> nextPage = tFetcher.nextPage();\n+                        sink.next(nextPage.flux());\n+                    } else {\n+                        logger.debug(\"No more results\");\n+                        sink.complete();\n+                    }\n+                    return tFetcher;\n+                });\n \n-            return generate.flatMapSequential(feedResponseFlux -> feedResponseFlux, 1);\n+            return generate.flatMapSequential(\n+                feedResponseFlux -> feedResponseFlux,\n+                1,\n+                preFetchCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzNDU2MA==", "bodyText": "nit: java code style.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562934560", "createdAt": "2021-01-22T21:51:56Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/ChangeFeedFetcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.query;\n+\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ObservableHelper;\n+import com.azure.cosmos.implementation.Resource;\n+import com.azure.cosmos.implementation.RetryPolicyWithDiagnostics;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.ShouldRetryResult;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+class ChangeFeedFetcher<T extends Resource> extends Fetcher<T> {\n+    private final ChangeFeedState changeFeedState;\n+    private final Supplier<RxDocumentServiceRequest> createRequestFunc;\n+    private final IRetryPolicy feedRangeContinuationSplitRetryPolicy;\n+\n+    public ChangeFeedFetcher(\n+        RxDocumentClientImpl client,\n+        Supplier<RxDocumentServiceRequest> createRequestFunc,\n+        Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+        ChangeFeedState changeFeedState,\n+        int top,\n+        int maxItemCount) {\n+\n+        super(executeFunc, true, top, maxItemCount);\n+\n+        checkNotNull(client, \"Argument 'client' must not be null.\");\n+        checkNotNull(createRequestFunc, \"Argument 'createRequestFunc' must not be null.\");\n+        checkNotNull(changeFeedState, \"Argument 'changeFeedState' must not be null.\");\n+        this.createRequestFunc = createRequestFunc;\n+        this.changeFeedState = changeFeedState;\n+        this.feedRangeContinuationSplitRetryPolicy = new FeedRangeContinuationSplitRetryPolicy(\n+            client,\n+            this.changeFeedState);\n+    }\n+\n+    @Override\n+    public Mono<FeedResponse<T>> nextPage() {\n+        // There are two conditions that require retries\n+        // in the change feed pipeline\n+        // 1) On 410 the FeedRangeContinuation needs to evaluate\n+        //    whether continuations need to be split (in the case that any continuation\n+        //    exists that would span more than one physical partition now\n+        // 2) On 304 a retry is needed if at least one continuation has not been drained yet.\n+        //    This prevents returning a 304 before we received a 304 for all continuations\n+        //\n+        // 410 handling: this is triggered by an exception - using an\n+        //               IRetryPolicy (FeedRangeContinuationSplitRetryPolicy)\n+        // 304 handling: this is not triggered by an exception (304 doesn't result in throwing)\n+        //               so using Reactor's built-in option of repeating the chain on an empty result\n+        //               so nextPageInternal below has the logic to return empty result\n+        //               if not all continuations have been drained yet.\n+        return ObservableHelper.inlineIfPossible(\n+            this::nextPageInternal,\n+            this.feedRangeContinuationSplitRetryPolicy);\n+    }\n+\n+    private Mono<FeedResponse<T>> nextPageInternal() {\n+        return Mono.fromSupplier(this::nextPageCore)\n+                   .flatMap(Function.identity())\n+                   .flatMap((r) -> {\n+                       FeedRangeContinuation continuationSnapshot =\n+                           this.changeFeedState.getContinuation();\n+\n+                       if (continuationSnapshot != null &&\n+                           continuationSnapshot.handleChangeFeedNotModified(r) == ShouldRetryResult.RETRY_NOW) {\n+\n+                           // not all continuations have been drained yet\n+                           // repeat with the next continuation\n+                           this.reenableShouldFetchMoreForRetry();\n+                           return Mono.empty();\n+                       }\n+\n+                       return Mono.just(r);\n+                   })\n+                   .repeatWhenEmpty(o -> o);\n+    }\n+\n+    @Override\n+    protected String applyServerResponseContinuation(\n+        String serverContinuationToken,\n+        RxDocumentServiceRequest request) {\n+\n+        return this.changeFeedState.applyServerResponseContinuation(\n+            serverContinuationToken, request);\n+    }\n+\n+    @Override\n+    protected boolean isFullyDrained(boolean isChangeFeed, FeedResponse<T> response) {\n+        if (ModelBridgeInternal.noChanges(response)) {\n+            return true;\n+        }\n+\n+        FeedRangeContinuation continuation = this.changeFeedState.getContinuation();\n+        return continuation != null && continuation.isDone();\n+    }\n+\n+    @Override\n+    protected String getContinuationForLogging() {\n+        return this.changeFeedState.toJson();\n+    }\n+\n+    @Override\n+    protected RxDocumentServiceRequest createRequest(int maxItemCount) {\n+        RxDocumentServiceRequest request = this.createRequestFunc.get();\n+        this.changeFeedState.populateRequest(request, maxItemCount);\n+        return request;\n+    }\n+\n+    private static final class FeedRangeContinuationSplitRetryPolicy extends RetryPolicyWithDiagnostics {\n+        private final ChangeFeedState state;\n+        private final RxDocumentClientImpl client;\n+\n+        public FeedRangeContinuationSplitRetryPolicy(\n+            RxDocumentClientImpl client,\n+            ChangeFeedState state) {\n+\n+            this.client = client;\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public Mono<ShouldRetryResult> shouldRetry(Exception e) {\n+            if (!(e instanceof GoneException)) {\n+                return Mono.just(ShouldRetryResult.noRetry());\n+            }\n+\n+            if (this.state.getContinuation() == null)\n+            {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzNTM5MA==", "bodyText": "is there any guarantee that repeatWhenEmpty() will not result in infinite loop/retry?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562935390", "createdAt": "2021-01-22T21:53:54Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/ChangeFeedFetcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.query;\n+\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ObservableHelper;\n+import com.azure.cosmos.implementation.Resource;\n+import com.azure.cosmos.implementation.RetryPolicyWithDiagnostics;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.ShouldRetryResult;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+class ChangeFeedFetcher<T extends Resource> extends Fetcher<T> {\n+    private final ChangeFeedState changeFeedState;\n+    private final Supplier<RxDocumentServiceRequest> createRequestFunc;\n+    private final IRetryPolicy feedRangeContinuationSplitRetryPolicy;\n+\n+    public ChangeFeedFetcher(\n+        RxDocumentClientImpl client,\n+        Supplier<RxDocumentServiceRequest> createRequestFunc,\n+        Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+        ChangeFeedState changeFeedState,\n+        int top,\n+        int maxItemCount) {\n+\n+        super(executeFunc, true, top, maxItemCount);\n+\n+        checkNotNull(client, \"Argument 'client' must not be null.\");\n+        checkNotNull(createRequestFunc, \"Argument 'createRequestFunc' must not be null.\");\n+        checkNotNull(changeFeedState, \"Argument 'changeFeedState' must not be null.\");\n+        this.createRequestFunc = createRequestFunc;\n+        this.changeFeedState = changeFeedState;\n+        this.feedRangeContinuationSplitRetryPolicy = new FeedRangeContinuationSplitRetryPolicy(\n+            client,\n+            this.changeFeedState);\n+    }\n+\n+    @Override\n+    public Mono<FeedResponse<T>> nextPage() {\n+        // There are two conditions that require retries\n+        // in the change feed pipeline\n+        // 1) On 410 the FeedRangeContinuation needs to evaluate\n+        //    whether continuations need to be split (in the case that any continuation\n+        //    exists that would span more than one physical partition now\n+        // 2) On 304 a retry is needed if at least one continuation has not been drained yet.\n+        //    This prevents returning a 304 before we received a 304 for all continuations\n+        //\n+        // 410 handling: this is triggered by an exception - using an\n+        //               IRetryPolicy (FeedRangeContinuationSplitRetryPolicy)\n+        // 304 handling: this is not triggered by an exception (304 doesn't result in throwing)\n+        //               so using Reactor's built-in option of repeating the chain on an empty result\n+        //               so nextPageInternal below has the logic to return empty result\n+        //               if not all continuations have been drained yet.\n+        return ObservableHelper.inlineIfPossible(\n+            this::nextPageInternal,\n+            this.feedRangeContinuationSplitRetryPolicy);\n+    }\n+\n+    private Mono<FeedResponse<T>> nextPageInternal() {\n+        return Mono.fromSupplier(this::nextPageCore)\n+                   .flatMap(Function.identity())\n+                   .flatMap((r) -> {\n+                       FeedRangeContinuation continuationSnapshot =\n+                           this.changeFeedState.getContinuation();\n+\n+                       if (continuationSnapshot != null &&\n+                           continuationSnapshot.handleChangeFeedNotModified(r) == ShouldRetryResult.RETRY_NOW) {\n+\n+                           // not all continuations have been drained yet\n+                           // repeat with the next continuation\n+                           this.reenableShouldFetchMoreForRetry();\n+                           return Mono.empty();\n+                       }\n+\n+                       return Mono.just(r);\n+                   })\n+                   .repeatWhenEmpty(o -> o);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzNjc1MA==", "bodyText": "why do we need both of feedRange and effectiveRange? why can't we just rely on feedRange?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562936750", "createdAt": "2021-01-22T21:56:57Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentServiceRequest.java", "diffHunk": "@@ -54,6 +56,9 @@\n     // has the non serialized value of the partition-key\n     private PartitionKeyInternal partitionKeyInternal;\n \n+    private FeedRangeInternal feedRange;\n+    private Range<String> effectiveRange;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzODE5Nw==", "bodyText": "was this unused (dead code)?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562938197", "createdAt": "2021-01-22T22:00:16Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1942,10 +1963,6 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n \n                             });\n \n-                        Set<PartitionKeyRange> partitionKeyRanges = partitionRangeItemKeyMap.keySet();\n-                        List<PartitionKeyRange> ranges = new ArrayList<>();\n-                        ranges.addAll(partitionKeyRanges);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7"}, "originalPosition": 171}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f9ef37d87f5f555cc2c03f3df5cdf91e46a6575", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f9ef37d87f5f555cc2c03f3df5cdf91e46a6575", "committedDate": "2021-01-22T23:51:41Z", "message": "Fixing ChangeFeedProcessor issues Matias found\n\n- Continuation persisted in leases was stored as Base64-encoded josn of ChangeFeedState (vs. just LSN)\n- Split handling was broken because the Change feed pull model is split-proof and doesn't surface GoneException which Change Feed processor relies on for splitting leases."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3724f5f9e6db2e6306b85487781612cb8282a8df", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3724f5f9e6db2e6306b85487781612cb8282a8df", "committedDate": "2021-01-23T00:28:14Z", "message": "Addressing code review comments from Mo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fc3b5e6383792989690f9d3472e941cfb3429ae", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fc3b5e6383792989690f9d3472e941cfb3429ae", "committedDate": "2021-01-23T00:49:38Z", "message": "Fixing SpotBUg issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d55b4c5e45e0cc34108d1f579dc5a8ec8f388c7", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9d55b4c5e45e0cc34108d1f579dc5a8ec8f388c7", "committedDate": "2021-01-23T01:03:09Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0ODg2NTg4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-574886588", "createdAt": "2021-01-24T00:29:03Z", "commit": {"oid": "9d55b4c5e45e0cc34108d1f579dc5a8ec8f388c7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNFQwMDoyOTowM1rOIZIERg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNFQwMDoyOTowM1rOIZIERg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzIxNzQ3OA==", "bodyText": "Good catch! Also can you please add the following check at line 604 (after stopping the changeFeedProcessor:\nint leaseCount = changeFeedProcessor.getCurrentState() .map(List::size).block(); assertThat(leaseCount > 1).as(\"Found %d leases\", leaseCount).isTrue();", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563217478", "createdAt": "2021-01-24T00:29:03Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ChangeFeedProcessorTest.java", "diffHunk": "@@ -508,7 +508,7 @@ public void staledLeaseAcquiring() throws InterruptedException {\n \n     @Test(groups = { \"simple\" }, timeOut = 50 * CHANGE_FEED_PROCESSOR_TIMEOUT)\n     public void readFeedDocumentsAfterSplit() throws InterruptedException {\n-        CosmosAsyncContainer createdFeedCollectionForSplit = createLeaseCollection(FEED_COLLECTION_THROUGHPUT_FOR_SPLIT);\n+        CosmosAsyncContainer createdFeedCollectionForSplit = createFeedCollection(FEED_COLLECTION_THROUGHPUT_FOR_SPLIT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d55b4c5e45e0cc34108d1f579dc5a8ec8f388c7"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9f114cb0a73540c30b6da72ae12302e8c51f0fc", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e9f114cb0a73540c30b6da72ae12302e8c51f0fc", "committedDate": "2021-01-25T10:16:14Z", "message": "Adding additional assert in CFP split test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "committedDate": "2021-01-25T10:16:33Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1NzE5MjI5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-575719229", "createdAt": "2021-01-25T19:05:01Z", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOTowNTowMlrOIZ2IrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOTowNTowMlrOIZ2IrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk3MjI2OQ==", "bodyText": "This class corresponds to starting from either \"null\" or a given continuation state (aka ChangeFeedState), right?  It would be useful to add a short description to all these ChangeFeedStart* classes which captures the specific cases they will be used.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563972269", "createdAt": "2021-01-25T19:05:02Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedStartFromETagAndFeedRangeImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+class ChangeFeedStartFromETagAndFeedRangeImpl extends ChangeFeedStartFromInternal {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1NzI2MzY1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-575726365", "createdAt": "2021-01-25T19:14:21Z", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOToxNDoyMlrOIZ2fFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOToxNDoyMlrOIZ2fFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk3ODAwNw==", "bodyText": "Is getting the object mapper instance affected by other external settings/configs which could impact how we serialize/de-serialize the values? If true, we might need to pass our own configuration settings such that the Base64 encoded Json string is not impacted by such external changes.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563978007", "createdAt": "2021-01-25T19:14:22Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedState.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@JsonDeserialize(using = ChangeFeedStateDeserializer.class)\n+public abstract class ChangeFeedState extends JsonSerializable {\n+    ChangeFeedState() {\n+    }\n+\n+    public abstract FeedRangeContinuation getContinuation();\n+\n+    public abstract ChangeFeedState setContinuation(FeedRangeContinuation continuation);\n+\n+    public abstract FeedRangeInternal getFeedRange();\n+\n+    public abstract ChangeFeedMode getMode();\n+\n+    public abstract ChangeFeedStartFromInternal getStartFromSettings();\n+\n+    public abstract String applyServerResponseContinuation(\n+        String serverContinuationToken,\n+        RxDocumentServiceRequest request);\n+\n+    public abstract String getContainerRid();\n+\n+    public static ChangeFeedState fromString(String base64EncodedJson) {\n+        checkNotNull(base64EncodedJson, \"Argument 'base64EncodedJson' must not be null\");\n+\n+        String json = new String(\n+            Base64.getUrlDecoder().decode(base64EncodedJson),\n+            StandardCharsets.UTF_8);\n+\n+        final ObjectMapper mapper = Utils.getSimpleObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1NzMxNzU2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-575731756", "createdAt": "2021-01-25T19:21:32Z", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOToyMTozMlrOIZ2wYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOToyMTozMlrOIZ2wYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4MjQzNQ==", "bodyText": "ChangeFeedStateV1 will always expect the ChangeFeedMode to be \"INCREMENTAL\". Rather than creating the FeedRangePartitionKeyRange here, we can make it as part of the ChangeFeedStateV1 constructor and instead pass the getStartFromSettings() as the parameter for the constructor of ChangeFeedStateV1.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563982435", "createdAt": "2021-01-25T19:21:32Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorFactoryImpl.java", "diffHunk": "@@ -60,20 +93,24 @@ public PartitionProcessor create(Lease lease, ChangeFeedObserver observer) {\n             throw new IllegalArgumentException(\"lease\");\n         }\n \n-        String startContinuation = lease.getContinuationToken();\n-\n-        if (startContinuation == null || startContinuation.isEmpty()) {\n-            startContinuation = this.changeFeedProcessorOptions.getStartContinuation();\n+        FeedRangeInternal feedRange = new FeedRangePartitionKeyRangeImpl(lease.getLeaseToken());\n+        ChangeFeedState state;\n+        if (Strings.isNullOrWhiteSpace(lease.getContinuationToken())) {\n+            state = new ChangeFeedStateV1(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1NzM1MzU4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-575735358", "createdAt": "2021-01-25T19:26:01Z", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOToyNjowMVrOIZ27Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOToyNjowMVrOIZ27Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4NTIxNA==", "bodyText": "private CosmosChangeFeedRequestOptions options;\n->\nprivate volatile CosmosChangeFeedRequestOptions options;", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563985214", "createdAt": "2021-01-25T19:26:01Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorImpl.java", "diffHunk": "@@ -37,36 +41,31 @@\n     private final ProcessorSettings settings;\n     private final PartitionCheckpointer checkpointer;\n     private final ChangeFeedObserver observer;\n-    private final ChangeFeedOptions options;\n+    private CosmosChangeFeedRequestOptions options;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1NzQwNzI2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-575740726", "createdAt": "2021-01-25T19:32:58Z", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOTozMjo1OVrOIZ3LwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxOTozMjo1OVrOIZ3LwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4OTQ0MQ==", "bodyText": "there's some significant de-ref'ing here; might be worth to move this in a \"try/catch\" and add specific trace logging in case we fail then through the exception.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563989441", "createdAt": "2021-01-25T19:32:59Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorImpl.java", "diffHunk": "@@ -207,8 +232,16 @@ public RuntimeException getResultException() {\n         return this.resultException;\n     }\n \n-    private Mono<Void> dispatchChanges(FeedResponse<JsonNode> response) {\n-        ChangeFeedObserverContext context = new ChangeFeedObserverContextImpl(this.settings.getPartitionKeyRangeId(), response, this.checkpointer);\n+    private Mono<Void> dispatchChanges(\n+        FeedResponse<JsonNode> response,\n+        ChangeFeedState continuationState) {\n+\n+        ChangeFeedObserverContext context = new ChangeFeedObserverContextImpl(\n+            // TODO fabianm - move observer to FeedRange for merge support\n+            ((FeedRangePartitionKeyRangeImpl)this.settings.getStartState().getFeedRange()).getPartitionKeyRangeId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1Nzc0MjEx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-575774211", "createdAt": "2021-01-25T20:18:11Z", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMDoxODoxMVrOIZ4z9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMDoxODoxMVrOIZ4z9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxNjExOA==", "bodyText": "Having these settings on the public facing \"models\" class become binding to the API and hard to change after. IMHO 1000 is a bit high, I will recommend starting with 100 instead.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564016118", "createdAt": "2021-01-25T20:18:11Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final int DEFAULT_MAX_ITEM_COUNT = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1Nzc3Njk4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-575777698", "createdAt": "2021-01-25T20:23:03Z", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMDoyMzowM1rOIZ491A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMDoyMzowM1rOIZ491A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxODY0NA==", "bodyText": "My understanding is that the \"models\" classes should only capture properties, any helper functions even if \"static\" will go in a separate helper class, outside \"models\" package...", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564018644", "createdAt": "2021-01-25T20:23:03Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final int DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final int DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private int maxItemCount;\n+    private int maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+    private boolean isSplitHandlingDisabled;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+        this.isSplitHandlingDisabled = false;\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public int getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(int maxItemCount) {\n+        this.maxItemCount = maxItemCount;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public int getMaxPrefetchPageCount() {\n+        return this.maxPrefetchPageCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @param maxPrefetchPageCount the max number of pages that will be prefetched from the backend\n+     *                             asynchronously in the background\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxPrefetchPageCount(int maxPrefetchPageCount) {\n+        checkArgument(\n+            maxPrefetchPageCount > 0,\n+            \"Argument 'maxPrefetchCount' must be larger than 0.\");\n+        this.maxPrefetchPageCount = maxPrefetchPageCount;\n+\n+        return this;\n+    }\n+\n+    boolean isSplitHandlingDisabled() {\n+        return this.isSplitHandlingDisabled;\n+    }\n+\n+    CosmosChangeFeedRequestOptions disableSplitHandling() {\n+        this.isSplitHandlingDisabled = true;\n+        return this;\n+    }\n+\n+    ChangeFeedMode getMode() {\n+        return this.mode;\n+    }\n+\n+    /**\n+     * Gets the properties\n+     *\n+     * @return Map of request options properties\n+     */\n+    Map<String, Object> getProperties() {\n+        return properties;\n+    }\n+\n+    ChangeFeedStartFromInternal getStartFromSettings() {\n+        return this.startFromInternal;\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from the beginning of the change feed\n+     *\n+     * @param feedRange The {@link FeedRange} that is used to define the scope (entire container,\n+     *                  logical partition or subset of a container)\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromBeginning(FeedRange feedRange) {\n+        checkNotNull(feedRange, \"Argument 'feedRange' must not be null.\");\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromBeginning(),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from a previous continuation\n+     *\n+     * @param continuation The continuation that was retrieved from a previously retrieved\n+     *                     FeedResponse\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromContinuation(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1Nzc4NDk0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-575778494", "createdAt": "2021-01-25T20:24:13Z", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMDoyNDoxM1rOIZ5ACw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMDoyNDoxM1rOIZ5ACw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxOTIxMQ==", "bodyText": "withFullFidelity -> fullFidelity", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564019211", "createdAt": "2021-01-25T20:24:13Z", "author": {"login": "milismsft"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final int DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final int DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private int maxItemCount;\n+    private int maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+    private boolean isSplitHandlingDisabled;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+        this.isSplitHandlingDisabled = false;\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public int getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(int maxItemCount) {\n+        this.maxItemCount = maxItemCount;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public int getMaxPrefetchPageCount() {\n+        return this.maxPrefetchPageCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @param maxPrefetchPageCount the max number of pages that will be prefetched from the backend\n+     *                             asynchronously in the background\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxPrefetchPageCount(int maxPrefetchPageCount) {\n+        checkArgument(\n+            maxPrefetchPageCount > 0,\n+            \"Argument 'maxPrefetchCount' must be larger than 0.\");\n+        this.maxPrefetchPageCount = maxPrefetchPageCount;\n+\n+        return this;\n+    }\n+\n+    boolean isSplitHandlingDisabled() {\n+        return this.isSplitHandlingDisabled;\n+    }\n+\n+    CosmosChangeFeedRequestOptions disableSplitHandling() {\n+        this.isSplitHandlingDisabled = true;\n+        return this;\n+    }\n+\n+    ChangeFeedMode getMode() {\n+        return this.mode;\n+    }\n+\n+    /**\n+     * Gets the properties\n+     *\n+     * @return Map of request options properties\n+     */\n+    Map<String, Object> getProperties() {\n+        return properties;\n+    }\n+\n+    ChangeFeedStartFromInternal getStartFromSettings() {\n+        return this.startFromInternal;\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from the beginning of the change feed\n+     *\n+     * @param feedRange The {@link FeedRange} that is used to define the scope (entire container,\n+     *                  logical partition or subset of a container)\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromBeginning(FeedRange feedRange) {\n+        checkNotNull(feedRange, \"Argument 'feedRange' must not be null.\");\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromBeginning(),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from a previous continuation\n+     *\n+     * @param continuation The continuation that was retrieved from a previously retrieved\n+     *                     FeedResponse\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromContinuation(\n+        String continuation) {\n+\n+        final ChangeFeedState changeFeedState = ChangeFeedState.fromString(continuation);\n+\n+        return createForProcessingFromContinuation(changeFeedState);\n+    }\n+\n+    static CosmosChangeFeedRequestOptions createForProcessingFromContinuation(\n+        ChangeFeedState changeFeedState) {\n+\n+        FeedRangeInternal feedRange = changeFeedState.getFeedRange();\n+        FeedRangeContinuation continuation = changeFeedState.getContinuation();\n+        ChangeFeedMode mode = changeFeedState.getMode();\n+\n+        if (continuation != null) {\n+            CompositeContinuationToken continuationToken =\n+                continuation.getCurrentContinuationToken();\n+            if (continuationToken != null) {\n+                String etag = continuationToken.getToken();\n+                return new CosmosChangeFeedRequestOptions(\n+                    feedRange,\n+                    ChangeFeedStartFromInternal.createFromETagAndFeedRange(etag, feedRange),\n+                    mode,\n+                    changeFeedState);\n+            }\n+\n+            return new CosmosChangeFeedRequestOptions(\n+                feedRange,\n+                ChangeFeedStartFromInternal.createFromBeginning(),\n+                mode,\n+                changeFeedState);\n+        }\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            feedRange,\n+            changeFeedState.getStartFromSettings(),\n+            mode,\n+            changeFeedState);\n+    }\n+\n+    static CosmosChangeFeedRequestOptions createForProcessingFromEtagAndFeedRange(\n+        String etag,\n+        FeedRange feedRange) {\n+\n+        if (etag != null) {\n+            return new CosmosChangeFeedRequestOptions(\n+                FeedRangeInternal.convert(feedRange),\n+                ChangeFeedStartFromInternal.createFromETagAndFeedRange(etag,\n+                    FeedRangeInternal.convert(feedRange)),\n+                ChangeFeedMode.INCREMENTAL,\n+                null);\n+        }\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromBeginning(),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from the current time - so only events for all future changes will be\n+     * retrieved\n+     *\n+     * @param feedRange The {@link FeedRange} that is used to define the scope (entire container,\n+     *                  logical partition or subset of a container)\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromNow(FeedRange feedRange) {\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromNow(),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from a certain point in time\n+     *\n+     * @param pointInTime The point in time from which processing of change feed events should start\n+     * @param feedRange   The {@link FeedRange} that is used to define the scope (entire container,\n+     *                    logical partition or subset of a container)\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromPointInTime(\n+        Instant pointInTime,\n+        FeedRange feedRange) {\n+\n+        if (pointInTime == null) {\n+            throw new NullPointerException(\"pointInTime\");\n+        }\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromPointInTime(pointInTime),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    void setRequestContinuation(String etag) {\n+        this.startFromInternal = ChangeFeedStartFromInternal.createFromETagAndFeedRange(\n+            etag,\n+            this.feedRangeInternal);\n+    }\n+\n+    CosmosChangeFeedRequestOptions withCosmosPagedFluxOptions(\n+        CosmosPagedFluxOptions pagedFluxOptions) {\n+\n+        if (pagedFluxOptions == null) {\n+            return this;\n+        }\n+\n+        CosmosChangeFeedRequestOptions effectiveRequestOptions = this;\n+\n+        if (pagedFluxOptions.getRequestContinuation() != null) {\n+            effectiveRequestOptions =\n+                CosmosChangeFeedRequestOptions.createForProcessingFromContinuation(\n+                    pagedFluxOptions.getRequestContinuation());\n+            effectiveRequestOptions.setMaxPrefetchPageCount(this.getMaxPrefetchPageCount());\n+        }\n+\n+        if (pagedFluxOptions.getMaxItemCount() != null) {\n+            effectiveRequestOptions.setMaxItemCount(pagedFluxOptions.getMaxItemCount());\n+        }\n+\n+        return effectiveRequestOptions;\n+    }\n+\n+    /**\n+     * Changes the change feed mode so that the change feed will contain events for creations,\n+     * deletes as well as all intermediary snapshots for updates. Enabling full fidelity change feed\n+     * mode requires configuring a retention duration in the change feed policy of the\n+     * container. {@link ChangeFeedPolicy}\n+     * <p>\n+     * Intermediary snapshots of changes as well as deleted documents would be\n+     * available for processing for 8 minutes before they vanish.\n+     * When enabling full fidelity mode you will only be able to process change feed events\n+     * within the retention window configured in the change feed policy of the container.\n+     * If you attempt to process a change feed after more than the retention window\n+     * an error (Status Code 400) will be returned because the events for intermediary\n+     * updates and deletes have vanished.\n+     * It would still be possible to process changes using Incremental mode even when\n+     * configuring a full fidelity change feed policy with retention window on the container\n+     * and when using Incremental mode it doesn't matter whether your are out of the retention\n+     * window or not - but no events for deletes or intermediary updates would be included.\n+     * When events are not getting processed within the retention window it is also possible\n+     * to continue processing future events in full fidelity mode by querying the change feed\n+     * with a new CosmosChangeFeedRequestOptions instance.\n+     * </p>\n+     *\n+     * @return a {@link CosmosChangeFeedRequestOptions} instance with full fidelity mode enabled\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions withFullFidelity() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "originalPosition": 373}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1NzgzNjg3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-575783687", "createdAt": "2021-01-25T20:31:32Z", "commit": {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37900c7c0a7bedcbec521bada2ae6978e81a9c15", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/37900c7c0a7bedcbec521bada2ae6978e81a9c15", "committedDate": "2021-01-25T21:33:53Z", "message": "Addressing code review comments from Milis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7ddca6b85b7ee59c3c785e500ec3fa816f646e9", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f7ddca6b85b7ee59c3c785e500ec3fa816f646e9", "committedDate": "2021-01-25T21:42:17Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf76ae47eb27ed4fce1cfec90303b2cc8fdaba2a", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf76ae47eb27ed4fce1cfec90303b2cc8fdaba2a", "committedDate": "2021-01-26T00:28:43Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc5NTM4NDA2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-579538406", "createdAt": "2021-01-29T19:05:40Z", "commit": {"oid": "bf76ae47eb27ed4fce1cfec90303b2cc8fdaba2a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxOTowNTo0MFrOIcw7Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxOTowNTo0MFrOIcw7Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzAzMjY3OQ==", "bodyText": "@FabianMeiswinkel Please can you make the changes in this file against the azure-sdk-tools repo. Follow instruction for common tooling https://github.com/Azure/azure-sdk-tools/blob/master/doc/common/common_engsys.md.\nYour current changes will be overwriten by this sync PR https://github.com/Azure/azure-sdk-for-java/pull/18879/files", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r567032679", "createdAt": "2021-01-29T19:05:40Z", "author": {"login": "chidozieononiwu"}, "path": "eng/common/pipelines/templates/steps/cosmos-emulator.yml", "diffHunk": "@@ -9,8 +9,92 @@ steps:\n       Write-Host \"Target Dir: $targetDir\"\n       msiexec /a ${{ parameters.EmulatorMsiUrl }} TARGETDIR=$targetDir /qn | wait-process\n     displayName: Download and Extract Public Cosmos DB Emulator\n+  - powershell: |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf76ae47eb27ed4fce1cfec90303b2cc8fdaba2a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk2Nzc3MTUz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-696777153", "createdAt": "2021-07-01T03:27:00Z", "commit": {"oid": "bf76ae47eb27ed4fce1cfec90303b2cc8fdaba2a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wMVQwMzoyNzowMFrOJ3R4Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wMVQwMzoyNzowMFrOJ3R4Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk0NDMzMQ==", "bodyText": "This has a bug that is causing the lastContinuationToken to always be null. The last parameter is the continuation token which is always set to null.\nreturn new ChangeFeedStateV1(\n            containerRid,\n            feedRange,\n            ChangeFeedMode.INCREMENTAL,\n            ChangeFeedStartFromInternal.createFromETagAndFeedRange(this.ContinuationToken, feedRange),\n            null);", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r661944331", "createdAt": "2021-07-01T03:27:00Z", "author": {"login": "j82w"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionSynchronizerImpl.java", "diffHunk": "@@ -74,7 +78,24 @@ public PartitionSynchronizerImpl(\n         }\n \n         String leaseToken = lease.getLeaseToken();\n-        String lastContinuationToken = lease.getContinuationToken();\n+\n+        ChangeFeedState lastContinuationState = lease.getContinuationState(\n+            this.collectionResourceId,\n+            new FeedRangePartitionKeyRangeImpl(leaseToken)\n+        );\n+\n+        // TODO fabianm - this needs more elaborate processing in case the initial\n+        // FeedRangeContinuation has continuation state for multiple feed Ranges\n+        // and with merge multiple CompositeContinuationItems\n+        // Means Split/Merge needs to be pushed into the FeedRangeContinuation\n+        // Will be necessary for merge anyway\n+        // but efficient testing only works if at least EPK filtering is available in Emulator\n+        // or at least Service - this will be part of the next set of changes\n+        // For now - no merge just simple V0 of lease contract\n+        // this simplification will work\n+        final String lastContinuationToken = lastContinuationState.getContinuation() != null ?\n+            lastContinuationState.getContinuation().getCurrentContinuationToken().getToken() :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf76ae47eb27ed4fce1cfec90303b2cc8fdaba2a"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21e25e7ec59ab43c0bf6a37aadcb3e218e51ba6c", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/21e25e7ec59ab43c0bf6a37aadcb3e218e51ba6c", "committedDate": "2020-11-04T00:58:15Z", "message": "Initial draft of FeedRange artifacts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e6930098c1df358ec74f580cb3617df00dff471", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6e6930098c1df358ec74f580cb3617df00dff471", "committedDate": "2020-11-04T10:30:17Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40ef415a3f00188fc0a204cd0dc214cde0bbf46d", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/40ef415a3f00188fc0a204cd0dc214cde0bbf46d", "committedDate": "2020-11-05T00:29:56Z", "message": "Iterating on FeedRange Apis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54bed2e218c4d42036e4c569c5df311420ac8850", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/54bed2e218c4d42036e4c569c5df311420ac8850", "committedDate": "2020-11-05T14:05:54Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58f98e7557075cc4859797a3d4841db3a6d3bd93", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/58f98e7557075cc4859797a3d4841db3a6d3bd93", "committedDate": "2020-11-11T23:05:03Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46662e06209505e511f01bd53027c378a375d28f", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/46662e06209505e511f01bd53027c378a375d28f", "committedDate": "2020-11-12T00:19:01Z", "message": "Adding public surface area"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03617a4b6c865db61b15eab54e644d2247028bbe", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/03617a4b6c865db61b15eab54e644d2247028bbe", "committedDate": "2020-11-12T23:13:26Z", "message": "Adding FeedRange unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7de6b34f68bcc4fedc8188773f4ee7c664eb276", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7de6b34f68bcc4fedc8188773f4ee7c664eb276", "committedDate": "2020-11-13T00:03:45Z", "message": "Adding test FeedRangePKRangeId_GetEffectiveRangesAsync_Refresh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4095bc5bc318c7c11178e3b2db19f9cec27d5637", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4095bc5bc318c7c11178e3b2db19f9cec27d5637", "committedDate": "2020-11-13T00:33:45Z", "message": "Adding test FeedRangePKRangeId_GetEffectiveRangesAsync_Null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e864bef45a1eac6c7b4dfec191e44975b7abf1c", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8e864bef45a1eac6c7b4dfec191e44975b7abf1c", "committedDate": "2020-11-13T10:18:21Z", "message": "Adding test feedRangeEPK_getPartitionKeyRangesAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ebd7cb8fdd916954a2d419dba6fbe056c1186be", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4ebd7cb8fdd916954a2d419dba6fbe056c1186be", "committedDate": "2020-11-13T10:27:33Z", "message": "Adding test feedRangePK_getPartitionKeyRangesAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e6eb7967c8d4a1a7ea37a2389ef6770d031a6ea", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2e6eb7967c8d4a1a7ea37a2389ef6770d031a6ea", "committedDate": "2020-11-13T10:32:17Z", "message": "Adding test feedRangePKRangeId_getPartitionKeyRangesAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc4c66c3402f26d1e2342ae7d02d0facadc74d62", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/dc4c66c3402f26d1e2342ae7d02d0facadc74d62", "committedDate": "2020-11-13T11:22:22Z", "message": "Adding request visitor unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ef3170e6b938b585218cb1274af297221a488a5", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ef3170e6b938b585218cb1274af297221a488a5", "committedDate": "2020-11-13T14:20:56Z", "message": "Finishing FeedRange tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae9dd96891d3cc3ef381aaba31b9695cde1f2f9c", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae9dd96891d3cc3ef381aaba31b9695cde1f2f9c", "committedDate": "2020-11-13T14:48:00Z", "message": "Cleanup and prettifying"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4811e5034bea83f2555f13ab6fb51f9c7defbd68", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4811e5034bea83f2555f13ab6fb51f9c7defbd68", "committedDate": "2020-11-13T14:50:19Z", "message": "Prettifying feed range tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d", "committedDate": "2020-11-13T15:14:38Z", "message": "Fixes and new test for Conatiner.getFeedRanges()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30e162e89883176c3bee6988e0e40e8b1ea0fbcd", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/30e162e89883176c3bee6988e0e40e8b1ea0fbcd", "committedDate": "2020-11-13T17:31:29Z", "message": "Addressing some SpotBug violations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b08488a3d52dd394fcd8bbd3de79184c796afe36", "committedDate": "2020-11-16T15:31:08Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c67b1f79e0d01e710a7ce3a619fbbbfb43af1f0d", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c67b1f79e0d01e710a7ce3a619fbbbfb43af1f0d", "committedDate": "2020-11-17T00:46:10Z", "message": "Iterating on Changefeed Pull model draft"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "428be5e931d9a90b656e1519785d8cb3f63503c6", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/428be5e931d9a90b656e1519785d8cb3f63503c6", "committedDate": "2020-11-17T22:33:56Z", "message": "Snapshot to be able to switch branches"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdfd53a84f6daf559148545dcbc0bc72643834c3", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fdfd53a84f6daf559148545dcbc0bc72643834c3", "committedDate": "2020-11-18T14:21:37Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "913725ee0435cc4e065002c125997dd0e9f6e93c", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/913725ee0435cc4e065002c125997dd0e9f6e93c", "committedDate": "2020-11-18T15:22:54Z", "message": "Finishing switch from deleted ChangeFeedOptions to new public CosmosChangeFeedRequestOptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afc26781c66c3d4a1e93df240dc4d7bd5c5f004c", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/afc26781c66c3d4a1e93df240dc4d7bd5c5f004c", "committedDate": "2020-11-20T01:24:00Z", "message": "Adding basic json serialization test coverage for FeedRangeContinuation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bec34f5ed6001e92fbef653d27e60e51ebbf3e0", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3bec34f5ed6001e92fbef653d27e60e51ebbf3e0", "committedDate": "2020-11-20T18:43:27Z", "message": "Snapshot - converting Chagefeed to FeedRanges - tests not working yet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c08a6b2484ec277ede5c9c2b9eea54e98092028b", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c08a6b2484ec277ede5c9c2b9eea54e98092028b", "committedDate": "2020-11-23T09:11:09Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abfac43abab7455fc00c120faf13d1939e4e1b6a", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/abfac43abab7455fc00c120faf13d1939e4e1b6a", "committedDate": "2020-11-25T21:28:18Z", "message": "Snapshot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b34420421169889327f382ad1906fba07367397e", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b34420421169889327f382ad1906fba07367397e", "committedDate": "2020-11-26T00:31:27Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93f971db277b3c4d90d749596fa6e7ad6e014e58", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/93f971db277b3c4d90d749596fa6e7ad6e014e58", "committedDate": "2020-11-26T03:45:22Z", "message": "Snapshot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7855790d1a7ae9365053491760609e9e6b9e8f1", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d7855790d1a7ae9365053491760609e9e6b9e8f1", "committedDate": "2020-12-09T11:40:19Z", "message": "Removing TODOs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33ab685246d302e2d7e312ddb350e27d7b1a020a", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/33ab685246d302e2d7e312ddb350e27d7b1a020a", "committedDate": "2020-12-09T11:41:42Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b7936e0dee02d82be4871cb3415c35a930b05d2", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3b7936e0dee02d82be4871cb3415c35a930b05d2", "committedDate": "2020-12-09T22:17:58Z", "message": "Fixing test regressions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37b2a4612a7e196c3606c447eebe4c75b8ed6e38", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/37b2a4612a7e196c3606c447eebe4c75b8ed6e38", "committedDate": "2020-12-09T23:19:28Z", "message": "Fixing a couple SpotBug violations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34ad1e5ed907d4d4f1129b5223c447ca7248c7a5", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/34ad1e5ed907d4d4f1129b5223c447ca7248c7a5", "committedDate": "2020-12-09T23:41:58Z", "message": "Fixing few more SPotBug violations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20aaccf6aaf32c3c833b97124a25c0a87b19de79", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/20aaccf6aaf32c3c833b97124a25c0a87b19de79", "committedDate": "2020-12-10T00:46:28Z", "message": "Fixing ChangeFeedState unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e55ea7fa028ff5b48674feddc8f7412ba9a30af", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9e55ea7fa028ff5b48674feddc8f7412ba9a30af", "committedDate": "2020-12-10T21:05:34Z", "message": "Code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90f371fcc7a00f8b452861ab8653f569cf1f8f57", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/90f371fcc7a00f8b452861ab8653f569cf1f8f57", "committedDate": "2020-12-10T21:09:59Z", "message": "Test code cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d197486ac539422c2a1183811638b42ddb7bfdf0", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d197486ac539422c2a1183811638b42ddb7bfdf0", "committedDate": "2020-12-11T11:30:45Z", "message": "Fixing a regression in Range json serialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "332acfe59e156dd684f72afe93bd252faed973ce", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/332acfe59e156dd684f72afe93bd252faed973ce", "committedDate": "2020-12-11T23:45:10Z", "message": "Fixing CF split unit test failure"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTc3OTk1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-554177995", "createdAt": "2020-12-16T23:52:23Z", "commit": {"oid": "332acfe59e156dd684f72afe93bd252faed973ce"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzo1MjoyNFrOIHeSBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzo1NjoyNVrOIHeYCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwNzA3Nw==", "bodyText": "nit: I would use Preconditions.checkNotNull() from shaded guava lib.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r544707077", "createdAt": "2020-12-16T23:52:24Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,233 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+@Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private Integer maxItemCount;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+    private final Map<String, Object> properties;\n+    private ChangeFeedMode mode;\n+    private final ChangeFeedState continuationState;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "332acfe59e156dd684f72afe93bd252faed973ce"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwNzc3MQ==", "bodyText": "any reason for this?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r544707771", "createdAt": "2020-12-16T23:54:08Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/PartitionKeyRange.java", "diffHunk": "@@ -107,7 +107,7 @@ public boolean equals(Object obj) {\n \n     @Override\n     public int hashCode() {\n-        int hash = 0;\n+        int hash = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "332acfe59e156dd684f72afe93bd252faed973ce"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwODYxNw==", "bodyText": "header.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r544708617", "createdAt": "2020-12-16T23:56:25Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedMode.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.azure.cosmos.implementation.changefeed.implementation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "332acfe59e156dd684f72afe93bd252faed973ce"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "804e2943fb896b9caefed94ac1e58ea193b56c35", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/804e2943fb896b9caefed94ac1e58ea193b56c35", "committedDate": "2020-12-31T12:44:42Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ececd082368b23c98d41f1c37abc6d885471e070", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ececd082368b23c98d41f1c37abc6d885471e070", "committedDate": "2020-12-31T12:50:07Z", "message": "Fixes for some code review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f8a3a9c88269755e6cf2af5d3df60c0015ec6e2", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/4f8a3a9c88269755e6cf2af5d3df60c0015ec6e2", "committedDate": "2021-01-04T11:11:01Z", "message": "Fixing test flakiness (unrelated to actual change)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7d675f894aa91e19cbf5904c1f0470b1f38b6d4", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7d675f894aa91e19cbf5904c1f0470b1f38b6d4", "committedDate": "2021-01-04T11:11:20Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ceacd3080ea9b395c2a1c1f52b386f2660a7410", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7ceacd3080ea9b395c2a1c1f52b386f2660a7410", "committedDate": "2021-01-07T15:29:58Z", "message": "Adding ChangeFeedPolicy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec9cd238d733f2bca604585b1772dabb5acd9209", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ec9cd238d733f2bca604585b1772dabb5acd9209", "committedDate": "2021-01-07T15:31:13Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01a4a68bb1684f7e9fa5bd3f414aa6b8036014c9", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/01a4a68bb1684f7e9fa5bd3f414aa6b8036014c9", "committedDate": "2021-01-07T19:27:24Z", "message": "Adding tests for ChangeFeedPolicy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84f36ea891d2aa95277382f4d684e355ceaa90f8", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/84f36ea891d2aa95277382f4d684e355ceaa90f8", "committedDate": "2021-01-07T19:37:29Z", "message": "Fixing build break"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f512e219a02bad5e2d4dc377fd3be3e7c67c2c1", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2f512e219a02bad5e2d4dc377fd3be3e7c67c2c1", "committedDate": "2021-01-07T19:50:28Z", "message": "Fixing SpotBug issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "714b9b27ccbf44c2ffd98f9ec72717d1b6dbd028", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/714b9b27ccbf44c2ffd98f9ec72717d1b6dbd028", "committedDate": "2021-01-07T21:14:04Z", "message": "Re-triggering CI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e149ed321dd3d2652eb2df22252f03d3535499f", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3e149ed321dd3d2652eb2df22252f03d3535499f", "committedDate": "2021-01-07T22:21:30Z", "message": "Deleting temp data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bbb0d30ea95db8a1179162841ef7502a875e7d2", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bbb0d30ea95db8a1179162841ef7502a875e7d2", "committedDate": "2021-01-07T22:43:20Z", "message": "Deleting CosmosDB Emulator temp data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f5196a2caa1fa78eb2bed681b1120843bb6c3c6", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6f5196a2caa1fa78eb2bed681b1120843bb6c3c6", "committedDate": "2021-01-07T23:01:35Z", "message": "Fixing scritp to delete temp folder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29adeb8a00ac854438a8f22bd98acdd8bbf4f278", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/29adeb8a00ac854438a8f22bd98acdd8bbf4f278", "committedDate": "2021-01-07T23:11:25Z", "message": "Fixing PS script"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aac6f0b64f07e2687e51e7165983bc895fc36f1", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3aac6f0b64f07e2687e51e7165983bc895fc36f1", "committedDate": "2021-01-08T00:56:26Z", "message": "Adding message with Emulator version to emulator install yaml file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ec9f6cb90169b2fe870ac96ab746729f2746c05", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7ec9f6cb90169b2fe870ac96ab746729f2746c05", "committedDate": "2021-01-08T02:00:15Z", "message": "Adding Cosmos DB Emulator installation logs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e533c90025ef11b31cb3ee1a780f65ae984a2de", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e533c90025ef11b31cb3ee1a780f65ae984a2de", "committedDate": "2021-01-08T03:44:45Z", "message": "Adding logic to unistall emulator to Cosmos Emulator yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d3280f9f20e5920f39df12dfbc59cbb03ff3e6f", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3d3280f9f20e5920f39df12dfbc59cbb03ff3e6f", "committedDate": "2021-01-08T04:08:26Z", "message": "Update cosmos-emulator.yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a69b86b9b2801d70e8711ceb3200e3689759bee", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a69b86b9b2801d70e8711ceb3200e3689759bee", "committedDate": "2021-01-08T10:56:35Z", "message": "Fixing missing admin elevation in the uninstall step in Cosmos Emulator yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c205b016fc614311c79564f3f0b1d1ea6bac0ec", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2c205b016fc614311c79564f3f0b1d1ea6bac0ec", "committedDate": "2021-01-08T12:37:06Z", "message": "Iterating on cosmos-emulator.yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f6e0b06dce4ee553d55e9e275f78a4ddabc5f54", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8f6e0b06dce4ee553d55e9e275f78a4ddabc5f54", "committedDate": "2021-01-08T13:02:30Z", "message": "Iteratiing on cosmos-emulator.yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e7f154d92bc2fc020925a76e3db42676e2837af", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9e7f154d92bc2fc020925a76e3db42676e2837af", "committedDate": "2021-01-08T13:13:41Z", "message": "Iterating on cosmos-emulator.yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8891306089a01b0af60db59fa892b56f318a3582", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8891306089a01b0af60db59fa892b56f318a3582", "committedDate": "2021-01-08T14:54:59Z", "message": "Iterating on cosmos-emulator.yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2577aa03284b4b192e58de9fb488540f1ee659de", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/2577aa03284b4b192e58de9fb488540f1ee659de", "committedDate": "2021-01-08T15:46:29Z", "message": "Iterating on comsos-emulator.yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4b3e72e7e6158dcd748e998dc26d8497bc0064e", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b4b3e72e7e6158dcd748e998dc26d8497bc0064e", "committedDate": "2021-01-08T17:44:27Z", "message": "Iterating on comsos-emulator.yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f706764cc9fc74c9ad15c79c59bb2756e49df26", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0f706764cc9fc74c9ad15c79c59bb2756e49df26", "committedDate": "2021-01-08T18:34:17Z", "message": "Iterate on cosmos-emulator.yml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efd3c6c8204019b8f281cfd6a8e9347f9f3359d9", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/efd3c6c8204019b8f281cfd6a8e9347f9f3359d9", "committedDate": "2021-01-08T19:12:52Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3bf00d9a986bd625640b639831c9a8f4856221b", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f3bf00d9a986bd625640b639831c9a8f4856221b", "committedDate": "2021-01-08T21:47:23Z", "message": "Adding FF changefeed unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27cd733cafebbd674eaca693ef3e32adc4a21c67", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/27cd733cafebbd674eaca693ef3e32adc4a21c67", "committedDate": "2021-01-08T22:19:22Z", "message": "Fixing build warning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "026b0e928fad187d10291ac2ad022c2742b5fa8f", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/026b0e928fad187d10291ac2ad022c2742b5fa8f", "committedDate": "2021-01-11T09:22:59Z", "message": "Fixing test regression when ContainerTest hit emulator limit of number of containers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "024ab997b171b44764b913429c55c923ca5ce57a", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/024ab997b171b44764b913429c55c923ca5ce57a", "committedDate": "2021-01-11T10:55:33Z", "message": "Fixing emulator config for CI tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90641a3f0b439a4e3e59dd463e1e916659f37949", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/90641a3f0b439a4e3e59dd463e1e916659f37949", "committedDate": "2021-01-11T11:43:26Z", "message": "Fixing test issue - causing Begin/After Method/Class to also happen for emulator tests in ChangeFeedTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88b5ae503911df6a5469539f621aacf1c13774d7", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/88b5ae503911df6a5469539f621aacf1c13774d7", "committedDate": "2021-01-12T02:04:36Z", "message": "Refactoring FeedRange visitors to populate request headers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09eab8ea917fb2c1b30507f45e917daf99ef4b92", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/09eab8ea917fb2c1b30507f45e917daf99ef4b92", "committedDate": "2021-01-12T19:42:50Z", "message": "Implementing FeedRangeInternal.populateFeedRangeFilteringHeaders"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aec75bab48e374bb863c490e59ed58c576aba854", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/aec75bab48e374bb863c490e59ed58c576aba854", "committedDate": "2021-01-12T21:13:51Z", "message": "Fixes for FeedRangeTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5e63cb26e77ddf8e30c5466485a9232c38d527e", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c5e63cb26e77ddf8e30c5466485a9232c38d527e", "committedDate": "2021-01-13T02:06:19Z", "message": "Refactoring FeedRangeINternal.getEffectiveRanges to getEffectiveRange"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbbd26dd0bba064a118aec2725a38296860b2084", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbbd26dd0bba064a118aec2725a38296860b2084", "committedDate": "2021-01-13T02:12:33Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0aeae1dcfed99249623996f11a0c37621549486", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e0aeae1dcfed99249623996f11a0c37621549486", "committedDate": "2021-01-13T02:30:28Z", "message": "Fixing test issue in FeedRangeTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edb744005875a9cd6d5f4432878ce92e2a28c3ee", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/edb744005875a9cd6d5f4432878ce92e2a28c3ee", "committedDate": "2021-01-13T11:06:59Z", "message": "Reacting to self-Code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/35a901f6049e17632ffa7ce65b9dca9b8feaa861", "committedDate": "2021-01-13T11:22:40Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NTcwNTY3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-567570567", "createdAt": "2021-01-13T19:56:38Z", "commit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxOTo1NjozOVrOIS_3JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxOTo1NjozOVrOIS_3JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc5MTU4OA==", "bodyText": "TODO - change this to whatever is the version at the time of merge before actually merging!", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556791588", "createdAt": "2021-01-13T19:56:39Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/Beta.java", "diffHunk": "@@ -55,5 +55,6 @@\n         V4_9_0,\n         /** v4.11.0 */\n         V4_11_0,\n+        WHATEVER_NEW_VERSION", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NTgyMjM3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-567582237", "createdAt": "2021-01-13T20:13:16Z", "commit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMDoxMzoxNlrOITAbBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMjoxMDoxNlrOITF6tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMDc3NQ==", "bodyText": "nit: Doesn't this cover the case of the above line also?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556800775", "createdAt": "2021-01-13T20:13:16Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ChangeFeedQueryImpl.java", "diffHunk": "@@ -3,128 +3,103 @@\n package com.azure.cosmos.implementation;\n \n import com.azure.cosmos.BridgeInternal;\n-import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStateV1;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n import com.azure.cosmos.implementation.query.Paginator;\n-import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n-import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n+import com.azure.cosmos.models.CosmosChangeFeedRequestOptions;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n \n-import java.time.ZoneOffset;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.function.BiFunction;\n import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n class ChangeFeedQueryImpl<T extends Resource> {\n \n-    private static final String IfNonMatchAllHeaderValue = \"*\";\n+    private static final int INITIAL_TOP_VALUE = -1;\n+\n     private final RxDocumentClientImpl client;\n     private final DiagnosticsClientContext clientContext;\n-    private final ResourceType resourceType;\n-    private final Class<T> klass;\n+    private final Supplier<RxDocumentServiceRequest> createRequestFunc;\n     private final String documentsLink;\n-    private final ChangeFeedOptions options;\n+    private final Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc;\n+    private final Class<T> klass;\n+    private final CosmosChangeFeedRequestOptions options;\n+    private final ResourceType resourceType;\n+    private final ChangeFeedState changeFeedState;\n+\n+    public ChangeFeedQueryImpl(\n+        RxDocumentClientImpl client,\n+        ResourceType resourceType,\n+        Class<T> klass,\n+        String collectionLink,\n+        CosmosChangeFeedRequestOptions requestOptions) {\n+\n+        checkNotNull(client, \"Argument 'client' must not be null.\");\n+        checkNotNull(resourceType, \"Argument 'resourceType' must not be null.\");\n+        checkNotNull(klass, \"Argument 'klass' must not be null.\");\n+        checkNotNull(requestOptions, \"Argument 'requestOptions' must not be null.\");\n+        checkNotNull(collectionLink, \"Argument 'collectionLink' must not be null.\");\n+        if (Strings.isNullOrWhiteSpace(collectionLink)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMjgzNg==", "bodyText": "Is this one required?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556802836", "createdAt": "2021-01-13T20:17:16Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/HttpConstants.java", "diffHunk": "@@ -258,6 +258,8 @@\n \n     public static class A_IMHeaderValues {\n         public static final String INCREMENTAL_FEED = \"Incremental Feed\";\n+        public static final String FullFidelityFeed = \"Full-Fidelity Feed\";\n+        public static final String IncrementalFullFidelityFeed = \"Incremental Full-Fidelity Feed\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwNDcyNA==", "bodyText": "Why is the continuation range needed? Isn't the information in the FeedRange enough (getFeedRange)?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556804724", "createdAt": "2021-01-13T20:20:55Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1411,7 +1413,97 @@ private RxDocumentServiceRequest addBatchHeaders(RxDocumentServiceRequest reques\n             request.getHeaders().put(HttpConstants.HttpHeaders.ACCEPT, RuntimeConstants.MediaTypes.JSON);\n         }\n \n-        return populateAuthorizationHeader(request);\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        if (this.requiresFeedRangeFiltering(request)) {\n+            final Range<String> continuationRange = request.getContinuationRange();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTA5NQ==", "bodyText": "Why would you need to store the complex continuation on a lease? If the lease is for a particular range within a partition, the ETAG would still be a valid continuation if the EPK filtering is in place, right?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556821095", "createdAt": "2021-01-13T20:53:14Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/ServiceItemLease.java", "diffHunk": "@@ -101,6 +108,27 @@ public String getContinuationToken() {\n         return this.ContinuationToken;\n     }\n \n+    public ChangeFeedState getContinuationState(\n+        String containerRid,\n+        FeedRangeInternal feedRange) {\n+\n+        checkNotNull(containerRid, \"Argument 'containerRid' must not be null.\");\n+        checkNotNull(feedRange, \"Argument 'feedRange' must not be null.\");\n+\n+        if (this.ContinuationToken != null &&\n+            this.ContinuationToken.startsWith(\"{\\\"V\\\":\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMjE0OQ==", "bodyText": "During our review for Full Fidelity, on .NET, we decided to put the mode (Incremental or FF) as a required parameter in the creation of the iterator, why did we decide to put it on the options here?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556822149", "createdAt": "2021-01-13T20:55:22Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,238 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+    public Integer getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(Integer maxItemCount) {\n+        this.maxItemCount = maxItemCount;\n+        return this;\n+    }\n+\n+    ChangeFeedMode getMode() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNDAwOQ==", "bodyText": "nit: Would the response had a previous continuation? Also, are there no semantics tied to continuation being null?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556824009", "createdAt": "2021-01-13T20:58:38Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/FeedResponse.java", "diffHunk": "@@ -287,6 +288,23 @@ public String getContinuationToken() {\n         return getValueOrNull(header, headerName);\n     }\n \n+    /**\n+     * Sets the continuation token to be used for continuing the enumeration.\n+     *\n+     * @param continuationToken updates the continuation token header of the response\n+     */\n+    void setContinuationToken(String continuationToken) {\n+        String headerName = useEtagAsContinuation\n+            ? HttpConstants.HttpHeaders.E_TAG\n+            : HttpConstants.HttpHeaders.CONTINUATION;\n+\n+        if (!Strings.isNullOrWhiteSpace(continuationToken)) {\n+            this.header.put(headerName, continuationToken);\n+        } else {\n+            this.header.remove(headerName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNTA0OQ==", "bodyText": "Do you need both the range in the continuation and a different range here? If the point is that the enumerator contains multiple continuation ranges (like a list of composite continuations), isn't the current continuation range enough?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556825049", "createdAt": "2021-01-13T21:00:27Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentServiceRequest.java", "diffHunk": "@@ -830,6 +836,22 @@ public void routeTo(PartitionKeyRangeIdentity partitionKeyRangeIdentity) {\n         this.setPartitionKeyRangeIdentity(partitionKeyRangeIdentity);\n     }\n \n+    public FeedRangeInternal getFeedRange() {\n+        return this.feedRange;\n+    }\n+\n+    public void applyFeedRangeFilter(FeedRangeInternal feedRange) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNTc3Nw==", "bodyText": "In .NET what we do is always use the ETAG for leases. If a lease for a partition is merged, we simply continue to use that same ETAG but apply EPK filtering for the range that was related to the original partition.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556825777", "createdAt": "2021-01-13T21:02:04Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/ServiceItemLease.java", "diffHunk": "@@ -101,6 +108,27 @@ public String getContinuationToken() {\n         return this.ContinuationToken;\n     }\n \n+    public ChangeFeedState getContinuationState(\n+        String containerRid,\n+        FeedRangeInternal feedRange) {\n+\n+        checkNotNull(containerRid, \"Argument 'containerRid' must not be null.\");\n+        checkNotNull(feedRange, \"Argument 'feedRange' must not be null.\");\n+\n+        if (this.ContinuationToken != null &&\n+            this.ContinuationToken.startsWith(\"{\\\"V\\\":\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTA5NQ=="}, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNjQ1NQ==", "bodyText": "nit: If this is an enum, might be worth thinking how (if it happens) would a mode that requires some extra state parameter (like Incremental Full Fidelity) work.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556826455", "createdAt": "2021-01-13T21:03:11Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedMode.java", "diffHunk": "@@ -0,0 +1,9 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+public enum ChangeFeedMode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4MzcwMg==", "bodyText": "How does this type work?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556883702", "createdAt": "2021-01-13T22:03:35Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedStartFromInternalDeserializer.java", "diffHunk": "@@ -0,0 +1,110 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.Strings;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternalDeserializer;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Locale;\n+\n+public class ChangeFeedStartFromInternalDeserializer extends StdDeserializer<ChangeFeedStartFromInternal> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public ChangeFeedStartFromInternalDeserializer() {\n+        this(null);\n+    }\n+\n+    public ChangeFeedStartFromInternalDeserializer(final Class<?> vc) {\n+        super(vc);\n+    }\n+\n+    @Override\n+    public ChangeFeedStartFromInternal deserialize(\n+        final JsonParser parser,\n+        final DeserializationContext context)\n+        throws IOException {\n+\n+        final JsonNode rootNode = parser.getCodec().readTree(parser);\n+        final ObjectMapper mapper = (ObjectMapper)parser.getCodec();\n+\n+        return deserializeStartFromInternal(rootNode, mapper, parser);\n+    }\n+\n+    public static ChangeFeedStartFromInternal deserializeStartFromInternal(\n+        JsonNode rootNode,\n+        ObjectMapper mapper,\n+        JsonParser parser) throws IOException {\n+\n+        JsonNode typeNode = rootNode.get(Constants.Properties.CHANGE_FEED_START_FROM_TYPE);\n+        if (typeNode == null || !typeNode.isTextual() || Strings.isNullOrWhiteSpace(typeNode.textValue())) {\n+            throw JsonMappingException.from(\n+                parser,\n+                String.format(\n+                    \"Required property '%s' missing or does not have a valid value.\",\n+                    Constants.Properties.CHANGE_FEED_START_FROM_TYPE));\n+        }\n+\n+        ChangeFeedStartFromTypes type;\n+        try {\n+            type = ChangeFeedStartFromTypes.valueOf(typeNode.textValue().toUpperCase(Locale.ROOT));\n+        } catch (IllegalArgumentException argException) {\n+            throw JsonMappingException.from(\n+                parser,\n+                String.format(\n+                    \"Value '%s' for required property '%s' does not have a valid value.\",\n+                    typeNode.textValue(),\n+                    Constants.Properties.CHANGE_FEED_START_FROM_TYPE),\n+                argException);\n+        }\n+\n+        switch (type) {\n+            case BEGINNING:\n+                return new ChangeFeedStartFromBeginningImpl();\n+\n+            case NOW:\n+                return new ChangeFeedStartFromNowImpl();\n+\n+            case POINT_IN_TIME:\n+                JsonNode pitNode =\n+                    rootNode.get(Constants.Properties.CHANGE_FEED_START_FROM_POINT_IN_TIME_MS);\n+                if (pitNode == null || !pitNode.isLong()) {\n+                    throw JsonMappingException.from(\n+                        parser,\n+                        String.format(\n+                            \"Required property '%s' missing or does not have a valid value.\",\n+                            Constants.Properties.CHANGE_FEED_START_FROM_POINT_IN_TIME_MS));\n+                }\n+                return new ChangeFeedStartFromPointInTimeImpl(Instant.ofEpochMilli(pitNode.longValue()));\n+\n+            case LEASE:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4Nzk0Ng==", "bodyText": "Why would the ranges have the full range? What if the feedRange is smaller?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556887946", "createdAt": "2021-01-13T22:07:38Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuation.java", "diffHunk": "@@ -34,25 +49,77 @@ public FeedRangeInternal getFeedRange() {\n         return this.feedRange;\n     }\n \n-    public abstract String getContinuation();\n+    public abstract CompositeContinuationToken getCurrentContinuationToken();\n \n     public abstract void replaceContinuation(String continuationToken);\n \n     public abstract boolean isDone();\n \n     public abstract void validateContainer(String containerRid);\n \n-    /* TODO fabianm - infinite recursion\n-    public static FeedRangeContinuation tryParse(String toStringValue) {\n-        return FeedRangeCompositeContinuationImpl.tryParse(toStringValue);\n-    }*/\n+    public void populatePropertyBag() {\n+        super.populatePropertyBag();\n+    }\n \n-    public abstract ShouldRetryResult handleChangeFeedNotModified(\n-        RxDocumentServiceResponse responseMessage);\n+    public static FeedRangeContinuation tryParse(String jsonString) {\n+        if (jsonString == null) {\n+            return null;\n+        }\n+\n+        try\n+        {\n+            return FeedRangeCompositeContinuationImpl.parse(jsonString);\n+        }\n+        catch (final IOException ioError) {\n+            LOGGER.debug(\n+                \"Failed to parse feed range continuation JSON {}\",\n+                jsonString,\n+                ioError);\n+            return null;\n+        }\n+    }\n+\n+    public static FeedRangeContinuation convert(final String continuationToken) {\n+        if (Strings.isNullOrWhiteSpace(continuationToken)) {\n+            throw new NullPointerException(\"continuationToken\");\n+        }\n+\n+        FeedRangeContinuation returnValue = tryParse(continuationToken);\n+        if (returnValue != null) {\n+            return returnValue;\n+        }\n+\n+        throw new IllegalArgumentException(\n+            String.format(\n+                \"Invalid Feed range continuation token '%s'\",\n+                continuationToken));\n+    }\n+\n+    public static FeedRangeContinuation createForFullFeedRange(\n+        String containerRid,\n+        FeedRangeInternal feedRange) {\n+\n+        checkNotNull(containerRid, \"Argument 'collectionLink' must not be null\");\n+        checkNotNull(feedRange, \"Argument 'feedRange' must not be null\");\n+\n+        List<Range<String>> ranges = new ArrayList<>();\n+        ranges.add(\n+            new Range<>(\n+                PartitionKeyInternalHelper.MinimumInclusiveEffectivePartitionKey,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MDgwNA==", "bodyText": "What is the result if the container was deleted and recreated with the same name while the objects were already created? Would this return an exception?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556890804", "createdAt": "2021-01-13T22:10:16Z", "author": {"login": "ealsur"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeEpkImpl.java", "diffHunk": "@@ -3,125 +3,253 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n+import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.HttpConstants;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.NotFoundException;\n import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ReadFeedKeyType;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n import com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.ModelBridgeInternal;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n import static com.azure.cosmos.BridgeInternal.setProperty;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n-final class FeedRangeEpkImpl extends FeedRangeInternal {\n+public final class FeedRangeEpkImpl extends FeedRangeInternal {\n     private static final FeedRangeEpkImpl fullRangeEPK =\n         new FeedRangeEpkImpl(PartitionKeyInternalHelper.FullRange);\n \n     private final Range<String> range;\n-    private final UnmodifiableList<Range<String>> rangeList;\n \n     public FeedRangeEpkImpl(final Range<String> range) {\n         checkNotNull(range, \"Argument 'range' must not be null\");\n         this.range = range;\n-        final ArrayList<Range<String>> temp = new ArrayList<>();\n-        temp.add(range);\n-\n-        this.rangeList = (UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp);\n     }\n \n     public Range<String> getRange() {\n         return this.range;\n     }\n \n-    public static FeedRangeEpkImpl forFullRange() {\n-        return fullRangeEPK;\n-    }\n-\n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangeEpkImpl that = (FeedRangeEpkImpl)o;\n+        return Objects.equals(this.range, that.range);\n     }\n \n     @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public int hashCode() {\n+        return Objects.hash(range);\n     }\n \n-    @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public static FeedRangeEpkImpl forFullRange() {\n+        return fullRangeEPK;\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        return Mono.just(this.rangeList);\n+        return Mono.just(this.range);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                this.range,\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                final ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n-                    for (final PartitionKeyRange pkRange : pkRanges) {\n-                        rangeList.add(pkRange.getId());\n-                    }\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 156}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NzE0NDk3", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#pullrequestreview-567714497", "createdAt": "2021-01-13T22:34:48Z", "commit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMjozNDo0OFrOITHgXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwMDoxMzoxMFrOITKKMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxNjgyOA==", "bodyText": "This seems to me something which for long run need to be incorporated to the emulator itself.\n@milismsft can this change be incorporated to the emulator itself?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556916828", "createdAt": "2021-01-13T22:34:48Z", "author": {"login": "moderakh"}, "path": "eng/common/pipelines/templates/steps/cosmos-emulator.yml", "diffHunk": "@@ -9,8 +9,92 @@ steps:\n       Write-Host \"Target Dir: $targetDir\"\n       msiexec /a ${{ parameters.EmulatorMsiUrl }} TARGETDIR=$targetDir /qn | wait-process\n     displayName: Download and Extract Public Cosmos DB Emulator\n+  - powershell: |\n+      Write-Host \"Deleting Cosmos DB Emulator data\"\n+      if (Test-Path $Env:LOCALAPPDATA\\CosmosDbEmulator) { Remove-Item -Recurse -Force $Env:LOCALAPPDATA\\CosmosDbEmulator }\n+    displayName: Delete Cosmos DB Emulator data\n+  - powershell: |\n+      Write-Host \"Getting Cosmos DB Emulator Version\"\n+      $ProductName = \"Azure Cosmos DB Emulator\"\n+      $Emulator = (Join-Path $env:temp (Join-Path $ProductName \"CosmosDB.Emulator.exe\"))\n+      $fileVersion = Get-ChildItem $Emulator\n+      Write-Host $Emulator $fileVersion.VersionInfo\n+    displayName: Get Cosmos DB Emulator Version\n   - powershell: |\n       Write-Host \"Launching Cosmos DB Emulator\"\n-      Import-Module \"$env:temp\\Azure Cosmos DB Emulator\\PSModules\\Microsoft.Azure.CosmosDB.Emulator\"\n-      Start-CosmosDbEmulator -NoUI ${{ parameters.StartParameters }}\n+      $ProductName = \"Azure Cosmos DB Emulator\"\n+      $Emulator = (Join-Path $env:temp (Join-Path $ProductName \"CosmosDB.Emulator.exe\"))\n+      if (!(Test-Path $Emulator)) {\n+        Write-Error \"The emulator is not installed where expected at '$Emulator'\"\n+        return\n+      }\n+\n+      $process = Start-Process $Emulator -ArgumentList \"/getstatus\" -PassThru -Wait\n+\n+      switch ($process.ExitCode) {\n+        1 {\n+          Write-Host \"The emulator is already starting\"\n+          return\n+        }\n+        2 {\n+          Write-Host \"The emulator is already running\"\n+          return\n+        }\n+        3 {\n+          Write-Host \"The emulator is stopped\"\n+        }\n+        default {\n+          Write-Host \"Unrecognized exit code $process.ExitCode\"\n+          return\n+        }\n+      }\n+\n+      $argumentList = \"\"\n+      if (-not [string]::IsNullOrEmpty(\"${{ parameters.StartParameters }}\")) {\n+          $argumentList += , \"${{ parameters.StartParameters }}\"\n+      }\n+\n+      Write-Host \"Starting emulator process: $Emulator $argumentList\"\n+      $process=Start-Process $Emulator -ArgumentList $argumentList -ErrorAction Stop -PassThru\n+      Write-Host \"Emulator process started: $($process.Name), $($process.FileVersion)\"\n+      $Timeout = 600\n+      $result=\"NotYetStarted\"\n+      $complete = if ($Timeout -gt 0) {\n+        $start = [DateTimeOffset]::Now\n+        $stop = $start.AddSeconds($Timeout)\n+        {\n+          $result -eq \"Running\" -or [DateTimeOffset]::Now -ge $stop\n+        }\n+      }\n+      else {\n+        {\n+          $result -eq \"Running\"\n+        }\n+      }\n+\n+      do {\n+        $process = Start-Process $Emulator -ArgumentList \"/getstatus\" -PassThru -Wait\n+\n+        switch ($process.ExitCode) {\n+          1 {\n+            Write-Host \"The emulator is starting\"\n+          }\n+          2 {\n+            Write-Host \"The emulator is running\"\n+            $result=\"Running\"\n+            return\n+          }\n+          3 {\n+            Write-Host \"The emulator is stopped\"\n+          }\n+          default {\n+            Write-Host \"Unrecognized exit code $process.ExitCode\"\n+          }\n+        }\n+\n+        Start-Sleep -Seconds 5\n+      }\n+      until ($complete.Invoke())\n+\n+      Write-Error \"The emulator failed to reach Running status within ${Timeout} seconds\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMDc4Ng==", "bodyText": "in other places we are registering serialzier/deserializer using @JsonSerialize annotation.\nsee this:\nhttps://github.com/Azure/azure-sdk-for-java/blob/master/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/routing/PartitionKeyInternal.java#L35-L36\nI imagine with the SimpleModule approach you are not paying the one-time reflection cost for discovering the serializer. correct? is there any other benefit?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556930786", "createdAt": "2021-01-13T22:52:20Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Utils.java", "diffHunk": "@@ -77,6 +87,21 @@\n         Utils.simpleObjectMapper.configure(JsonParser.Feature.STRICT_DUPLICATE_DETECTION, true);\n         Utils.simpleObjectMapper.configure(DeserializationFeature.ACCEPT_FLOAT_AS_INT, false);\n \n+        final SimpleModule customDeserializationModules = new SimpleModule();\n+        customDeserializationModules.addDeserializer(\n+            FeedRangeInternal.class,\n+            new FeedRangeInternalDeserializer());\n+        customDeserializationModules.addDeserializer(\n+            FeedRangeContinuation.class,\n+            new FeedRangeContinuationDeserializer());\n+        customDeserializationModules.addDeserializer(\n+            ChangeFeedStartFromInternal.class,\n+            new ChangeFeedStartFromInternalDeserializer());\n+        customDeserializationModules.addDeserializer(\n+            ChangeFeedState.class,\n+            new ChangeFeedStateDeserializer());\n+        Utils.simpleObjectMapper.registerModule(customDeserializationModules);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMTYzNw==", "bodyText": "does this correlate with a String header we pass to the BE? or is it merely a client side config?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556931637", "createdAt": "2021-01-13T22:54:27Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedMode.java", "diffHunk": "@@ -0,0 +1,9 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+public enum ChangeFeedMode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMzM2MQ==", "bodyText": "nit: indentation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556933361", "createdAt": "2021-01-13T22:58:15Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuationDeserializer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class FeedRangeContinuationDeserializer extends StdDeserializer<FeedRangeContinuation>  {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public FeedRangeContinuationDeserializer() {\n+        this(null);\n+    }\n+\n+    public FeedRangeContinuationDeserializer(final Class<?> vc) {\n+        super(vc);\n+    }\n+\n+    @Override\n+    public FeedRangeContinuation deserialize(final JsonParser parser,\n+                                         final DeserializationContext context)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1Mjc4MQ==", "bodyText": "do we have unit tests for serializer/deserializer?\nif not, it is worth to add unit tests. Same for other serializer/deserializers.\nplease see this as example:\nhttps://github.com/Azure/azure-sdk-for-java/blob/master/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/CilentConfigDiagnosticsTest.java", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556952781", "createdAt": "2021-01-13T23:50:59Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuationDeserializer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class FeedRangeContinuationDeserializer extends StdDeserializer<FeedRangeContinuation>  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1OTA1NA==", "bodyText": "as per reactive-stream contract, null value is not a permissible value hence this will be always true,\nperhaps you should check\npkRangeHolder.v != null instead", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556959054", "createdAt": "2021-01-14T00:09:23Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyImpl.java", "diffHunk": "@@ -30,73 +37,125 @@ public PartitionKeyInternal getPartitionKeyInternal() {\n     }\n \n     @Override\n-    public void accept(FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyImpl that = (FeedRangePartitionKeyImpl)o;\n+        return Objects.equals(this.partitionKey, that.partitionKey);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKey);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n+    public Mono<Range<String>> getEffectiveRange(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n \n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        Range<String> range = Range.getPointRange(effectivePartitionKey);\n-        ArrayList<Range<String>> rangeList = new ArrayList<>();\n-        rangeList.add(range);\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n \n-        return Mono.just((UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(rangeList));\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n+\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                Range<String> range = Range.getPointRange(effectivePartitionKey);\n+                return Mono.just(range);\n+            });\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n+    public Mono<List<String>> getPartitionKeyRanges(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                Range.getPointRange(effectivePartitionKey),\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    String rangeId = pkRangeHolder.v.get(0).getId();\n-                    rangeList.add(rangeId);\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        Range.getPointRange(effectivePartitionKey),\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        ArrayList<String> rangeList = new ArrayList<>();\n+\n+                        if (pkRangeHolder != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1OTM2MA==", "bodyText": "given that this is a FeedRange for a partition key, is the returned List always a List of size 1?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556959360", "createdAt": "2021-01-14T00:10:15Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyImpl.java", "diffHunk": "@@ -30,73 +37,125 @@ public PartitionKeyInternal getPartitionKeyInternal() {\n     }\n \n     @Override\n-    public void accept(FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyImpl that = (FeedRangePartitionKeyImpl)o;\n+        return Objects.equals(this.partitionKey, that.partitionKey);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKey);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n+    public Mono<Range<String>> getEffectiveRange(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n \n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        Range<String> range = Range.getPointRange(effectivePartitionKey);\n-        ArrayList<Range<String>> rangeList = new ArrayList<>();\n-        rangeList.add(range);\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n \n-        return Mono.just((UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(rangeList));\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n+\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                Range<String> range = Range.getPointRange(effectivePartitionKey);\n+                return Mono.just(range);\n+            });\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n+    public Mono<List<String>> getPartitionKeyRanges(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1OTk5MA==", "bodyText": "as per reactive-stream contract null value is not permissible, so this is always true.\nperhaps you want to check pkRangeHolder.v != null ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556959990", "createdAt": "2021-01-14T00:12:18Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeEpkImpl.java", "diffHunk": "@@ -3,125 +3,253 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n+import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.HttpConstants;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.NotFoundException;\n import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ReadFeedKeyType;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n import com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.ModelBridgeInternal;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n import static com.azure.cosmos.BridgeInternal.setProperty;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n-final class FeedRangeEpkImpl extends FeedRangeInternal {\n+public final class FeedRangeEpkImpl extends FeedRangeInternal {\n     private static final FeedRangeEpkImpl fullRangeEPK =\n         new FeedRangeEpkImpl(PartitionKeyInternalHelper.FullRange);\n \n     private final Range<String> range;\n-    private final UnmodifiableList<Range<String>> rangeList;\n \n     public FeedRangeEpkImpl(final Range<String> range) {\n         checkNotNull(range, \"Argument 'range' must not be null\");\n         this.range = range;\n-        final ArrayList<Range<String>> temp = new ArrayList<>();\n-        temp.add(range);\n-\n-        this.rangeList = (UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp);\n     }\n \n     public Range<String> getRange() {\n         return this.range;\n     }\n \n-    public static FeedRangeEpkImpl forFullRange() {\n-        return fullRangeEPK;\n-    }\n-\n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangeEpkImpl that = (FeedRangeEpkImpl)o;\n+        return Objects.equals(this.range, that.range);\n     }\n \n     @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public int hashCode() {\n+        return Objects.hash(range);\n     }\n \n-    @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public static FeedRangeEpkImpl forFullRange() {\n+        return fullRangeEPK;\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        return Mono.just(this.rangeList);\n+        return Mono.just(this.range);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                this.range,\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                final ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n-                    for (final PartitionKeyRange pkRange : pkRanges) {\n-                        rangeList.add(pkRange.getId());\n-                    }\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        final ArrayList<String> rangeList = new ArrayList<>();\n+\n+                        if (pkRangeHolder != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk2MDMwNA==", "bodyText": "we will never hit here. as explained above null is not a permissible value for reactive-stream", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556960304", "createdAt": "2021-01-14T00:13:10Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeEpkImpl.java", "diffHunk": "@@ -3,125 +3,253 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n+import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.HttpConstants;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.NotFoundException;\n import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ReadFeedKeyType;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n import com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.ModelBridgeInternal;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n import static com.azure.cosmos.BridgeInternal.setProperty;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n-final class FeedRangeEpkImpl extends FeedRangeInternal {\n+public final class FeedRangeEpkImpl extends FeedRangeInternal {\n     private static final FeedRangeEpkImpl fullRangeEPK =\n         new FeedRangeEpkImpl(PartitionKeyInternalHelper.FullRange);\n \n     private final Range<String> range;\n-    private final UnmodifiableList<Range<String>> rangeList;\n \n     public FeedRangeEpkImpl(final Range<String> range) {\n         checkNotNull(range, \"Argument 'range' must not be null\");\n         this.range = range;\n-        final ArrayList<Range<String>> temp = new ArrayList<>();\n-        temp.add(range);\n-\n-        this.rangeList = (UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp);\n     }\n \n     public Range<String> getRange() {\n         return this.range;\n     }\n \n-    public static FeedRangeEpkImpl forFullRange() {\n-        return fullRangeEPK;\n-    }\n-\n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangeEpkImpl that = (FeedRangeEpkImpl)o;\n+        return Objects.equals(this.range, that.range);\n     }\n \n     @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public int hashCode() {\n+        return Objects.hash(range);\n     }\n \n-    @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public static FeedRangeEpkImpl forFullRange() {\n+        return fullRangeEPK;\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        return Mono.just(this.rangeList);\n+        return Mono.just(this.range);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                this.range,\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                final ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n-                    for (final PartitionKeyRange pkRange : pkRanges) {\n-                        rangeList.add(pkRange.getId());\n-                    }\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        final ArrayList<String> rangeList = new ArrayList<>();\n+\n+                        if (pkRangeHolder != null) {\n+                            final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n+                            for (final PartitionKeyRange pkRange : pkRanges) {\n+                                rangeList.add(pkRange.getId());\n+                            }\n+                        }\n+\n+                        return Mono.just(UnmodifiableList.unmodifiableList(rangeList));\n+                    });\n             });\n     }\n \n     @Override\n-    public String toString() {\n-        return this.range.toString();\n+    public Mono<RxDocumentServiceRequest> populateFeedRangeFilteringHeaders(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n+\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        if (pkRangeHolder == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861"}, "originalPosition": 214}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e75d98ae1335b405bfcea7e25c3347e8ded2955", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e75d98ae1335b405bfcea7e25c3347e8ded2955", "committedDate": "2021-01-14T13:44:14Z", "message": "Actually adding public APIs for queryChangeFeed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32ae487783147ddff57335d498d93cdb961764d2", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/32ae487783147ddff57335d498d93cdb961764d2", "committedDate": "2021-01-14T22:03:49Z", "message": "Adding public API in CosmosContainer and SomsosAsyncContainer for CF pull model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c955cc6414ae453db61d5961a79fec19ed3692e4", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c955cc6414ae453db61d5961a79fec19ed3692e4", "committedDate": "2021-01-14T23:14:14Z", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce2bae2375b12ce3a6a0bf0363424c3960d01651", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ce2bae2375b12ce3a6a0bf0363424c3960d01651", "committedDate": "2021-01-14T23:14:39Z", "message": "Reacting to CR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af1469e110210d881e055e43478917ff7a35ba74", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/af1469e110210d881e055e43478917ff7a35ba74", "committedDate": "2021-01-15T00:24:38Z", "message": "SpotBug fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bb6f603fcd577ce1267002d526243ad31d79f1b", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bb6f603fcd577ce1267002d526243ad31d79f1b", "committedDate": "2021-01-15T01:12:42Z", "message": "Fixing JavaDoc bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f99a86bf70af637551b38ffc351b652d16aa7b2", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f99a86bf70af637551b38ffc351b652d16aa7b2", "committedDate": "2021-01-15T01:52:30Z", "message": "Reverting switch to @JsonDeserialize for custom deserializers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32f22dde64d521e5b807b130b5a0d6134d501101", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/32f22dde64d521e5b807b130b5a0d6134d501101", "committedDate": "2021-01-16T01:26:15Z", "message": "Iterating on code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eda9329d1448a7ea354373a68d84b0e2cf51b7da", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/eda9329d1448a7ea354373a68d84b0e2cf51b7da", "committedDate": "2021-01-16T03:28:28Z", "message": "Adding more unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d256919da1b9b7f37f1661965065f18e5944e5bb", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d256919da1b9b7f37f1661965065f18e5944e5bb", "committedDate": "2021-01-16T03:31:14Z", "message": "Spotbug fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2348cefb5e874f8cfc4d6d9780fc878e0f2d954", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2348cefb5e874f8cfc4d6d9780fc878e0f2d954", "committedDate": "2021-01-16T03:54:29Z", "message": "Fix for test failures in FeedRangeTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e386a2c5eeed388500ca90a27aa95fda6f72486c", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e386a2c5eeed388500ca90a27aa95fda6f72486c", "committedDate": "2021-01-16T04:25:21Z", "message": "Fixing SpotBUg issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c8eba5670d031f6c95fb1afebade53086324f33", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5c8eba5670d031f6c95fb1afebade53086324f33", "committedDate": "2021-01-18T09:43:53Z", "message": "Fixing test issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3819b373c83f28f34cab1ea6d9450436bc3ff0c8", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3819b373c83f28f34cab1ea6d9450436bc3ff0c8", "committedDate": "2021-01-18T12:02:31Z", "message": "Iterating on Cosmos Container ChangeFeed tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e78972be6ae98b83f6d6389cacdb5c60521b478", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/7e78972be6ae98b83f6d6389cacdb5c60521b478", "committedDate": "2021-01-18T12:15:48Z", "message": "Fixing test issue for small page size"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d88840d627ba668669874db2c59faa71703d9c1", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3d88840d627ba668669874db2c59faa71703d9c1", "committedDate": "2021-01-18T17:03:55Z", "message": "Adding addiitonal unit tests for change feed pull model"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca796ce421934ed278f92218e3b0c63792c71d00", "author": {"user": {"login": "FabianMeiswinkel", "name": "Fabian Meiswinkel"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/ca796ce421934ed278f92218e3b0c63792c71d00", "committedDate": "2021-01-18T17:29:07Z", "message": "Adding remaining tests for CF pull model"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1440, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}