{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NDIzNzcz", "number": 13493, "title": "Consume/drain the inbound in case a cancellation is received before subscription", "bodyText": "Consume/drain the inbound in case a cancellation is received before subscription\nBased on the suggestions from reactor-netty owner : reactor/reactor-netty#1165 (comment)\nImprovements are based on springframework : spring-projects/spring-framework@21d0696\nThey further improved it to this : https://github.com/spring-projects/spring-framework/blob/v5.2.8.RELEASE/spring-web/src/main/java/org/springframework/http/client/reactive/ReactorClientHttpResponse.java\nWe also have the same logic in our Rntbd client now", "createdAt": "2020-07-24T18:16:33Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493", "merged": true, "mergeCommit": {"oid": "e7f151b3f300538bdcb25bd3ced734aa598d25ca"}, "closed": true, "closedAt": "2020-07-27T17:26:01Z", "author": {"login": "kushagraThapar"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc4IF89gH2gAyNDU2NDIzNzczOjVkNGM4OGEyM2M4NzE3ZWU4NGJlZWJjYjViYmQ4MDI5MTIyOWJmNjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc4JqYsgH2gAyNDU2NDIzNzczOmY2OTFmMTc4MTYxYWQ4YjhiNDU0MDlhMmZkYTQ1MzNlZjIxNjBiZmM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60", "author": {"user": {"login": "kushagraThapar", "name": "Kushagra Thapar"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/5d4c88a23c8717ee84beebcb5bbd80291229bf60", "committedDate": "2020-07-24T18:11:35Z", "message": "Added logic to release/drain content in case a connection is cancelled before getting subscribed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTE0ODA0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#pullrequestreview-455114804", "createdAt": "2020-07-24T18:54:19Z", "commit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NDoxOVrOG26UAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NToxN1rOG26VxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTY4Mg==", "bodyText": "Do 304 classified as non body status code ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460231682", "createdAt": "2020-07-24T18:54:19Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Releasing body, not yet subscribed\");\n+                }\n+                this.bodyIntern()\n+                    .doOnNext(byteBuf -> {})\n+                    .subscribe(byteBuf -> {}, ex -> {});\n+            }\n+        }\n+\n+        private boolean mayHaveBody(HttpMethod method) {\n+            int code = this.statusCode();\n+            return !((code >= 100 && code < 200) || code == 204 || code == 205 ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMjEzMg==", "bodyText": "Do we need mayHaveBody check , what happen if we clear on all cancel irrespective of body, we can avoid extra check ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460232132", "createdAt": "2020-07-24T18:55:17Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTE1MTg5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#pullrequestreview-455115189", "createdAt": "2020-07-24T18:54:57Z", "commit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NDo1N1rOG26VIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxODo1NDo1N1rOG26VIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTk3MQ==", "bodyText": "I think some of 4xx error codes from Cosmos (e.g., 400 query plan) also have body.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#discussion_r460231971", "createdAt": "2020-07-24T18:54:57Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/http/ReactorNettyClient.java", "diffHunk": "@@ -215,5 +233,50 @@ private ByteBufFlux bodyIntern() {\n         Connection internConnection() {\n             return reactorNettyConnection;\n         }\n+\n+        private void updateSubscriptionState(Subscription subscription) {\n+            if (this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.SUBSCRIBED)) {\n+                return;\n+            }\n+            // https://github.com/reactor/reactor-netty/issues/503\n+            // FluxReceive rejects multiple subscribers, but not after a cancel().\n+            // Subsequent subscribers after cancel() will not be rejected, but will hang instead.\n+            // So we need to reject ones in cancelled state.\n+            if (this.state.get() == ReactorNettyResponseState.CANCELLED) {\n+                throw new IllegalStateException(\n+                    \"The client response body has been released already due to cancellation.\");\n+            }\n+        }\n+\n+        /**\n+         * Called by {@link ReactorNettyClient} when a cancellation is detected\n+         * but the content has not been subscribed to. If the subscription never\n+         * materializes then the content will remain not drained. Or it could still\n+         * materialize if the cancellation happened very early, or the response\n+         * reading was delayed for some reason.\n+         */\n+        private void releaseAfterCancel(HttpMethod method) {\n+            if (mayHaveBody(method) && this.state.compareAndSet(ReactorNettyResponseState.NOT_SUBSCRIBED, ReactorNettyResponseState.CANCELLED)) {\n+                if (logger.isDebugEnabled()) {\n+                    logger.debug(\"Releasing body, not yet subscribed\");\n+                }\n+                this.bodyIntern()\n+                    .doOnNext(byteBuf -> {})\n+                    .subscribe(byteBuf -> {}, ex -> {});\n+            }\n+        }\n+\n+        private boolean mayHaveBody(HttpMethod method) {\n+            int code = this.statusCode();\n+            return !((code >= 100 && code < 200) || code == 204 || code == 205 ||\n+                method.equals(HttpMethod.HEAD) || headers().getContentLength() == 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTI3NDAz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13493#pullrequestreview-455127403", "createdAt": "2020-07-24T19:16:05Z", "commit": {"oid": "5d4c88a23c8717ee84beebcb5bbd80291229bf60"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f691f178161ad8b8b45409a2fda4533ef2160bfc", "author": {"user": {"login": "kushagraThapar", "name": "Kushagra Thapar"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/f691f178161ad8b8b45409a2fda4533ef2160bfc", "committedDate": "2020-07-24T20:01:17Z", "message": "Selecting tradeoff to drain body in all cases when cancellation has happened before subscription"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1118, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}