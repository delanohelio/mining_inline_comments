{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzOTQ2MjA3", "number": 10265, "title": "Tracer support in cosmosdb", "bodyText": "Added tracer support on all the public api\nSample view from the JaegerUi\n\nFollowing below points\nEnd to end public api capture\nNo nested spans will be captured only capturing parent call\nSpan name \".\"\nFor query \"method name>..\u201d\nSpan attributes\ndb.type (cosmosdb)\ndb.instance(Database name)\ndb.statement(exact same as span name)\ndb.url(cosmos account uri)\nIn case of exception\nerror.msg(throwable.getMessage())\nerror.type(throwable.getClass().getName())\nerror.stack(throwable.printStackTrace())\nSpan status(both in succes and failure) - Comos status code (HttpBased)", "createdAt": "2020-04-15T19:27:26Z", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265", "merged": true, "mergeCommit": {"oid": "55c23c6c4fe118fca384f0fd10a648569558659f"}, "closed": true, "closedAt": "2020-06-15T19:42:20Z", "author": {"login": "simplynaveen20"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVo42BgH2gAyNDAzOTQ2MjA3OjA4OTMwN2EzYTgxNjdmOTZkZDM4ZWNiZjNjM2ExY2E2YTFjYTMyYjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrlIlCgH2gAyNDAzOTQ2MjA3OjgwMjQ5OTliMjY5MDg2Y2RjODA0Y2YxYjIyMTJhYmRlOWYyMWNhNmE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "089307a3a8167f96dd38ecbf3c3a1ca6a1ca32b2", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/089307a3a8167f96dd38ecbf3c3a1ca6a1ca32b2", "committedDate": "2020-04-08T14:36:47Z", "message": "initial commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "175222e616cf0ff1026ff70735fcc36377d05054", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/175222e616cf0ff1026ff70735fcc36377d05054", "committedDate": "2020-04-08T14:46:01Z", "message": "changing sample"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe03e665cc2fdbef20b5aab7961a690854d8f48c", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe03e665cc2fdbef20b5aab7961a690854d8f48c", "committedDate": "2020-04-13T16:29:48Z", "message": "adding query api tracer support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f9cce807228f3e8cbe3ec9654a58823f432ad4f", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/9f9cce807228f3e8cbe3ec9654a58823f432ad4f", "committedDate": "2020-04-14T18:46:05Z", "message": "merging with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2e8e9e468a8a8c038ea4c1cf70e33414395b775", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2e8e9e468a8a8c038ea4c1cf70e33414395b775", "committedDate": "2020-04-14T19:25:12Z", "message": "reverting change for jaeger ui local testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2fc40f3a35df2381104f88817209804491ae329", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c2fc40f3a35df2381104f88817209804491ae329", "committedDate": "2020-04-15T19:11:27Z", "message": "adding tracers in trigger udf and sproc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDcyNDEx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-394072411", "createdAt": "2020-04-15T19:30:04Z", "commit": {"oid": "c2fc40f3a35df2381104f88817209804491ae329"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOTozMDowNFrOGGIdNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxOTozMjoyNlrOGGIiHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MzE5MA==", "bodyText": "As per conversation with Sameekhsa and Anu, core team will provide withContext, fluxContext api with map attributes to handle nested calls on sdk more cleanly", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r409083190", "createdAt": "2020-04-15T19:30:04Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -223,10 +221,14 @@ CosmosKeyCredential cosmosKeyCredential() {\n         }\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseSettings.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n-                       this))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;\n+        return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2fc40f3a35df2381104f88817209804491ae329"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NDQ0Nw==", "bodyText": "Ending span on very first element of pagedFlux , avoiding accountability of any user side delay. Please let me know if anyone think other wise and want it on OnComplete()", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r409084447", "createdAt": "2020-04-15T19:32:26Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -84,4 +117,28 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n             return Flux.fromIterable(elements);\n         }).subscribe(coreSubscriber);\n     }\n+\n+    private Flux<FeedResponse<T>> byPage(CosmosPagedFluxOptions pagedFluxOptions, Context context) {\n+        final AtomicReference<Context> parentContext =  new AtomicReference<>(Context.NONE);\n+\n+        return this.optionsFluxFunction.apply(pagedFluxOptions).doOnSubscribe(ignoredValue -> {\n+            if (pagedFluxOptions.getTracerProvider().isEnabled()) {\n+                reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                if (!callerFunc.isPresent()) {\n+                    parentContext.set(pagedFluxOptions.getTracerProvider().startSpan(pagedFluxOptions.getTracerSpanName(),\n+                        context.addData(TracerProvider.ATTRIBUTE_MAP, pagedFluxOptions.getTracingAttributes()), ProcessKind.DATABASE));\n+                }\n+            }\n+        }).doOnEach(responseSignal -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2fc40f3a35df2381104f88817209804491ae329"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTIyODEz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-394122813", "createdAt": "2020-04-15T20:47:13Z", "commit": {"oid": "c2fc40f3a35df2381104f88817209804491ae329"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMDo0NzoxM1rOGGK8KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMDo0NzoxM1rOGGK8KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyMzg4MQ==", "bodyText": "@simplynaveen20 - It seems the trace specific doOnSubscribe | doOnSuccess | doOnError   handlers need to be repeated in all APIs. Wondering it makes sense to centralize it\nWith that this method looks something like:\nprivate Mono<CosmosAsyncTriggerResponse> read(Context context) {\n    Mono<CosmosAsyncDatabaseResponse> resultPublisher = asyncDocumentClient.createDatabase(database, ModelBridgeInternal.toRequestOptions(options))\n        .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n            this))\n        .single()\n    if (!tracerProvider.isEnabled()) {\n        return resultPublisher;\n    } else {\n        final String spanName = \"read.\" + database.getId();\n        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n            put(TracerProvider.DB_INSTANCE, database.getId());\n            put(TracerProvider.DB_URL, serviceEndpoint);\n            put(TracerProvider.DB_STATEMENT, spanName);\n        }};\n        return traceEnabledPublisher(resultPublisher, tracingAttributes, context);\n    }\n}\n\n// Reusable code \n//\nprivate <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher, Map<String, String> tracingAttributes, Context context) {\n    return resultPublisher\n        .doOnSubscribe(ignoredValue -> {\n                reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n                Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n                Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n                if (!callerFunc.isPresent()) {\n                    parentContext.set(tracerProvider.startSpan(spanName,\n                        context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n                }\n        }).doOnSuccess(response -> {\n            tracerProvider.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n        }).doOnError(throwable -> {\n            tracerProvider.endSpan(parentContext.get(), Signal.error(throwable), 0);\n        });\n}", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r409123881", "createdAt": "2020-04-15T20:47:13Z", "author": {"login": "anuchandy"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -411,4 +421,101 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database) {\n+        return withContext(context -> createDatabaseIfNotExistsInternal(database, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);\n+        });\n+    }\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                                Context context) {\n+        final boolean isTracingEnabled = tracerProvider.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        String spanName = \"createDatabaseIfNotExistsInternal.\" + database.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, database.getId());\n+            put(TracerProvider.DB_URL, serviceEndpoint);\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        return database.read().onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosClientException) {\n+                final CosmosClientException cosmosClientException = (CosmosClientException) unwrappedException;\n+                if (cosmosClientException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n+                        new CosmosDatabaseRequestOptions());\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        }).doOnSubscribe(ignoredValue -> {\n+            if (isTracingEnabled) {\n+                reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                if (!callerFunc.isPresent()) {\n+                    parentContext.set(tracerProvider.startSpan(spanName,\n+                        context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                }\n+            }\n+        }).doOnSuccess(response -> {\n+            if (isTracingEnabled) {\n+                tracerProvider.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+            }\n+        }).doOnError(throwable -> {\n+            if (isTracingEnabled) {\n+                tracerProvider.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+            }\n+        });\n+    }\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabase(Database database, CosmosDatabaseRequestOptions options, Context context){\n+        final boolean isTracingEnabled = tracerProvider.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        String spanName = \"createDatabase.\" + database.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, database.getId());\n+            put(TracerProvider.DB_URL, serviceEndpoint);\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        return asyncDocumentClient.createDatabase(database, ModelBridgeInternal.toRequestOptions(options))\n+            .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n+                this))\n+            .single()\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(tracerProvider.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    tracerProvider.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    tracerProvider.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2fc40f3a35df2381104f88817209804491ae329"}, "originalPosition": 233}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb82b61e1ff3d7c78d68435cc485f452fbe41b2d", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb82b61e1ff3d7c78d68435cc485f452fbe41b2d", "committedDate": "2020-04-21T13:41:47Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e614db5d38ff2f4947900fa0174774f8c13f37fe", "committedDate": "2020-04-21T21:13:25Z", "message": "adding test case and refactoring code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NzYyNjkx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-397762691", "createdAt": "2020-04-22T00:23:45Z", "commit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoyMzo0NVrOGJd8Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMjo0OTo1MlrOGJg6aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MDg4Ng==", "bodyText": "the lambda that's passed to subscriberContext() looks identical across lots of places, could be reused\nalso, I think it could be simplified:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n          \n          \n            \n                        if (master.isPresent()) {\n          \n          \n            \n                            reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n          \n          \n            \n                        }\n          \n          \n            \n                        return reactorContext.put(TracerProvider.MASTER_CALL, true);\n          \n          \n            \n                    });\n          \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        if (reactorContext.hasKey(TracerProvider.MASTER_CALL)) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.NESTED_CALL, true);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.MASTER_CALL, true);\n          \n          \n            \n                        }\n          \n          \n            \n                    });", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412580886", "createdAt": "2020-04-22T00:23:45Z", "author": {"login": "trask"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -281,10 +278,14 @@ CosmosKeyCredential cosmosKeyCredential() {\n         ModelBridgeInternal.setOfferThroughput(options, throughput);\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseSettings.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n-                       this))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;\n+        return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4Njg2Nw==", "bodyText": "these 3 methods look the same other than mapping response to status code. maybe extract out private method that also takes a Function<T, Integer> and delegate to that?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412586867", "createdAt": "2020-04-22T00:41:33Z", "author": {"login": "trask"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";\n+\n+    public static final Object ATTRIBUTE_MAP = \"span-attributes\";\n+\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(e -> this.tracers.add(e));\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracers.size() > 0;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, Context context, ProcessKind processKind) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(processKind, \"'processKind' cannot be null.\");\n+\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local, processKind);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public void endSpan(Context context, Signal<CosmosResponse> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosClientException) {\n+                        CosmosClientException exception = (CosmosClientException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                  Map<String, String> tracingAttributes,\n+                                                                                  Context context,\n+                                                                                  String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Map<String, String> tracingAttributes,\n+                                                              Context context,\n+                                                              String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), 200);\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Map<String, String> tracingAttributes,\n+                                                                                        Context context,\n+                                                                                        String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzEzNA==", "bodyText": "hasKey never returns null", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412587134", "createdAt": "2020-04-22T00:42:18Z", "author": {"login": "trask"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";\n+\n+    public static final Object ATTRIBUTE_MAP = \"span-attributes\";\n+\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(e -> this.tracers.add(e));\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracers.size() > 0;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, Context context, ProcessKind processKind) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(processKind, \"'processKind' cannot be null.\");\n+\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local, processKind);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public void endSpan(Context context, Signal<CosmosResponse> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosClientException) {\n+                        CosmosClientException exception = (CosmosClientException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                  Map<String, String> tracingAttributes,\n+                                                                                  Context context,\n+                                                                                  String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Map<String, String> tracingAttributes,\n+                                                              Context context,\n+                                                              String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), 200);\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Map<String, String> tracingAttributes,\n+                                                                                        Context context,\n+                                                                                        String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5OTMxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n          \n          \n            \n                                if (!callerFunc.isPresent()) {\n          \n          \n            \n                                if (!reactorContext.hasKey(TracerProvider.NESTED_CALL)) {", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412599310", "createdAt": "2020-04-22T01:20:07Z", "author": {"login": "trask"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";\n+\n+    public static final Object ATTRIBUTE_MAP = \"span-attributes\";\n+\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(e -> this.tracers.add(e));\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracers.size() > 0;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, Context context, ProcessKind processKind) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(processKind, \"'processKind' cannot be null.\");\n+\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local, processKind);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public void endSpan(Context context, Signal<CosmosResponse> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosClientException) {\n+                        CosmosClientException exception = (CosmosClientException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                  Map<String, String> tracingAttributes,\n+                                                                                  Context context,\n+                                                                                  String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Map<String, String> tracingAttributes,\n+                                                              Context context,\n+                                                              String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), 200);\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Map<String, String> tracingAttributes,\n+                                                                                        Context context,\n+                                                                                        String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNzE5MQ==", "bodyText": "just throwing out another option here, instead of tracking MASTER_CALL and NESTED_CALL independently, is to add a single item into the context COSMOS_CALL_DEPTH, e.g.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n          \n          \n            \n                        if (master.isPresent()) {\n          \n          \n            \n                            reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n          \n          \n            \n                        }\n          \n          \n            \n                        return reactorContext.put(TracerProvider.MASTER_CALL, true);\n          \n          \n            \n                    });\n          \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        int callDepth = reactorContext.getOrDefault(TracerProvider.COSMOS_CALL_DEPTH, 0);\n          \n          \n            \n                        if (callDepth == 0) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.COSMOS_CALL_DEPTH, 1);\n          \n          \n            \n                        } else if (callDepth == 1) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.COSMOS_CALL_DEPTH, 2);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            // tracking beyond 2 levels isn't needed, and would create extra copies of the context\n          \n          \n            \n                            return reactorContext;\n          \n          \n            \n                        }\n          \n          \n            \n                    });", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412627191", "createdAt": "2020-04-22T02:42:25Z", "author": {"login": "trask"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -281,10 +278,14 @@ CosmosKeyCredential cosmosKeyCredential() {\n         ModelBridgeInternal.setOfferThroughput(options, throughput);\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseSettings.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n-                       this))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;\n+        return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MDg4Ng=="}, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyOTA2OA==", "bodyText": "Last option (promise \ud83d\ude04), in case you don't like auto-boxing of the integers in the last option (not sure that I do). Define an enum CallDepth with values ZERO, ONE, TWO_OR_MORE, and then:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n          \n          \n            \n                        if (master.isPresent()) {\n          \n          \n            \n                            reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n          \n          \n            \n                        }\n          \n          \n            \n                        return reactorContext.put(TracerProvider.MASTER_CALL, true);\n          \n          \n            \n                    });\n          \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        CallDepth callDepth = reactorContext.getOrDefault(TracerProvider.COSMOS_CALL_DEPTH, CallDepth.ZERO);\n          \n          \n            \n                        if (callDepth == CallDepth.ZERO) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.COSMOS_CALL_DEPTH, CallDepth.ONE);\n          \n          \n            \n                        } else if (callDepth == CallDepth.ONE) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.COSMOS_CALL_DEPTH, CallDepth.TWO_OR_MORE);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return reactorContext;\n          \n          \n            \n                        }\n          \n          \n            \n                    });", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412629068", "createdAt": "2020-04-22T02:48:11Z", "author": {"login": "trask"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -281,10 +278,14 @@ CosmosKeyCredential cosmosKeyCredential() {\n         ModelBridgeInternal.setOfferThroughput(options, throughput);\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseSettings.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n-                       this))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;\n+        return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MDg4Ng=="}, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyOTYwOQ==", "bodyText": "probably should prefix/namespace these since they are put into the reactor context, just to make sure they don't conflict with anything that users may put into there", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412629609", "createdAt": "2020-04-22T02:49:52Z", "author": {"login": "trask"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NTI4ODA2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-398528806", "createdAt": "2020-04-22T19:48:50Z", "commit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxOTo0ODo1MVrOGKISuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxOTo0ODo1MVrOGKISuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3NDgwOQ==", "bodyText": "Given the requirements to set these specific attributes on every span it would help if we could use\nlocal = tracer.start(methodName, local); // will start the span\ntracer.setAttribute(DB_INSTANCE, \"myDatabaseName\", local); // use the current span to set attributes on it\nThis way we don't have to add a new ProcessKind and this startSpan overload can be used as it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413274809", "createdAt": "2020-04-22T19:48:51Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";\n+\n+    public static final Object ATTRIBUTE_MAP = \"span-attributes\";\n+\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(e -> this.tracers.add(e));\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracers.size() > 0;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, Context context, ProcessKind processKind) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(processKind, \"'processKind' cannot be null.\");\n+\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local, processKind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MjIwNzA4", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-399220708", "createdAt": "2020-04-23T15:32:38Z", "commit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTozMjozOFrOGKucTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTo0MDo1MlrOGKu2Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5OTg1Mw==", "bodyText": "this logs the query text? If the query has private info, this will get logged? is that ok?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413899853", "createdAt": "2020-04-23T15:32:38Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -386,6 +389,8 @@ CosmosKeyCredential cosmosKeyCredential() {\n      */\n     public CosmosPagedFlux<CosmosDatabaseProperties> queryDatabases(SqlQuerySpec querySpec, FeedOptions options) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryDatabases.\" + querySpec.getQueryText();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMTQ3OQ==", "bodyText": "seems this code is repeated exactly, can this be factored out as a function and passed here?\n\\liked this\nreturn withContext(context -> replace(containerProperties, requestOptions, context))\n    .subscriberContext(reactorContext -> factoredOutFunc())", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413901479", "createdAt": "2020-04-23T15:34:33Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -156,9 +192,34 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosContainerRequestOptions();\n         }\n-        return database.getDocClientWrapper()\n-                   .replaceCollection(ModelBridgeInternal.getV2Collection(containerProperties), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncContainerResponse(response, database)).single();\n+\n+        final CosmosContainerRequestOptions requestOptions = options;\n+        return withContext(context -> replace(containerProperties, requestOptions, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMjA4NQ==", "bodyText": "exactly the same code, can this be factored out\nreturn withContext(context -> replace(containerProperties, requestOptions, context))\n    .subscriberContext(reactorContext -> factoredOutFunc())", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413902085", "createdAt": "2020-04-23T15:35:21Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -216,16 +276,37 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosItemRequestOptions();\n         }\n+\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> createItem(item, requestOptions, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzE0Ng==", "bodyText": "does this log the user query? is that ok? user query may have private info?\n\"queryItems.\" + this.getId() + \".\" + sqlQuerySpec.getQueryText();", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413903146", "createdAt": "2020-04-23T15:36:35Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -379,6 +464,9 @@ public String getId() {\n     private <T> CosmosPagedFlux<T> queryItemsInternal(\n         SqlQuerySpec sqlQuerySpec, FeedOptions feedOptions, Class<T> classType) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryItems.\" + this.getId() + \".\" + sqlQuerySpec.getQueryText();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzU2Mw==", "bodyText": "can we factor out this code, here and other places?\ne.g,\nreturn withContext(context -> replaceItem(itemType, itemId, doc, requestOptions,context))\n    .subscriberContext(reactorContext -> factoredOutFunc())", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413903563", "createdAt": "2020-04-23T15:37:07Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -481,11 +572,14 @@ public String getId() {\n         ModelBridgeInternal.setPartitionKey(options, partitionKey);\n         @SuppressWarnings(\"unchecked\")\n         Class<T> itemType = (Class<T>) item.getClass();\n-        return this.getDatabase()\n-                   .getDocClientWrapper()\n-                   .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n-                   .single();\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> replaceItem(itemType, itemId, doc, requestOptions,context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNjIwMg==", "bodyText": "exactly same code as above, can we factor out?\nMap<String, String> createTracingMap(...) {\n   ...\n}\n\nand then invoke createTracingMap() here", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413906202", "createdAt": "2020-04-23T15:40:23Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -681,4 +763,168 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItem(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        String spanName = \"deleteItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono =  this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            tracingAttributes,\n+            context, spanName);\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItem(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        String spanName = \"replaceItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNjUzMQ==", "bodyText": "ditto, here and other places.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413906531", "createdAt": "2020-04-23T15:40:52Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -681,4 +763,168 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItem(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        String spanName = \"deleteItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono =  this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            tracingAttributes,\n+            context, spanName);\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItem(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        String spanName = \"replaceItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            tracingAttributes,\n+            context, spanName);\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItem(T item, CosmosItemRequestOptions options, Context context) {\n+        String spanName = \"upsertItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe"}, "originalPosition": 423}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4ae21b2d1031f572abd8ba9c46b2e591a167b25", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/c4ae21b2d1031f572abd8ba9c46b2e591a167b25", "committedDate": "2020-04-24T18:49:27Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eabbec95e6c61b20fa9365824e0944c5c5dcaf1a", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/eabbec95e6c61b20fa9365824e0944c5c5dcaf1a", "committedDate": "2020-04-24T20:05:35Z", "message": "refactoring code with PR ready version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36dde959516c9db168cca34023a105bbb19aa5da", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/36dde959516c9db168cca34023a105bbb19aa5da", "committedDate": "2020-04-24T21:06:40Z", "message": "ending span on doOnComplete"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzY0Njk0", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-400364694", "createdAt": "2020-04-25T06:23:32Z", "commit": {"oid": "36dde959516c9db168cca34023a105bbb19aa5da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwNjoyMzozM1rOGLxO5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwNjoyMzozM1rOGLxO5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE0OA==", "bodyText": "Does documentDB refer to us? if so, that name is deprecated.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414994148", "createdAt": "2020-04-25T06:23:33Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String MICROSOFT_DOCOMENTDB = \"Microsoft.DocumentDB\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36dde959516c9db168cca34023a105bbb19aa5da"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzY0NzEy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-400364712", "createdAt": "2020-04-25T06:23:54Z", "commit": {"oid": "36dde959516c9db168cca34023a105bbb19aa5da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwNjoyMzo1NFrOGLxPFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwNjoyMzo1NFrOGLxPFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE5Nw==", "bodyText": "shouldn't this be \"cosmos\" instead of \"cosmosdb\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414994197", "createdAt": "2020-04-25T06:23:54Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36dde959516c9db168cca34023a105bbb19aa5da"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36743ca506ec2fca6e25fe1c80062abcaba04688", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/36743ca506ec2fca6e25fe1c80062abcaba04688", "committedDate": "2020-05-04T15:02:31Z", "message": "resolving error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cff33addaf0ee49c7ec153f0a6a8d6474f3870ef", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/cff33addaf0ee49c7ec153f0a6a8d6474f3870ef", "committedDate": "2020-05-04T15:33:04Z", "message": "merging with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ca24ec529a3e6ea073cde068f3e46b2173cc6e5", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8ca24ec529a3e6ea073cde068f3e46b2173cc6e5", "committedDate": "2020-05-05T20:06:26Z", "message": "perf improvement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21034b55d17e22f587a0a9004359423c21959d4b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/21034b55d17e22f587a0a9004359423c21959d4b", "committedDate": "2020-05-06T16:07:20Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f9f1397b3ef30c383800bd32e6ebc1986c2567b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f9f1397b3ef30c383800bd32e6ebc1986c2567b", "committedDate": "2020-05-06T16:37:16Z", "message": "fixing build error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aab85a6184c6ceda774df0b0ae055ee78af29289", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/aab85a6184c6ceda774df0b0ae055ee78af29289", "committedDate": "2020-05-11T14:27:12Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d14a0bb5ee30f455dd35b545f564ec6b0ee5beb7", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d14a0bb5ee30f455dd35b545f564ec6b0ee5beb7", "committedDate": "2020-05-11T14:29:15Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e", "committedDate": "2020-05-11T14:36:28Z", "message": "check non opentelementry jar non existence in starting of all api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b09e5c2504b94e80788d30048c96836bd20c1cb", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b09e5c2504b94e80788d30048c96836bd20c1cb", "committedDate": "2020-05-11T15:18:52Z", "message": "fixing checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MzYxMzUy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-409361352", "createdAt": "2020-05-11T17:04:27Z", "commit": {"oid": "8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzowNDoyN1rOGTlSVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzowNDoyN1rOGTlSVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NzAyOA==", "bodyText": "The withContext overload would be used for context passing and not just tracing context-related so should be included regardless of tracing presence.\n@srnagar", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423187028", "createdAt": "2020-05-11T17:04:27Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -199,7 +201,12 @@ boolean isContentResponseOnWriteEnabled() {\n      * an error.\n      */\n     public Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExists(CosmosDatabaseProperties databaseSettings) {\n-        return createDatabaseIfNotExistsInternal(getDatabase(databaseSettings.getId()));\n+        if(!getTracerProvider().isEnabled()) {\n+            return createDatabaseIfNotExistsInternal(getDatabase(databaseSettings.getId()));\n+        }\n+\n+        return withContext(context -> createDatabaseIfNotExistsInternal(getDatabase(databaseSettings.getId()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MzYzMDgw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-409363080", "createdAt": "2020-05-11T17:06:39Z", "commit": {"oid": "6b09e5c2504b94e80788d30048c96836bd20c1cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzowNjo0MFrOGTlXnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzowNjo0MFrOGTlXnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4ODM4MA==", "bodyText": "Should this span name be createDatabaseIfNotExists and not internal?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423188380", "createdAt": "2020-05-11T17:06:40Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -444,4 +447,77 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(boolean isParameterised, SqlQuerySpec querySpec, FeedOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName;\n+            if (isParameterised) {\n+                spanName = \"queryDatabases.\" + querySpec.getQueryText();\n+            } else {\n+                spanName = \"queryDatabases\";\n+            }\n+\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                                Context context) {\n+        String spanName = \"createDatabaseIfNotExistsInternal.\" + database.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b09e5c2504b94e80788d30048c96836bd20c1cb"}, "originalPosition": 179}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81040b270c3a369ae5289428143c144b9e57d54c", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/81040b270c3a369ae5289428143c144b9e57d54c", "committedDate": "2020-05-11T18:09:41Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbc74c8f7ea56fdcf88c1bc35032d81139302805", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbc74c8f7ea56fdcf88c1bc35032d81139302805", "committedDate": "2020-05-11T18:20:59Z", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "806cdf154862a36147c6bc3cfebe582e6fa323b3", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/806cdf154862a36147c6bc3cfebe582e6fa323b3", "committedDate": "2020-05-11T18:56:09Z", "message": "check style fix as per java 8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d061db5abcbf948ae4159576f7ee94a75eca574f", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d061db5abcbf948ae4159576f7ee94a75eca574f", "committedDate": "2020-05-11T21:11:36Z", "message": "adding azure-core-tracing-opentelemetry in test scope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32d9172690f0c9bb71a539f3b6cbca1a7cfd19d2", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/32d9172690f0c9bb71a539f3b6cbca1a7cfd19d2", "committedDate": "2020-05-11T23:17:04Z", "message": "resolving conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fc0cc923557735ac777c7037e5a5491e6675467", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0fc0cc923557735ac777c7037e5a5491e6675467", "committedDate": "2020-05-11T23:38:49Z", "message": "build error fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1290ae13cd5eb1995ddd3a4bbc9a705456fafd9a", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/1290ae13cd5eb1995ddd3a4bbc9a705456fafd9a", "committedDate": "2020-05-12T01:19:20Z", "message": "test failure fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/d2a815459cf553a0f24126b0765e5b3a375ccd4b", "committedDate": "2020-05-12T02:00:54Z", "message": "test fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMjU0MTYz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-410254163", "createdAt": "2020-05-12T17:13:26Z", "commit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzoxMzoyNlrOGUQxfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxODo0MDo1M1rOGUUBQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTUxOQ==", "bodyText": "Version should have a version tag similar to the one azure-core has <!-- {x-version-update;com.azure:azure-core;dependency} -->", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423899519", "createdAt": "2020-05-12T17:13:26Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -132,6 +132,19 @@ Licensed under the MIT License.\n       </exclusions>\n     </dependency>\n \n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-core-tracing-opentelemetry</artifactId>\n+      <scope>test</scope>\n+      <version>1.0.0-beta.4</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMjE0Nw==", "bodyText": "@samvaity is right, context is used not just for tracing. So, !getTracerProvider().isEnabled() is not the right check to determine whether to use withContext() or not.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423902147", "createdAt": "2020-05-12T17:17:47Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -199,7 +201,12 @@ boolean isContentResponseOnWriteEnabled() {\n      * an error.\n      */\n     public Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExists(CosmosDatabaseProperties databaseSettings) {\n-        return createDatabaseIfNotExistsInternal(getDatabase(databaseSettings.getId()));\n+        if(!getTracerProvider().isEnabled()) {\n+            return createDatabaseIfNotExistsInternal(getDatabase(databaseSettings.getId()));\n+        }\n+\n+        return withContext(context -> createDatabaseIfNotExistsInternal(getDatabase(databaseSettings.getId()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NzAyOA=="}, "originalCommit": {"oid": "8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0NTI1Mw==", "bodyText": "callDepth cannot be null as you are doing getOrDefault in the previous line.\nAlso, it's better to use if (callDepth == null) { throw exception; } instead of using assert. If the assertion fails, it throws AssertionError extends from Error which is considered fatal and the program cannot recover.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423945253", "createdAt": "2020-05-12T18:27:53Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import com.azure.cosmos.models.ResourceWrapper;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String MICROSOFT_DOCOMENTDB = \"Microsoft.DocumentDB\";\n+\n+\n+    public final static Function<reactor.util.context.Context, reactor.util.context.Context> callDepthAttributeFunc = (\n+        reactor.util.context.Context reactorContext) -> {\n+        CallDepth callDepth = reactorContext.getOrDefault(COSMOS_CALL_DEPTH, CallDepth.ZERO);\n+        assert callDepth != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1MjcwNg==", "bodyText": "This code segment is common for both overloads of createDatabaseIfNotExistsInternal. Consider extracting into a common method instead of repeating it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423952706", "createdAt": "2020-05-12T18:40:53Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -444,4 +447,77 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(boolean isParameterised, SqlQuerySpec querySpec, FeedOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName;\n+            if (isParameterised) {\n+                spanName = \"queryDatabases.\" + querySpec.getQueryText();\n+            } else {\n+                spanName = \"queryDatabases\";\n+            }\n+\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                                Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Mono<CosmosAsyncDatabaseResponse> responseMono = database.read().onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosClientException) {\n+                final CosmosClientException cosmosClientException = (CosmosClientException) unwrappedException;\n+                if (cosmosClientException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n+                        new CosmosDatabaseRequestOptions());\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 190}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTg3ODQx", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-410587841", "createdAt": "2020-05-13T05:00:11Z", "commit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNTowMDoxMVrOGUhd4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNTozNDozOFrOGUiCqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MzAyNQ==", "bodyText": "excluding only boring ssl should be sufficient.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424173025", "createdAt": "2020-05-13T05:00:11Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -132,6 +132,19 @@ Licensed under the MIT License.\n       </exclusions>\n     </dependency>\n \n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-core-tracing-opentelemetry</artifactId>\n+      <scope>test</scope>\n+      <version>1.0.0-beta.4</version>\n+      <exclusions>\n+        <exclusion>\n+          <groupId>io.netty</groupId>\n+          <artifactId>*</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NDEyOQ==", "bodyText": "The brand of our service, our package name, etc, is cosmos. So this should match that.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424174129", "createdAt": "2020-05-13T05:04:27Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE5Nw=="}, "originalCommit": {"oid": "36dde959516c9db168cca34023a105bbb19aa5da"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTgwNA==", "bodyText": "code style: callDepthAttributeFunc is a static field. CALL_DEPTH_ATTRIBUTE_FUNC ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424175804", "createdAt": "2020-05-13T05:10:22Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import com.azure.cosmos.models.ResourceWrapper;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String MICROSOFT_DOCOMENTDB = \"Microsoft.DocumentDB\";\n+\n+\n+    public final static Function<reactor.util.context.Context, reactor.util.context.Context> callDepthAttributeFunc = (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTk4NA==", "bodyText": "MICROSOFT_DOCOMENTDB -> RESOURCE_PROVIDER_NAME", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424175984", "createdAt": "2020-05-13T05:11:01Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import com.azure.cosmos.models.ResourceWrapper;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String MICROSOFT_DOCOMENTDB = \"Microsoft.DocumentDB\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3ODgyOA==", "bodyText": "regardless of if tracing is enabled or not we are passing the Pageflux to the tracing stack, and recreating some internal Map in FluxUtil::toAzureContext\nThis should sit behind a tracing enabled flag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return FluxUtil.fluxContext(context ->  byPage(cosmosPagedFluxOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);\n          \n          \n            \n            if (tracing.enabled) {\n          \n          \n            \n             return FluxUtil.fluxContext(context ->  byPage(cosmosPagedFluxOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);\n          \n          \n            \n            } else {\n          \n          \n            \n             return this.optionsFluxFunction.apply(cosmosPagedFluxOptions);\n          \n          \n            \n            }\n          \n      \n    \n    \n  \n\nYou should be able to factor out the common if/else code into a method and just call that here, but it seems to me we should have a short circurt for when tracing is not enabled.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424178828", "createdAt": "2020-05-13T05:22:14Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -37,24 +44,23 @@\n     @Override\n     public Flux<FeedResponse<T>> byPage() {\n         CosmosPagedFluxOptions cosmosPagedFluxOptions = new CosmosPagedFluxOptions();\n-\n-        return this.optionsFluxFunction.apply(cosmosPagedFluxOptions);\n+        return FluxUtil.fluxContext(context ->  byPage(cosmosPagedFluxOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTA4Mg==", "bodyText": "magic number 200 should be a constant.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424179082", "createdAt": "2020-05-13T05:23:15Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -84,4 +90,26 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n             return Flux.fromIterable(elements);\n         }).subscribe(coreSubscriber);\n     }\n+\n+    private Flux<FeedResponse<T>> byPage(CosmosPagedFluxOptions pagedFluxOptions, Context context) {\n+        final AtomicReference<Context> parentContext =  new AtomicReference<>(Context.NONE);\n+        TracerProvider.CallDepth callDepth = FluxUtil.toReactorContext(context).getOrDefault(COSMOS_CALL_DEPTH,\n+            TracerProvider.CallDepth.ZERO);\n+        assert callDepth != null;\n+        final boolean isNestedCall = callDepth.equals(TracerProvider.CallDepth.TWO_OR_MORE);\n+        return this.optionsFluxFunction.apply(pagedFluxOptions).doOnSubscribe(ignoredValue -> {\n+            if ( pagedFluxOptions.getTracerProvider().isEnabled() && !isNestedCall) {\n+                    parentContext.set(pagedFluxOptions.getTracerProvider().startSpan(pagedFluxOptions.getTracerSpanName(), pagedFluxOptions.getDatabaseId(), pagedFluxOptions.getServiceEndpoint(),\n+                        context));\n+            }\n+        }).doOnComplete(() -> {\n+            if ( pagedFluxOptions.getTracerProvider().isEnabled() && !isNestedCall) {\n+                pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.complete(), 200);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTE4Nw==", "bodyText": "license header.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424179187", "createdAt": "2020-05-13T05:23:37Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package com.azure.cosmos;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTEwNw==", "bodyText": "this will have additional cost even if tracer not enabled.\ni see in the code withContext is doing Map creation etc.\nwe should short circuit this if tracer is not enabled.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424181107", "createdAt": "2020-05-13T05:29:59Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -85,8 +88,13 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosContainerRequestOptions();\n         }\n-        return database.getDocClientWrapper().readCollection(getLink(), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncContainerResponse(response, database)).single();\n+\n+        final CosmosContainerRequestOptions requestOptions = options;\n+        if(!database.getClient().getTracerProvider().isEnabled()){\n+            return readInternal(options);\n+        }\n+\n+        return withContext(context -> read(requestOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTIxNQ==", "bodyText": "ditto, here and in other places.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424181215", "createdAt": "2020-05-13T05:30:16Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -104,8 +112,13 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosContainerRequestOptions();\n         }\n-        return database.getDocClientWrapper().deleteCollection(getLink(), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncContainerResponse(response, database)).single();\n+\n+        if (!database.getClient().getTracerProvider().isEnabled()) {\n+            return deleteInternal(options);\n+        }\n+\n+        final CosmosContainerRequestOptions requestOptions = options;\n+        return withContext(context -> deleteInternal(requestOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTY1Mw==", "bodyText": "id is the id of the container. so it means in the scope of this container \"createItem.\" + this.getId() can be pre-computed for the container, rather than re-computing it each time.\nCould you pre-compute this in the container level.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424181653", "createdAt": "2020-05-13T05:31:56Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -218,16 +234,33 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosItemRequestOptions();\n         }\n+\n+        if (!database.getClient().getTracerProvider().isEnabled()) {\n+            return createItemInternal(item, options);\n+        }\n+\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> createItemInternal(item, requestOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> createItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        String spanName = \"createItem.\" + this.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTg0NQ==", "bodyText": "id is the id of the container. so it means in the scope of this container \"readAllItems.\" + this.getId() can be pre-computed for the container, rather than re-computing it each time.\nCould you pre-compute this in the container level.\nhere and other places.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424181845", "createdAt": "2020-05-13T05:32:33Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -302,6 +334,9 @@ public String getId() {\n      */\n     public <T> CosmosPagedFlux<T> readAllItems(FeedOptions options, Class<T> classType) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"readAllItems.\" + this.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MjQ0MA==", "bodyText": "\"readItem.\" + this.getId() can be pre-computed in container rather than re-computing each time.\nplease pre-compute in the container.\nand for similar other operations.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424182440", "createdAt": "2020-05-13T05:34:38Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -747,4 +776,182 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        String spanName = \"deleteItem.\" + this.getId();\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, spanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions) {\n+        return this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        String spanName = \"replaceItem.\" + this.getId();\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = replaceItemInternal(itemType, itemId, doc, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, spanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options) {\n+       return this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        String spanName = \"upsertItem.\" + this.getId();\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = upsertItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, spanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<T> itemType = (Class<T>) item.getClass();\n+        return this.getDatabase().getDocClientWrapper()\n+            .upsertDocument(this.getLink(), item,\n+                ModelBridgeInternal.toRequestOptions(options),\n+                true)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> readItemInternal(\n+        String itemId, PartitionKey partitionKey,\n+        RequestOptions requestOptions, Class<T> itemType,\n+        Context context) {\n+        String spanName = \"readItem.\" + this.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b"}, "originalPosition": 415}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30c2f8962f070e59790585b7abee6aa5e5a136a1", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/30c2f8962f070e59790585b7abee6aa5e5a136a1", "committedDate": "2020-05-13T15:56:57Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7fa831bfcdc284440ff14a26ec84bd02732c79c", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7fa831bfcdc284440ff14a26ec84bd02732c79c", "committedDate": "2020-05-13T17:38:31Z", "message": "complie error fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjIxMzI5", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-411221329", "createdAt": "2020-05-13T19:10:45Z", "commit": {"oid": "e7fa831bfcdc284440ff14a26ec84bd02732c79c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxMDo0NlrOGU_zIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToxMDo0NlrOGU_zIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2OTk4NA==", "bodyText": "The tag should be associated with the <version>.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424669984", "createdAt": "2020-05-13T19:10:46Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -132,6 +132,18 @@ Licensed under the MIT License.\n       </exclusions>\n     </dependency>\n \n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-core-tracing-opentelemetry</artifactId> <!-- {x-version-update;com.azure:azure-core-tracing-opentelemetry;dependency} -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fa831bfcdc284440ff14a26ec84bd02732c79c"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aa851d64c0ee1d43d1d86994d4e19a677ac7dc8", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3aa851d64c0ee1d43d1d86994d4e19a677ac7dc8", "committedDate": "2020-05-15T14:51:03Z", "message": "removing query text from tracer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0debac080b3ff04085ed11f0fdaa2a482a8eb096", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0debac080b3ff04085ed11f0fdaa2a482a8eb096", "committedDate": "2020-05-15T16:14:16Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8efa4514350b03035400964d817e4136b4e03486", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8efa4514350b03035400964d817e4136b4e03486", "committedDate": "2020-05-26T23:17:29Z", "message": "merge with master and removing subscriber context for perf gain"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7fe8bb66384a0999cb137e3d0476540cf419c84", "committedDate": "2020-05-26T23:20:33Z", "message": "resolving merge conflict"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzk2MTc2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-420396176", "createdAt": "2020-05-28T18:51:03Z", "commit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo1MTowNFrOGcCNCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0MzowNlrOGcHyvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0OTQxOA==", "bodyText": "does 0 have a specific meaning in the failure context?\nshoudn't we pass error code here instead of 0?\nFor example if it is a CosmosException then cosmosExcpetion.getStatusCode() instead of 0 ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432049418", "createdAt": "2020-05-28T18:51:04Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -84,4 +103,18 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n             return Flux.fromIterable(elements);\n         }).subscribe(coreSubscriber);\n     }\n+\n+    private Flux<FeedResponse<T>> byPage(CosmosPagedFluxOptions pagedFluxOptions, Context context) {\n+        final AtomicReference<Context> parentContext = new AtomicReference<>(Context.NONE);\n+        return this.optionsFluxFunction.apply(pagedFluxOptions).doOnSubscribe(ignoredValue -> {\n+            parentContext.set(pagedFluxOptions.getTracerProvider().startSpan(pagedFluxOptions.getTracerSpanName(),\n+                pagedFluxOptions.getDatabaseId(), pagedFluxOptions.getServiceEndpoint(),\n+                context));\n+        }).doOnComplete(() -> {\n+            pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.complete(),\n+                HttpConstants.StatusCodes.OK);\n+        }).doOnError(throwable -> {\n+            pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.error(throwable), 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MjM1Mg==", "bodyText": "fix indentation plz. args on the same indentation.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432052352", "createdAt": "2020-05-28T18:56:18Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MzI1Ng==", "bodyText": "why are we sending 0? does 0 have special meaning?\nif so shouldn't 0 be used a constant?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432053256", "createdAt": "2020-05-28T18:57:57Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName,databaseId, endpoint,\n+            (T response) -> response.getStatusCode());\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Context context,\n+                                                              String spanName,\n+                                                              String databaseId,\n+                                                              String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName, databaseId, endpoint, (T response) -> HttpConstants.StatusCodes.OK);\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Context context,\n+                                                                                        String spanName,\n+                                                                                        String databaseId,\n+                                                                                        String endpoint) {\n+        return traceEnabledPublisher(resultPublisher, context, spanName,databaseId, endpoint,\n+            CosmosAsyncItemResponse::getStatusCode);\n+    }\n+\n+    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n+                                             Context context,\n+                                             String spanName,\n+                                             String databaseId,\n+                                             String endpoint,\n+                                             Function<T, Integer> statusCodeFunc) {\n+        final AtomicReference<Context> parentContext = new AtomicReference<>(Context.NONE);\n+        Optional<Object> callDepth = context.getData(COSMOS_CALL_DEPTH);\n+        final boolean isNestedCall = callDepth.isPresent();\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (!isNestedCall) {\n+                    parentContext.set(this.startSpan(spanName, databaseId, endpoint,\n+                        context));\n+                }\n+            }).doOnSuccess(response -> {\n+                if (!isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), statusCodeFunc.apply(response));\n+                }\n+            }).doOnError(throwable -> {\n+                if (!isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDI2NQ==", "bodyText": "very long line hard to read, it would be great if we break\nin method invocation, either all args should go in one line (if not a long line)\notherwise one arg per line.\nhere and other places. please. this should improve the readibility.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432064265", "createdAt": "2020-05-28T19:18:32Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -224,16 +270,32 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosItemRequestOptions();\n         }\n+\n+        if (!database.getClient().getTracerProvider().isEnabled()) {\n+            return createItemInternal(item, options);\n+        }\n+\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> createItemInternal(item, requestOptions, context));\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> createItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = createItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono, context", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MDM1Nw==", "bodyText": "why don't we have \"readItem\" span name here?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432070357", "createdAt": "2020-05-28T19:30:25Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -46,12 +49,42 @@\n     private final CosmosAsyncDatabase database;\n     private final String id;\n     private final String link;\n+    private final String replaceContainerSpanName;\n+    private final String deleteContainerSpanName;\n+    private final String replaceProvisionedThroughputSpanName;\n+    private final String readProvisionedThroughputSpanName;\n+    private final String replaceThroughputSpanName;\n+    private final String readThroughputSpanName;\n+    private final String readContainerSpanName;\n+    private final String upsertItemSpanName;\n+    private final String deleteItemSpanName;\n+    private final String replaceItemSpanName;\n+    private final String createItemSpanName;\n+    private final String readAllItemsSpanName;\n+    private final String queryItemsSpanName;\n+    private final String readAllConflictsSpanName;\n+    private final String queryConflictsSpanName;\n     private CosmosAsyncScripts scripts;\n \n     CosmosAsyncContainer(String id, CosmosAsyncDatabase database) {\n         this.id = id;\n         this.database = database;\n         this.link = getParentLink() + \"/\" + getURIPathSegment() + \"/\" + getId();\n+        this.replaceContainerSpanName = \"replaceContainer.\" + this.id;\n+        this.deleteContainerSpanName = \"deleteContainer.\" + this.id;\n+        this.replaceProvisionedThroughputSpanName = \"replaceProvisionedThroughput.\" + this.id;\n+        this.readProvisionedThroughputSpanName = \"readProvisionedThroughput.\" + this.id;\n+        this.replaceThroughputSpanName = \"replaceThroughput.\" + this.id;\n+        this.readThroughputSpanName = \"readThroughput.\" + this.id;\n+        this.readContainerSpanName = \"readContainer.\" + this.id;\n+        this.upsertItemSpanName = \"upsertItem.\" + this.id;\n+        this.deleteItemSpanName = \"deleteItem.\" + this.id;\n+        this.replaceItemSpanName = \"replaceItem.\" + this.id;\n+        this.createItemSpanName = \"createItem.\" + this.id;\n+        this.readAllItemsSpanName = \"readAllItems.\" + this.id;\n+        this.queryItemsSpanName = \"queryItems.\" + this.id;\n+        this.readAllConflictsSpanName = \"readAllConflicts.\" + this.id;\n+        this.queryConflictsSpanName = \"queryConflicts.\" + this.id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDk4OQ==", "bodyText": "CosmosPagedFlux allows both paginated iteration and also item by item iteration.\nI see that we covered the pageByPage iteration through adding CosmosPagedFlux#byPage(.) what about the item by item iteration shoudldn't we cover that as well?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432140989", "createdAt": "2020-05-28T21:43:06Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -84,4 +103,18 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n             return Flux.fromIterable(elements);\n         }).subscribe(coreSubscriber);\n     }\n+\n+    private Flux<FeedResponse<T>> byPage(CosmosPagedFluxOptions pagedFluxOptions, Context context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTMxOTcz", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-420531973", "createdAt": "2020-05-28T22:18:35Z", "commit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjoxODozNVrOGcIrVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjoxODo1MlrOGcIrzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1NTQ3OA==", "bodyText": "readContainerSpanName -> readItemSpanName. Please check other ones too.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432155478", "createdAt": "2020-05-28T22:18:35Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -768,4 +782,244 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.deleteItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions) {\n+        return this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = replaceItemInternal(itemType, itemId, doc, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.replaceItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options) {\n+       return this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = upsertItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.upsertItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<T> itemType = (Class<T>) item.getClass();\n+        return this.getDatabase().getDocClientWrapper()\n+            .upsertDocument(this.getLink(), item,\n+                ModelBridgeInternal.toRequestOptions(options),\n+                true)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> readItemInternal(\n+        String itemId, PartitionKey partitionKey,\n+        RequestOptions requestOptions, Class<T> itemType,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = readItemInternal(itemId, partitionKey, requestOptions, itemType);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.readContainerSpanName, database.getId(), database.getClient().getServiceEndpoint());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 536}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1NTU5OA==", "bodyText": "bug: partitionKey is not passed here.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432155598", "createdAt": "2020-05-28T22:18:52Z", "author": {"login": "moderakh"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -768,4 +782,244 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.deleteItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions) {\n+        return this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = replaceItemInternal(itemType, itemId, doc, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.replaceItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options) {\n+       return this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = upsertItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.upsertItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<T> itemType = (Class<T>) item.getClass();\n+        return this.getDatabase().getDocClientWrapper()\n+            .upsertDocument(this.getLink(), item,\n+                ModelBridgeInternal.toRequestOptions(options),\n+                true)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> readItemInternal(\n+        String itemId, PartitionKey partitionKey,\n+        RequestOptions requestOptions, Class<T> itemType,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = readItemInternal(itemId, partitionKey, requestOptions, itemType);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.readContainerSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> readItemInternal(\n+        String itemId, PartitionKey partitionKey,\n+        RequestOptions requestOptions, Class<T> itemType) {\n+        return this.getDatabase().getDocClientWrapper()\n+            .readDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 544}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMTY4Nzc2", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-422168776", "createdAt": "2020-06-01T20:45:56Z", "commit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMDo0NTo1NlrOGdZg6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMDo0NTo1NlrOGdZg6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3OTkxMg==", "bodyText": "These are not required as com.azure.core module already requires them transitively.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433479912", "createdAt": "2020-06-01T20:45:56Z", "author": {"login": "srnagar"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/module-info.java", "diffHunk": "@@ -24,13 +24,18 @@\n     requires micrometer.core;\n     //  This is only required by guava shaded libraries\n     requires java.logging;\n+    requires reactor.core;\n+    requires org.reactivestreams;\n+    requires com.fasterxml.jackson.databind;\n+    requires org.slf4j;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMTg0ODMy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-422184832", "createdAt": "2020-06-01T21:10:50Z", "commit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMToxMDo1MFrOGdaR-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMTo0MjoyMlrOGdbH3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5MjQ3NA==", "bodyText": "Seeing this is used frequently throughout the class, can this be extracted to somewhere common?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433492474", "createdAt": "2020-06-01T21:10:50Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -164,9 +207,13 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosContainerRequestOptions();\n         }\n-        return database.getDocClientWrapper()\n-                   .replaceCollection(ModelBridgeInternal.getV2Collection(containerProperties), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncContainerResponse(response, database)).single();\n+\n+        if(!database.getClient().getTracerProvider().isEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NTU2OQ==", "bodyText": "The span name should match the method name which is read here", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433495569", "createdAt": "2020-06-01T21:17:31Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncUserDefinedFunction.java", "diffHunk": "@@ -115,4 +121,45 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosAsyncUserDefinedFunctionResponse> readInternal(Context context) {\n+        String spanName = \"readUDF.\" + container.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NTk0Nw==", "bodyText": "Same for methods replace and delete below.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433495947", "createdAt": "2020-06-01T21:18:24Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncUserDefinedFunction.java", "diffHunk": "@@ -115,4 +121,45 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosAsyncUserDefinedFunctionResponse> readInternal(Context context) {\n+        String spanName = \"readUDF.\" + container.getId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NTU2OQ=="}, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NzEzNw==", "bodyText": "We don't need to support multiple tracer implementation.\nRefer here - https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TracerProvider.java#L40", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433497137", "createdAt": "2020-06-01T21:21:00Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5ODA0Mw==", "bodyText": "AZ_TRACING_NAMESPACE_KEY needs to be passed using the context as the tracer expects it in the context here and aligns with other SDK behavior.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433498043", "createdAt": "2020-06-01T21:23:05Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5ODQxMA==", "bodyText": "remove this comment?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433498410", "createdAt": "2020-06-01T21:23:48Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5OTU3OA==", "bodyText": "Why are we always sending a 200 OK status here?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433499578", "createdAt": "2020-06-01T21:26:23Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName,databaseId, endpoint,\n+            (T response) -> response.getStatusCode());\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Context context,\n+                                                              String spanName,\n+                                                              String databaseId,\n+                                                              String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName, databaseId, endpoint, (T response) -> HttpConstants.StatusCodes.OK);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjU1NA==", "bodyText": "do we think this is a good idea?\nespecially since Throwable.printStackTrace() isn't thread-safe and could give out confusing logs/statements?\ncc: @srnagar", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433502554", "createdAt": "2020-06-01T21:33:26Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName,databaseId, endpoint,\n+            (T response) -> response.getStatusCode());\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Context context,\n+                                                              String spanName,\n+                                                              String databaseId,\n+                                                              String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName, databaseId, endpoint, (T response) -> HttpConstants.StatusCodes.OK);\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Context context,\n+                                                                                        String spanName,\n+                                                                                        String databaseId,\n+                                                                                        String endpoint) {\n+        return traceEnabledPublisher(resultPublisher, context, spanName,databaseId, endpoint,\n+            CosmosAsyncItemResponse::getStatusCode);\n+    }\n+\n+    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n+                                             Context context,\n+                                             String spanName,\n+                                             String databaseId,\n+                                             String endpoint,\n+                                             Function<T, Integer> statusCodeFunc) {\n+        final AtomicReference<Context> parentContext = new AtomicReference<>(Context.NONE);\n+        Optional<Object> callDepth = context.getData(COSMOS_CALL_DEPTH);\n+        final boolean isNestedCall = callDepth.isPresent();\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (!isNestedCall) {\n+                    parentContext.set(this.startSpan(spanName, databaseId, endpoint,\n+                        context));\n+                }\n+            }).doOnSuccess(response -> {\n+                if (!isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), statusCodeFunc.apply(response));\n+                }\n+            }).doOnError(throwable -> {\n+                if (!isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    private void end(int statusCode, Throwable throwable, Context context) {\n+        for (Tracer tracer : tracers) {\n+            if (throwable != null) {\n+                tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n+                tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n+                StringWriter errorStack = new StringWriter();\n+                throwable.printStackTrace(new PrintWriter(errorStack));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjY3OA==", "bodyText": "isTracerEnable --> isTracerEnabled", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433502678", "createdAt": "2020-06-01T21:33:47Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -29,41 +34,55 @@\n public final class CosmosPagedFlux<T> extends ContinuablePagedFlux<String, T, FeedResponse<T>> {\n \n     private final Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> optionsFluxFunction;\n+    private final boolean isTracerEnable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzM4Mw==", "bodyText": "+1 we should pass the failing status code.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433503383", "createdAt": "2020-06-01T21:35:31Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -84,4 +103,18 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n             return Flux.fromIterable(elements);\n         }).subscribe(coreSubscriber);\n     }\n+\n+    private Flux<FeedResponse<T>> byPage(CosmosPagedFluxOptions pagedFluxOptions, Context context) {\n+        final AtomicReference<Context> parentContext = new AtomicReference<>(Context.NONE);\n+        return this.optionsFluxFunction.apply(pagedFluxOptions).doOnSubscribe(ignoredValue -> {\n+            parentContext.set(pagedFluxOptions.getTracerProvider().startSpan(pagedFluxOptions.getTracerSpanName(),\n+                pagedFluxOptions.getDatabaseId(), pagedFluxOptions.getServiceEndpoint(),\n+                context));\n+        }).doOnComplete(() -> {\n+            pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.complete(),\n+                HttpConstants.StatusCodes.OK);\n+        }).doOnError(throwable -> {\n+            pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.error(throwable), 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0OTQxOA=="}, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzY2Mw==", "bodyText": "isTraceeEnable --> isTracerEnabled", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433503663", "createdAt": "2020-06-01T21:36:11Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/UtilBridgeInternal.java", "diffHunk": "@@ -24,10 +24,11 @@\n     private UtilBridgeInternal() {}\n \n     @Warning(value = INTERNAL_USE_ONLY_WARNING)\n-    public static <T> CosmosPagedFlux<T> createCosmosPagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction) {\n-        return new CosmosPagedFlux<>(pagedFluxOptionsFluxFunction);\n+    public static <T> CosmosPagedFlux<T> createCosmosPagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction, boolean isTracerEnable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNDI1NQ==", "bodyText": "use StepVerifier instead of block for testing async calls?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433504255", "createdAt": "2020-06-01T21:37:44Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.CosmosItemProperties;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.FeedOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ServiceLoader;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNDY3Mg==", "bodyText": "Rather than any string could we validate the span names and attributes being set on the span?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433504672", "createdAt": "2020-06-01T21:38:41Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.CosmosItemProperties;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.FeedOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ServiceLoader;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNjI2OQ==", "bodyText": "Should consider adding tests for TracerProvider.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433506269", "createdAt": "2020-06-01T21:42:22Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/TestSuiteBase.java", "diffHunk": "@@ -469,8 +469,8 @@ public static CosmosItemProperties createDocument(CosmosAsyncContainer cosmosCon\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjI2Mzcy", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-422226372", "createdAt": "2020-06-01T22:33:42Z", "commit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjI3MzAw", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#pullrequestreview-422227300", "createdAt": "2020-06-01T22:36:04Z", "commit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMjozNjowNFrOGdcTeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMjozNjowNFrOGdcTeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyNTYyNQ==", "bodyText": "Is this test dependency being used even when you are using mockito?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433525625", "createdAt": "2020-06-01T22:36:04Z", "author": {"login": "samvaity"}, "path": "sdk/cosmos/azure-cosmos/pom.xml", "diffHunk": "@@ -127,7 +127,18 @@ Licensed under the MIT License.\n         </exclusion>\n       </exclusions>\n     </dependency>\n-\n+    <dependency>\n+      <groupId>com.azure</groupId>\n+      <artifactId>azure-core-tracing-opentelemetry</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3461604e14d02caffdb2e6df5e9755702bf658c6", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/3461604e14d02caffdb2e6df5e9755702bf658c6", "committedDate": "2020-06-11T18:04:42Z", "message": "resolving merge conflict after GA"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0984a9ceadd61b2c0862a4a6ae3b968693952d57", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/0984a9ceadd61b2c0862a4a6ae3b968693952d57", "committedDate": "2020-06-11T22:11:06Z", "message": "code formating change and some comment resolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9c60a2431add13e597f3c7874f590cc8695945f", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9c60a2431add13e597f3c7874f590cc8695945f", "committedDate": "2020-06-11T23:30:10Z", "message": "resolving comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaabc72ed458360d2e758f05e8744f2ba22d2d8e", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/aaabc72ed458360d2e758f05e8744f2ba22d2d8e", "committedDate": "2020-06-15T16:33:48Z", "message": "moving AZ_TRACING_NAMESPACE_KEY to context from span attribute"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8024999b269086cdc804cf1b2212abde9f21ca6a", "author": {"user": {"login": "simplynaveen20", "name": "Naveen Singh"}}, "url": "https://github.com/Azure/azure-sdk-for-java/commit/8024999b269086cdc804cf1b2212abde9f21ca6a", "committedDate": "2020-06-15T18:40:41Z", "message": "updating core opentelementry jar"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 971, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}