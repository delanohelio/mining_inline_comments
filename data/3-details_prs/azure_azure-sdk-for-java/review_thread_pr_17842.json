{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MzUwODI3", "number": 17842, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwMTo0NjoyMlrOE90iVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODozOToyM1rOE_weqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMjU5MzUxOnYy", "diffSide": "LEFT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwMTo0NjoyMlrOH6tVhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOToyMjoyNFrOIA2p9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTMyMjI0NA==", "bodyText": "@conniey Why do we try to acquire the semaphore when closing? We are not doing anything after acquiring the semaphore.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r531322244", "createdAt": "2020-11-27T01:46:22Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java", "diffHunk": "@@ -175,14 +175,6 @@ private void scheduleCompletePendingTasks() {\n     public void close() {\n         if (!isDisposed.getAndSet(true)) {\n             close(true, \"ReactorExecutor.close() was called.\");\n-\n-            try {\n-                if (!disposeSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n-                    logger.info(\"Unable to acquire dispose reactor semaphore within timeout.\");\n-                }\n-            } catch (InterruptedException e) {\n-                logger.warning(\"Could not acquire semaphore to finish close operation.\", e);\n-            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcxMTU3NQ==", "bodyText": "I think this could be removed.\n\nAlso this close() will call scheduleCompletePendingTasks() which again try to acquire the semaphore.\nscheduleCompletePendingTasks() \": This function calls\nreactor.stop();\nreactor.process();\nshouldn't this be called in reverse order i.e.  call reactor.process() first. ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r531711575", "createdAt": "2020-11-27T17:34:39Z", "author": {"login": "hemanttanwar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java", "diffHunk": "@@ -175,14 +175,6 @@ private void scheduleCompletePendingTasks() {\n     public void close() {\n         if (!isDisposed.getAndSet(true)) {\n             close(true, \"ReactorExecutor.close() was called.\");\n-\n-            try {\n-                if (!disposeSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n-                    logger.info(\"Unable to acquire dispose reactor semaphore within timeout.\");\n-                }\n-            } catch (InterruptedException e) {\n-                logger.warning(\"Could not acquire semaphore to finish close operation.\", e);\n-            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTMyMjI0NA=="}, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NTIzNA==", "bodyText": "the original reason I had added this is because I wanted the rest of the tasks in the task queue to complete before removing the executor.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r534395234", "createdAt": "2020-12-02T18:38:00Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java", "diffHunk": "@@ -175,14 +175,6 @@ private void scheduleCompletePendingTasks() {\n     public void close() {\n         if (!isDisposed.getAndSet(true)) {\n             close(true, \"ReactorExecutor.close() was called.\");\n-\n-            try {\n-                if (!disposeSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n-                    logger.info(\"Unable to acquire dispose reactor semaphore within timeout.\");\n-                }\n-            } catch (InterruptedException e) {\n-                logger.warning(\"Could not acquire semaphore to finish close operation.\", e);\n-            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTMyMjI0NA=="}, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NjM4OQ==", "bodyText": "@conniey This could result in a deadlock as the underlying connection may be closed and the tasks in the queue will not complete and hold on to the semaphore. I profiled this and all the executor threads were stuck waiting to acquire the semaphore.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r537766389", "createdAt": "2020-12-07T19:22:24Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorExecutor.java", "diffHunk": "@@ -175,14 +175,6 @@ private void scheduleCompletePendingTasks() {\n     public void close() {\n         if (!isDisposed.getAndSet(true)) {\n             close(true, \"ReactorExecutor.close() was called.\");\n-\n-            try {\n-                if (!disposeSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n-                    logger.info(\"Unable to acquire dispose reactor semaphore within timeout.\");\n-                }\n-            } catch (InterruptedException e) {\n-                logger.warning(\"Could not acquire semaphore to finish close operation.\", e);\n-            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTMyMjI0NA=="}, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNTE5NzYyOnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNzo1Mzo1NVrOH7FdFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOToyMzoxOFrOIA2sAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcxNzM5OQ==", "bodyText": "Schedulers.single()  always create a daemon thread  and newSingle will create non-daemon thread.\nSo in case of newSingle , Any existing user threads prevent the application from terminating.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r531717399", "createdAt": "2020-11-27T17:53:55Z", "author": {"login": "hemanttanwar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.\n+            // Using Schedulers.single() will use the same thread for all connections in this process which\n+            // limits the scalability of the no. of concurrent connections a single process can have.\n+            Scheduler scheduler = Schedulers.newSingle(\"reactor-executor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5MzgwMw==", "bodyText": "There is another API Schedulers.newSingle(String name, boolean daemon) that should be used in this case.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r533693803", "createdAt": "2020-12-01T20:15:47Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.\n+            // Using Schedulers.single() will use the same thread for all connections in this process which\n+            // limits the scalability of the no. of concurrent connections a single process can have.\n+            Scheduler scheduler = Schedulers.newSingle(\"reactor-executor\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcxNzM5OQ=="}, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NjkxMw==", "bodyText": "We discussed this and we didn't want to make this a daemon thread.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r537766913", "createdAt": "2020-12-07T19:23:18Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.\n+            // Using Schedulers.single() will use the same thread for all connections in this process which\n+            // limits the scalability of the no. of concurrent connections a single process can have.\n+            Scheduler scheduler = Schedulers.newSingle(\"reactor-executor\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTcxNzM5OQ=="}, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODM1Mzg4OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMDoxOTo0NVrOH8-NmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOToxNDozM1rOIA2WQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5NTg5Ng==", "bodyText": "Is there anything we could do to make calls into QPID's Reactor thread safe? If so I'm wondering if it would be safer to use a thread-pooled Scheduler so that we don't create and tear down many, many threads.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r533695896", "createdAt": "2020-12-01T20:19:45Z", "author": {"login": "alzimmermsft"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MTM0NQ==", "bodyText": "I think it is the qpid library that's not thread-safe. So, I don't think we can fix it in this library.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r537761345", "createdAt": "2020-12-07T19:14:33Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5NTg5Ng=="}, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MjkwMDI2OnYy", "diffSide": "RIGHT", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODozOToyM1rOH9o8_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOToxNTozMFrOIA2Yog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NjE1OA==", "bodyText": "Since we own this scheduler, we should make sure to dispose of it.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r534396158", "createdAt": "2020-12-02T18:39:23Z", "author": {"login": "conniey"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.\n+            // Using Schedulers.single() will use the same thread for all connections in this process which\n+            // limits the scalability of the no. of concurrent connections a single process can have.\n+            Scheduler scheduler = Schedulers.newSingle(\"reactor-executor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MTk1NA==", "bodyText": "@conniey we dispose this scheduler it in the ReactorExecutor when close is called.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17842#discussion_r537761954", "createdAt": "2020-12-07T19:15:30Z", "author": {"login": "srnagar"}, "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -350,7 +351,11 @@ private synchronized Connection getOrCreateConnection() throws IOException {\n             connection = reactor.connectionToHost(handler.getHostname(), handler.getProtocolPort(), handler);\n \n             reactorExceptionHandler = new ReactorExceptionHandler();\n-            executor = new ReactorExecutor(reactor, Schedulers.single(), connectionId,\n+            // Use a new single-threaded scheduler for this connection as QPID's Reactor is not thread-safe.\n+            // Using Schedulers.single() will use the same thread for all connections in this process which\n+            // limits the scalability of the no. of concurrent connections a single process can have.\n+            Scheduler scheduler = Schedulers.newSingle(\"reactor-executor\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM5NjE1OA=="}, "originalCommit": {"oid": "3107353c7cabf2879df231a1f90e66a1a83a3f72"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2718, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}