{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNjIwNzg5", "number": 17908, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyMDoyMlrOE_YTrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0OTo1NFrOFSBCyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODkzOTk5OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyMDoyMlrOH9D3LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMTo1NTo1MFrOICrT7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODQ2MQ==", "bodyText": "E_TAG or ETAG? In other locations in Storage we already use constants where it doesn't have the _ such as https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/storage/azure-storage-common/src/main/java/com/azure/storage/common/implementation/Constants.java#L221", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533788461", "createdAt": "2020-12-01T23:20:22Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Concurrency control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    E_TAG,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMDk5NQ==", "bodyText": "I think the docs should also specify that we will respect the conditions they pass initially and then we will lock on the etag", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533800995", "createdAt": "2020-12-01T23:54:17Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Concurrency control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    E_TAG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODQ2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMTE3NA==", "bodyText": "And should maybe mention that specifying an etag is mutually exclusive to having a version set.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533801174", "createdAt": "2020-12-01T23:54:45Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Concurrency control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    E_TAG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODQ2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1MDA3Mw==", "bodyText": "I can change it to ETAG", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r534350073", "createdAt": "2020-12-02T17:29:00Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Concurrency control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    E_TAG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODQ2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1MDU0MQ==", "bodyText": "@rickle-msft - Does this line not indicate that we will respect their conditions?\nIf {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\nOtherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r534350541", "createdAt": "2020-12-02T17:29:40Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Concurrency control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    E_TAG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODQ2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3NTYyNQ==", "bodyText": "Yea that's fine. I think when I wrote that, I was thinking about the other comment I left about using the customer's request for the getProperties and applying that here. But anyway. Yea this is fine.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r534375625", "createdAt": "2020-12-02T18:07:09Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Concurrency control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    E_TAG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODQ2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3NzY3Ng==", "bodyText": "Resolved", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539677676", "createdAt": "2020-12-09T21:55:50Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Concurrency control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    E_TAG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODQ2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODk0Mjg5OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyMToyNlrOH9D49Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzozNDo0OFrOH9mY1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODkxNw==", "bodyText": "Do we want to log an informational or warning message here instead of throwing?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533788917", "createdAt": "2020-12-01T23:21:26Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1NDEzMg==", "bodyText": "I would rather throw. I dont want the user to think they were locking on something but they really werent", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r534354132", "createdAt": "2020-12-02T17:34:48Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4ODkxNw=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODk0Nzg5OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyMzozM1rOH9D8Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzo1ODowNlrOH9nWHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4OTc1MA==", "bodyText": "Should we make this into two constants as we only have two cases we need to cover and that will eliminate a string format.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533789750", "createdAt": "2020-12-01T23:23:33Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);\n+                    }\n+                }\n+                break;\n+            default:\n+                throw logger.logExceptionAsError(\n+                    new UnsupportedOperationException(\"Concurrency control type not supported.\"));\n         }\n \n         return new BlobInputStream(client, range.getOffset(), range.getCount(), chunkSize,\n             requestConditions, properties);\n     }\n \n+    private UnsupportedOperationException generateNoneException(String wrongValue, String toSet) {\n+        return new UnsupportedOperationException(String.format(\"'%s' can not be set when 'concurrencyControl'\"\n+            + \" is set to NONE. Set 'concurrencyControl' to %s.\", wrongValue, toSet));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1MDk5OQ==", "bodyText": "Yeah, this doesn't really need to be a method honestly", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r534350999", "createdAt": "2020-12-02T17:30:17Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);\n+                    }\n+                }\n+                break;\n+            default:\n+                throw logger.logExceptionAsError(\n+                    new UnsupportedOperationException(\"Concurrency control type not supported.\"));\n         }\n \n         return new BlobInputStream(client, range.getOffset(), range.getCount(), chunkSize,\n             requestConditions, properties);\n     }\n \n+    private UnsupportedOperationException generateNoneException(String wrongValue, String toSet) {\n+        return new UnsupportedOperationException(String.format(\"'%s' can not be set when 'concurrencyControl'\"\n+            + \" is set to NONE. Set 'concurrencyControl' to %s.\", wrongValue, toSet));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4OTc1MA=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2OTgyMw==", "bodyText": "With the addition of a few more error cases (if you take a second look), I think we should just leave this as a format.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r534369823", "createdAt": "2020-12-02T17:58:06Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);\n+                    }\n+                }\n+                break;\n+            default:\n+                throw logger.logExceptionAsError(\n+                    new UnsupportedOperationException(\"Concurrency control type not supported.\"));\n         }\n \n         return new BlobInputStream(client, range.getOffset(), range.getCount(), chunkSize,\n             requestConditions, properties);\n     }\n \n+    private UnsupportedOperationException generateNoneException(String wrongValue, String toSet) {\n+        return new UnsupportedOperationException(String.format(\"'%s' can not be set when 'concurrencyControl'\"\n+            + \" is set to NONE. Set 'concurrencyControl' to %s.\", wrongValue, toSet));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4OTc1MA=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODk1MTEyOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyNDozOVrOH9D-DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzozNjoyMFrOH9mc1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MDIyMA==", "bodyText": "Should the error types being thrown here be IllegalStateException instead of UnsupportedOperationException? They feel more like bad states and not like operations that can't be perfromed.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533790220", "createdAt": "2020-12-01T23:24:39Z", "author": {"login": "alzimmermsft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);\n+                    }\n+                }\n+                break;\n+            default:\n+                throw logger.logExceptionAsError(\n+                    new UnsupportedOperationException(\"Concurrency control type not supported.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1NTE1Ng==", "bodyText": "I think its more of a Illegal Argument Exception. I can change it to that", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r534355156", "createdAt": "2020-12-02T17:36:20Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);\n+                    }\n+                }\n+                break;\n+            default:\n+                throw logger.logExceptionAsError(\n+                    new UnsupportedOperationException(\"Concurrency control type not supported.\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MDIyMA=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTAyMjMyOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1MzoyNlrOH9Em8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMTo1NzowMlrOICrWnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMDY4OA==", "bodyText": "I think we should be using the customer's requestConditions for this call and THEN locking on the resulting etag.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533800688", "createdAt": "2020-12-01T23:53:26Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3ODM2NQ==", "bodyText": "Resolved", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539678365", "createdAt": "2020-12-09T21:57:02Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMDY4OA=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTAyNzY4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1NToyNlrOH9Ep4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMTo1NzoxNlrOICrXIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMTQ0Mw==", "bodyText": "I think we want to throw here if etag is specified and throw above if version is specified", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533801443", "createdAt": "2020-12-01T23:55:26Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3ODQ5OA==", "bodyText": "Resolved", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539678498", "createdAt": "2020-12-09T21:57:16Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,60 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.E_TAG\n+            : options.getConcurrencyControl();\n \n         BlobProperties properties = getProperties();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"requestConditions.ifMatch\", \"E_TAG\"));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateNoneException(\"client.versionId\", \"VERSION_ID\"));\n+                }\n+                break;\n+            case E_TAG:\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (versionId == null) {\n+                    throw logger.logExceptionAsError(\n+                        new UnsupportedOperationException(\"Versioning is not supported on this account.\"));\n+                } else {\n+                    // Target the user specified version by default. If not provided, target the latest version.\n+                    if (this.client.getVersionId() == null) {\n+                        client = this.client.getVersionClient(versionId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMTQ0Mw=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTAzODA3OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1OToyNVrOH9Ev0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMTo1NzoyNFrOICrXeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMjk2MQ==", "bodyText": "I don't love the name concurrency control. I think it's technically correct, but it sounds to me more like it's intended to manage like number of threads or something. And etags are for optimistic concurrency, but I don't think versions fits in that linguistic space. That might just be me. It's more about like ensuring a consistent view of the blob for the whole download. It's also weird because they behave differently. Etag will throw if it changes, but version id will never throw as long as the version is not deleted.\n... I don't have any suggestions here though.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r533802961", "createdAt": "2020-12-01T23:59:25Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM2MDI2MQ==", "bodyText": "ConsistencyControl?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r534360261", "createdAt": "2020-12-02T17:44:06Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMjk2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3NjQzMQ==", "bodyText": "Yea I think that works better in my mind. Good one.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r534376431", "createdAt": "2020-12-02T18:08:30Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMjk2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NTEyNA==", "bodyText": "ConsistentReadControl ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535375124", "createdAt": "2020-12-03T16:15:08Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMjk2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3MTU3Mg==", "bodyText": "I like that as well", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535471572", "createdAt": "2020-12-03T18:17:33Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMjk2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4NDg4MQ==", "bodyText": "Going with Kamil's suggestion", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535484881", "createdAt": "2020-12-03T18:36:12Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMjk2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3ODU4NQ==", "bodyText": "Resolved", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539678585", "createdAt": "2020-12-09T21:57:24Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConcurrencyControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #E_TAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConcurrencyControl {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMjk2MQ=="}, "originalCommit": {"oid": "5391e4e4e4ad90f0d395afa5132e2823318f7dd0"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODk3NzcwOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjoxNzo1MFrOH-k1Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODoyOTo1OVrOH-rK6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzI1MQ==", "bodyText": "How about other requestConditions?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535377251", "createdAt": "2020-12-03T16:17:50Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,71 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.ETAG\n+            : options.getConcurrencyControl();\n \n-        BlobProperties properties = getProperties();\n+        BlobProperties properties = getPropertiesWithResponse(options.getRequestConditions(), null, null).getValue();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"requestConditions.ifMatch\",\n+                        ConcurrencyControl.NONE.toString(), ConcurrencyControl.ETAG.toString()));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"client.versionId\",\n+                        ConcurrencyControl.NONE.toString(), ConcurrencyControl.VERSION_ID.toString()));\n+                }\n+                break;\n+            case ETAG:\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"client.versionId\",\n+                        ConcurrencyControl.ETAG.toString(), ConcurrencyControl.VERSION_ID.toString()));\n+                }\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"requestConditions.ifMatch\",\n+                        ConcurrencyControl.VERSION_ID.toString(), ConcurrencyControl.ETAG.toString()));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe4699c480aa71aeb9d7a89359722493b6fa9f54"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3MzU1OQ==", "bodyText": "I think only etag is checked because we only lock on the etag. The other request conditions are only used in the initial get properties and then will be replaced by the etag (if that's the control type specified). Although I can see how it might be odd to specify LMT and version at the same time....", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535473559", "createdAt": "2020-12-03T18:19:54Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,71 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.ETAG\n+            : options.getConcurrencyControl();\n \n-        BlobProperties properties = getProperties();\n+        BlobProperties properties = getPropertiesWithResponse(options.getRequestConditions(), null, null).getValue();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"requestConditions.ifMatch\",\n+                        ConcurrencyControl.NONE.toString(), ConcurrencyControl.ETAG.toString()));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"client.versionId\",\n+                        ConcurrencyControl.NONE.toString(), ConcurrencyControl.VERSION_ID.toString()));\n+                }\n+                break;\n+            case ETAG:\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"client.versionId\",\n+                        ConcurrencyControl.ETAG.toString(), ConcurrencyControl.VERSION_ID.toString()));\n+                }\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"requestConditions.ifMatch\",\n+                        ConcurrencyControl.VERSION_ID.toString(), ConcurrencyControl.ETAG.toString()));\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzI1MQ=="}, "originalCommit": {"oid": "fe4699c480aa71aeb9d7a89359722493b6fa9f54"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4MTA2Ng==", "bodyText": "Maybe they just want that extra level of assurance :P", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535481066", "createdAt": "2020-12-03T18:29:59Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,71 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConcurrencyControl concurrencyControl = options.getConcurrencyControl() == null ? ConcurrencyControl.ETAG\n+            : options.getConcurrencyControl();\n \n-        BlobProperties properties = getProperties();\n+        BlobProperties properties = getPropertiesWithResponse(options.getRequestConditions(), null, null).getValue();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (concurrencyControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"requestConditions.ifMatch\",\n+                        ConcurrencyControl.NONE.toString(), ConcurrencyControl.ETAG.toString()));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"client.versionId\",\n+                        ConcurrencyControl.NONE.toString(), ConcurrencyControl.VERSION_ID.toString()));\n+                }\n+                break;\n+            case ETAG:\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"client.versionId\",\n+                        ConcurrencyControl.ETAG.toString(), ConcurrencyControl.VERSION_ID.toString()));\n+                }\n+                // Target the user specified eTag by default. If not provided, target the latest eTag.\n+                if (requestConditions.getIfMatch() == null) {\n+                    requestConditions.setIfMatch(eTag);\n+                }\n+                break;\n+            case VERSION_ID:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateControlException(\"requestConditions.ifMatch\",\n+                        ConcurrencyControl.VERSION_ID.toString(), ConcurrencyControl.ETAG.toString()));\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzI1MQ=="}, "originalCommit": {"oid": "fe4699c480aa71aeb9d7a89359722493b6fa9f54"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTY2Njk2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODozNjozNVrOH-ra3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMTo1Nzo1NFrOICrYuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4NTE0OA==", "bodyText": "Rewrite these docs", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535485148", "createdAt": "2020-12-03T18:36:35Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf5d119b830ca3486aff335d068a78e487f33a84"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3ODkwNA==", "bodyText": "Done", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539678904", "createdAt": "2020-12-09T21:57:54Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConcurrencyControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No concurrency control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4NTE0OA=="}, "originalCommit": {"oid": "cf5d119b830ca3486aff335d068a78e487f33a84"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTc2ODg1OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOTowMDoyM1rOH-sZ2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxOToxMTo1NVrOH-s1Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMTI3Mg==", "bodyText": "If someone is using both versionid and ifmatch condition this is going to break them.\nMaybe we shouldn't default to \"ETAG\" few lines above but rather apply this switch block only if consistency controll was explicitly set. Otherwise use old logic?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535501272", "createdAt": "2020-12-03T19:00:23Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,71 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConsistentReadControl consistentReadControl = options.getConsistentReadControl() == null ? ConsistentReadControl.ETAG\n+            : options.getConsistentReadControl();\n \n-        BlobProperties properties = getProperties();\n+        BlobProperties properties = getPropertiesWithResponse(options.getRequestConditions(), null, null).getValue();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (consistentReadControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateConsistentReadControlException(\"requestConditions.ifMatch\",\n+                        ConsistentReadControl.NONE.toString(), ConsistentReadControl.ETAG.toString()));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateConsistentReadControlException(\"client.versionId\",\n+                        ConsistentReadControl.NONE.toString(), ConsistentReadControl.VERSION_ID.toString()));\n+                }\n+                break;\n+            case ETAG:\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateConsistentReadControlException(\"client.versionId\",\n+                        ConsistentReadControl.ETAG.toString(), ConsistentReadControl.VERSION_ID.toString()));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf5d119b830ca3486aff335d068a78e487f33a84"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwODIyNw==", "bodyText": "I think Rick and I already talked about this - there really is no reason to be using both version and ifMatch conditions (since theyre basically duplicating work).", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r535508227", "createdAt": "2020-12-03T19:11:55Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/specialized/BlobClientBase.java", "diffHunk": "@@ -261,23 +262,71 @@ public final BlobInputStream openInputStream(BlobRange range, BlobRequestConditi\n      */\n     public BlobInputStream openInputStream(BlobInputStreamOptions options) {\n         options = options == null ? new BlobInputStreamOptions() : options;\n+        ConsistentReadControl consistentReadControl = options.getConsistentReadControl() == null ? ConsistentReadControl.ETAG\n+            : options.getConsistentReadControl();\n \n-        BlobProperties properties = getProperties();\n+        BlobProperties properties = getPropertiesWithResponse(options.getRequestConditions(), null, null).getValue();\n+        String eTag = properties.getETag();\n+        String versionId = properties.getVersionId();\n \n         BlobRange range = options.getRange() == null ? new BlobRange(0) : options.getRange();\n         int chunkSize = options.getBlockSize() == null ? 4 * Constants.MB : options.getBlockSize();\n \n         BlobRequestConditions requestConditions = options.getRequestConditions() == null\n             ? new BlobRequestConditions() : options.getRequestConditions();\n-        // Target the user specified version by default. If not provided, target the latest version.\n-        if (requestConditions.getIfMatch() == null) {\n-            requestConditions.setIfMatch(properties.getETag());\n+        BlobAsyncClientBase client = this.client;\n+\n+        switch (consistentReadControl) {\n+            case NONE:\n+                if (requestConditions.getIfMatch() != null) {\n+                    throw logger.logExceptionAsError(generateConsistentReadControlException(\"requestConditions.ifMatch\",\n+                        ConsistentReadControl.NONE.toString(), ConsistentReadControl.ETAG.toString()));\n+                }\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateConsistentReadControlException(\"client.versionId\",\n+                        ConsistentReadControl.NONE.toString(), ConsistentReadControl.VERSION_ID.toString()));\n+                }\n+                break;\n+            case ETAG:\n+                if (this.client.getVersionId() != null) {\n+                    throw logger.logExceptionAsError(generateConsistentReadControlException(\"client.versionId\",\n+                        ConsistentReadControl.ETAG.toString(), ConsistentReadControl.VERSION_ID.toString()));\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUwMTI3Mg=="}, "originalCommit": {"oid": "cf5d119b830ca3486aff335d068a78e487f33a84"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODA4Mzc4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDowMzo0OFrOICnDlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQyMjozODo1OFrOIES1gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzk1OQ==", "bodyText": "I think we should also have a case where readControl.ETAG is set, but no request conditions are passed to ensure we will pick the latest etag if none is specified.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539607959", "createdAt": "2020-12-09T20:03:48Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control etag\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when: \"Use recent eTag\"\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        def outputStream = new ByteArrayOutputStream()\n+        def b\n+        try {\n+            while ((b = inputStream.read()) != -1) {\n+                outputStream.write(b)\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex)\n+        }\n+        byte[] randomBytes2 = outputStream.toByteArray()\n+        assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMDE1Ng==", "bodyText": "And some validation that etag and version can't both be set for both the etag and version options.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539610156", "createdAt": "2020-12-09T20:07:12Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control etag\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when: \"Use recent eTag\"\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        def outputStream = new ByteArrayOutputStream()\n+        def b\n+        try {\n+            while ((b = inputStream.read()) != -1) {\n+                outputStream.write(b)\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex)\n+        }\n+        byte[] randomBytes2 = outputStream.toByteArray()\n+        assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzk1OQ=="}, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3OTcxNw==", "bodyText": "I think that is what \"Input stream etag lock default\" tests for. I can add tests for the etag and version set at same time ones", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539679717", "createdAt": "2020-12-09T21:59:19Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control etag\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when: \"Use recent eTag\"\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        def outputStream = new ByteArrayOutputStream()\n+        def b\n+        try {\n+            while ((b = inputStream.read()) != -1) {\n+                outputStream.write(b)\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex)\n+        }\n+        byte[] randomBytes2 = outputStream.toByteArray()\n+        assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzk1OQ=="}, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM3MzgyNg==", "bodyText": "Added the other tests too", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r541373826", "createdAt": "2020-12-11T22:38:58Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control etag\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when: \"Use recent eTag\"\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        def outputStream = new ByteArrayOutputStream()\n+        def b\n+        try {\n+            while ((b = inputStream.read()) != -1) {\n+                outputStream.write(b)\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex)\n+        }\n+        byte[] randomBytes2 = outputStream.toByteArray()\n+        assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzk1OQ=="}, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODA5Mzg0OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDowNjowOFrOICnJiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMjowMDo0NFrOICre0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwOTQ4MQ==", "bodyText": "why is this necessary?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539609481", "createdAt": "2020-12-09T20:06:08Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control etag\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when: \"Use recent eTag\"\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        def outputStream = new ByteArrayOutputStream()\n+        def b\n+        try {\n+            while ((b = inputStream.read()) != -1) {\n+                outputStream.write(b)\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MDIwMw==", "bodyText": "Not too sure, this was a copy paste from another test that exists. I can just rethrow the exception", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539680203", "createdAt": "2020-12-09T22:00:10Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control etag\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when: \"Use recent eTag\"\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        def outputStream = new ByteArrayOutputStream()\n+        def b\n+        try {\n+            while ((b = inputStream.read()) != -1) {\n+                outputStream.write(b)\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwOTQ4MQ=="}, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MDQ2Ng==", "bodyText": "Actually we dont even need to catch since groovy doesnt care", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539680466", "createdAt": "2020-12-09T22:00:44Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control etag\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when: \"Use recent eTag\"\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        def outputStream = new ByteArrayOutputStream()\n+        def b\n+        try {\n+            while ((b = inputStream.read()) != -1) {\n+                outputStream.write(b)\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwOTQ4MQ=="}, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODEwMTQ2OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDowNzo1NlrOICnN3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMjo1NzowM1rOICtUOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMDU5MA==", "bodyText": "Why do these have to be live mode?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539610590", "createdAt": "2020-12-09T20:07:56Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcxMDUyMQ==", "bodyText": "just fixed this", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r539710521", "createdAt": "2020-12-09T22:57:03Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -173,4 +174,149 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         then:\n         thrown(IOException)\n     }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        BlobOutputStream outStream = bc.getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        // Read from the input stream\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        outStream = bc.getBlobOutputStream(true)\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    @Requires({ liveMode() })\n+    def \"Input stream concurrency control none error\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        BlobOutputStream outStream = blobClient.getBlockBlobClient().getBlobOutputStream()\n+        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n+        outStream.close()\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+\n+        when:\n+        blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+\n+        then:\n+        thrown(UnsupportedOperationException)\n+    }\n+\n+    @Requires({ liveMode() })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMDU5MA=="}, "originalCommit": {"oid": "cb28fc7374c60a52de919f2de91bd7b76f3748e9"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzOTgyMzY3OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxOTozMDowOVrOIYGhYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxOTozMDowOVrOIYGhYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0MzU4Ng==", "bodyText": "locking on etag means we will throw if it changes in the meantime", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562143586", "createdAt": "2021-01-21T19:30:09Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No consistent read control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Consistent read control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6a404e7250922e8b81c6f0333830a5d8f9fc31"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzOTgzMDU3OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxOTozMjowOVrOIYGlxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxOTozMjowOVrOIYGlxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0NDcxMQ==", "bodyText": "locking on version means you get a consisten read on blob without throwing if it vhanges in the meantime", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562144711", "createdAt": "2021-01-21T19:32:09Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No consistent read control. 'requestConditions.ifMatch' and 'client.versionId' must not be set.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Consistent read control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     */\n+    ETAG,\n+\n+    /**\n+     * Consistent control based on versionId. Note: Versioning must be supported by the account to use this value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e6a404e7250922e8b81c6f0333830a5d8f9fc31"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NDEzMzAzOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzo1MDo0NFrOIYuspQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzo1MDo0NFrOIYuspQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwMTgyOQ==", "bodyText": "nit: Should we call out specific exception type that will be thrown?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562801829", "createdAt": "2021-01-22T17:50:44Z", "author": {"login": "kasobol-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,38 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No consistent read control. The client will honor user provided {@link BlobRequestConditions#getIfMatch()} and\n+     * {@link BlobClient#getVersionId()}.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Consistent read control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     * Note: Modification of the base blob will result in an {@code Exception} if eTag is the only form of consistent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NDIzNDczOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODoxNDo0N1rOIYvvXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODoxNDo0N1rOIYvvXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxODkwOQ==", "bodyText": "I think we should add a bit more here: \"Defines values to indicate what strategy the sdk should use when reading from a blob to ensure the view of the data is consistent and not changed during the read.\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562818909", "createdAt": "2021-01-22T18:14:47Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,38 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NDIzOTc3OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODoxNjowOFrOIYvyhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODoxNjowOFrOIYvyhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxOTcxOA==", "bodyText": "\"... but it may no longer be the latest data.\"", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562819718", "createdAt": "2021-01-22T18:16:08Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/storage/blob/models/ConsistentReadControl.java", "diffHunk": "@@ -0,0 +1,38 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.blob.models;\n+\n+import com.azure.storage.blob.BlobClient;\n+\n+/**\n+ * Defines values for ConsistentReadControl.\n+ * {@link #NONE}\n+ * {@link #ETAG}\n+ * {@link #VERSION_ID}\n+ */\n+public enum ConsistentReadControl {\n+    /**\n+     * No consistent read control. The client will honor user provided {@link BlobRequestConditions#getIfMatch()} and\n+     * {@link BlobClient#getVersionId()}.\n+     */\n+    NONE,\n+\n+    /**\n+     * Default value. Consistent read control based on eTag.\n+     * If {@link BlobRequestConditions#getIfMatch()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobRequestConditions#getIfMatch()} is set to the latest eTag.\n+     * Note: Modification of the base blob will result in an {@code Exception} if eTag is the only form of consistent\n+     * read control being employed.\n+     */\n+    ETAG,\n+\n+    /**\n+     * Consistent control based on versionId. Note: Versioning must be supported by the account to use this value.\n+     * If {@link BlobClient#getVersionId()} is set, the client will honor this value.\n+     * Otherwise, {@link BlobClient#getVersionId()} is set to the latest versionId.\n+     * Note: Modification of the base blob will not result in an {@code Exception} and allow you to continue reading the\n+     * entirety of the appropriate version of the blob determined at the time of opening the {@code InputStream}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NDMyODUxOnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0MToyNVrOIYwpXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0NTowOVrOIYwxCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzMzc1Ng==", "bodyText": "I think we should try modifying and check for failure on these after we get success to make sure that it's actually getting set.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562833756", "createdAt": "2021-01-22T18:41:25Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -147,30 +148,308 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n     }\n \n-    // Only run this test in live mode as BlobOutputStream dynamically assigns blocks\n-    @Requires({ liveMode() })\n-    def \"Input stream etag lock\"() {\n+    def \"Input stream etag lock default\"() {\n         setup:\n         int length = 6 * Constants.MB\n         byte[] randomBytes = getRandomByteArray(length)\n-        BlobOutputStream outStream = bc.getBlobOutputStream()\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        // Read from the input stream\n+        // Create the input stream and read from it.\n         // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n         def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1))\n         inputStream.read()\n \n         // Modify the blob again.\n-        outStream = bc.getBlobOutputStream(true)\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        when:\n+        when: \"Reading after etag has been changed\"\n         inputStream.read()\n \n         then:\n         thrown(IOException)\n     }\n+\n+    def \"IS consistent read control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        // Create the input stream and read from it.\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    def \"IS consistent read control etag client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No eTag specified - client will lock on latest one.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNTcyMQ==", "bodyText": "I see there's an error case below now.", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562835721", "createdAt": "2021-01-22T18:45:09Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -147,30 +148,308 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n     }\n \n-    // Only run this test in live mode as BlobOutputStream dynamically assigns blocks\n-    @Requires({ liveMode() })\n-    def \"Input stream etag lock\"() {\n+    def \"Input stream etag lock default\"() {\n         setup:\n         int length = 6 * Constants.MB\n         byte[] randomBytes = getRandomByteArray(length)\n-        BlobOutputStream outStream = bc.getBlobOutputStream()\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        // Read from the input stream\n+        // Create the input stream and read from it.\n         // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n         def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1))\n         inputStream.read()\n \n         // Modify the blob again.\n-        outStream = bc.getBlobOutputStream(true)\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        when:\n+        when: \"Reading after etag has been changed\"\n         inputStream.read()\n \n         then:\n         thrown(IOException)\n     }\n+\n+    def \"IS consistent read control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        // Create the input stream and read from it.\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    def \"IS consistent read control etag client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No eTag specified - client will lock on latest one.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzMzc1Ng=="}, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NDMzMzg4OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0MzowN1rOIYws3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxOTo1MTowN1rOIYy6xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNDY1NQ==", "bodyText": "Is this true if the specify etag? Or does the etag on the version also get locked so they'll always match?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562834655", "createdAt": "2021-01-22T18:43:07Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -147,30 +148,308 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n     }\n \n-    // Only run this test in live mode as BlobOutputStream dynamically assigns blocks\n-    @Requires({ liveMode() })\n-    def \"Input stream etag lock\"() {\n+    def \"Input stream etag lock default\"() {\n         setup:\n         int length = 6 * Constants.MB\n         byte[] randomBytes = getRandomByteArray(length)\n-        BlobOutputStream outStream = bc.getBlobOutputStream()\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        // Read from the input stream\n+        // Create the input stream and read from it.\n         // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n         def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1))\n         inputStream.read()\n \n         // Modify the blob again.\n-        outStream = bc.getBlobOutputStream(true)\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        when:\n+        when: \"Reading after etag has been changed\"\n         inputStream.read()\n \n         then:\n         thrown(IOException)\n     }\n+\n+    def \"IS consistent read control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        // Create the input stream and read from it.\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    def \"IS consistent read control etag client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No eTag specified - client will lock on latest one.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version and etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+        // When a versioned client is used it should still succeed if the blob has been modified", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg3MDk4MA==", "bodyText": "Since the user specifies the version client - we do a getProperties on that version so we get back the etag for that version so it works right. Does that make sense?\nIf they specify the etag and it is correct - it'll work. If its wrong it will fail as usual and the service will handle that", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562870980", "createdAt": "2021-01-22T19:51:07Z", "author": {"login": "gapra-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -147,30 +148,308 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n     }\n \n-    // Only run this test in live mode as BlobOutputStream dynamically assigns blocks\n-    @Requires({ liveMode() })\n-    def \"Input stream etag lock\"() {\n+    def \"Input stream etag lock default\"() {\n         setup:\n         int length = 6 * Constants.MB\n         byte[] randomBytes = getRandomByteArray(length)\n-        BlobOutputStream outStream = bc.getBlobOutputStream()\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        // Read from the input stream\n+        // Create the input stream and read from it.\n         // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n         def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1))\n         inputStream.read()\n \n         // Modify the blob again.\n-        outStream = bc.getBlobOutputStream(true)\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        when:\n+        when: \"Reading after etag has been changed\"\n         inputStream.read()\n \n         then:\n         thrown(IOException)\n     }\n+\n+    def \"IS consistent read control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        // Create the input stream and read from it.\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    def \"IS consistent read control etag client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No eTag specified - client will lock on latest one.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version and etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+        // When a versioned client is used it should still succeed if the blob has been modified", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNDY1NQ=="}, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0NDM1Nzg1OnYy", "diffSide": "RIGHT", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0OTo1NFrOIYw7_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODo0OTo1NFrOIYw7_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzODUyNQ==", "bodyText": "Can we do another upload after we get the properties to force this version to be different from the latest at the time of constructing the stream?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17908#discussion_r562838525", "createdAt": "2021-01-22T18:49:54Z", "author": {"login": "rickle-msft"}, "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/storage/blob/BlockBlobInputOutputStreamTest.groovy", "diffHunk": "@@ -147,30 +148,308 @@ class BlockBlobInputOutputStreamTest extends APISpec {\n         assert randomBytes2 == Arrays.copyOfRange(randomBytes, 1 * Constants.MB, 6 * Constants.MB)\n     }\n \n-    // Only run this test in live mode as BlobOutputStream dynamically assigns blocks\n-    @Requires({ liveMode() })\n-    def \"Input stream etag lock\"() {\n+    def \"Input stream etag lock default\"() {\n         setup:\n         int length = 6 * Constants.MB\n         byte[] randomBytes = getRandomByteArray(length)\n-        BlobOutputStream outStream = bc.getBlobOutputStream()\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        // Read from the input stream\n+        // Create the input stream and read from it.\n         // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n         def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1))\n         inputStream.read()\n \n         // Modify the blob again.\n-        outStream = bc.getBlobOutputStream(true)\n-        outStream.write(randomBytes, 1 * Constants.MB, 5 * Constants.MB)\n-        outStream.close()\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n \n-        when:\n+        when: \"Reading after etag has been changed\"\n         inputStream.read()\n \n         then:\n         thrown(IOException)\n     }\n+\n+    def \"IS consistent read control none\"() {\n+        setup:\n+        int length = 6 * Constants.MB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        // Create the input stream and read from it.\n+        // Note: Setting block size to 1 is inefficient but helps demonstrate the purpose of this test.\n+        def inputStream = bc.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.NONE))\n+        inputStream.read()\n+\n+        // Modify the blob again.\n+        bc.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        inputStream.read()\n+\n+        then: \"Exception should not be thrown even though blob was modified\"\n+        notThrown(IOException)\n+    }\n+\n+    def \"IS consistent read control etag client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No eTag specified - client will lock on latest one.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version and etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG)\n+        // User provides eTag to use\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    def \"IS consistent read control etag user provides version client chooses etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        // User provides version client\n+        def inputStream = blobClient.getVersionClient(properties.getVersionId()).openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.ETAG))\n+        def outputStream = new ByteArrayOutputStream()\n+        // When a versioned client is used it should still succeed if the blob has been modified\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        then: \"Successful read\"\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+\n+        byte[] randomBytes1 = outputStream.toByteArray()\n+        assert randomBytes1 == randomBytes\n+    }\n+\n+    // Error case\n+    def \"IS consistent read control etag user provides old etag\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+\n+        when:\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setBlockSize(1).setConsistentReadControl(ConsistentReadControl.ETAG)\n+            .setRequestConditions(new BlobRequestConditions().setIfMatch(properties.getETag())))\n+\n+        // Since eTag is the only form of consistentReadControl and the blob is modified, we will throw.\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        inputStream.read()\n+\n+        then: \"Failed read\"\n+        thrown(IOException) // BlobStorageException = ConditionNotMet\n+    }\n+\n+    def \"IS consistent read control version client chooses version\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+\n+        when:\n+        // No version specified - client will lock on it.\n+        def inputStream = blobClient.openInputStream(new BlobInputStreamOptions().setConsistentReadControl(ConsistentReadControl.VERSION_ID))\n+        def outputStream = new ByteArrayOutputStream()\n+\n+        // When a versioned client is used it should still succeed if the blob has been modified\n+        blobClient.upload(new ByteArrayInputStream(getRandomByteArray(length)), length, true)\n+\n+        then:\n+        def b\n+        while ((b = inputStream.read()) != -1) {\n+            outputStream.write(b)\n+        }\n+        byte[] randomBytes2 = outputStream.toByteArray()\n+        assert randomBytes2 == randomBytes\n+    }\n+\n+    def \"IS consistent read control version user provides version\"() {\n+        setup:\n+        int length = Constants.KB\n+        byte[] randomBytes = getRandomByteArray(length)\n+        def blobContainerClient = versionedBlobServiceClient.createBlobContainer(containerName)\n+        def blobClient = blobContainerClient.getBlobClient(generateBlobName())\n+        blobClient.upload(new ByteArrayInputStream(randomBytes), length, true)\n+        def properties = blobClient.getProperties()\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fff06c1c940056706a5a5c185788e0190f171dab"}, "originalPosition": 221}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2757, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}