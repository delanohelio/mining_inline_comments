{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxMzM5ODk1", "number": 18182, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOTozMzozOVrOFGXKVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMjoxNTo1NlrOFHXN6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjE1MjU1OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/StoreReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOTozMzozOVrOIHVyJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOTozMzozOVrOIHVyJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU2Nzg0NA==", "bodyText": "nit: same line", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18182#discussion_r544567844", "createdAt": "2020-12-16T19:33:39Z", "author": {"login": "xinlian12"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/StoreReader.java", "diffHunk": "@@ -656,6 +649,33 @@ private ReadReplicaResult createReadReplicaResult(List<StoreResult> responseResu\n         return task;\n     }\n \n+    StoreResult createAndRecordStoreResult(\n+        RxDocumentServiceRequest request,\n+        StoreResponse storeResponse,\n+        Exception responseException,\n+        boolean requiresValidLsn,\n+        boolean useLocalLSNBasedHeaders,\n+        Uri storePhysicalAddress) {\n+\n+        StoreResult storeResult = this.createStoreResult(storeResponse, responseException, requiresValidLsn, useLocalLSNBasedHeaders, storePhysicalAddress);\n+\n+        try {\n+            BridgeInternal.recordResponse(request.requestContext.cosmosDiagnostics, request, storeResult);\n+            if (request.requestContext.requestChargeTracker != null) {\n+                request.requestContext.requestChargeTracker.addCharge(storeResult.requestCharge);\n+            }\n+        }\n+        catch (Exception e){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "181b1174411889178043328895a8663934cb066e"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjY3MjcyOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/StoreReader.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTo0NTo1NFrOIHahUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMzowMTo1NFrOII1YKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0NTQ1Ng==", "bodyText": "There is one problem observed if throw exception here: based on the current logic, we may do not record the response from other replicas:\nList<Flux> storeResult = readStoreTasks\n.stream()\n.map(item -> toStoreResult(entity, item, readMode, requiresValidLsn))\n.collect(Collectors.toList());\nFlux allStoreResults = Flux.merge(storeResult);\nreturn allStoreResults.collectList().onErrorResume(e -> {\nTwo solutions can think of now:\n\ndo not do verifyCanContinueOnException check when create and record store results, add the logic after get all store results\nInstead of Flux.merge, change to Flux.mergeDelayError", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18182#discussion_r544645456", "createdAt": "2020-12-16T21:45:54Z", "author": {"login": "xinlian12"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/StoreReader.java", "diffHunk": "@@ -656,6 +649,32 @@ private ReadReplicaResult createReadReplicaResult(List<StoreResult> responseResu\n         return task;\n     }\n \n+    StoreResult createAndRecordStoreResult(\n+        RxDocumentServiceRequest request,\n+        StoreResponse storeResponse,\n+        Exception responseException,\n+        boolean requiresValidLsn,\n+        boolean useLocalLSNBasedHeaders,\n+        Uri storePhysicalAddress) {\n+\n+        StoreResult storeResult = this.createStoreResult(storeResponse, responseException, requiresValidLsn, useLocalLSNBasedHeaders, storePhysicalAddress);\n+\n+        try {\n+            BridgeInternal.recordResponse(request.requestContext.cosmosDiagnostics, request, storeResult);\n+            if (request.requestContext.requestChargeTracker != null) {\n+                request.requestContext.requestChargeTracker.addCharge(storeResult.requestCharge);\n+            }\n+        } catch (Exception e){\n+            logger.error(\"Unexpected failure while recording response\", e);\n+        }\n+\n+        if (responseException !=null) {\n+            verifyCanContinueOnException(storeResult.getException());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f03f046474350360aab314084ef88ce668a0cec3"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNDcwNA==", "bodyText": "I think its fine to continue with current logic , because we are not interested in result of other replica in case of these exceptions and break the flow", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18182#discussion_r546114704", "createdAt": "2020-12-18T22:10:37Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/StoreReader.java", "diffHunk": "@@ -656,6 +649,32 @@ private ReadReplicaResult createReadReplicaResult(List<StoreResult> responseResu\n         return task;\n     }\n \n+    StoreResult createAndRecordStoreResult(\n+        RxDocumentServiceRequest request,\n+        StoreResponse storeResponse,\n+        Exception responseException,\n+        boolean requiresValidLsn,\n+        boolean useLocalLSNBasedHeaders,\n+        Uri storePhysicalAddress) {\n+\n+        StoreResult storeResult = this.createStoreResult(storeResponse, responseException, requiresValidLsn, useLocalLSNBasedHeaders, storePhysicalAddress);\n+\n+        try {\n+            BridgeInternal.recordResponse(request.requestContext.cosmosDiagnostics, request, storeResult);\n+            if (request.requestContext.requestChargeTracker != null) {\n+                request.requestContext.requestChargeTracker.addCharge(storeResult.requestCharge);\n+            }\n+        } catch (Exception e){\n+            logger.error(\"Unexpected failure while recording response\", e);\n+        }\n+\n+        if (responseException !=null) {\n+            verifyCanContinueOnException(storeResult.getException());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0NTQ1Ng=="}, "originalCommit": {"oid": "f03f046474350360aab314084ef88ce668a0cec3"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExODg4NQ==", "bodyText": "Good observation: I would prefer option 2) - but am not quite sure yet whether there are certain scenarios - like 429 from only a subset of replicas - where this could negatively impact latency. My assumption is that the impact is negligible and 2) looks cleaner to me - so my vote would be for 2)\n@simplynaveen20  / @moderakh - what do you think?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18182#discussion_r546118885", "createdAt": "2020-12-18T22:23:01Z", "author": {"login": "FabianMeiswinkel"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/StoreReader.java", "diffHunk": "@@ -656,6 +649,32 @@ private ReadReplicaResult createReadReplicaResult(List<StoreResult> responseResu\n         return task;\n     }\n \n+    StoreResult createAndRecordStoreResult(\n+        RxDocumentServiceRequest request,\n+        StoreResponse storeResponse,\n+        Exception responseException,\n+        boolean requiresValidLsn,\n+        boolean useLocalLSNBasedHeaders,\n+        Uri storePhysicalAddress) {\n+\n+        StoreResult storeResult = this.createStoreResult(storeResponse, responseException, requiresValidLsn, useLocalLSNBasedHeaders, storePhysicalAddress);\n+\n+        try {\n+            BridgeInternal.recordResponse(request.requestContext.cosmosDiagnostics, request, storeResult);\n+            if (request.requestContext.requestChargeTracker != null) {\n+                request.requestContext.requestChargeTracker.addCharge(storeResult.requestCharge);\n+            }\n+        } catch (Exception e){\n+            logger.error(\"Unexpected failure while recording response\", e);\n+        }\n+\n+        if (responseException !=null) {\n+            verifyCanContinueOnException(storeResult.getException());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0NTQ1Ng=="}, "originalCommit": {"oid": "f03f046474350360aab314084ef88ce668a0cec3"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEzNDA1OQ==", "bodyText": "We don't need either of these two options, earlier code was also not caring about other replica responses in case of certain exceptions. Its like fire and forget if we hit error in any replica , we don't care about the response from other replica. In case of multiple responses come successfully  together before this code , we will have multiple store result in diagnostics , which is also fine.\nSo i don't think any code change is needed and above two options have unnecessary perf implication . Have offline conversation with Annie on this", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18182#discussion_r546134059", "createdAt": "2020-12-18T23:01:54Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/StoreReader.java", "diffHunk": "@@ -656,6 +649,32 @@ private ReadReplicaResult createReadReplicaResult(List<StoreResult> responseResu\n         return task;\n     }\n \n+    StoreResult createAndRecordStoreResult(\n+        RxDocumentServiceRequest request,\n+        StoreResponse storeResponse,\n+        Exception responseException,\n+        boolean requiresValidLsn,\n+        boolean useLocalLSNBasedHeaders,\n+        Uri storePhysicalAddress) {\n+\n+        StoreResult storeResult = this.createStoreResult(storeResponse, responseException, requiresValidLsn, useLocalLSNBasedHeaders, storePhysicalAddress);\n+\n+        try {\n+            BridgeInternal.recordResponse(request.requestContext.cosmosDiagnostics, request, storeResult);\n+            if (request.requestContext.requestChargeTracker != null) {\n+                request.requestContext.requestChargeTracker.addCharge(storeResult.requestCharge);\n+            }\n+        } catch (Exception e){\n+            logger.error(\"Unexpected failure while recording response\", e);\n+        }\n+\n+        if (responseException !=null) {\n+            verifyCanContinueOnException(storeResult.getException());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0NTQ1Ng=="}, "originalCommit": {"oid": "f03f046474350360aab314084ef88ce668a0cec3"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjY0MTAxOnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/StoreReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMjoxMzoyOFrOII0QJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMjoxMzoyOFrOII0QJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNTYyMA==", "bodyText": "why this null check ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18182#discussion_r546115620", "createdAt": "2020-12-18T22:13:28Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/StoreReader.java", "diffHunk": "@@ -849,6 +867,10 @@ private static int generateNextRandom(int maxValue) {\n     }\n \n     static void verifyCanContinueOnException(CosmosException ex) {\n+        if (ex == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f03f046474350360aab314084ef88ce668a0cec3"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjY0NzQ0OnYy", "diffSide": "RIGHT", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/directconnectivity/ConsistencyWriterTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMjoxNTo1NlrOII0Ttg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMzowMDo0MVrOII1WRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjUzNA==", "bodyText": "if two replica reach the diagnostic capture block at same time then we will have two results ?", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18182#discussion_r546116534", "createdAt": "2020-12-18T22:15:56Z", "author": {"login": "simplynaveen20"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/directconnectivity/ConsistencyWriterTest.java", "diffHunk": "@@ -193,6 +205,53 @@ public void timeout2() throws Exception {\n         subscriber.assertError(RequestTimeoutException.class);\n     }\n \n+    @Test(groups = \"unit\", dataProvider = \"storeResponseArgProvider\")\n+    public void storeResponseRecordedOnException(Exception ex, StoreResponse storeResponse) {\n+        DiagnosticsClientContext clientContext = mockDiagnosticsClientContext();\n+        TransportClientWrapper transportClientWrapper;\n+\n+        if (ex != null) {\n+            transportClientWrapper = new TransportClientWrapper.Builder.ReplicaResponseBuilder\n+                .SequentialBuilder()\n+                .then(ex)\n+                .build();\n+        } else {\n+            transportClientWrapper = new TransportClientWrapper.Builder.ReplicaResponseBuilder\n+                .SequentialBuilder()\n+                .then(storeResponse)\n+                .build();\n+        }\n+\n+        Uri primaryUri = Uri.create(\"primary\");\n+        Uri secondaryUri1 = Uri.create(\"secondary1\");\n+        Uri secondaryUri2 = Uri.create(\"secondary2\");\n+        Uri secondaryUri3 = Uri.create(\"secondary3\");\n+\n+        AddressSelectorWrapper addressSelectorWrapper = AddressSelectorWrapper.Builder.Simple.create()\n+            .withPrimary(primaryUri)\n+            .withSecondary(ImmutableList.of(secondaryUri1, secondaryUri2, secondaryUri3))\n+            .build();\n+        sessionContainer = Mockito.mock(ISessionContainer.class);\n+        IAuthorizationTokenProvider authorizationTokenProvider = Mockito.mock(IAuthorizationTokenProvider.class);\n+        serviceConfigReader = Mockito.mock(GatewayServiceConfigurationReader.class);\n+\n+        consistencyWriter = new ConsistencyWriter(clientContext,\n+            addressSelectorWrapper.addressSelector,\n+            sessionContainer,\n+            transportClientWrapper.transportClient,\n+            authorizationTokenProvider,\n+            serviceConfigReader,\n+            false);\n+\n+        TimeoutHelper timeoutHelper = Mockito.mock(TimeoutHelper.class);\n+        RxDocumentServiceRequest dsr = mockDocumentServiceRequest(clientContext);\n+\n+        consistencyWriter.writeAsync(dsr, timeoutHelper, false).subscribe();\n+\n+        String cosmosDiagnostics = dsr.requestContext.cosmosDiagnostics.toString();\n+        assertThat(cosmosDiagnostics).containsOnlyOnce(\"storeResult\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f03f046474350360aab314084ef88ce668a0cec3"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEzMzU3Mg==", "bodyText": "since for write scenario, we will only contacted the primary replica, so it will only contain one replica.\nIn the StoreReader test, since it could happen we will record multiple results, so the check there is >=1", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18182#discussion_r546133572", "createdAt": "2020-12-18T23:00:41Z", "author": {"login": "xinlian12"}, "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/directconnectivity/ConsistencyWriterTest.java", "diffHunk": "@@ -193,6 +205,53 @@ public void timeout2() throws Exception {\n         subscriber.assertError(RequestTimeoutException.class);\n     }\n \n+    @Test(groups = \"unit\", dataProvider = \"storeResponseArgProvider\")\n+    public void storeResponseRecordedOnException(Exception ex, StoreResponse storeResponse) {\n+        DiagnosticsClientContext clientContext = mockDiagnosticsClientContext();\n+        TransportClientWrapper transportClientWrapper;\n+\n+        if (ex != null) {\n+            transportClientWrapper = new TransportClientWrapper.Builder.ReplicaResponseBuilder\n+                .SequentialBuilder()\n+                .then(ex)\n+                .build();\n+        } else {\n+            transportClientWrapper = new TransportClientWrapper.Builder.ReplicaResponseBuilder\n+                .SequentialBuilder()\n+                .then(storeResponse)\n+                .build();\n+        }\n+\n+        Uri primaryUri = Uri.create(\"primary\");\n+        Uri secondaryUri1 = Uri.create(\"secondary1\");\n+        Uri secondaryUri2 = Uri.create(\"secondary2\");\n+        Uri secondaryUri3 = Uri.create(\"secondary3\");\n+\n+        AddressSelectorWrapper addressSelectorWrapper = AddressSelectorWrapper.Builder.Simple.create()\n+            .withPrimary(primaryUri)\n+            .withSecondary(ImmutableList.of(secondaryUri1, secondaryUri2, secondaryUri3))\n+            .build();\n+        sessionContainer = Mockito.mock(ISessionContainer.class);\n+        IAuthorizationTokenProvider authorizationTokenProvider = Mockito.mock(IAuthorizationTokenProvider.class);\n+        serviceConfigReader = Mockito.mock(GatewayServiceConfigurationReader.class);\n+\n+        consistencyWriter = new ConsistencyWriter(clientContext,\n+            addressSelectorWrapper.addressSelector,\n+            sessionContainer,\n+            transportClientWrapper.transportClient,\n+            authorizationTokenProvider,\n+            serviceConfigReader,\n+            false);\n+\n+        TimeoutHelper timeoutHelper = Mockito.mock(TimeoutHelper.class);\n+        RxDocumentServiceRequest dsr = mockDocumentServiceRequest(clientContext);\n+\n+        consistencyWriter.writeAsync(dsr, timeoutHelper, false).subscribe();\n+\n+        String cosmosDiagnostics = dsr.requestContext.cosmosDiagnostics.toString();\n+        assertThat(cosmosDiagnostics).containsOnlyOnce(\"storeResult\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjExNjUzNA=="}, "originalCommit": {"oid": "f03f046474350360aab314084ef88ce668a0cec3"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2598, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}