{"pr_number": 4590, "pr_title": "fix(TDI-31777) : warning with special csv files", "pr_createdAt": "2020-04-03T12:20:53Z", "pr_url": "https://github.com/Talend/tdi-studio-se/pull/4590", "timeline": [{"oid": "767e0bc3c63f62d10418b3c19f80a41fde9fccee", "url": "https://github.com/Talend/tdi-studio-se/commit/767e0bc3c63f62d10418b3c19f80a41fde9fccee", "message": "fix(TDI-31777) : warning with special csv files", "committedDate": "2020-04-03T12:18:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MjIxNQ==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r403982215", "bodyText": "No warning if lineEnd is empty ?", "author": "ypiel-talend", "createdAt": "2020-04-06T10:20:10Z", "path": "main/plugins/org.talend.designer.components.libs/libs_src/talendcsv/src/main/java/com/talend/csv/CSVReader.java", "diffHunk": "@@ -0,0 +1,585 @@\n+package com.talend.csv;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.HashMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CSVReader {\n+\n+    private final static Logger log = LoggerFactory.getLogger(CSVReader.class);\n+\n+    private Reader reader;\n+    \n+    private char separator = ',';\n+\n+    private char quotechar = '\"';\n+    \n+    private char escapechar = '\"';\n+\n+    private String lineEnd;\n+\n+    private boolean skipEmptyRecords = false;\n+    \n+    private boolean trimWhitespace = true;\n+    \n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    \n+    private static final int FETCH_SIZE = 10 * 50;\n+    \n+    private char[] buffer = new char[FETCH_SIZE]; \n+    private int currentPosition = 0;\n+    private int bufferCount = 0;\n+    \n+    private boolean hasMoreData = true;\n+    \n+    private boolean hasNext = false;\n+    \n+    private boolean inColumn = false;\n+    \n+    private boolean escaping = false;\n+    \n+    private char previousChar = '\\0';\n+    \n+    private String[] values = new String[10];\n+    \n+    private HeadersReader headersReader = new HeadersReader();\n+    \n+    private int columnCount = 0;\n+    \n+    private boolean inQuote = false; \n+    \n+    private StringBuilder sb = new StringBuilder(16);\n+    \n+    private boolean storeRawRecord = false;\n+    private StringBuilder stringBuilder = new StringBuilder(16 * 10);\n+    private String rawRecord = \"\";\n+    \n+    public CSVReader(final String filename, final char separator, final String charset) throws IOException {\n+        this(new FileInputStream(filename), separator, charset);\n+    }\n+    \n+    public CSVReader(final InputStream inputStream, final char separator, final String charset) throws IOException {\n+        this(new UnicodeReader(inputStream, charset), separator);\n+    }\n+\n+    public CSVReader(final Reader reader, final char separator) {\n+        this.reader = new BufferedReader(reader,BUFFER_SIZE);\n+        this.separator = separator;\n+    }\n+    \n+    public static CSVReader parse(final String content) {\n+        if (content == null) {\n+            throw new IllegalArgumentException(\n+                    \"Parameter content can not be null.\");\n+        }\n+\n+        return new CSVReader(new StringReader(content),',');\n+    }\n+    \n+    public CSVReader setLineEnd(final String lineEnd) {\n+        if (\"\\n\".equals(lineEnd) || \"\\r\\n\".equals(lineEnd)) {\n+            this.lineEnd = null;\n+        }\n+        else {\n+            this.lineEnd = lineEnd;\n+            if (lineEnd != null && lineEnd.length() > 1) {", "originalCommit": "767e0bc3c63f62d10418b3c19f80a41fde9fccee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAxODM4Ng==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404018386", "bodyText": "right, replace by lineEnd.length() != 1", "author": "clesaec", "createdAt": "2020-04-06T11:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyMzkxMg==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404023912", "bodyText": "So the warning message is not relevent if empty line end...", "author": "ypiel-talend", "createdAt": "2020-04-06T11:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyOTkwMQ==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404029901", "bodyText": "changed", "author": "clesaec", "createdAt": "2020-04-06T11:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MjIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MjMzNA==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r403982334", "bodyText": "Add a comment to explain", "author": "ypiel-talend", "createdAt": "2020-04-06T10:20:21Z", "path": "main/plugins/org.talend.designer.components.libs/libs_src/talendcsv/src/main/java/com/talend/csv/CSVReader.java", "diffHunk": "@@ -0,0 +1,585 @@\n+package com.talend.csv;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.HashMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CSVReader {\n+\n+    private final static Logger log = LoggerFactory.getLogger(CSVReader.class);\n+\n+    private Reader reader;\n+    \n+    private char separator = ',';\n+\n+    private char quotechar = '\"';\n+    \n+    private char escapechar = '\"';\n+\n+    private String lineEnd;\n+\n+    private boolean skipEmptyRecords = false;\n+    \n+    private boolean trimWhitespace = true;\n+    \n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    \n+    private static final int FETCH_SIZE = 10 * 50;\n+    \n+    private char[] buffer = new char[FETCH_SIZE]; \n+    private int currentPosition = 0;\n+    private int bufferCount = 0;\n+    \n+    private boolean hasMoreData = true;\n+    \n+    private boolean hasNext = false;\n+    \n+    private boolean inColumn = false;\n+    \n+    private boolean escaping = false;\n+    \n+    private char previousChar = '\\0';\n+    \n+    private String[] values = new String[10];\n+    \n+    private HeadersReader headersReader = new HeadersReader();\n+    \n+    private int columnCount = 0;\n+    \n+    private boolean inQuote = false; \n+    \n+    private StringBuilder sb = new StringBuilder(16);\n+    \n+    private boolean storeRawRecord = false;\n+    private StringBuilder stringBuilder = new StringBuilder(16 * 10);\n+    private String rawRecord = \"\";\n+    \n+    public CSVReader(final String filename, final char separator, final String charset) throws IOException {\n+        this(new FileInputStream(filename), separator, charset);\n+    }\n+    \n+    public CSVReader(final InputStream inputStream, final char separator, final String charset) throws IOException {\n+        this(new UnicodeReader(inputStream, charset), separator);\n+    }\n+\n+    public CSVReader(final Reader reader, final char separator) {\n+        this.reader = new BufferedReader(reader,BUFFER_SIZE);\n+        this.separator = separator;\n+    }\n+    \n+    public static CSVReader parse(final String content) {\n+        if (content == null) {\n+            throw new IllegalArgumentException(\n+                    \"Parameter content can not be null.\");\n+        }\n+\n+        return new CSVReader(new StringReader(content),',');\n+    }\n+    \n+    public CSVReader setLineEnd(final String lineEnd) {\n+        if (\"\\n\".equals(lineEnd) || \"\\r\\n\".equals(lineEnd)) {\n+            this.lineEnd = null;", "originalCommit": "767e0bc3c63f62d10418b3c19f80a41fde9fccee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAxOTA4MQ==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404019081", "bodyText": "added", "author": "clesaec", "createdAt": "2020-04-06T11:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MjMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MzA4MQ==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r403983081", "bodyText": "NoneRFC or NotRFC but Non is french word", "author": "ypiel-talend", "createdAt": "2020-04-06T10:21:39Z", "path": "main/plugins/org.talend.designer.components.libs/libs_src/talendcsv/src/main/java/com/talend/csv/CSVReader.java", "diffHunk": "@@ -0,0 +1,585 @@\n+package com.talend.csv;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.HashMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CSVReader {\n+\n+    private final static Logger log = LoggerFactory.getLogger(CSVReader.class);\n+\n+    private Reader reader;\n+    \n+    private char separator = ',';\n+\n+    private char quotechar = '\"';\n+    \n+    private char escapechar = '\"';\n+\n+    private String lineEnd;\n+\n+    private boolean skipEmptyRecords = false;\n+    \n+    private boolean trimWhitespace = true;\n+    \n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    \n+    private static final int FETCH_SIZE = 10 * 50;\n+    \n+    private char[] buffer = new char[FETCH_SIZE]; \n+    private int currentPosition = 0;\n+    private int bufferCount = 0;\n+    \n+    private boolean hasMoreData = true;\n+    \n+    private boolean hasNext = false;\n+    \n+    private boolean inColumn = false;\n+    \n+    private boolean escaping = false;\n+    \n+    private char previousChar = '\\0';\n+    \n+    private String[] values = new String[10];\n+    \n+    private HeadersReader headersReader = new HeadersReader();\n+    \n+    private int columnCount = 0;\n+    \n+    private boolean inQuote = false; \n+    \n+    private StringBuilder sb = new StringBuilder(16);\n+    \n+    private boolean storeRawRecord = false;\n+    private StringBuilder stringBuilder = new StringBuilder(16 * 10);\n+    private String rawRecord = \"\";\n+    \n+    public CSVReader(final String filename, final char separator, final String charset) throws IOException {\n+        this(new FileInputStream(filename), separator, charset);\n+    }\n+    \n+    public CSVReader(final InputStream inputStream, final char separator, final String charset) throws IOException {\n+        this(new UnicodeReader(inputStream, charset), separator);\n+    }\n+\n+    public CSVReader(final Reader reader, final char separator) {\n+        this.reader = new BufferedReader(reader,BUFFER_SIZE);\n+        this.separator = separator;\n+    }\n+    \n+    public static CSVReader parse(final String content) {\n+        if (content == null) {\n+            throw new IllegalArgumentException(\n+                    \"Parameter content can not be null.\");\n+        }\n+\n+        return new CSVReader(new StringReader(content),',');\n+    }\n+    \n+    public CSVReader setLineEnd(final String lineEnd) {\n+        if (\"\\n\".equals(lineEnd) || \"\\r\\n\".equals(lineEnd)) {\n+            this.lineEnd = null;\n+        }\n+        else {\n+            this.lineEnd = lineEnd;\n+            if (lineEnd != null && lineEnd.length() > 1) {\n+                log.warn(\"Line end params {} is too long\", lineEnd);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public CSVReader setSeparator(final char separator) {\n+        this.separator = separator;\n+        return this;\n+    }\n+\n+    public CSVReader setEscapeChar(final char escapechar) {\n+        this.escapechar = escapechar;\n+        return this;\n+    }\n+    \n+    public CSVReader setQuoteChar(final char quotechar) {\n+        this.quotechar = quotechar;\n+        return this;\n+    }\n+    \n+    public char getQuoteChar() {\n+        return this.quotechar;\n+    }\n+    \n+    public CSVReader setTrimWhitespace(final boolean trimWhitespace) {\n+        this.trimWhitespace = trimWhitespace;\n+        return this;\n+    }\n+    \n+    public CSVReader setSkipEmptyRecords(final boolean skipEmptyRecords) {\n+        this.skipEmptyRecords = skipEmptyRecords;\n+        return this;\n+    }\n+    \n+    public CSVReader setStoreRawRecord(final boolean storeRawRecord) {\n+        this.storeRawRecord = storeRawRecord;\n+        return this;\n+    }\n+    \n+    public String getRawRecord() {\n+        return this.rawRecord;\n+    }\n+    \n+    public void endRecord() {\n+        this.hasNext = true;\n+    }\n+    \n+    public void endColumn() {\n+        this.inColumn = false;\n+        \n+        String currentValue = this.sb.toString();\n+        \n+        if(this.trimWhitespace && !this.inQuote) {\n+            currentValue = this.trimTail(currentValue);\n+        }\n+        \n+        if (this.columnCount == this.values.length) {\n+            final int newLength = this.values.length * 2;\n+\n+            final String[] holder = new String[newLength];\n+\n+            System.arraycopy(this.values, 0, holder, 0, this.values.length);\n+\n+            this.values = holder;\n+        }\n+\n+        this.values[this.columnCount] = currentValue;\n+\n+        this.columnCount++;\n+\n+        this.sb.setLength(0);\n+    }\n+    \n+    public boolean readNext() throws IOException {\n+        this.columnCount = 0;\n+        this.hasNext = false;\n+\n+        this.rawRecord = \"\";\n+        boolean warningNonRFC = false;", "originalCommit": "767e0bc3c63f62d10418b3c19f80a41fde9fccee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAxNzQ1MA==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404017450", "bodyText": "it can be english, like non-operating-incomes , non-english country  ....\ndictionnary https://dictionary.cambridge.org/dictionary/english/non ;)", "author": "clesaec", "createdAt": "2020-04-06T11:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MzA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4NDk2OQ==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r403984969", "bodyText": "...data will be ignored", "author": "ypiel-talend", "createdAt": "2020-04-06T10:24:57Z", "path": "main/plugins/org.talend.designer.components.libs/libs_src/talendcsv/src/main/java/com/talend/csv/CSVReader.java", "diffHunk": "@@ -0,0 +1,585 @@\n+package com.talend.csv;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.HashMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CSVReader {\n+\n+    private final static Logger log = LoggerFactory.getLogger(CSVReader.class);\n+\n+    private Reader reader;\n+    \n+    private char separator = ',';\n+\n+    private char quotechar = '\"';\n+    \n+    private char escapechar = '\"';\n+\n+    private String lineEnd;\n+\n+    private boolean skipEmptyRecords = false;\n+    \n+    private boolean trimWhitespace = true;\n+    \n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    \n+    private static final int FETCH_SIZE = 10 * 50;\n+    \n+    private char[] buffer = new char[FETCH_SIZE]; \n+    private int currentPosition = 0;\n+    private int bufferCount = 0;\n+    \n+    private boolean hasMoreData = true;\n+    \n+    private boolean hasNext = false;\n+    \n+    private boolean inColumn = false;\n+    \n+    private boolean escaping = false;\n+    \n+    private char previousChar = '\\0';\n+    \n+    private String[] values = new String[10];\n+    \n+    private HeadersReader headersReader = new HeadersReader();\n+    \n+    private int columnCount = 0;\n+    \n+    private boolean inQuote = false; \n+    \n+    private StringBuilder sb = new StringBuilder(16);\n+    \n+    private boolean storeRawRecord = false;\n+    private StringBuilder stringBuilder = new StringBuilder(16 * 10);\n+    private String rawRecord = \"\";\n+    \n+    public CSVReader(final String filename, final char separator, final String charset) throws IOException {\n+        this(new FileInputStream(filename), separator, charset);\n+    }\n+    \n+    public CSVReader(final InputStream inputStream, final char separator, final String charset) throws IOException {\n+        this(new UnicodeReader(inputStream, charset), separator);\n+    }\n+\n+    public CSVReader(final Reader reader, final char separator) {\n+        this.reader = new BufferedReader(reader,BUFFER_SIZE);\n+        this.separator = separator;\n+    }\n+    \n+    public static CSVReader parse(final String content) {\n+        if (content == null) {\n+            throw new IllegalArgumentException(\n+                    \"Parameter content can not be null.\");\n+        }\n+\n+        return new CSVReader(new StringReader(content),',');\n+    }\n+    \n+    public CSVReader setLineEnd(final String lineEnd) {\n+        if (\"\\n\".equals(lineEnd) || \"\\r\\n\".equals(lineEnd)) {\n+            this.lineEnd = null;\n+        }\n+        else {\n+            this.lineEnd = lineEnd;\n+            if (lineEnd != null && lineEnd.length() > 1) {\n+                log.warn(\"Line end params {} is too long\", lineEnd);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public CSVReader setSeparator(final char separator) {\n+        this.separator = separator;\n+        return this;\n+    }\n+\n+    public CSVReader setEscapeChar(final char escapechar) {\n+        this.escapechar = escapechar;\n+        return this;\n+    }\n+    \n+    public CSVReader setQuoteChar(final char quotechar) {\n+        this.quotechar = quotechar;\n+        return this;\n+    }\n+    \n+    public char getQuoteChar() {\n+        return this.quotechar;\n+    }\n+    \n+    public CSVReader setTrimWhitespace(final boolean trimWhitespace) {\n+        this.trimWhitespace = trimWhitespace;\n+        return this;\n+    }\n+    \n+    public CSVReader setSkipEmptyRecords(final boolean skipEmptyRecords) {\n+        this.skipEmptyRecords = skipEmptyRecords;\n+        return this;\n+    }\n+    \n+    public CSVReader setStoreRawRecord(final boolean storeRawRecord) {\n+        this.storeRawRecord = storeRawRecord;\n+        return this;\n+    }\n+    \n+    public String getRawRecord() {\n+        return this.rawRecord;\n+    }\n+    \n+    public void endRecord() {\n+        this.hasNext = true;\n+    }\n+    \n+    public void endColumn() {\n+        this.inColumn = false;\n+        \n+        String currentValue = this.sb.toString();\n+        \n+        if(this.trimWhitespace && !this.inQuote) {\n+            currentValue = this.trimTail(currentValue);\n+        }\n+        \n+        if (this.columnCount == this.values.length) {\n+            final int newLength = this.values.length * 2;\n+\n+            final String[] holder = new String[newLength];\n+\n+            System.arraycopy(this.values, 0, holder, 0, this.values.length);\n+\n+            this.values = holder;\n+        }\n+\n+        this.values[this.columnCount] = currentValue;\n+\n+        this.columnCount++;\n+\n+        this.sb.setLength(0);\n+    }\n+    \n+    public boolean readNext() throws IOException {\n+        this.columnCount = 0;\n+        this.hasNext = false;\n+\n+        this.rawRecord = \"\";\n+        boolean warningNonRFC = false;\n+        \n+        if(!this.hasMoreData) {\n+            return false;\n+        }\n+        \n+        while(this.hasMoreData && !this.hasNext) {\n+            if(this.arriveEnd()) {\n+                this.fill();\n+                continue;\n+            }\n+            \n+            char currentChar = this.buffer[this.currentPosition];\n+\n+            this.inQuote = false;\n+            \n+            if(this.quotechar !='\\0' && currentChar == this.quotechar) {//quote char as start of column\n+                this.inColumn = true;\n+                this.inQuote = true;\n+                this.currentPosition++;\n+                this.escaping = false;\n+                \n+                boolean previousCharAsQuote = false;\n+                boolean deleteTrailNoUseChars = false;\n+                \n+                if(this.storeRawRecord) {\n+                    this.stringBuilder.append(currentChar);\n+                }\n+                \n+                while(this.hasMoreData && this.inColumn) {\n+                    if(this.arriveEnd()) {\n+                        this.fill();\n+                        continue;\n+                    }\n+                    \n+                    currentChar = this.buffer[this.currentPosition];\n+                    if(deleteTrailNoUseChars){\n+                        if(currentChar == this.separator) {\n+                            this.endColumn();\n+                            \n+                            if(this.storeRawRecord) {\n+                                this.stringBuilder.append(currentChar);\n+                            }\n+                        } else if((this.lineEnd == null && (currentChar == '\\n' || currentChar == '\\r'))\n+                                || (this.lineEnd !=null && currentChar == this.lineEnd.charAt(0))) {\n+                            this.endColumn();\n+                            this.endRecord();\n+                        } else {\n+                            if ((!warningNonRFC) && currentChar != ' ' && currentChar != '\\t' && currentChar != '\\r') {\n+                                log.warn(\"CSV source '{}' is not conform to RFC, some data will be ignore.\", this.sb.toString());", "originalCommit": "767e0bc3c63f62d10418b3c19f80a41fde9fccee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyMDU3Nw==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404020577", "bodyText": "this was the point of orginal text of the JIRA. But, after reading RFC and realize that this demand is far from it, we decided to just put a warning.", "author": "clesaec", "createdAt": "2020-04-06T11:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4NDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyNjA5MA==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404026090", "bodyText": "I was talking about \"ignore\" that should be \"ignored\"", "author": "ypiel-talend", "createdAt": "2020-04-06T11:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4NDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAzMDMxMQ==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404030311", "bodyText": "Corrected (always have difficulties with this mix of future (will), and past (ed termination)) ;)", "author": "clesaec", "createdAt": "2020-04-06T11:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4NDk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4NTcyMw==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r403985723", "bodyText": "... data will be ignored", "author": "ypiel-talend", "createdAt": "2020-04-06T10:26:13Z", "path": "main/plugins/org.talend.designer.components.libs/libs_src/talendcsv/src/main/java/com/talend/csv/CSVReader.java", "diffHunk": "@@ -0,0 +1,585 @@\n+package com.talend.csv;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.HashMap;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CSVReader {\n+\n+    private final static Logger log = LoggerFactory.getLogger(CSVReader.class);\n+\n+    private Reader reader;\n+    \n+    private char separator = ',';\n+\n+    private char quotechar = '\"';\n+    \n+    private char escapechar = '\"';\n+\n+    private String lineEnd;\n+\n+    private boolean skipEmptyRecords = false;\n+    \n+    private boolean trimWhitespace = true;\n+    \n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    \n+    private static final int FETCH_SIZE = 10 * 50;\n+    \n+    private char[] buffer = new char[FETCH_SIZE]; \n+    private int currentPosition = 0;\n+    private int bufferCount = 0;\n+    \n+    private boolean hasMoreData = true;\n+    \n+    private boolean hasNext = false;\n+    \n+    private boolean inColumn = false;\n+    \n+    private boolean escaping = false;\n+    \n+    private char previousChar = '\\0';\n+    \n+    private String[] values = new String[10];\n+    \n+    private HeadersReader headersReader = new HeadersReader();\n+    \n+    private int columnCount = 0;\n+    \n+    private boolean inQuote = false; \n+    \n+    private StringBuilder sb = new StringBuilder(16);\n+    \n+    private boolean storeRawRecord = false;\n+    private StringBuilder stringBuilder = new StringBuilder(16 * 10);\n+    private String rawRecord = \"\";\n+    \n+    public CSVReader(final String filename, final char separator, final String charset) throws IOException {\n+        this(new FileInputStream(filename), separator, charset);\n+    }\n+    \n+    public CSVReader(final InputStream inputStream, final char separator, final String charset) throws IOException {\n+        this(new UnicodeReader(inputStream, charset), separator);\n+    }\n+\n+    public CSVReader(final Reader reader, final char separator) {\n+        this.reader = new BufferedReader(reader,BUFFER_SIZE);\n+        this.separator = separator;\n+    }\n+    \n+    public static CSVReader parse(final String content) {\n+        if (content == null) {\n+            throw new IllegalArgumentException(\n+                    \"Parameter content can not be null.\");\n+        }\n+\n+        return new CSVReader(new StringReader(content),',');\n+    }\n+    \n+    public CSVReader setLineEnd(final String lineEnd) {\n+        if (\"\\n\".equals(lineEnd) || \"\\r\\n\".equals(lineEnd)) {\n+            this.lineEnd = null;\n+        }\n+        else {\n+            this.lineEnd = lineEnd;\n+            if (lineEnd != null && lineEnd.length() > 1) {\n+                log.warn(\"Line end params {} is too long\", lineEnd);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public CSVReader setSeparator(final char separator) {\n+        this.separator = separator;\n+        return this;\n+    }\n+\n+    public CSVReader setEscapeChar(final char escapechar) {\n+        this.escapechar = escapechar;\n+        return this;\n+    }\n+    \n+    public CSVReader setQuoteChar(final char quotechar) {\n+        this.quotechar = quotechar;\n+        return this;\n+    }\n+    \n+    public char getQuoteChar() {\n+        return this.quotechar;\n+    }\n+    \n+    public CSVReader setTrimWhitespace(final boolean trimWhitespace) {\n+        this.trimWhitespace = trimWhitespace;\n+        return this;\n+    }\n+    \n+    public CSVReader setSkipEmptyRecords(final boolean skipEmptyRecords) {\n+        this.skipEmptyRecords = skipEmptyRecords;\n+        return this;\n+    }\n+    \n+    public CSVReader setStoreRawRecord(final boolean storeRawRecord) {\n+        this.storeRawRecord = storeRawRecord;\n+        return this;\n+    }\n+    \n+    public String getRawRecord() {\n+        return this.rawRecord;\n+    }\n+    \n+    public void endRecord() {\n+        this.hasNext = true;\n+    }\n+    \n+    public void endColumn() {\n+        this.inColumn = false;\n+        \n+        String currentValue = this.sb.toString();\n+        \n+        if(this.trimWhitespace && !this.inQuote) {\n+            currentValue = this.trimTail(currentValue);\n+        }\n+        \n+        if (this.columnCount == this.values.length) {\n+            final int newLength = this.values.length * 2;\n+\n+            final String[] holder = new String[newLength];\n+\n+            System.arraycopy(this.values, 0, holder, 0, this.values.length);\n+\n+            this.values = holder;\n+        }\n+\n+        this.values[this.columnCount] = currentValue;\n+\n+        this.columnCount++;\n+\n+        this.sb.setLength(0);\n+    }\n+    \n+    public boolean readNext() throws IOException {\n+        this.columnCount = 0;\n+        this.hasNext = false;\n+\n+        this.rawRecord = \"\";\n+        boolean warningNonRFC = false;\n+        \n+        if(!this.hasMoreData) {\n+            return false;\n+        }\n+        \n+        while(this.hasMoreData && !this.hasNext) {\n+            if(this.arriveEnd()) {\n+                this.fill();\n+                continue;\n+            }\n+            \n+            char currentChar = this.buffer[this.currentPosition];\n+\n+            this.inQuote = false;\n+            \n+            if(this.quotechar !='\\0' && currentChar == this.quotechar) {//quote char as start of column\n+                this.inColumn = true;\n+                this.inQuote = true;\n+                this.currentPosition++;\n+                this.escaping = false;\n+                \n+                boolean previousCharAsQuote = false;\n+                boolean deleteTrailNoUseChars = false;\n+                \n+                if(this.storeRawRecord) {\n+                    this.stringBuilder.append(currentChar);\n+                }\n+                \n+                while(this.hasMoreData && this.inColumn) {\n+                    if(this.arriveEnd()) {\n+                        this.fill();\n+                        continue;\n+                    }\n+                    \n+                    currentChar = this.buffer[this.currentPosition];\n+                    if(deleteTrailNoUseChars){\n+                        if(currentChar == this.separator) {\n+                            this.endColumn();\n+                            \n+                            if(this.storeRawRecord) {\n+                                this.stringBuilder.append(currentChar);\n+                            }\n+                        } else if((this.lineEnd == null && (currentChar == '\\n' || currentChar == '\\r'))\n+                                || (this.lineEnd !=null && currentChar == this.lineEnd.charAt(0))) {\n+                            this.endColumn();\n+                            this.endRecord();\n+                        } else {\n+                            if ((!warningNonRFC) && currentChar != ' ' && currentChar != '\\t' && currentChar != '\\r') {\n+                                log.warn(\"CSV source '{}' is not conform to RFC, some data will be ignore.\", this.sb.toString());\n+                                warningNonRFC = true;\n+                            }\n+                            if(this.storeRawRecord) {\n+                                this.stringBuilder.append(currentChar);\n+                            }\n+                        }\n+                    } else if(currentChar == this.quotechar) {\n+                        if(this.escaping) {//quote char as text\n+                            this.sb.append(currentChar);\n+                            this.escaping = false;\n+                            previousCharAsQuote = false;\n+                        } else {//quote char as escape or end of column \n+                            if(this.escapechar !='\\0' && currentChar == this.escapechar) {\n+                                this.escaping = true;\n+                            } \n+                            previousCharAsQuote = true;\n+                        }\n+                        \n+                        if(this.storeRawRecord) {\n+                            this.stringBuilder.append(currentChar);\n+                        }\n+                    } else if(this.escapechar !='\\0' && this.escapechar != this.quotechar && this.escaping) {\n+                        switch (currentChar) {\n+                        case 'n':\n+                            this.sb.append('\\n');\n+                            break;\n+                        case 'r':\n+                            this.sb.append('\\r');\n+                            break;\n+                        case 't':\n+                            this.sb.append('\\t');\n+                            break;\n+                        case 'b':\n+                            this.sb.append('\\b');\n+                            break;\n+                        case 'f':\n+                            this.sb.append('\\f');\n+                            break;\n+                        case 'e':\n+                            this.sb.append('\\u001B');\n+                            break;\n+                        case 'v':\n+                            this.sb.append('\\u000B');\n+                            break;\n+                        case 'a':\n+                            this.sb.append('\\u0007');\n+                            break;\n+                        default :\n+                            this.sb.append(currentChar);\n+                            break;\n+                        }\n+\n+                        this.escaping = false;\n+                        \n+                        if(this.storeRawRecord) {\n+                            this.stringBuilder.append(currentChar);\n+                        }\n+                    } else if(this.escapechar !='\\0' && currentChar == this.escapechar) {\n+                        this.escaping =  true;\n+                        \n+                        if(this.storeRawRecord) {\n+                            this.stringBuilder.append(currentChar);\n+                        }\n+                    } else if(previousCharAsQuote) {//quote char as end of column\n+                        if(currentChar == this.separator) {\n+                            this.endColumn();\n+                            \n+                            if(this.storeRawRecord) {\n+                                this.stringBuilder.append(currentChar);\n+                            }\n+                        } else if((this.lineEnd == null && (currentChar == '\\n' || currentChar == '\\r'))\n+                                || (this.lineEnd !=null && currentChar == this.lineEnd.charAt(0))) {\n+                            this.endColumn();\n+                            this.endRecord();\n+                        } else {\n+                            deleteTrailNoUseChars = true;\n+                            if ((!warningNonRFC) && currentChar != ' ' && currentChar != '\\t' && currentChar != '\\r') {\n+                                log.warn(\"CSV source '{}' is not conform to RFC, some data will be ignore.\", this.sb.toString());", "originalCommit": "767e0bc3c63f62d10418b3c19f80a41fde9fccee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyMDY1MA==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404020650", "bodyText": "Same as precedent", "author": "clesaec", "createdAt": "2020-04-06T11:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4NTcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyNjEzOA==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404026138", "bodyText": "The same...", "author": "ypiel-talend", "createdAt": "2020-04-06T11:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4NTcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAzMDQ0Mg==", "url": "https://github.com/Talend/tdi-studio-se/pull/4590#discussion_r404030442", "bodyText": "changed", "author": "clesaec", "createdAt": "2020-04-06T11:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4NTcyMw=="}], "type": "inlineReview"}, {"oid": "71714297e94710371a5501d057c9031a9e5859f7", "url": "https://github.com/Talend/tdi-studio-se/commit/71714297e94710371a5501d057c9031a9e5859f7", "message": "fix(TDI-31777) : yves review", "committedDate": "2020-04-06T11:34:07Z", "type": "commit"}, {"oid": "02e2bfbe016fcc338dde6c1f25c24e24ac6e7c4b", "url": "https://github.com/Talend/tdi-studio-se/commit/02e2bfbe016fcc338dde6c1f25c24e24ac6e7c4b", "message": "fix(TDI-31777) : yves review", "committedDate": "2020-04-06T11:49:18Z", "type": "commit"}]}