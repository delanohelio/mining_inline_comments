{"pr_number": 7049, "pr_title": "[KEYCLOAK-12305] [Testsuite] Check LDAP federated user (in)valid login(s) using various authentication methods, bind credential types, and connection encryption mechanisms", "pr_createdAt": "2020-05-07T13:54:18Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7049", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyMTEwOQ==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r423521109", "bodyText": "If I understand correctly, the combination like enableAnonymousAccess==true && enableAccessControl==true is invalid. Will it makes sense to throw the exception if the attempt of such configuration is tried?\nI mean something like:\nif (enableAnonymousAccess && enableAccessControl) {\n    throw new IllegalStateException(\"Illegal to enableAnonymousAccess and enableAccessControl at the same time\");\n}", "author": "mposolda", "createdAt": "2020-05-12T07:32:01Z", "path": "util/embedded-ldap/src/main/java/org/keycloak/util/ldap/LDAPEmbeddedServer.java", "diffHunk": "@@ -226,19 +251,52 @@ protected LdapServer createLdapServer() {\n         // Read the transports\n         Transport ldap = new TcpTransport(this.bindHost, this.bindPort, 3, 50);\n         ldapServer.addTransports( ldap );\n-        if (enableSSL) {\n-            Transport ldaps = new TcpTransport(this.bindHost, this.bindLdapsPort, 3, 50);\n-            ldaps.setEnableSSL(true);\n+        if (enableSSL || enableStartTLS) {\n             ldapServer.setKeystoreFile(keystoreFile);\n             ldapServer.setCertificatePassword(certPassword);\n-            ldapServer.addTransports( ldaps );\n+            if (enableSSL) {\n+                Transport ldaps = new TcpTransport(this.bindHost, this.bindLdapsPort, 3, 50);\n+                ldaps.setEnableSSL(true);\n+                ldapServer.addTransports( ldaps );\n+                if (ldaps.isSSLEnabled()) {\n+                    log.info(\"Enabled SSL support on the LDAP server.\");\n+                }\n+            }\n+            if (enableStartTLS) {\n+                try {\n+                    ldapServer.addExtendedOperationHandler(new StartTlsHandler());\n+                } catch (Exception e) {\n+                    throw new IllegalStateException(\"Cannot add the StartTLS extension handler: \", e);\n+                }\n+                for (ExtendedOperationHandler eoh : ldapServer.getExtendedOperationHandlers()) {\n+                    if (eoh.getOid().equals(StartTlsHandler.EXTENSION_OID)) {\n+                        log.info(\"Enabled StartTLS support on the LDAP server.\");\n+                        break;\n+                    }\n+                }\n+            }\n         }\n \n         // Associate the DS to this LdapServer\n         ldapServer.setDirectoryService( directoryService );\n \n-        // Propagate the anonymous flag to the DS\n-        directoryService.setAllowAnonymousAccess(false);\n+        if (enableAnonymousAccess && !enableAccessControl) {", "originalCommit": "023458e5dea6129093bae347f3ef3ddac6fc2bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNTkwMQ==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r424505901", "bodyText": "AFAIU it's not completely forbidden combination (per the Apache DS upstream docs), but once the access control subsystem is enabled, \"full\" anonymous binds / access might not work even if anonymous access is enabled (only root DSE would be allowed to be accessed directly, the child ones not, here the access control setting would apply).\nBut agree it will be better not to allow this combination (both access control & anonymous binds enabled @ the same time) to simplify the configuration for the test runs. This way anonymous binds are either fully enabled or disabled. There's nothing in between (the test writer won't need to find out / solve the nuisances between full & partial anonymous access allowed).\nFixed in 2nd commit", "author": "iankko", "createdAt": "2020-05-13T14:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyMTEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYzMzI1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r423633255", "bodyText": "nitpick: Will be slightly better to use constant Errors.USER_NOT_FOUND", "author": "mposolda", "createdAt": "2020-05-12T10:36:12Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPUserLoginTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.keycloak.testsuite.federation.ldap;\n+\n+import org.jboss.arquillian.graphene.page.Page;\n+import org.junit.FixMethodOrder;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExternalResource;\n+import org.junit.runners.MethodSorters;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.LDAPConstants;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.storage.ldap.idm.model.LDAPObject;\n+import org.keycloak.testsuite.arquillian.annotation.EnableVault;\n+import org.keycloak.testsuite.Assert;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.pages.AppPage;\n+import org.keycloak.testsuite.pages.LoginPage;\n+import org.keycloak.testsuite.util.LDAPRule;\n+import org.keycloak.testsuite.util.LDAPRule.LDAPConnectionParameters;\n+import org.keycloak.testsuite.util.LDAPTestUtils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Test user logins utilizing various LDAP authentication methods and different LDAP connection encryption mechanisms.\n+ *\n+ * @author <a href=\"mailto:jlieskov@redhat.com\">Jan Lieskovsky</a>\n+ */\n+@EnableVault\n+@FixMethodOrder(MethodSorters.NAME_ASCENDING)\n+public class LDAPUserLoginTest extends AbstractLDAPTest {\n+\n+    @Rule\n+    // Start an embedded LDAP server with configuration derived from test annotations before each test\n+    public LDAPRule ldapRule = new LDAPRule();\n+\n+    @Override\n+    protected LDAPRule getLDAPRule() {\n+        return ldapRule;\n+    }\n+\n+    @Rule\n+    // Recreate a new LDAP provider based on test annotations before each test\n+    public ExternalResource ldapProviderRule = new ExternalResource() {\n+\n+        @Override\n+        protected void after() {\n+            // Delete the previously imported realm(s) after each test. This forces\n+            // a new LDAP provider with custom configuration (derived from the test\n+            // annotations) to be created each time the next test is run\n+            if (getTestingClient() != null) {\n+                getTestContext().getTestRealmReps().clear();\n+            }\n+        }\n+\n+    };\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    protected static final Map<String, String> DEFAULT_TEST_USERS = new HashMap<String, String>();\n+    static {\n+        DEFAULT_TEST_USERS.put(\"EMPTY_USER_PASSWORD\", new String());\n+        DEFAULT_TEST_USERS.put(\"INVALID_USER_NAME\", \"userUnknown\");\n+        DEFAULT_TEST_USERS.put(\"INVALID_USER_EMAIL\", \"unknown@keycloak.org\");\n+        DEFAULT_TEST_USERS.put(\"INVALID_USER_PASSWORD\", \"1nval!D\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_EMAIL\", \"jdoe@keycloak.org\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_NAME\", \"jdoe\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_FIRST_NAME\", \"John\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_LAST_NAME\", \"Doe\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_PASSWORD\", \"P@ssw0rd!\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_POSTAL_CODE\", \"12345\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_STREET\", \"1th Avenue\");\n+    }\n+\n+    @Override\n+    protected void afterImportTestRealm() {\n+        getTestingClient().server().run(session -> {\n+            LDAPTestContext ctx = LDAPTestContext.init(session);\n+            RealmModel appRealm = ctx.getRealm();\n+\n+            // Delete all LDAP users\n+            LDAPTestUtils.removeAllLDAPUsers(ctx.getLdapProvider(), appRealm);\n+            // Add some new LDAP users for testing\n+            LDAPObject john = LDAPTestUtils.addLDAPUser\n+            (\n+                ctx.getLdapProvider(),\n+                appRealm,\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_NAME\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_FIRST_NAME\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_LAST_NAME\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_EMAIL\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_STREET\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_POSTAL_CODE\")\n+            );\n+            LDAPTestUtils.updateLDAPPassword(ctx.getLdapProvider(), john, DEFAULT_TEST_USERS.get(\"VALID_USER_PASSWORD\"));\n+        });\n+    }\n+\n+    @Page\n+    protected AppPage appPage;\n+\n+    @Page\n+    protected LoginPage loginPage;\n+\n+    // Helper methods\n+    private void verifyLoginSucceededAndLogout(String username, String password) {\n+        loginPage.open();\n+        loginPage.login(username, password);\n+        appPage.assertCurrent();\n+        Assert.assertEquals(AppPage.RequestType.AUTH_RESPONSE, appPage.getRequestType());\n+        Assert.assertNotNull(oauth.getCurrentQuery().get(OAuth2Constants.CODE));\n+        appPage.logout();\n+    }\n+\n+    private void verifyLoginFailed(String username, String password) {\n+        // Clear the events queue before the actual test to catch all errors properly\n+        events.clear();\n+        // Run the test actions\n+        loginPage.open();\n+        loginPage.login(username, password);\n+        Assert.assertEquals(\"Invalid username or password.\", loginPage.getError());\n+\n+        if (username.equals(DEFAULT_TEST_USERS.get(\"INVALID_USER_EMAIL\")) || username.equals(DEFAULT_TEST_USERS.get(\"INVALID_USER_NAME\"))) {\n+\n+            events.expect(EventType.LOGIN_ERROR).user((String) null).error(\"user_not_found\").assertEvent();", "originalCommit": "023458e5dea6129093bae347f3ef3ddac6fc2bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNjIwNg==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r424506206", "bodyText": "Fixed in 2nd commit", "author": "iankko", "createdAt": "2020-05-13T14:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYzMzI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYzMzY5OA==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r423633698", "bodyText": "nitpick: Will be slightly better to use constant Errors.INVALID_USER_CREDENTIALS", "author": "mposolda", "createdAt": "2020-05-12T10:37:01Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPUserLoginTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.keycloak.testsuite.federation.ldap;\n+\n+import org.jboss.arquillian.graphene.page.Page;\n+import org.junit.FixMethodOrder;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExternalResource;\n+import org.junit.runners.MethodSorters;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.LDAPConstants;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.storage.ldap.idm.model.LDAPObject;\n+import org.keycloak.testsuite.arquillian.annotation.EnableVault;\n+import org.keycloak.testsuite.Assert;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.pages.AppPage;\n+import org.keycloak.testsuite.pages.LoginPage;\n+import org.keycloak.testsuite.util.LDAPRule;\n+import org.keycloak.testsuite.util.LDAPRule.LDAPConnectionParameters;\n+import org.keycloak.testsuite.util.LDAPTestUtils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Test user logins utilizing various LDAP authentication methods and different LDAP connection encryption mechanisms.\n+ *\n+ * @author <a href=\"mailto:jlieskov@redhat.com\">Jan Lieskovsky</a>\n+ */\n+@EnableVault\n+@FixMethodOrder(MethodSorters.NAME_ASCENDING)\n+public class LDAPUserLoginTest extends AbstractLDAPTest {\n+\n+    @Rule\n+    // Start an embedded LDAP server with configuration derived from test annotations before each test\n+    public LDAPRule ldapRule = new LDAPRule();\n+\n+    @Override\n+    protected LDAPRule getLDAPRule() {\n+        return ldapRule;\n+    }\n+\n+    @Rule\n+    // Recreate a new LDAP provider based on test annotations before each test\n+    public ExternalResource ldapProviderRule = new ExternalResource() {\n+\n+        @Override\n+        protected void after() {\n+            // Delete the previously imported realm(s) after each test. This forces\n+            // a new LDAP provider with custom configuration (derived from the test\n+            // annotations) to be created each time the next test is run\n+            if (getTestingClient() != null) {\n+                getTestContext().getTestRealmReps().clear();\n+            }\n+        }\n+\n+    };\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    protected static final Map<String, String> DEFAULT_TEST_USERS = new HashMap<String, String>();\n+    static {\n+        DEFAULT_TEST_USERS.put(\"EMPTY_USER_PASSWORD\", new String());\n+        DEFAULT_TEST_USERS.put(\"INVALID_USER_NAME\", \"userUnknown\");\n+        DEFAULT_TEST_USERS.put(\"INVALID_USER_EMAIL\", \"unknown@keycloak.org\");\n+        DEFAULT_TEST_USERS.put(\"INVALID_USER_PASSWORD\", \"1nval!D\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_EMAIL\", \"jdoe@keycloak.org\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_NAME\", \"jdoe\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_FIRST_NAME\", \"John\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_LAST_NAME\", \"Doe\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_PASSWORD\", \"P@ssw0rd!\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_POSTAL_CODE\", \"12345\");\n+        DEFAULT_TEST_USERS.put(\"VALID_USER_STREET\", \"1th Avenue\");\n+    }\n+\n+    @Override\n+    protected void afterImportTestRealm() {\n+        getTestingClient().server().run(session -> {\n+            LDAPTestContext ctx = LDAPTestContext.init(session);\n+            RealmModel appRealm = ctx.getRealm();\n+\n+            // Delete all LDAP users\n+            LDAPTestUtils.removeAllLDAPUsers(ctx.getLdapProvider(), appRealm);\n+            // Add some new LDAP users for testing\n+            LDAPObject john = LDAPTestUtils.addLDAPUser\n+            (\n+                ctx.getLdapProvider(),\n+                appRealm,\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_NAME\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_FIRST_NAME\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_LAST_NAME\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_EMAIL\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_STREET\"),\n+                DEFAULT_TEST_USERS.get(\"VALID_USER_POSTAL_CODE\")\n+            );\n+            LDAPTestUtils.updateLDAPPassword(ctx.getLdapProvider(), john, DEFAULT_TEST_USERS.get(\"VALID_USER_PASSWORD\"));\n+        });\n+    }\n+\n+    @Page\n+    protected AppPage appPage;\n+\n+    @Page\n+    protected LoginPage loginPage;\n+\n+    // Helper methods\n+    private void verifyLoginSucceededAndLogout(String username, String password) {\n+        loginPage.open();\n+        loginPage.login(username, password);\n+        appPage.assertCurrent();\n+        Assert.assertEquals(AppPage.RequestType.AUTH_RESPONSE, appPage.getRequestType());\n+        Assert.assertNotNull(oauth.getCurrentQuery().get(OAuth2Constants.CODE));\n+        appPage.logout();\n+    }\n+\n+    private void verifyLoginFailed(String username, String password) {\n+        // Clear the events queue before the actual test to catch all errors properly\n+        events.clear();\n+        // Run the test actions\n+        loginPage.open();\n+        loginPage.login(username, password);\n+        Assert.assertEquals(\"Invalid username or password.\", loginPage.getError());\n+\n+        if (username.equals(DEFAULT_TEST_USERS.get(\"INVALID_USER_EMAIL\")) || username.equals(DEFAULT_TEST_USERS.get(\"INVALID_USER_NAME\"))) {\n+\n+            events.expect(EventType.LOGIN_ERROR).user((String) null).error(\"user_not_found\").assertEvent();\n+\n+        } else if (username.equals(DEFAULT_TEST_USERS.get(\"VALID_USER_EMAIL\")) || username.equals(DEFAULT_TEST_USERS.get(\"VALID_USER_NAME\"))) {\n+\n+            List<UserRepresentation> knownUsers = getAdminClient().realm(TEST_REALM_NAME).users().search(DEFAULT_TEST_USERS.get(\"VALID_USER_NAME\"));\n+            Assert.assertTrue(!knownUsers.isEmpty());\n+            final String userId = knownUsers.get(0).getId();\n+            events.expect(EventType.LOGIN_ERROR).user(userId).error(\"invalid_user_credentials\").assertEvent();", "originalCommit": "023458e5dea6129093bae347f3ef3ddac6fc2bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNjM3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r424506373", "bodyText": "Fixed in 2nd commit", "author": "iankko", "createdAt": "2020-05-13T14:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYzMzY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY0Njk1Ng==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r423646956", "bodyText": "I think this test will work just with embedded ApacheDS server? It seems for other LDAP servers, test will need to be ignored. See for example LDAPLegacyImportTest for the inspiration.", "author": "mposolda", "createdAt": "2020-05-12T11:02:07Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPUserLoginTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.keycloak.testsuite.federation.ldap;\n+\n+import org.jboss.arquillian.graphene.page.Page;\n+import org.junit.FixMethodOrder;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExternalResource;\n+import org.junit.runners.MethodSorters;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.LDAPConstants;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.storage.ldap.idm.model.LDAPObject;\n+import org.keycloak.testsuite.arquillian.annotation.EnableVault;\n+import org.keycloak.testsuite.Assert;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.pages.AppPage;\n+import org.keycloak.testsuite.pages.LoginPage;\n+import org.keycloak.testsuite.util.LDAPRule;\n+import org.keycloak.testsuite.util.LDAPRule.LDAPConnectionParameters;\n+import org.keycloak.testsuite.util.LDAPTestUtils;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Test user logins utilizing various LDAP authentication methods and different LDAP connection encryption mechanisms.\n+ *\n+ * @author <a href=\"mailto:jlieskov@redhat.com\">Jan Lieskovsky</a>\n+ */\n+@EnableVault\n+@FixMethodOrder(MethodSorters.NAME_ASCENDING)\n+public class LDAPUserLoginTest extends AbstractLDAPTest {\n+\n+    @Rule\n+    // Start an embedded LDAP server with configuration derived from test annotations before each test\n+    public LDAPRule ldapRule = new LDAPRule();", "originalCommit": "023458e5dea6129093bae347f3ef3ddac6fc2bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwODAwOA==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r424508008", "bodyText": "Fixed in 2nd commit (intentionally kept it separate, so the changes done are better visible) Will squash the commits later (since it's likely there will be conflicts with the Tero's one, I might need to up2date this one anyway). Thanks for the example test hint, utilizing that assumeTrue() condition!", "author": "iankko", "createdAt": "2020-05-13T15:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY0Njk1Ng=="}], "type": "inlineReview"}, {"oid": "3624d8917a16ead8691b1aa90d8200f6cfe571ed", "url": "https://github.com/keycloak/keycloak/commit/3624d8917a16ead8691b1aa90d8200f6cfe571ed", "message": "[KEYCLOAK-12305] [Testsuite] Check LDAP federated user (in)valid\nlogin(s) using various authentication methods, bind credential\ntypes, and connection encryption mechanisms\n\nThe tests cover various possible combinations of the following:\n* Authentication method: Anonymous or Simple (default),\n* Bind credential: Secret (default) or Vault,\n* Connection encryption: Plaintext (default), SSL, or startTLS\n\nSigned-off-by: Jan Lieskovsky <jlieskov@redhat.com>", "committedDate": "2020-05-13T13:35:04Z", "type": "forcePushed"}, {"oid": "35726dca866441c65f9ea1195cfab88696b545f3", "url": "https://github.com/keycloak/keycloak/commit/35726dca866441c65f9ea1195cfab88696b545f3", "message": "[KEYCLOAK-12305] [Testsuite] Check LDAP federated user (in)valid\nlogin(s) using various authentication methods, bind credential\ntypes, and connection encryption mechanisms\n\nThe tests cover various possible combinations of the following:\n* Authentication method: Anonymous or Simple (default),\n* Bind credential: Secret (default) or Vault,\n* Connection encryption: Plaintext (default), SSL, or startTLS\n\nSigned-off-by: Jan Lieskovsky <jlieskov@redhat.com>", "committedDate": "2020-05-14T18:08:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMzg3OQ==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r425703879", "bodyText": "I am not sure if this change is correct. IMO the StartTLS is something, which client can use or not. So perhaps it should be still possible to connect through the \"plain\" connection even if StartTLS support or \"enableSSL\" support is enabled.", "author": "mposolda", "createdAt": "2020-05-15T10:13:59Z", "path": "util/embedded-ldap/src/main/java/org/keycloak/util/ldap/LDAPEmbeddedServer.java", "diffHunk": "@@ -240,23 +265,65 @@ protected LdapServer createLdapServer() {\n \n         ldapServer.setServiceName(\"DefaultLdapServer\");\n         ldapServer.setSearchBaseDn(this.baseDN);\n+        // Tolerate plaintext LDAP connections from clients by default\n+        ldapServer.setConfidentialityRequired(false);\n \n         // Read the transports\n         Transport ldap = new TcpTransport(this.bindHost, this.bindPort, 3, 50);\n         ldapServer.addTransports( ldap );\n-        if (enableSSL) {\n-            Transport ldaps = new TcpTransport(this.bindHost, this.bindLdapsPort, 3, 50);\n-            ldaps.setEnableSSL(true);\n+        if (enableSSL || enableStartTLS) {\n             ldapServer.setKeystoreFile(keystoreFile);\n             ldapServer.setCertificatePassword(certPassword);\n-            ldapServer.addTransports( ldaps );\n+            // Require the LDAP server to accept only encrypted connections in the case LDAP over SSL / StartTLS operation mode was requested\n+            ldapServer.setConfidentialityRequired(true);", "originalCommit": "35726dca866441c65f9ea1195cfab88696b545f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxMTA4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r425711087", "bodyText": "Ok, fair enough. I will redo it differently yet & retest yet. Mmt", "author": "iankko", "createdAt": "2020-05-15T10:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMzg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyMDYxNA==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r425720614", "bodyText": "Since StartTLS is opportunistic encryption there is of course an option to fallback to insecure connection - it becomes a policy question if that is acceptable or not.\nBut from the point of StartTLS test it is of course important to make sure that StartTLS was really used :)", "author": "tsaarni", "createdAt": "2020-05-15T10:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMzg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNDkyMQ==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r425734921", "bodyText": "Right. Originally thought, if StartTLS is requested, confidentiality should be enforced for all tests. But will change the PR to be more tolerant (still require confidentiality == true for StartTLS & LDAPS for this set of newly added LDAP tests), but tolerate plaintext connections for the existing tests already. Hopefully that's reasonable compromise (otherwise we might need to rewrite those failing tests to truly support StartTLS).", "author": "iankko", "createdAt": "2020-05-15T11:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMzg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc0MzU4MA==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r425743580", "bodyText": "+1 for require confidentiality==true just for the StartTLS tests (and eventually SSL tests if it is not additional headaches to cover). IMO other existing LDAP tests not related to StartTLS feature should not use StartTLS. Among other things, StartTLS connection is slower than the \"plaintext\" connection AFAIK.", "author": "mposolda", "createdAt": "2020-05-15T11:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMzg3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1MDE4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7049#discussion_r425850183", "bodyText": "@mposolda @tsaarni Updated, should be ready for re-review again past the Travis run finished. The logic was changed to require confidentiality with StartTLS / LDAPS connections if and only if the StartTLS / LDAPS mode on LDAPEmbeddedServer was requested via the test annotation. Otherwise it will default to false (allow also unencrypted connections)", "author": "iankko", "createdAt": "2020-05-15T14:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMzg3OQ=="}], "type": "inlineReview"}, {"oid": "a0138d99e1db76ac2196129f293f193ea19f3295", "url": "https://github.com/keycloak/keycloak/commit/a0138d99e1db76ac2196129f293f193ea19f3295", "message": "[KEYCLOAK-12305] [Testsuite] Check LDAP federated user (in)valid\nlogin(s) using various authentication methods, bind credential\ntypes, and connection encryption mechanisms\n\nThe tests cover various possible combinations of the following:\n* Authentication method: Anonymous or Simple (default),\n* Bind credential: Secret (default) or Vault,\n* Connection encryption: Plaintext (default), SSL, or startTLS\n\nSigned-off-by: Jan Lieskovsky <jlieskov@redhat.com>", "committedDate": "2020-05-15T14:35:58Z", "type": "forcePushed"}, {"oid": "ccbfe2366a8c08228fbb4d3acfe8151b9bc253ff", "url": "https://github.com/keycloak/keycloak/commit/ccbfe2366a8c08228fbb4d3acfe8151b9bc253ff", "message": "[KEYCLOAK-12305] [Testsuite] Check LDAP federated user (in)valid\nlogin(s) using various authentication methods, bind credential\ntypes, and connection encryption mechanisms\n\nThe tests cover various possible combinations of the following:\n* Authentication method: Anonymous or Simple (default),\n* Bind credential: Secret (default) or Vault,\n* Connection encryption: Plaintext (default), SSL, or startTLS\n\nAlso, ignore the StartTLS LDAP tests for now till KEYCLOAK-14343\n& KEYCLOAK-14354 are corrected (due these issues they aren't\nworking with auth server Wildfly). They will be re-enabled later\nvia KEYCLOAK-14358 once possible\n\nSigned-off-by: Jan Lieskovsky <jlieskov@redhat.com>", "committedDate": "2020-06-02T09:57:15Z", "type": "commit"}, {"oid": "ccbfe2366a8c08228fbb4d3acfe8151b9bc253ff", "url": "https://github.com/keycloak/keycloak/commit/ccbfe2366a8c08228fbb4d3acfe8151b9bc253ff", "message": "[KEYCLOAK-12305] [Testsuite] Check LDAP federated user (in)valid\nlogin(s) using various authentication methods, bind credential\ntypes, and connection encryption mechanisms\n\nThe tests cover various possible combinations of the following:\n* Authentication method: Anonymous or Simple (default),\n* Bind credential: Secret (default) or Vault,\n* Connection encryption: Plaintext (default), SSL, or startTLS\n\nAlso, ignore the StartTLS LDAP tests for now till KEYCLOAK-14343\n& KEYCLOAK-14354 are corrected (due these issues they aren't\nworking with auth server Wildfly). They will be re-enabled later\nvia KEYCLOAK-14358 once possible\n\nSigned-off-by: Jan Lieskovsky <jlieskov@redhat.com>", "committedDate": "2020-06-02T09:57:15Z", "type": "forcePushed"}]}