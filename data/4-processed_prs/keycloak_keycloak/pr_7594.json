{"pr_number": 7594, "pr_title": "KEYCLOAK-14206 Client Policy - Executor : Enforce more secure state and nonce treatment for preventing CSRF", "pr_createdAt": "2020-11-11T00:14:33Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7594", "timeline": [{"oid": "d6046a04a2f7bd0f1616b09c40c651245efcbc5c", "url": "https://github.com/keycloak/keycloak/commit/d6046a04a2f7bd0f1616b09c40c651245efcbc5c", "message": "KEYCLOAK-14206 Client Policy - Executor : Enforce more secure state and nonce treatment for preventing CSRF", "committedDate": "2020-11-11T00:11:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4MDg1Ng==", "url": "https://github.com/keycloak/keycloak/pull/7594#discussion_r521180856", "bodyText": "Just to doublechec, wouldn't it be better to check that \"state\" parameter is always there? In other words, remove it from the \"else\" branch? This would mean that for OIDC clients, both \"state\" and \"nonce\" will be enforced, which IMO is fine behaviour?", "author": "mposolda", "createdAt": "2020-11-11T08:02:57Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureSessionEnforceExecutor.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyLogger;\n+import org.keycloak.util.TokenUtil;\n+\n+public class SecureSessionEnforceExecutor implements ClientPolicyExecutorProvider {\n+\n+    private static final Logger logger = Logger.getLogger(SecureSessionEnforceExecutor.class);\n+\n+    private final KeycloakSession session;\n+    private final ComponentModel componentModel;\n+\n+    public SecureSessionEnforceExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return componentModel.getName();\n+    }\n+\n+    @Override\n+    public String getProviderId() {\n+        return componentModel.getProviderId();\n+    }\n+\n+    @Override\n+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        switch (context.getEvent()) {\n+            case AUTHORIZATION_REQUEST:\n+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;\n+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),\n+                    authorizationRequestContext.getAuthorizationEndpointRequest(),\n+                    authorizationRequestContext.getRedirectUri());\n+                return;\n+            default:\n+                return;\n+        }\n+    }\n+\n+    private void executeOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Authz Endpoint - authz request\");\n+        if (TokenUtil.isOIDCRequest(request.getScope())) {\n+            if(request.getNonce() == null) {\n+                ClientPolicyLogger.log(logger, \"Missing parameter: nonce\");\n+                throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Missing parameter: nonce\");\n+            }\n+        } else {\n+            if(request.getState() == null) {", "originalCommit": "d6046a04a2f7bd0f1616b09c40c651245efcbc5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxNzA3Nw==", "url": "https://github.com/keycloak/keycloak/pull/7594#discussion_r521217077", "bodyText": "@mposolda Yes, as you pointed out, it is more secure for OIDC clients to be enforced with both \"state\" and \"nonce\".\nHowever, considering passing all FAPI-RW conformance tests, it should not be to do that. The one test case of current FAPI-RW conformance tests \"fapi-rw-id2-ensure-authorization-request-without-state-success\" checks whether the authorization server accepts the authorization request without \"state\" from OIDC client.", "author": "tnorimat", "createdAt": "2020-11-11T09:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4MDg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMDYwNg==", "url": "https://github.com/keycloak/keycloak/pull/7594#discussion_r521610606", "bodyText": "Ok, Thanks for explaining that.", "author": "mposolda", "createdAt": "2020-11-11T20:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4MDg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4NTg1Nw==", "url": "https://github.com/keycloak/keycloak/pull/7594#discussion_r521185857", "bodyText": "This is out of scope of this PR, but I wonder if we plan to have the condition, which will always evaluate to true? Or something like this... I can imagine that enforcing \"state\" and \"nonce\" parameter is something, which many deployments may want by default without a need for the client to match any special condition. WDYT? Just an idea for the future, nothing needed in this PR :-)", "author": "mposolda", "createdAt": "2020-11-11T08:14:00Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java", "diffHunk": "@@ -812,6 +813,61 @@ public void testClientIpAddressCondition() throws ClientRegistrationException, C\n         }\n     }\n \n+    @Test\n+    public void testSecureSessionEnforceExecutor() throws ClientRegistrationException, ClientPolicyException {\n+        String policyBetaName = \"MyPolicy-beta\";\n+        createPolicy(policyBetaName, DefaultClientPolicyProviderFactory.PROVIDER_ID, null, null, null);\n+        logger.info(\"... Created Policy : \" + policyBetaName);\n+\n+        createCondition(\"ClientRolesCondition-beta\", ClientRolesConditionFactory.PROVIDER_ID, null, (ComponentRepresentation provider) -> {", "originalCommit": "d6046a04a2f7bd0f1616b09c40c651245efcbc5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyODQyMQ==", "url": "https://github.com/keycloak/keycloak/pull/7594#discussion_r521228421", "bodyText": "@mposolda Yes, I totally agree with you. This \"always true\" condition is needed to realize pre-set policy which are adopted to all clients.\nI'd like to implement this condition afterwards. Thank you.", "author": "tnorimat", "createdAt": "2020-11-11T09:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4NTg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMDcxMQ==", "url": "https://github.com/keycloak/keycloak/pull/7594#discussion_r521610711", "bodyText": "@tnorimat Thanks for the info", "author": "mposolda", "createdAt": "2020-11-11T20:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4NTg1Nw=="}], "type": "inlineReview"}]}