{"pr_number": 7652, "pr_title": "[KEYCLOAK-16508] Complement methods for accessing user sessions with \u2026", "pr_createdAt": "2020-12-01T18:23:15Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7652", "timeline": [{"oid": "dbcce24f889fb3d5629648c1d13d3e856e101d7e", "url": "https://github.com/keycloak/keycloak/commit/dbcce24f889fb3d5629648c1d13d3e856e101d7e", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-02T12:13:03Z", "type": "forcePushed"}, {"oid": "a24ef953d17ea87db7beefe8c25e410c63b53296", "url": "https://github.com/keycloak/keycloak/commit/a24ef953d17ea87db7beefe8c25e410c63b53296", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-03T01:15:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg3OTk5NQ==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534879995", "bodyText": "I'm wondering whether it's nicer to avoid the iterator:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Iterator<UserSessionEntity> itr = cache.entrySet().stream()\n          \n          \n            \n                    List<UserSessionModel> resultSessions = cache.entrySet().stream()\n          \n          \n            \n                            .filter(predicate)\n          \n          \n            \n                            .map(Mappers.userSessionEntity())\n          \n          \n            \n                            .map(entity -> wrap(realm, entity, offline))\n          \n          \n            \n                            .collect(Collectors.toList());\n          \n          \n            \n                    \n          \n          \n            \n                    return resultSessions.stream();", "author": "martin-kanis", "createdAt": "2020-12-03T08:11:01Z", "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -270,25 +270,25 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool\n     }\n \n \n-    protected List<UserSessionModel> getUserSessions(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n+    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n         Cache<String, SessionEntityWrapper<UserSessionEntity>> cache = getCache(offline);\n-\n         cache = CacheDecorators.skipCacheLoaders(cache);\n \n-        Stream<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> cacheStream = cache.entrySet().stream();\n-\n-        List<UserSessionModel> resultSessions = new LinkedList<>();\n-\n-        Iterator<UserSessionEntity> itr = cacheStream.filter(predicate)\n+        Iterator<UserSessionEntity> itr = cache.entrySet().stream()", "originalCommit": "a24ef953d17ea87db7beefe8c25e410c63b53296", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMDA2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537710063", "bodyText": "It is, but as discussed there was an issue with the infinispan cache trying to serialize things that are not supposed to be sent through the wire. I've been able to get around this by \"wrapping\" the cache stream with one that uses the spliterator from the cache and thus obtains the elements one by one without incurring in serialization issues.", "author": "sguilhen", "createdAt": "2020-12-07T17:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg3OTk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg4MDI1MA==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534880250", "bodyText": "Same note as above.", "author": "martin-kanis", "createdAt": "2020-12-03T08:11:09Z", "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -357,16 +357,17 @@ public UserSessionModel getUserSessionByBrokerSessionId(RealmModel realm, String\n             stream = stream.limit(maxResults);\n         }\n \n-        final List<UserSessionModel> sessions = new LinkedList<>();\n+        // while it looks natural to just do another map(entity -> wrap(realm, entity, offline)) on the stream and return it\n+        // directly, we need to pre-consume the stream from the infinispan cache using an iterator to avoid a serialization\n+        // error from infinispan when the stream is later consumed (by e.g. a call to collect or forEach) in certain cross-dc\n+        // scenarios.\n+        List<UserSessionModel> resultSessions = new LinkedList<>();", "originalCommit": "a24ef953d17ea87db7beefe8c25e410c63b53296", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMDQwNw==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537710407", "bodyText": "Same explanation :)", "author": "sguilhen", "createdAt": "2020-12-07T17:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg4MDI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4NjE0MQ==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534986141", "bodyText": "Star import.", "author": "martin-kanis", "createdAt": "2020-12-03T09:16:00Z", "path": "services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java", "diffHunk": "@@ -98,6 +99,8 @@\n import org.w3c.dom.Element;\n \n import java.util.*;", "originalCommit": "a24ef953d17ea87db7beefe8c25e410c63b53296", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4NjIyNQ==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534986225", "bodyText": "Could you please extract this forEach block to a separate method for better readability?", "author": "martin-kanis", "createdAt": "2020-12-03T09:16:06Z", "path": "services/src/main/java/org/keycloak/broker/saml/SAMLEndpoint.java", "diffHunk": "@@ -296,22 +299,22 @@ protected Response handleSamlRequest(String samlRequest, String relayState) {\n         protected Response logoutRequest(LogoutRequestType request, String relayState) {\n             String brokerUserId = config.getAlias() + \".\" + request.getNameID().getValue();\n             if (request.getSessionIndex() == null || request.getSessionIndex().isEmpty()) {\n-                List<UserSessionModel> userSessions = session.sessions().getUserSessionByBrokerUserId(realm, brokerUserId);\n-                for (UserSessionModel userSession : userSessions) {\n-                    if (userSession.getState() == UserSessionModel.State.LOGGING_OUT || userSession.getState() == UserSessionModel.State.LOGGED_OUT) {\n-                        continue;\n-                    }\n-\n-                    for(Iterator<SamlAuthenticationPreprocessor> it = SamlSessionUtils.getSamlAuthenticationPreprocessorIterator(session); it.hasNext();) {\n-                        request = it.next().beforeProcessingLogoutRequest(request, userSession, null);\n-                    }\n-\n-                    try {\n-                        AuthenticationManager.backchannelLogout(session, realm, userSession, session.getContext().getUri(), clientConnection, headers, false);\n-                    } catch (Exception e) {\n-                        logger.warn(\"failed to do backchannel logout for userSession\", e);\n-                    }\n-                }\n+                AtomicReference<LogoutRequestType> ref = new AtomicReference<>(request);\n+                session.sessions().getUserSessionByBrokerUserIdStream(realm, brokerUserId)\n+                        .filter(userSession -> userSession.getState() != UserSessionModel.State.LOGGING_OUT &&\n+                                userSession.getState() != UserSessionModel.State.LOGGED_OUT)\n+                        .collect(Collectors.toList()) // collect to avoid concurrent modification as backchannelLogout removes the user sessions.\n+                        .forEach(userSession -> {", "originalCommit": "a24ef953d17ea87db7beefe8c25e410c63b53296", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODIxNg==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537718216", "bodyText": "Done!", "author": "sguilhen", "createdAt": "2020-12-07T18:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4NjIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4ODY1MQ==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r534988651", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .forEach(offlineUserSession -> userSessionManager.revokeOfflineUserSession(offlineUserSession));\n          \n          \n            \n                            .forEach(userSessionManager::revokeOfflineUserSession);", "author": "martin-kanis", "createdAt": "2020-12-03T09:19:34Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java", "diffHunk": "@@ -345,34 +345,29 @@ private BackchannelLogoutResponse backchannelLogoutFederatedUserId(String federa\n         BackchannelLogoutResponse backchannelLogoutResponse = new BackchannelLogoutResponse();\n         backchannelLogoutResponse.setLocalLogoutSucceeded(true);\n         identityProviderAliases.forEach(identityProviderAlias -> {\n-            List<UserSessionModel> userSessions = session.sessions().getUserSessionByBrokerUserId(realm,\n-                    identityProviderAlias + \".\" + federatedUserId);\n \n             if (logoutOfflineSessions) {\n                 logoutOfflineUserSessions(identityProviderAlias + \".\" + federatedUserId);\n             }\n \n-            for (UserSessionModel userSession : userSessions) {\n-                BackchannelLogoutResponse userBackchannelLogoutResponse;\n-                userBackchannelLogoutResponse = logoutUserSession(userSession);\n-                backchannelLogoutResponse.setLocalLogoutSucceeded(backchannelLogoutResponse.getLocalLogoutSucceeded()\n-                        && userBackchannelLogoutResponse.getLocalLogoutSucceeded());\n-                userBackchannelLogoutResponse.getClientResponses()\n-                        .forEach(backchannelLogoutResponse::addClientResponses);\n-            }\n+            session.sessions().getUserSessionByBrokerUserIdStream(realm, identityProviderAlias + \".\" + federatedUserId)\n+                    .collect(Collectors.toList()) // collect to avoid concurrent modification as backchannelLogout removes the user sessions.\n+                    .forEach(userSession -> {\n+                        BackchannelLogoutResponse userBackchannelLogoutResponse = this.logoutUserSession(userSession);\n+                        backchannelLogoutResponse.setLocalLogoutSucceeded(backchannelLogoutResponse.getLocalLogoutSucceeded()\n+                                && userBackchannelLogoutResponse.getLocalLogoutSucceeded());\n+                        userBackchannelLogoutResponse.getClientResponses()\n+                                .forEach(backchannelLogoutResponse::addClientResponses);\n+                    });\n         });\n \n         return backchannelLogoutResponse;\n     }\n \n     private void logoutOfflineUserSessions(String brokerUserId) {\n-        List<UserSessionModel> offlineUserSessions =\n-                session.sessions().getOfflineUserSessionByBrokerUserId(realm, brokerUserId);\n-\n         UserSessionManager userSessionManager = new UserSessionManager(session);\n-        for (UserSessionModel offlineUserSession : offlineUserSessions) {\n-            userSessionManager.revokeOfflineUserSession(offlineUserSession);\n-        }\n+        session.sessions().getOfflineUserSessionByBrokerUserIdStream(realm, brokerUserId).collect(Collectors.toList())\n+                .forEach(offlineUserSession -> userSessionManager.revokeOfflineUserSession(offlineUserSession));", "originalCommit": "a24ef953d17ea87db7beefe8c25e410c63b53296", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxOTA0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537719046", "bodyText": "Good catch, thanks!", "author": "sguilhen", "createdAt": "2020-12-07T18:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4ODY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxNTE1Mw==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535015153", "bodyText": "Would this work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    kcSession.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())\n          \n          \n            \n                    kcSession.sessions().getOfflineUserSessionsStream(realm, user)\n          \n          \n            \n                            .map(userSession -> userSession.getAuthenticatedClientSessionByClient(client.getId()))\n          \n          \n            \n                            .filter(Objects::nonNull)\n          \n          \n            \n                            .collect(Collectors.toList())\n          \n          \n            \n                            .forEach(clientSession -> {\n          \n          \n            \n                                if (logger.isTraceEnabled()) {\n          \n          \n            \n                                    logger.tracef(\"Removing existing offline token for user '%s' and client '%s' .\",\n          \n          \n            \n                                            user.getUsername(), client.getClientId());\n          \n          \n            \n                                }\n          \n          \n            \n            \n          \n          \n            \n                                UserSessionModel userSession = clientSession.getUserSession();\n          \n          \n            \n                                clientSession.detachFromUserSession();\n          \n          \n            \n                                persister.removeClientSession(userSession.getId(), client.getId(), true);\n          \n          \n            \n                                checkOfflineUserSessionHasClientSessions(realm, user, userSession);\n          \n          \n            \n                                anyRemoved.set(true);\n          \n          \n            \n                            });", "author": "martin-kanis", "createdAt": "2020-12-03T09:40:31Z", "path": "services/src/main/java/org/keycloak/services/managers/UserSessionManager.java", "diffHunk": "@@ -77,43 +78,42 @@ public UserSessionModel findOfflineUserSession(RealmModel realm, String userSess\n     }\n \n     public Set<ClientModel> findClientsWithOfflineToken(RealmModel realm, UserModel user) {\n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        Set<ClientModel> clients = new HashSet<>();\n-        for (UserSessionModel userSession : userSessions) {\n-            Set<String> clientIds = userSession.getAuthenticatedClientSessions().keySet();\n-            for (String clientUUID : clientIds) {\n-                ClientModel client = realm.getClientById(clientUUID);\n-                clients.add(client);\n-            }\n-        }\n-        return clients;\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user)\n+                .flatMap(userSession -> userSession.getAuthenticatedClientSessions().keySet().stream())\n+                .map(clientUUID -> realm.getClientById(clientUUID))\n+                .collect(Collectors.toSet());\n     }\n \n+    @Deprecated\n     public List<UserSessionModel> findOfflineSessions(RealmModel realm, UserModel user) {\n-        return kcSession.sessions().getOfflineUserSessions(realm, user);\n+        return this.findOfflineSessionsStream(realm, user).collect(Collectors.toList());\n+    }\n+\n+    public Stream<UserSessionModel> findOfflineSessionsStream(RealmModel realm, UserModel user) {\n+        return kcSession.sessions().getOfflineUserSessionsStream(realm, user);\n     }\n \n     public boolean revokeOfflineToken(UserModel user, ClientModel client) {\n         RealmModel realm = client.getRealm();\n \n-        List<UserSessionModel> userSessions = kcSession.sessions().getOfflineUserSessions(realm, user);\n-        boolean anyRemoved = false;\n-        for (UserSessionModel userSession : userSessions) {\n-            AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(client.getId());\n-            if (clientSession != null) {\n-                if (logger.isTraceEnabled()) {\n-                    logger.tracef(\"Removing existing offline token for user '%s' and client '%s' .\",\n-                            user.getUsername(), client.getClientId());\n-                }\n-\n-                clientSession.detachFromUserSession();\n-                persister.removeClientSession(userSession.getId(), client.getId(), true);\n-                checkOfflineUserSessionHasClientSessions(realm, user, userSession);\n-                anyRemoved = true;\n-            }\n-        }\n-\n-        return anyRemoved;\n+        AtomicBoolean anyRemoved = new AtomicBoolean(false);\n+        kcSession.sessions().getOfflineUserSessionsStream(realm, user).collect(Collectors.toList())", "originalCommit": "a24ef953d17ea87db7beefe8c25e410c63b53296", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyMjU2MA==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537722560", "bodyText": "I don't think it would because after you map it you lose the reference to the userSession that is used in the forEach block. That is, the forEach in your suggestion has only a reference to a clientSession, the userSession is gone by then.", "author": "sguilhen", "createdAt": "2020-12-07T18:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxNTE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0OTUyMg==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r538449522", "bodyText": "I workaround it by UserSessionModel userSession = clientSession.getUserSession(); inside the forEach block. But anyway the pros of my suggestion are disputable :)\nWhatever works better for you.", "author": "martin-kanis", "createdAt": "2020-12-08T14:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxNTE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDgzNw==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r538750837", "bodyText": "Ugh, missed that. I guess your approach works then, which at least makes the scope of the forEach block smaller. I'll give it a try.", "author": "sguilhen", "createdAt": "2020-12-08T19:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxNTE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA1Nzg1OA==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535057858", "bodyText": "Maybe this could work? WDYT?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    checkAccountApiEnabled();\n          \n          \n            \n                    public Stream<ClientRepresentation> applications(@QueryParam(\"name\") String name) {\n          \n          \n            \n                    checkAccountApiEnabled();\n          \n          \n            \n                    auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_APPLICATIONS);\n          \n          \n            \n            \n          \n          \n            \n                    List<String> inUseClients = new LinkedList<>();\n          \n          \n            \n                    Stream<ClientModel> clients = session.sessions().getUserSessionsStream(realm, user)\n          \n          \n            \n                            .flatMap(s -> s.getAuthenticatedClientSessions().values().stream())\n          \n          \n            \n                            .map(AuthenticatedClientSessionModel::getClient)\n          \n          \n            \n                            .peek(client -> inUseClients.add(client.getClientId()));\n          \n          \n            \n            \n          \n          \n            \n                    List<String> offlineClients = new LinkedList<>();\n          \n          \n            \n                    clients = Streams.concat(session.sessions().getOfflineUserSessionsStream(realm, user)\n          \n          \n            \n                            .flatMap(s -> s.getAuthenticatedClientSessions().values().stream())\n          \n          \n            \n                            .map(AuthenticatedClientSessionModel::getClient)\n          \n          \n            \n                            .peek(client -> offlineClients.add(client.getClientId())), clients).distinct();\n          \n          \n            \n            \n          \n          \n            \n                    Map<String, UserConsentModel> consentModels = new HashMap<>();\n          \n          \n            \n                    clients = Streams.concat(session.users().getConsentsStream(realm, user.getId())\n          \n          \n            \n                            .peek(consent -> consentModels.put(consent.getClient().getClientId(), consent))\n          \n          \n            \n                            .map(UserConsentModel::getClient), clients).distinct();\n          \n          \n            \n            \n          \n          \n            \n                    clients = Streams.concat(realm.getAlwaysDisplayInConsoleClientsStream(), clients).distinct();\n          \n          \n            \n            \n          \n          \n            \n                    return clients.filter(client -> !client.isBearerOnly() && client.getBaseUrl() != null && !client.getBaseUrl().isEmpty())\n          \n          \n            \n                            .filter(client -> matches(client, name))\n          \n          \n            \n                            .map(client -> modelToRepresentation(client, inUseClients, offlineClients, consentModels));\n          \n          \n            \n                }", "author": "martin-kanis", "createdAt": "2020-12-03T10:19:18Z", "path": "services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java", "diffHunk": "@@ -405,26 +405,20 @@ public LinkedAccountsResource linkedAccounts() {\n         checkAccountApiEnabled();", "originalCommit": "a24ef953d17ea87db7beefe8c25e410c63b53296", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3MDkwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537770905", "bodyText": "Yeah, I like this approach", "author": "sguilhen", "createdAt": "2020-12-07T19:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA1Nzg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1NzgxNw==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537857817", "bodyText": "EDIT: this breaks several tests in AccountRestServiceTest because the intermediary inUseClients, offlineClients and consentModels are not fully formed when the last map operation is performed. As the stream elements are processed one by one these intermediary collections that are needed to convert to ClientRepresentation are not totally in place by the time the modelToRepresentation call is made.\nBecause of that I had to collect each of the intermediary streams in order to force the processing of the intermediary collections and ensure they are fully formed when modelToRepresentation is called on each client.", "author": "sguilhen", "createdAt": "2020-12-07T21:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA1Nzg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEwMzI0NA==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535103244", "bodyText": "Maybe this could be slightly changed and return stream instead a collection?\nSomething like distinctByKey in this example.", "author": "martin-kanis", "createdAt": "2020-12-03T11:01:03Z", "path": "services/src/main/java/org/keycloak/services/resources/account/SessionResource.java", "diffHunk": "@@ -88,33 +89,31 @@ public SessionResource(KeycloakSession session, Auth auth, HttpRequest request)\n     @NoCache\n     public Collection<DeviceRepresentation> devices() {", "originalCommit": "a24ef953d17ea87db7beefe8c25e410c63b53296", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MDI0MA==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537750240", "bodyText": "We can change it to stream, but I don't see how to make use of something like you mentioned. If I could map the session into devices then I could filter the devices as shown in that example, but then I would no longer have a reference to the session and it is needed to properly create the device representation.", "author": "sguilhen", "createdAt": "2020-12-07T18:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEwMzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE1NDg2OQ==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r535154869", "bodyText": "assertNotEquals could be used", "author": "martin-kanis", "createdAt": "2020-12-03T11:50:17Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderTest.java", "diffHunk": "@@ -773,11 +778,12 @@ public static void testOnUserRemoved(KeycloakSession session) {\n \n         session.userStorageManager().removeUser(realm, user1);\n \n-        assertTrue(session.sessions().getUserSessions(realm, user1).isEmpty());\n+        assertEquals(0, session.sessions().getUserSessionsStream(realm, user1).count());\n \n         session.getTransactionManager().commit();\n \n-        assertFalse(session.sessions().getUserSessions(realm, session.users().getUserByUsername(\"user2\", realm)).isEmpty());\n+        assertFalse(session.sessions().getUserSessionsStream(realm, session.users().getUserByUsername(\"user2\", realm))", "originalCommit": "a24ef953d17ea87db7beefe8c25e410c63b53296", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyNDc4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537724785", "bodyText": "Changed", "author": "sguilhen", "createdAt": "2020-12-07T18:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE1NDg2OQ=="}], "type": "inlineReview"}, {"oid": "6ae3c85bf7f8c202627bc8d3f3302c4179d8e522", "url": "https://github.com/keycloak/keycloak/commit/6ae3c85bf7f8c202627bc8d3f3302c4179d8e522", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-04T13:07:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MjA5Nw==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r536142097", "bodyText": "Would the following work as well?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(cache.entrySet().stream().iterator(), 0), true)\n          \n          \n            \n                    return StreamSupport.stream(cache.entrySet().stream().spliterator(), true)", "author": "hmlnarik", "createdAt": "2020-12-04T14:34:22Z", "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanUserSessionProvider.java", "diffHunk": "@@ -270,25 +272,16 @@ private UserSessionEntity getUserSessionEntity(RealmModel realm, String id, bool\n     }\n \n \n-    protected List<UserSessionModel> getUserSessions(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n+    protected Stream<UserSessionModel> getUserSessionsStream(RealmModel realm, Predicate<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> predicate, boolean offline) {\n         Cache<String, SessionEntityWrapper<UserSessionEntity>> cache = getCache(offline);\n-\n         cache = CacheDecorators.skipCacheLoaders(cache);\n \n-        Stream<Map.Entry<String, SessionEntityWrapper<UserSessionEntity>>> cacheStream = cache.entrySet().stream();\n-\n-        List<UserSessionModel> resultSessions = new LinkedList<>();\n-\n-        Iterator<UserSessionEntity> itr = cacheStream.filter(predicate)\n+        // return a stream that 'wraps' the infinispan cache stream so that the cache stream's elements are read one by one\n+        // and then filtered/mapped locally to avoid serialization issues when trying to manipulate the cache stream directly.\n+        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(cache.entrySet().stream().iterator(), 0), true)", "originalCommit": "6ae3c85bf7f8c202627bc8d3f3302c4179d8e522", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcyMzkwMA==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r537723900", "bodyText": "Yes, it does. Not sure why I haven't tried it first.", "author": "sguilhen", "createdAt": "2020-12-07T18:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MjA5Nw=="}], "type": "inlineReview"}, {"oid": "ebc62865c2b9116d4f430072517a9c9fcd6ad31c", "url": "https://github.com/keycloak/keycloak/commit/ebc62865c2b9116d4f430072517a9c9fcd6ad31c", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-07T16:03:53Z", "type": "forcePushed"}, {"oid": "ec0fc5930bbbc5cfd9a84daa72cdb8d6798696e5", "url": "https://github.com/keycloak/keycloak/commit/ec0fc5930bbbc5cfd9a84daa72cdb8d6798696e5", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-07T19:32:02Z", "type": "forcePushed"}, {"oid": "93c87a3571f35763cbf20d49baca938fd94a978a", "url": "https://github.com/keycloak/keycloak/commit/93c87a3571f35763cbf20d49baca938fd94a978a", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-07T20:39:38Z", "type": "forcePushed"}, {"oid": "aedb9753638c2bc9a7574fb4a4fe78d7cdac3857", "url": "https://github.com/keycloak/keycloak/commit/aedb9753638c2bc9a7574fb4a4fe78d7cdac3857", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-07T21:49:28Z", "type": "forcePushed"}, {"oid": "4792c9816231da91a7bd69608afdcf0fec11147d", "url": "https://github.com/keycloak/keycloak/commit/4792c9816231da91a7bd69608afdcf0fec11147d", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-07T23:22:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NTg1Mw==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539095853", "bodyText": "Maybe we can replace collect + forEach with collectToMap + putAll\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        currentSession.sessions().getUserSessionsStream(realm, testApp).collect(Collectors.toList())\n          \n          \n            \n                        offlineSessions.putAll(currentSession.sessions().getUserSessionsStream(realm, testApp)\n          \n          \n            \n                                .collect(Collectors.toMap(UserSessionModel::getId,\n          \n          \n            \n                                        userSession -> createOfflineSessionIncludeClientSessions(currentSession, userSession))));", "author": "martin-kanis", "createdAt": "2020-12-09T08:16:17Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "diffHunk": "@@ -112,10 +113,8 @@ public void testOfflineSessionsCrud(KeycloakSession session) {\n             // Key is userSession ID, values are client UUIDS\n             // Persist 3 created userSessions and clientSessions as offline\n             ClientModel testApp = realm.getClientByClientId(\"test-app\");\n-            List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp);\n-            for (UserSessionModel userSession : userSessions) {\n-                offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));\n-            }\n+            currentSession.sessions().getUserSessionsStream(realm, testApp).collect(Collectors.toList())", "originalCommit": "4792c9816231da91a7bd69608afdcf0fec11147d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgwODIwOA==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539808208", "bodyText": "It doesn't work in this case because createOfflineSessionIncludeClientSessions is creating new sessions while the stream is still being processed, which leads to concurrent modification exception. The prior approach collects the elements first and then attempts to add new offline sessions which now doesn't make changes to the stream source.", "author": "sguilhen", "createdAt": "2020-12-10T03:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NTg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkwNTc1MA==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539905750", "bodyText": "I see. Thank you for the explanation.", "author": "martin-kanis", "createdAt": "2020-12-10T06:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NTg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NjIyNA==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539096224", "bodyText": "Again collectToMap + putAll", "author": "martin-kanis", "createdAt": "2020-12-09T08:16:45Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/UserSessionProviderOfflineTest.java", "diffHunk": "@@ -462,10 +463,8 @@ public void testExpired(KeycloakSession session) {\n \n                 // Persist 3 created userSessions and clientSessions as offline\n                 testApp[0] = realm.getClientByClientId(\"test-app\");\n-                List<UserSessionModel> userSessions = currentSession.sessions().getUserSessions(realm, testApp[0]);\n-                for (UserSessionModel userSession : userSessions) {\n-                    offlineSessions.put(userSession.getId(), createOfflineSessionIncludeClientSessions(currentSession, userSession));\n-                }\n+                currentSession.sessions().getUserSessionsStream(realm, testApp[0]).collect(Collectors.toList())", "originalCommit": "4792c9816231da91a7bd69608afdcf0fec11147d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTgwODQ4Mg==", "url": "https://github.com/keycloak/keycloak/pull/7652#discussion_r539808482", "bodyText": "Same as above. Test fails because it cannot create the offline sessions while the stream is still \"live\"", "author": "sguilhen", "createdAt": "2020-12-10T03:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NjIyNA=="}], "type": "inlineReview"}, {"oid": "aa6513ed9176955b15cae4770579cb5e4b0ac1fa", "url": "https://github.com/keycloak/keycloak/commit/aa6513ed9176955b15cae4770579cb5e4b0ac1fa", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-10T12:32:25Z", "type": "commit"}, {"oid": "aa6513ed9176955b15cae4770579cb5e4b0ac1fa", "url": "https://github.com/keycloak/keycloak/commit/aa6513ed9176955b15cae4770579cb5e4b0ac1fa", "message": "[KEYCLOAK-16508] Complement methods for accessing user sessions with Stream variants", "committedDate": "2020-12-10T12:32:25Z", "type": "forcePushed"}]}