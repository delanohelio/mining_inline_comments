{"pr_number": 7524, "pr_title": "[KEYCLOAK-15200] Complement methods for accessing users with Stream v\u2026", "pr_createdAt": "2020-10-21T17:35:10Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7524", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4NDQwNg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511784406", "bodyText": "ldapQuery.getResultList() doesn't seem to return null so maybe this if may be removed?", "author": "martin-kanis", "createdAt": "2020-10-26T08:23:53Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -257,23 +256,18 @@ public boolean supportsCredentialAuthenticationFor(String type) {\n              List<LDAPObject> ldapObjects = ldapQuery.getResultList();\n \n              if (ldapObjects == null || ldapObjects.isEmpty()) {", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NDgwMg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511984802", "bodyText": "Yeah, good point.", "author": "sguilhen", "createdAt": "2020-10-26T14:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc4NDQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5NDAxNA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511794014", "bodyText": "I think we need to be more careful with skip which throws an IllegalArgumentException when a negative number is provided.", "author": "martin-kanis", "createdAt": "2020-10-26T08:41:43Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NTMwMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511985300", "bodyText": "You are right, I think I've added some guards somewhere but forgot to check all other places", "author": "sguilhen", "createdAt": "2020-10-26T14:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5NDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5OTIyOQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511799229", "bodyText": "This lambda can be avoided like this: ((Predicate<List>) List::isEmpty).negate()", "author": "martin-kanis", "createdAt": "2020-10-26T08:51:05Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NTQzOA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511985438", "bodyText": "I like the suggestion, will change it.", "author": "sguilhen", "createdAt": "2020-10-26T14:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc5OTIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511800715", "bodyText": "Maybe it can be simplified like\nreturn...\n.map(List::stream)\n.findFirst().orElse(Stream.empty());", "author": "martin-kanis", "createdAt": "2020-10-26T08:53:45Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NjQyMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511986420", "bodyText": "I suppose this would work, yes. I will make the change", "author": "sguilhen", "createdAt": "2020-10-26T14:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NDUyMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512274520", "bodyText": "Prefer list.isEmpty() to list.size() where possible. The former is simple check while the latter may need to enumerate the items e.g. in case of LinkedList", "author": "hmlnarik", "createdAt": "2020-10-26T21:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMDcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTQ2MA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511801460", "bodyText": "Same as above", "author": "martin-kanis", "createdAt": "2020-10-26T08:55:00Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {\n-        return getRoleMembers(realm, role, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n+        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getRoleMembers(realm, role, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .filter(list -> list.size() > 0)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NjUzMA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511986530", "bodyText": "Noted", "author": "sguilhen", "createdAt": "2020-10-26T14:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwMTU3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511801572", "bodyText": "Same as above", "author": "martin-kanis", "createdAt": "2020-10-26T08:55:10Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -393,65 +387,42 @@ public int getUsersCount(RealmModel realm) {\n             }\n         }\n \n-        List<UserModel> searchResults =new LinkedList<UserModel>();\n-\n         List<LDAPObject> ldapUsers = searchLDAP(realm, params, maxResults + firstResult);\n-        int counter = 0;\n-        for (LDAPObject ldapUser : ldapUsers) {\n-            if (counter++ < firstResult) continue;\n-            String ldapUsername = LDAPUtils.getUsername(ldapUser, this.ldapIdentityStore.getConfig());\n-            if (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null) {\n-                UserModel imported = importUserFromLDAP(session, realm, ldapUser);\n-                searchResults.add(imported);\n-            }\n-        }\n-\n-        return searchResults;\n+        return ldapUsers.stream().skip(firstResult).filter(ldapObject -> {\n+            String ldapUsername = LDAPUtils.getUsername(ldapObject, this.ldapIdentityStore.getConfig());\n+            return (session.userLocalStorage().getUserByUsername(ldapUsername, realm) == null);\n+        }).map(ldapObject -> importUserFromLDAP(session, realm, ldapObject));\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n-        return getGroupMembers(realm, group, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group) {\n+        return getGroupMembersStream(realm, group, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n-                .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getGroupMembers(realm, group, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+    public Stream<UserModel> getGroupMembersStream(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+            .sorted(ldapMappersComparator.sortAsc())\n+            .map(mapperModel ->\n+                mapperManager.getMapper(mapperModel).getGroupMembers(realm, group, firstResult, maxResults))\n+            .filter(list -> list.size() > 0)\n+            .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {\n-        return getRoleMembers(realm, role, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n+        return getRoleMembersStream(realm, role, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n-        List<ComponentModel> sortedMappers = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n+    public Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        List<UserModel> users = realm.getComponentsStream(model.getId(), LDAPStorageMapper.class.getName())\n                 .sorted(ldapMappersComparator.sortAsc())\n-                .collect(Collectors.toList());\n-        for (ComponentModel mapperModel : sortedMappers) {\n-            LDAPStorageMapper ldapMapper = mapperManager.getMapper(mapperModel);\n-            List<UserModel> users = ldapMapper.getRoleMembers(realm, role, firstResult, maxResults);\n-\n-            // Sufficient for now\n-            if (users.size() > 0) {\n-                return users;\n-            }\n-        }\n-        return Collections.emptyList();\n+                .map(mapperModel -> mapperManager.getMapper(mapperModel).getRoleMembers(realm, role, firstResult, maxResults))\n+                .filter(list -> list.size() > 0)\n+                .findFirst().orElse(null);\n+        return users == null ? Stream.empty() : users.stream();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzMzQ0NA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511833444", "bodyText": "Is this equal to the collection variant? Shouldn't there be Stream.concat(super.getRequiredActionsStream(), Stream.of(RequiredAction.UPDATE_PASSWORD.toString())).distinct(); ?", "author": "martin-kanis", "createdAt": "2020-10-26T09:47:50Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java", "diffHunk": "@@ -299,18 +300,13 @@ public void removeRequiredAction(String action) {\n         }\n \n         @Override\n-        public Set<String> getRequiredActions() {\n-            Set<String> requiredActions = super.getRequiredActions();\n-\n+        public Stream<String> getRequiredActionsStream() {\n             if (ldapProvider.getEditMode() == UserStorageProvider.EditMode.WRITABLE) {\n                 if (getPwdLastSet() == 0 || getUserAccountControl(ldapUser).has(UserAccountControl.PASSWORD_EXPIRED)) {\n-                    requiredActions = new HashSet<>(requiredActions);\n-                    requiredActions.add(RequiredAction.UPDATE_PASSWORD.toString());\n-                    return requiredActions;\n+                    return Stream.of(RequiredAction.UPDATE_PASSWORD.toString());", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMDU0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512000547", "bodyText": "You are absolutely right, I misread the if() section and didn't see the creation of the collection with the values already obtained by calling super.getRequiredActions().", "author": "sguilhen", "createdAt": "2020-10-26T14:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzMzQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzI4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511857287", "bodyText": "Couldn't we just return already obtained identities? federatedIdentities.stream();?", "author": "martin-kanis", "createdAt": "2020-10-26T10:27:18Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -578,64 +576,65 @@ public int getUsersCount(Map<String, String> params, RealmModel realm, Set<Strin\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {\n-        return getDelegate().getUsers(realm, firstResult, maxResults, includeServiceAccounts);\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults, boolean includeServiceAccounts) {\n+        return getDelegate().getUsersStream(realm, firstResult, maxResults, includeServiceAccounts);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n-        return getUsers(realm, false);\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n+        return getUsersStream(realm, false);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-         return getUsers(realm, firstResult, maxResults, false);\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n+         return getUsersStream(realm, firstResult, maxResults, false);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm) {\n-        return getDelegate().searchForUser(search, realm);\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n+        return getDelegate().searchForUserStream(search, realm);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUser(search, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n+        return getDelegate().searchForUserStream(search, realm, firstResult, maxResults);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n-        return getDelegate().searchForUser(attributes, realm);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n+        return getDelegate().searchForUserStream(attributes, realm);\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n-        return getDelegate().searchForUser(attributes, realm, firstResult, maxResults);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n+        return getDelegate().searchForUserStream(attributes, realm, firstResult, maxResults);\n     }\n \n     @Override\n-    public List<UserModel> searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {\n-        return getDelegate().searchForUserByUserAttribute(attrName, attrValue, realm);\n+    public Stream<UserModel> searchForUserByUserAttributeStream(String attrName, String attrValue, RealmModel realm) {\n+        return getDelegate().searchForUserByUserAttributeStream(attrName, attrValue, realm);\n     }\n \n     @Override\n-    public Set<FederatedIdentityModel> getFederatedIdentities(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n         logger.tracev(\"getFederatedIdentities: {0}\", user.getUsername());\n \n         String cacheKey = getFederatedIdentityLinksCacheKey(user.getId());\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(user.getId()) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getFederatedIdentities(user, realm);\n+            return getDelegate().getFederatedIdentitiesStream(user, realm);\n         }\n \n         CachedFederatedIdentityLinks cachedLinks = cache.get(cacheKey, CachedFederatedIdentityLinks.class);\n \n         if (cachedLinks == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n-            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentities(user, realm);\n+            Set<FederatedIdentityModel> federatedIdentities = getDelegate().getFederatedIdentitiesStream(user, realm)\n+                    .collect(Collectors.toSet());\n             cachedLinks = new CachedFederatedIdentityLinks(loaded, cacheKey, realm, federatedIdentities);\n             cache.addRevisioned(cachedLinks, startupRevision);\n-            return federatedIdentities;\n+            return getDelegate().getFederatedIdentitiesStream(user, realm);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMzE1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512003155", "bodyText": "Yeah, we could do that. This is one of the places where using streams leads to code that is a bit odd - we get a stream, consume it into a collection, then get the cached collection and streamify it again.", "author": "sguilhen", "createdAt": "2020-10-26T14:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1ODQ0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511858445", "bodyText": "Couldn't we just return already obtained consents? consents.stream();?", "author": "martin-kanis", "createdAt": "2020-10-26T10:29:14Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/UserCacheSession.java", "diffHunk": "@@ -708,31 +707,25 @@ public UserConsentModel getConsentByClient(RealmModel realm, String userId, Stri\n     }\n \n     @Override\n-    public List<UserConsentModel> getConsents(RealmModel realm, String userId) {\n+    public Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId) {\n         logger.tracev(\"getConsents: {0}\", userId);\n \n         String cacheKey = getConsentCacheKey(userId);\n         if (realmInvalidations.contains(realm.getId()) || invalidations.contains(userId) || invalidations.contains(cacheKey)) {\n-            return getDelegate().getConsents(realm, userId);\n+            return getDelegate().getConsentsStream(realm, userId);\n         }\n \n         CachedUserConsents cached = cache.get(cacheKey, CachedUserConsents.class);\n \n         if (cached == null) {\n             Long loaded = cache.getCurrentRevision(cacheKey);\n-            List<UserConsentModel> consents = getDelegate().getConsents(realm, userId);\n+            List<UserConsentModel> consents = getDelegate().getConsentsStream(realm, userId).collect(Collectors.toList());\n             cached = new CachedUserConsents(loaded, cacheKey, realm, consents);\n             cache.addRevisioned(cached, startupRevision);\n-            return consents;\n+            return getDelegate().getConsentsStream(realm, userId);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg2MTcxOA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511861718", "bodyText": "I know you didn't introduce this star import but maybe it's right time to fix it now :)", "author": "martin-kanis", "createdAt": "2020-10-26T10:34:37Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -59,8 +59,13 @@\n import javax.persistence.criteria.Subquery;\n import java.util.*;", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5ODI5Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511998293", "bodyText": "Hahaha, good catch. Will change it :D", "author": "sguilhen", "createdAt": "2020-10-26T14:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg2MTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4OTY2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511889665", "bodyText": "Missing closing of the stream.", "author": "martin-kanis", "createdAt": "2020-10-26T11:25:13Z", "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -164,12 +163,12 @@ public void removeAttribute(RealmModel realm, String userId, String name) {\n     }\n \n     @Override\n-    public List<String> getUsersByUserAttribute(RealmModel realm, String name, String value) {\n+    public Stream<String> getUsersByUserAttributeStream(RealmModel realm, String name, String value) {\n         TypedQuery<String> query = em.createNamedQuery(\"getFederatedAttributesByNameAndValue\", String.class)\n                 .setParameter(\"realmId\", realm.getId())\n                 .setParameter(\"name\", name)\n                 .setParameter(\"value\", value);\n-        return query.getResultList();\n+        return query.getResultStream();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5ODUwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511998505", "bodyText": "Nice catch, thanks", "author": "sguilhen", "createdAt": "2020-10-26T14:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg4OTY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTk4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511891983", "bodyText": "Maybe also use distinct() here.", "author": "martin-kanis", "createdAt": "2020-10-26T11:29:45Z", "path": "model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java", "diffHunk": "@@ -489,28 +476,21 @@ public void leaveGroup(RealmModel realm, String userId, GroupModel group) {\n         if (max != -1) {\n             query.setMaxResults(max);\n         }\n-\n-        return query.getResultList();\n+        return closing(query.getResultStream());\n     }\n \n     @Override\n-    public Set<String> getRequiredActions(RealmModel realm, String userId) {\n-        Set<String> set = new HashSet<>();\n-        List<FederatedUserRequiredActionEntity> values = getRequiredActionEntities(realm, userId, LockModeType.NONE);\n-        for (FederatedUserRequiredActionEntity entity : values) {\n-            set.add(entity.getAction());\n-        }\n-\n-        return set;\n-\n+    public Stream<String> getRequiredActionsStream(RealmModel realm, String userId) {\n+        return this.getRequiredActionEntitiesStream(realm, userId, LockModeType.NONE).\n+                map(FederatedUserRequiredActionEntity::getAction);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMzk2NA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512003964", "bodyText": "Yeah, definitely.", "author": "sguilhen", "createdAt": "2020-10-26T14:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5MTk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjI2MA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511896260", "bodyText": "You kept the original deprecated method on purpose?", "author": "martin-kanis", "createdAt": "2020-10-26T11:38:22Z", "path": "server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java", "diffHunk": "@@ -160,6 +160,11 @@ public String getFirstAttribute(String name) {\n         return value;\n     }\n \n+    @Override", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3OTQxNg==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512079416", "bodyText": "No, that was definitely a brain fart :)", "author": "sguilhen", "createdAt": "2020-10-26T16:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5NjM2MA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511896360", "bodyText": "Same as above", "author": "martin-kanis", "createdAt": "2020-10-26T11:38:33Z", "path": "server-spi-private/src/main/java/org/keycloak/storage/adapter/InMemoryUserAdapter.java", "diffHunk": "@@ -170,6 +175,11 @@ public String getFirstAttribute(String name) {\n         return requiredActions;\n     }\n \n+    @Override", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg5OTM1Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511899353", "bodyText": "Missing Javadoc.", "author": "martin-kanis", "createdAt": "2020-10-26T11:44:16Z", "path": "server-spi/src/main/java/org/keycloak/storage/federated/UserGroupMembershipFederatedStorage.java", "diffHunk": "@@ -38,6 +38,15 @@\n \n     void joinGroup(RealmModel realm, String userId, GroupModel group);\n     void leaveGroup(RealmModel realm, String userId, GroupModel group);\n-    List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max);\n+\n+    /**\n+     * @deprecated Use {@link #getMembershipStream(RealmModel, GroupModel, int, int) getMembershipStream} instead.\n+     */\n+    @Deprecated\n+    default List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max) {\n+        return this.getMembershipStream(realm, group, firstResult, max).collect(Collectors.toList());\n+    }\n+\n+    Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max);", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTY4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511911685", "bodyText": "To avoid extra lambda  (int) users.filter(u -> u.getGroupsStream().map(GroupModel::getId).anyMatch(groupIds::contains)).count();", "author": "martin-kanis", "createdAt": "2020-10-26T12:08:19Z", "path": "server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java", "diffHunk": "@@ -126,10 +122,8 @@ default int getUsersCount(Map<String, String> params, RealmModel realm, Set<Stri\n      * @param groupIds id of groups that should be checked for\n      * @return number of users that are in at least one of the groups\n      */\n-    static int countUsersInGroups(List<UserModel> users, Set<String> groupIds) {\n-        return (int) users.stream()\n-                .filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId())))\n-                .count();\n+    static int countUsersInGroups(Stream<UserModel> users, Set<String> groupIds) {\n+        return (int) users.filter(u -> u.getGroupsStream().anyMatch(group -> groupIds.contains(group.getId()))).count();", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5NzA2OA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511997068", "bodyText": "Thanks for the suggestion, definitely worth changing.", "author": "sguilhen", "createdAt": "2020-10-26T14:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511955159", "bodyText": "I'm wondering if we should time bound the results from federated storage same as we did in ClientStorageManager.searchClientsByClientIdStream whenever we concat local and federated entities.", "author": "martin-kanis", "createdAt": "2020-10-26T13:24:00Z", "path": "services/src/main/java/org/keycloak/storage/UserStorageManager.java", "diffHunk": "@@ -608,14 +600,13 @@ public UserModel getServiceAccount(ClientModel client) {\n     }\n \n     @Override\n-    public Set<FederatedIdentityModel> getFederatedIdentities(UserModel user, RealmModel realm) {\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n         if (user == null) throw new IllegalStateException(\"Federated user no longer valid\");\n-        Set<FederatedIdentityModel> set = new HashSet<>();\n-        if (StorageId.isLocalStorage(user)) {\n-            set.addAll(localStorage().getFederatedIdentities(user, realm));\n-        }\n-        if (getFederatedStorage() != null) set.addAll(getFederatedStorage().getFederatedIdentities(user.getId(), realm));\n-        return set;\n+        Stream<FederatedIdentityModel> stream = StorageId.isLocalStorage(user) ?\n+                localStorage().getFederatedIdentitiesStream(user, realm) : Stream.empty();\n+        if (getFederatedStorage() != null)\n+            stream = Streams.concat(stream, getFederatedStorage().getFederatedIdentitiesStream(user.getId(), realm));", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5NjE3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511996173", "bodyText": "I will check this", "author": "sguilhen", "createdAt": "2020-10-26T14:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI3NTYwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512275605", "bodyText": "@mhajas FYI", "author": "hmlnarik", "createdAt": "2020-10-26T21:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ4MjA2OQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r512482069", "bodyText": "Well, this is a good question. However, I don't think we should. The federatedStorage is something little bit confusing, I spent quite a lot of time on investigating what is it for. If I understand correctly, this is the point: if you have some users, from external storage/provider and you are not able to store some keycloak specific properties (attributes, roles, groups etc.) in that external storage, you can configure keycloak to store it for you using this federatedStorage. For example you store a user with id id_pointing_to_external_storage have roles admin and manager. So whenever there is a call to federatedStorage for FederatedIdentityModel, it should be a call to a database/map storage (in future). See current jpa implementation.\nTherefore, If we would time bound federated storage, the same logic would apply also to localStorage() and I don't like this idea. WDYT?", "author": "mhajas", "createdAt": "2020-10-27T08:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzNzM1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r514437355", "bodyText": "Given @mhajas comment, I'm leaving it as is for now.", "author": "sguilhen", "createdAt": "2020-10-29T17:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NTE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1NzcwNw==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511957707", "bodyText": "Here again \"-1\" in skip will cause an IllegalStateException.", "author": "martin-kanis", "createdAt": "2020-10-26T13:27:56Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -293,49 +291,45 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n         return userPasswords.keySet().stream()\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1OTU2OA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511959568", "bodyText": "Negative number in skip.", "author": "martin-kanis", "createdAt": "2020-10-26T13:30:21Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -293,49 +291,45 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n         return userPasswords.keySet().stream()\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .skip(firstResult)\n           .limit(maxResults)\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .filter(userName -> userName.contains(search))\n-          .map(userName -> createUser(realm, userName))\n-          .collect(Collectors.toList());\n+          .map(userName -> createUser(realm, userName));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n         return userPasswords.keySet().stream()\n           .sorted()\n           .filter(userName -> userName.contains(search))\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MTQyNA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511961424", "bodyText": "Negative number in skip.", "author": "martin-kanis", "createdAt": "2020-10-26T13:33:02Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -361,30 +355,27 @@ public int getUsersCount(RealmModel realm) {\n         return userStream\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MjM1OA==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511962358", "bodyText": "Negative number in skip.", "author": "martin-kanis", "createdAt": "2020-10-26T13:34:20Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java", "diffHunk": "@@ -412,15 +403,14 @@ public void leaveGroup(RealmModel realm, String userId, GroupModel group) {\n     }\n \n     @Override\n-    public List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max) {\n+    public Stream<String> getMembershipStream(RealmModel realm, GroupModel group, int firstResult, int max) {\n         return userGroups.entrySet().stream()\n           .filter(me -> me.getValue().contains(group.getId()))\n           .map(Map.Entry::getKey)\n           .filter(realmUser -> realmUser.startsWith(realm.getId()))\n           .map(realmUser -> realmUser.substring(realmUser.indexOf(\"/\") + 1))\n           .skip(firstResult)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MzYxOQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511973619", "bodyText": "What \"-1\" in maxResults actually should achieve? If that means we don't want limit number of results shouldn't we use Integer.MAX_VALUE - 1 ? Not sure if limit(0) will do the same.\nIf \"-1\" means I don't want any results (which doesn't make sense to me :D ) then it's, I guess correct.", "author": "martin-kanis", "createdAt": "2020-10-26T13:50:09Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java", "diffHunk": "@@ -146,88 +144,64 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm) {\n-        List<UserModel> users = new LinkedList<>();\n-        for (Object username : userPasswords.keySet()) {\n-            users.add(createUser(realm, (String)username));\n-        }\n-        return users;\n+    public Stream<UserModel> getUsersStream(RealmModel realm) {\n+        return userPasswords.keySet().stream().map(obj -> createUser(realm, (String) obj));\n     }\n \n     @Override\n-    public List<UserModel> searchForUser(Map<String, String> attributes, RealmModel realm) {\n-        return searchForUser(attributes, realm, 0, Integer.MAX_VALUE - 1);\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm) {\n+        return searchForUserStream(attributes, realm, 0, Integer.MAX_VALUE - 1);\n     }\n \n     @Override\n-    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n-        if (maxResults == 0) return Collections.EMPTY_LIST;\n-        List<UserModel> users = new LinkedList<>();\n-        int count = 0;\n-        for (Object un : userPasswords.keySet()) {\n-            if (count++ < firstResult) continue;\n-            String username = (String)un;\n-            users.add(createUser(realm, username));\n-            if (users.size() + 1 > maxResults) break;\n-        }\n-        return users;\n+    public Stream<UserModel> getUsersStream(RealmModel realm, int firstResult, int maxResults) {\n+        return userPasswords.keySet().stream().skip(firstResult < 0 ? 0 : firstResult).limit(maxResults < 0 ? 0 : maxResults)", "originalCommit": "6ae2c7c8c7f30da8b94588d1fe4d65de8b3094ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NzQwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7524#discussion_r511987405", "bodyText": "I will have to check this again, this is a very good point.", "author": "sguilhen", "createdAt": "2020-10-26T14:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MzYxOQ=="}], "type": "inlineReview"}, {"oid": "b839690d32f81140a94289f9a443ed61111fa8e5", "url": "https://github.com/keycloak/keycloak/commit/b839690d32f81140a94289f9a443ed61111fa8e5", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-10-29T17:23:27Z", "type": "forcePushed"}, {"oid": "73b8207ab295a9a00c192d2d5debc14317a05816", "url": "https://github.com/keycloak/keycloak/commit/73b8207ab295a9a00c192d2d5debc14317a05816", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-10-30T19:28:40Z", "type": "forcePushed"}, {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289", "url": "https://github.com/keycloak/keycloak/commit/ce4c5764c2a2c85c895f63957dda72b22bd0a289", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-11-09T12:21:05Z", "type": "commit"}, {"oid": "ce4c5764c2a2c85c895f63957dda72b22bd0a289", "url": "https://github.com/keycloak/keycloak/commit/ce4c5764c2a2c85c895f63957dda72b22bd0a289", "message": "[KEYCLOAK-15200] Complement methods for accessing users with Stream variants", "committedDate": "2020-11-09T12:21:05Z", "type": "forcePushed"}]}