{"pr_number": 7657, "pr_title": "KEYCLOAK-11908 Support for conditional creating indices based on number", "pr_createdAt": "2020-12-03T04:06:45Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7657", "timeline": [{"oid": "74c53324d60b8edaf4a73d8ac2223f786aa8fe53", "url": "https://github.com/keycloak/keycloak/commit/74c53324d60b8edaf4a73d8ac2223f786aa8fe53", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-07T02:49:29Z", "type": "forcePushed"}, {"oid": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "url": "https://github.com/keycloak/keycloak/commit/f997c299d53b316f4c1a45c05549f2b96a4117ce", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-11T04:12:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNTY3MA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540835670", "bodyText": "nit: missing copyright comment", "author": "vramik", "createdAt": "2020-12-11T10:11:22Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NjkxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542186915", "bodyText": "Deleted CustomCreateIndexChange.", "author": "y-tabata", "createdAt": "2020-12-14T08:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNjAwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544236005", "bodyText": "thank you", "author": "vramik", "createdAt": "2020-12-16T11:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNTY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540836924", "bodyText": "If I understand it correctly this check is here to test if the table actually exist, am I right? If so I wonder if the check is necessary.", "author": "vramik", "createdAt": "2020-12-11T10:13:19Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NzQ5Ng==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542187496", "bodyText": "If this check not exists, the initial startup fails.", "author": "y-tabata", "createdAt": "2020-12-14T08:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE4ODk3OQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544188979", "bodyText": "You're right. The reason why it fails is the fact that generateStatements(Database) is called during validation and other stuff multiple times when the table doesn't have to be there yet. Maybe it'd be worth to add a // comment with the info to this check as well, wdyt?", "author": "vramik", "createdAt": "2020-12-16T10:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0NzExOA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544647118", "bodyText": "Added a comment.", "author": "y-tabata", "createdAt": "2020-12-16T21:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzNjkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzUyNA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540843524", "bodyText": "Have you chance to test this sql in various databases like MySQL, Oracle, Portgres and MSSQL? It seems there is missing whitespace character after from keyword.\nIf I remember correctly there is also a need to properly escape schema for select statements when the table name is retrieved. Please see CustomKeycloakTask.getTableName(String) for more details.", "author": "vramik", "createdAt": "2020-12-11T10:24:14Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n+                return super.generateStatements(database);\n+\n+            int result = ExecutorService.getInstance().getExecutor(database)\n+                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODA0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188045", "bodyText": "Modified. And I tested on PostgreSQL.", "author": "y-tabata", "createdAt": "2020-12-14T08:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDYyNw==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540844627", "bodyText": "Could @DatabaseChange annotation be used directly instead of overriding this method?", "author": "vramik", "createdAt": "2020-12-11T10:25:57Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n+            return super.generateStatements(database);\n+\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n+                return super.generateStatements(database);\n+\n+            int result = ExecutorService.getInstance().getExecutor(database)\n+                .queryForInt(new RawSqlStatement(\"select count(*) from\" + getTableName()));\n+\n+            if (result > (Integer) indexCreationThreshold) {\n+                logger.warnv(\"Following index should be created: CREATE INDEX {0};\",\n+                    new Index(getIndexName(), getCatalogName(), getSchemaName(), getTableName()));\n+                return new SqlStatement[] {};\n+            }\n+        } catch (DatabaseException | InvalidExampleException e) {\n+            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n+        }\n+\n+        return super.generateStatements(database);\n+    }\n+\n+    @Override\n+    public ChangeMetaData createChangeMetaData() {", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODE0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188145", "bodyText": "Deleted CustomCreateIndexChange.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NDYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjE0MQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540846141", "bodyText": "I'd suggest to add a // comment with a note the CustomCreateIndexChange is registered for handle conditional indices creation", "author": "vramik", "createdAt": "2020-12-11T10:28:17Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java", "diffHunk": "@@ -109,12 +116,14 @@ protected void baseLiquibaseInitialization() {\n \n         // Use \"SELECT FOR UPDATE\" for locking database\n         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());\n-    }\n \n+        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODIxMg==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188212", "bodyText": "Deleted CustomCreateIndexChange.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNTkxNA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544235914", "bodyText": "thank you", "author": "vramik", "createdAt": "2020-12-16T11:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0ODQwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540848405", "bodyText": "I'd suggest to add // comment where could be specified that this check is here for manual migration. It should be easily overlooked and the comment should help.", "author": "vramik", "createdAt": "2020-12-11T10:32:00Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODI5OQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188299", "bodyText": "Deleted CustomCreateIndexChange.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0ODQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzNjA4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544236086", "bodyText": "thank you", "author": "vramik", "createdAt": "2020-12-16T11:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0ODQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NDEwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540864105", "bodyText": "The intention is to avoid tens of seconds spent on index creation upon upgrade, so I think 100000 would be still perfectly acceptable.", "author": "vramik", "createdAt": "2020-12-11T10:58:05Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/conn/DefaultLiquibaseConnectionProvider.java", "diffHunk": "@@ -109,12 +116,14 @@ protected void baseLiquibaseInitialization() {\n \n         // Use \"SELECT FOR UPDATE\" for locking database\n         SqlGeneratorFactory.getInstance().register(new CustomLockDatabaseChangeLogGenerator());\n-    }\n \n+        ChangeFactory.getInstance().register(CustomCreateIndexChange.class);\n+    }\n \n     @Override\n     public void init(Config.Scope config) {\n-\n+        indexCreationThreshold = config.getInt(\"indexCreationThreshold\", 10000);", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODQ1MQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188451", "bodyText": "Changed.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NDEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4MDg1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r540880855", "bodyText": "I'd suggest to introduce private int indexCreationThreshold; in this class and I'd also suggest following\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)\n          \n          \n            \n                    if (indexCreationThreshold instanceof Integer) {\n          \n          \n            \n                        this.indexCreationThreshold = (Integer) indexCreationThreshold;\n          \n          \n            \n                        if (this.indexCreationThreshold <= 0) return super.generateStatements(database);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return super.generateStatements(database);\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\ninstanceof  should take care of null and we can avoid type casting on line 50. wdyt?", "author": "vramik", "createdAt": "2020-12-11T11:27:52Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.DatabaseChangeNote;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Index;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold == null || (Integer) indexCreationThreshold == -1)", "originalCommit": "f997c299d53b316f4c1a45c05549f2b96a4117ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODU5Mw==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r542188593", "bodyText": "Changed.", "author": "y-tabata", "createdAt": "2020-12-14T08:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4MDg1NQ=="}], "type": "inlineReview"}, {"oid": "bce93fb0c80e637282040e762ca880e1e5542ce0", "url": "https://github.com/keycloak/keycloak/commit/bce93fb0c80e637282040e762ca880e1e5542ce0", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-14T07:49:22Z", "type": "forcePushed"}, {"oid": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "url": "https://github.com/keycloak/keycloak/commit/052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-15T05:49:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0Mzg4MQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544343881", "bodyText": "What'd you say about idea to create make DefaultLiquibaseConnectionProvider.indexCreationThreshold static and to introduce\n    public static int getIndexCreationThreshold() {\n        return indexCreationThreshold;\n    }\n\nthere? We'd then be able to use\nif (DefaultLiquibaseConnectionProvider.getIndexCreationThreshold() <= 0)\n                return super.generateStatements(database);\n\nhere instead of parsing Integer from attributes.", "author": "vramik", "createdAt": "2020-12-16T14:31:20Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.io.StringWriter;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProvider;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.AddColumnConfig;\n+import liquibase.change.ChangeFactory;\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.ChangeParameterMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.exception.ValidationErrors;\n+import liquibase.exception.Warnings;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.sqlgenerator.SqlGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.CreateIndexStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+@DatabaseChange(name = \"createIndex\", description = \"Creates an index on an existing column or set of columns conditionally based on the number of records.\", priority = ChangeMetaData.PRIORITY_DEFAULT\n+    + 1, appliesTo = \"index\")\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+    private int indexCreationThreshold;\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        // This check is for manual migration\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)", "originalCommit": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQzNzYzNA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544437634", "bodyText": "I'd say if the indexCreationThreshold would need to be static, then the current approach is cleaner.", "author": "hmlnarik", "createdAt": "2020-12-16T16:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0Mzg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0OTQ1MA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544649450", "bodyText": "@vramik @hmlnarik\nI keep this implementation as-is.", "author": "y-tabata", "createdAt": "2020-12-16T21:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0Mzg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODU2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544348565", "bodyText": "Can we avoid overriding this and following two methods?", "author": "vramik", "createdAt": "2020-12-16T14:37:27Z", "path": "model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.connections.jpa.updater.liquibase.custom;\n+\n+import java.io.StringWriter;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.connections.jpa.updater.liquibase.LiquibaseJpaUpdaterProvider;\n+import org.keycloak.connections.jpa.updater.liquibase.conn.DefaultLiquibaseConnectionProvider;\n+\n+import liquibase.change.AddColumnConfig;\n+import liquibase.change.ChangeFactory;\n+import liquibase.change.ChangeMetaData;\n+import liquibase.change.ChangeParameterMetaData;\n+import liquibase.change.DatabaseChange;\n+import liquibase.change.core.CreateIndexChange;\n+import liquibase.database.AbstractJdbcDatabase;\n+import liquibase.database.Database;\n+import liquibase.exception.DatabaseException;\n+import liquibase.exception.UnexpectedLiquibaseException;\n+import liquibase.exception.ValidationErrors;\n+import liquibase.exception.Warnings;\n+import liquibase.executor.ExecutorService;\n+import liquibase.executor.LoggingExecutor;\n+import liquibase.snapshot.InvalidExampleException;\n+import liquibase.snapshot.SnapshotGeneratorFactory;\n+import liquibase.sqlgenerator.SqlGeneratorFactory;\n+import liquibase.statement.SqlStatement;\n+import liquibase.statement.core.CreateIndexStatement;\n+import liquibase.statement.core.RawSqlStatement;\n+import liquibase.structure.core.Schema;\n+import liquibase.structure.core.Table;\n+\n+/**\n+ * @author <a href=\"mailto:yoshiyuki.tabata.jy@hitachi.com\">Yoshiyuki Tabata</a>\n+ */\n+@DatabaseChange(name = \"createIndex\", description = \"Creates an index on an existing column or set of columns conditionally based on the number of records.\", priority = ChangeMetaData.PRIORITY_DEFAULT\n+    + 1, appliesTo = \"index\")\n+public class CustomCreateIndexChange extends CreateIndexChange {\n+    private static final Logger logger = Logger.getLogger(CustomCreateIndexChange.class);\n+    private int indexCreationThreshold;\n+\n+    @Override\n+    public SqlStatement[] generateStatements(Database database) {\n+        // This check is for manual migration\n+        if (ExecutorService.getInstance().getExecutor(database) instanceof LoggingExecutor)\n+            return super.generateStatements(database);\n+\n+        Object indexCreationThreshold = ((AbstractJdbcDatabase) database)\n+            .get(DefaultLiquibaseConnectionProvider.INDEX_CREATION_THRESHOLD_PARAM);\n+\n+        if (indexCreationThreshold instanceof Integer) {\n+            this.indexCreationThreshold = (Integer) indexCreationThreshold;\n+            if (this.indexCreationThreshold <= 0)\n+                return super.generateStatements(database);\n+        } else {\n+            return super.generateStatements(database);\n+        }\n+        try {\n+            if (!SnapshotGeneratorFactory.getInstance()\n+                .has(new Table().setName(getTableName()).setSchema(new Schema(getCatalogName(), getSchemaName())), database))\n+                return super.generateStatements(database);\n+\n+            int result = ExecutorService.getInstance().getExecutor(database).queryForInt(\n+                new RawSqlStatement(\"SELECT COUNT(*) FROM \" + getTableNameForSqlSelects(database, getTableName())));\n+\n+            if (result > this.indexCreationThreshold) {\n+                String loggingString = createLoggingString(database);\n+                logger.warnv(\"Following index should be created: {0}\", loggingString);\n+                getChangeSet().setComments(loggingString);\n+                return new SqlStatement[] {};\n+            }\n+\n+        } catch (DatabaseException | InvalidExampleException e) {\n+            throw new UnexpectedLiquibaseException(\"Database error while index threshold validation.\", e);\n+        }\n+\n+        return super.generateStatements(database);\n+    }\n+\n+    private String getTableNameForSqlSelects(Database database, String tableName) {\n+        String correctedSchemaName = database.escapeObjectName(database.getDefaultSchemaName(), Schema.class);\n+        return LiquibaseJpaUpdaterProvider.getTable(tableName, correctedSchemaName);\n+    }\n+\n+    private String createLoggingString(Database database) throws DatabaseException {\n+        StringWriter writer = new StringWriter();\n+        LoggingExecutor loggingExecutor = new LoggingExecutor(ExecutorService.getInstance().getExecutor(database), writer,\n+            database);\n+        SqlStatement sqlStatement = new CreateIndexStatement(getIndexName(), getCatalogName(), getSchemaName(), getTableName(),\n+            this.isUnique(), getAssociatedWith(), getColumns().toArray(new AddColumnConfig[getColumns().size()]))\n+                .setTablespace(getTablespace()).setClustered(getClustered());\n+\n+        loggingExecutor.execute(sqlStatement);\n+\n+        return writer.toString();\n+    }\n+\n+    @Override\n+    public boolean generateStatementsVolatile(Database database) {", "originalCommit": "052e14bb2fb06a13b698198b355ed9ca53a8b2c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1NzU4MA==", "url": "https://github.com/keycloak/keycloak/pull/7657#discussion_r544657580", "bodyText": "Without these 3 override methods and without expressly calling the generateStatements method of the superclass, the generateStatements method of this class is called 14 times in one migration (so the warning outputs 14 times).\nI also considered the way to add if which judges the caller method by using stack trace in the generateStatements method, but I think the current way is smarter.\nIf there is a better way, I'm happy if you tell me.", "author": "y-tabata", "createdAt": "2020-12-16T22:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODU2NQ=="}], "type": "inlineReview"}, {"oid": "486733f8f8fc557a94ee93072eba08eed8daea74", "url": "https://github.com/keycloak/keycloak/commit/486733f8f8fc557a94ee93072eba08eed8daea74", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-16T21:46:29Z", "type": "commit"}, {"oid": "486733f8f8fc557a94ee93072eba08eed8daea74", "url": "https://github.com/keycloak/keycloak/commit/486733f8f8fc557a94ee93072eba08eed8daea74", "message": "KEYCLOAK-11908 Support for conditional creating indices based on number\nof records", "committedDate": "2020-12-16T21:46:29Z", "type": "forcePushed"}]}