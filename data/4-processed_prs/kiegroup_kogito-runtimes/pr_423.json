{"pr_number": 423, "pr_title": "[KOGITO-1248] Align hierarchy", "pr_createdAt": "2020-04-07T11:05:46Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/423", "timeline": [{"oid": "a9d3b34fdf13e43d5fb0092cad4021b8c78e5ba1", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a9d3b34fdf13e43d5fb0092cad4021b8c78e5ba1", "message": "[KOGITO-1248] Align hierarchy and reduce duplication\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-07T15:32:35Z", "type": "forcePushed"}, {"oid": "aa4884610fda7f7cb8d14a572f09a8b85c8d5c9c", "url": "https://github.com/kiegroup/kogito-runtimes/commit/aa4884610fda7f7cb8d14a572f09a8b85c8d5c9c", "message": "[KOGITO-1248] Align hierarchy and reduce duplication\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-08T16:23:49Z", "type": "forcePushed"}, {"oid": "518fba5360f774affe52d06d55c21b1aa0b05f3d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/518fba5360f774affe52d06d55c21b1aa0b05f3d", "message": "[KOGITO-1248] Align hierarchy and reduce duplication\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-08T16:59:00Z", "type": "forcePushed"}, {"oid": "bd0191b27e5f6345fb33d1c76d9d5017c59cb7b0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/bd0191b27e5f6345fb33d1c76d9d5017c59cb7b0", "message": "[KOGITO-1248] Split input files\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-13T08:29:49Z", "type": "forcePushed"}, {"oid": "789d67300079d65ead1b8103e4ace931f9e8afbf", "url": "https://github.com/kiegroup/kogito-runtimes/commit/789d67300079d65ead1b8103e4ace931f9e8afbf", "message": "[KOGITO-1248] Split input files\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-13T09:02:15Z", "type": "forcePushed"}, {"oid": "c43aa82884dc7c5e8ffecd46afe22b35303c0bd7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c43aa82884dc7c5e8ffecd46afe22b35303c0bd7", "message": "[KOGITO-1248] Remove future resource\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-15T06:16:49Z", "type": "forcePushed"}, {"oid": "1922aba0f5f1b9a959dd0a6be4907bc5d3c07737", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1922aba0f5f1b9a959dd0a6be4907bc5d3c07737", "message": "[KOGITO-1248] Remove future resource and allow yaml extensions workflows\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-15T07:46:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2Mzc5Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r408663796", "bodyText": "any reason for using the generic interface instead of the implementation?", "author": "evacchi", "createdAt": "2020-04-15T08:18:59Z", "path": "jbpm/jbpm-flow-builder/src/test/java/org/jbpm/compiler/canonical/ProcessToExecModelGeneratorTest.java", "diffHunk": "@@ -61,9 +61,9 @@ public void testScriptAndWorkItemGeneration() {\n         .connection(4, 2)\n         .connection(1, 3);\n         \n-        Process process = factory.validate().getProcess();\n+        WorkflowProcess process = factory.validate().getProcess();\n         \n-        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate((WorkflowProcess) process);\n+        ProcessMetaData processMetadata = ProcessToExecModelGenerator.INSTANCE.generate(process);", "originalCommit": "1922aba0f5f1b9a959dd0a6be4907bc5d3c07737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2ODcyMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r408668721", "bodyText": "It is redundant. Any reason not to do it? \ud83d\ude04", "author": "ruromero", "createdAt": "2020-04-15T08:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2Mzc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4MDkzOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r408680939", "bodyText": "Just asking :) sometimes we may want to use the implementation directly and/or we may want to drop some useless interfaces in Kogito (at some point in time :P) so using the implementation (if no cast is involved) could be even safer. Anyway, that's ok here.", "author": "evacchi", "createdAt": "2020-04-15T08:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2Mzc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5NTYxMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r408695610", "bodyText": "I always prefer to use the interface when possible. If we want to drop useless interfaces this is a good point to think it they're really useless. As you said, if a casting is involved, the interface should not be used.", "author": "ruromero", "createdAt": "2020-04-15T09:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2Mzc5Ng=="}], "type": "inlineReview"}, {"oid": "748b1bf4fdeca66204db8f1932f6709eb9f61237", "url": "https://github.com/kiegroup/kogito-runtimes/commit/748b1bf4fdeca66204db8f1932f6709eb9f61237", "message": "[KOGITO-1248] Remove future resource and allow yaml extensions workflows\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-15T08:42:45Z", "type": "forcePushed"}, {"oid": "ad25a4dc4ae9cb6a7be2e2ddb3b988aa682ad658", "url": "https://github.com/kiegroup/kogito-runtimes/commit/ad25a4dc4ae9cb6a7be2e2ddb3b988aa682ad658", "message": "[KOGITO-1248] Remove future resource and allow yaml extensions workflows\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-15T09:08:56Z", "type": "forcePushed"}, {"oid": "7c14c4cc6282686f7264cf764c658d4987b0a0d6", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7c14c4cc6282686f7264cf764c658d4987b0a0d6", "message": "[KOGITO-1248] Remove future resource and allow yaml extensions workflows\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-15T15:59:29Z", "type": "forcePushed"}, {"oid": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "message": "[KOGITO-1248] Remove future resource and allow yaml extensions workflows\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-15T19:57:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNjg1MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409306850", "bodyText": "maybe a JIRA for this?", "author": "cristianonicolai", "createdAt": "2020-04-16T06:17:20Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ProcessVisitor.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.compiler.canonical;\n+\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.LongLiteralExpr;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NullLiteralExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.VariableDeclarationExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import org.jbpm.process.core.ContextContainer;\n+import org.jbpm.process.core.Work;\n+import org.jbpm.process.core.context.variable.Variable;\n+import org.jbpm.process.core.context.variable.VariableScope;\n+import org.jbpm.process.core.datatype.impl.type.ObjectDataType;\n+import org.jbpm.ruleflow.core.RuleFlowProcessFactory;\n+import org.jbpm.workflow.core.Node;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.ConnectionImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.CompositeContextNode;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.EventSubProcessNode;\n+import org.jbpm.workflow.core.node.FaultNode;\n+import org.jbpm.workflow.core.node.ForEachNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.RuleSetNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.SubProcessNode;\n+import org.jbpm.workflow.core.node.TimerNode;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.WorkflowProcess;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory.METHOD_CONNECTION;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_DYNAMIC;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_GLOBAL;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_IMPORTS;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_NAME;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_PACKAGE_NAME;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VALIDATE;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VARIABLE;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VERSION;\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METHOD_VISIBILITY;\n+\n+public class ProcessVisitor extends AbstractVisitor {\n+\n+    public static final String DEFAULT_VERSION = \"1.0\";\n+\n+    private static final String METADATA_HIDDEN = \"hidden\";\n+    private static final String METADATA_UNIQUE_ID = \"UniqueId\";\n+    private static final String METADATA_LINK_NODE_HIDDEN = \"linkNodeHidden\";\n+\n+    private Map<Class<?>, AbstractNodeVisitor> nodesVisitors = new HashMap<>();\n+\n+    public ProcessVisitor(ClassLoader contextClassLoader) {\n+        this.nodesVisitors.put(StartNode.class, new StartNodeVisitor());\n+        this.nodesVisitors.put(ActionNode.class, new ActionNodeVisitor());\n+        this.nodesVisitors.put(EndNode.class, new EndNodeVisitor());\n+        this.nodesVisitors.put(HumanTaskNode.class, new HumanTaskNodeVisitor());\n+        this.nodesVisitors.put(WorkItemNode.class, new WorkItemNodeVisitor(contextClassLoader));\n+        this.nodesVisitors.put(SubProcessNode.class, new LambdaSubProcessNodeVisitor());\n+        this.nodesVisitors.put(Split.class, new SplitNodeVisitor());\n+        this.nodesVisitors.put(Join.class, new JoinNodeVisitor());\n+        this.nodesVisitors.put(FaultNode.class, new FaultNodeVisitor());\n+        this.nodesVisitors.put(RuleSetNode.class, new RuleSetNodeVisitor(contextClassLoader));\n+        this.nodesVisitors.put(BoundaryEventNode.class, new BoundaryEventNodeVisitor());\n+        this.nodesVisitors.put(EventNode.class, new EventNodeVisitor());\n+        this.nodesVisitors.put(ForEachNode.class, new ForEachNodeVisitor(nodesVisitors));\n+        this.nodesVisitors.put(CompositeContextNode.class, new CompositeContextNodeVisitor(nodesVisitors));\n+        this.nodesVisitors.put(EventSubProcessNode.class, new EventSubprocessNodeVisitor(nodesVisitors));\n+        this.nodesVisitors.put(TimerNode.class, new TimerNodeVisitor());\n+    }\n+\n+    public void visitProcess(WorkflowProcess process, MethodDeclaration processMethod, ProcessMetaData metadata) {\n+        BlockStmt body = new BlockStmt();\n+\n+        ClassOrInterfaceType processFactoryType = new ClassOrInterfaceType(null, RuleFlowProcessFactory.class.getSimpleName());\n+\n+        // create local variable factory and assign new fluent process to it\n+        VariableDeclarationExpr factoryField = new VariableDeclarationExpr(processFactoryType, FACTORY_FIELD_NAME);\n+        MethodCallExpr assignFactoryMethod = new MethodCallExpr(new NameExpr(processFactoryType.getName().asString()), \"createProcess\");\n+        assignFactoryMethod.addArgument(new StringLiteralExpr(process.getId()));\n+        body.addStatement(new AssignExpr(factoryField, assignFactoryMethod, AssignExpr.Operator.ASSIGN));\n+\n+        // item definitions\n+        Set<String> visitedVariables = new HashSet<>();\n+        VariableScope variableScope = (VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+\n+        visitVariableScope(variableScope, body, visitedVariables);\n+        visitSubVariableScopes(process.getNodes(), body, visitedVariables);\n+\n+        visitInterfaces(process.getNodes(), body);\n+\n+        // the process itself\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_NAME, new StringLiteralExpr(process.getName()));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_PACKAGE_NAME, new StringLiteralExpr(process.getPackageName()));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_DYNAMIC, new BooleanLiteralExpr(((org.jbpm.workflow.core.WorkflowProcess) process).isDynamic()));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VERSION, new StringLiteralExpr(getOrDefault(process.getVersion(), DEFAULT_VERSION)));\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VISIBILITY, new StringLiteralExpr(getOrDefault(process.getVisibility(), WorkflowProcess.PUBLIC_VISIBILITY)));\n+\n+        visitMetaData(process.getMetaData(), body, FACTORY_FIELD_NAME);\n+\n+        visitHeader(process, body);\n+\n+        List<Node> processNodes = new ArrayList<>();\n+        for (org.kie.api.definition.process.Node procNode : process.getNodes()) {\n+            processNodes.add((org.jbpm.workflow.core.Node) procNode);\n+        }\n+        visitNodes(processNodes, body, variableScope, metadata);\n+        visitConnections(process.getNodes(), body);\n+\n+        addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VALIDATE);\n+\n+        MethodCallExpr getProcessMethod = new MethodCallExpr(new NameExpr(FACTORY_FIELD_NAME), \"getProcess\");\n+        body.addStatement(new ReturnStmt(getProcessMethod));\n+        processMethod.setBody(body);\n+    }\n+\n+    private void visitVariableScope(VariableScope variableScope, BlockStmt body, Set<String> visitedVariables) {\n+        if (variableScope != null && !variableScope.getVariables().isEmpty()) {\n+            for (Variable variable : variableScope.getVariables()) {\n+\n+                if (!visitedVariables.add(variable.getName())) {\n+                    continue;\n+                }\n+                String tags = (String) variable.getMetaData(Variable.VARIABLE_TAGS);\n+                ClassOrInterfaceType variableType = new ClassOrInterfaceType(null, ObjectDataType.class.getSimpleName());\n+                ObjectCreationExpr variableValue = new ObjectCreationExpr(null, variableType, new NodeList<>(new StringLiteralExpr(variable.getType().getStringType())));\n+                addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_VARIABLE, new StringLiteralExpr(variable.getName()), variableValue, new StringLiteralExpr(Variable.VARIABLE_TAGS), tags != null ? new StringLiteralExpr(tags) : new NullLiteralExpr());\n+            }\n+        }\n+    }\n+\n+    private void visitSubVariableScopes(org.kie.api.definition.process.Node[] nodes, BlockStmt body, Set<String> visitedVariables) {\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            if (node instanceof ContextContainer) {\n+                VariableScope variableScope = (VariableScope)\n+                        ((ContextContainer) node).getDefaultContext(VariableScope.VARIABLE_SCOPE);\n+                if (variableScope != null) {\n+                    visitVariableScope(variableScope, body, visitedVariables);\n+                }\n+            }\n+            if (node instanceof NodeContainer) {\n+                visitSubVariableScopes(((NodeContainer) node).getNodes(), body, visitedVariables);\n+            }\n+        }\n+    }\n+\n+    private void visitHeader(WorkflowProcess process, BlockStmt body) {\n+        Map<String, Object> metaData = getMetaData(process.getMetaData());\n+        Set<String> imports = ((org.jbpm.process.core.Process) process).getImports();\n+        Map<String, String> globals = ((org.jbpm.process.core.Process) process).getGlobals();\n+        if ((imports != null && !imports.isEmpty()) || (globals != null && globals.size() > 0) || !metaData.isEmpty()) {\n+            if (imports != null) {\n+                for (String s : imports) {\n+                    addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_IMPORTS, new StringLiteralExpr(s));\n+                }\n+            }\n+            if (globals != null) {\n+                for (Map.Entry<String, String> global : globals.entrySet()) {\n+                    addFactoryMethodWithArgs(FACTORY_FIELD_NAME, body, METHOD_GLOBAL, new StringLiteralExpr(global.getKey()), new StringLiteralExpr(global.getValue()));\n+                }\n+            }\n+        }\n+    }\n+\n+    private Map<String, Object> getMetaData(Map<String, Object> input) {\n+        Map<String, Object> metaData = new HashMap<>();\n+        for (Map.Entry<String, Object> entry : input.entrySet()) {\n+            String name = entry.getKey();\n+            if (entry.getKey().startsWith(\"custom\")\n+                    && entry.getValue() instanceof String) {\n+                metaData.put(name, entry.getValue());\n+            }\n+        }\n+        return metaData;\n+    }\n+\n+    private void visitNodes(List<org.jbpm.workflow.core.Node> nodes, BlockStmt body, VariableScope variableScope, ProcessMetaData metadata) {\n+\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            AbstractNodeVisitor visitor = nodesVisitors.get(node.getClass());\n+\n+            if (visitor == null) {\n+                throw new IllegalStateException(\"No visitor found for node \" + node.getClass().getName());\n+            }\n+\n+            visitor.visitNode(node, body, variableScope, metadata);\n+        }\n+    }\n+\n+    private void visitConnections(org.kie.api.definition.process.Node[] nodes, BlockStmt body) {\n+\n+        List<Connection> connections = new ArrayList<>();\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            for (List<Connection> connectionList : node.getIncomingConnections().values()) {\n+                connections.addAll(connectionList);\n+            }\n+        }\n+        for (Connection connection : connections) {\n+            visitConnection(connection, body);\n+        }\n+    }\n+\n+    private void visitInterfaces(org.kie.api.definition.process.Node[] nodes, BlockStmt body) {\n+        for (org.kie.api.definition.process.Node node : nodes) {\n+            if (node instanceof WorkItemNode) {\n+                Work work = ((WorkItemNode) node).getWork();\n+                if (work != null) {\n+                    // TODO - finish this method", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3MTMxMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409471310", "bodyText": "Created Jira KOGITO-1882 and added as a comment", "author": "ruromero", "createdAt": "2020-04-16T11:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNjg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwODk0Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409308943", "bodyText": "formatting seems a bit off from here", "author": "cristianonicolai", "createdAt": "2020-04-16T06:22:44Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/DynamicNodeFactory.java", "diffHunk": "@@ -16,111 +16,90 @@\n \n package org.jbpm.ruleflow.core.factory;\n \n-import org.jbpm.process.core.datatype.DataType;\n-import org.jbpm.process.core.context.exception.ActionExceptionHandler;\n import org.jbpm.process.core.context.exception.ExceptionHandler;\n-import org.jbpm.process.core.context.exception.ExceptionScope;\n-import org.jbpm.process.core.context.variable.Variable;\n-import org.jbpm.process.core.context.variable.VariableScope;\n+import org.jbpm.process.core.datatype.DataType;\n import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n-import org.jbpm.workflow.core.Node;\n import org.jbpm.workflow.core.NodeContainer;\n-import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n import org.jbpm.workflow.core.node.CompositeContextNode;\n import org.jbpm.workflow.core.node.DynamicNode;\n \n /**\n  *\n  */\n-public class DynamicNodeFactory extends RuleFlowNodeContainerFactory {\n+public class DynamicNodeFactory extends CompositeContextNodeFactory {\n \n-\tprivate RuleFlowNodeContainerFactory nodeContainerFactory;\n-\tprivate NodeContainer nodeContainer;\n-\tprivate long linkedIncomingNodeId = -1;\n-\tprivate long linkedOutgoingNodeId = -1;\n-\t\n     public DynamicNodeFactory(RuleFlowNodeContainerFactory nodeContainerFactory, NodeContainer nodeContainer, long id) {\n-    \tthis.nodeContainerFactory = nodeContainerFactory;\n-    \tthis.nodeContainer = nodeContainer;\n-    \tDynamicNode compositeNode = new DynamicNode();\n-        compositeNode.setId(id);\n-        setNodeContainer(compositeNode);\n-    }\n-    \n-    protected CompositeContextNode getCompositeNode() {\n-    \treturn (CompositeContextNode) getNodeContainer();\n+    \tsuper(nodeContainerFactory, nodeContainer, id);\n     }\n-    \n+\n+    @Override\n+    protected CompositeContextNode createNode() {\n+    \treturn new DynamicNode();\n+\t}\n+\n     protected DynamicNode getDynamicNode() {\n     \treturn (DynamicNode) getNodeContainer();\n     }\n \n+\t@Override\n+\tprotected CompositeContextNode getCompositeNode() {\n+\t\treturn (CompositeContextNode) getNodeContainer();\n+\t}\n+\n+    @Override\n     public DynamicNodeFactory variable(String name, DataType type) {\n-    \treturn variable(name, type, null);\n+    \tsuper.variable(name, type);\n+    \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory variable(String name, DataType type, Object value) {\n-    \tVariable variable = new Variable();\n-    \tvariable.setName(name);\n-    \tvariable.setType(type);\n-    \tvariable.setValue(value);\n-    \tVariableScope variableScope = (VariableScope)\n-\t\t\tgetCompositeNode().getDefaultContext(VariableScope.VARIABLE_SCOPE);\n-\t\tif (variableScope == null) {\n-\t\t\tvariableScope = new VariableScope();\n-\t\t\tgetCompositeNode().addContext(variableScope);\n-\t\t\tgetCompositeNode().setDefaultContext(variableScope);\n-\t\t}\n-\t\tvariableScope.getVariables().add(variable);\n-        return this;\n+    \tsuper.variable(name, type, value);\n+    \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory exceptionHandler(String exception, ExceptionHandler exceptionHandler) {\n-    \tExceptionScope exceptionScope = (ExceptionScope)\n-\t\t\tgetCompositeNode().getDefaultContext(ExceptionScope.EXCEPTION_SCOPE);\n-\t\tif (exceptionScope == null) {\n-\t\t\texceptionScope = new ExceptionScope();\n-\t\t\tgetCompositeNode().addContext(exceptionScope);\n-\t\t\tgetCompositeNode().setDefaultContext(exceptionScope);\n-\t\t}\n-\t\texceptionScope.setExceptionHandler(exception, exceptionHandler);\n+    \tsuper.exceptionHandler(exception, exceptionHandler);\n     \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory exceptionHandler(String exception, String dialect, String action) {\n-    \tActionExceptionHandler exceptionHandler = new ActionExceptionHandler();\n-    \texceptionHandler.setAction(new DroolsConsequenceAction(dialect, action));\n-    \treturn exceptionHandler(exception, exceptionHandler);\n+    \tsuper.exceptionHandler(exception, dialect, action);\n+    \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory autoComplete(boolean autoComplete) {\n-    \tgetDynamicNode().setAutoComplete(autoComplete);\n+    \tsuper.autoComplete(autoComplete);\n     \treturn this;\n     }\n-    \n+\n+    @Override\n     public DynamicNodeFactory linkIncomingConnections(long nodeId) {\n-    \tthis.linkedIncomingNodeId = nodeId;\n+    \tsuper.linkIncomingConnections(nodeId);\n         return this;\n     }\n \n+\t@Override\n     public DynamicNodeFactory linkOutgoingConnections(long nodeId) {\n-    \tthis.linkedOutgoingNodeId = nodeId;\n+    \tsuper.linkOutgoingConnections(nodeId);\n     \treturn this;\n     }\n \n-    public RuleFlowNodeContainerFactory done() {\n-    \tif (linkedIncomingNodeId != -1) {\n-    \t\tgetCompositeNode().linkIncomingConnections(\n-\t\t\t\tNode.CONNECTION_DEFAULT_TYPE,\n-\t\t        linkedIncomingNodeId, Node.CONNECTION_DEFAULT_TYPE);\n-    \t}\n-    \tif (linkedOutgoingNodeId != -1) {\n-    \t\tgetCompositeNode().linkOutgoingConnections(\n-\t\t\t\tlinkedOutgoingNodeId, Node.CONNECTION_DEFAULT_TYPE,\n-\t            Node.CONNECTION_DEFAULT_TYPE);\n-    \t}\n-        nodeContainer.addNode(getCompositeNode());\n-        return nodeContainerFactory;\n-    }\n+    public DynamicNodeFactory language(String language) {\n+    \tgetDynamicNode().setLanguage(language);", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwOTQ5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409309492", "bodyText": "could be removed or documented? :)", "author": "cristianonicolai", "createdAt": "2020-04-16T06:24:01Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/ExtendedNodeFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwOTU5OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409309598", "bodyText": "can we remove these extra lines?", "author": "cristianonicolai", "createdAt": "2020-04-16T06:24:19Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/ExtendedNodeFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *\n+ */\n+public abstract class ExtendedNodeFactory extends NodeFactory {\n+\n+    protected static final String METADATA_ACTION = \"Action\";\n+\n+    protected ExtendedNodeFactory(RuleFlowNodeContainerFactory nodeContainerFactory, NodeContainer nodeContainer, long id) {\n+        super(nodeContainerFactory, nodeContainer, id);\n+    }\n+\n+    protected ExtendedNodeImpl getExtendedNode() {\n+        return (ExtendedNodeImpl) getNode();\n+    }\n+\n+    public ExtendedNodeFactory onEntryAction(String dialect, String action) {\n+        if (getExtendedNode().getActions(dialect) != null) {\n+            getExtendedNode().getActions(dialect).add(new DroolsConsequenceAction(dialect, action));\n+        } else {\n+            List<DroolsAction> actions = new ArrayList<>();\n+            actions.add(new DroolsConsequenceAction(dialect, action));\n+            getExtendedNode().setActions(ExtendedNodeImpl.EVENT_NODE_ENTER, actions);\n+        }\n+        return this;\n+    }\n+\n+    public ExtendedNodeFactory onExitAction(String dialect, String action) {\n+        if (getExtendedNode().getActions(dialect) != null) {\n+            getExtendedNode().getActions(dialect).add(new DroolsConsequenceAction(dialect, action));\n+        } else {\n+            List<DroolsAction> actions = new ArrayList<>();\n+            actions.add(new DroolsConsequenceAction(dialect, action));\n+            getExtendedNode().setActions(ExtendedNodeImpl.EVENT_NODE_EXIT, actions);\n+        }\n+        return this;\n+    }\n+}\n+", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMDE1Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409310152", "bodyText": "no need for public static final", "author": "cristianonicolai", "createdAt": "2020-04-16T06:25:49Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/MappableNodeFactory.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.process.core.context.variable.Mappable;\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+\n+/**\n+ *\n+ */\n+public interface MappableNodeFactory {\n+\n+    String METHOD_IN_MAPPING = \"inMapping\";\n+    public static final String METHOD_OUT_MAPPING = \"outMapping\";", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMDI4MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409310281", "bodyText": "same here to remove.", "author": "cristianonicolai", "createdAt": "2020-04-16T06:26:06Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/MappableNodeFactory.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.process.core.context.variable.Mappable;\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+\n+/**\n+ *", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMDMzMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409310333", "bodyText": "and here :)", "author": "cristianonicolai", "createdAt": "2020-04-16T06:26:13Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/MappableNodeFactory.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.ruleflow.core.factory;\n+\n+import org.jbpm.process.core.context.variable.Mappable;\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\n+import org.jbpm.workflow.core.NodeContainer;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+\n+/**\n+ *\n+ */\n+public interface MappableNodeFactory {\n+\n+    String METHOD_IN_MAPPING = \"inMapping\";\n+    public static final String METHOD_OUT_MAPPING = \"outMapping\";\n+\n+    Mappable getMappableNode();\n+\n+    default MappableNodeFactory inMapping(String parameterName, String variableName) {\n+        getMappableNode().addInMapping(parameterName, variableName);\n+        return this;\n+    }\n+\n+    default MappableNodeFactory outMapping(String parameterName, String variableName) {\n+        getMappableNode().addOutMapping(parameterName, variableName);\n+        return this;\n+    }\n+}\n+", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMTE0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409311145", "bodyText": "perhaps rename to SUPPORTED_SW_EXTENSIONS ?", "author": "cristianonicolai", "createdAt": "2020-04-16T06:28:18Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/ProcessCodegen.java", "diffHunk": "@@ -81,6 +82,10 @@\n     private static final Logger LOGGER = LoggerFactory.getLogger(ProcessCodegen.class);\n \n     private static final SemanticModules BPMN_SEMANTIC_MODULES = new SemanticModules();\n+    private static final Set<String> SUPPORTED_BPMN_EXTENSIONS = Collections.unmodifiableSet(Set.of(\".bpmn\", \".bpmn2\"));\n+    private static final String YAML_PARSER = \"yml\";\n+    private static final String JSON_PARSER = \"json\";\n+    private static final Map<String, String> SUPPORTED_WORKFLOW_EXTENSIONS = Map.of(\".sw.yml\", YAML_PARSER, \".sw.yaml\", YAML_PARSER, \".sw.json\", JSON_PARSER);", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMTMwNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409311307", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n          \n          \n            \n             * Copyright 2020 Red Hat, Inc. and/or its affiliates.", "author": "cristianonicolai", "createdAt": "2020-04-16T06:28:41Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MTQ2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409461460", "bodyText": "Already in the parent PR", "author": "ruromero", "createdAt": "2020-04-16T10:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMjEwOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409312109", "bodyText": "same comment as in the other PR, to make each file the parametrized test, and findining the files dinamically so every new resource is included by default.", "author": "cristianonicolai", "createdAt": "2020-04-16T06:30:41Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,488 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.CompositeNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed processes in process-generation folder files\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final String TEST_FILE_PATH = \"src/test/resources/org/kie/kogito/codegen/process-generation/%s.txt\";\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"businessruleunit\", \"decision\", \"event-subprocess\",\n+            \"gateway\", \"messageevent\", \"messagestartevent\", \"ruletask\", \"servicetask\",\n+            \"signalevent\", \"subprocess\", \"timer\", \"usertask\", \"serverless\"})\n+    public void testProcessesGeneration(String fileName) throws IOException {\n+        Files.lines(Paths.get(String.format(TEST_FILE_PATH, fileName)))", "originalCommit": "7dac1c9316a3d8c78db1bf66c0b21e11649f8725", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MTI5Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r409461297", "bodyText": "Yes, this will be there once rebased", "author": "ruromero", "createdAt": "2020-04-16T10:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxMjEwOQ=="}], "type": "inlineReview"}, {"oid": "4b66df9c8558159a50f07d30df6a429d358c2a47", "url": "https://github.com/kiegroup/kogito-runtimes/commit/4b66df9c8558159a50f07d30df6a429d358c2a47", "message": "[KOGITO-1248] Changes after review\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T11:03:52Z", "type": "forcePushed"}, {"oid": "3a469f01cfc7bc594912b82b472b62ef874fbc59", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3a469f01cfc7bc594912b82b472b62ef874fbc59", "message": "[KOGITO-1248] Changes after review\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T11:05:56Z", "type": "forcePushed"}, {"oid": "493f7b899aaca33af11d2f951791440dbc0ec510", "url": "https://github.com/kiegroup/kogito-runtimes/commit/493f7b899aaca33af11d2f951791440dbc0ec510", "message": "[KOGITO-1248] Changes after review\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T11:09:51Z", "type": "forcePushed"}, {"oid": "72225afca3217acfd56b929bff94f70c471992e7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/72225afca3217acfd56b929bff94f70c471992e7", "message": "[KOGITO-1248] Changes after review\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:28:58Z", "type": "forcePushed"}, {"oid": "8adc0e5274854616861b1e996cb71ed4903664f8", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8adc0e5274854616861b1e996cb71ed4903664f8", "message": "[KOGITO-1248] Changes after review\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:32:43Z", "type": "forcePushed"}, {"oid": "a3661f01ed825b86a761bd56b6f1c2e2b3b140d7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a3661f01ed825b86a761bd56b6f1c2e2b3b140d7", "message": "[KOGITO-1248] Avoid java11 methods\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-17T08:15:59Z", "type": "forcePushed"}, {"oid": "3d2fb94ce7ef6e8e6b204cad9770188e41037a0b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3d2fb94ce7ef6e8e6b204cad9770188e41037a0b", "message": "[KOGITO-1248] Avoid java11 methods\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-17T09:49:32Z", "type": "forcePushed"}, {"oid": "18827b763810b049fe848b629ee4ae5c1922a869", "url": "https://github.com/kiegroup/kogito-runtimes/commit/18827b763810b049fe848b629ee4ae5c1922a869", "message": "[KOGITO-1248] Align hierarchy and reduce duplication\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-17T10:59:51Z", "type": "commit"}, {"oid": "18827b763810b049fe848b629ee4ae5c1922a869", "url": "https://github.com/kiegroup/kogito-runtimes/commit/18827b763810b049fe848b629ee4ae5c1922a869", "message": "[KOGITO-1248] Align hierarchy and reduce duplication\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-17T10:59:51Z", "type": "forcePushed"}, {"oid": "2fcb4b6a8ce7f786013485cf1c85c8b588e9c8f5", "url": "https://github.com/kiegroup/kogito-runtimes/commit/2fcb4b6a8ce7f786013485cf1c85c8b588e9c8f5", "message": "[KOGITO-1248] Increase code coverage\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-17T14:58:13Z", "type": "commit"}, {"oid": "f827ed415abd22a31c3861065c765d3aa64897fb", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f827ed415abd22a31c3861065c765d3aa64897fb", "message": "[KOGITO-1248] addStatement\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-17T16:13:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIwMDE2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/423#discussion_r410200163", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n          \n          \n            \n             * Copyright 2020 Red Hat, Inc. and/or its affiliates.", "author": "cristianonicolai", "createdAt": "2020-04-17T12:50:09Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/CompositeContextNodeFactory.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.", "originalCommit": "18827b763810b049fe848b629ee4ae5c1922a869", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "feb4456c2c62934244f59743f63a99d45407c7b6", "url": "https://github.com/kiegroup/kogito-runtimes/commit/feb4456c2c62934244f59743f63a99d45407c7b6", "message": "Update jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/CompositeContextNodeFactory.java\n\nCo-Authored-By: Cristiano Nicolai <cristiano.nicolai@gmail.com>", "committedDate": "2020-04-20T09:17:21Z", "type": "commit"}]}