{"pr_number": 416, "pr_title": "[KOGITO-1248] Add process generation tests and some fixes", "pr_createdAt": "2020-04-03T15:49:46Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/416", "timeline": [{"oid": "92a68ace794f9dec3b20b08c3bf7499f440fccf5", "url": "https://github.com/kiegroup/kogito-runtimes/commit/92a68ace794f9dec3b20b08c3bf7499f440fccf5", "message": "[KOGITO-1248] Add process generation tests and some fixes\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-03T15:51:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NjA1OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405086058", "bodyText": "I think you can use the already defined method on AbstractVisitor, \n  \n    \n      kogito-runtimes/jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/AbstractVisitor.java\n    \n    \n         Line 163\n      in\n      e785096\n    \n    \n    \n    \n\n        \n          \n           protected void addNodeMappings(Mappable node, BlockStmt body, String variableName) { \n        \n    \n  \n\n\nBut it is at least strange the things are working without this mapping... and probably it would be necessary on other visitors like EventNode, EndNode, etc... WDYT?", "author": "tiagodolphine", "createdAt": "2020-04-07T20:18:16Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/StartNodeVisitor.java", "diffHunk": "@@ -51,7 +51,7 @@ public void visitNode(String factoryField, Node node, BlockStmt body, VariableSc\n         visitMetaData(startNode.getMetaData(), body, \"startNode\" + node.getId());\n         \n         addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"done\");\n-        \n+        startNode.getOutMappings().forEach((k, v) -> addFactoryMethodWithArgs(body, \"startNode\" + node.getId(), \"addOutMapping\", new StringLiteralExpr(k), new StringLiteralExpr(v)));", "originalCommit": "92a68ace794f9dec3b20b08c3bf7499f440fccf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM2ODE4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405368187", "bodyText": "Actually I had to rollback the change because the getInMappings method for StartNode throws an IllegalArgumentException", "author": "ruromero", "createdAt": "2020-04-08T09:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NjA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0NjM2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405546367", "bodyText": "After our discussion I changed it back again and the StartNode don't throw exceptions for getters only for setters.", "author": "ruromero", "createdAt": "2020-04-08T13:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NjA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MjQzNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405092437", "bodyText": "you can follow the same name pattern for other NodeFactories, like HumanTaskNodeFactory.outMapping.. but as I said on the other comment why this call was not necessary for other nodes, like EventNode, EndNode, etc...", "author": "tiagodolphine", "createdAt": "2020-04-07T20:29:35Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/factory/StartNodeFactory.java", "diffHunk": "@@ -50,6 +50,11 @@ public StartNodeFactory interrupting(boolean interrupting) {\n         getStartNode().setInterrupting(interrupting);\n         return this;\n     }\n+\n+    public StartNodeFactory addOutMapping(String parameterName, String variableName) {", "originalCommit": "92a68ace794f9dec3b20b08c3bf7499f440fccf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MzA1MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r405093051", "bodyText": "maybe a simple javadoc comment to explain the purpose of the class...", "author": "tiagodolphine", "createdAt": "2020-04-07T20:30:44Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.assertj.core.api.ThrowableAssert;\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.*;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ProcessGenerationTest extends AbstractCodegenTest {", "originalCommit": "92a68ace794f9dec3b20b08c3bf7499f440fccf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwOTI1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r407909254", "bodyText": "we had to revert to JDK 8 compatibility on 0.9.x branch. We will merge this back on master too. This is therefore not a valid method call.", "author": "evacchi", "createdAt": "2020-04-14T07:02:41Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -97,12 +97,12 @@ public RuleFlowProcessFactory packageName(String packageName) {\n     }\n \n     public RuleFlowProcessFactory imports(String... imports) {\n-    \tgetRuleFlowProcess().setImports(new HashSet<String>(Arrays.asList(imports)));\n+        getRuleFlowProcess().getImports().addAll(Set.of(imports));", "originalCommit": "9a2e041f43c979b5952acc8a4a274e5292206ac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY3NDgyMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408674821", "bodyText": "Done, thanks", "author": "ruromero", "createdAt": "2020-04-15T08:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkwOTI1NA=="}], "type": "inlineReview"}, {"oid": "eac934e923ddfa7417d6a47493e8c86e59176f34", "url": "https://github.com/kiegroup/kogito-runtimes/commit/eac934e923ddfa7417d6a47493e8c86e59176f34", "message": "[KOGITO-1248] Stick to jdk8\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-15T08:52:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMzkzMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408713930", "bodyText": "Probably would be nicer to have a dedicated addAll() method for this as adding something using getters may be considered as bad practice. But if we cannot/don't want to change the interfaces, I'm fine with that.", "author": "MarianMacik", "createdAt": "2020-04-15T09:42:13Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/ruleflow/core/RuleFlowProcessFactory.java", "diffHunk": "@@ -97,12 +97,12 @@ public RuleFlowProcessFactory packageName(String packageName) {\n     }\n \n     public RuleFlowProcessFactory imports(String... imports) {\n-    \tgetRuleFlowProcess().setImports(new HashSet<String>(Arrays.asList(imports)));\n+        getRuleFlowProcess().getImports().addAll(Arrays.asList(imports));\n         return this;\n     }\n     \n     public RuleFlowProcessFactory functionImports(String... functionImports) {\n-    \tgetRuleFlowProcess().setFunctionImports(Arrays.asList(functionImports));\n+        getRuleFlowProcess().getFunctionImports().addAll(Arrays.asList(functionImports));", "originalCommit": "eac934e923ddfa7417d6a47493e8c86e59176f34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MjI2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408762261", "bodyText": "Added", "author": "ruromero", "createdAt": "2020-04-15T11:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMzkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTI4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408725283", "bodyText": "Gereration -> Generation :)", "author": "MarianMacik", "createdAt": "2020-04-15T10:00:53Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {", "originalCommit": "eac934e923ddfa7417d6a47493e8c86e59176f34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTU1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408725554", "bodyText": "This will be implemented in the future? If so, we can link a JIRA here so we won't forget.", "author": "MarianMacik", "createdAt": "2020-04-15T10:01:23Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());", "originalCommit": "eac934e923ddfa7417d6a47493e8c86e59176f34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2MDU3Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408760576", "bodyText": "I'll add a different assertion", "author": "ruromero", "createdAt": "2020-04-15T11:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTY0Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408725642", "bodyText": "Same for these.", "author": "MarianMacik", "createdAt": "2020-04-15T10:01:33Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());", "originalCommit": "eac934e923ddfa7417d6a47493e8c86e59176f34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODk3Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408948977", "bodyText": "implemented assertion", "author": "ruromero", "createdAt": "2020-04-15T15:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNTY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNzQyNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408727424", "bodyText": "Maybe an improvement - assert also the size of the maps? This way it will be sure that there is nothing redundant on the current side.", "author": "MarianMacik", "createdAt": "2020-04-15T10:04:36Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));", "originalCommit": "eac934e923ddfa7417d6a47493e8c86e59176f34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0OTA5Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408949097", "bodyText": "done!", "author": "ruromero", "createdAt": "2020-04-15T15:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyNzQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyOTM4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408729386", "bodyText": "Same here.", "author": "MarianMacik", "createdAt": "2020-04-15T10:07:59Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));", "originalCommit": "eac934e923ddfa7417d6a47493e8c86e59176f34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyOTcxNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408729716", "bodyText": "Formatting here.", "author": "MarianMacik", "createdAt": "2020-04-15T10:08:34Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) ignoredKeys = new HashSet<>();", "originalCommit": "eac934e923ddfa7417d6a47493e8c86e59176f34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMDE5Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408730196", "bodyText": "Again probably asserting on the size would be beneficial?", "author": "MarianMacik", "createdAt": "2020-04-15T10:09:22Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {", "originalCommit": "eac934e923ddfa7417d6a47493e8c86e59176f34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0OTg0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408949845", "bodyText": "done too", "author": "ruromero", "createdAt": "2020-04-15T15:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMDE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMTA4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408731083", "bodyText": "@evacchi probably?", "author": "MarianMacik", "createdAt": "2020-04-15T10:11:01Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGereration);\n+    }\n+\n+    private void testProcessGereration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+//        assertEquals(expected.getVersion(), current.getVersion());\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+//        assertEquals(expected.getName(), current.getName());\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+//        assertEquals(((NodeImpl) eNode).getConstraints(), ((NodeImpl) cNode).getConstraints());\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", clazz.getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) ignoredKeys = new HashSet<>();\n+        expected.keySet()\n+                .stream()\n+                .filter(Predicate.not(ignoredKeys::contains))\n+                .forEach(k -> assertEquals(expected.get(k), current.get(k), \"Metadata \"+ k));\n+    }\n+\n+    private static void assertConnections(Map<String, List<Connection>> expectedConnections, Map<String, List<Connection>> currentConnections) {\n+        assertEquals(expectedConnections.size(), currentConnections.size());\n+        expectedConnections.forEach((type, expectedByType) -> {\n+            assertTrue(currentConnections.containsKey(type), \"Node does not have connections of type: \" + type);\n+            List<Connection> currentByType = currentConnections.get(type);\n+            expectedByType.forEach(expected -> {\n+                Optional<Connection> current = currentByType\n+                        .stream()\n+                        .filter(c -> expected.getMetaData().isEmpty() || expected.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\")))\n+                        .findFirst();\n+                assertTrue(current.isPresent(), \"Connection is present for \" + expected.getMetaData().get(\"UniqueId\"));\n+                assertEquals(expected.getFromType(), current.get().getFromType(), \"FromType\");\n+                assertEquals(expected.getFrom().getId(), current.get().getFrom().getId(), \"From.Id\");\n+                assertEquals(expected.getToType(), current.get().getToType(), \"ToType\");\n+                assertEquals(expected.getTo().getId(), current.get().getTo().getId(), \"To.Id\");\n+            });\n+        });\n+    }\n+\n+    private static void assertTriggers(List<Trigger> expected, List<Trigger> current) {\n+        try {\n+            if (expected == null) {\n+                assertNull(current);\n+                return;\n+            }\n+            assertNotNull(current);\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                Trigger e = expected.get(i);\n+                Trigger c = current.get(i);\n+                e.getInMappings().forEach((k, v) -> assertEquals(v, c.getInMapping(k), \"InMapping for \" + k));\n+                assertDataAssociations(e.getInAssociations(), c.getInAssociations());\n+            }\n+        } catch (Throwable e) {\n+            fail(\"Triggers are not equal\", e);\n+        }\n+    }\n+\n+    private static void assertDataAssociations(List<DataAssociation> expected, List<DataAssociation> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        if (expected.isEmpty()) {\n+            assertEquals(1, current.size());\n+            assertEquals(1, current.get(0).getSources().size());\n+            assertEquals(\"\", current.get(0).getSources().get(0));\n+        } else {\n+            assertEquals(expected.size(), current.size());\n+            for (int i = 0; i < expected.size(); i++) {\n+                assertEquals(expected.get(i).getSources(), current.get(i).getSources(), \"Sources\");\n+                assertEquals(expected.get(i).getTarget(), current.get(i).getTarget(), \"Target\");\n+                assertEquals(expected.get(i).getTransformation(), current.get(i).getTransformation(), \"Transformation\");\n+                assertAssignments(expected.get(i).getAssignments(), current.get(i).getAssignments());\n+            }\n+        }\n+    }\n+\n+    private static void assertActions(List<DroolsAction> expected, List<DroolsAction> current) {\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getDialect(), ((DroolsConsequenceAction) current.get(i)).getDialect(), \"Dialect\");\n+            assertEquals(((DroolsConsequenceAction) expected.get(i)).getConsequence(), ((DroolsConsequenceAction) current.get(i)).getConsequence(), \"Consequence\");\n+        }\n+    }\n+\n+    private static void assertAssignments(List<Assignment> expected, List<Assignment> current) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertEquals(expected.size(), current.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            assertEquals(expected.get(i).getFrom(), current.get(i).getFrom(), \"From\");\n+            assertEquals(expected.get(i).getDialect(), current.get(i).getDialect(), \"Dialect\");\n+            assertEquals(expected.get(i).getTo(), current.get(i).getTo(), \"To\");\n+        }\n+    }\n+\n+    private static void assertTimers(Map<Timer, DroolsAction> expected, Map<Timer, DroolsAction> current) {\n+        if(expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        assertEquals(expected.size(), current.size(), \"Size\");\n+        expected.forEach((expectedTimer, expectedAction) -> {\n+            Optional<Timer> currentTimer = current.keySet().stream().filter(c -> c.getId() == expectedTimer.getId()).findFirst();\n+            assertTrue(currentTimer.isPresent());\n+            assertEquals(expectedTimer.getPeriod(), currentTimer.get().getPeriod(), \"Period\");\n+            assertEquals(expectedTimer.getDate(), currentTimer.get().getDate(), \"Date\");\n+            assertEquals(expectedTimer.getDelay(), currentTimer.get().getDelay(), \"Delay\");\n+            assertEquals(expectedTimer.getTimeType(), currentTimer.get().getTimeType(), \"TimeType\");\n+            DroolsAction currentAction = current.get(currentTimer.get());\n+            if(expectedAction == null) {\n+                assertNull(currentAction);\n+                return;\n+            }\n+            assertNotNull(currentAction);\n+            assertEquals(expectedAction.getName(), currentAction.getName(), \"DroolsAction name\");\n+            //TODO: Is this expected? They are totally different objects. Expected DroolsConsequenceAction, Got lambda\n+            // assertEquals(expectedAction.getMetaData(DroolsAction.METADATA_ACTION), currentAction.getMetaData(DroolsAction.METADATA_ACTION));", "originalCommit": "eac934e923ddfa7417d6a47493e8c86e59176f34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzNDExOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r410034119", "bodyText": "IIRC it used to be a lambda of type DroolsAction", "author": "evacchi", "createdAt": "2020-04-17T07:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMTA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0Nzg2Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r410047866", "bodyText": "It is actually of type Action. I decided to validate just that the content is not empty. We can improve the action assertions later on, if needed.", "author": "ruromero", "createdAt": "2020-04-17T07:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMTA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1OTM0MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408959340", "bodyText": "Come on, formatting again? You can do better \ud83e\udd23", "author": "MarianMacik", "createdAt": "2020-04-15T16:04:56Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {", "originalCommit": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NzMzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409087336", "bodyText": "I just not get used to the IDE (random excuse)", "author": "ruromero", "createdAt": "2020-04-15T19:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1OTM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1OTk4NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408959984", "bodyText": "Formatting.", "author": "MarianMacik", "createdAt": "2020-04-15T16:06:01Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {\n+                assertEquals(expected.getVersion(), current.getVersion());\n+            } else {\n+                assertEquals(\"1.0\", current.getVersion());\n+            }\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+        if(expected.getName() != null) {", "originalCommit": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2MTE0Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r408961143", "bodyText": "Still formatting.", "author": "MarianMacik", "createdAt": "2020-04-15T16:07:44Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,478 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.process.instance.impl.ReturnValueConstraintEvaluator;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ConstraintImpl;\n+import org.jbpm.workflow.core.impl.DroolsConsequenceAction;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ *\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ *\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n+                .filter(f -> !f.startsWith(\"#\"))\n+                .forEach(this::testProcessGeneration);\n+    }\n+\n+    private void testProcessGeneration(String processFile) {\n+        try {\n+            List<org.kie.api.definition.process.Process> processes = ProcessCodegen.parseProcesses(Stream.of(processFile)\n+                    .map(resource -> new File(\"src/test/resources\", resource))\n+                    .collect(Collectors.toList()));\n+            RuleFlowProcess expected = (RuleFlowProcess) processes.get(0);\n+\n+            Application app = generateCodeProcessesOnly(processFile);\n+            AbstractProcess<? extends Model> process = (AbstractProcess<? extends Model>) app.processes().processById(expected.getId());\n+            RuleFlowProcess current = (RuleFlowProcess) process.legacyProcess();\n+\n+            assertNotNull(current);\n+            assertEquals(expected.getId(), current.getId(), \"Id\");\n+            assertEquals(expected.getName(), current.getName(), \"Name\");\n+            assertEquals(expected.getPackageName(), current.getPackageName(), \"PackageName\");\n+            assertEquals(expected.getVisibility(), current.getVisibility(), \"Visibility\");\n+            assertEquals(expected.getType(), current.getType(), \"Type\");\n+            assertEquals(expected.isAutoComplete(), current.isAutoComplete(), \"AutoComplete\");\n+            assertEquals(expected.isDynamic(), current.isDynamic(), \"Dynamic\");\n+            if(expected.getVersion() != null) {\n+                assertEquals(expected.getVersion(), current.getVersion());\n+            } else {\n+                assertEquals(\"1.0\", current.getVersion());\n+            }\n+            assertEquals(expected.getImports(), current.getImports(), \"Imports\");\n+            assertEquals(expected.getFunctionImports(), current.getFunctionImports(), \"FunctionImports\");\n+            assertMetadata(expected.getMetaData(), current.getMetaData(), IGNORED_PROCESS_META);\n+\n+            List<Node> expectedNodes = expected.getNodesRecursively();\n+            List<Node> currentNodes = current.getNodesRecursively();\n+            assertEquals(expectedNodes.size(), currentNodes.size());\n+            expectedNodes.forEach(eNode -> {\n+                Optional<Node> cNode = currentNodes.stream().filter(c -> eNode.getMetaData().get(\"UniqueId\").equals(c.getMetaData().get(\"UniqueId\"))).findFirst();\n+                assertTrue(cNode.isPresent(), \"Missing node \" + eNode.getName());\n+                assertNode(eNode, cNode.get());\n+            });\n+        } catch (Throwable e) {\n+            fail(\"Unable to validate process generation for: \" + processFile, e);\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> nodeAsserter = (expected, current) -> {\n+        assertEquals(expected.getId(), current.getId());\n+        if(expected.getName() != null) {\n+            assertEquals(expected.getName(), current.getName());\n+        } else {\n+            assertNotNull(current.getName());\n+        }\n+        assertConnections(expected.getIncomingConnections(), current.getIncomingConnections());\n+        assertConnections(expected.getOutgoingConnections(), current.getOutgoingConnections());\n+        assertConstraints((NodeImpl) expected, (NodeImpl) current);\n+    };\n+\n+    private static final BiConsumer<Node, Node> extendedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(ExtendedNodeImpl.class.isAssignableFrom(cNode.getClass()));\n+        ExtendedNodeImpl expected = (ExtendedNodeImpl) eNode;\n+        ExtendedNodeImpl current = (ExtendedNodeImpl) cNode;\n+        assertActions(eNode, expected, current);\n+    };\n+\n+    // onEntry and onExit actions are not yet supported - KOGITO-1709\n+    private static void assertActions(Node eNode, ExtendedNodeImpl expected, ExtendedNodeImpl current) {\n+        for (String actionType : expected.getActionTypes()) {\n+            List<DroolsAction> expectedActions = expected.getActions(actionType);\n+            if(eNode instanceof EndNode && expected.getMetaData(\"TriggerRef\") != null) {\n+                // Generated lambda to publish event for the given variable\n+                if (expectedActions == null) {\n+                    expectedActions = new ArrayList<>();\n+                }\n+                expectedActions.add(new DroolsAction());\n+            }\n+            try {\n+                if (expected.getActions(actionType) == null) {\n+                    assertNull(current.getActions(actionType));\n+                } else {\n+                    assertNotNull(current.getActions(actionType));\n+                    // onEntry and onExit actions are not yet supported\n+//                    assertEquals(expected.getActions(actionType).size(), current.getActions(actionType).size());\n+//                    assertActions(expected.getActions(actionType), current.getActions(actionType));\n+                }\n+            } catch (Throwable e) {\n+                fail(\"Actions are not equal for type: \" + actionType, e);\n+            }\n+        }\n+    }\n+\n+    private static final BiConsumer<Node, Node> startNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(StartNode.class, eNode.getClass());\n+        assertEquals(StartNode.class, cNode.getClass());\n+        StartNode expected = (StartNode) eNode;\n+        StartNode current = (StartNode) cNode;\n+        assertEquals(expected.isInterrupting(), current.isInterrupting(), \"Interrupting\");\n+        assertTriggers(expected.getTriggers(), current.getTriggers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> endNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(EndNode.class, eNode.getClass());\n+        assertEquals(EndNode.class, cNode.getClass());\n+        EndNode expected = (EndNode) eNode;\n+        EndNode current = (EndNode) cNode;\n+        assertEquals(expected.isTerminate(), current.isTerminate(), \"Terminate\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> stateBasedNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(StateBasedNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(StateBasedNode.class.isAssignableFrom(cNode.getClass()));\n+        StateBasedNode expected = (StateBasedNode) eNode;\n+        StateBasedNode current = (StateBasedNode) cNode;\n+        assertEquals(expected.getBoundaryEvents(), current.getBoundaryEvents(), \"BoundaryEvents\");\n+        assertTimers(expected.getTimers(), current.getTimers());\n+    };\n+\n+    private static final BiConsumer<Node, Node> workItemNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(WorkItemNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(WorkItemNode.class.isAssignableFrom(cNode.getClass()));\n+        WorkItemNode expected = (WorkItemNode) eNode;\n+        WorkItemNode current = (WorkItemNode) cNode;\n+        assertEquals(expected.isWaitForCompletion(), current.isWaitForCompletion(), \"WaitForCompletion\");\n+        assertEquals(expected.getInMappings().size(), current.getInMappings().size(), \"inMappings\");\n+        expected.getInMappings().forEach((k, v) -> assertEquals(v, current.getInMapping(k), \"inMapping \" + k));\n+        assertEquals(expected.getOutMappings().size(), current.getOutMappings().size(), \"outMappings\");\n+        expected.getOutMappings().forEach((k, v) -> assertEquals(v, current.getOutMapping(k), \"outMapping \" + k));\n+\n+    };\n+\n+    private static final BiConsumer<Node, Node> humanTaskNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(HumanTaskNode.class, eNode.getClass());\n+        assertEquals(HumanTaskNode.class, cNode.getClass());\n+        HumanTaskNode expected = (HumanTaskNode) eNode;\n+        HumanTaskNode current = (HumanTaskNode) cNode;\n+        assertEquals(expected.getSwimlane(), current.getSwimlane(), \"Swimlane\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> eventNodeAsserter = (eNode, cNode) -> {\n+        assertTrue(EventNode.class.isAssignableFrom(eNode.getClass()));\n+        assertTrue(EventNode.class.isAssignableFrom(cNode.getClass()));\n+        EventNode expected = (EventNode) eNode;\n+        EventNode current = (EventNode) cNode;\n+        assertEquals(expected.getScope(), current.getScope(), \"Scope\");\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getVariableName(), current.getVariableName(), \"VariableName\");\n+        assertEquals(expected.getEventFilters().size(), current.getEventFilters().size(), \"EventFilters\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> boundaryEventNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(BoundaryEventNode.class, eNode.getClass());\n+        assertEquals(BoundaryEventNode.class, cNode.getClass());\n+        BoundaryEventNode expected = (BoundaryEventNode) eNode;\n+        BoundaryEventNode current = (BoundaryEventNode) cNode;\n+        assertEquals(expected.getAttachedToNodeId(), current.getAttachedToNodeId(), \"AttachedToNodeId\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> splitNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Split.class, eNode.getClass());\n+        assertEquals(Split.class, cNode.getClass());\n+        Split expected = (Split) eNode;\n+        Split current = (Split) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> joinNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(Join.class, eNode.getClass());\n+        assertEquals(Join.class, cNode.getClass());\n+        Join expected = (Join) eNode;\n+        Join current = (Join) cNode;\n+        assertEquals(expected.getType(), current.getType(), \"Type\");\n+        assertEquals(expected.getN(), current.getN(), \"N\");\n+    };\n+\n+    private static final BiConsumer<Node, Node> actionNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(ActionNode.class, eNode.getClass());\n+        assertEquals(ActionNode.class, cNode.getClass());\n+        ActionNode expected = (ActionNode) eNode;\n+        ActionNode current = (ActionNode) cNode;\n+        if (expected.getAction() != null) {\n+            assertNotNull(current.getAction());\n+            assertEquals(expected.getAction().getName(), current.getAction().getName(), \"Action\");\n+        }\n+    };\n+\n+    private static final BiConsumer<Node, Node> milestoneNodeAsserter = (eNode, cNode) -> {\n+        assertEquals(MilestoneNode.class, eNode.getClass());\n+        assertEquals(MilestoneNode.class, cNode.getClass());\n+        MilestoneNode expected = (MilestoneNode) eNode;\n+        MilestoneNode current = (MilestoneNode) cNode;\n+        assertEquals(expected.getConstraint(), current.getConstraint(), \"Constraint\");\n+        assertEquals(expected.getMatchVariable(), current.getMatchVariable(), \"MatchVariable\");\n+    };\n+\n+    private static final Map<Class<? extends Node>, BiConsumer<Node, Node>> nodeAsserters = new HashMap<>();\n+\n+    static {\n+        nodeAsserters.put(NodeImpl.class, nodeAsserter);\n+        nodeAsserters.put(ExtendedNodeImpl.class, extendedNodeAsserter);\n+        nodeAsserters.put(StartNode.class, startNodeAsserter);\n+        nodeAsserters.put(EndNode.class, endNodeAsserter);\n+        nodeAsserters.put(Split.class, splitNodeAsserter);\n+        nodeAsserters.put(Join.class, joinNodeAsserter);\n+        nodeAsserters.put(StateBasedNode.class, stateBasedNodeAsserter);\n+        nodeAsserters.put(WorkItemNode.class, workItemNodeAsserter);\n+        nodeAsserters.put(HumanTaskNode.class, humanTaskNodeAsserter);\n+        nodeAsserters.put(EventNode.class, eventNodeAsserter);\n+        nodeAsserters.put(BoundaryEventNode.class, boundaryEventNodeAsserter);\n+        nodeAsserters.put(ActionNode.class, actionNodeAsserter);\n+        nodeAsserters.put(MilestoneNode.class, milestoneNodeAsserter);\n+    }\n+\n+    private static void assertNode(Node expected, Node current) {\n+        nodeAsserters.keySet()\n+                .stream()\n+                .filter(clazz -> clazz.isAssignableFrom(expected.getClass()))\n+                .forEach(clazz -> {\n+                    try {\n+                        nodeAsserters.get(clazz).accept(expected, current);\n+                    } catch (Throwable e) {\n+                        fail(String.format(\"[%s] nodes with name [%s] are not equal\", expected.getClass().getSimpleName(), current.getName()), e);\n+                    }\n+                });\n+    }\n+\n+    private static void assertMetadata(Map<String, Object> expected, Map<String, Object> current, Set<String> ignoredKeys) {\n+        if (expected == null) {\n+            assertNull(current);\n+            return;\n+        }\n+        assertNotNull(current);\n+        if(ignoredKeys == null) {", "originalCommit": "5013a0b79ce0e6a221ede8e4bcf107cc3ccbbbeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5MjY5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409292692", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n          \n          \n            \n             * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n          \n      \n    \n    \n  \n\n:D", "author": "cristianonicolai", "createdAt": "2020-04-16T05:35:33Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "originalCommit": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Njc0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409296746", "bodyText": "@ruromero could you turn this test into a parametrized test, so each file is a different instance. That also helps to clearly distinguish which file fails.", "author": "cristianonicolai", "createdAt": "2020-04-16T05:48:25Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {", "originalCommit": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMzE2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409303163", "bodyText": "In the follow up PR I already did that, by folder so I prefer to keep it like this for this one if you don't mind", "author": "ruromero", "createdAt": "2020-04-16T06:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Njc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2NDk5NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409464995", "bodyText": "Done", "author": "ruromero", "createdAt": "2020-04-16T10:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Njc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Nzc1NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409297754", "bodyText": "would also suggest here that instead of having to keep a list in a file, we do a find and include all .bpmn2 with some exclusions based on limitations. That way any new .bpmn would be automatically pickup by the test, wdyt?", "author": "cristianonicolai", "createdAt": "2020-04-16T05:51:32Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.codegen.process;\n+\n+import org.jbpm.process.core.timer.Timer;\n+import org.jbpm.ruleflow.core.RuleFlowProcess;\n+import org.jbpm.workflow.core.Constraint;\n+import org.jbpm.workflow.core.DroolsAction;\n+import org.jbpm.workflow.core.impl.ConnectionRef;\n+import org.jbpm.workflow.core.impl.ExtendedNodeImpl;\n+import org.jbpm.workflow.core.impl.NodeImpl;\n+import org.jbpm.workflow.core.node.ActionNode;\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.BoundaryEventNode;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.EndNode;\n+import org.jbpm.workflow.core.node.EventNode;\n+import org.jbpm.workflow.core.node.HumanTaskNode;\n+import org.jbpm.workflow.core.node.Join;\n+import org.jbpm.workflow.core.node.MilestoneNode;\n+import org.jbpm.workflow.core.node.Split;\n+import org.jbpm.workflow.core.node.StartNode;\n+import org.jbpm.workflow.core.node.StateBasedNode;\n+import org.jbpm.workflow.core.node.Trigger;\n+import org.jbpm.workflow.core.node.WorkItemNode;\n+import org.junit.jupiter.api.Test;\n+import org.kie.api.definition.process.Connection;\n+import org.kie.api.definition.process.Node;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.Model;\n+import org.kie.kogito.codegen.AbstractCodegenTest;\n+import org.kie.kogito.process.impl.AbstractProcess;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.jbpm.ruleflow.core.RuleFlowProcessFactory.METADATA_ACTION;\n+import static org.jbpm.workflow.core.Node.CONNECTION_DEFAULT_TYPE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * ProcessGenerationTest iterates over all the listed process files in process-generation-test.txt\n+ * <p>\n+ * For each process the test will:\n+ * <ul>\n+ *     <li>Parse the XML and generate an instance of the process: Expected</li>\n+ *     <li>Generate the code from this process and instantiate a process definition using the generated code: Current</li>\n+ *     <li>Iterate over all the process fields and metadata and assert that current and expected are equivalent</li>\n+ *     <li>Iterate over all the process' nodes fields and metadata and assert that current and expected are equivalent</li>\n+ * </ul>\n+ * <p>\n+ * Exceptions:\n+ * <ul>\n+ *     <li>Version is not set by default in Expected</li>\n+ *     <li>The node name has a default value for current when not set</li>\n+ *     <li>Node constraints are ignored</li>\n+ *     <li>OnEntry/OnExit actions are not yet implemented</li>\n+ *     <li>Timer Actions are generated differently</li>\n+ * </ul>\n+ */\n+public class ProcessGenerationTest extends AbstractCodegenTest {\n+\n+    private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n+\n+    @Test\n+    public void testProcessesGeneration() throws IOException {\n+        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))", "originalCommit": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwNDQ4MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409304481", "bodyText": "As there are some processes that are meant to fail or that include functionalities not covered by this process generation like multi-processes or model dependencies I'll do the other way around. I'll create files with the processes to ignore.", "author": "ruromero", "createdAt": "2020-04-16T06:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Nzc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTQ0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409299448", "bodyText": "@ruromero so what is the main reason for the changes here? for instance, we now would have the setInMappings and  addInMapping that would throw exception but these method wouldnt.", "author": "cristianonicolai", "createdAt": "2020-04-16T05:56:20Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/workflow/core/node/StartNode.java", "diffHunk": "@@ -118,12 +118,12 @@ public void setInMappings(Map<String, String> inMapping) {\n \n     @Override\n     public String getInMapping(String parameterName) {\n-        throw new IllegalArgumentException(\"A start event [\" + this.getMetaData(\"UniqueId\") + \", \" + this.getName() + \"] does not support input mappings\");", "originalCommit": "a192bd77ead0aceeeaaf057e94d0411b2bc240ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2NDY5OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409464698", "bodyText": "Because this allows writing generic methods for any Mappable node.", "author": "ruromero", "createdAt": "2020-04-16T10:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5ODc5Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r410098796", "bodyText": "Not sure I understood that. Can you elaborate @ruromero ?", "author": "MarianMacik", "createdAt": "2020-04-17T09:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5OTk4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r410099983", "bodyText": "Ah, I see now, so we can call it without worrying about the exceptions.", "author": "MarianMacik", "createdAt": "2020-04-17T09:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5OTQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMTYyOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409521629", "bodyText": "@ruromero I think the best approach here would be to use this https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests-sources-MethodSource, a method source, so each file name is a parameter to testProcessGeneration.", "author": "cristianonicolai", "createdAt": "2020-04-16T12:38:18Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -91,18 +96,28 @@\n public class ProcessGenerationTest extends AbstractCodegenTest {\n \n     private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n-\n-    @Test\n-    public void testProcessesGeneration() throws IOException {\n-        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n-                .filter(f -> !f.startsWith(\"#\"))\n+    private static final Path BASE_PATH = Path.of(\"src/test/resources\");\n+    private static final Collection<String> PROCESS_EXTENSIONS = Arrays.asList(\".bpmn2\", \".bpmn\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"decision\", \"event-subprocess\", \"gateway\", \"messageevent\", \"messagestartevent\",", "originalCommit": "c42b301e037b30d34a7e7eab711ce2064a62db9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5NDk0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409594946", "bodyText": "I didn't know about MethodSource. Thanks I have updated it.", "author": "ruromero", "createdAt": "2020-04-16T14:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMTYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMTk4MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/416#discussion_r409521980", "bodyText": "@ruromero cool, best of both approaches :)", "author": "cristianonicolai", "createdAt": "2020-04-16T12:38:53Z", "path": "kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java", "diffHunk": "@@ -91,18 +96,28 @@\n public class ProcessGenerationTest extends AbstractCodegenTest {\n \n     private static final Set<String> IGNORED_PROCESS_META = Set.of(\"Definitions\", \"BPMN.Connections\", \"ItemDefinitions\");\n-\n-    @Test\n-    public void testProcessesGeneration() throws IOException {\n-        Files.lines(Paths.get(\"src/test/resources/org/kie/kogito/codegen/process/process-generation-test.txt\"))\n-                .filter(f -> !f.startsWith(\"#\"))\n+    private static final Path BASE_PATH = Path.of(\"src/test/resources\");\n+    private static final Collection<String> PROCESS_EXTENSIONS = Arrays.asList(\".bpmn2\", \".bpmn\");\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"decision\", \"event-subprocess\", \"gateway\", \"messageevent\", \"messagestartevent\",\n+            \"org/kie/kogito/codegen/tests\", \"ruletask\", \"servicetask\", \"signalevent\", \"subprocess\",\n+            \"timer\", \"usertask\"})\n+    public void testProcessesGeneration(String folderName) throws IOException {\n+        Set<String> ignoredFiles = Files.lines(BASE_PATH.resolve(\"org/kie/kogito/codegen/process/process-generation-test.skip.txt\"))", "originalCommit": "c42b301e037b30d34a7e7eab711ce2064a62db9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3c54b88844035232a1faca3ca6d562e0295a480a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3c54b88844035232a1faca3ca6d562e0295a480a", "message": "[KOGITO-1248] Add process generation tests and some fixes\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "7172316848c4296cd911a192be1a18f596707f18", "url": "https://github.com/kiegroup/kogito-runtimes/commit/7172316848c4296cd911a192be1a18f596707f18", "message": "[KOGITO-1248] Add javadoc and reuse mappings method\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "37fcf7d6970207ce7117934d1285d39e1dc1b9af", "url": "https://github.com/kiegroup/kogito-runtimes/commit/37fcf7d6970207ce7117934d1285d39e1dc1b9af", "message": "[KOGITO-1248] Revert addMappings. StartEvent does not support it\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "dab8574c6600ea0607d549c2c836c858ace176e5", "url": "https://github.com/kiegroup/kogito-runtimes/commit/dab8574c6600ea0607d549c2c836c858ace176e5", "message": "[KOGITO-1248] Add mappings and don't throw exception\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "fb9416634405e5b5cedd06df985365d479b4c055", "url": "https://github.com/kiegroup/kogito-runtimes/commit/fb9416634405e5b5cedd06df985365d479b4c055", "message": "[KOGITO-1248] Avoid using outMappings in the factory\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "551bd496e6c6d5a6fa4d5a67967b9ad0c759f131", "url": "https://github.com/kiegroup/kogito-runtimes/commit/551bd496e6c6d5a6fa4d5a67967b9ad0c759f131", "message": "[KOGITO-1248] use emptyMap/emptyList\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "d02a131bbf72fa04275a2a7a2f49fffe6e4b94aa", "url": "https://github.com/kiegroup/kogito-runtimes/commit/d02a131bbf72fa04275a2a7a2f49fffe6e4b94aa", "message": "[KOGITO-1248] Stick to jdk8\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "f2b197e10e5837883e35ecb0e4fdd865c0cd1f05", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f2b197e10e5837883e35ecb0e4fdd865c0cd1f05", "message": "[KOGITO-1248] Apply review changes\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "a46ba0553bb276ed4312073f1df8cb7dabcc0b62", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a46ba0553bb276ed4312073f1df8cb7dabcc0b62", "message": "[KOGITO-1248] Fix formatting and remove TODO\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "730b571222cb1434b7e8b85a92612f288810dc76", "url": "https://github.com/kiegroup/kogito-runtimes/commit/730b571222cb1434b7e8b85a92612f288810dc76", "message": "Update kogito-codegen/src/test/java/org/kie/kogito/codegen/process/ProcessGenerationTest.java\n\nCo-Authored-By: Cristiano Nicolai <cristiano.nicolai@gmail.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "de6ed7fcd19e801f5f52de6fbee33db916b4d8df", "url": "https://github.com/kiegroup/kogito-runtimes/commit/de6ed7fcd19e801f5f52de6fbee33db916b4d8df", "message": "[KOGITO-1248] Find processes in parameterized folder\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:29:46Z", "type": "commit"}, {"oid": "a9df5347ce905c7069cc5fbd48185a1ef2c2b5c8", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a9df5347ce905c7069cc5fbd48185a1ef2c2b5c8", "message": "[KOGITO-1248] Use MethodSource\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:30:28Z", "type": "commit"}, {"oid": "a9df5347ce905c7069cc5fbd48185a1ef2c2b5c8", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a9df5347ce905c7069cc5fbd48185a1ef2c2b5c8", "message": "[KOGITO-1248] Use MethodSource\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-16T14:30:28Z", "type": "forcePushed"}, {"oid": "3db29d69992577da63af243235cad931c999ade4", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3db29d69992577da63af243235cad931c999ade4", "message": "[KOGITO-1248] Avoid java11 methods\n\nSigned-off-by: ruromero <rromerom@redhat.com>", "committedDate": "2020-04-17T08:04:13Z", "type": "commit"}]}