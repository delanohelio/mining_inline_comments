{"pr_number": 674, "pr_title": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint", "pr_createdAt": "2020-08-04T09:43:33Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/674", "timeline": [{"oid": "cb36b7961c4ee4ce0c9cb72d5ed156b0043cdd25", "url": "https://github.com/kiegroup/kogito-runtimes/commit/cb36b7961c4ee4ce0c9cb72d5ed156b0043cdd25", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-04T09:57:55Z", "type": "forcePushed"}, {"oid": "6aa77f2ce70b0d3344ccc3efd42e6e1515ddccf6", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6aa77f2ce70b0d3344ccc3efd42e6e1515ddccf6", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-04T10:12:32Z", "type": "forcePushed"}, {"oid": "51fe0dcd84f5ac0fc3c833ee5684f9e7c9b36b10", "url": "https://github.com/kiegroup/kogito-runtimes/commit/51fe0dcd84f5ac0fc3c833ee5684f9e7c9b36b10", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-04T17:19:21Z", "type": "forcePushed"}, {"oid": "27c2678b2f0171feb2f1f6c200ce1ad8c75a5eca", "url": "https://github.com/kiegroup/kogito-runtimes/commit/27c2678b2f0171feb2f1f6c200ce1ad8c75a5eca", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-04T17:29:49Z", "type": "forcePushed"}, {"oid": "8f1166d078c7f4d16aa5fb09e037a173c3326c31", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8f1166d078c7f4d16aa5fb09e037a173c3326c31", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-04T19:28:10Z", "type": "forcePushed"}, {"oid": "5effce28561ce34a084c989b6624d51e789fd8c9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/5effce28561ce34a084c989b6624d51e789fd8c9", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-05T07:43:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzNzk5Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465537996", "bodyText": "OutputModel", "author": "evacchi", "createdAt": "2020-08-05T07:47:37Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/MapOutput.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito;\n+\n+import java.util.Map;\n+\n+/**\n+ * A model which can express its internal information as a Map\n+ */\n+public interface MapOutput {", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0Nzg1Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465547856", "bodyText": "That was the original name, but then I realize that this interface is just adding a toMap method to any class that implements it, model or not, so it is far more generic and I think clear about the purpose.\nI have to update the comment though, wdyt?", "author": "fjtirado", "createdAt": "2020-08-05T08:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzNzk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxODk2OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465618969", "bodyText": "documentation updated", "author": "fjtirado", "createdAt": "2020-08-05T10:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzNzk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczMjQzMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465732432", "bodyText": "it really boils down to whether this method will be provided by anything that exposes toMap, or only by Output models or Models. Anyway we can always update", "author": "evacchi", "createdAt": "2020-08-05T13:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzNzk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAxMTIyNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467011225", "bodyText": "Here it sounds to me like a class implementing this interface can be an output of a map, not that it provides this method. I would suggest something like MapOutputAware or similar, but we can always update as this is just a name...", "author": "MarianMacik", "createdAt": "2020-08-07T12:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzNzk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzODEyOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465538129", "bodyText": "I'd propose to call it InputModel", "author": "evacchi", "createdAt": "2020-08-05T07:47:49Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/MapInput.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito;\n+\n+import java.util.Map;\n+\n+/**\n+ * A model which can be populated from a Map\n+ */\n+public interface MapInput {", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0Nzk2Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465547966", "bodyText": "Same rationale than in previous comment", "author": "fjtirado", "createdAt": "2020-08-05T08:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzODEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxOTA2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465619063", "bodyText": "documentation updated", "author": "fjtirado", "createdAt": "2020-08-05T10:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzODEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzODI0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465538249", "bodyText": "I am not sure I like making all these methods fluent. The reason is that if we wanted at some point in the future to make any of those to return a value then we won't be able. We can make the code just as concise by using { pi.start(); pi.something() } etc. (notice the semicolon)\nI know my original bug report included some fluent interfaces :P but not sure I want it for all. I am not sure I want it for some either at this point, because it would make the API asymmetrical.", "author": "evacchi", "createdAt": "2020-08-05T07:48:05Z", "path": "api/kogito-api/src/main/java/org/kie/kogito/process/ProcessInstance.java", "diffHunk": "@@ -47,30 +47,30 @@\n     /**\n      * Starts process instance\n      */\n-    void start();\n+    ProcessInstance<T> start();", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NDExNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465554114", "bodyText": "Hmmmmmm,\nTwo statements in the same line is not a good idea, too confusing.\nI agree on rationale to not make start methods fluent, but then we have to assume a longer generated code (which is probably fine anyway)\nRegarding methods in processIntances that I change but are not start or abort, I think they can be fluent without compromising api consistency. lets analyze them individually:\n\nupdateVariables can return updated variables\ncheckError only makes sense if it returns ProcessInstance, if not, the  logic inside it (checking if there is any eeor)  should be make part of start method itself", "author": "fjtirado", "createdAt": "2020-08-05T08:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUzODI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MDI3NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465540275", "bodyText": "I don't like the ternary operator here\nwhat if we let startFromNode accept null => invoke start() internally?.\nlet's put checkError() on its line, and make it void for now (see comment above)", "author": "evacchi", "createdAt": "2020-08-05T07:51:42Z", "path": "kogito-codegen/src/main/resources/class-templates/ReactiveRestResourceTemplate.java", "diffHunk": "@@ -37,134 +38,75 @@\n public class $Type$ReactiveResource {\n \n     Process<$Type$> process;\n-    \n+\n     Application application;\n \n     @POST()\n     @Produces(MediaType.APPLICATION_JSON)\n-    @Consumes(MediaType.APPLICATION_JSON)    \n+    @Consumes(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> createResource_$name$(@Context HttpHeaders httpHeaders, @QueryParam(\"businessKey\") String businessKey, $Type$Input resource) {\n-        if (resource == null) {\n-            resource = new $Type$Input();\n-        }\n-        final $Type$Input value = resource;\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.createInstance(businessKey, mapInput(value, new $Type$()));\n-                String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n-                \n-                if (startFromNode != null) {\n-                    pi.startFrom(startFromNode);\n-                } else {\n-                    pi.start();\n-                }\n-                return getModel(pi);\n-            });\n-        });\n+\n+        return CompletableFuture.supplyAsync(() -> UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            $Type$Input inputModel = resource != null ? resource : new $Type$Input();\n+            ProcessInstance<$Type$> pi = process.createInstance(businessKey, inputModel.toModel());\n+            String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n+            return (startFromNode != null ? pi.startFrom(startFromNode) : pi.start()).checkError().variables().toOutput();", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NDM3OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465554379", "bodyText": "Agree, except for checkError part (see coment abovce)", "author": "fjtirado", "createdAt": "2020-08-05T08:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MDI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MDYxMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465540611", "bodyText": "please format this on more lines -- even it's a oneliner", "author": "evacchi", "createdAt": "2020-08-05T07:52:16Z", "path": "kogito-codegen/src/main/resources/class-templates/ReactiveRestResourceTemplate.java", "diffHunk": "@@ -37,134 +38,75 @@\n public class $Type$ReactiveResource {\n \n     Process<$Type$> process;\n-    \n+\n     Application application;\n \n     @POST()\n     @Produces(MediaType.APPLICATION_JSON)\n-    @Consumes(MediaType.APPLICATION_JSON)    \n+    @Consumes(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> createResource_$name$(@Context HttpHeaders httpHeaders, @QueryParam(\"businessKey\") String businessKey, $Type$Input resource) {\n-        if (resource == null) {\n-            resource = new $Type$Input();\n-        }\n-        final $Type$Input value = resource;\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.createInstance(businessKey, mapInput(value, new $Type$()));\n-                String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n-                \n-                if (startFromNode != null) {\n-                    pi.startFrom(startFromNode);\n-                } else {\n-                    pi.start();\n-                }\n-                return getModel(pi);\n-            });\n-        });\n+\n+        return CompletableFuture.supplyAsync(() -> UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            $Type$Input inputModel = resource != null ? resource : new $Type$Input();\n+            ProcessInstance<$Type$> pi = process.createInstance(businessKey, inputModel.toModel());\n+            String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n+            return (startFromNode != null ? pi.startFrom(startFromNode) : pi.start()).checkError().variables().toOutput();\n+        }));\n     }\n \n     @GET()\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<List<$Type$Output>> getResources_$name$() {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return process.instances().values().stream()\n-                    .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n-                 .collect(Collectors.toList());\n-        });   \n+        return CompletableFuture.supplyAsync(() -> process.instances().values().stream()\n+                                                          .map(pi -> pi.variables().toOutput())\n+                                                          .collect(Collectors.toList()));\n     }\n \n     @GET()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> getResource_$name$(@PathParam(\"id\") String id) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return process.instances()\n-                    .findById(id)\n-                    .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n-                    .orElse(null);\n-        });\n+        return CompletableFuture.supplyAsync(() -> process.instances()\n+                                                          .findById(id)\n+                                                          .map(pi -> pi.variables().toOutput())\n+                                                          .orElse(null));\n     }\n-    \n+\n     @DELETE()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> deleteResource_$name$(@PathParam(\"id\") final String id) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.instances()\n-                        .findById(id)\n-                        .orElse(null);\n-                if (pi == null) {\n-                    return null;\n-                } else {\n-                    pi.abort();\n-                    return getModel(pi);\n-                }\n-            });\n-        });\n+        return CompletableFuture.supplyAsync(() -> UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> pi.abort().variables().toOutput()).orElse(\n+                                                                                                                                                                                                                      null)));\n     }\n-    \n+\n     @POST()\n     @Path(\"/{id}\")\n     @Consumes(MediaType.APPLICATION_JSON)\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> updateModel_$name$(@PathParam(\"id\") String id, $Type$ resource) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.instances()\n-                        .findById(id)\n-                        .orElse(null);\n-                if (pi == null) {\n-                    return null;\n-                } else {\n-                    pi.updateVariables(resource);\n-                    return mapOutput(new $Type$Output(), pi.variables());\n-                }\n-            });\n-        });\n+        return CompletableFuture.supplyAsync(() -> UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> pi.updateVariables(resource).toOutput()).orElse(null));", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MDY5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465540692", "bodyText": "please format this on more lines -- even it's a oneliner", "author": "evacchi", "createdAt": "2020-08-05T07:52:25Z", "path": "kogito-codegen/src/main/resources/class-templates/ReactiveRestResourceTemplate.java", "diffHunk": "@@ -37,134 +38,75 @@\n public class $Type$ReactiveResource {\n \n     Process<$Type$> process;\n-    \n+\n     Application application;\n \n     @POST()\n     @Produces(MediaType.APPLICATION_JSON)\n-    @Consumes(MediaType.APPLICATION_JSON)    \n+    @Consumes(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> createResource_$name$(@Context HttpHeaders httpHeaders, @QueryParam(\"businessKey\") String businessKey, $Type$Input resource) {\n-        if (resource == null) {\n-            resource = new $Type$Input();\n-        }\n-        final $Type$Input value = resource;\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.createInstance(businessKey, mapInput(value, new $Type$()));\n-                String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n-                \n-                if (startFromNode != null) {\n-                    pi.startFrom(startFromNode);\n-                } else {\n-                    pi.start();\n-                }\n-                return getModel(pi);\n-            });\n-        });\n+\n+        return CompletableFuture.supplyAsync(() -> UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            $Type$Input inputModel = resource != null ? resource : new $Type$Input();\n+            ProcessInstance<$Type$> pi = process.createInstance(businessKey, inputModel.toModel());\n+            String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n+            return (startFromNode != null ? pi.startFrom(startFromNode) : pi.start()).checkError().variables().toOutput();\n+        }));\n     }\n \n     @GET()\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<List<$Type$Output>> getResources_$name$() {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return process.instances().values().stream()\n-                    .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n-                 .collect(Collectors.toList());\n-        });   \n+        return CompletableFuture.supplyAsync(() -> process.instances().values().stream()\n+                                                          .map(pi -> pi.variables().toOutput())\n+                                                          .collect(Collectors.toList()));\n     }\n \n     @GET()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> getResource_$name$(@PathParam(\"id\") String id) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return process.instances()\n-                    .findById(id)\n-                    .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n-                    .orElse(null);\n-        });\n+        return CompletableFuture.supplyAsync(() -> process.instances()\n+                                                          .findById(id)\n+                                                          .map(pi -> pi.variables().toOutput())\n+                                                          .orElse(null));\n     }\n-    \n+\n     @DELETE()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> deleteResource_$name$(@PathParam(\"id\") final String id) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.instances()\n-                        .findById(id)\n-                        .orElse(null);\n-                if (pi == null) {\n-                    return null;\n-                } else {\n-                    pi.abort();\n-                    return getModel(pi);\n-                }\n-            });\n-        });\n+        return CompletableFuture.supplyAsync(() -> UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> pi.abort().variables().toOutput()).orElse(", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTA5MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465541091", "bodyText": "same comment about ternary operator and making checkError() void", "author": "evacchi", "createdAt": "2020-08-05T07:53:09Z", "path": "kogito-codegen/src/main/resources/class-templates/RestResourceTemplate.java", "diffHunk": "@@ -44,29 +49,19 @@\n     @Produces(MediaType.APPLICATION_JSON)\n     @Consumes(MediaType.APPLICATION_JSON)\n     public $Type$Output createResource_$name$(@Context HttpHeaders httpHeaders, @QueryParam(\"businessKey\") String businessKey, $Type$Input resource) {\n-        if (resource == null) {\n-            resource = new $Type$Input();\n-        }\n-        final $Type$Input value = resource;\n-\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-            ProcessInstance<$Type$> pi = process.createInstance(businessKey, mapInput(value, new $Type$()));\n+        return UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            $Type$Input inputModel = resource != null ? resource : new $Type$Input();\n+            ProcessInstance<$Type$> pi = process.createInstance(businessKey, inputModel.toModel());\n             String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n-\n-            if (startFromNode != null) {\n-                pi.startFrom(startFromNode);\n-            } else {\n-                pi.start();\n-            }\n-            return getModel(pi);\n+            return (startFromNode != null ? pi.startFrom(startFromNode) : pi.start()).checkError().variables().toOutput();", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTE3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465541173", "bodyText": "please format this on more lines -- even it's a oneliner", "author": "evacchi", "createdAt": "2020-08-05T07:53:18Z", "path": "kogito-codegen/src/main/resources/class-templates/RestResourceTemplate.java", "diffHunk": "@@ -76,29 +71,23 @@\n     public $Type$Output getResource_$name$(@PathParam(\"id\") String id) {\n         return process.instances()\n                       .findById(id)\n-                      .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n+                      .map(pi -> pi.variables().toOutput())\n                       .orElse(null);\n     }\n \n     @DELETE()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public $Type$Output deleteResource_$name$(@PathParam(\"id\") final String id) {\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> {\n-            pi.abort();\n-            return getModel(pi);\n-        }).orElse(null));\n+        return UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> pi.abort().variables().toOutput()).orElse(null));", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTIwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465541204", "bodyText": "please format this on more lines -- even it's a oneliner", "author": "evacchi", "createdAt": "2020-08-05T07:53:21Z", "path": "kogito-codegen/src/main/resources/class-templates/RestResourceTemplate.java", "diffHunk": "@@ -76,29 +71,23 @@\n     public $Type$Output getResource_$name$(@PathParam(\"id\") String id) {\n         return process.instances()\n                       .findById(id)\n-                      .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n+                      .map(pi -> pi.variables().toOutput())\n                       .orElse(null);\n     }\n \n     @DELETE()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public $Type$Output deleteResource_$name$(@PathParam(\"id\") final String id) {\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> {\n-            pi.abort();\n-            return getModel(pi);\n-        }).orElse(null));\n+        return UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> pi.abort().variables().toOutput()).orElse(null));\n     }\n \n     @POST()\n     @Path(\"/{id}\")\n     @Consumes(MediaType.APPLICATION_JSON)\n     @Produces(MediaType.APPLICATION_JSON)\n     public $Type$Output updateModel_$name$(@PathParam(\"id\") String id, $Type$ resource) {\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> {\n-            pi.updateVariables(resource);\n-            return mapOutput(new $Type$Output(), pi.variables());\n-        }).orElse(null));\n+        return UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> pi.updateVariables(resource).toOutput()).orElse(null));", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTM5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465541392", "bodyText": "check the formatting here", "author": "evacchi", "createdAt": "2020-08-05T07:53:43Z", "path": "kogito-codegen/src/main/resources/class-templates/RestResourceUserTaskTemplate.java", "diffHunk": "@@ -76,9 +78,10 @@\n                                   @QueryParam(\"phase\") @DefaultValue(\"abort\") final String phase,\n                                   @QueryParam(\"user\") final String user,\n                                   @QueryParam(\"group\") final List<String> groups) {\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> {\n-            pi.transitionWorkItem(workItemId, org.jbpm.process.instance.impl.humantask.HumanTaskTransition.withoutModel(phase, policies(user, groups)));\n-            return getModel(pi);\n-        }).orElse(null));\n+        return UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> pi.transitionWorkItem(workItemId,", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NTI2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465555268", "bodyText": "see comment above", "author": "fjtirado", "createdAt": "2020-08-05T08:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTU3Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465541576", "bodyText": "same comment on ternary + void checkError()", "author": "evacchi", "createdAt": "2020-08-05T07:54:03Z", "path": "kogito-codegen/src/main/resources/class-templates/spring/SpringRestResourceTemplate.java", "diffHunk": "@@ -51,100 +58,65 @@\n \n     Application application;\n \n-    @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE, consumes =\n-            MediaType.APPLICATION_JSON_VALUE)\n+    @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)\n     public $Type$Output createResource_$name$(@RequestHeader HttpHeaders httpHeaders,\n                                               @RequestParam(value = \"businessKey\", required = false) String businessKey,\n                                               @RequestBody $Type$Input resource) {\n-        if (resource == null) {\n-            resource = new $Type$Input();\n-        }\n-        final $Type$Input value = resource;\n-\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-            ProcessInstance<$Type$> pi = process.createInstance(businessKey, mapInput(value, new $Type$()));\n+        return UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+            $Type$Input inputModel = resource != null ? resource : new $Type$Input();\n+            ProcessInstance<$Type$> pi = process.createInstance(businessKey, inputModel.toModel());\n             String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n-\n-            if (startFromNode != null) {\n-                pi.startFrom(startFromNode);\n-            } else {\n-                pi.start();\n-            }\n-            return getModel(pi);\n+            return (startFromNode != null ? pi.startFrom(startFromNode) : pi.start()).checkError().variables().toOutput();", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTc2OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465541768", "bodyText": "add newline before .body", "author": "evacchi", "createdAt": "2020-08-05T07:54:24Z", "path": "kogito-codegen/src/main/resources/class-templates/spring/SpringRestResourceUserTaskTemplate.java", "diffHunk": "@@ -18,41 +18,45 @@\n public class $Type$Resource {\n \n     @PostMapping(value = \"/{id}/$taskName$\", produces = MediaType.APPLICATION_JSON_VALUE,\n-            consumes = MediaType.APPLICATION_JSON_VALUE)\n-    public org.springframework.http.ResponseEntity<$Type$Output> signal(@PathVariable(\"id\") final String id) {\n+                 consumes = MediaType.APPLICATION_JSON_VALUE)\n+    public ResponseEntity<$Type$Output> signal(@PathVariable(\"id\") final String id) {\n         return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n             return process.instances().findById(id).map(pi -> {\n                 pi.send(Sig.of(\"$taskNodeName$\", java.util.Collections.emptyMap()));\n                 java.util.Optional<WorkItem> task = pi.workItems().stream().filter(wi -> wi.getName().equals(\"$taskName$\")).findFirst();\n                 if (task.isPresent()) {\n-                    return javax.ws.rs.core.Response.ok(getModel(pi))\n-                                                    .header(\"Link\", \"</\" + id + \"/$taskName$/\" + task.get().getId() + \">; rel='instance'\")\n-                                                    .build();\n+                    return ResponseEntity.status(HttpStatus.OK)\n+                                         .header(\"Link\", \"</\" + id + \"/$taskName$/\" + task.get().getId() + \">; rel='instance'\").body(pi.variables().toOutput())", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NTQwMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465555401", "bodyText": "same", "author": "fjtirado", "createdAt": "2020-08-05T08:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTg0MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465541840", "bodyText": "check formatting", "author": "evacchi", "createdAt": "2020-08-05T07:54:34Z", "path": "kogito-codegen/src/main/resources/class-templates/spring/SpringRestResourceUserTaskTemplate.java", "diffHunk": "@@ -18,41 +18,45 @@\n public class $Type$Resource {\n \n     @PostMapping(value = \"/{id}/$taskName$\", produces = MediaType.APPLICATION_JSON_VALUE,\n-            consumes = MediaType.APPLICATION_JSON_VALUE)\n-    public org.springframework.http.ResponseEntity<$Type$Output> signal(@PathVariable(\"id\") final String id) {\n+                 consumes = MediaType.APPLICATION_JSON_VALUE)\n+    public ResponseEntity<$Type$Output> signal(@PathVariable(\"id\") final String id) {\n         return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n             return process.instances().findById(id).map(pi -> {\n                 pi.send(Sig.of(\"$taskNodeName$\", java.util.Collections.emptyMap()));\n                 java.util.Optional<WorkItem> task = pi.workItems().stream().filter(wi -> wi.getName().equals(\"$taskName$\")).findFirst();\n                 if (task.isPresent()) {\n-                    return javax.ws.rs.core.Response.ok(getModel(pi))\n-                                                    .header(\"Link\", \"</\" + id + \"/$taskName$/\" + task.get().getId() + \">; rel='instance'\")\n-                                                    .build();\n+                    return ResponseEntity.status(HttpStatus.OK)\n+                                         .header(\"Link\", \"</\" + id + \"/$taskName$/\" + task.get().getId() + \">; rel='instance'\").body(pi.variables().toOutput())\n+                                         .build();\n                 }\n-                return javax.ws.rs.core.Response.status(javax.ws.rs.core.Response.Status.NOT_FOUND).build();\n+                return ResponseEntity.notFound().build();\n             }).orElse(null);\n         });\n     }\n \n     @PostMapping(value = \"/{id}/$taskName$/{workItemId}\", produces = MediaType.APPLICATION_JSON_VALUE,\n-            consumes = MediaType.APPLICATION_JSON_VALUE)\n+                 consumes = MediaType.APPLICATION_JSON_VALUE)\n     public $Type$Output completeTask(@PathVariable(\"id\") final String id,\n                                      @PathVariable(\"workItemId\") final String workItemId,\n                                      @RequestParam(value = \"phase\", defaultValue = \"complete\") final String phase,\n                                      @RequestParam(value = \"user\", required = false) final String user,\n                                      @RequestParam(value = \"group\", required = false) final List<String> groups,\n                                      @RequestBody final $TaskOutput$ model) {\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> {\n-            pi.transitionWorkItem(workItemId, org.jbpm.process.instance.impl.humantask.HumanTaskTransition.withModel(phase, model.toMap(), policies(user, groups)));\n-            return getModel(pi);\n-        }).orElse(null));\n+        return UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> pi.transitionWorkItem(workItemId,", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NTQ0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465555445", "bodyText": "same", "author": "fjtirado", "createdAt": "2020-08-05T08:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTkyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465541923", "bodyText": "check formatting", "author": "evacchi", "createdAt": "2020-08-05T07:54:42Z", "path": "kogito-codegen/src/main/resources/class-templates/spring/SpringRestResourceUserTaskTemplate.java", "diffHunk": "@@ -71,9 +75,10 @@ public JsonSchema getSchemaAndPhases(@PathParam(\"id\") final String id, @PathPara\n                                   @RequestParam(value = \"phase\", defaultValue = \"abort\") final String phase,\n                                   @RequestParam(value = \"user\", required = false) final String user,\n                                   @RequestParam(value = \"group\", required = false) final List<String> groups) {\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> {\n-            pi.transitionWorkItem(workItemId, org.jbpm.process.instance.impl.humantask.HumanTaskTransition.withoutModel(phase, policies(user, groups)));\n-            return getModel(pi);\n-        }).orElse(null));\n+        return UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> pi.transitionWorkItem(workItemId,", "originalCommit": "5effce28561ce34a084c989b6624d51e789fd8c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NTUwMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r465555503", "bodyText": "same", "author": "fjtirado", "createdAt": "2020-08-05T08:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MTkyMw=="}], "type": "inlineReview"}, {"oid": "33cb2688f35b2fa830fb9ae3c6ed83b721d0c4e3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/33cb2688f35b2fa830fb9ae3c6ed83b721d0c4e3", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-05T07:58:20Z", "type": "forcePushed"}, {"oid": "a2c77a10e22b1964eeb56501108f8d9175dc8940", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a2c77a10e22b1964eeb56501108f8d9175dc8940", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-05T07:59:53Z", "type": "forcePushed"}, {"oid": "b7994327a0fe4d297a371d004aeb46cfbda44a51", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b7994327a0fe4d297a371d004aeb46cfbda44a51", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-05T10:02:06Z", "type": "forcePushed"}, {"oid": "3799592a41a8e19b16b90f412e679aae2f19e3c5", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3799592a41a8e19b16b90f412e679aae2f19e3c5", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-05T10:04:05Z", "type": "forcePushed"}, {"oid": "993cbdf7092cd10ded32d2c3ee8e698892248b64", "url": "https://github.com/kiegroup/kogito-runtimes/commit/993cbdf7092cd10ded32d2c3ee8e698892248b64", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd chechError to ProcessInstance\nstart, startFrom, transition and abort methods on ProcessInstance now\nreturns ProcessInstance to allow fluent usage\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-05T10:06:09Z", "type": "forcePushed"}, {"oid": "761108efce510434e7ce550a38be07a11d34f7d8", "url": "https://github.com/kiegroup/kogito-runtimes/commit/761108efce510434e7ce550a38be07a11d34f7d8", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd checkError to ProcessInstance\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-05T13:52:09Z", "type": "forcePushed"}, {"oid": "a662858279aca19b431dfb62af411491411aa882", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a662858279aca19b431dfb62af411491411aa882", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd checkError to ProcessInstance\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-05T15:47:52Z", "type": "forcePushed"}, {"oid": "eea243441f1f7665bb7d9a93cefacc920949dfcc", "url": "https://github.com/kiegroup/kogito-runtimes/commit/eea243441f1f7665bb7d9a93cefacc920949dfcc", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd checkError to ProcessInstance\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-05T15:54:55Z", "type": "forcePushed"}, {"oid": "5c5c75104895e9addb7e29ee37e6f5b6237b111d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/5c5c75104895e9addb7e29ee37e6f5b6237b111d", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd checkError to ProcessInstance\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-06T15:55:24Z", "type": "forcePushed"}, {"oid": "b84ffe5c781eabd3bbe88c67eaba291349f26276", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b84ffe5c781eabd3bbe88c67eaba291349f26276", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd checkError to ProcessInstance\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-06T16:04:43Z", "type": "forcePushed"}, {"oid": "957bcf3f2b547753307b6bca5f554ccc129813c8", "url": "https://github.com/kiegroup/kogito-runtimes/commit/957bcf3f2b547753307b6bca5f554ccc129813c8", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd checkError to ProcessInstance\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-06T16:32:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2OTE4NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467069185", "bodyText": "Just one question: aren't we using $token$ format? Just asking because XXX seems something different.", "author": "ricardozanini", "createdAt": "2020-08-07T14:17:06Z", "path": "jbpm/jbpm-flow-builder/src/main/resources/class-templates/TaskInputTemplate.java", "diffHunk": "@@ -24,7 +24,7 @@ public String getName() {\n         return this._name;\n     }\n \n-    public static XXXTaskInput fromMap(org.kie.kogito.process.WorkItem workItem) {\n+    public static XXXTaskInput from(org.kie.kogito.process.WorkItem workItem) {", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExMzA5NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467113095", "bodyText": "I guess because the replacement here can be done using setClassName method and there is not need to seach for a particular name", "author": "fjtirado", "createdAt": "2020-08-07T15:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2OTE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAxNDQ0Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467014442", "bodyText": "This can be on one line.", "author": "MarianMacik", "createdAt": "2020-08-07T12:40:15Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ProcessToExecModelGenerator.java", "diffHunk": "@@ -101,28 +108,78 @@ public MethodDeclaration generateMethod(WorkflowProcess process) {\n     public ModelMetaData generateModel(WorkflowProcess process) {\n         String packageName = process.getPackageName();\n         String name = extractModelClassName(process.getId());\n-\n+        VariableScope variableScope = getVariableScope(process);\n         return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(),\n-                VariableDeclarations.of((VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE)),\n-                false);\n+                                 VariableDeclarations.of(variableScope),\n+                                 false, \"/class-templates/ModelTemplate.java\",\n+                                 new AddMethodConsumer(\"toOutput\", extractModelClassName(process.getId()) + \"Output\",\n+                                                       VariableDeclarations.ofOutput(variableScope), true));\n     }\n \n     public ModelMetaData generateInputModel(WorkflowProcess process) {\n         String packageName = process.getPackageName();\n-        String name = extractModelClassName(process.getId()) + \"Input\";\n-\n-        return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(),\n-                VariableDeclarations.ofInput((VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE)),\n-                true, \"/class-templates/ModelNoIDTemplate.java\");\n+        String modelName = extractModelClassName(process.getId());\n+        String name = modelName + \"Input\";\n+        VariableDeclarations inputVars = VariableDeclarations.ofInput(getVariableScope(process));\n+        return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(), inputVars, true,\n+                                 \"/class-templates/ModelNoIDTemplate.java\", new AddMethodConsumer(\"toModel\", modelName,\n+                                                                                                  inputVars, false));\n     }\n \n     public ModelMetaData generateOutputModel(WorkflowProcess process) {\n         String packageName = process.getPackageName();\n         String name = extractModelClassName(process.getId()) + \"Output\";\n-\n         return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(),\n-                VariableDeclarations.ofOutput((VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE)),\n-                true);\n+                                 VariableDeclarations.ofOutput(getVariableScope(process)), true);\n+    }\n+\n+    private static VariableScope getVariableScope(WorkflowProcess process) {\n+        return (VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(\n+                                                                                           VariableScope.VARIABLE_SCOPE);", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAxNjA1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467016059", "bodyText": "Maybe do the same with generateModel, it is much easier to read.", "author": "MarianMacik", "createdAt": "2020-08-07T12:43:38Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ProcessToExecModelGenerator.java", "diffHunk": "@@ -101,28 +108,78 @@ public MethodDeclaration generateMethod(WorkflowProcess process) {\n     public ModelMetaData generateModel(WorkflowProcess process) {\n         String packageName = process.getPackageName();\n         String name = extractModelClassName(process.getId());\n-\n+        VariableScope variableScope = getVariableScope(process);\n         return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(),\n-                VariableDeclarations.of((VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE)),\n-                false);\n+                                 VariableDeclarations.of(variableScope),\n+                                 false, \"/class-templates/ModelTemplate.java\",\n+                                 new AddMethodConsumer(\"toOutput\", extractModelClassName(process.getId()) + \"Output\",\n+                                                       VariableDeclarations.ofOutput(variableScope), true));\n     }\n \n     public ModelMetaData generateInputModel(WorkflowProcess process) {\n         String packageName = process.getPackageName();\n-        String name = extractModelClassName(process.getId()) + \"Input\";\n-\n-        return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(),\n-                VariableDeclarations.ofInput((VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE)),\n-                true, \"/class-templates/ModelNoIDTemplate.java\");\n+        String modelName = extractModelClassName(process.getId());\n+        String name = modelName + \"Input\";\n+        VariableDeclarations inputVars = VariableDeclarations.ofInput(getVariableScope(process));", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExNjAxOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467116018", "bodyText": "Here Im using inputVars local variable because it is used as parameter twice and I do not want to generate two instances.\nIn generateModel Im reusing the scope.\nI changed the format to make it more readable, hopefully....", "author": "fjtirado", "createdAt": "2020-08-07T15:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAxNjA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAyNzY5Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467027692", "bodyText": "Do we need here a type parameter? I think we would be fine with just MapOutput data, right?", "author": "MarianMacik", "createdAt": "2020-08-07T13:06:08Z", "path": "jbpm/jbpm-flow/src/main/java/org/jbpm/process/instance/impl/humantask/HumanTaskTransition.java", "diffHunk": "@@ -36,8 +37,8 @@\n     private Map<String, Object> data;\n     private List<Policy<?>> policies = new ArrayList<>();\n     \n-    public static HumanTaskTransition withModel(String phase, Map<String, Object> data, Policy<?>... policies) {\n-        return new HumanTaskTransition(phase, data, policies);\n+    public static <T extends MapOutput> HumanTaskTransition withModel(String phase, T data, Policy<?>... policies) {\n+        return new HumanTaskTransition(phase, data.toMap(), policies);", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzOTcyOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467139729", "bodyText": "I think it was cooler that way, but you are right, uneeded and more readeable with MapOutput", "author": "fjtirado", "createdAt": "2020-08-07T16:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAyNzY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNTEzOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467035139", "bodyText": "Please format this, ideally as before.", "author": "MarianMacik", "createdAt": "2020-08-07T13:19:53Z", "path": "kogito-codegen/src/main/resources/class-templates/ReactiveRestResourceTemplate.java", "diffHunk": "@@ -38,134 +39,108 @@\n public class $Type$ReactiveResource {\n \n     Process<$Type$> process;\n-    \n+\n     Application application;\n \n     @POST()\n     @Produces(MediaType.APPLICATION_JSON)\n-    @Consumes(MediaType.APPLICATION_JSON)    \n-    public CompletionStage<$Type$Output> createResource_$name$(@Context HttpHeaders httpHeaders, @QueryParam(\"businessKey\") String businessKey, $Type$Input resource) {\n-        if (resource == null) {\n-            resource = new $Type$Input();\n-        }\n-        final $Type$Input value = resource;\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.createInstance(businessKey, mapInput(value, new $Type$()));\n-                String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n-                \n-                if (startFromNode != null) {\n-                    pi.startFrom(startFromNode);\n-                } else {\n-                    pi.start();\n-                }\n-                return getModel(pi);\n-            });\n-        });\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public CompletionStage<$Type$Output> createResource_$name$(@Context HttpHeaders httpHeaders,\n+                                                               @QueryParam(\"businessKey\") String businessKey,\n+                                                               $Type$Input resource) {\n+        return CompletableFuture.supplyAsync(\n+                                             () -> UnitOfWorkExecutor.executeInUnitOfWork(\n+                                                                                          application.unitOfWorkManager(),\n+                                                                                          () -> {\n+                                                                                              $Type$Input inputModel =\n+                                                                                                      resource != null\n+                                                                                                              ? resource\n+                                                                                                              : new $Type$Input();\n+                                                                                              ProcessInstance<$Type$> pi =\n+                                                                                                      process.createInstance(businessKey,\n+                                                                                                                             inputModel.toModel());\n+                                                                                              String startFromNode =\n+                                                                                                      httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n+                                                                                              if (startFromNode != null) {\n+                                                                                                  pi.startFrom(startFromNode);\n+                                                                                              } else {\n+                                                                                                  pi.start();\n+                                                                                              }\n+                                                                                              return pi.checkError()\n+                                                                                                       .variables()\n+                                                                                                       .toOutput();\n+                                                                                          }));", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExNjM2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467116363", "bodyText": "Ill try, but the code style is tricky in that line", "author": "fjtirado", "createdAt": "2020-08-07T15:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNTEzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNzYxMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467137610", "bodyText": "After trying during a while, I formatted it manually, hope the result is more read friendly", "author": "fjtirado", "createdAt": "2020-08-07T16:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNTEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNTUzOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467035538", "bodyText": "Same here.", "author": "MarianMacik", "createdAt": "2020-08-07T13:20:38Z", "path": "kogito-codegen/src/main/resources/class-templates/ReactiveRestResourceTemplate.java", "diffHunk": "@@ -38,134 +39,108 @@\n public class $Type$ReactiveResource {\n \n     Process<$Type$> process;\n-    \n+\n     Application application;\n \n     @POST()\n     @Produces(MediaType.APPLICATION_JSON)\n-    @Consumes(MediaType.APPLICATION_JSON)    \n-    public CompletionStage<$Type$Output> createResource_$name$(@Context HttpHeaders httpHeaders, @QueryParam(\"businessKey\") String businessKey, $Type$Input resource) {\n-        if (resource == null) {\n-            resource = new $Type$Input();\n-        }\n-        final $Type$Input value = resource;\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.createInstance(businessKey, mapInput(value, new $Type$()));\n-                String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n-                \n-                if (startFromNode != null) {\n-                    pi.startFrom(startFromNode);\n-                } else {\n-                    pi.start();\n-                }\n-                return getModel(pi);\n-            });\n-        });\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public CompletionStage<$Type$Output> createResource_$name$(@Context HttpHeaders httpHeaders,\n+                                                               @QueryParam(\"businessKey\") String businessKey,\n+                                                               $Type$Input resource) {\n+        return CompletableFuture.supplyAsync(\n+                                             () -> UnitOfWorkExecutor.executeInUnitOfWork(\n+                                                                                          application.unitOfWorkManager(),\n+                                                                                          () -> {\n+                                                                                              $Type$Input inputModel =\n+                                                                                                      resource != null\n+                                                                                                              ? resource\n+                                                                                                              : new $Type$Input();\n+                                                                                              ProcessInstance<$Type$> pi =\n+                                                                                                      process.createInstance(businessKey,\n+                                                                                                                             inputModel.toModel());\n+                                                                                              String startFromNode =\n+                                                                                                      httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n+                                                                                              if (startFromNode != null) {\n+                                                                                                  pi.startFrom(startFromNode);\n+                                                                                              } else {\n+                                                                                                  pi.start();\n+                                                                                              }\n+                                                                                              return pi.checkError()\n+                                                                                                       .variables()\n+                                                                                                       .toOutput();\n+                                                                                          }));\n     }\n \n     @GET()\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<List<$Type$Output>> getResources_$name$() {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return process.instances().values().stream()\n-                    .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n-                 .collect(Collectors.toList());\n-        });   \n+        return CompletableFuture.supplyAsync(() -> process.instances().values().stream()\n+                                                          .map(pi -> pi.variables().toOutput())\n+                                                          .collect(Collectors.toList()));\n     }\n \n     @GET()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> getResource_$name$(@PathParam(\"id\") String id) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return process.instances()\n-                    .findById(id, ProcessInstanceReadMode.READ_ONLY)\n-                    .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n-                    .orElse(null);\n-        });\n+        return CompletableFuture.supplyAsync(() -> process.instances()\n+                                                          .findById(id, ProcessInstanceReadMode.READ_ONLY)\n+                                                          .map(pi -> pi.variables().toOutput())\n+                                                          .orElse(null));\n     }\n-    \n+\n     @DELETE()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> deleteResource_$name$(@PathParam(\"id\") final String id) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.instances()\n-                        .findById(id)\n-                        .orElse(null);\n-                if (pi == null) {\n-                    return null;\n-                } else {\n-                    pi.abort();\n-                    return getModel(pi);\n-                }\n-            });\n-        });\n+        return CompletableFuture.supplyAsync(() -> UnitOfWorkExecutor.executeInUnitOfWork(\n+                                                                                          application.unitOfWorkManager(),\n+                                                                                          () -> process.instances()\n+                                                                                                       .findById(id)\n+                                                                                                       .map(pi -> {\n+                                                                                                           pi.abort();\n+                                                                                                           return pi.variables()\n+                                                                                                                    .toOutput();\n+                                                                                                       }).orElse(\n+                                                                                                                 null)));", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNjgzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467036836", "bodyText": "Some methods here have each argument on a separate line, some of them don't. Can we maybe unify it? I think all can fit on one line here.", "author": "MarianMacik", "createdAt": "2020-08-07T13:22:58Z", "path": "kogito-codegen/src/main/resources/class-templates/ReactiveRestResourceTemplate.java", "diffHunk": "@@ -38,134 +39,108 @@\n public class $Type$ReactiveResource {\n \n     Process<$Type$> process;\n-    \n+\n     Application application;\n \n     @POST()\n     @Produces(MediaType.APPLICATION_JSON)\n-    @Consumes(MediaType.APPLICATION_JSON)    \n-    public CompletionStage<$Type$Output> createResource_$name$(@Context HttpHeaders httpHeaders, @QueryParam(\"businessKey\") String businessKey, $Type$Input resource) {\n-        if (resource == null) {\n-            resource = new $Type$Input();\n-        }\n-        final $Type$Input value = resource;\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.createInstance(businessKey, mapInput(value, new $Type$()));\n-                String startFromNode = httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n-                \n-                if (startFromNode != null) {\n-                    pi.startFrom(startFromNode);\n-                } else {\n-                    pi.start();\n-                }\n-                return getModel(pi);\n-            });\n-        });\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public CompletionStage<$Type$Output> createResource_$name$(@Context HttpHeaders httpHeaders,\n+                                                               @QueryParam(\"businessKey\") String businessKey,\n+                                                               $Type$Input resource) {\n+        return CompletableFuture.supplyAsync(\n+                                             () -> UnitOfWorkExecutor.executeInUnitOfWork(\n+                                                                                          application.unitOfWorkManager(),\n+                                                                                          () -> {\n+                                                                                              $Type$Input inputModel =\n+                                                                                                      resource != null\n+                                                                                                              ? resource\n+                                                                                                              : new $Type$Input();\n+                                                                                              ProcessInstance<$Type$> pi =\n+                                                                                                      process.createInstance(businessKey,\n+                                                                                                                             inputModel.toModel());\n+                                                                                              String startFromNode =\n+                                                                                                      httpHeaders.getHeaderString(\"X-KOGITO-StartFromNode\");\n+                                                                                              if (startFromNode != null) {\n+                                                                                                  pi.startFrom(startFromNode);\n+                                                                                              } else {\n+                                                                                                  pi.start();\n+                                                                                              }\n+                                                                                              return pi.checkError()\n+                                                                                                       .variables()\n+                                                                                                       .toOutput();\n+                                                                                          }));\n     }\n \n     @GET()\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<List<$Type$Output>> getResources_$name$() {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return process.instances().values().stream()\n-                    .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n-                 .collect(Collectors.toList());\n-        });   \n+        return CompletableFuture.supplyAsync(() -> process.instances().values().stream()\n+                                                          .map(pi -> pi.variables().toOutput())\n+                                                          .collect(Collectors.toList()));\n     }\n \n     @GET()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> getResource_$name$(@PathParam(\"id\") String id) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return process.instances()\n-                    .findById(id, ProcessInstanceReadMode.READ_ONLY)\n-                    .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n-                    .orElse(null);\n-        });\n+        return CompletableFuture.supplyAsync(() -> process.instances()\n+                                                          .findById(id, ProcessInstanceReadMode.READ_ONLY)\n+                                                          .map(pi -> pi.variables().toOutput())\n+                                                          .orElse(null));\n     }\n-    \n+\n     @DELETE()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> deleteResource_$name$(@PathParam(\"id\") final String id) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.instances()\n-                        .findById(id)\n-                        .orElse(null);\n-                if (pi == null) {\n-                    return null;\n-                } else {\n-                    pi.abort();\n-                    return getModel(pi);\n-                }\n-            });\n-        });\n+        return CompletableFuture.supplyAsync(() -> UnitOfWorkExecutor.executeInUnitOfWork(\n+                                                                                          application.unitOfWorkManager(),\n+                                                                                          () -> process.instances()\n+                                                                                                       .findById(id)\n+                                                                                                       .map(pi -> {\n+                                                                                                           pi.abort();\n+                                                                                                           return pi.variables()\n+                                                                                                                    .toOutput();\n+                                                                                                       }).orElse(\n+                                                                                                                 null)));\n     }\n-    \n+\n     @POST()\n     @Path(\"/{id}\")\n     @Consumes(MediaType.APPLICATION_JSON)\n     @Produces(MediaType.APPLICATION_JSON)\n     public CompletionStage<$Type$Output> updateModel_$name$(@PathParam(\"id\") String id, $Type$ resource) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n-                ProcessInstance<$Type$> pi = process.instances()\n-                        .findById(id)\n-                        .orElse(null);\n-                if (pi == null) {\n-                    return null;\n-                } else {\n-                    pi.updateVariables(resource);\n-                    return mapOutput(new $Type$Output(), pi.variables());\n-                }\n-            });\n-        });\n+        return CompletableFuture.supplyAsync(() -> UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(),\n+                                                                                          () -> process.instances()\n+                                                                                                       .findById(id)\n+                                                                                                       .map(pi -> pi.updateVariables(resource)\n+                                                                                                                    .toOutput())\n+                                                                                                       .orElse(null)));\n     }\n-    \n+\n     @GET()\n     @Path(\"/{id}/tasks\")\n     @Produces(MediaType.APPLICATION_JSON)\n-    public CompletionStage<Map<String, String>> getTasks_$name$(@PathParam(\"id\") String id, @QueryParam(\"user\") final String user, @QueryParam(\"group\") final List<String> groups) {\n-        return CompletableFuture.supplyAsync(() -> {\n-            return process.instances()\n-                    .findById(id, ProcessInstanceReadMode.READ_ONLY)\n-                    .map(pi -> pi.workItems(policies(user, groups)))\n-                    .map(l -> l.stream().collect(Collectors.toMap(WorkItem::getId, WorkItem::getName)))\n-                    .orElse(null);\n-        });\n-    }\n-    \n-    protected $Type$Output getModel(ProcessInstance<$Type$> pi) {\n-        if (pi.status() == ProcessInstance.STATE_ERROR && pi.error().isPresent()) {\n-            throw new ProcessInstanceExecutionException(pi.id(), pi.error().get().failedNodeId(), pi.error().get().errorMessage());\n-        }\n-        \n-        return mapOutput(new $Type$Output(), pi.variables());\n+    public CompletionStage<Map<String, String>> getTasks_$name$(@PathParam(\"id\") String id,\n+                                                                @QueryParam(\"user\") final String user,\n+                                                                @QueryParam(\"group\") final List<String> groups) {", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExNzg1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467117859", "bodyText": "Ill review that, but any change in format from previous version is probably performed by the IDE automatically according to the code style globally defined for KIE group", "author": "fjtirado", "createdAt": "2020-08-07T15:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNjgzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEzNjUyOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467136529", "bodyText": "I think all methods that have arguments on separate line exceeds the 120 limit, so I guess it is fine to have them splitted and the ones that does not exceed the limit kept on one line.", "author": "fjtirado", "createdAt": "2020-08-07T16:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAzNjgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2Nzc3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467067773", "bodyText": "Missing checkError().", "author": "MarianMacik", "createdAt": "2020-08-07T14:14:48Z", "path": "kogito-codegen/src/main/resources/class-templates/RestResourceSignalTemplate.java", "diffHunk": "@@ -32,10 +32,10 @@\n     @Consumes(MediaType.APPLICATION_JSON)\n     @Produces(MediaType.APPLICATION_JSON)\n     public $Type$Output signal(@PathParam(\"id\") final String id, final $signalType$ data) {\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n+        return UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> {\n             return process.instances().findById(id).map(pi -> {\n                 pi.send(Sig.of(\"$signalName$\", data));\n-                return getModel(pi);\n+                return pi.variables().toOutput();", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExNzk1OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467117958", "bodyText": "good catch", "author": "fjtirado", "createdAt": "2020-08-07T15:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2Nzc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2ODQ5Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467068497", "bodyText": "Probably missing checkError() also here?", "author": "MarianMacik", "createdAt": "2020-08-07T14:15:56Z", "path": "kogito-codegen/src/main/resources/class-templates/RestResourceTemplate.java", "diffHunk": "@@ -77,68 +79,61 @@\n     public $Type$Output getResource_$name$(@PathParam(\"id\") String id) {\n         return process.instances()\n                       .findById(id, ProcessInstanceReadMode.READ_ONLY)\n-                      .map(pi -> mapOutput(new $Type$Output(), pi.variables()))\n+                      .map(pi -> pi.variables().toOutput())\n                       .orElse(null);\n     }\n \n     @DELETE()\n     @Path(\"/{id}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public $Type$Output deleteResource_$name$(@PathParam(\"id\") final String id) {\n-        return org.kie.kogito.services.uow.UnitOfWorkExecutor.executeInUnitOfWork(application.unitOfWorkManager(), () -> process.instances().findById(id).map(pi -> {\n-            pi.abort();\n-            return getModel(pi);\n-        }).orElse(null));\n+        return UnitOfWorkExecutor.executeInUnitOfWork(\n+                                                      application.unitOfWorkManager(),\n+                                                      () -> process\n+                                                                   .instances()\n+                                                                   .findById(id)\n+                                                                   .map(pi -> {\n+                                                                       pi.abort();\n+                                                                       return pi.variables().toOutput();", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExODA4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467118087", "bodyText": "hmm, it will not harm, added", "author": "fjtirado", "createdAt": "2020-08-07T15:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2ODQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4OTA3MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467089071", "bodyText": "Why not to leverage already existing fromMap() and toMap() methods on all 3 models (ModelInput, Model, ModelOutput).\nThen in ModelInput it would look something like:\npublic OrdersModel toModel() {\n        OrdersModel result = new OrdersModel();\n        result.fromMap(toMap());\n        return result;\n}\nOf course in case some variables are not available, they will be just set to null in the result.fromMap() call, but that's OK.\nAnd for Model:\npublic OrdersModelOutput toOutput() {\n        OrdersModelOutput result = new OrdersModelOutput();\n        result.fromMap(getId(), toMap());\n        return result;\n}\nAgain, ModelOutput will take only what it needs from the Model map so it should be OK.\nMy main point is to have as little code generation code as possible as it is much less readable in general than the actual runtime code. Otherwise the method duo (fromMap(), toMap()) will be now just used to bind and unbind variables I guess.\nAlso in case of a lot of variable, the code can be less verbose. I know it is a generated code but I think everybody has to look at it from time to time :)", "author": "MarianMacik", "createdAt": "2020-08-07T14:49:20Z", "path": "jbpm/jbpm-flow-builder/src/main/java/org/jbpm/compiler/canonical/ProcessToExecModelGenerator.java", "diffHunk": "@@ -101,28 +108,78 @@ public MethodDeclaration generateMethod(WorkflowProcess process) {\n     public ModelMetaData generateModel(WorkflowProcess process) {\n         String packageName = process.getPackageName();\n         String name = extractModelClassName(process.getId());\n-\n+        VariableScope variableScope = getVariableScope(process);\n         return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(),\n-                VariableDeclarations.of((VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE)),\n-                false);\n+                                 VariableDeclarations.of(variableScope),\n+                                 false, \"/class-templates/ModelTemplate.java\",\n+                                 new AddMethodConsumer(\"toOutput\", extractModelClassName(process.getId()) + \"Output\",\n+                                                       VariableDeclarations.ofOutput(variableScope), true));\n     }\n \n     public ModelMetaData generateInputModel(WorkflowProcess process) {\n         String packageName = process.getPackageName();\n-        String name = extractModelClassName(process.getId()) + \"Input\";\n-\n-        return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(),\n-                VariableDeclarations.ofInput((VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE)),\n-                true, \"/class-templates/ModelNoIDTemplate.java\");\n+        String modelName = extractModelClassName(process.getId());\n+        String name = modelName + \"Input\";\n+        VariableDeclarations inputVars = VariableDeclarations.ofInput(getVariableScope(process));\n+        return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(), inputVars, true,\n+                                 \"/class-templates/ModelNoIDTemplate.java\", new AddMethodConsumer(\"toModel\", modelName,\n+                                                                                                  inputVars, false));\n     }\n \n     public ModelMetaData generateOutputModel(WorkflowProcess process) {\n         String packageName = process.getPackageName();\n         String name = extractModelClassName(process.getId()) + \"Output\";\n-\n         return new ModelMetaData(process.getId(), packageName, name, process.getVisibility(),\n-                VariableDeclarations.ofOutput((VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(VariableScope.VARIABLE_SCOPE)),\n-                true);\n+                                 VariableDeclarations.ofOutput(getVariableScope(process)), true);\n+    }\n+\n+    private static VariableScope getVariableScope(WorkflowProcess process) {\n+        return (VariableScope) ((org.jbpm.process.core.Process) process).getDefaultContext(\n+                                                                                           VariableScope.VARIABLE_SCOPE);\n+    }\n+\n+    private static class AddMethodConsumer implements Consumer<CompilationUnit> {\n+\n+        private String methodName;\n+        private String returnClassName;\n+        private VariableDeclarations vars;\n+        private boolean includeId;\n+\n+        public AddMethodConsumer(String methodName, String returnClassName, VariableDeclarations vars, boolean includeId) {\n+            this.methodName = methodName;\n+            this.returnClassName = returnClassName;\n+            this.vars = vars;\n+            this.includeId = includeId;\n+        }\n+\n+        @Override\n+        public void accept(CompilationUnit cu) {\n+            Optional<ClassOrInterfaceDeclaration> clazz = cu.findFirst(ClassOrInterfaceDeclaration.class);\n+            if (!clazz.isPresent()) {\n+                throw new NoSuchElementException(\"Cannot find class declaration in the template\");\n+            }\n+            ClassOrInterfaceType type = parseClassOrInterfaceType(returnClassName);\n+            final String resultVarName = \"result\";\n+            MethodDeclaration method = clazz.get().addMethod(methodName, Modifier.Keyword.PUBLIC).setType(type);\n+            BlockStmt body = new BlockStmt();\n+            VariableDeclarationExpr returnVar = new VariableDeclarationExpr(type, resultVarName);\n+            body.addStatement(new AssignExpr(returnVar, new ObjectCreationExpr(null, type, NodeList.nodeList()),\n+                                             AssignExpr.Operator.ASSIGN));\n+            NameExpr returnName = new NameExpr(resultVarName);\n+            // fill id\n+            if (includeId) {\n+                body.addStatement(new MethodCallExpr(returnName, \"setId\").addArgument(new MethodCallExpr(null,\n+                                                                                                         \"getId\")));\n+            }\n+            for (Variable var : vars.getTypes().values()) {\n+                final String fieldName = StringUtils.ucFirst(var.getSanitizedName());\n+                body.addStatement(new MethodCallExpr(returnName, \"set\" + fieldName).addArgument(new MethodCallExpr(null,\n+                                                                                                                   \"get\" +\n+                                                                                                                         fieldName)));\n+            }\n+            body.addStatement(new ReturnStmt(returnName));\n+            method.setBody(body);", "originalCommit": "957bcf3f2b547753307b6bca5f554ccc129813c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExMjMwMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467112303", "bodyText": "I think that reading a map and then using that map to fill the parameters of the class being created is very inneficient compared with direct attribute assignment.\nThe rule Im following to write generated code is to generate the code I will write as it was not generated at all, and if I were writting a method to create outputmodel from a model I would definitely  use getter an setters rather than toMap-fromMap.\nThis means, as you  pointed out, that fromMap-toMap are not longer used for bind-unbiding any longer. And I think that is for good...\ntoMap method is still used for human task transition.\nfromMap can be probably removed, but I think this should be done in a different JIRA", "author": "fjtirado", "createdAt": "2020-08-07T15:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4OTA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc0Mjc4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/674#discussion_r467742783", "bodyText": "I think that reading and writing to a HashMap is basically a constant operation, but I also see your point. Bear in mind that toMap and fromMap are still used in generated bind/unbind methods of process instance, so we cannot remove them.", "author": "MarianMacik", "createdAt": "2020-08-10T08:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4OTA3MQ=="}], "type": "inlineReview"}, {"oid": "0d6c2fa30bad84a17311c86dd1464caec0391cd7", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0d6c2fa30bad84a17311c86dd1464caec0391cd7", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd checkError to ProcessInstance\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-07T16:12:45Z", "type": "forcePushed"}, {"oid": "430aa47ed1472406321395896add1f2e4e4f9900", "url": "https://github.com/kiegroup/kogito-runtimes/commit/430aa47ed1472406321395896add1f2e4e4f9900", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd checkError to ProcessInstance\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-07T16:19:50Z", "type": "commit"}, {"oid": "430aa47ed1472406321395896add1f2e4e4f9900", "url": "https://github.com/kiegroup/kogito-runtimes/commit/430aa47ed1472406321395896add1f2e4e4f9900", "message": "[KOGITO-2753] Processes: Remove model transformations from REST endpoint\n\nModel interface extends MapOutput and MapInput interfaces\nxxxTaskOutput classes implements MapOutput (generated code does not\nlonger need to invoke toMap when building HumanTaskTransition)\nNew methods toModel on InputModel and toOutput on Model\nAdd checkError to ProcessInstance\nModification on templates to use them (removing mapInput, mapOutput and\ngetModel)", "committedDate": "2020-08-07T16:19:50Z", "type": "forcePushed"}]}