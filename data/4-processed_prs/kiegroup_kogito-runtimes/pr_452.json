{"pr_number": 452, "pr_title": "KOGITO-1631 - File System based persistence addon", "pr_createdAt": "2020-04-17T07:46:15Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/452", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MTQ0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r410171448", "bodyText": "@mswiderski can you include the copywrite headers :)", "author": "cristianonicolai", "createdAt": "2020-04-17T11:49:48Z", "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/filesystem/FileSystemProcessInstances.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.kie.kogito.persistence.filesystem;", "originalCommit": "b9a38a9efbd7f25024509b206c81b556a3370c89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MTY0MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r410171641", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n          \n          \n            \n             * Copyright 2020 Red Hat, Inc. and/or its affiliates.", "author": "cristianonicolai", "createdAt": "2020-04-17T11:50:20Z", "path": "addons/persistence/filesystem-persistence-addon/src/test/java/org/kie/persistence/filesystem/FileSystemProcessInstancesTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.", "originalCommit": "b9a38a9efbd7f25024509b206c81b556a3370c89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3NTU0OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r410175549", "bodyText": "any specific reason for doing a list and not using it? perhaps just do a size assert?", "author": "cristianonicolai", "createdAt": "2020-04-17T11:59:03Z", "path": "addons/persistence/filesystem-persistence-addon/src/test/java/org/kie/persistence/filesystem/FileSystemProcessInstancesTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.persistence.filesystem;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_COMPLETED;\n+\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.services.identity.StaticIdentityProvider;\n+\n+public class FileSystemProcessInstancesTest {\n+\n+\t\n+\tprivate SecurityPolicy securityPolicy = SecurityPolicy.of(new StaticIdentityProvider(\"john\"));\n+\t\n+    @Test\n+    public void testBasicFlow() {\n+\n+        BpmnProcess process = (BpmnProcess) BpmnProcess.from(new ClassPathResource(\"BPMN2-UserTask.bpmn2\")).get(0);\n+        process.setProcessInstancesFactory(new FileSystemProcessInstancesFactory());\n+        process.configure();\n+                                     \n+        ProcessInstance<BpmnVariables> processInstance = process.createInstance(BpmnVariables.create(Collections.singletonMap(\"test\", \"test\")));\n+\n+        processInstance.start();\n+        assertEquals(STATE_ACTIVE, processInstance.status());\n+        assertEquals(\"User Task\", processInstance.description());\n+        \n+        process.instances().values();", "originalCommit": "b9a38a9efbd7f25024509b206c81b556a3370c89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3Njc0OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r410176748", "bodyText": "this file should not be needed, the .gitignore in the root should be enough", "author": "cristianonicolai", "createdAt": "2020-04-17T12:01:43Z", "path": "addons/persistence/filesystem-persistence-addon/.gitignore", "diffHunk": "@@ -0,0 +1,10 @@\n+target/", "originalCommit": "b9a38a9efbd7f25024509b206c81b556a3370c89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0ead05b67b71ae1c42b88e86ea5d03d561b62e0b", "message": "KOGITO-1631 - File System based persistence addon", "committedDate": "2020-04-17T12:17:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNjUwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411336504", "bodyText": "It seems this method read all files on the target path, in case we have N files this can be dangerous loading all into memory, wouldn't be better to have at least a limit/pagination?", "author": "tiagodolphine", "createdAt": "2020-04-20T12:28:18Z", "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/filesystem/FileSystemProcessInstances.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.filesystem;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.UserDefinedFileAttributeView;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@SuppressWarnings({\"rawtypes\"})\n+public class FileSystemProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FileSystemProcessInstances.class);\n+\n+    private static final String PI_DESCRIPTION = \"ProcessInstanceDescription\";\n+    private Process<?> process;\n+    private Path storage;\n+\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage) {\n+        this(process, storage, new ProcessInstanceMarshaller());\n+    }\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage, ProcessInstanceMarshaller marshaller) {\n+        this.process = process;\n+        this.storage = Paths.get(storage.toString(), process.id());\n+        this.marshaller = marshaller;\n+\n+        try {\n+            Files.createDirectories(this.storage);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to create directories for file based storage of process instances\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional findById(String id) {\n+        String resolvedId = resolveId(id);\n+        Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+        if (Files.notExists(processInstanceStorage)) {\n+            return Optional.empty();\n+        }\n+        return (Optional<? extends ProcessInstance>) Optional.of(marshaller.unmarshallProcessInstance(readBytesFromFile(processInstanceStorage), process));\n+\n+    }\n+\n+    @Override\n+    public Collection values() {\n+        try {\n+            return Files.walk(storage)\n+                        .filter(file -> !Files.isDirectory(file))\n+                        .map(f -> marshaller.unmarshallProcessInstance(readBytesFromFile(f), process))\n+                        .collect(Collectors.toList());", "originalCommit": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM2MzI3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411363272", "bodyText": "this is exactly the same as other implementations as well. loading all with high number of active instances might lead to overloaded situations. This has been recently discussed and once the implementation of pagination or limitation is decided this implies should be updated accordingly", "author": "mswiderski", "createdAt": "2020-04-20T13:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNjUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNzQyNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411337427", "bodyText": "formatting", "author": "tiagodolphine", "createdAt": "2020-04-20T12:29:49Z", "path": "addons/persistence/filesystem-persistence-addon/src/test/java/org/kie/persistence/filesystem/FileSystemProcessInstancesTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.persistence.filesystem;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE;\n+import static org.kie.api.runtime.process.ProcessInstance.STATE_COMPLETED;\n+\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+\n+import org.drools.core.io.impl.ClassPathResource;\n+import org.junit.jupiter.api.Test;\n+import org.kie.kogito.auth.SecurityPolicy;\n+import org.kie.kogito.persistence.KogitoProcessInstancesFactory;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.WorkItem;\n+import org.kie.kogito.process.bpmn2.BpmnProcess;\n+import org.kie.kogito.process.bpmn2.BpmnVariables;\n+import org.kie.kogito.services.identity.StaticIdentityProvider;\n+\n+public class FileSystemProcessInstancesTest {\n+\n+\t\n+\tprivate SecurityPolicy securityPolicy = SecurityPolicy.of(new StaticIdentityProvider(\"john\"));", "originalCommit": "0ead05b67b71ae1c42b88e86ea5d03d561b62e0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM2Mzk5MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411363990", "bodyText": "fixed", "author": "mswiderski", "createdAt": "2020-04-20T13:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNzQyNw=="}], "type": "inlineReview"}, {"oid": "b748af707ac34620f05f7dd91a2f98ae54ac9ab9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b748af707ac34620f05f7dd91a2f98ae54ac9ab9", "message": "KOGITO-1631 - File System based persistence addon", "committedDate": "2020-04-20T13:10:23Z", "type": "forcePushed"}, {"oid": "88fb8db9e595c086fd6bf0925c66214ece19b842", "url": "https://github.com/kiegroup/kogito-runtimes/commit/88fb8db9e595c086fd6bf0925c66214ece19b842", "message": "KOGITO-1631 - File System based persistence addon", "committedDate": "2020-04-20T15:50:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3MjQwNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411472406", "bodyText": "Don't we want to inform a user in case a process instance we are trying to update does not exist?", "author": "MarianMacik", "createdAt": "2020-04-20T15:28:52Z", "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/filesystem/FileSystemProcessInstances.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.filesystem;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.UserDefinedFileAttributeView;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@SuppressWarnings({\"rawtypes\"})\n+public class FileSystemProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FileSystemProcessInstances.class);\n+\n+    private static final String PI_DESCRIPTION = \"ProcessInstanceDescription\";\n+    private Process<?> process;\n+    private Path storage;\n+\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage) {\n+        this(process, storage, new ProcessInstanceMarshaller());\n+    }\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage, ProcessInstanceMarshaller marshaller) {\n+        this.process = process;\n+        this.storage = Paths.get(storage.toString(), process.id());\n+        this.marshaller = marshaller;\n+\n+        try {\n+            Files.createDirectories(this.storage);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to create directories for file based storage of process instances\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional findById(String id) {\n+        String resolvedId = resolveId(id);\n+        Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+        if (Files.notExists(processInstanceStorage)) {\n+            return Optional.empty();\n+        }\n+        return (Optional<? extends ProcessInstance>) Optional.of(marshaller.unmarshallProcessInstance(readBytesFromFile(processInstanceStorage), process));\n+\n+    }\n+\n+    @Override\n+    public Collection values() {\n+        try {\n+            return Files.walk(storage)\n+                        .filter(file -> !Files.isDirectory(file))\n+                        .map(f -> marshaller.unmarshallProcessInstance(readBytesFromFile(f), process))\n+                        .collect(Collectors.toList());\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return Files.exists(Paths.get(storage.toString(), resolveId(id)));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            String resolvedId = resolveId(id);\n+            Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+            if (Files.exists(processInstanceStorage)) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            storeProcessInstance(processInstanceStorage, instance);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            String resolvedId = resolveId(id);\n+            Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+            if (Files.exists(processInstanceStorage)) {\n+                storeProcessInstance(processInstanceStorage, instance);\n+            }", "originalCommit": "b748af707ac34620f05f7dd91a2f98ae54ac9ab9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxMTQzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411611436", "bodyText": "It should be no op when there is no process instance already stored", "author": "mswiderski", "createdAt": "2020-04-20T18:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3MjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk2Njk2NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411966964", "bodyText": "Why? I mean in case there is a bug in the engine which will try to update the instance but won't find it we have no info about this happening.", "author": "MarianMacik", "createdAt": "2020-04-21T08:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3MjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3MzMyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411473326", "bodyText": "Shouldn't we inform a user if the process instance we are trying to delete does not exist? This can really help avoid potential issues in the future in case there is a bug in the code.", "author": "MarianMacik", "createdAt": "2020-04-20T15:29:58Z", "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/filesystem/FileSystemProcessInstances.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence.filesystem;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.UserDefinedFileAttributeView;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.kie.kogito.process.MutableProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstance;\n+import org.kie.kogito.process.ProcessInstanceDuplicatedException;\n+import org.kie.kogito.process.impl.AbstractProcessInstance;\n+import org.kie.kogito.process.impl.marshalling.ProcessInstanceMarshaller;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@SuppressWarnings({\"rawtypes\"})\n+public class FileSystemProcessInstances implements MutableProcessInstances {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FileSystemProcessInstances.class);\n+\n+    private static final String PI_DESCRIPTION = \"ProcessInstanceDescription\";\n+    private Process<?> process;\n+    private Path storage;\n+\n+    private ProcessInstanceMarshaller marshaller;\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage) {\n+        this(process, storage, new ProcessInstanceMarshaller());\n+    }\n+\n+    public FileSystemProcessInstances(Process<?> process, Path storage, ProcessInstanceMarshaller marshaller) {\n+        this.process = process;\n+        this.storage = Paths.get(storage.toString(), process.id());\n+        this.marshaller = marshaller;\n+\n+        try {\n+            Files.createDirectories(this.storage);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to create directories for file based storage of process instances\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Optional findById(String id) {\n+        String resolvedId = resolveId(id);\n+        Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+        if (Files.notExists(processInstanceStorage)) {\n+            return Optional.empty();\n+        }\n+        return (Optional<? extends ProcessInstance>) Optional.of(marshaller.unmarshallProcessInstance(readBytesFromFile(processInstanceStorage), process));\n+\n+    }\n+\n+    @Override\n+    public Collection values() {\n+        try {\n+            return Files.walk(storage)\n+                        .filter(file -> !Files.isDirectory(file))\n+                        .map(f -> marshaller.unmarshallProcessInstance(readBytesFromFile(f), process))\n+                        .collect(Collectors.toList());\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to read process instances \", e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean exists(String id) {\n+        return Files.exists(Paths.get(storage.toString(), resolveId(id)));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void create(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            String resolvedId = resolveId(id);\n+            Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+            if (Files.exists(processInstanceStorage)) {\n+                throw new ProcessInstanceDuplicatedException(id);\n+            }\n+            storeProcessInstance(processInstanceStorage, instance);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void update(String id, ProcessInstance instance) {\n+        if (isActive(instance)) {\n+            String resolvedId = resolveId(id);\n+            Path processInstanceStorage = Paths.get(storage.toString(), resolvedId);\n+\n+            if (Files.exists(processInstanceStorage)) {\n+                storeProcessInstance(processInstanceStorage, instance);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void remove(String id) {\n+        Path processInstanceStorage = Paths.get(storage.toString(), resolveId(id));\n+\n+        try {\n+            Files.deleteIfExists(processInstanceStorage);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Unable to remove process instance with id \" + id, e);", "originalCommit": "b748af707ac34620f05f7dd91a2f98ae54ac9ab9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxMDk4NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411610984", "bodyText": "If it does not exist it should never call this method as it is only accessed from the process instance abort method", "author": "mswiderski", "createdAt": "2020-04-20T18:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3MzMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MDU0MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411490540", "bodyText": "mutually", "author": "MarianMacik", "createdAt": "2020-04-20T15:51:50Z", "path": "pom.xml", "diffHunk": "@@ -842,6 +842,8 @@\n                               <include name=\"**/target/classes/**/*.class\"/>\n                               <!-- To avoid a complaint about duplicate classes from archetypes. -->\n                               <exclude name=\"**/target/test-classes/**/*.class\"/>\n+                              <!-- To avoid a complaint about duplicate classes as KogitoProcessInstancesFactory.class is required in every persistence addon that is mutally exclusive. -->", "originalCommit": "88fb8db9e595c086fd6bf0925c66214ece19b842", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMjAxOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411632019", "bodyText": "fixed", "author": "mswiderski", "createdAt": "2020-04-20T19:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MDU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwODA2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411508061", "bodyText": "Would be good to have this at the top as a constant as well.", "author": "MarianMacik", "createdAt": "2020-04-20T16:14:00Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -273,4 +147,199 @@ public void setDependencyInjection(DependencyInjectionAnnotator annotator) {\n     protected boolean useInjection() {\n         return this.annotator != null;\n     }\n+    \n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    protected void inifinispanBasedPersistence(List<GeneratedFile> generatedFiles) {\n+        Collection dataModelClasses = protoGenerator.extractDataClasses((Collection) modelClasses, targetDirectory.toString());\n+        Path protoFilePath = Paths.get(targetDirectory.getParent(), \"src/main/resources\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+        File persistencePath = Paths.get(targetDirectory.getAbsolutePath(), \"/classes/persistence\").toFile();\n+        \n+        if (persistencePath != null && persistencePath.isDirectory()) {\n+            // only process proto files generated by the inner generator\n+            for (final File protoFile : Objects.requireNonNull(persistencePath.listFiles((dir, name) ->\n+                    !KOGITO_APPLICATION_PROTO.equalsIgnoreCase(name) && name.toLowerCase().endsWith(PersistenceProtoFilesLabeler.PROTO_FILE_EXT))))\n+                this.persistenceProtoLabeler.processProto(protoFile);\n+        }\n+        \n+        if (!protoFilePath.toFile().exists()) {\n+            try {\n+                // generate proto file based on known data model\n+                Proto proto = protoGenerator.generate(packageName, dataModelClasses, \"import \\\"kogito-types.proto\\\";\");\n+                protoFilePath = Paths.get(targetDirectory.toString(), \"classes\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+            \n+                Files.createDirectories(protoFilePath.getParent());\n+                Files.write(protoFilePath, proto.toString().getBytes(StandardCharsets.UTF_8));\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error during proto file generation/store\", e);\n+            }\n+            \n+        }\n+    \n+    \n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        \n+        List<Expression> paramNames = new ArrayList<>();\n+        for (String parameter : parameters) {\n+            String name = \"param\" + paramNames.size();\n+            constructor.addParameter(parameter, name);\n+            paramNames.add(new NameExpr(name));\n+        }\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(paramNames));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);\n+            annotator.withInjection(constructor);\n+            \n+            FieldDeclaration templateNameField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(TEMPLATE_NAME));\n+            annotator.withConfigInjection(templateNameField, \"kogito.persistence.infinispan.template\");\n+            // allow to inject template name for the cache\n+            BlockStmt templateMethodBody = new BlockStmt();                \n+            templateMethodBody.addStatement(new ReturnStmt(new MethodCallExpr(new NameExpr(TEMPLATE_NAME), \"orElse\").addArgument(new StringLiteralExpr(\"\"))));\n+            \n+            MethodDeclaration templateNameMethod = new MethodDeclaration()\n+                    .addModifier(Keyword.PUBLIC)\n+                    .setName(\"template\")\n+                    .setType(String.class)                                \n+                    .setBody(templateMethodBody);\n+            \n+            persistenceProviderClazz.addMember(templateNameField);\n+            persistenceProviderClazz.addMember(templateNameMethod);\n+        }\n+        List<String> variableMarshallers = new ArrayList<>();  \n+        // handler process variable marshallers\n+        if (protoFilePath.toFile().exists()) {\n+            MarshallerGenerator marshallerGenerator = new MarshallerGenerator(this.classLoader);\n+            try {\n+                String protoContent = new String(Files.readAllBytes(protoFilePath));\n+                \n+                List<CompilationUnit> marshallers = marshallerGenerator.generate(protoContent);\n+                \n+                if (!marshallers.isEmpty()) {\n+                    \n+                    for (CompilationUnit marshallerClazz : marshallers) {\n+                        String packageName = marshallerClazz.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                        String clazzName = packageName + \".\" + marshallerClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+                     \n+                        variableMarshallers.add(clazzName);\n+                        \n+                        generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                          clazzName.replace('.', '/') + \".java\",\n+                                          marshallerClazz.toString().getBytes(StandardCharsets.UTF_8)));                        \n+                    }                    \n+                }\n+        \n+                // handler process variable marshallers                                     \n+                if (!variableMarshallers.isEmpty()) {\n+                    \n+                    MethodDeclaration protoMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"proto\")\n+                            .setType(String.class)                                \n+                            .setBody(new BlockStmt()\n+                                     .addStatement(new ReturnStmt(new StringLiteralExpr().setString(protoContent))));\n+                    \n+                    persistenceProviderClazz.addMember(protoMethod);\n+                    \n+                    ClassOrInterfaceType listType = new ClassOrInterfaceType(null, List.class.getCanonicalName());\n+                    BlockStmt marshallersMethodBody = new BlockStmt();\n+                    VariableDeclarationExpr marshallerList = new VariableDeclarationExpr(new VariableDeclarator(listType, \"list\", new ObjectCreationExpr(null, new ClassOrInterfaceType(null, ArrayList.class.getCanonicalName()), NodeList.nodeList())));\n+                    marshallersMethodBody.addStatement(marshallerList);\n+                    \n+                    for (String marshallerClazz : variableMarshallers) {\n+                        \n+                        MethodCallExpr addMarshallerMethod = new MethodCallExpr(new NameExpr(\"list\"), \"add\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, marshallerClazz), NodeList.nodeList()));\n+                        marshallersMethodBody.addStatement(addMarshallerMethod);\n+                        \n+                    }\n+                    \n+                    marshallersMethodBody.addStatement(new ReturnStmt(new NameExpr(\"list\")));\n+                    \n+                    MethodDeclaration marshallersMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"marshallers\")\n+                            .setType(listType)                                \n+                            .setBody(marshallersMethodBody);\n+                    \n+                    persistenceProviderClazz.addMember(marshallersMethod);\n+                }\n+                    \n+                \n+                String packageName = compilationUnit.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                String clazzName = packageName + \".\" + persistenceProviderClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+             \n+                generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                                     clazzName.replace('.', '/') + \".java\",\n+                                                     compilationUnit.toString().getBytes(StandardCharsets.UTF_8))); \n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error when generating marshallers for defined variables\", e);\n+            }\n+            persistenceProviderClazz.getMembers().sort(new BodyDeclarationComparator());\n+        }\n+    }\n+    \n+    protected void fileSystemBasedPersistence(List<GeneratedFile> generatedFiles) {\n+    \tClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        constructor.addParameter(new ClassOrInterfaceType(null, String.class.getName()), \"storagePath\");\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new MethodCallExpr(new NameExpr(Paths.class.getCanonicalName()), \"get\").addArgument(new NameExpr(\"storagePath\"))));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);            \n+            \n+            FieldDeclaration pathField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(PATH_NAME));\n+            annotator.withConfigInjection(pathField, \"kogito.persistence.filesystem.path\");", "originalCommit": "88fb8db9e595c086fd6bf0925c66214ece19b842", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMjE0MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411632141", "bodyText": "moved to constant", "author": "mswiderski", "createdAt": "2020-04-20T19:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwODA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTA3Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411519077", "bodyText": "PATH_NAME can be used here as well.", "author": "MarianMacik", "createdAt": "2020-04-20T16:28:58Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -273,4 +147,199 @@ public void setDependencyInjection(DependencyInjectionAnnotator annotator) {\n     protected boolean useInjection() {\n         return this.annotator != null;\n     }\n+    \n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    protected void inifinispanBasedPersistence(List<GeneratedFile> generatedFiles) {\n+        Collection dataModelClasses = protoGenerator.extractDataClasses((Collection) modelClasses, targetDirectory.toString());\n+        Path protoFilePath = Paths.get(targetDirectory.getParent(), \"src/main/resources\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+        File persistencePath = Paths.get(targetDirectory.getAbsolutePath(), \"/classes/persistence\").toFile();\n+        \n+        if (persistencePath != null && persistencePath.isDirectory()) {\n+            // only process proto files generated by the inner generator\n+            for (final File protoFile : Objects.requireNonNull(persistencePath.listFiles((dir, name) ->\n+                    !KOGITO_APPLICATION_PROTO.equalsIgnoreCase(name) && name.toLowerCase().endsWith(PersistenceProtoFilesLabeler.PROTO_FILE_EXT))))\n+                this.persistenceProtoLabeler.processProto(protoFile);\n+        }\n+        \n+        if (!protoFilePath.toFile().exists()) {\n+            try {\n+                // generate proto file based on known data model\n+                Proto proto = protoGenerator.generate(packageName, dataModelClasses, \"import \\\"kogito-types.proto\\\";\");\n+                protoFilePath = Paths.get(targetDirectory.toString(), \"classes\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+            \n+                Files.createDirectories(protoFilePath.getParent());\n+                Files.write(protoFilePath, proto.toString().getBytes(StandardCharsets.UTF_8));\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error during proto file generation/store\", e);\n+            }\n+            \n+        }\n+    \n+    \n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        \n+        List<Expression> paramNames = new ArrayList<>();\n+        for (String parameter : parameters) {\n+            String name = \"param\" + paramNames.size();\n+            constructor.addParameter(parameter, name);\n+            paramNames.add(new NameExpr(name));\n+        }\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(paramNames));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);\n+            annotator.withInjection(constructor);\n+            \n+            FieldDeclaration templateNameField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(TEMPLATE_NAME));\n+            annotator.withConfigInjection(templateNameField, \"kogito.persistence.infinispan.template\");\n+            // allow to inject template name for the cache\n+            BlockStmt templateMethodBody = new BlockStmt();                \n+            templateMethodBody.addStatement(new ReturnStmt(new MethodCallExpr(new NameExpr(TEMPLATE_NAME), \"orElse\").addArgument(new StringLiteralExpr(\"\"))));\n+            \n+            MethodDeclaration templateNameMethod = new MethodDeclaration()\n+                    .addModifier(Keyword.PUBLIC)\n+                    .setName(\"template\")\n+                    .setType(String.class)                                \n+                    .setBody(templateMethodBody);\n+            \n+            persistenceProviderClazz.addMember(templateNameField);\n+            persistenceProviderClazz.addMember(templateNameMethod);\n+        }\n+        List<String> variableMarshallers = new ArrayList<>();  \n+        // handler process variable marshallers\n+        if (protoFilePath.toFile().exists()) {\n+            MarshallerGenerator marshallerGenerator = new MarshallerGenerator(this.classLoader);\n+            try {\n+                String protoContent = new String(Files.readAllBytes(protoFilePath));\n+                \n+                List<CompilationUnit> marshallers = marshallerGenerator.generate(protoContent);\n+                \n+                if (!marshallers.isEmpty()) {\n+                    \n+                    for (CompilationUnit marshallerClazz : marshallers) {\n+                        String packageName = marshallerClazz.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                        String clazzName = packageName + \".\" + marshallerClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+                     \n+                        variableMarshallers.add(clazzName);\n+                        \n+                        generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                          clazzName.replace('.', '/') + \".java\",\n+                                          marshallerClazz.toString().getBytes(StandardCharsets.UTF_8)));                        \n+                    }                    \n+                }\n+        \n+                // handler process variable marshallers                                     \n+                if (!variableMarshallers.isEmpty()) {\n+                    \n+                    MethodDeclaration protoMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"proto\")\n+                            .setType(String.class)                                \n+                            .setBody(new BlockStmt()\n+                                     .addStatement(new ReturnStmt(new StringLiteralExpr().setString(protoContent))));\n+                    \n+                    persistenceProviderClazz.addMember(protoMethod);\n+                    \n+                    ClassOrInterfaceType listType = new ClassOrInterfaceType(null, List.class.getCanonicalName());\n+                    BlockStmt marshallersMethodBody = new BlockStmt();\n+                    VariableDeclarationExpr marshallerList = new VariableDeclarationExpr(new VariableDeclarator(listType, \"list\", new ObjectCreationExpr(null, new ClassOrInterfaceType(null, ArrayList.class.getCanonicalName()), NodeList.nodeList())));\n+                    marshallersMethodBody.addStatement(marshallerList);\n+                    \n+                    for (String marshallerClazz : variableMarshallers) {\n+                        \n+                        MethodCallExpr addMarshallerMethod = new MethodCallExpr(new NameExpr(\"list\"), \"add\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, marshallerClazz), NodeList.nodeList()));\n+                        marshallersMethodBody.addStatement(addMarshallerMethod);\n+                        \n+                    }\n+                    \n+                    marshallersMethodBody.addStatement(new ReturnStmt(new NameExpr(\"list\")));\n+                    \n+                    MethodDeclaration marshallersMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"marshallers\")\n+                            .setType(listType)                                \n+                            .setBody(marshallersMethodBody);\n+                    \n+                    persistenceProviderClazz.addMember(marshallersMethod);\n+                }\n+                    \n+                \n+                String packageName = compilationUnit.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                String clazzName = packageName + \".\" + persistenceProviderClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+             \n+                generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                                     clazzName.replace('.', '/') + \".java\",\n+                                                     compilationUnit.toString().getBytes(StandardCharsets.UTF_8))); \n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error when generating marshallers for defined variables\", e);\n+            }\n+            persistenceProviderClazz.getMembers().sort(new BodyDeclarationComparator());\n+        }\n+    }\n+    \n+    protected void fileSystemBasedPersistence(List<GeneratedFile> generatedFiles) {\n+    \tClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        constructor.addParameter(new ClassOrInterfaceType(null, String.class.getName()), \"storagePath\");\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new MethodCallExpr(new NameExpr(Paths.class.getCanonicalName()), \"get\").addArgument(new NameExpr(\"storagePath\"))));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);            \n+            \n+            FieldDeclaration pathField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(PATH_NAME));\n+            annotator.withConfigInjection(pathField, \"kogito.persistence.filesystem.path\");\n+            // allow to inject path for the file system storage\n+            BlockStmt pathMethodBody = new BlockStmt();                \n+            pathMethodBody.addStatement(new ReturnStmt(new MethodCallExpr(new NameExpr(PATH_NAME), \"orElse\").addArgument(new StringLiteralExpr(\"/tmp\"))));\n+            \n+            MethodDeclaration pathMethod = new MethodDeclaration()\n+                    .addModifier(Keyword.PUBLIC)\n+                    .setName(\"path\")", "originalCommit": "88fb8db9e595c086fd6bf0925c66214ece19b842", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMjE3Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411632177", "bodyText": "fixed", "author": "mswiderski", "createdAt": "2020-04-20T19:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxOTA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MjA2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411562067", "bodyText": "We can call just super() here and the effect will be the same.", "author": "MarianMacik", "createdAt": "2020-04-20T17:32:42Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -273,4 +147,199 @@ public void setDependencyInjection(DependencyInjectionAnnotator annotator) {\n     protected boolean useInjection() {\n         return this.annotator != null;\n     }\n+    \n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    protected void inifinispanBasedPersistence(List<GeneratedFile> generatedFiles) {\n+        Collection dataModelClasses = protoGenerator.extractDataClasses((Collection) modelClasses, targetDirectory.toString());\n+        Path protoFilePath = Paths.get(targetDirectory.getParent(), \"src/main/resources\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+        File persistencePath = Paths.get(targetDirectory.getAbsolutePath(), \"/classes/persistence\").toFile();\n+        \n+        if (persistencePath != null && persistencePath.isDirectory()) {\n+            // only process proto files generated by the inner generator\n+            for (final File protoFile : Objects.requireNonNull(persistencePath.listFiles((dir, name) ->\n+                    !KOGITO_APPLICATION_PROTO.equalsIgnoreCase(name) && name.toLowerCase().endsWith(PersistenceProtoFilesLabeler.PROTO_FILE_EXT))))\n+                this.persistenceProtoLabeler.processProto(protoFile);\n+        }\n+        \n+        if (!protoFilePath.toFile().exists()) {\n+            try {\n+                // generate proto file based on known data model\n+                Proto proto = protoGenerator.generate(packageName, dataModelClasses, \"import \\\"kogito-types.proto\\\";\");\n+                protoFilePath = Paths.get(targetDirectory.toString(), \"classes\", \"/persistence\", KOGITO_APPLICATION_PROTO);\n+            \n+                Files.createDirectories(protoFilePath.getParent());\n+                Files.write(protoFilePath, proto.toString().getBytes(StandardCharsets.UTF_8));\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error during proto file generation/store\", e);\n+            }\n+            \n+        }\n+    \n+    \n+        ClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));\n+        \n+        ConstructorDeclaration constructor = persistenceProviderClazz.addConstructor(Keyword.PUBLIC);\n+        \n+        List<Expression> paramNames = new ArrayList<>();\n+        for (String parameter : parameters) {\n+            String name = \"param\" + paramNames.size();\n+            constructor.addParameter(parameter, name);\n+            paramNames.add(new NameExpr(name));\n+        }\n+        BlockStmt body = new BlockStmt();\n+        ExplicitConstructorInvocationStmt superExp = new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(paramNames));\n+        body.addStatement(superExp);\n+        \n+        constructor.setBody(body);\n+        \n+        if (useInjection()) {\n+            annotator.withApplicationComponent(persistenceProviderClazz);\n+            annotator.withInjection(constructor);\n+            \n+            FieldDeclaration templateNameField = new FieldDeclaration().addVariable(new VariableDeclarator()\n+                                                                                     .setType(new ClassOrInterfaceType(null, new SimpleName(Optional.class.getCanonicalName()), NodeList.nodeList(new ClassOrInterfaceType(null, String.class.getCanonicalName()))))\n+                                                                                     .setName(TEMPLATE_NAME));\n+            annotator.withConfigInjection(templateNameField, \"kogito.persistence.infinispan.template\");\n+            // allow to inject template name for the cache\n+            BlockStmt templateMethodBody = new BlockStmt();                \n+            templateMethodBody.addStatement(new ReturnStmt(new MethodCallExpr(new NameExpr(TEMPLATE_NAME), \"orElse\").addArgument(new StringLiteralExpr(\"\"))));\n+            \n+            MethodDeclaration templateNameMethod = new MethodDeclaration()\n+                    .addModifier(Keyword.PUBLIC)\n+                    .setName(\"template\")\n+                    .setType(String.class)                                \n+                    .setBody(templateMethodBody);\n+            \n+            persistenceProviderClazz.addMember(templateNameField);\n+            persistenceProviderClazz.addMember(templateNameMethod);\n+        }\n+        List<String> variableMarshallers = new ArrayList<>();  \n+        // handler process variable marshallers\n+        if (protoFilePath.toFile().exists()) {\n+            MarshallerGenerator marshallerGenerator = new MarshallerGenerator(this.classLoader);\n+            try {\n+                String protoContent = new String(Files.readAllBytes(protoFilePath));\n+                \n+                List<CompilationUnit> marshallers = marshallerGenerator.generate(protoContent);\n+                \n+                if (!marshallers.isEmpty()) {\n+                    \n+                    for (CompilationUnit marshallerClazz : marshallers) {\n+                        String packageName = marshallerClazz.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                        String clazzName = packageName + \".\" + marshallerClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+                     \n+                        variableMarshallers.add(clazzName);\n+                        \n+                        generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                          clazzName.replace('.', '/') + \".java\",\n+                                          marshallerClazz.toString().getBytes(StandardCharsets.UTF_8)));                        \n+                    }                    \n+                }\n+        \n+                // handler process variable marshallers                                     \n+                if (!variableMarshallers.isEmpty()) {\n+                    \n+                    MethodDeclaration protoMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"proto\")\n+                            .setType(String.class)                                \n+                            .setBody(new BlockStmt()\n+                                     .addStatement(new ReturnStmt(new StringLiteralExpr().setString(protoContent))));\n+                    \n+                    persistenceProviderClazz.addMember(protoMethod);\n+                    \n+                    ClassOrInterfaceType listType = new ClassOrInterfaceType(null, List.class.getCanonicalName());\n+                    BlockStmt marshallersMethodBody = new BlockStmt();\n+                    VariableDeclarationExpr marshallerList = new VariableDeclarationExpr(new VariableDeclarator(listType, \"list\", new ObjectCreationExpr(null, new ClassOrInterfaceType(null, ArrayList.class.getCanonicalName()), NodeList.nodeList())));\n+                    marshallersMethodBody.addStatement(marshallerList);\n+                    \n+                    for (String marshallerClazz : variableMarshallers) {\n+                        \n+                        MethodCallExpr addMarshallerMethod = new MethodCallExpr(new NameExpr(\"list\"), \"add\").addArgument(new ObjectCreationExpr(null, new ClassOrInterfaceType(null, marshallerClazz), NodeList.nodeList()));\n+                        marshallersMethodBody.addStatement(addMarshallerMethod);\n+                        \n+                    }\n+                    \n+                    marshallersMethodBody.addStatement(new ReturnStmt(new NameExpr(\"list\")));\n+                    \n+                    MethodDeclaration marshallersMethod = new MethodDeclaration()\n+                            .addModifier(Keyword.PUBLIC)\n+                            .setName(\"marshallers\")\n+                            .setType(listType)                                \n+                            .setBody(marshallersMethodBody);\n+                    \n+                    persistenceProviderClazz.addMember(marshallersMethod);\n+                }\n+                    \n+                \n+                String packageName = compilationUnit.getPackageDeclaration().map(pd -> pd.getName().toString()).orElse(\"\");\n+                String clazzName = packageName + \".\" + persistenceProviderClazz.findFirst(ClassOrInterfaceDeclaration.class).map(c -> c.getName().toString()).get();\n+             \n+                generatedFiles.add(new GeneratedFile(GeneratedFile.Type.CLASS,\n+                                                     clazzName.replace('.', '/') + \".java\",\n+                                                     compilationUnit.toString().getBytes(StandardCharsets.UTF_8))); \n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Error when generating marshallers for defined variables\", e);\n+            }\n+            persistenceProviderClazz.getMembers().sort(new BodyDeclarationComparator());\n+        }\n+    }\n+    \n+    protected void fileSystemBasedPersistence(List<GeneratedFile> generatedFiles) {\n+    \tClassOrInterfaceDeclaration persistenceProviderClazz = new ClassOrInterfaceDeclaration()\n+                .setName(\"KogitoProcessInstancesFactoryImpl\")\n+                .setModifiers(Modifier.Keyword.PUBLIC)\n+                .addExtendedType(\"org.kie.kogito.persistence.KogitoProcessInstancesFactory\");\n+        \n+        CompilationUnit compilationUnit = new CompilationUnit(\"org.kie.kogito.persistence\");            \n+        compilationUnit.getTypes().add(persistenceProviderClazz);  \n+        \n+        persistenceProviderClazz.addConstructor(Keyword.PUBLIC).setBody(new BlockStmt().addStatement(new ExplicitConstructorInvocationStmt(false, null, NodeList.nodeList(new NullLiteralExpr()))));", "originalCommit": "88fb8db9e595c086fd6bf0925c66214ece19b842", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMjI0MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411632241", "bodyText": "fixed", "author": "mswiderski", "createdAt": "2020-04-20T19:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MjA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MjEzMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411562131", "bodyText": "Why not unify it with generated KogitoProcessInstancesFactoryImpl? storage is not actually used as only its String representation is. We can make String from storage and then just override a setter in the generated class with injection. By doing this we won't need any path method and also we won't need additional path field in the generated class, wdyt?", "author": "MarianMacik", "createdAt": "2020-04-20T17:32:48Z", "path": "addons/persistence/filesystem-persistence-addon/src/main/java/org/kie/kogito/persistence/KogitoProcessInstancesFactory.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.kogito.persistence;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.kie.kogito.persistence.filesystem.FileSystemProcessInstances;\n+import org.kie.kogito.process.Process;\n+import org.kie.kogito.process.ProcessInstancesFactory;\n+\n+/**\n+ * This class must always have exact FQCN as <code>org.kie.kogito.persistence.KogitoProcessInstancesFactory</code>\n+ *\n+ */\n+public abstract class KogitoProcessInstancesFactory implements ProcessInstancesFactory {\n+   \n+\tprivate Path storage; ", "originalCommit": "88fb8db9e595c086fd6bf0925c66214ece19b842", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwOTkwMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411609902", "bodyText": "This can be also used without code gen and it could just reuse the constructor", "author": "mswiderski", "createdAt": "2020-04-20T18:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk3MTcyNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411971724", "bodyText": "Yes, but so can be my proposal :) The thing is that we don't need storage of type Path at all as we are anyway then calling back String representation from it with storage.toString(), so String field would do just as well. Even if somebody uses KogitoProcessInstancesFactory without codegen, then they have to call the KogitoProcessInstancesFactory constructor which will store something as a Path just to call toString() again and again call Paths.Get() on that String as a part of createProcessInstances() method.", "author": "MarianMacik", "createdAt": "2020-04-21T08:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2Mjc4NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411562785", "bodyText": "What was the reason for adding this?", "author": "MarianMacik", "createdAt": "2020-04-20T17:33:52Z", "path": "kogito-maven-plugin/src/main/java/org/kie/kogito/maven/plugin/ProcessClassesMojo.java", "diffHunk": "@@ -107,10 +111,14 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n                         parameters.add(t.getTypeName());\n                     }\n                 }\n+                \n+                GeneratorContext context = GeneratorContext.ofResourcePath(kieSourcesDirectory);\n+                context.withBuildContext(discoverKogitoRuntimeContext(project));", "originalCommit": "88fb8db9e595c086fd6bf0925c66214ece19b842", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxMjM0Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411612343", "bodyText": "Because context is required by persistence generator so application.properties can be accessed", "author": "mswiderski", "createdAt": "2020-04-20T18:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2Mjc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2NzA3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411567072", "bodyText": "Can't we do this based on kogito.addon files?", "author": "MarianMacik", "createdAt": "2020-04-20T17:40:26Z", "path": "kogito-codegen/src/main/java/org/kie/kogito/codegen/process/persistence/PersistenceGenerator.java", "diffHunk": "@@ -102,152 +109,19 @@ public ApplicationSection section() {\n         return null;\n     }\n \n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    \n     @Override\n     public Collection<GeneratedFile> generate() {\n+    \tString persistenceType = context.getApplicationProperty(\"kogito.persistence.type\").orElse(DEFAULT_PERSISTENCE_TYPE);", "originalCommit": "88fb8db9e595c086fd6bf0925c66214ece19b842", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxMjYzOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/452#discussion_r411612638", "bodyText": "I prefer to have it explicit", "author": "mswiderski", "createdAt": "2020-04-20T18:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2NzA3Mg=="}], "type": "inlineReview"}, {"oid": "a65f9fbe92e6902c20d72caa98e8017e327da135", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a65f9fbe92e6902c20d72caa98e8017e327da135", "message": "KOGITO-1631 - File System based persistence addon", "committedDate": "2020-04-20T19:24:24Z", "type": "commit"}, {"oid": "a65f9fbe92e6902c20d72caa98e8017e327da135", "url": "https://github.com/kiegroup/kogito-runtimes/commit/a65f9fbe92e6902c20d72caa98e8017e327da135", "message": "KOGITO-1631 - File System based persistence addon", "committedDate": "2020-04-20T19:24:24Z", "type": "forcePushed"}]}