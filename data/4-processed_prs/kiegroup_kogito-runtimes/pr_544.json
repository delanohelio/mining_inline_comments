{"pr_number": 544, "pr_title": "[KOGITO-2126] Implement decision tracing addon with TraceEvent", "pr_createdAt": "2020-06-04T13:41:57Z", "pr_url": "https://github.com/kiegroup/kogito-runtimes/pull/544", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNDI3OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435734279", "bodyText": "Is this Counter class used just for this check?", "author": "r00ta", "createdAt": "2020-06-05T07:20:09Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/DecisionTracingCollector.java", "diffHunk": "@@ -35,49 +38,84 @@\n     private static final Logger LOG = LoggerFactory.getLogger(DecisionTracingCollector.class);\n \n     private final Map<String, List<EvaluateEvent>> cacheMap;\n+    private final Map<String, Counter> openEventsCounterMap;\n     private final Aggregator<?> aggregator;\n     private final Consumer<String> payloadConsumer;\n+    private final ModelSupplier modelSupplier;\n \n-    public DecisionTracingCollector(Consumer<String> payloadConsumer) {\n-        this(new DefaultAggregator(), payloadConsumer);\n+    public DecisionTracingCollector(Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n+        this(new DefaultAggregator(), payloadConsumer, modelSupplier);\n     }\n \n-    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer) {\n-        this.payloadConsumer = payloadConsumer;\n+    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n         this.cacheMap = new HashMap<>();\n+        this.openEventsCounterMap = new HashMap<>();\n         this.aggregator = aggregator;\n+        this.payloadConsumer = payloadConsumer;\n+        this.modelSupplier = modelSupplier;\n     }\n \n     public void addEvent(EvaluateEvent event) {\n-        LOG.trace(\n-                \"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\",\n-                event.getClass().getSimpleName(),\n-                event.getExecutionId(),\n-                event.getModelName(),\n-                event.getModelNamespace()\n-        );\n+        LOG.trace(\"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\", event.getType(), event.getExecutionId(), event.getModelName(), event.getModelNamespace());\n \n         String evaluationId = event.getExecutionId();\n         if (cacheMap.containsKey(evaluationId)) {\n             cacheMap.get(evaluationId).add(event);\n+            if (event.getType().isBefore()) {\n+                openEventsCounterMap.get(evaluationId).increment();\n+            } else {\n+                openEventsCounterMap.get(evaluationId).decrement();\n+            }\n         } else {\n             List<EvaluateEvent> list = new LinkedList<>();\n             list.add(event);\n             cacheMap.put(evaluationId, list);\n+            openEventsCounterMap.put(evaluationId, new Counter(1));\n             LOG.trace(\"Added evaluation {} to cache (current size: {})\", evaluationId, cacheMap.size());\n         }\n \n-        if (event instanceof AfterEvaluateAllEvent) {\n-            String payload = aggregate(evaluationId, cacheMap.get(evaluationId));\n-            payloadConsumer.accept(payload);\n-            LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+        if (openEventsCounterMap.get(evaluationId).getValue() == 0) {", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNDcwMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436024701", "bodyText": "Have you verified if it is possible to receive events in a wrong order? If not a check on AfterEvaluateAllEvent should be enough (you can still check the counter for consistency)\nEDIT: ok here there is the implicit assumption that events are ordered so probably AfterEvaluateAllEvent should be enough", "author": "danielezonca", "createdAt": "2020-06-05T16:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNDI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NjA2Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438846066", "bodyText": "I removed the Counter class and moved the logic that determines the evaluation termination in a dedicated TerminationDetector interface with two different implementations, one that checks the first and last events and one that counts the \"open\" events (a before without a corresponding after).", "author": "kostola", "createdAt": "2020-06-11T14:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNDI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTc0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435735745", "bodyText": "Record execution timestamp?", "author": "r00ta", "createdAt": "2020-06-05T07:23:29Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceHeader.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+\n+public class TraceHeader {\n+\n+    private final TraceEvent.Type type;\n+    private final String executionId;\n+    private final long duration;\n+    private final TraceModel resourceId;\n+    @JsonInclude(NON_EMPTY)\n+    private final List<Message> messages;\n+\n+    public TraceHeader(TraceEvent.Type type, String executionId, long duration, TraceModel resourceId, List<Message> messages) {", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NjE4OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438846188", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2020-06-11T14:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczOTcwMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435739702", "bodyText": "Duplicated code", "author": "r00ta", "createdAt": "2020-06-05T07:31:39Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmEvaluationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmInvocationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0NjQzOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437546439", "bodyText": "Removed", "author": "kostola", "createdAt": "2020-06-09T16:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczOTcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MDEzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435740136", "bodyText": "Duplicated code as above?", "author": "r00ta", "createdAt": "2020-06-05T07:32:34Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmEvaluationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmInvocationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnContextEntryTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Object result = afterEvent.getContextEntryResult().getExpressionResult();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"expressionId\", afterEvent.getContextEntryResult().getExpressionId());\n+        additionalData.put(\"nodeId\", model.getDecisionByName(afterEvent.getNodeName()).getId());\n+        additionalData.put(\"variableId\", afterEvent.getContextEntryResult().getVariableId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getContextEntryResult().getVariableName(), result, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnDecisionTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        List<Message> messages = afterEvent.getResult().getMessages().stream()\n+                .filter(m -> afterEvent.getNodeId().equals(m.getSourceId()))\n+                .collect(Collectors.toList());\n+\n+        Object result = afterEvent.getResult().getDecisionResults().stream()\n+                .filter(dr -> dr.getDecisionId().equals(afterEvent.getNodeId()))\n+                .findFirst()\n+                .map(EvaluateDecisionResult::getResult)\n+                .orElse(null);\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), result, messages, additionalData, stackEntry.getChildren());\n+    }\n+\n+    private static TraceExecutionStep buildDmnDecisionServiceTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep\n+        long duration = afterEvent.getNanoTime() - stackEntry.getBeforeEvent().getNanoTime();\n+\n+        Map<String, Object> additionalData = new HashMap<>();\n+        additionalData.put(\"nodeId\", afterEvent.getNodeId());\n+\n+        return new TraceExecutionStep(stackEntry.getType(), duration, afterEvent.getNodeName(), null, Collections.emptyList(), additionalData, stackEntry.getChildren());\n+    }", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0Njc3Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437546776", "bodyText": "Removed as above \ud83d\ude1c", "author": "kostola", "createdAt": "2020-06-09T16:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MDEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MzcyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435743726", "bodyText": "Move to separated file", "author": "r00ta", "createdAt": "2020-06-05T07:40:04Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/evaluate/EvaluateEvent.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.evaluate;\n+\n+import java.util.Map;\n+\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.ast.DMNNode;\n+import org.kie.dmn.api.core.event.AfterEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.AfterInvokeBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.BeforeInvokeBKMEvent;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+\n+public class EvaluateEvent {\n+\n+    public enum Type {\n+        BEFORE_EVALUATE_ALL(true),\n+        AFTER_EVALUATE_ALL(false),\n+        BEFORE_EVALUATE_BKM(true),\n+        AFTER_EVALUATE_BKM(false),\n+        BEFORE_EVALUATE_CONTEXT_ENTRY(true),\n+        AFTER_EVALUATE_CONTEXT_ENTRY(false),\n+        BEFORE_EVALUATE_DECISION(true),\n+        AFTER_EVALUATE_DECISION(false),\n+        BEFORE_EVALUATE_DECISION_SERVICE(true),\n+        AFTER_EVALUATE_DECISION_SERVICE(false),\n+        BEFORE_EVALUATE_DECISION_TABLE(true),\n+        AFTER_EVALUATE_DECISION_TABLE(false),\n+        BEFORE_INVOKE_BKM(true),\n+        AFTER_INVOKE_BKM(false);\n+\n+        private final boolean before;\n+\n+        Type(boolean before) {\n+            this.before = before;\n+        }\n+\n+        public boolean isBefore() {\n+            return before;\n+        }\n+\n+        public boolean isAfter() {\n+            return !before;\n+        }\n+    }", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0NjkzMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437546932", "bodyText": "Done", "author": "kostola", "createdAt": "2020-06-09T16:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0MzcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NDE4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435744183", "bodyText": "Move to separated file", "author": "r00ta", "createdAt": "2020-06-05T07:41:00Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceExecutionStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+public class TraceExecutionStep {\n+\n+    public enum Type {\n+        DMN_BKM_EVALUATION,\n+        DMN_BKM_INVOCATION,\n+        DMN_CONTEXT_ENTRY,\n+        DMN_DECISION,\n+        DMN_DECISION_SERVICE,\n+        DMN_DECISION_TABLE\n+    }", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0NzA3MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437547070", "bodyText": "Done", "author": "kostola", "createdAt": "2020-06-09T16:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NDE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0OTI3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435749272", "bodyText": "I think these two properties are not enough to identify a model of a particular version. We should include the GAV and the other properties we talked about some time ago @danielezonca wdyt?", "author": "r00ta", "createdAt": "2020-06-05T07:50:49Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceModel.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import org.kie.dmn.api.core.DMNModel;\n+\n+public class TraceModel {\n+    private final String modelNamespace;\n+    private final String modelName;\n+", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2OTMxNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436069316", "bodyText": "Yes you are right, I would prefer to have:\n\nserviceName with group:artifact\nserviceVersion with version\nresourceIdentifier with name:namespace", "author": "danielezonca", "createdAt": "2020-06-05T17:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0OTI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NzgwMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438847803", "bodyText": "You have a point @r00ta. I agreed with @danielezonca to keep this part as it is for this PR and open a dedicated ticket for the suggested enhancements.", "author": "kostola", "createdAt": "2020-06-11T14:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0OTI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk4MjA1OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r439982058", "bodyText": "Ticket created: KOGITO-2439", "author": "kostola", "createdAt": "2020-06-15T07:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0OTI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTY2NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435751664", "bodyText": "Just a consideration: with this structure, the consumer of this data will have to load the DMN model and then do some magic to properly deserialize the value. For example of the type is composite, then the consumer will have to figure it out looking at the model and then use the information to deserialize the JsonNode value to a properly typed structure. Just saying that the complexity is then delegated to the consumer that will have to use the dmn model for sure", "author": "r00ta", "createdAt": "2020-06-05T07:55:38Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceInputValue.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+\n+public class TraceInputValue {\n+\n+    private final String id;\n+    private final String name;\n+    private final TraceType type;\n+    private final JsonNode value;\n+    @JsonInclude(NON_EMPTY)\n+    private final List<Message> messages;\n+\n+    public TraceInputValue(String id, String name, TraceType type, JsonNode value, List<Message> messages) {\n+        this.id = id;\n+        this.name = name;\n+        this.type = type;\n+        this.value = value;\n+        this.messages = messages;\n+    }", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4NDI2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436084263", "bodyText": "I think the consumer will have to manage a \"raw\" Json in any case because there is not java bean to use for deserialization.\nSaid that we can probably consider multiple options to enrich the value to preserve some (all?) type information.\nI know many approaches and none of them looks nice :)\nWe can probably move this topic to another ticket\n@r00ta @kostola Wdyt?", "author": "danielezonca", "createdAt": "2020-06-05T18:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcwOTQ4OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436709488", "bodyText": "There are two alternative implementations here:\n\nEvery TraceEvents contains all the explainability information so that nothing else is required to explain that evaluation to the user. This produces a lot of duplicated data because some fields (e.g. the structure of the types that we're talking about) may change only when the DMN model changes.\nTraceEvent contains only the execution values and the consumer must combine them with the DMN Model (to be retrieved somewhere else) to obtain the whole set of explainability data for the user.\n\nTo be honest I thought so far that we agreed on option 2, because a realistic production environment will generate a lot of TraceEvents and requiring the consumer to combine the event with the model structure to obtain the full explainability was a good tradeoff for using less bandwidth.\nI have no problems in adding information about the types but we should clarify which option we want to adopt.", "author": "kostola", "createdAt": "2020-06-08T13:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0ODYyNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438848624", "bodyText": "I agreed with @danielezonca to go with option 2 (the one currently implemented) because at the moment the consumer might need the DMN model anyway. We will discuss the enhancement in a dedicated ticket.", "author": "kostola", "createdAt": "2020-06-11T14:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk4MjMyOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r439982329", "bodyText": "Ticket created: KOGITO-2440", "author": "kostola", "createdAt": "2020-06-15T07:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTgzNw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435751837", "bodyText": "Same considerations for the InputValue", "author": "r00ta", "createdAt": "2020-06-05T07:55:57Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceOutputValue.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+\n+public class TraceOutputValue {\n+\n+    private final String id;\n+    private final String name;\n+    private final String status;\n+    private final TraceType type;\n+    private final JsonNode value;\n+    @JsonInclude(NON_EMPTY)\n+    private final List<Message> messages;\n+\n+    public TraceOutputValue(String id, String name, String status, TraceType type, JsonNode value, List<Message> messages) {\n+        this.id = id;\n+        this.name = name;\n+        this.status = status;\n+        this.type = type;\n+        this.value = value;\n+        this.messages = messages;\n+    }", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0OTM2OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438849369", "bodyText": "Same reply as here", "author": "kostola", "createdAt": "2020-06-11T14:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1Mjc1Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435752753", "bodyText": "I'm not sure we should be a little bit more specific here since the DMNType has a kind of implicit contract documented here https://github.com/kiegroup/drools/blob/00811849ad79a98c562adc188862f705c71859a0/kie-dmn/kie-dmn-api/src/main/java/org/kie/dmn/api/core/DMNType.java#L30 . Basically when you call dmnType.getName() you get data with different semantic if the node is usin FEEL or not", "author": "r00ta", "createdAt": "2020-06-05T07:57:45Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceType.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.dmn.api.core.DMNType;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+@JsonInclude(NON_NULL)\n+public class TraceType {\n+    private final String id;\n+    private final String namespace;\n+    private final String name;\n+\n+    public TraceType(String id, String namespace, String name) {\n+        this.id = id;\n+        this.namespace = namespace;\n+        this.name = name;\n+    }", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MDA2NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438860065", "bodyText": "To be honest I did not see any ambiguity in determining the type from those attributes, even with this semantic.", "author": "kostola", "createdAt": "2020-06-11T15:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1Mjc1Mw=="}], "type": "inlineReview"}, {"oid": "f533801625f51cfd343d8a6e19b0de00c764ab87", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f533801625f51cfd343d8a6e19b0de00c764ab87", "message": "[KOGITO-2126] Fix tests", "committedDate": "2020-06-05T12:23:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NzI4Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435857287", "bodyText": "Please use AtomicInteger instead of this custom class", "author": "danielezonca", "createdAt": "2020-06-05T11:22:39Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/DecisionTracingCollector.java", "diffHunk": "@@ -35,49 +38,84 @@\n     private static final Logger LOG = LoggerFactory.getLogger(DecisionTracingCollector.class);\n \n     private final Map<String, List<EvaluateEvent>> cacheMap;\n+    private final Map<String, Counter> openEventsCounterMap;\n     private final Aggregator<?> aggregator;\n     private final Consumer<String> payloadConsumer;\n+    private final ModelSupplier modelSupplier;\n \n-    public DecisionTracingCollector(Consumer<String> payloadConsumer) {\n-        this(new DefaultAggregator(), payloadConsumer);\n+    public DecisionTracingCollector(Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n+        this(new DefaultAggregator(), payloadConsumer, modelSupplier);\n     }\n \n-    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer) {\n-        this.payloadConsumer = payloadConsumer;\n+    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n         this.cacheMap = new HashMap<>();\n+        this.openEventsCounterMap = new HashMap<>();\n         this.aggregator = aggregator;\n+        this.payloadConsumer = payloadConsumer;\n+        this.modelSupplier = modelSupplier;\n     }\n \n     public void addEvent(EvaluateEvent event) {\n-        LOG.trace(\n-                \"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\",\n-                event.getClass().getSimpleName(),\n-                event.getExecutionId(),\n-                event.getModelName(),\n-                event.getModelNamespace()\n-        );\n+        LOG.trace(\"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\", event.getType(), event.getExecutionId(), event.getModelName(), event.getModelNamespace());\n \n         String evaluationId = event.getExecutionId();\n         if (cacheMap.containsKey(evaluationId)) {\n             cacheMap.get(evaluationId).add(event);\n+            if (event.getType().isBefore()) {\n+                openEventsCounterMap.get(evaluationId).increment();\n+            } else {\n+                openEventsCounterMap.get(evaluationId).decrement();\n+            }\n         } else {\n             List<EvaluateEvent> list = new LinkedList<>();\n             list.add(event);\n             cacheMap.put(evaluationId, list);\n+            openEventsCounterMap.put(evaluationId, new Counter(1));\n             LOG.trace(\"Added evaluation {} to cache (current size: {})\", evaluationId, cacheMap.size());\n         }\n \n-        if (event instanceof AfterEvaluateAllEvent) {\n-            String payload = aggregate(evaluationId, cacheMap.get(evaluationId));\n-            payloadConsumer.accept(payload);\n-            LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+        if (openEventsCounterMap.get(evaluationId).getValue() == 0) {\n+            Optional<DMNModel> optModel = modelSupplier.get(event.getModelNamespace(), event.getModelName());\n+\n+            if (optModel.isPresent()) {\n+                try {\n+                    String payload = aggregate(optModel.get(), evaluationId, cacheMap.get(evaluationId));\n+                    payloadConsumer.accept(payload);\n+                    LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+                } catch (AggregatorException e) {\n+                    LOG.error(\"Aggregator exception. Evaluation with id \" + evaluationId + \" will be discarded.\", e);\n+                }\n+            } else {\n+                LOG.error(\"Can't find model (namespace={}, name={}). Evaluation with id {} will be discarded.\", event.getModelNamespace(), event.getModelName(), evaluationId);\n+            }\n+\n             cacheMap.remove(evaluationId);\n             LOG.trace(\"Removed evaluation {} from cache (current size: {})\", evaluationId, cacheMap.size());\n         }\n     }\n \n-    private String aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        return Json.encode(aggregator.aggregate(evaluationId, events));\n+    private String aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        return Json.encode(aggregator.aggregate(model, evaluationId, events));\n     }\n \n+    private static class Counter {", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0NzMwOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437547309", "bodyText": "Done", "author": "kostola", "createdAt": "2020-06-09T16:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3Mzk4OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435873988", "bodyText": "This object is quite generic, I think we can move it to tracing.decision.event.common", "author": "danielezonca", "createdAt": "2020-06-05T11:59:58Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/common/Message.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.common;", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcxMDA0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436710045", "bodyText": "I'm sorry I don't get this. The class is already in tracing.decision.event.common.", "author": "kostola", "createdAt": "2020-06-08T13:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3Mzk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4NTc1OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437985759", "bodyText": "Sorry I meant tracing.event.common\nEDIT: not needed because of #544 (comment)", "author": "danielezonca", "createdAt": "2020-06-10T09:24:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3Mzk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NDE5NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435874195", "bodyText": "This object is quite generic, I think we can move it to tracing.decision.event.common", "author": "danielezonca", "createdAt": "2020-06-05T12:00:25Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/common/MessageException.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.common;", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcxMDIzMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436710232", "bodyText": "I'm sorry I don't get this. The class is already in tracing.decision.event.common.", "author": "kostola", "createdAt": "2020-06-08T13:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NDE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4NTg2NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437985864", "bodyText": "Sorry I meant tracing.event.common\nEDIT: not needed because of #544 (comment)", "author": "danielezonca", "createdAt": "2020-06-10T09:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NDE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NDYzNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435874634", "bodyText": "Can you please better explain this?", "author": "danielezonca", "createdAt": "2020-06-05T12:01:19Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/common/MessageFEELEvent.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.common;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.dmn.api.feel.runtime.events.FEELEvent;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+public class MessageFEELEvent {\n+    private final FEELEvent.Severity severity;\n+    private final String message;\n+    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = PositiveIntegerFilter.class)\n+    private final int line;\n+    @JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = PositiveIntegerFilter.class)\n+    private final int column;\n+    @JsonInclude(NON_NULL)\n+    private final MessageException sourceException;\n+\n+    public MessageFEELEvent(FEELEvent.Severity severity, String message, int line, int column, MessageException sourceException) {\n+        this.severity = severity;\n+        this.message = message;\n+        this.line = line;\n+        this.column = column;\n+        this.sourceException = sourceException;\n+    }\n+\n+    public FEELEvent.Severity getSeverity() {\n+        return severity;\n+    }\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public int getLine() {\n+        return line;\n+    }\n+\n+    public int getColumn() {\n+        return column;\n+    }\n+\n+    public MessageException getSourceException() {\n+        return sourceException;\n+    }\n+\n+    public static MessageFEELEvent from(FEELEvent feelEvent) {\n+        if (feelEvent == null) {\n+            return null;\n+        }\n+        return new MessageFEELEvent(\n+                feelEvent.getSeverity(),\n+                feelEvent.getMessage(),\n+                feelEvent.getLine(),\n+                feelEvent.getColumn(),\n+                MessageException.from(feelEvent.getSourceException())\n+        );\n+    }\n+\n+    public static class PositiveIntegerFilter {\n+        @Override\n+        public boolean equals(Object other) {\n+            // Trick required to be compliant with the Jackson Custom attribute processing", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NzM4Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438857383", "bodyText": "This is a Jackson filter that triggers serialization of a integer field only if its value is >= 0.\nI need this because line and column are plain int in the DMN FEELEvent and have a default value of -1 when not used, while 0 may indicate a meaningful data that must be exported.\nThis comment was part of a copy-paste I did at the beginning to test if the filter was correct, but now I cleaned the code up and removed it.", "author": "kostola", "createdAt": "2020-06-11T15:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NDYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkxODQ0Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438918446", "bodyText": "Sorry but it is still not clear to me: if we want don't want -1 as value can't just ignore it in the constructor?\nI would prefer to make fields Integer and then skip null during the serialization instead of use a specific feature of Jackson.", "author": "danielezonca", "createdAt": "2020-06-11T16:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NDYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEzOTA2Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440139066", "bodyText": "Your solution is cleaner. I implemented the way you suggested.", "author": "kostola", "createdAt": "2020-06-15T12:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3NDYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3ODI0NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r435878244", "bodyText": "This class is intended to be generic so please move it to tracing.event.trace and same for the related classes", "author": "danielezonca", "createdAt": "2020-06-05T12:08:59Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceEvent.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+public class TraceEvent {", "originalCommit": "5bb4ea8ce12260cf56dfeb9a21b5a794bdf62687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjcxMzIyNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436713225", "bodyText": "I kept everything under tracing.decision because this is the decision tracing addon.\nIsn't it better to move everything out when will implement a broader tracing addon that will cover other kinds of executions?", "author": "kostola", "createdAt": "2020-06-08T13:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3ODI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4NzM4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437987386", "bodyText": "Yes you are right, let's postpone this when we will do a general tracing addon", "author": "danielezonca", "createdAt": "2020-06-10T09:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3ODI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzMzYyOQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436033629", "bodyText": "This should never happen and I would consider this as a fatal error \ud83e\udd14\nIt is a completely broken state", "author": "danielezonca", "createdAt": "2020-06-05T16:32:39Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/DecisionTracingCollector.java", "diffHunk": "@@ -35,49 +38,84 @@\n     private static final Logger LOG = LoggerFactory.getLogger(DecisionTracingCollector.class);\n \n     private final Map<String, List<EvaluateEvent>> cacheMap;\n+    private final Map<String, Counter> openEventsCounterMap;\n     private final Aggregator<?> aggregator;\n     private final Consumer<String> payloadConsumer;\n+    private final ModelSupplier modelSupplier;\n \n-    public DecisionTracingCollector(Consumer<String> payloadConsumer) {\n-        this(new DefaultAggregator(), payloadConsumer);\n+    public DecisionTracingCollector(Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n+        this(new DefaultAggregator(), payloadConsumer, modelSupplier);\n     }\n \n-    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer) {\n-        this.payloadConsumer = payloadConsumer;\n+    public DecisionTracingCollector(Aggregator<?> aggregator, Consumer<String> payloadConsumer, ModelSupplier modelSupplier) {\n         this.cacheMap = new HashMap<>();\n+        this.openEventsCounterMap = new HashMap<>();\n         this.aggregator = aggregator;\n+        this.payloadConsumer = payloadConsumer;\n+        this.modelSupplier = modelSupplier;\n     }\n \n     public void addEvent(EvaluateEvent event) {\n-        LOG.trace(\n-                \"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\",\n-                event.getClass().getSimpleName(),\n-                event.getExecutionId(),\n-                event.getModelName(),\n-                event.getModelNamespace()\n-        );\n+        LOG.trace(\"Received {}(evaluationId: {}, modelName: {}, modelNamespace: {})\", event.getType(), event.getExecutionId(), event.getModelName(), event.getModelNamespace());\n \n         String evaluationId = event.getExecutionId();\n         if (cacheMap.containsKey(evaluationId)) {\n             cacheMap.get(evaluationId).add(event);\n+            if (event.getType().isBefore()) {\n+                openEventsCounterMap.get(evaluationId).increment();\n+            } else {\n+                openEventsCounterMap.get(evaluationId).decrement();\n+            }\n         } else {\n             List<EvaluateEvent> list = new LinkedList<>();\n             list.add(event);\n             cacheMap.put(evaluationId, list);\n+            openEventsCounterMap.put(evaluationId, new Counter(1));\n             LOG.trace(\"Added evaluation {} to cache (current size: {})\", evaluationId, cacheMap.size());\n         }\n \n-        if (event instanceof AfterEvaluateAllEvent) {\n-            String payload = aggregate(evaluationId, cacheMap.get(evaluationId));\n-            payloadConsumer.accept(payload);\n-            LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+        if (openEventsCounterMap.get(evaluationId).getValue() == 0) {\n+            Optional<DMNModel> optModel = modelSupplier.get(event.getModelNamespace(), event.getModelName());\n+\n+            if (optModel.isPresent()) {\n+                try {\n+                    String payload = aggregate(optModel.get(), evaluationId, cacheMap.get(evaluationId));\n+                    payloadConsumer.accept(payload);\n+                    LOG.debug(\"Generated aggregated event for evaluation {} (length {})\", evaluationId, payload.length());\n+                } catch (AggregatorException e) {\n+                    LOG.error(\"Aggregator exception. Evaluation with id \" + evaluationId + \" will be discarded.\", e);\n+                }\n+            } else {\n+                LOG.error(\"Can't find model (namespace={}, name={}). Evaluation with id {} will be discarded.\", event.getModelNamespace(), event.getModelName(), evaluationId);", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxNjc5NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438016794", "bodyText": "I removed this part. Now the collector generates a TraceEvent even if the model is null.", "author": "kostola", "createdAt": "2020-06-10T10:17:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzMzYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNjk1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436036955", "bodyText": "I think this class should be removed as concept itself: aggregation happens in parallel and we should never generate an expected error but define a default strategy to preserve data and proceed.", "author": "danielezonca", "createdAt": "2020-06-05T16:39:14Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/AggregatorException.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.aggregator;\n+\n+public class AggregatorException extends RuntimeException {", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxNzU3Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438017572", "bodyText": "I agree with your comment: I refactored all the aggregation error management to implement some fallback strategies that generate partial TraceEvents and removed AggregatorException.", "author": "kostola", "createdAt": "2020-06-10T10:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNjk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0MjM2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436042360", "bodyText": "This is not possible because here last event is added to the list.\nI don't think we can be too defensive in this code because we cannot really \"expect\" or manage an unexpected situation: model could be null too, same for evaluationId, you cannot neither trust of events.get(0) to be not null (accept or not null elements is an implementation detail of the List itself).", "author": "danielezonca", "createdAt": "2020-06-05T16:49:59Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MzMzOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438853338", "bodyText": "I removed this part", "author": "kostola", "createdAt": "2020-06-11T15:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0MjM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0OTQ0NA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436049444", "bodyText": "Can this really happen? The only reason I see for this is when the engine is broken so I got an AfterEvaluateAllEvent alone. If this is the case it is already too late so it is useless to \"manage\" this :)", "author": "danielezonca", "createdAt": "2020-06-05T17:04:10Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxNzc4MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438017781", "bodyText": "I removed this part (see #544 (comment))", "author": "kostola", "createdAt": "2020-06-10T10:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0OTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MjkyNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436052926", "bodyText": "Again, this can only happen if the engine is broken :)\nBtw I think we can consider TraceExecutionStep as some sort of optional so if it is not possible to create all of them we should return partial steps (if possible) or none of them but not skip the whole execution", "author": "danielezonca", "createdAt": "2020-06-05T17:11:28Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxODI4Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438018282", "bodyText": "I removed this part (see #544 (comment))", "author": "kostola", "createdAt": "2020-06-10T10:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MjkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MzQ1OA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436053458", "bodyText": "Same comment as above, it is better to loose some TraceExecutionStep instead of skip the whole execution", "author": "danielezonca", "createdAt": "2020-06-05T17:12:35Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxODQxNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438018415", "bodyText": "I removed this part (see #544 (comment))", "author": "kostola", "createdAt": "2020-06-10T10:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1MzQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1Mzg2Mg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436053862", "bodyText": "Please create ticket (or tickets) with the missing logic (same for all the others TODOs)", "author": "danielezonca", "createdAt": "2020-06-05T17:13:28Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");\n+    }\n+\n+    private static TraceExecutionStep buildDmnBkmEvaluationTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        // TODO: implement complete construction of TraceExecutionStep", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MzY4OQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438853689", "bodyText": "I removed all the TODOs because now the structure is good enough for this version.", "author": "kostola", "createdAt": "2020-06-11T15:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1Mzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NzQ3MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436057470", "bodyText": "I think the whole isBefore/isAfter logic could (should?) be moved directly to DMN events.\nSame for event Type enum (or equivalent mechanims). Wdyt?\n@tarilabs FYI, wdyt?\nDMNEvent is a generic interface but the list of events that the engine can fire is hardcoded so we can probably add an abstraction in the middle like DMNRuntimeEvent with Type, isBefore and isAfter that extends DMNEvent and that all runtime events has to use", "author": "danielezonca", "createdAt": "2020-06-05T17:20:46Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/evaluate/EvaluateEvent.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.evaluate;\n+\n+import java.util.Map;\n+\n+import org.kie.dmn.api.core.DMNResult;\n+import org.kie.dmn.api.core.ast.DMNNode;\n+import org.kie.dmn.api.core.event.AfterEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.AfterInvokeBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.BeforeInvokeBKMEvent;\n+import org.kie.kogito.decision.DecisionExecutionIdUtils;\n+\n+public class EvaluateEvent {\n+\n+    public enum Type {\n+        BEFORE_EVALUATE_ALL(true),\n+        AFTER_EVALUATE_ALL(false),\n+        BEFORE_EVALUATE_BKM(true),\n+        AFTER_EVALUATE_BKM(false),\n+        BEFORE_EVALUATE_CONTEXT_ENTRY(true),\n+        AFTER_EVALUATE_CONTEXT_ENTRY(false),\n+        BEFORE_EVALUATE_DECISION(true),\n+        AFTER_EVALUATE_DECISION(false),\n+        BEFORE_EVALUATE_DECISION_SERVICE(true),\n+        AFTER_EVALUATE_DECISION_SERVICE(false),\n+        BEFORE_EVALUATE_DECISION_TABLE(true),\n+        AFTER_EVALUATE_DECISION_TABLE(false),\n+        BEFORE_INVOKE_BKM(true),\n+        AFTER_INVOKE_BKM(false);\n+\n+        private final boolean before;\n+\n+        Type(boolean before) {\n+            this.before = before;\n+        }\n+\n+        public boolean isBefore() {\n+            return before;\n+        }\n+\n+        public boolean isAfter() {\n+            return !before;\n+        }", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUyMzIzNg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436523236", "bodyText": "isn't this a bit over-engineering? I mean yes the classes follow the convention of having in the name After/Before and relate to some decision logic, but the order within a decision logic is fixed, while the total ordering depends on which API call to DMNRuntime was invoked.", "author": "tarilabs", "createdAt": "2020-06-08T08:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NzQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MTI3Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438851273", "bodyText": "EvaluateEvents are used only internally in the addon. We can keep this as it is for now and discuss enhancement of the DMN engine in a dedicated ticket if necessary.", "author": "kostola", "createdAt": "2020-06-11T15:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NzQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2MjA1Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436062053", "bodyText": "I would like not to have a so strict relation with DMN internals, what about a simple String? Do we use this Type to obtain some specific logic?", "author": "danielezonca", "createdAt": "2020-06-05T17:29:51Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceExecutionStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+public class TraceExecutionStep {\n+\n+    public enum Type {\n+        DMN_BKM_EVALUATION,\n+        DMN_BKM_INVOCATION,\n+        DMN_CONTEXT_ENTRY,\n+        DMN_DECISION,\n+        DMN_DECISION_SERVICE,\n+        DMN_DECISION_TABLE", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MjcwNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r438852704", "bodyText": "At this moment yes, it's used during aggregation logic. Since TraceEvents are serialized as JSON and sent to Kafka, we can change this field to String afterwards if we realize that the enum is too strict.", "author": "kostola", "createdAt": "2020-06-11T15:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2MjA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2Mzc0Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436063743", "bodyText": "Again too defensive both for the initial if and then with the Optional result :)", "author": "danielezonca", "createdAt": "2020-06-05T17:32:53Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/modelsupplier/ApplicationModelSupplier.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.modelsupplier;\n+\n+import java.util.Optional;\n+\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.kogito.Application;\n+import org.kie.kogito.decision.DecisionModel;\n+\n+public class ApplicationModelSupplier implements ModelSupplier {\n+\n+    private final Application application;\n+\n+    public ApplicationModelSupplier(Application application) {\n+        this.application = application;\n+    }\n+\n+    @Override\n+    public Optional<DMNModel> get(String namespace, String name) {\n+        if (namespace == null || name == null) {\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(application)\n+                .map(Application::decisionModels)\n+                .map(dm -> dm.getDecisionModel(namespace, name))\n+                .map(DecisionModel::getDMNModel);\n+    }", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0ODEwNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437548105", "bodyText": "I simplified this logic now", "author": "kostola", "createdAt": "2020-06-09T16:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2Mzc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2NDcyMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436064723", "bodyText": "What do you have against BiFunction? :)", "author": "danielezonca", "createdAt": "2020-06-05T17:33:56Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/modelsupplier/ModelSupplier.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.modelsupplier;\n+\n+import java.util.Optional;\n+\n+import org.kie.dmn.api.core.DMNModel;\n+\n+@FunctionalInterface\n+public interface ModelSupplier {", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0ODM4Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437548386", "bodyText": "Removed ModelSupplier and using BiFunction now instead \ud83d\ude09", "author": "kostola", "createdAt": "2020-06-09T16:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2NDcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2NTgyMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r436065820", "bodyText": "What's the reason of this change? And why a SingleThreadExecutor?\nIf it is needed what about Quakus?", "author": "danielezonca", "createdAt": "2020-06-05T17:36:04Z", "path": "addons/tracing/tracing-decision-springboot-addon/src/main/java/org/kie/kogito/tracing/decision/SpringBootDecisionTracingConfiguration.java", "diffHunk": "@@ -91,4 +93,8 @@ public NewTopic newTopic() {\n         return new KafkaTemplate<>(producerFactory());\n     }\n \n+    @Bean(name = \"kogitoTracingDecisionAddonTaskExecutor\")\n+    public Executor threadPoolTaskExecutor() {\n+        return Executors.newSingleThreadExecutor(r -> new Thread(r, \"kogito-tracing\"));\n+    }", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzNjQ2MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437236460", "bodyText": "What is the purpose of empty public constructor? Can we remove it?", "author": "jiripetrlik", "createdAt": "2020-06-09T08:41:22Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/AggregatorException.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.aggregator;\n+\n+public class AggregatorException extends RuntimeException {\n+\n+    public AggregatorException() {", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0ODgxMw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437548813", "bodyText": "It was purposeless in fact and now I removed the whole class \ud83d\ude09", "author": "kostola", "createdAt": "2020-06-09T16:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzNjQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzNzc2Mw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437237763", "bodyText": "Can you be more specific in description? For example \"Unknown stack entry type: type\". Or if you plan to not throw exception as @danielezonca suggested, please log proper warning message.", "author": "jiripetrlik", "createdAt": "2020-06-09T08:43:24Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,234 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceModel;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String evaluationId, List<EvaluateEvent> events) {\n+        if (events == null) {\n+            throw new AggregatorException(\"Event list is null\");\n+        }\n+        if (events.size() < 2) {\n+            throw new AggregatorException(\"Event list contains less than 2 elements\");\n+        }\n+\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        // header\n+        TraceHeader header = new TraceHeader(\n+                TraceEvent.Type.DMN,\n+                evaluationId,\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceModel.from(model),\n+                lastEvent.getResult().getMessages().stream()\n+                        .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                        .collect(Collectors.toList())\n+        );\n+\n+        // inputs\n+        List<TraceInputValue> inputs = model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+\n+        // outputs\n+        List<TraceOutputValue> outputs = lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+\n+        // execution steps\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Stack<DefaultAggregatorStackEntry> stack = new Stack<>();\n+        for (int i = 1; i < events.size() - 1; i++) {\n+            EvaluateEvent event = events.get(i);\n+            LOG.trace(\"Started aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+            if (event.getType().isBefore()) {\n+                stack.push(new DefaultAggregatorStackEntry(event));\n+            } else {\n+                if (stack.isEmpty() || !stack.peek().isValidAfterEvent(event)) {\n+                    throw new AggregatorException(String.format(\"Can't match %s \\\"after\\\" event with corresponding \\\"before\\\" event\", event.getType()));\n+                }\n+                DefaultAggregatorStackEntry stackEntry = stack.pop();\n+                TraceExecutionStep step = buildTraceExecutionStep(model, stackEntry, event);\n+                if (stack.isEmpty()) {\n+                    executionSteps.add(step);\n+                } else {\n+                    stack.peek().addChild(step);\n+                }\n+            }\n+            LOG.trace(\"Finished aggregating event {} (execution steps: {}, stack size: {})\", event.getType(), executionSteps.size(), stack.size());\n+        }\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionSteps);\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n                 .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+                .withSource(URI.create(URLEncoder.encode(lastEvent.getModelName(), StandardCharsets.UTF_8)))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static TraceExecutionStep buildTraceExecutionStep(DMNModel model, DefaultAggregatorStackEntry stackEntry, EvaluateEvent afterEvent) {\n+        switch (stackEntry.getType()) {\n+            case DMN_BKM_EVALUATION:\n+                return buildDmnBkmEvaluationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_BKM_INVOCATION:\n+                return buildDmnBkmInvocationTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_CONTEXT_ENTRY:\n+                return buildDmnContextEntryTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION:\n+                return buildDmnDecisionTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_SERVICE:\n+                return buildDmnDecisionServiceTraceExecutionStep(model, stackEntry, afterEvent);\n+            case DMN_DECISION_TABLE:\n+                return buildDmnDecisionTableTraceExecutionStep(model, stackEntry, afterEvent);\n+        }\n+        // this should never happen\n+        throw new AggregatorException(\"Can't build trace execution step\");", "originalCommit": "f533801625f51cfd343d8a6e19b0de00c764ab87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0ODk5Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r437548997", "bodyText": "No more AggregatorExceptions", "author": "kostola", "createdAt": "2020-06-09T16:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzNzc2Mw=="}], "type": "inlineReview"}, {"oid": "6c1a9cede43df9c3546115491f8a511e43ed563b", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6c1a9cede43df9c3546115491f8a511e43ed563b", "message": "[KOGITO-2126] Best effort aggregation", "committedDate": "2020-06-09T16:01:55Z", "type": "forcePushed"}, {"oid": "c7a6c1e525995db11b6fcac731ef26a034c49176", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c7a6c1e525995db11b6fcac731ef26a034c49176", "message": "[KOGITO-2126] Expand tracing-decision-common tests", "committedDate": "2020-06-10T10:14:42Z", "type": "forcePushed"}, {"oid": "f9f5150751cba0494bdca859f6f488c657f2fa71", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f9f5150751cba0494bdca859f6f488c657f2fa71", "message": "[KOGITO-2126] Add TerminationDetector", "committedDate": "2020-06-11T09:17:31Z", "type": "forcePushed"}, {"oid": "296fa692b36eb3b7ad3dfdd27e16b1ad99884454", "url": "https://github.com/kiegroup/kogito-runtimes/commit/296fa692b36eb3b7ad3dfdd27e16b1ad99884454", "message": "[KOGITO-2126] Add EvaluateEventTypeTest", "committedDate": "2020-06-11T12:08:00Z", "type": "forcePushed"}, {"oid": "3e6e2063a341c625137f1ce4c2bb0d25fc68ef47", "url": "https://github.com/kiegroup/kogito-runtimes/commit/3e6e2063a341c625137f1ce4c2bb0d25fc68ef47", "message": "[KOGITO-2126] Improve resourceId and source in decision service evaluations", "committedDate": "2020-06-11T16:03:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NDExMg==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r439974112", "bodyText": "null is better?", "author": "r00ta", "createdAt": "2020-06-15T07:17:45Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,339 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.dmn.core.ast.DecisionServiceNodeImpl;\n+import org.kie.dmn.feel.util.Pair;\n+import org.kie.kogito.tracing.decision.event.common.InternalMessageType;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStepType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceResourceId;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.AFTER_EVALUATE_DECISION_SERVICE;\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE;\n+\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n-                .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        return events == null || events.isEmpty()\n+                ? buildNotEnoughDataCloudEvent(model, executionId)\n+                : buildDefaultCloudEvent(model, executionId, events);\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildNotEnoughDataCloudEvent(DMNModel model, String executionId) {\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                0L,\n+                0L,\n+                0L,", "originalCommit": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzMzgxMQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440333811", "bodyText": "Changed to null", "author": "kostola", "createdAt": "2020-06-15T17:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NDExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjA0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r439976045", "bodyText": "firstEvent.getTimestamp() and lastEvent.getTimestamp() return the timestamp in milliseconds, but the duration is stored as nanoseconds. I think the three properties should have the same unit of measurement", "author": "r00ta", "createdAt": "2020-06-15T07:21:50Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,339 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.dmn.core.ast.DecisionServiceNodeImpl;\n+import org.kie.dmn.feel.util.Pair;\n+import org.kie.kogito.tracing.decision.event.common.InternalMessageType;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStepType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceResourceId;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.AFTER_EVALUATE_DECISION_SERVICE;\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE;\n+\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n-                .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        return events == null || events.isEmpty()\n+                ? buildNotEnoughDataCloudEvent(model, executionId)\n+                : buildDefaultCloudEvent(model, executionId, events);\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildNotEnoughDataCloudEvent(DMNModel model, String executionId) {\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                0L,\n+                0L,\n+                0L,\n+                TraceResourceId.from(model),\n+                Stream.of(\n+                        Message.from(InternalMessageType.NOT_ENOUGH_DATA),\n+                        model == null ? Message.from(InternalMessageType.DMN_MODEL_NOT_FOUND) : null\n+                ).filter(Objects::nonNull).collect(Collectors.toList())\n+        );\n+\n+        TraceEvent event = new TraceEvent(header, Collections.emptyList(), Collections.emptyList(), Collections.emptyList());\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n+                .withId(executionId)\n+                .withSource(URI.create(URLEncoder.encode(\"__UNKNOWN_SOURCE__\", StandardCharsets.UTF_8)))\n+                .withData(event)\n+                .build();\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildDefaultCloudEvent(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        List<TraceInputValue> inputs = buildTraceInputValues(model, firstEvent);\n+\n+        List<TraceOutputValue> outputs = buildTraceOutputValues(model, lastEvent);\n+\n+        Pair<List<TraceExecutionStep>, List<Message>> executionStepsPair = buildTraceExecutionSteps(model, executionId, events);\n+\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                firstEvent.getTimestamp(),\n+                lastEvent.getTimestamp(),\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),", "originalCommit": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzMDQ0NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440330445", "bodyText": "Duration is in nanosecond because I am using System.nanoTime() to compute elapsed time and System.currentTimeMillis() to obtain a specific timestamp, as explained in this Stack Overflow answer and in the JavaDoc of the two methods I linked in their names.\nI am fine with uniforming the unit of measurement, but I'd like to read also @danielezonca 's opinion.", "author": "kostola", "createdAt": "2020-06-15T17:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYyOTczOA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440629738", "bodyText": "In any case, I think it's better to document the measurement unit we are going to use for each property in the javadoc of that class", "author": "r00ta", "createdAt": "2020-06-16T07:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3Njg1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440676855", "bodyText": "I agree with @r00ta that we should have the same unit of measurement.\nI don't think we need nanotime precision so we can use nanotime to calculate the elapsed and then convert it to millis.\n@kostola\nWdyt?", "author": "danielezonca", "createdAt": "2020-06-16T08:28:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4OTQ1MA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440689450", "bodyText": "The clarity of using the same unit of measurement is probably more useful than the nanosecond precision. I will change this asap.", "author": "kostola", "createdAt": "2020-06-16T08:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcyNjE2Nw==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440726167", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2020-06-16T09:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NzY2MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r439977661", "bodyText": "Why does it start from 1?", "author": "r00ta", "createdAt": "2020-06-15T07:25:11Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/aggregator/DefaultAggregator.java", "diffHunk": "@@ -19,31 +19,339 @@\n import java.net.URI;\n import java.net.URLEncoder;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import com.fasterxml.jackson.databind.JsonNode;\n+import io.cloudevents.json.Json;\n import io.cloudevents.v1.CloudEventBuilder;\n import io.cloudevents.v1.CloudEventImpl;\n-import org.kie.kogito.tracing.decision.event.AfterEvaluateAllEvent;\n-import org.kie.kogito.tracing.decision.event.EvaluateEvent;\n+import org.kie.dmn.api.core.DMNModel;\n+import org.kie.dmn.api.core.ast.DecisionNode;\n+import org.kie.dmn.api.core.ast.InputDataNode;\n+import org.kie.dmn.core.ast.DecisionServiceNodeImpl;\n+import org.kie.dmn.feel.util.Pair;\n+import org.kie.kogito.tracing.decision.event.common.InternalMessageType;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateDecisionResult;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEvent;\n+import org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEvent;\n+import org.kie.kogito.tracing.decision.event.trace.TraceEventType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStep;\n+import org.kie.kogito.tracing.decision.event.trace.TraceExecutionStepType;\n+import org.kie.kogito.tracing.decision.event.trace.TraceHeader;\n+import org.kie.kogito.tracing.decision.event.trace.TraceInputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceOutputValue;\n+import org.kie.kogito.tracing.decision.event.trace.TraceResourceId;\n+import org.kie.kogito.tracing.decision.event.trace.TraceType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-public class DefaultAggregator implements Aggregator<AfterEvaluateAllEvent> {\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.AFTER_EVALUATE_DECISION_SERVICE;\n+import static org.kie.kogito.tracing.decision.event.evaluate.EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE;\n+\n+public class DefaultAggregator implements Aggregator<TraceEvent> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultAggregator.class);\n \n     @Override\n-    public CloudEventImpl<AfterEvaluateAllEvent> aggregate(String evaluationId, List<EvaluateEvent> events) {\n-        AfterEvaluateAllEvent event = Optional.ofNullable(events)\n-                .filter(l -> !l.isEmpty())\n-                .map(l -> l.get(l.size() - 1))\n-                .filter(AfterEvaluateAllEvent.class::isInstance)\n-                .map(AfterEvaluateAllEvent.class::cast)\n-                .orElseThrow(() -> new IllegalStateException(\"Invalid event list\"));\n-\n-        return CloudEventBuilder.<AfterEvaluateAllEvent>builder()\n-                .withType(AfterEvaluateAllEvent.class.getName())\n-                .withId(evaluationId)\n-                .withSource(URI.create(URLEncoder.encode(event.getModelName(), StandardCharsets.UTF_8)))\n+    public CloudEventImpl<TraceEvent> aggregate(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        return events == null || events.isEmpty()\n+                ? buildNotEnoughDataCloudEvent(model, executionId)\n+                : buildDefaultCloudEvent(model, executionId, events);\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildNotEnoughDataCloudEvent(DMNModel model, String executionId) {\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                0L,\n+                0L,\n+                0L,\n+                TraceResourceId.from(model),\n+                Stream.of(\n+                        Message.from(InternalMessageType.NOT_ENOUGH_DATA),\n+                        model == null ? Message.from(InternalMessageType.DMN_MODEL_NOT_FOUND) : null\n+                ).filter(Objects::nonNull).collect(Collectors.toList())\n+        );\n+\n+        TraceEvent event = new TraceEvent(header, Collections.emptyList(), Collections.emptyList(), Collections.emptyList());\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n+                .withId(executionId)\n+                .withSource(URI.create(URLEncoder.encode(\"__UNKNOWN_SOURCE__\", StandardCharsets.UTF_8)))\n+                .withData(event)\n+                .build();\n+    }\n+\n+    private static CloudEventImpl<TraceEvent> buildDefaultCloudEvent(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        EvaluateEvent firstEvent = events.get(0);\n+        EvaluateEvent lastEvent = events.get(events.size() - 1);\n+\n+        List<TraceInputValue> inputs = buildTraceInputValues(model, firstEvent);\n+\n+        List<TraceOutputValue> outputs = buildTraceOutputValues(model, lastEvent);\n+\n+        Pair<List<TraceExecutionStep>, List<Message>> executionStepsPair = buildTraceExecutionSteps(model, executionId, events);\n+\n+        TraceHeader header = new TraceHeader(\n+                TraceEventType.DMN,\n+                executionId,\n+                firstEvent.getTimestamp(),\n+                lastEvent.getTimestamp(),\n+                lastEvent.getNanoTime() - firstEvent.getNanoTime(),\n+                TraceResourceId.from(firstEvent),\n+                Stream.of(\n+                        model == null ? Stream.of(Message.from(InternalMessageType.DMN_MODEL_NOT_FOUND)) : Stream.<Message>empty(),\n+                        executionStepsPair.getRight().stream(),\n+                        lastEvent.getResult().getMessages().stream()\n+                                .filter(m -> m.getSourceId() == null || m.getSourceId().isBlank())\n+                ).flatMap(Function.identity()).collect(Collectors.toList())\n+        );\n+\n+        // complete event\n+        TraceEvent event = new TraceEvent(header, inputs, outputs, executionStepsPair.getLeft());\n+\n+        return CloudEventBuilder.<TraceEvent>builder()\n+                .withType(TraceEvent.class.getName())\n+                .withId(executionId)\n+                .withSource(buildSource(firstEvent))\n                 .withData(event)\n                 .build();\n     }\n \n+    private static URI buildSource(EvaluateEvent event) {\n+        return event.getType() == BEFORE_EVALUATE_DECISION_SERVICE || event.getType() == AFTER_EVALUATE_DECISION_SERVICE\n+               ? URI.create(String.format(\"%s/%s\", urlEncode(event.getModelName()), urlEncode(event.getNodeName())))\n+               : URI.create(urlEncode(event.getModelName()));\n+    }\n+\n+    private static List<TraceInputValue> buildTraceInputValues(DMNModel model, EvaluateEvent firstEvent) {\n+        if (model == null) {\n+            return firstEvent.getContext().entrySet().stream()\n+                    .map(DefaultAggregator::traceInputFrom)\n+                    .collect(Collectors.toList());\n+        }\n+        if (firstEvent.getType() == EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE) {\n+            // cast to DecisionServiceNodeImpl here is required to have access to getInputParameters method\n+            Optional<DecisionServiceNodeImpl> optNode = model.getDecisionServices().stream()\n+                    .filter(ds -> ds.getId().equals(firstEvent.getNodeId()))\n+                    .findFirst()\n+                    .filter(DecisionServiceNodeImpl.class::isInstance)\n+                    .map(DecisionServiceNodeImpl.class::cast);\n+\n+            if (optNode.isPresent()) {\n+                return optNode.get().getInputParameters().values().stream()\n+                        .filter(InputDataNode.class::isInstance)\n+                        .map(InputDataNode.class::cast)\n+                        .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                        .collect(Collectors.toList());\n+            }\n+        }\n+        return model.getInputs().stream()\n+                .map(i -> traceInputFrom(i, firstEvent.getContext()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static List<TraceOutputValue> buildTraceOutputValues(DMNModel model, EvaluateEvent lastEvent) {\n+        return lastEvent.getResult().getDecisionResults().stream()\n+                .map(dr -> traceOutputFrom(dr, model))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static Pair<List<TraceExecutionStep>, List<Message>> buildTraceExecutionSteps(DMNModel model, String executionId, List<EvaluateEvent> events) {\n+        try {\n+            return new Pair<>(buildTraceExecutionStepsHierarchy(model, events), Collections.emptyList());\n+        } catch (IllegalStateException e) {\n+            LOG.error(String.format(\"IllegalStateException during aggregation of evaluation %s\", executionId), e);\n+            return new Pair<>(buildTraceExecutionStepsList(model, events), List.of(Message.from(InternalMessageType.NO_EXECUTION_STEP_HIERARCHY, e)));\n+        }\n+    }\n+\n+    private static List<TraceExecutionStep> buildTraceExecutionStepsHierarchy(DMNModel model, List<EvaluateEvent> events) {\n+        List<TraceExecutionStep> executionSteps = new ArrayList<>(events.size() / 2);\n+        Deque<DefaultAggregatorStackEntry> stack = new ArrayDeque<>(events.size() / 2);\n+        for (int i = 1; i < events.size() - 1; i++) {", "originalCommit": "c7dbf2b2cecf8779a27c913db8e4c1050eed8e2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNjMwNQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440326305", "bodyText": "Because the first and last event determine the type of evaluation (evaluateAll or evaluateDecisionService) and the information they contain are already present in the input and output section, so there's no need in my opinion to create a redundant execution step object. What do you think?", "author": "kostola", "createdAt": "2020-06-15T17:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NzY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYyNzUwMA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440627500", "bodyText": "Since in the other methods there are some checks for the order of the events (for example line 209 of this class), I just wonder if it's possible that there is something wrong with the first event of the list and there are no checks for it. wdyt?", "author": "r00ta", "createdAt": "2020-06-16T07:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NzY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2Mjk3MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r440662971", "bodyText": "I did not put too many checks in the first and last event because I assume the first to be the least probable to fail and the last is somehow checked with both the implemented termination detectors (even if the \"counter\" one doesn't check the event type).\nI also implemented several tests in DefaultAggregatorTest that make sure that a TraceEvent is generated by the aggregator even with incomplete information. It works also when receiving only the first event (which is not possible by the current implementation of the collector, but ensures a higher level of resiliency).\nI think the checks are enough for this first implementation and we should not be too defensive (as @danielezonca suggested here). We can add more checks if we find some corner cases while using our addon in real scenarios.", "author": "kostola", "createdAt": "2020-06-16T08:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NzY2MQ=="}], "type": "inlineReview"}, {"oid": "b68b61c1da8b3f6b1b84f942378d31b0a126c5b9", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b68b61c1da8b3f6b1b84f942378d31b0a126c5b9", "message": "[KOGITO-2126] Remove PositiveIntegerFilter in MessageFEELEvent", "committedDate": "2020-06-15T12:24:26Z", "type": "forcePushed"}, {"oid": "51f48178e1f3947fb5aac7d8d585c9123b85d0f3", "url": "https://github.com/kiegroup/kogito-runtimes/commit/51f48178e1f3947fb5aac7d8d585c9123b85d0f3", "message": "[KOGITO-2126] duration is now in milliseconds instead of nanoseconds", "committedDate": "2020-06-16T09:46:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzODI5Ng==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r441338296", "bodyText": "Can you please add a check to verify that DMNRuntimeEventListener doesn't contain other/additional methods?\nSame for EvaluateEventType.\nThe goal of this test is to understand if something is changing so we should cover:\n\nexisting event changes -> already covered\nadditional event not managed -> to cover\nadditional type EvaluateEventType to match -> to cover", "author": "danielezonca", "createdAt": "2020-06-17T07:30:35Z", "path": "addons/tracing/tracing-decision-common/src/test/java/org/kie/kogito/tracing/decision/event/evaluate/EvaluateEventTypeTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.evaluate;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.event.AfterEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.AfterEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.AfterInvokeBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateAllEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateBKMEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateContextEntryEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionServiceEvent;\n+import org.kie.dmn.api.core.event.BeforeEvaluateDecisionTableEvent;\n+import org.kie.dmn.api.core.event.BeforeInvokeBKMEvent;\n+import org.kie.dmn.api.core.event.DMNEvent;\n+import org.kie.dmn.api.core.event.DMNRuntimeEventListener;\n+import org.kie.dmn.feel.util.Pair;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The purpose of this test is ensure that the structure of {@link DMNRuntimeEventListener} remains\n+ * aligned with our {@link EvaluateEventType} enum that maps {@link DMNEvent} to {@link EvaluateEvent}.\n+ */\n+class EvaluateEventTypeTest {\n+\n+    private static final Map<EvaluateEventType, Pair<String, Class<?>>> CHECK_MAP = new HashMap<>() {{\n+        put(EvaluateEventType.BEFORE_EVALUATE_ALL, new Pair<>(\"beforeEvaluateAll\", BeforeEvaluateAllEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_ALL, new Pair<>(\"afterEvaluateAll\", AfterEvaluateAllEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_BKM, new Pair<>(\"beforeEvaluateBKM\", BeforeEvaluateBKMEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_BKM, new Pair<>(\"afterEvaluateBKM\", AfterEvaluateBKMEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_CONTEXT_ENTRY, new Pair<>(\"beforeEvaluateContextEntry\", BeforeEvaluateContextEntryEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_CONTEXT_ENTRY, new Pair<>(\"afterEvaluateContextEntry\", AfterEvaluateContextEntryEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_DECISION, new Pair<>(\"beforeEvaluateDecision\", BeforeEvaluateDecisionEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_DECISION, new Pair<>(\"afterEvaluateDecision\", AfterEvaluateDecisionEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_DECISION_SERVICE, new Pair<>(\"beforeEvaluateDecisionService\", BeforeEvaluateDecisionServiceEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_DECISION_SERVICE, new Pair<>(\"afterEvaluateDecisionService\", AfterEvaluateDecisionServiceEvent.class));\n+        put(EvaluateEventType.BEFORE_EVALUATE_DECISION_TABLE, new Pair<>(\"beforeEvaluateDecisionTable\", BeforeEvaluateDecisionTableEvent.class));\n+        put(EvaluateEventType.AFTER_EVALUATE_DECISION_TABLE, new Pair<>(\"afterEvaluateDecisionTable\", AfterEvaluateDecisionTableEvent.class));\n+        put(EvaluateEventType.BEFORE_INVOKE_BKM, new Pair<>(\"beforeInvokeBKM\", BeforeInvokeBKMEvent.class));\n+        put(EvaluateEventType.AFTER_INVOKE_BKM, new Pair<>(\"afterInvokeBKM\", AfterInvokeBKMEvent.class));\n+    }};\n+\n+    @Test\n+    void test() {\n+        for (EvaluateEventType t : EvaluateEventType.values()) {\n+            assertTrue(CHECK_MAP.containsKey(t), () -> String.format(\"Missing test entry for %s\", t));\n+        }\n+\n+        Class<DMNRuntimeEventListener> listenerClass = DMNRuntimeEventListener.class;\n+        CHECK_MAP.forEach((type, checkPair) ->\n+                assertDoesNotThrow(\n+                        () -> listenerClass.getDeclaredMethod(checkPair.getLeft(), checkPair.getRight()),\n+                        () -> String.format(\"Method %s(%s) not found for EvaluateEventType.%s\", checkPair.getLeft(), checkPair.getRight().getSimpleName(), type)\n+                )\n+        );\n+    }\n+}", "originalCommit": "51f48178e1f3947fb5aac7d8d585c9123b85d0f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQxODA1NQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r441418055", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2020-06-17T09:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzODI5Ng=="}], "type": "inlineReview"}, {"oid": "0d2c2661fe5855170388ae16842540233ec5a8ba", "url": "https://github.com/kiegroup/kogito-runtimes/commit/0d2c2661fe5855170388ae16842540233ec5a8ba", "message": "[KOGITO-2126] Expand EvaluateEventTypeTest", "committedDate": "2020-06-17T09:30:52Z", "type": "forcePushed"}, {"oid": "900ecd22a22b154b35d4600f304285eb6b06b245", "url": "https://github.com/kiegroup/kogito-runtimes/commit/900ecd22a22b154b35d4600f304285eb6b06b245", "message": "[KOGITO-2126] Expand EvaluateEventTypeTest", "committedDate": "2020-06-18T08:53:17Z", "type": "forcePushed"}, {"oid": "16527d1da3d70c2850e3333324bee2021b0c9d58", "url": "https://github.com/kiegroup/kogito-runtimes/commit/16527d1da3d70c2850e3333324bee2021b0c9d58", "message": "[KOGITO-2126] Implement decision tracing addon with TraceEvent", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "1234816f179aa6570ece266eefa62c4d3e6fcb64", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1234816f179aa6570ece266eefa62c4d3e6fcb64", "message": "[KOGITO-2126] Fix tests", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "f057659dba296802ad6002bf428484e920af7391", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f057659dba296802ad6002bf428484e920af7391", "message": "[KOGITO-2126] Improvements and fixes for code smells", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "1265e48e3d42ed53a08bc10bb62567a497dc5619", "url": "https://github.com/kiegroup/kogito-runtimes/commit/1265e48e3d42ed53a08bc10bb62567a497dc5619", "message": "[KOGITO-2126] Best effort aggregation", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "8ad1687febebb609140f2319d9059dbef9ce4c0a", "url": "https://github.com/kiegroup/kogito-runtimes/commit/8ad1687febebb609140f2319d9059dbef9ce4c0a", "message": "[KOGITO-2126] Expand tracing-decision-common tests", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "17f8dc2ee24f8e32acdf3a29150559a9c528bcac", "url": "https://github.com/kiegroup/kogito-runtimes/commit/17f8dc2ee24f8e32acdf3a29150559a9c528bcac", "message": "[KOGITO-2126] Expand testing of evaluateDecisionService", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "fee37c872d26bb3212122c908ce8abf3a3785bca", "url": "https://github.com/kiegroup/kogito-runtimes/commit/fee37c872d26bb3212122c908ce8abf3a3785bca", "message": "[KOGITO-2126] Add TerminationDetector", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "831d420c311702c86f4f1d7ae0636993046fb3aa", "url": "https://github.com/kiegroup/kogito-runtimes/commit/831d420c311702c86f4f1d7ae0636993046fb3aa", "message": "[KOGITO-2126] Add EvaluateEventTypeTest", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "b73caea635feb998ac31ee3053e67eb18bf6d1dc", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b73caea635feb998ac31ee3053e67eb18bf6d1dc", "message": "[KOGITO-2126] Add start and end timestamps to TraceHeader", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "4523b2f1400555dd92b3d9f6c6ca97d0be2b8d85", "url": "https://github.com/kiegroup/kogito-runtimes/commit/4523b2f1400555dd92b3d9f6c6ca97d0be2b8d85", "message": "[KOGITO-2126] Update json test resources with timestamps", "committedDate": "2020-06-19T09:24:14Z", "type": "commit"}, {"oid": "b2bcd5fa6077722b632dab0dd70b75bc7cfae509", "url": "https://github.com/kiegroup/kogito-runtimes/commit/b2bcd5fa6077722b632dab0dd70b75bc7cfae509", "message": "[KOGITO-2126] Improve resourceId and source in decision service evaluations", "committedDate": "2020-06-19T09:24:15Z", "type": "commit"}, {"oid": "556c2b5c02b14bedba1636ed17eb123f4be8ddcc", "url": "https://github.com/kiegroup/kogito-runtimes/commit/556c2b5c02b14bedba1636ed17eb123f4be8ddcc", "message": "[KOGITO-2126] Add missing getters to TraceResourceId", "committedDate": "2020-06-19T09:24:15Z", "type": "commit"}, {"oid": "404f536bf43d04c876b25e81afd8baa7d4ccde68", "url": "https://github.com/kiegroup/kogito-runtimes/commit/404f536bf43d04c876b25e81afd8baa7d4ccde68", "message": "[KOGITO-2126] Remove PositiveIntegerFilter in MessageFEELEvent", "committedDate": "2020-06-19T09:24:15Z", "type": "commit"}, {"oid": "4cbe74196d10840902d48182a59e8cf9b83b86ce", "url": "https://github.com/kiegroup/kogito-runtimes/commit/4cbe74196d10840902d48182a59e8cf9b83b86ce", "message": "[KOGITO-2126] Use null to indicate missing values for startTs, endTs and duration in TraceHeader", "committedDate": "2020-06-19T09:24:15Z", "type": "commit"}, {"oid": "6aff6964b6f22180d183d36362221aba8f4bf032", "url": "https://github.com/kiegroup/kogito-runtimes/commit/6aff6964b6f22180d183d36362221aba8f4bf032", "message": "[KOGITO-2126] Reduce code smells", "committedDate": "2020-06-19T09:24:15Z", "type": "commit"}, {"oid": "f75501d3bb5c4ce13d668a276304cd115998b1a0", "url": "https://github.com/kiegroup/kogito-runtimes/commit/f75501d3bb5c4ce13d668a276304cd115998b1a0", "message": "[KOGITO-2126] duration is now in milliseconds instead of nanoseconds", "committedDate": "2020-06-19T09:24:15Z", "type": "commit"}, {"oid": "63f32e37647a7cf9ec942ba794821c1976a0a30d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/63f32e37647a7cf9ec942ba794821c1976a0a30d", "message": "[KOGITO-2126] Expand EvaluateEventTypeTest", "committedDate": "2020-06-19T09:24:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNzA3MQ==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r442817071", "bodyText": "Could you review a bit this logic? If an execution is really fast, it might be that the duration is 0. I mean, if the consumer sets it to 0 then it should remain 0 and not null", "author": "r00ta", "createdAt": "2020-06-19T12:41:15Z", "path": "addons/tracing/tracing-decision-common/src/main/java/org/kie/kogito/tracing/decision/event/trace/TraceHeader.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ *  Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.kie.kogito.tracing.decision.event.trace;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import org.kie.kogito.tracing.decision.event.common.Message;\n+\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_EMPTY;\n+import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;\n+\n+public class TraceHeader {\n+\n+    private final TraceEventType type;\n+    private final String executionId;\n+    @JsonInclude(NON_NULL)\n+    private final Long startTimestamp;\n+    @JsonInclude(NON_NULL)\n+    private final Long endTimestamp;\n+    @JsonInclude(NON_NULL)\n+    private final Long duration;\n+    private final TraceResourceId resourceId;\n+    @JsonInclude(NON_EMPTY)\n+    private final List<Message> messages;\n+\n+    public TraceHeader(TraceEventType type, String executionId, Long startTs, Long endTs, Long duration, TraceResourceId resourceId, List<Message> messages) {\n+        this.type = type;\n+        this.executionId = executionId;\n+        this.startTimestamp = startTs == null || startTs <= 0 ? null : startTs;\n+        this.endTimestamp = endTs == null || endTs <= 0 ? null : endTs;\n+        this.duration = duration == null || duration <= 0 ? null : duration;", "originalCommit": "900ecd22a22b154b35d4600f304285eb6b06b245", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzMzIxNA==", "url": "https://github.com/kiegroup/kogito-runtimes/pull/544#discussion_r442833214", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2020-06-19T13:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNzA3MQ=="}], "type": "inlineReview"}, {"oid": "c32561c6681dd9edca576f1943e1517876ba247d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c32561c6681dd9edca576f1943e1517876ba247d", "message": "[KOGITO-2126] Allow zero duration in TraceHeader", "committedDate": "2020-06-19T13:12:49Z", "type": "commit"}, {"oid": "c32561c6681dd9edca576f1943e1517876ba247d", "url": "https://github.com/kiegroup/kogito-runtimes/commit/c32561c6681dd9edca576f1943e1517876ba247d", "message": "[KOGITO-2126] Allow zero duration in TraceHeader", "committedDate": "2020-06-19T13:12:49Z", "type": "forcePushed"}]}