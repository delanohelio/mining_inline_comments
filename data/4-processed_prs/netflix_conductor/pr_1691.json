{"pr_number": 1691, "pr_title": "Added multiple features in a specification ForkJoinSpec to verify the\u2026", "pr_createdAt": "2020-05-19T17:40:33Z", "pr_url": "https://github.com/Netflix/conductor/pull/1691", "timeline": [{"oid": "1477c32bb512e28376306f774951d89f9da70b69", "url": "https://github.com/Netflix/conductor/commit/1477c32bb512e28376306f774951d89f9da70b69", "message": "Added multiple features in a specification ForkJoinSpec to verify the fork join behavior", "committedDate": "2020-05-19T17:38:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3MjY1OA==", "url": "https://github.com/Netflix/conductor/pull/1691#discussion_r427772658", "bodyText": "Please add license header.", "author": "apanicker-nflx", "createdAt": "2020-05-20T06:37:06Z", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/ForkJoinSpec.groovy", "diffHunk": "@@ -0,0 +1,874 @@\n+package com.netflix.counductor.integration.test", "originalCommit": "1477c32bb512e28376306f774951d89f9da70b69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3MzU3Ng==", "url": "https://github.com/Netflix/conductor/pull/1691#discussion_r427773576", "bodyText": "I believe this was done to maintain consistency with the existing JUnit tests, but this spec does not use/need modification of retry counts, so this could be removed.", "author": "apanicker-nflx", "createdAt": "2020-05-20T06:39:23Z", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/ForkJoinSpec.groovy", "diffHunk": "@@ -0,0 +1,874 @@\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.archaius.guice.ArchaiusModule\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.core.execution.tasks.SubWorkflow\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Shared\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class, ArchaiusModule.class])\n+class ForkJoinSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Shared\n+    def FORK_JOIN_WF = 'FanInOutTest'\n+\n+    @Shared\n+    def FORK_JOIN_NESTED_WF = 'FanInOutNestedTest'\n+\n+    @Shared\n+    def FORK_JOIN_NESTED_SUB_WF = 'FanInOutNestedSubWorkflowTest'\n+\n+    @Shared\n+    def WORKFLOW_FORK_JOIN_OPTIONAL_SW = \"integration_test_fork_join_optional_sw\"\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows('fork_join_integration_test.json',\n+                'fork_join_with_no_task_retry_integration_test.json',\n+                'nested_fork_join_integration_test.json',\n+                'simple_workflow_1_integration_test.json',\n+                'nested_fork_join_with_sub_workflow_integration_test.json',\n+                'simple_one_task_sub_workflow_integration_test.json',\n+                'fork_join_with_optional_sub_workflow_forks_integration_test.json'\n+        )\n+    }\n+\n+    /**\n+     *               start\n+     *                 |\n+     *               fork\n+     *              /    \\\n+     *         task1     task2\n+     *          \\        /\n+     *          task3   /\n+     *           \\     /\n+     *            \\  /\n+     *            join\n+     *              |\n+     *             task4\n+     *              |\n+     *             End\n+     */\n+    def \"Test a simple workflow with fork join success flow\"() {\n+        setup: \"Ensure that all the tasks involved in the workflow have a retry count of 0\"", "originalCommit": "1477c32bb512e28376306f774951d89f9da70b69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE0ODExNg==", "url": "https://github.com/Netflix/conductor/pull/1691#discussion_r428148116", "bodyText": "This was done before using the fork_join_workflow_without_retryable_tasks , this test can be changed to use a different workflow and the setup and cleanup are not needed.", "author": "pctreddy", "createdAt": "2020-05-20T16:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3MzU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NDI1Mg==", "url": "https://github.com/Netflix/conductor/pull/1691#discussion_r427774252", "bodyText": "restarting -> retrying", "author": "apanicker-nflx", "createdAt": "2020-05-20T06:40:56Z", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/ForkJoinSpec.groovy", "diffHunk": "@@ -0,0 +1,874 @@\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.archaius.guice.ArchaiusModule\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.core.execution.tasks.SubWorkflow\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Shared\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class, ArchaiusModule.class])\n+class ForkJoinSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Shared\n+    def FORK_JOIN_WF = 'FanInOutTest'\n+\n+    @Shared\n+    def FORK_JOIN_NESTED_WF = 'FanInOutNestedTest'\n+\n+    @Shared\n+    def FORK_JOIN_NESTED_SUB_WF = 'FanInOutNestedSubWorkflowTest'\n+\n+    @Shared\n+    def WORKFLOW_FORK_JOIN_OPTIONAL_SW = \"integration_test_fork_join_optional_sw\"\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows('fork_join_integration_test.json',\n+                'fork_join_with_no_task_retry_integration_test.json',\n+                'nested_fork_join_integration_test.json',\n+                'simple_workflow_1_integration_test.json',\n+                'nested_fork_join_with_sub_workflow_integration_test.json',\n+                'simple_one_task_sub_workflow_integration_test.json',\n+                'fork_join_with_optional_sub_workflow_forks_integration_test.json'\n+        )\n+    }\n+\n+    /**\n+     *               start\n+     *                 |\n+     *               fork\n+     *              /    \\\n+     *         task1     task2\n+     *          \\        /\n+     *          task3   /\n+     *           \\     /\n+     *            \\  /\n+     *            join\n+     *              |\n+     *             task4\n+     *              |\n+     *             End\n+     */\n+    def \"Test a simple workflow with fork join success flow\"() {\n+        setup: \"Ensure that all the tasks involved in the workflow have a retry count of 0\"\n+        def persistedIntegrationTask1Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_1').get()\n+        def modifiedIntegrationTask1Definition = new TaskDef(persistedIntegrationTask1Definition.name,\n+                persistedIntegrationTask1Definition.description, 0, 0)\n+        def persistedIntegrationTask2Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_2').get()\n+        def modifiedIntegrationTask2Definition = new TaskDef(persistedIntegrationTask2Definition.name,\n+                persistedIntegrationTask2Definition.description, 0, 0)\n+        def persistedIntegrationTask3Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_3').get()\n+        def modifiedIntegrationTask3Definition = new TaskDef(persistedIntegrationTask3Definition.name,\n+                persistedIntegrationTask3Definition.description, 0, 0)\n+        def persistedIntegrationTask4Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_4').get()\n+        def modifiedIntegrationTask4Definition = new TaskDef(persistedIntegrationTask4Definition.name,\n+                persistedIntegrationTask4Definition.description, 0, 0)\n+\n+        metadataService.updateTaskDef(modifiedIntegrationTask1Definition)\n+        metadataService.updateTaskDef(modifiedIntegrationTask2Definition)\n+        metadataService.updateTaskDef(modifiedIntegrationTask3Definition)\n+        metadataService.updateTaskDef(modifiedIntegrationTask4Definition)\n+\n+        when: \"A fork join workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(FORK_JOIN_WF, 1,\n+                'fanoutTest', [:],\n+                null, null, null)\n+\n+        then: \"verify that the workflow has started and the starting nodes of the each fork are in scheduled state\"\n+        workflowInstanceId\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 4\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.SCHEDULED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+        }\n+\n+        when: \"The first task of the fork is polled and completed\"\n+        def polledAndAckTask1Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_1', 'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_1' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask1Try1)\n+\n+        and: \"The workflow has been updated and has all the required tasks in the right status to move forward\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 5\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.SCHEDULED\n+            tasks[4].taskType == 'integration_task_3'\n+        }\n+\n+        when: \"The 'integration_task_3' is polled and completed\"\n+        def polledAndAckTask3Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_3',\n+                'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_3' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask3Try1)\n+\n+        and: \"The workflow has been updated with the task status and task list\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 5\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.COMPLETED\n+            tasks[4].taskType == 'integration_task_3'\n+        }\n+\n+        when: \"The other node of the fork is completed by completing 'integration_task_2'\"\n+        def polledAndAckTask2Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_2',\n+                'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_2' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask2Try1)\n+\n+        and: \"The workflow has been updated with the task status and task list\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 6\n+            tasks[2].status == Task.Status.COMPLETED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.COMPLETED\n+            tasks[3].taskType == 'JOIN'\n+            tasks[5].status == Task.Status.SCHEDULED\n+            tasks[5].taskType == 'integration_task_4'\n+        }\n+\n+        when: \"The last task of the workflow is then polled and completed integration_task_4'\"\n+        def polledAndAckTask4Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_4',\n+                'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_4' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask4Try1)\n+\n+        and: \"Then verify that the workflow is completed\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.COMPLETED\n+            tasks.size() == 6\n+            tasks[5].status == Task.Status.COMPLETED\n+            tasks[5].taskType == 'integration_task_4'\n+        }\n+\n+        cleanup: \"Restore the task definitions that were modified as part of this feature testing\"\n+        metadataService.updateTaskDef(persistedIntegrationTask1Definition)\n+        metadataService.updateTaskDef(persistedIntegrationTask2Definition)\n+        metadataService.updateTaskDef(persistedIntegrationTask3Definition)\n+        metadataService.updateTaskDef(persistedIntegrationTask4Definition)\n+    }\n+\n+\n+    def \"Test a simple workflow with fork join failure flow\"() {\n+        setup: \"Ensure that 'integration_task_2' has a retry count of 0\"\n+        def persistedIntegrationTask2Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_2').get()\n+        def modifiedIntegrationTask2Definition = new TaskDef(persistedIntegrationTask2Definition.name,\n+                persistedIntegrationTask2Definition.description, 0, 0)\n+        metadataService.updateTaskDef(modifiedIntegrationTask2Definition)\n+\n+        when: \"A fork join workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(FORK_JOIN_WF, 1,\n+                'fanoutTest', [:],\n+                null, null, null)\n+\n+        then: \"verify that the workflow has started and the starting nodes of the each fork are in scheduled state\"\n+        workflowInstanceId\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 4\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.SCHEDULED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+        }\n+\n+        when: \"The first task of the fork is polled and completed\"\n+        def polledAndAckTask1Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_1', 'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_1' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask1Try1)\n+\n+        and: \"The workflow has been updated and has all the required tasks in the right status to move forward\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 5\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.SCHEDULED\n+            tasks[4].taskType == 'integration_task_3'\n+        }\n+\n+        when: \"The other node of the fork is completed by completing 'integration_task_2'\"\n+        def polledAndAckTask2Try1 = workflowTestUtil.pollAndFailTask('integration_task_2',\n+                'task1.worker', 'Failed....', 0)\n+\n+        then: \"verify that the 'integration_task_2' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask2Try1)\n+\n+        and: \"the workflow is in the failed state\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.FAILED\n+            tasks.size() == 5\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.FAILED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.CANCELED\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.CANCELED\n+            tasks[4].taskType == 'integration_task_3'\n+        }\n+\n+        cleanup: \"Restore the task definitions that were modified as part of this feature testing\"\n+        metadataService.updateTaskDef(persistedIntegrationTask2Definition)\n+    }\n+\n+    def \"Test restarting a failed fork join workflow\"() {", "originalCommit": "1477c32bb512e28376306f774951d89f9da70b69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc3NTI5Nw==", "url": "https://github.com/Netflix/conductor/pull/1691#discussion_r427775297", "bodyText": "restarted -> retried", "author": "apanicker-nflx", "createdAt": "2020-05-20T06:43:24Z", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/ForkJoinSpec.groovy", "diffHunk": "@@ -0,0 +1,874 @@\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.archaius.guice.ArchaiusModule\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.core.execution.tasks.SubWorkflow\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Shared\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class, ArchaiusModule.class])\n+class ForkJoinSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Shared\n+    def FORK_JOIN_WF = 'FanInOutTest'\n+\n+    @Shared\n+    def FORK_JOIN_NESTED_WF = 'FanInOutNestedTest'\n+\n+    @Shared\n+    def FORK_JOIN_NESTED_SUB_WF = 'FanInOutNestedSubWorkflowTest'\n+\n+    @Shared\n+    def WORKFLOW_FORK_JOIN_OPTIONAL_SW = \"integration_test_fork_join_optional_sw\"\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows('fork_join_integration_test.json',\n+                'fork_join_with_no_task_retry_integration_test.json',\n+                'nested_fork_join_integration_test.json',\n+                'simple_workflow_1_integration_test.json',\n+                'nested_fork_join_with_sub_workflow_integration_test.json',\n+                'simple_one_task_sub_workflow_integration_test.json',\n+                'fork_join_with_optional_sub_workflow_forks_integration_test.json'\n+        )\n+    }\n+\n+    /**\n+     *               start\n+     *                 |\n+     *               fork\n+     *              /    \\\n+     *         task1     task2\n+     *          \\        /\n+     *          task3   /\n+     *           \\     /\n+     *            \\  /\n+     *            join\n+     *              |\n+     *             task4\n+     *              |\n+     *             End\n+     */\n+    def \"Test a simple workflow with fork join success flow\"() {\n+        setup: \"Ensure that all the tasks involved in the workflow have a retry count of 0\"\n+        def persistedIntegrationTask1Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_1').get()\n+        def modifiedIntegrationTask1Definition = new TaskDef(persistedIntegrationTask1Definition.name,\n+                persistedIntegrationTask1Definition.description, 0, 0)\n+        def persistedIntegrationTask2Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_2').get()\n+        def modifiedIntegrationTask2Definition = new TaskDef(persistedIntegrationTask2Definition.name,\n+                persistedIntegrationTask2Definition.description, 0, 0)\n+        def persistedIntegrationTask3Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_3').get()\n+        def modifiedIntegrationTask3Definition = new TaskDef(persistedIntegrationTask3Definition.name,\n+                persistedIntegrationTask3Definition.description, 0, 0)\n+        def persistedIntegrationTask4Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_4').get()\n+        def modifiedIntegrationTask4Definition = new TaskDef(persistedIntegrationTask4Definition.name,\n+                persistedIntegrationTask4Definition.description, 0, 0)\n+\n+        metadataService.updateTaskDef(modifiedIntegrationTask1Definition)\n+        metadataService.updateTaskDef(modifiedIntegrationTask2Definition)\n+        metadataService.updateTaskDef(modifiedIntegrationTask3Definition)\n+        metadataService.updateTaskDef(modifiedIntegrationTask4Definition)\n+\n+        when: \"A fork join workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(FORK_JOIN_WF, 1,\n+                'fanoutTest', [:],\n+                null, null, null)\n+\n+        then: \"verify that the workflow has started and the starting nodes of the each fork are in scheduled state\"\n+        workflowInstanceId\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 4\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.SCHEDULED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+        }\n+\n+        when: \"The first task of the fork is polled and completed\"\n+        def polledAndAckTask1Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_1', 'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_1' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask1Try1)\n+\n+        and: \"The workflow has been updated and has all the required tasks in the right status to move forward\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 5\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.SCHEDULED\n+            tasks[4].taskType == 'integration_task_3'\n+        }\n+\n+        when: \"The 'integration_task_3' is polled and completed\"\n+        def polledAndAckTask3Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_3',\n+                'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_3' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask3Try1)\n+\n+        and: \"The workflow has been updated with the task status and task list\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 5\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.COMPLETED\n+            tasks[4].taskType == 'integration_task_3'\n+        }\n+\n+        when: \"The other node of the fork is completed by completing 'integration_task_2'\"\n+        def polledAndAckTask2Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_2',\n+                'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_2' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask2Try1)\n+\n+        and: \"The workflow has been updated with the task status and task list\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 6\n+            tasks[2].status == Task.Status.COMPLETED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.COMPLETED\n+            tasks[3].taskType == 'JOIN'\n+            tasks[5].status == Task.Status.SCHEDULED\n+            tasks[5].taskType == 'integration_task_4'\n+        }\n+\n+        when: \"The last task of the workflow is then polled and completed integration_task_4'\"\n+        def polledAndAckTask4Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_4',\n+                'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_4' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask4Try1)\n+\n+        and: \"Then verify that the workflow is completed\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.COMPLETED\n+            tasks.size() == 6\n+            tasks[5].status == Task.Status.COMPLETED\n+            tasks[5].taskType == 'integration_task_4'\n+        }\n+\n+        cleanup: \"Restore the task definitions that were modified as part of this feature testing\"\n+        metadataService.updateTaskDef(persistedIntegrationTask1Definition)\n+        metadataService.updateTaskDef(persistedIntegrationTask2Definition)\n+        metadataService.updateTaskDef(persistedIntegrationTask3Definition)\n+        metadataService.updateTaskDef(persistedIntegrationTask4Definition)\n+    }\n+\n+\n+    def \"Test a simple workflow with fork join failure flow\"() {\n+        setup: \"Ensure that 'integration_task_2' has a retry count of 0\"\n+        def persistedIntegrationTask2Definition = workflowTestUtil.getPersistedTaskDefinition('integration_task_2').get()\n+        def modifiedIntegrationTask2Definition = new TaskDef(persistedIntegrationTask2Definition.name,\n+                persistedIntegrationTask2Definition.description, 0, 0)\n+        metadataService.updateTaskDef(modifiedIntegrationTask2Definition)\n+\n+        when: \"A fork join workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(FORK_JOIN_WF, 1,\n+                'fanoutTest', [:],\n+                null, null, null)\n+\n+        then: \"verify that the workflow has started and the starting nodes of the each fork are in scheduled state\"\n+        workflowInstanceId\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 4\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.SCHEDULED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+        }\n+\n+        when: \"The first task of the fork is polled and completed\"\n+        def polledAndAckTask1Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_1', 'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_1' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask1Try1)\n+\n+        and: \"The workflow has been updated and has all the required tasks in the right status to move forward\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 5\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.SCHEDULED\n+            tasks[4].taskType == 'integration_task_3'\n+        }\n+\n+        when: \"The other node of the fork is completed by completing 'integration_task_2'\"\n+        def polledAndAckTask2Try1 = workflowTestUtil.pollAndFailTask('integration_task_2',\n+                'task1.worker', 'Failed....', 0)\n+\n+        then: \"verify that the 'integration_task_2' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask2Try1)\n+\n+        and: \"the workflow is in the failed state\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.FAILED\n+            tasks.size() == 5\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'integration_task_1'\n+            tasks[2].status == Task.Status.FAILED\n+            tasks[2].taskType == 'integration_task_2'\n+            tasks[3].status == Task.Status.CANCELED\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.CANCELED\n+            tasks[4].taskType == 'integration_task_3'\n+        }\n+\n+        cleanup: \"Restore the task definitions that were modified as part of this feature testing\"\n+        metadataService.updateTaskDef(persistedIntegrationTask2Definition)\n+    }\n+\n+    def \"Test restarting a failed fork join workflow\"() {\n+\n+        when: \"A fork join workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(FORK_JOIN_WF + '_2', 1,\n+                'fanoutTest', [:],\n+                null, null, null)\n+\n+        then: \"verify that the workflow has started and the starting nodes of the each fork are in scheduled state\"\n+        workflowInstanceId\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 4\n+            tasks[0].status == Task.Status.COMPLETED\n+            tasks[0].taskType == 'FORK'\n+            tasks[1].status == Task.Status.SCHEDULED\n+            tasks[1].taskType == 'integration_task_0_RT_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_0_RT_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+        }\n+\n+        when: \"The first task of the fork is polled and completed\"\n+        def polledAndAckTask1Try1 = workflowTestUtil.pollAndCompleteTask('integration_task_0_RT_1', 'task1.worker', [:], 0)\n+\n+        then: \"verify that the 'integration_task_0_RT_1' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask1Try1)\n+\n+        and: \"The workflow has been updated and has all the required tasks in the right status to move forward\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 5\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'integration_task_0_RT_1'\n+            tasks[2].status == Task.Status.SCHEDULED\n+            tasks[2].taskType == 'integration_task_0_RT_2'\n+            tasks[3].status == Task.Status.IN_PROGRESS\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.SCHEDULED\n+            tasks[4].taskType == 'integration_task_0_RT_3'\n+        }\n+\n+        when: \"The other node of the fork is completed by completing 'integration_task_0_RT_2'\"\n+        def polledAndAckTask2Try1 = workflowTestUtil.pollAndFailTask('integration_task_0_RT_2',\n+                'task1.worker', 'Failed....', 0)\n+\n+        then: \"verify that the 'integration_task_0_RT_1' was polled and acknowledged\"\n+        workflowTestUtil.verifyPolledAndAcknowledgedTask([:], polledAndAckTask2Try1)\n+\n+        and: \"the workflow is in the failed state\"\n+        with(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.FAILED\n+            tasks.size() == 5\n+            tasks[1].status == Task.Status.COMPLETED\n+            tasks[1].taskType == 'integration_task_0_RT_1'\n+            tasks[2].status == Task.Status.FAILED\n+            tasks[2].taskType == 'integration_task_0_RT_2'\n+            tasks[3].status == Task.Status.CANCELED\n+            tasks[3].taskType == 'JOIN'\n+            tasks[4].status == Task.Status.CANCELED\n+            tasks[4].taskType == 'integration_task_0_RT_3'\n+        }\n+\n+        when: \"The workflow is retried\"\n+        workflowExecutor.retry(workflowInstanceId)\n+\n+        then: \"verify that all the workflow is restarted and new tasks are added in place of the failed tasks\"", "originalCommit": "1477c32bb512e28376306f774951d89f9da70b69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "87b9ce4c05844ab78e9259c96a25ed51f7234610", "url": "https://github.com/Netflix/conductor/commit/87b9ce4c05844ab78e9259c96a25ed51f7234610", "message": "Code review clean up", "committedDate": "2020-05-20T17:06:58Z", "type": "commit"}]}