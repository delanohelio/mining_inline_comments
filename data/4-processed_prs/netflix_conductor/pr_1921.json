{"pr_number": 1921, "pr_title": "Adding resiliency tests and relevant changes for QueueDAO.", "pr_createdAt": "2020-10-12T23:17:40Z", "pr_url": "https://github.com/Netflix/conductor/pull/1921", "timeline": [{"oid": "f836543e736241e70b28bc37e5edcbf47cfee916", "url": "https://github.com/Netflix/conductor/commit/f836543e736241e70b28bc37e5edcbf47cfee916", "message": "Adding resiliency tests and relevant changes for QueueDAO.", "committedDate": "2020-10-12T23:15:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY1ODE2Mg==", "url": "https://github.com/Netflix/conductor/pull/1921#discussion_r503658162", "bodyText": "Nice", "author": "apanicker-nflx", "createdAt": "2020-10-13T04:20:05Z", "path": "jersey/src/main/java/com/netflix/conductor/server/resources/TaskResource.java", "diffHunk": "@@ -187,6 +187,7 @@ public void removeTaskFromQueue(@PathParam(\"taskType\") String taskType,\n \t\treturn taskService.getAllPollData();\n \t}\n \n+\t@Deprecated", "originalCommit": "f836543e736241e70b28bc37e5edcbf47cfee916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMDcxNg==", "url": "https://github.com/Netflix/conductor/pull/1921#discussion_r504120716", "bodyText": "I am not convinced that a try...catch block here is the right way to address this. The exception when terminating a workflow should be caught at a granular level within the terminate logic and this should be logged/handled accordingly.", "author": "apanicker-nflx", "createdAt": "2020-10-13T17:07:32Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -514,7 +514,23 @@ public void rewind(String workflowId, boolean useLatestDefinitions) {\n         workflow.setStatus(WorkflowStatus.RUNNING);\n         workflow.setOutput(null);\n         workflow.setExternalOutputPayloadStoragePath(null);\n-        executionDAOFacade.createWorkflow(workflow);\n+\n+        try {\n+            executionDAOFacade.createWorkflow(workflow);\n+        } catch (Exception e) {\n+            Monitors.recordWorkflowStartError(workflowDef.getName(), WorkflowContext.get().getClientApp());\n+            LOGGER.error(\"Unable to restart workflow: {}\", workflowDef.getName(), e);\n+\n+            // It's possible the terminate workflow call hits an exception as well, in that case we want to log both\n+            // errors to help diagnosis.\n+            try {\n+                terminateWorkflow(workflowId, \"Error when restarting the workflow\");", "originalCommit": "f836543e736241e70b28bc37e5edcbf47cfee916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIwNzE5Nw==", "url": "https://github.com/Netflix/conductor/pull/1921#discussion_r504207197", "bodyText": "This exception is primarily for executionDAOFacade.createWorkflow(workflow), and terminateWorkflow is just a clean up as part of that exception. I'd still like to throw the exception for createWorkflow, irrespective of what happened with terminateWorkflow, while logging terminateWorkflow exception. Thoughts?", "author": "kishorebanala", "createdAt": "2020-10-13T19:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMDcxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIxNjE4Mg==", "url": "https://github.com/Netflix/conductor/pull/1921#discussion_r504216182", "bodyText": "Yes, the exception handling for createWorkflow needs to be handled.\nMy comment is regarding the extended handling for the terminate part which seems out of place here. Something like this -\ntry {\n    executionDAOFacade.createWorkflow(workflow);\n} catch (Exception e) {\n    Monitors.recordWorkflowStartError(workflowDef.getName(), WorkflowContext.get().getClientApp());\n    LOGGER.error(\"Unable to restart workflow: {}\", workflowDef.getName(), e);\n    terminateWorkflow(workflowId, \"Error when restarting the workflow\");\n    throw e;\n}", "author": "apanicker-nflx", "createdAt": "2020-10-13T19:52:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEyMDcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNjA5OQ==", "url": "https://github.com/Netflix/conductor/pull/1921#discussion_r504136099", "bodyText": "Please add license header.", "author": "apanicker-nflx", "createdAt": "2020-10-13T17:33:01Z", "path": "test-harness/src/test/groovy/com/netflix/conductor/test/resiliency/QueueResiliencySpec.groovy", "diffHunk": "@@ -0,0 +1,557 @@\n+package com.netflix.conductor.test.resiliency", "originalCommit": "f836543e736241e70b28bc37e5edcbf47cfee916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzODI4NA==", "url": "https://github.com/Netflix/conductor/pull/1921#discussion_r504138284", "bodyText": "Do you want to add another test case for updateTask with IN_PROGRESS state?\nThis case only covers the updateTask with COMPLETED state, which does not directly use the queue, but the former uses queue to postpone.", "author": "apanicker-nflx", "createdAt": "2020-10-13T17:37:05Z", "path": "test-harness/src/test/groovy/com/netflix/conductor/test/resiliency/QueueResiliencySpec.groovy", "diffHunk": "@@ -0,0 +1,557 @@\n+package com.netflix.conductor.test.resiliency\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskResult\n+import com.netflix.conductor.common.metadata.workflow.RerunWorkflowRequest\n+import com.netflix.conductor.common.metadata.workflow.StartWorkflowRequest\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.core.execution.ApplicationException\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.server.resources.TaskResource\n+import com.netflix.conductor.server.resources.WorkflowResource\n+import com.netflix.conductor.test.util.MockQueueDAOModule\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import spock.guice.UseModules\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+/**\n+ * When QueueDAO is unavailable,\n+ * Ensure All Worklow and Task resource endpoints either:\n+ * 1. Fails and/or throws an Exception\n+ * 2. Succeeds\n+ * 3. Doesn't involve QueueDAO\n+ */\n+@UseModules(MockQueueDAOModule)\n+class QueueResiliencySpec extends Specification {\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    @Inject\n+    WorkflowResource workflowResource\n+\n+    @Inject\n+    TaskResource taskResource\n+\n+    def SIMPLE_TWO_TASK_WORKFLOW = 'integration_test_wf'\n+\n+    def setup() {\n+        workflowTestUtil.taskDefinitions()\n+        workflowTestUtil.registerWorkflows(\n+                'simple_workflow_1_integration_test.json'\n+        )\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    /// Workflow Resource endpoints\n+\n+    def \"Verify Start workflow fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def response = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow starts when there are no Queue failures\"\n+        response\n+\n+        when: \"We try same request Queue failure\"\n+        response = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify that workflow start fails with BACKEND_ERROR\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        thrown(ApplicationException)\n+    }\n+\n+    def \"Verify terminate succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We terminate it when QueueDAO is unavailable\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that terminate is successful without any exceptions\"\n+        1 * queueDAO.remove(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue remove failed from Spy\") }\n+        0 * queueDAO._\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+    }\n+\n+    def \"Verify Restart workflow fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        and: \"We terminate it when QueueDAO is unavailable\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that workflow is in terminated state\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+\n+        when: \"We restart workflow when QueueDAO is unavailable\"\n+        workflowResource.restart(workflowInstanceId, false)\n+\n+        then: \"\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        1 * queueDAO.remove(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue remove failed from Spy\") }\n+        0 * queueDAO._\n+        thrown(ApplicationException)\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 0\n+        }\n+    }\n+\n+    def \"Verify rerun fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        and: \"terminate it\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that workflow is in terminated state\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+\n+        when: \"Workflow is rerun when QueueDAO is unavailable\"\n+        def rerunWorkflowRequest = new RerunWorkflowRequest()\n+        rerunWorkflowRequest.setReRunFromWorkflowId(workflowInstanceId)\n+        workflowResource.rerun(workflowInstanceId, rerunWorkflowRequest)\n+\n+        then: \"\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        0 * queueDAO._\n+        thrown(ApplicationException)\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 0\n+        }\n+    }\n+\n+    def \"Verify retry fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        and: \"terminate it\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that workflow is in terminated state\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+\n+        when: \"workflow is restarted when QueueDAO is unavailable\"\n+        workflowResource.retry(workflowInstanceId)\n+\n+        then: \"Verify retry fails\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        0 * queueDAO._\n+        thrown(ApplicationException)\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+    }\n+\n+    def \"Verify getWorkflow succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We get a workflow when QueueDAO is unavailable\"\n+        def workflow = workflowResource.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify workflow is returned\"\n+        0 * queueDAO._\n+        workflow.getStatus() == Workflow.WorkflowStatus.RUNNING\n+        workflow.getTasks().size() == 1\n+        workflow.getTasks()[0].status == Task.Status.SCHEDULED\n+    }\n+\n+    def \"Verify getWorkflows succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We get a workflow when QueueDAO is unavailable\"\n+        def workflows = workflowResource.getWorkflows(SIMPLE_TWO_TASK_WORKFLOW, \"\", true, true)\n+\n+        then: \"Verify queueDAO is not involved and an exception is not thrown\"\n+        0 * queueDAO._\n+        notThrown(Exception)\n+    }\n+\n+    def \"Verify remove workflow succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We get a workflow when QueueDAO is unavailable\"\n+        workflowResource.delete(workflowInstanceId, false)\n+\n+        then: \"Verify queueDAO is not involved\"\n+        0 * queueDAO._\n+\n+        when: \"We try to get deleted workflow\"\n+        workflowResource.getExecutionStatus(workflowInstanceId, true)\n+\n+        then:\n+        thrown(ApplicationException)\n+    }\n+\n+    def \"Verify decide succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We decide a workflow\"\n+        workflowResource.decide(workflowInstanceId)\n+\n+        then: \"Verify queueDAO is not involved\"\n+        0 * queueDAO._\n+    }\n+\n+    def \"Verify pause succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The workflow is paused when QueueDAO is unavailable\"\n+        workflowResource.pauseWorkflow(workflowInstanceId)\n+\n+        then: \"Verify workflow is paused without any exceptions\"\n+        0 * queueDAO._\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.PAUSED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+    }\n+\n+    def \"Verify resume succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The workflow is paused\"\n+        workflowResource.pauseWorkflow(workflowInstanceId)\n+\n+        then: \"Verify workflow is paused\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.PAUSED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Workflow is resumed when QueueDAO is unavailable\"\n+        workflowResource.resumeWorkflow(workflowInstanceId)\n+\n+        then: \"Verify QueueDAO is not involved and Workflow is resumed successfully\"\n+        0 * queueDAO._\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+    }\n+\n+    def \"Verify reset callbacks fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Task is updated with callBackAfterSeconds\"\n+        def workflow = workflowResource.getExecutionStatus(workflowInstanceId, true)\n+        def task = workflow.getTasks().get(0)\n+        def taskResult = new TaskResult(task)\n+        taskResult.setCallbackAfterSeconds(120)\n+        taskResource.updateTask(taskResult)\n+\n+        and: \"and then reset callbacks when QueueDAO is unavailable\"\n+        workflowResource.resetWorkflow(workflowInstanceId)\n+\n+        then: \"Verify an exception is thrown\"\n+        1 * queueDAO.resetOffsetTime(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue resetOffsetTime failed from Spy\") }\n+        thrown(ApplicationException)\n+    }\n+\n+    def \"Verify search is not impacted by QueueDAO\"() {\n+        when: \"We perform a search\"\n+        workflowResource.search(0, 1, \"\", \"\", \"\")\n+\n+        then: \"Verify it doesn't involve QueueDAO\"\n+        0 * queueDAO._\n+    }\n+\n+    def \"Verify search workflows by tasks is not impacted by QueueDAO\"() {\n+        when: \"We perform a search\"\n+        workflowResource.searchWorkflowsByTasks(0, 1, \"\", \"\", \"\")\n+\n+        then: \"Verify it doesn't involve QueueDAO\"\n+        0 * queueDAO._\n+    }\n+\n+    def \"Verify get external storage location is not impacted by QueueDAO\"() {\n+        when:\n+        workflowResource.getExternalStorageLocation(\"\", \"\", \"\")\n+\n+        then: \"Verify it doesn't involve QueueDAO\"\n+        0 * queueDAO._\n+    }\n+\n+\n+    /// Task Resource endpoints\n+\n+    def \"Verify polls return with no result when QueueDAO is unavailable\"() {\n+        when: \"Some task 'integration_task_1' is polled\"\n+        def pollResult = taskResource.poll(\"integration_task_1\", \"test\", \"\")\n+\n+        then:\n+        1 * queueDAO.pop(*_) >> { throw new IllegalStateException(\"Queue pop failed from Spy\") }\n+        0 * queueDAO._\n+        notThrown(Exception)\n+        pollResult == null\n+    }\n+\n+    def \"Verify updateTask succeeds when QueueDAO is unavailable\"() {", "originalCommit": "f836543e736241e70b28bc37e5edcbf47cfee916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIxNzI3Nw==", "url": "https://github.com/Netflix/conductor/pull/1921#discussion_r504217277", "bodyText": "update the text here?", "author": "apanicker-nflx", "createdAt": "2020-10-13T19:54:06Z", "path": "test-harness/src/test/groovy/com/netflix/conductor/test/resiliency/QueueResiliencySpec.groovy", "diffHunk": "@@ -0,0 +1,605 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.conductor.test.resiliency\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskResult\n+import com.netflix.conductor.common.metadata.workflow.RerunWorkflowRequest\n+import com.netflix.conductor.common.metadata.workflow.StartWorkflowRequest\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.core.execution.ApplicationException\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.server.resources.TaskResource\n+import com.netflix.conductor.server.resources.WorkflowResource\n+import com.netflix.conductor.test.util.MockQueueDAOModule\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import spock.guice.UseModules\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+/**\n+ * When QueueDAO is unavailable,\n+ * Ensure All Worklow and Task resource endpoints either:\n+ * 1. Fails and/or throws an Exception\n+ * 2. Succeeds\n+ * 3. Doesn't involve QueueDAO\n+ */\n+@UseModules(MockQueueDAOModule)\n+class QueueResiliencySpec extends Specification {\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    @Inject\n+    WorkflowResource workflowResource\n+\n+    @Inject\n+    TaskResource taskResource\n+\n+    def SIMPLE_TWO_TASK_WORKFLOW = 'integration_test_wf'\n+\n+    def setup() {\n+        workflowTestUtil.taskDefinitions()\n+        workflowTestUtil.registerWorkflows(\n+                'simple_workflow_1_integration_test.json'\n+        )\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    /// Workflow Resource endpoints\n+\n+    def \"Verify Start workflow fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def response = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow starts when there are no Queue failures\"\n+        response\n+\n+        when: \"We try same request Queue failure\"\n+        response = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify that workflow start fails with BACKEND_ERROR\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        thrown(ApplicationException)\n+    }\n+\n+    def \"Verify terminate succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We terminate it when QueueDAO is unavailable\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that terminate is successful without any exceptions\"\n+        1 * queueDAO.remove(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue remove failed from Spy\") }\n+        0 * queueDAO._\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+    }\n+\n+    def \"Verify Restart workflow fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        and: \"We terminate it when QueueDAO is unavailable\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that workflow is in terminated state\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+\n+        when: \"We restart workflow when QueueDAO is unavailable\"\n+        workflowResource.restart(workflowInstanceId, false)\n+\n+        then: \"\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        1 * queueDAO.remove(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue remove failed from Spy\") }\n+        0 * queueDAO._\n+        thrown(ApplicationException)\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 0\n+        }\n+    }\n+\n+    def \"Verify rerun fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        and: \"terminate it\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that workflow is in terminated state\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+\n+        when: \"Workflow is rerun when QueueDAO is unavailable\"\n+        def rerunWorkflowRequest = new RerunWorkflowRequest()\n+        rerunWorkflowRequest.setReRunFromWorkflowId(workflowInstanceId)\n+        workflowResource.rerun(workflowInstanceId, rerunWorkflowRequest)\n+\n+        then: \"\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        0 * queueDAO._\n+        thrown(ApplicationException)\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 0\n+        }\n+    }\n+\n+    def \"Verify retry fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        and: \"terminate it\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that workflow is in terminated state\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+\n+        when: \"workflow is restarted when QueueDAO is unavailable\"\n+        workflowResource.retry(workflowInstanceId)\n+\n+        then: \"Verify retry fails\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        0 * queueDAO._\n+        thrown(ApplicationException)\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+    }\n+\n+    def \"Verify getWorkflow succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We get a workflow when QueueDAO is unavailable\"\n+        def workflow = workflowResource.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify workflow is returned\"\n+        0 * queueDAO._\n+        workflow.getStatus() == Workflow.WorkflowStatus.RUNNING\n+        workflow.getTasks().size() == 1\n+        workflow.getTasks()[0].status == Task.Status.SCHEDULED\n+    }\n+\n+    def \"Verify getWorkflows succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We get a workflow when QueueDAO is unavailable\"\n+        def workflows = workflowResource.getWorkflows(SIMPLE_TWO_TASK_WORKFLOW, \"\", true, true)\n+\n+        then: \"Verify queueDAO is not involved and an exception is not thrown\"\n+        0 * queueDAO._\n+        notThrown(Exception)\n+    }\n+\n+    def \"Verify remove workflow succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We get a workflow when QueueDAO is unavailable\"\n+        workflowResource.delete(workflowInstanceId, false)\n+\n+        then: \"Verify queueDAO is not involved\"\n+        0 * queueDAO._\n+\n+        when: \"We try to get deleted workflow\"\n+        workflowResource.getExecutionStatus(workflowInstanceId, true)\n+\n+        then:\n+        thrown(ApplicationException)\n+    }\n+\n+    def \"Verify decide succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We decide a workflow\"\n+        workflowResource.decide(workflowInstanceId)\n+\n+        then: \"Verify queueDAO is not involved\"\n+        0 * queueDAO._\n+    }\n+\n+    def \"Verify pause succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The workflow is paused when QueueDAO is unavailable\"\n+        workflowResource.pauseWorkflow(workflowInstanceId)\n+\n+        then: \"Verify workflow is paused without any exceptions\"\n+        0 * queueDAO._\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.PAUSED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+    }\n+\n+    def \"Verify resume succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The workflow is paused\"\n+        workflowResource.pauseWorkflow(workflowInstanceId)\n+\n+        then: \"Verify workflow is paused\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.PAUSED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Workflow is resumed when QueueDAO is unavailable\"\n+        workflowResource.resumeWorkflow(workflowInstanceId)\n+\n+        then: \"Verify QueueDAO is not involved and Workflow is resumed successfully\"\n+        0 * queueDAO._\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+    }\n+\n+    def \"Verify reset callbacks fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Task is updated with callBackAfterSeconds\"\n+        def workflow = workflowResource.getExecutionStatus(workflowInstanceId, true)\n+        def task = workflow.getTasks().get(0)\n+        def taskResult = new TaskResult(task)\n+        taskResult.setCallbackAfterSeconds(120)\n+        taskResource.updateTask(taskResult)\n+\n+        and: \"and then reset callbacks when QueueDAO is unavailable\"\n+        workflowResource.resetWorkflow(workflowInstanceId)\n+\n+        then: \"Verify an exception is thrown\"\n+        1 * queueDAO.resetOffsetTime(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue resetOffsetTime failed from Spy\") }\n+        thrown(ApplicationException)\n+    }\n+\n+    def \"Verify search is not impacted by QueueDAO\"() {\n+        when: \"We perform a search\"\n+        workflowResource.search(0, 1, \"\", \"\", \"\")\n+\n+        then: \"Verify it doesn't involve QueueDAO\"\n+        0 * queueDAO._\n+    }\n+\n+    def \"Verify search workflows by tasks is not impacted by QueueDAO\"() {\n+        when: \"We perform a search\"\n+        workflowResource.searchWorkflowsByTasks(0, 1, \"\", \"\", \"\")\n+\n+        then: \"Verify it doesn't involve QueueDAO\"\n+        0 * queueDAO._\n+    }\n+\n+    def \"Verify get external storage location is not impacted by QueueDAO\"() {\n+        when:\n+        workflowResource.getExternalStorageLocation(\"\", \"\", \"\")\n+\n+        then: \"Verify it doesn't involve QueueDAO\"\n+        0 * queueDAO._\n+    }\n+\n+\n+    /// Task Resource endpoints\n+\n+    def \"Verify polls return with no result when QueueDAO is unavailable\"() {\n+        when: \"Some task 'integration_task_1' is polled\"\n+        def pollResult = taskResource.poll(\"integration_task_1\", \"test\", \"\")\n+\n+        then:\n+        1 * queueDAO.pop(*_) >> { throw new IllegalStateException(\"Queue pop failed from Spy\") }\n+        0 * queueDAO._\n+        notThrown(Exception)\n+        pollResult == null\n+    }\n+\n+    def \"Verify updateTask with COMPLETE status succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The first task 'integration_task_1' is polled\"\n+        def task = taskResource.poll(\"integration_task_1\", \"test\", null)\n+\n+        then: \"Verify task is returned successfully\"\n+        task\n+        task.status == Task.Status.IN_PROGRESS\n+        task.taskType == 'integration_task_1'\n+\n+        when: \"the above task is updated, while QueueDAO is unavailable\"\n+        def taskResult = new TaskResult(task)\n+        taskResult.setStatus(TaskResult.Status.COMPLETED)\n+        def result = taskResource.updateTask(taskResult)\n+\n+        then: \"updateTask returns successfully without any exceptions\"\n+        1 * queueDAO.remove(*_) >> { throw new IllegalStateException(\"Queue remove failed from Spy\") }\n+        result == task.getTaskId()\n+        notThrown(Exception)\n+    }\n+\n+    def \"Verify updateTask with IN_PROGRESS state fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The first task 'integration_task_1' is polled\"\n+        def task = taskResource.poll(\"integration_task_1\", \"test\", null)\n+\n+        then: \"Verify task is returned successfully\"\n+        task\n+        task.status == Task.Status.IN_PROGRESS\n+        task.taskType == 'integration_task_1'\n+\n+        when: \"the above task is updated, while QueueDAO is unavailable\"\n+        def taskResult = new TaskResult(task)\n+        taskResult.setStatus(TaskResult.Status.IN_PROGRESS)\n+        taskResult.setCallbackAfterSeconds(120)\n+        def result = taskResource.updateTask(taskResult)\n+\n+        then: \"updateTask returns successfully without any exceptions\"", "originalCommit": "25641f5e3e00d952fe131d5a48e212809033dadf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIxODE1OQ==", "url": "https://github.com/Netflix/conductor/pull/1921#discussion_r504218159", "bodyText": "Why is postpone invoked twice? Given that we retry twice, shouldn't this be 3?", "author": "apanicker-nflx", "createdAt": "2020-10-13T19:55:37Z", "path": "test-harness/src/test/groovy/com/netflix/conductor/test/resiliency/QueueResiliencySpec.groovy", "diffHunk": "@@ -0,0 +1,605 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.conductor.test.resiliency\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskResult\n+import com.netflix.conductor.common.metadata.workflow.RerunWorkflowRequest\n+import com.netflix.conductor.common.metadata.workflow.StartWorkflowRequest\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.core.execution.ApplicationException\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.server.resources.TaskResource\n+import com.netflix.conductor.server.resources.WorkflowResource\n+import com.netflix.conductor.test.util.MockQueueDAOModule\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import spock.guice.UseModules\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+/**\n+ * When QueueDAO is unavailable,\n+ * Ensure All Worklow and Task resource endpoints either:\n+ * 1. Fails and/or throws an Exception\n+ * 2. Succeeds\n+ * 3. Doesn't involve QueueDAO\n+ */\n+@UseModules(MockQueueDAOModule)\n+class QueueResiliencySpec extends Specification {\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    @Inject\n+    WorkflowResource workflowResource\n+\n+    @Inject\n+    TaskResource taskResource\n+\n+    def SIMPLE_TWO_TASK_WORKFLOW = 'integration_test_wf'\n+\n+    def setup() {\n+        workflowTestUtil.taskDefinitions()\n+        workflowTestUtil.registerWorkflows(\n+                'simple_workflow_1_integration_test.json'\n+        )\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    /// Workflow Resource endpoints\n+\n+    def \"Verify Start workflow fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def response = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow starts when there are no Queue failures\"\n+        response\n+\n+        when: \"We try same request Queue failure\"\n+        response = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify that workflow start fails with BACKEND_ERROR\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        thrown(ApplicationException)\n+    }\n+\n+    def \"Verify terminate succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We terminate it when QueueDAO is unavailable\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that terminate is successful without any exceptions\"\n+        1 * queueDAO.remove(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue remove failed from Spy\") }\n+        0 * queueDAO._\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+    }\n+\n+    def \"Verify Restart workflow fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        and: \"We terminate it when QueueDAO is unavailable\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that workflow is in terminated state\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+\n+        when: \"We restart workflow when QueueDAO is unavailable\"\n+        workflowResource.restart(workflowInstanceId, false)\n+\n+        then: \"\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        1 * queueDAO.remove(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue remove failed from Spy\") }\n+        0 * queueDAO._\n+        thrown(ApplicationException)\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 0\n+        }\n+    }\n+\n+    def \"Verify rerun fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        and: \"terminate it\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that workflow is in terminated state\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+\n+        when: \"Workflow is rerun when QueueDAO is unavailable\"\n+        def rerunWorkflowRequest = new RerunWorkflowRequest()\n+        rerunWorkflowRequest.setReRunFromWorkflowId(workflowInstanceId)\n+        workflowResource.rerun(workflowInstanceId, rerunWorkflowRequest)\n+\n+        then: \"\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        0 * queueDAO._\n+        thrown(ApplicationException)\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 0\n+        }\n+    }\n+\n+    def \"Verify retry fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        and: \"terminate it\"\n+        workflowResource.terminate(workflowInstanceId, \"Terminated from a test\")\n+\n+        then: \"Verify that workflow is in terminated state\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+\n+        when: \"workflow is restarted when QueueDAO is unavailable\"\n+        workflowResource.retry(workflowInstanceId)\n+\n+        then: \"Verify retry fails\"\n+        1 * queueDAO.push(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue push failed from Spy\") }\n+        0 * queueDAO._\n+        thrown(ApplicationException)\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.TERMINATED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.CANCELED\n+        }\n+    }\n+\n+    def \"Verify getWorkflow succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We get a workflow when QueueDAO is unavailable\"\n+        def workflow = workflowResource.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify workflow is returned\"\n+        0 * queueDAO._\n+        workflow.getStatus() == Workflow.WorkflowStatus.RUNNING\n+        workflow.getTasks().size() == 1\n+        workflow.getTasks()[0].status == Task.Status.SCHEDULED\n+    }\n+\n+    def \"Verify getWorkflows succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We get a workflow when QueueDAO is unavailable\"\n+        def workflows = workflowResource.getWorkflows(SIMPLE_TWO_TASK_WORKFLOW, \"\", true, true)\n+\n+        then: \"Verify queueDAO is not involved and an exception is not thrown\"\n+        0 * queueDAO._\n+        notThrown(Exception)\n+    }\n+\n+    def \"Verify remove workflow succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+        then: \"Verify workflow is started\"\n+\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We get a workflow when QueueDAO is unavailable\"\n+        workflowResource.delete(workflowInstanceId, false)\n+\n+        then: \"Verify queueDAO is not involved\"\n+        0 * queueDAO._\n+\n+        when: \"We try to get deleted workflow\"\n+        workflowResource.getExecutionStatus(workflowInstanceId, true)\n+\n+        then:\n+        thrown(ApplicationException)\n+    }\n+\n+    def \"Verify decide succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"We decide a workflow\"\n+        workflowResource.decide(workflowInstanceId)\n+\n+        then: \"Verify queueDAO is not involved\"\n+        0 * queueDAO._\n+    }\n+\n+    def \"Verify pause succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The workflow is paused when QueueDAO is unavailable\"\n+        workflowResource.pauseWorkflow(workflowInstanceId)\n+\n+        then: \"Verify workflow is paused without any exceptions\"\n+        0 * queueDAO._\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.PAUSED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+    }\n+\n+    def \"Verify resume succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The workflow is paused\"\n+        workflowResource.pauseWorkflow(workflowInstanceId)\n+\n+        then: \"Verify workflow is paused\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.PAUSED\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Workflow is resumed when QueueDAO is unavailable\"\n+        workflowResource.resumeWorkflow(workflowInstanceId)\n+\n+        then: \"Verify QueueDAO is not involved and Workflow is resumed successfully\"\n+        0 * queueDAO._\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+    }\n+\n+    def \"Verify reset callbacks fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"Task is updated with callBackAfterSeconds\"\n+        def workflow = workflowResource.getExecutionStatus(workflowInstanceId, true)\n+        def task = workflow.getTasks().get(0)\n+        def taskResult = new TaskResult(task)\n+        taskResult.setCallbackAfterSeconds(120)\n+        taskResource.updateTask(taskResult)\n+\n+        and: \"and then reset callbacks when QueueDAO is unavailable\"\n+        workflowResource.resetWorkflow(workflowInstanceId)\n+\n+        then: \"Verify an exception is thrown\"\n+        1 * queueDAO.resetOffsetTime(*_) >> { throw new ApplicationException(ApplicationException.Code.BACKEND_ERROR, \"Queue resetOffsetTime failed from Spy\") }\n+        thrown(ApplicationException)\n+    }\n+\n+    def \"Verify search is not impacted by QueueDAO\"() {\n+        when: \"We perform a search\"\n+        workflowResource.search(0, 1, \"\", \"\", \"\")\n+\n+        then: \"Verify it doesn't involve QueueDAO\"\n+        0 * queueDAO._\n+    }\n+\n+    def \"Verify search workflows by tasks is not impacted by QueueDAO\"() {\n+        when: \"We perform a search\"\n+        workflowResource.searchWorkflowsByTasks(0, 1, \"\", \"\", \"\")\n+\n+        then: \"Verify it doesn't involve QueueDAO\"\n+        0 * queueDAO._\n+    }\n+\n+    def \"Verify get external storage location is not impacted by QueueDAO\"() {\n+        when:\n+        workflowResource.getExternalStorageLocation(\"\", \"\", \"\")\n+\n+        then: \"Verify it doesn't involve QueueDAO\"\n+        0 * queueDAO._\n+    }\n+\n+\n+    /// Task Resource endpoints\n+\n+    def \"Verify polls return with no result when QueueDAO is unavailable\"() {\n+        when: \"Some task 'integration_task_1' is polled\"\n+        def pollResult = taskResource.poll(\"integration_task_1\", \"test\", \"\")\n+\n+        then:\n+        1 * queueDAO.pop(*_) >> { throw new IllegalStateException(\"Queue pop failed from Spy\") }\n+        0 * queueDAO._\n+        notThrown(Exception)\n+        pollResult == null\n+    }\n+\n+    def \"Verify updateTask with COMPLETE status succeeds when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The first task 'integration_task_1' is polled\"\n+        def task = taskResource.poll(\"integration_task_1\", \"test\", null)\n+\n+        then: \"Verify task is returned successfully\"\n+        task\n+        task.status == Task.Status.IN_PROGRESS\n+        task.taskType == 'integration_task_1'\n+\n+        when: \"the above task is updated, while QueueDAO is unavailable\"\n+        def taskResult = new TaskResult(task)\n+        taskResult.setStatus(TaskResult.Status.COMPLETED)\n+        def result = taskResource.updateTask(taskResult)\n+\n+        then: \"updateTask returns successfully without any exceptions\"\n+        1 * queueDAO.remove(*_) >> { throw new IllegalStateException(\"Queue remove failed from Spy\") }\n+        result == task.getTaskId()\n+        notThrown(Exception)\n+    }\n+\n+    def \"Verify updateTask with IN_PROGRESS state fails when QueueDAO is unavailable\"() {\n+        when: \"Start a simple workflow\"\n+        def workflowInstanceId = workflowResource.startWorkflow(new StartWorkflowRequest()\n+                .withName(SIMPLE_TWO_TASK_WORKFLOW)\n+                .withVersion(1))\n+\n+        then: \"Verify workflow is started\"\n+        with(workflowResource.getExecutionStatus(workflowInstanceId, true)) {\n+            status == Workflow.WorkflowStatus.RUNNING\n+            tasks.size() == 1\n+            tasks[0].taskType == 'integration_task_1'\n+            tasks[0].status == Task.Status.SCHEDULED\n+        }\n+\n+        when: \"The first task 'integration_task_1' is polled\"\n+        def task = taskResource.poll(\"integration_task_1\", \"test\", null)\n+\n+        then: \"Verify task is returned successfully\"\n+        task\n+        task.status == Task.Status.IN_PROGRESS\n+        task.taskType == 'integration_task_1'\n+\n+        when: \"the above task is updated, while QueueDAO is unavailable\"\n+        def taskResult = new TaskResult(task)\n+        taskResult.setStatus(TaskResult.Status.IN_PROGRESS)\n+        taskResult.setCallbackAfterSeconds(120)\n+        def result = taskResource.updateTask(taskResult)\n+\n+        then: \"updateTask returns successfully without any exceptions\"\n+        2 * queueDAO.postpone(*_) >> { throw new IllegalStateException(\"Queue postpone failed from Spy\") }", "originalCommit": "25641f5e3e00d952fe131d5a48e212809033dadf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMyNTIwMA==", "url": "https://github.com/Netflix/conductor/pull/1921#discussion_r504325200", "bodyText": "The RetryUtil we're using here retries up to the provided number, which should be greater than >=1.", "author": "kishorebanala", "createdAt": "2020-10-14T00:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIxODE1OQ=="}], "type": "inlineReview"}, {"oid": "61d403f74285ace1021ddddd5dddac2015a718d6", "url": "https://github.com/Netflix/conductor/commit/61d403f74285ace1021ddddd5dddac2015a718d6", "message": "Improvements to QueueDAO resiliency changes to verify the case when update task is called with IN_PROGRESS state.", "committedDate": "2020-10-14T00:04:32Z", "type": "commit"}, {"oid": "61d403f74285ace1021ddddd5dddac2015a718d6", "url": "https://github.com/Netflix/conductor/commit/61d403f74285ace1021ddddd5dddac2015a718d6", "message": "Improvements to QueueDAO resiliency changes to verify the case when update task is called with IN_PROGRESS state.", "committedDate": "2020-10-14T00:04:32Z", "type": "forcePushed"}]}