{"pr_number": 1693, "pr_title": "added scenario based integration tests for DO_WHILE task", "pr_createdAt": "2020-05-20T03:07:02Z", "pr_url": "https://github.com/Netflix/conductor/pull/1693", "timeline": [{"oid": "abbeca270b3f01c76e0441c3c36fcb690e392456", "url": "https://github.com/Netflix/conductor/commit/abbeca270b3f01c76e0441c3c36fcb690e392456", "message": "added scenario based integration tests for DO_WHILE task", "committedDate": "2020-05-20T03:08:11Z", "type": "forcePushed"}, {"oid": "a6bd8c2323da2475e12e40417bb268ec1847cd85", "url": "https://github.com/Netflix/conductor/commit/a6bd8c2323da2475e12e40417bb268ec1847cd85", "message": "added scenario based integration tests for DO_WHILE task", "committedDate": "2020-05-20T07:02:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2MjI3Mg==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428062272", "bodyText": "nit: use intuitive variable names. Instead of using generic variable name task, something like task0 or integrationTask0 will be me more readable", "author": "pctreddy", "createdAt": "2020-05-20T14:33:30Z", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)", "originalCommit": "a6bd8c2323da2475e12e40417bb268ec1847cd85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTY3MA==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461670", "bodyText": "fixed", "author": "apanicker-nflx", "createdAt": "2020-05-21T06:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2MjI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2NjYzOA==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428066638", "bodyText": "There are couple of methods in the WorkflowTestUtil which take care of repetitive steps during the test:\n\nPoll and Complete Task : Tuple pollAndCompleteTask(String taskName, String workerId, Map<String, String> outputParams, int waitAtEndSeconds) {\nPoll and Fail Task  : Tuple pollAndFailTask(String taskName, String workerId, String failureReason, int waitAtEndSeconds) {\nVerify weather a Task was polled and acknowledged: static void verifyPolledAndAcknowledgedTask(Map<String, String> expectedTaskInputParams, Tuple completedTaskAndAck) {\n\ntry to reuse them wherever possible, this helps reuse and makes test code readable.", "author": "pctreddy", "createdAt": "2020-05-20T14:39:13Z", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED", "originalCommit": "a6bd8c2323da2475e12e40417bb268ec1847cd85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTcxNg==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461716", "bodyText": "refactored", "author": "apanicker-nflx", "createdAt": "2020-05-21T06:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2NjYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MDYwNw==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428070607", "bodyText": "Define new variables instead reassigning new values to existing variables, in this case task. Defining new variables is cheap and improves readability in each given -  when -then", "author": "pctreddy", "createdAt": "2020-05-20T14:44:18Z", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)", "originalCommit": "a6bd8c2323da2475e12e40417bb268ec1847cd85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTc1OA==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461758", "bodyText": "fixed", "author": "apanicker-nflx", "createdAt": "2020-05-21T06:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MDYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MzQ3OQ==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428073479", "bodyText": "nit: Validate the contents of the task[] to to verify that previous performed task completion has an affect and as a result the next task in schedule state.", "author": "pctreddy", "createdAt": "2020-05-20T14:47:53Z", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6", "originalCommit": "a6bd8c2323da2475e12e40417bb268ec1847cd85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTgwMA==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461800", "bodyText": "validated", "author": "apanicker-nflx", "createdAt": "2020-05-21T06:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MzQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3NzM5Ng==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428077396", "bodyText": "nit: getting the workflow state in the when can be moved to then and assigning of the variable can be skipped by leveraging the with:\nthen:\nwith(workflowExecutionService.getExecutionStatus(workflowInstanceId, true)){\n  status == Workflow.WorkflowStatus.RUNNING\n  tasks.size() == 6\n  tasks[1].taskType == 'integration_task_0'\n  tasks[1].status == Task.Status.COMPLETED\n}", "author": "pctreddy", "createdAt": "2020-05-20T14:52:42Z", "path": "test-harness/src/test/groovy/com/netflix/counductor/integration/test/DoWhileSpec.groovy", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.counductor.integration.test\n+\n+import com.netflix.conductor.common.metadata.tasks.Task\n+import com.netflix.conductor.common.metadata.tasks.TaskDef\n+import com.netflix.conductor.common.run.Workflow\n+import com.netflix.conductor.common.utils.TaskUtils\n+import com.netflix.conductor.core.execution.WorkflowExecutor\n+import com.netflix.conductor.dao.QueueDAO\n+import com.netflix.conductor.service.ExecutionService\n+import com.netflix.conductor.service.MetadataService\n+import com.netflix.conductor.test.util.WorkflowTestUtil\n+import com.netflix.conductor.tests.utils.TestModule\n+import com.netflix.governator.guice.test.ModulesForTesting\n+import spock.lang.Specification\n+\n+import javax.inject.Inject\n+\n+@ModulesForTesting([TestModule.class])\n+class DoWhileSpec extends Specification {\n+\n+    @Inject\n+    ExecutionService workflowExecutionService\n+\n+    @Inject\n+    MetadataService metadataService\n+\n+    @Inject\n+    WorkflowExecutor workflowExecutor\n+\n+    @Inject\n+    WorkflowTestUtil workflowTestUtil\n+\n+    @Inject\n+    QueueDAO queueDAO\n+\n+    def setup() {\n+        workflowTestUtil.registerWorkflows(\"do_while_integration_test.json\",\n+                \"do_while_multiple_integration_test.json\")\n+    }\n+\n+    def cleanup() {\n+        workflowTestUtil.clearWorkflows()\n+    }\n+\n+    def \"Test workflow with a single iteration Do While task\"() {\n+        given: \"Number of iterations of the loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Workflow\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for second task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_1\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 6\n+\n+        when: \"Polling for third task\"\n+        task = workflowExecutionService.getLastPollTask(\"integration_task_2\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is completed\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.COMPLETED\n+        workflow.tasks.size() == 6\n+    }\n+\n+    def \"Test workflow with multiple Do While tasks with multiple iterations\"() {\n+        given: \"Number of iterations of the first loop is set to 2 and second loop is set to 1\"\n+        def workflowInput = new HashMap()\n+        workflowInput['loop'] = 2\n+        workflowInput['loop2'] = 1\n+\n+        when: \"The workflow is started\"\n+        def workflowInstanceId = workflowExecutor.startWorkflow(\"Do_While_Multiple\", 1, \"looptest\", workflowInput, null, null)\n+\n+        and: \"The workflow is retrieved\"\n+        def workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow\n+        workflow.status == Workflow.WorkflowStatus.RUNNING\n+        workflow.tasks.size() == 2\n+\n+        when: \"Polling for first task\"\n+        def task = workflowExecutionService.getLastPollTask(\"integration_task_0\", \"integration.test.worker\", null)\n+\n+        then: \"Verify that the expected task is polled\"\n+        task\n+        task.getReferenceTaskName().endsWith(TaskUtils.getLoopOverTaskRefNameSuffix(task.getIteration()))\n+\n+        when: \"The task is completed\"\n+        task.status = Task.Status.COMPLETED\n+        workflowExecutionService.updateTask(task)\n+        workflow = workflowExecutionService.getExecutionStatus(workflowInstanceId, true)\n+\n+        then: \"Verify that workflow is running\"\n+        workflow", "originalCommit": "a6bd8c2323da2475e12e40417bb268ec1847cd85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTUyNQ==", "url": "https://github.com/Netflix/conductor/pull/1693#discussion_r428461525", "bodyText": "refactored", "author": "apanicker-nflx", "createdAt": "2020-05-21T06:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3NzM5Ng=="}], "type": "inlineReview"}, {"oid": "1225556b1af44ef6a54a757b444bfb8a41ef0c98", "url": "https://github.com/Netflix/conductor/commit/1225556b1af44ef6a54a757b444bfb8a41ef0c98", "message": "added scenario based integration tests for DO_WHILE task", "committedDate": "2020-05-21T06:01:18Z", "type": "forcePushed"}, {"oid": "acd91fd4838d09042506c2063923bb465a034472", "url": "https://github.com/Netflix/conductor/commit/acd91fd4838d09042506c2063923bb465a034472", "message": "added scenario based integration tests for DO_WHILE task", "committedDate": "2020-05-21T06:15:20Z", "type": "commit"}, {"oid": "acd91fd4838d09042506c2063923bb465a034472", "url": "https://github.com/Netflix/conductor/commit/acd91fd4838d09042506c2063923bb465a034472", "message": "added scenario based integration tests for DO_WHILE task", "committedDate": "2020-05-21T06:15:20Z", "type": "forcePushed"}]}