{"pr_number": 1649, "pr_title": "Refactored Subworkflow processing to leverage asyncComplete, and othe\u2026", "pr_createdAt": "2020-04-20T18:47:35Z", "pr_url": "https://github.com/Netflix/conductor/pull/1649", "timeline": [{"oid": "0940444b39399f592dcd992ef12f1efe85d2c696", "url": "https://github.com/Netflix/conductor/commit/0940444b39399f592dcd992ef12f1efe85d2c696", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements.", "committedDate": "2020-04-20T19:25:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MjUxNA==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r412582514", "bodyText": "Does this need to be a public method? Please add a unit test for this method.", "author": "apanicker-nflx", "createdAt": "2020-04-22T00:28:38Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1538,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    /**\n+     * Update parent Workflow status based on Subworkflow state.\n+     * @param subWorkflow\n+     */\n+    public void updateParentWorkflow(Workflow subWorkflow) {", "originalCommit": "0940444b39399f592dcd992ef12f1efe85d2c696", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MjY4NQ==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r412582685", "bodyText": "Does this need to be a public method? Please add a unit test for this method.", "author": "apanicker-nflx", "createdAt": "2020-04-22T00:29:04Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1538,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    /**\n+     * Update parent Workflow status based on Subworkflow state.\n+     * @param subWorkflow\n+     */\n+    public void updateParentWorkflow(Workflow subWorkflow) {\n+        Workflow parent = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        WorkflowDef parentDef = Optional.ofNullable(parent.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parent.getWorkflowName(), parent.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parent.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        Task parentWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        // On workflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (subWorkflow.getStatus().isSuccessful() && StringUtils.isBlank(parentDef.getFailureWorkflow()) && parent.getStatus() == WorkflowStatus.FAILED && parentWorkflowTask.getStatus() == FAILED) {\n+                LOGGER.debug(\"Subworkflow: {} is successful, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), parent.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                parentWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(parentWorkflowTask);\n+                parent.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parent);\n+                decide(parent.getWorkflowId());\n+            } else if (parentWorkflowTask.getStatus() == IN_PROGRESS) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, updating parent workflow: {}\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parent.getWorkflowId());\n+                SubWorkflow subWorkflowTask = new SubWorkflow();\n+                subWorkflowTask.execute(subWorkflow, parentWorkflowTask, this);\n+                // Keep Subworkflow task's data consistent with Subworkflow's.\n+                if (parentWorkflowTask.getExternalOutputPayloadStoragePath() != null && !parentWorkflowTask.getOutputData().isEmpty()) {\n+                    Map<String, Object> parentWorkflowTaskOutputData = parentWorkflowTask.getOutputData();\n+                    deciderService.populateTaskData(parentWorkflowTask);\n+                    parentWorkflowTask.getOutputData().putAll(parentWorkflowTaskOutputData);\n+                    deciderService.externalizeTaskData(parentWorkflowTask);\n+                }\n+                updateTask(new TaskResult(parentWorkflowTask));\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow\");\n+            }\n+        } else {\n+            // On workflow retry or restart..\n+            if (StringUtils.isBlank(parentDef.getFailureWorkflow()) && parent.getStatus() == WorkflowStatus.FAILED && parentWorkflowTask.getStatus() == FAILED) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parent.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                parentWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(parentWorkflowTask);\n+                parent.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parent);\n+                decide(parent.getWorkflowId());\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Verify that the Subworkflow is still operational for a given parent workflow.\n+     * For eg., if parent workflow's Subworkflow task is retried, the previous workflow is no longer associated with parent,\n+     * and any operations on it shouldn't impact the current running Subworkflow and Parent.\n+     * Future improvements: Check if this flow is part of other System task like Decide, Join etc.\n+     * @param workflow\n+     * @return\n+     */\n+    public boolean isViolatingParentWorkflowConsistency(Workflow workflow) {", "originalCommit": "0940444b39399f592dcd992ef12f1efe85d2c696", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDkzOA==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r412584938", "bodyText": "What is the case where the parent workflow task is expected to have output data in external storage while remaining in progress? Shouldn't the output data only get populated when the sub workflow task completes?", "author": "apanicker-nflx", "createdAt": "2020-04-22T00:35:50Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1538,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    /**\n+     * Update parent Workflow status based on Subworkflow state.\n+     * @param subWorkflow\n+     */\n+    public void updateParentWorkflow(Workflow subWorkflow) {\n+        Workflow parent = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        WorkflowDef parentDef = Optional.ofNullable(parent.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parent.getWorkflowName(), parent.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parent.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        Task parentWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        // On workflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (subWorkflow.getStatus().isSuccessful() && StringUtils.isBlank(parentDef.getFailureWorkflow()) && parent.getStatus() == WorkflowStatus.FAILED && parentWorkflowTask.getStatus() == FAILED) {\n+                LOGGER.debug(\"Subworkflow: {} is successful, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), parent.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                parentWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(parentWorkflowTask);\n+                parent.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parent);\n+                decide(parent.getWorkflowId());\n+            } else if (parentWorkflowTask.getStatus() == IN_PROGRESS) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, updating parent workflow: {}\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parent.getWorkflowId());\n+                SubWorkflow subWorkflowTask = new SubWorkflow();\n+                subWorkflowTask.execute(subWorkflow, parentWorkflowTask, this);\n+                // Keep Subworkflow task's data consistent with Subworkflow's.\n+                if (parentWorkflowTask.getExternalOutputPayloadStoragePath() != null && !parentWorkflowTask.getOutputData().isEmpty()) {", "originalCommit": "0940444b39399f592dcd992ef12f1efe85d2c696", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "url": "https://github.com/Netflix/conductor/commit/4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements.", "committedDate": "2020-04-22T22:32:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4NDk1MQ==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413384951", "bodyText": "Do not throw an exception.", "author": "kishorebanala", "createdAt": "2020-04-22T22:49:25Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1540,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    private boolean updateParentWorkflow(Workflow subWorkflow) {\n+        Task subWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        Workflow parentWorkflow = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    private boolean updateParentWorkflow(Task subWorkflowTask, Workflow parentWorkflow) {\n+        Workflow subWorkflow = executionDAOFacade.getWorkflowById(subWorkflowTask.getSubWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    /**\n+     * Update parent Workflow based on Subworkflow state.\n+     * Updates the provided subWorkflowTask and/or parentWorkflow inplace, where applicable.\n+     * @param subWorkflowTask\n+     * @param subWorkflow\n+     * @param parentWorkflow\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean updateParentWorkflow(Task subWorkflowTask, Workflow subWorkflow, Workflow parentWorkflow) {\n+        WorkflowDef parentDef = Optional.ofNullable(parentWorkflow.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parentWorkflow.getWorkflowName(), parentWorkflow.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parentWorkflow.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        // On Subworkflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (parentWorkflow.getStatus().equals(WorkflowStatus.FAILED)) {\n+                String errorMsg = String.format(\"Subworkflow: %s is successful, but parent workflow: %s is in FAILED state.\",\n+                        subWorkflow.getWorkflowId(), parentWorkflow.getWorkflowId());\n+                LOGGER.warn(errorMsg);\n+                throw new IllegalStateException(errorMsg);", "originalCommit": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4NTAxMQ==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413385011", "bodyText": "Update comments", "author": "kishorebanala", "createdAt": "2020-04-22T22:49:34Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1540,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    private boolean updateParentWorkflow(Workflow subWorkflow) {\n+        Task subWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        Workflow parentWorkflow = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    private boolean updateParentWorkflow(Task subWorkflowTask, Workflow parentWorkflow) {\n+        Workflow subWorkflow = executionDAOFacade.getWorkflowById(subWorkflowTask.getSubWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    /**\n+     * Update parent Workflow based on Subworkflow state.\n+     * Updates the provided subWorkflowTask and/or parentWorkflow inplace, where applicable.\n+     * @param subWorkflowTask\n+     * @param subWorkflow\n+     * @param parentWorkflow\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean updateParentWorkflow(Task subWorkflowTask, Workflow subWorkflow, Workflow parentWorkflow) {\n+        WorkflowDef parentDef = Optional.ofNullable(parentWorkflow.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parentWorkflow.getWorkflowName(), parentWorkflow.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parentWorkflow.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        // On Subworkflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them", "originalCommit": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMDY3Mg==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413400672", "bodyText": "Unable to do something can be changed to Unable to evaluate parent workflow", "author": "apanicker-nflx", "createdAt": "2020-04-22T23:27:45Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1540,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    private boolean updateParentWorkflow(Workflow subWorkflow) {\n+        Task subWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        Workflow parentWorkflow = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    private boolean updateParentWorkflow(Task subWorkflowTask, Workflow parentWorkflow) {\n+        Workflow subWorkflow = executionDAOFacade.getWorkflowById(subWorkflowTask.getSubWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    /**\n+     * Update parent Workflow based on Subworkflow state.\n+     * Updates the provided subWorkflowTask and/or parentWorkflow inplace, where applicable.\n+     * @param subWorkflowTask\n+     * @param subWorkflow\n+     * @param parentWorkflow\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean updateParentWorkflow(Task subWorkflowTask, Workflow subWorkflow, Workflow parentWorkflow) {\n+        WorkflowDef parentDef = Optional.ofNullable(parentWorkflow.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parentWorkflow.getWorkflowName(), parentWorkflow.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parentWorkflow.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        // On Subworkflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (parentWorkflow.getStatus().equals(WorkflowStatus.FAILED)) {\n+                String errorMsg = String.format(\"Subworkflow: %s is successful, but parent workflow: %s is in FAILED state.\",\n+                        subWorkflow.getWorkflowId(), parentWorkflow.getWorkflowId());\n+                LOGGER.warn(errorMsg);\n+                throw new IllegalStateException(errorMsg);\n+            } else if (subWorkflowTask.getStatus().equals(IN_PROGRESS)) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, updating parent workflow: {}\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parentWorkflow.getWorkflowId());\n+                SubWorkflow subWorkflowSystemTask = new SubWorkflow();\n+                subWorkflowSystemTask.execute(subWorkflow, subWorkflowTask, this);\n+                // Keep Subworkflow task's data consistent with Subworkflow's.\n+                if (subWorkflowTask.getStatus().isTerminal() && subWorkflowTask.getExternalOutputPayloadStoragePath() != null && !subWorkflowTask.getOutputData().isEmpty()) {\n+                    Map<String, Object> parentWorkflowTaskOutputData = subWorkflowTask.getOutputData();\n+                    deciderService.populateTaskData(subWorkflowTask);\n+                    subWorkflowTask.getOutputData().putAll(parentWorkflowTaskOutputData);\n+                    deciderService.externalizeTaskData(subWorkflowTask);\n+                }\n+                return true;\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow: {} in status: {}, and subworkflow: {} in status: {}\",\n+                        parentWorkflow.getWorkflowId(), parentWorkflow.getStatus().name(),\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name());\n+            }\n+        } else {\n+            // On workflow retry or restart..\n+            if (StringUtils.isBlank(parentDef.getFailureWorkflow()) && parentWorkflow.getStatus().isTerminal() && subWorkflowTask.getStatus().isTerminal()) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parentWorkflow.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                subWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(subWorkflowTask);\n+                parentWorkflow.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parentWorkflow);\n+                return true;\n+            } else if (parentWorkflow.getStatus().equals(WorkflowStatus.RUNNING)) {\n+                if (subWorkflowTask.getStatus().isTerminal()) {\n+                    String errorMsg = String.format(\"Subworkflow: %s is in RUNNING state, but Subworkflow task: %s in parent workflow: %s is in FAILED state.\",\n+                            subWorkflow.getWorkflowId(),subWorkflowTask.getTaskId(), parentWorkflow.getWorkflowId());\n+                    LOGGER.warn(errorMsg);\n+                    throw new IllegalStateException(errorMsg);\n+                } else {\n+                    // parentWorkflow, subWorkflowTask and subWorkflow are in non-terminal state\n+                    return false;\n+                }\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow: {} in status: {}, and subworkflow: {} in status: {}\",", "originalCommit": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMTMzOA==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413401338", "bodyText": "Why was this status changed?", "author": "apanicker-nflx", "createdAt": "2020-04-22T23:29:24Z", "path": "core/src/test/java/com/netflix/conductor/core/execution/tasks/TestSubWorkflow.java", "diffHunk": "@@ -211,7 +211,7 @@ public void testExecuteWorkflowStatus() {\n         subWorkflowInstance.setStatus(Workflow.WorkflowStatus.TIMED_OUT);\n         subWorkflowInstance.setReasonForIncompletion(\"unit2\");\n         assertTrue(subWorkflow.execute(workflowInstance, task, workflowExecutor));\n-        assertEquals(Task.Status.FAILED, task.getStatus());\n+        assertEquals(Task.Status.TIMED_OUT, task.getStatus());", "originalCommit": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NTQ1Nw==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413495457", "bodyText": "Subworkflow task has been updated to closely reflect Workflow status. If the workflow were to TIMED_OUT, the task is now set to TIMED_OUT as well.", "author": "kishorebanala", "createdAt": "2020-04-23T04:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMTMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMTkxMA==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413401910", "bodyText": "What is the scenario when this would be invoked?", "author": "apanicker-nflx", "createdAt": "2020-04-22T23:31:01Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1539,4 +1540,86 @@ public TaskDef getTaskDefinition(Task task) {\n                             return new TerminateWorkflowException(reason);\n                         }));\n     }\n+\n+    private boolean updateParentWorkflow(Workflow subWorkflow) {\n+        Task subWorkflowTask = executionDAOFacade.getTaskById(subWorkflow.getParentWorkflowTaskId());\n+        Workflow parentWorkflow = executionDAOFacade.getWorkflowById(subWorkflow.getParentWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    private boolean updateParentWorkflow(Task subWorkflowTask, Workflow parentWorkflow) {\n+        Workflow subWorkflow = executionDAOFacade.getWorkflowById(subWorkflowTask.getSubWorkflowId(), false);\n+        return updateParentWorkflow(subWorkflowTask, subWorkflow, parentWorkflow);\n+    }\n+\n+    /**\n+     * Update parent Workflow based on Subworkflow state.\n+     * Updates the provided subWorkflowTask and/or parentWorkflow inplace, where applicable.\n+     * @param subWorkflowTask\n+     * @param subWorkflow\n+     * @param parentWorkflow\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean updateParentWorkflow(Task subWorkflowTask, Workflow subWorkflow, Workflow parentWorkflow) {\n+        WorkflowDef parentDef = Optional.ofNullable(parentWorkflow.getWorkflowDefinition())\n+                .orElseGet(() -> metadataDAO.getWorkflowDef(parentWorkflow.getWorkflowName(), parentWorkflow.getWorkflowVersion())\n+                        .orElseThrow(() -> new ApplicationException(NOT_FOUND, String.format(\"Unable to find parent workflow definition for %s\", parentWorkflow.getWorkflowId())))\n+                );\n+        LOGGER.debug(\"Evaluating parent workflow: {} for sub-workflow: {}\", subWorkflow.getParentWorkflowId(), subWorkflow.getWorkflowId());\n+\n+        // On Subworkflow complete or terminate..\n+        if (subWorkflow.getStatus().isTerminal()) {\n+            // If parent is FAILED and the sub workflow task in parent is FAILED, we want to resume them\n+            if (parentWorkflow.getStatus().equals(WorkflowStatus.FAILED)) {\n+                String errorMsg = String.format(\"Subworkflow: %s is successful, but parent workflow: %s is in FAILED state.\",\n+                        subWorkflow.getWorkflowId(), parentWorkflow.getWorkflowId());\n+                LOGGER.warn(errorMsg);\n+                throw new IllegalStateException(errorMsg);\n+            } else if (subWorkflowTask.getStatus().equals(IN_PROGRESS)) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, updating parent workflow: {}\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parentWorkflow.getWorkflowId());\n+                SubWorkflow subWorkflowSystemTask = new SubWorkflow();\n+                subWorkflowSystemTask.execute(subWorkflow, subWorkflowTask, this);\n+                // Keep Subworkflow task's data consistent with Subworkflow's.\n+                if (subWorkflowTask.getStatus().isTerminal() && subWorkflowTask.getExternalOutputPayloadStoragePath() != null && !subWorkflowTask.getOutputData().isEmpty()) {\n+                    Map<String, Object> parentWorkflowTaskOutputData = subWorkflowTask.getOutputData();\n+                    deciderService.populateTaskData(subWorkflowTask);\n+                    subWorkflowTask.getOutputData().putAll(parentWorkflowTaskOutputData);\n+                    deciderService.externalizeTaskData(subWorkflowTask);\n+                }\n+                return true;\n+            } else {\n+                LOGGER.warn(\"Unable to do something with parent workflow: {} in status: {}, and subworkflow: {} in status: {}\",\n+                        parentWorkflow.getWorkflowId(), parentWorkflow.getStatus().name(),\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name());\n+            }\n+        } else {\n+            // On workflow retry or restart..\n+            if (StringUtils.isBlank(parentDef.getFailureWorkflow()) && parentWorkflow.getStatus().isTerminal() && subWorkflowTask.getStatus().isTerminal()) {\n+                LOGGER.debug(\"Subworkflow: {} is {}, resetting failed parent workflow: {}, and Subworkflow task: {} status to IN_PROGRESS\",\n+                        subWorkflow.getWorkflowId(), subWorkflow.getStatus().name(), parentWorkflow.getWorkflowId(), subWorkflow.getParentWorkflowTaskId());\n+                subWorkflowTask.setStatus(IN_PROGRESS);\n+                executionDAOFacade.updateTask(subWorkflowTask);\n+                parentWorkflow.setStatus(WorkflowStatus.RUNNING);\n+                executionDAOFacade.updateWorkflow(parentWorkflow);\n+                return true;\n+            } else if (parentWorkflow.getStatus().equals(WorkflowStatus.RUNNING)) {\n+                if (subWorkflowTask.getStatus().isTerminal()) {", "originalCommit": "4b7ec4ca730265c7a0ce5e632f8da563ff7d5580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NTA2Mw==", "url": "https://github.com/Netflix/conductor/pull/1649#discussion_r413495063", "bodyText": "Ideally, it shouldn't. But, until we have recovery, if the workflow were to run into inconsistent state because of previous transient errors, this helps stops it from further continuing the inconsistency.", "author": "kishorebanala", "createdAt": "2020-04-23T04:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMTkxMA=="}], "type": "inlineReview"}, {"oid": "7f758c5af544d32a56b7e02ff468716089f6fe34", "url": "https://github.com/Netflix/conductor/commit/7f758c5af544d32a56b7e02ff468716089f6fe34", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements.", "committedDate": "2020-04-23T04:20:42Z", "type": "forcePushed"}, {"oid": "afcffb3f7dce6b3277961be13572a1d33f35c1dc", "url": "https://github.com/Netflix/conductor/commit/afcffb3f7dce6b3277961be13572a1d33f35c1dc", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements.", "committedDate": "2020-04-23T18:27:16Z", "type": "commit"}, {"oid": "afcffb3f7dce6b3277961be13572a1d33f35c1dc", "url": "https://github.com/Netflix/conductor/commit/afcffb3f7dce6b3277961be13572a1d33f35c1dc", "message": "Refactored Subworkflow processing to leverage asyncComplete, and other improvements.", "committedDate": "2020-04-23T18:27:16Z", "type": "forcePushed"}]}