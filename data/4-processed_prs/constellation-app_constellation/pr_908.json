{"pr_number": 908, "pr_title": "Performance/28 cosine", "pr_createdAt": "2020-12-07T04:32:57Z", "pr_url": "https://github.com/constellation-app/constellation/pull/908", "timeline": [{"oid": "f96d4bc38fa2eea6a199c7ae92bc404a6c519587", "url": "https://github.com/constellation-app/constellation/commit/f96d4bc38fa2eea6a199c7ae92bc404a6c519587", "message": ":racehorse: Various changes to reduce pagerank memory usage\nNow stores the amount of outward links a vertex has in the separate outcounts map instead of storing it a number of times equal to the amount of verticies it neighbours.\nTidied edge direction logic.\nDeal with sinks (nodes with no outgoing edges) more succinctly.\nAdded progress tracker.\nNo longer build extra set of neighbours for each vertex. Looks like these wern't being garbage collected properly and may have been the main cause of the memory issue.\nMoved maxPagerank and delta calculation to after pagerank calculation instead of during, this is to set up for trialing using the stream framework or parallelising the pagerank calculation to improve performance (neither of these have been done yet).", "committedDate": "2020-11-18T05:01:01Z", "type": "commit"}, {"oid": "3ae3af1f1d3bf1abdb56628a9d7162220450f0a9", "url": "https://github.com/constellation-app/constellation/commit/3ae3af1f1d3bf1abdb56628a9d7162220450f0a9", "message": ":bug: Fixed bug causing early finish\nDelta was being calculated incorrectly. This would cause the epsilon to be met prematurely and the analytic to finish prematurely.", "committedDate": "2020-11-19T02:06:07Z", "type": "commit"}, {"oid": "2a94eeaf399acca5eb2f67085aa9e49af22155f2", "url": "https://github.com/constellation-app/constellation/commit/2a94eeaf399acca5eb2f67085aa9e49af22155f2", "message": ":racehorse: :art: Complete refactor of PagerankCentralityPlugin.edit\nCreated new subclass PagerankVertex to enable sotrage of related information together and allow quicker access to data such as pageRank, neighbours etc\nThis also reduces the amount of duplicate data and makes the code more readable through the creation of multiple new methods.\n\nImproves both the speed and memory usage of the analytic.", "committedDate": "2020-11-19T23:58:04Z", "type": "commit"}, {"oid": "44422dbb6946dde698d32030b91f883c7a0424a5", "url": "https://github.com/constellation-app/constellation/commit/44422dbb6946dde698d32030b91f883c7a0424a5", "message": ":art: Made variables final and private where applicable.", "committedDate": "2020-11-20T00:22:11Z", "type": "commit"}, {"oid": "dc0df09ffea257cd1db3aca4586bfcf778f17997", "url": "https://github.com/constellation-app/constellation/commit/dc0df09ffea257cd1db3aca4586bfcf778f17997", "message": ":art: Updated author due to wholesale changes.", "committedDate": "2020-11-20T00:34:11Z", "type": "commit"}, {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26", "url": "https://github.com/constellation-app/constellation/commit/5e7dda1324f201051c50a5a21905a6829fb76f26", "message": ":art: Fixed code smells.", "committedDate": "2020-11-20T01:53:24Z", "type": "commit"}, {"oid": "5cbe3e2047ab4a387d4140556c5a71f3b92e8e2c", "url": "https://github.com/constellation-app/constellation/commit/5cbe3e2047ab4a387d4140556c5a71f3b92e8e2c", "message": ":art: Made changes requested in pull request.", "committedDate": "2020-11-24T21:40:19Z", "type": "commit"}, {"oid": "ebbffaeaf4dc707fcd7d87eb767f1dc753b407a8", "url": "https://github.com/constellation-app/constellation/commit/ebbffaeaf4dc707fcd7d87eb767f1dc753b407a8", "message": ":racehorse:WIP Reduced memory usage and slightly improved performance.\n\nChanged data structure for storing neighbour weights from an int[] to a HashMap. In the common cases where most verticies are not neighbours this will reduce memory usage by not strong 0s for all the vertex pairs without a transaction between them.\nVertex details are now stored in an object with neighbourWeight details to break up logic and stop the storage of every vertices weight together.\nNext Step: Improve performance of adding results to the graph.", "committedDate": "2020-12-04T02:32:27Z", "type": "commit"}, {"oid": "7c94be72ebb92d2ce0f92f0852052ac9fda60f3a", "url": "https://github.com/constellation-app/constellation/commit/7c94be72ebb92d2ce0f92f0852052ac9fda60f3a", "message": ":art: Separated attribute ensuring logic from score adding logic.\n\nCreated method setGraphAndEnsureAttributes to separate the logic for ensuring the graph has the right attributes from the logic that adds the scores to the graph. This is to pave the way for publically allowing scored to be added individually without repeatedly ensuring attributes are on the graph.", "committedDate": "2020-12-04T03:06:14Z", "type": "commit"}, {"oid": "ac69cc8bf7e0c9a1b426c103b7303ec9389b0501", "url": "https://github.com/constellation-app/constellation/commit/ac69cc8bf7e0c9a1b426c103b7303ec9389b0501", "message": ":racehorse: Refactored addScoreToGraph to contain bulk of logic.\n\nRefactored the addScoreToGraph method to contain the bulk of the logic so that addScoresToGraph now calls addScoreToGraph multiple times rather than addScoreToGraph creating a collection and calling addScoresToGraph.\n\nClarified some logic and deleted extrenuous comments in CosineSimilarityPlugin.", "committedDate": "2020-12-07T00:22:56Z", "type": "commit"}, {"oid": "0bcfc0a323f6f997fb65d6a389220e8ce30f5ea7", "url": "https://github.com/constellation-app/constellation/commit/0bcfc0a323f6f997fb65d6a389220e8ce30f5ea7", "message": ":racehorse: Modified plugins to make use of addScoreToGraph method\n\nModified analytic plugins currently using the addScoreToGraph plugin to instead make use of the addScoreToGraph plugin.\nThe eliminated the need to gather all scores prior to adding them to the graph, reducing memory usage and decreesing the time taken to add scores to the graph.", "committedDate": "2020-12-07T01:32:51Z", "type": "commit"}, {"oid": "9ed398466c149286384bf8e9948f5dbd6d193c4e", "url": "https://github.com/constellation-app/constellation/commit/9ed398466c149286384bf8e9948f5dbd6d193c4e", "message": ":art: Fixed typo", "committedDate": "2020-12-07T02:22:29Z", "type": "commit"}, {"oid": "47eb15a785a5e2d646328b39c9a057ad70cc6360", "url": "https://github.com/constellation-app/constellation/commit/47eb15a785a5e2d646328b39c9a057ad70cc6360", "message": ":racehorse:Early removal of verticies unable to pass minCommonFeatures.\n\nInstead of adding every vertex with atleast one neighbour to the list of vertices we now only add vertices with more neighbours than the minCommonFeatures values.\nIf minCommonFeatures > 1 then this will reduce the number of times that the common neighbours are calculated and increase the speed of the plugin.", "committedDate": "2020-12-07T04:11:00Z", "type": "commit"}, {"oid": "dcc7b9c3e54b20d770d937ebfc21c82adbb5f74d", "url": "https://github.com/constellation-app/constellation/commit/dcc7b9c3e54b20d770d937ebfc21c82adbb5f74d", "message": "Merge branch 'master' into performance/28-Cosine", "committedDate": "2020-12-07T04:16:06Z", "type": "commit"}, {"oid": "7813b77e5538273bcb709f87a8b7135c9a070e89", "url": "https://github.com/constellation-app/constellation/commit/7813b77e5538273bcb709f87a8b7135c9a070e89", "message": ":art:Removed unusued parameter from addScoreToGraph.", "committedDate": "2020-12-07T04:45:17Z", "type": "commit"}, {"oid": "3a0b85d70cf0887cbfe5db721cd1a309d5736033", "url": "https://github.com/constellation-app/constellation/commit/3a0b85d70cf0887cbfe5db721cd1a309d5736033", "message": ":art: Renamed variable to avoid hiding class variable.", "committedDate": "2020-12-07T04:47:03Z", "type": "commit"}, {"oid": "fa8306111e639c8b457901bc3fccaf2b1ac70b2f", "url": "https://github.com/constellation-app/constellation/commit/fa8306111e639c8b457901bc3fccaf2b1ac70b2f", "message": ":art: Removed unused logger.", "committedDate": "2020-12-07T04:49:05Z", "type": "commit"}, {"oid": "2eeb6110a4e9dd4966611a3f29bca5716a3e7185", "url": "https://github.com/constellation-app/constellation/commit/2eeb6110a4e9dd4966611a3f29bca5716a3e7185", "message": ":art: Made applicable variables and arguments final.", "committedDate": "2020-12-07T04:53:41Z", "type": "commit"}, {"oid": "87dc582b478d88fc59610291570e6b06e52337e4", "url": "https://github.com/constellation-app/constellation/commit/87dc582b478d88fc59610291570e6b06e52337e4", "message": ":art: Removes unused method agrument.", "committedDate": "2020-12-07T05:10:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1Nzk4OQ==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537757989", "bodyText": "@Nova-2119 can you let me know if you removed the use of Tuple because it was causing memory issues or was it a side effect that you didn't need to use them when you re-factored this?", "author": "arcturus2", "createdAt": "2020-12-07T19:09:08Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/AdamicAdarIndexPlugin.java", "diffHunk": "@@ -33,10 +33,7 @@\n import au.gov.asd.tac.constellation.plugins.parameters.types.IntegerParameterType;\n import au.gov.asd.tac.constellation.plugins.parameters.types.IntegerParameterType.IntegerParameterValue;\n import au.gov.asd.tac.constellation.plugins.templates.SimpleEditPlugin;\n-import au.gov.asd.tac.constellation.utilities.datastructure.Tuple;", "originalCommit": "87dc582b478d88fc59610291570e6b06e52337e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MjE3Mw==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557742173", "bodyText": "Just a side effect", "author": "Nova-2119", "createdAt": "2021-01-14T22:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1Nzk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5MzU2Mw==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537893563", "bodyText": "should be able to omit the brackets that around the outside of this boolean", "author": "antares1470", "createdAt": "2020-12-07T22:51:05Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);", "originalCommit": "87dc582b478d88fc59610291570e6b06e52337e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5NDg3MA==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537894870", "bodyText": "change this declaration to a plain old Map (the instantiation below is fine)", "author": "antares1470", "createdAt": "2020-12-07T22:53:42Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;", "originalCommit": "87dc582b478d88fc59610291570e6b06e52337e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MzUxMg==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557743512", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2021-01-14T22:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5NDg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5NTU1OA==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537895558", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-07T22:55:00Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);", "originalCommit": "87dc582b478d88fc59610291570e6b06e52337e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0NzQzNg==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557747436", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2021-01-14T22:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5NTU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMDUwMw==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537900503", "bodyText": "I think getMagnitude() is more complicated then it needs to be. If you set magnitude to calculateMagnitude() at the end of the constructor and then getMagnitude() simply returns magnitude.\nThis will help prevent needing to do a null check everytime", "author": "antares1470", "createdAt": "2020-12-07T23:05:25Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }", "originalCommit": "87dc582b478d88fc59610291570e6b06e52337e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3NjI5Mw==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557776293", "bodyText": "Can you explain this to me further?", "author": "Nova-2119", "createdAt": "2021-01-14T23:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMDUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NTczOQ==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557785739", "bodyText": "@Nova-2119 If I recall, you initially instantiated magnitude to null so as far as I could tell, the null check in getMagnitude() was purely to run calculateMagnitude() the first time and so didn't appear to be needed for subsequent calls. Subsequent calls on getMagnitude() would still do that null check though so my idea was really about moving that `calculateMagnitude()' call out of the function so that a null check wasn't needed.\nObviously you've made changes since so it doesn't really apply now but those were my thoughts at the time", "author": "antares1470", "createdAt": "2021-01-15T00:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMDUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMTg3Mw==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537901873", "bodyText": "minor but adding spacing between dot, =, and 0 would be good", "author": "antares1470", "createdAt": "2020-12-07T23:08:12Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }\n+        \n     }\n-\n-    private float magnitude(final int[] vector) {\n-        float magnitude = 0;\n-        for (int index = 0; index < vector.length; index++) {\n-            magnitude += Math.pow(vector[index], 2);\n+    \n+    BitSet getCommonNeighbours(final BitSet leftVertexNeighbours, final BitSet rightVertexNeighbours) {\n+        final BitSet intersection = (BitSet) leftVertexNeighbours.clone();\n+        intersection.and(rightVertexNeighbours);\n+        return intersection;\n+    }\n+    \n+    float getNeighbourDotProduct(final VertexWithNeighbours vertex1, final VertexWithNeighbours vertex2, BitSet intersection) {\n+        float dot=0;", "originalCommit": "87dc582b478d88fc59610291570e6b06e52337e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3Njk4MA==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557776980", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2021-01-15T00:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMjA0Mg==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537902042", "bodyText": "intersection can be final", "author": "antares1470", "createdAt": "2020-12-07T23:08:34Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {\n+                mag += Math.pow(neighbourWeight, 2);\n+            }\n+            return (float) Math.sqrt(mag);\n+        }\n+        \n     }\n-\n-    private float magnitude(final int[] vector) {\n-        float magnitude = 0;\n-        for (int index = 0; index < vector.length; index++) {\n-            magnitude += Math.pow(vector[index], 2);\n+    \n+    BitSet getCommonNeighbours(final BitSet leftVertexNeighbours, final BitSet rightVertexNeighbours) {\n+        final BitSet intersection = (BitSet) leftVertexNeighbours.clone();\n+        intersection.and(rightVertexNeighbours);\n+        return intersection;\n+    }\n+    \n+    float getNeighbourDotProduct(final VertexWithNeighbours vertex1, final VertexWithNeighbours vertex2, BitSet intersection) {", "originalCommit": "87dc582b478d88fc59610291570e6b06e52337e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3Njk1Mg==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557776952", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2021-01-15T00:00:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMjA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMjE4NA==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537902184", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-07T23:08:53Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+        }\n+        \n+        private float getMagnitude() {\n+            if (magnitude == null) {\n+                magnitude = calculateMagnitude();\n+            }\n+            return magnitude;\n+        }\n+        \n+        private float calculateMagnitude() {\n+            float mag = 0;\n+            for(int neighbourWeight : neighbourWeightsMap.values()) {", "originalCommit": "87dc582b478d88fc59610291570e6b06e52337e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3NjY4NQ==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557776685", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2021-01-14T23:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkwMjE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNjk2OA==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r537916968", "bodyText": "for completion, should a recalculation of magnitude be done every time the weights map is updated?", "author": "antares1470", "createdAt": "2020-12-07T23:35:52Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +109,128 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            if (graph.getVertexNeighbourCount(vertexId) > minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final HashMap<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);", "originalCommit": "87dc582b478d88fc59610291570e6b06e52337e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1MTYwNA==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557751604", "bodyText": "Hmm I see what you are getting at, but I don't think this is the correct solution, otherwise we will be calculating magnitude a heap of times.\nInstead I think I will make it set an recalculateMagnitude boolean to true and modifiy getMagnitude to recalculate it if the bit is true. That way we can ensure it is up to date when retrieved without calculating it too many times.", "author": "Nova-2119", "createdAt": "2021-01-14T22:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNjk2OA=="}], "type": "inlineReview"}, {"oid": "3569ec0adfdf092e19a268ef3edcf7d9d7b33335", "url": "https://github.com/constellation-app/constellation/commit/3569ec0adfdf092e19a268ef3edcf7d9d7b33335", "message": ":art: Make tests more readable and resistant to unimportant changes\n\npreviously the tests relied upon knowing the transactionID each \ncosine similarity result would be assigned to. This is unimportant to the analyst\nand obtuse when reading the code. Switching to rely upon the more meaningful identifier of the\ntransaction to figure out which results we are testing means that the test is now resistant to changes\nthat may alter the order cosine similarity scores are generated but not the actual results and\nis easier to read for future developers.", "committedDate": "2020-12-21T02:02:53Z", "type": "commit"}, {"oid": "be68a3e41495a89797f4c20302e18d62f3ac646a", "url": "https://github.com/constellation-app/constellation/commit/be68a3e41495a89797f4c20302e18d62f3ac646a", "message": ":bug: Fixed bug meaning only results > minCommonFeatures were calculated\n\nRelaxed minCommonFeatures condition from > to >= to stop the analytic ignoring similarities\nof interest.Also made a small change to connectionOn/Out logic so that it revolved around the vertex\nof interest and not the neighbour, I think this is just slightly clearer.", "committedDate": "2020-12-21T02:04:48Z", "type": "commit"}, {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093", "url": "https://github.com/constellation-app/constellation/commit/a2687fdc437b6eccbe55853cf7d2a339e1e45093", "message": ":bug: :white_check_mark: Updates tests.\nTest were previously incorrect, they looked for values that were slightly wrong.\nThese values included a bug where the pageRank distributed to each other node by a sink would\nbe its pageRank divided by the total number of nodes rather than the number of nodes minus 1 (as it wont distributed pageRank to itself).\n\nI have modified the test to only perform 2 iterations. This should still test that multiple iterations works but is also now a small enough test for values to be calculated by hand in order to verify the values are correct. This allows the values to be set based on the true value and not the values being produced by the analytic at the time of writing the test.", "committedDate": "2020-12-21T04:41:44Z", "type": "commit"}, {"oid": "65e809bd633b2b01e09376b7b0dfa73b6d7d15b8", "url": "https://github.com/constellation-app/constellation/commit/65e809bd633b2b01e09376b7b0dfa73b6d7d15b8", "message": "Merge branch 'performance/28-PagerankMemory' into performance/28-Cosine", "committedDate": "2020-12-21T04:49:28Z", "type": "commit"}, {"oid": "b36a54d7fb21bd277231982fffd08c527e86a61f", "url": "https://github.com/constellation-app/constellation/commit/b36a54d7fb21bd277231982fffd08c527e86a61f", "message": ":bug: :white_check_mark: Updated tests.\nUpdates tests to rely on the identifier of the transaction, not the transaction ID\nas the transaction ID could change without the results being changed.", "committedDate": "2020-12-21T05:24:32Z", "type": "commit"}, {"oid": "2ee29e58d790588b0bdac24d18c4995bec81193c", "url": "https://github.com/constellation-app/constellation/commit/2ee29e58d790588b0bdac24d18c4995bec81193c", "message": ":bug: :white_check_mark: Updated tests.\nUpdates tests to rely on the identifier of the transaction, not the transaction ID\nas the transaction ID could change without the results being changed.", "committedDate": "2020-12-21T06:01:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4ODUwMg==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r555088502", "bodyText": "@Nova-2119 @cygnus-x-1 Previously vxId4 was last but now vxId3 is. Does that mean the page rank was wrong before or wrong now?", "author": "arcturus2", "createdAt": "2021-01-11T14:34:59Z", "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -102,15 +102,15 @@ public void testNormalisedPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, true);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.22181106f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.4309117f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.42492065f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.8254921f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 1f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.18089105f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.39393282f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.5371851f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 1f);", "originalCommit": "2ee29e58d790588b0bdac24d18c4995bec81193c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE1MTg4MQ==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r556151881", "bodyText": "It was wrong before, all the values were slightly out because when there was a sink it included itself in the count of how many nodes it was distributing its pagerank too when it shouldn't have (it used the total number of nodes rather than number of nodes-1).\nThis has changed all the values a little.", "author": "Nova-2119", "createdAt": "2021-01-12T22:57:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4ODUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4OTEzOQ==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r555089139", "bodyText": "@Nova-2119 @cygnus-x-1 Previously vxId4 was last but now its vxId3. Does that mean the page rank was wrong before or wrong now?", "author": "arcturus2", "createdAt": "2021-01-11T14:35:52Z", "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -84,16 +84,16 @@ public void testPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, false);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.08510862f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.15745096f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.15202528f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.28124678f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 0.32416838f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.0725f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.134125f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.1755625f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.3094375f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 0.308375f);", "originalCommit": "2ee29e58d790588b0bdac24d18c4995bec81193c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE1MTMxMw==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r556151313", "bodyText": "It was wrong before, all the values were slightly out because when there was a sink it included itself in the count of how many nodes it was distributing its pagerank too when it shouldn't have (it used the total number of nodes rather than number of nodes-1).\nThis has changed all the values a little.", "author": "Nova-2119", "createdAt": "2021-01-12T22:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4OTEzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3Nzk3Ng==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557777976", "bodyText": "ok thank you @Nova-2119", "author": "arcturus2", "createdAt": "2021-01-15T00:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4OTEzOQ=="}], "type": "inlineReview"}, {"oid": "4fd734e5470f5a80b56e864fdf0ecc3738f4e011", "url": "https://github.com/constellation-app/constellation/commit/4fd734e5470f5a80b56e864fdf0ecc3738f4e011", "message": ":art: Minor improvements suggested in PR review.", "committedDate": "2021-01-15T00:04:40Z", "type": "commit"}, {"oid": "69121991b44ebb235abef7472392726f3b1fb097", "url": "https://github.com/constellation-app/constellation/commit/69121991b44ebb235abef7472392726f3b1fb097", "message": ":art: Minor improvements suggested in PR review.", "committedDate": "2021-01-15T00:04:47Z", "type": "commit"}, {"oid": "8cf373c1505b3d3fb20c830a983d4fd917af958a", "url": "https://github.com/constellation-app/constellation/commit/8cf373c1505b3d3fb20c830a983d4fd917af958a", "message": "Revert \":art: Minor improvements suggested in PR review.\"\n\nThis reverts commit 4fd734e5470f5a80b56e864fdf0ecc3738f4e011.", "committedDate": "2021-01-15T00:10:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NzI1NQ==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557787255", "bodyText": "\ud83d\ude04 (EDIT: I'd either rename this, make it final and use it in the subsequent for loop, or remove the variable entirely)", "author": "antares1470", "createdAt": "2021-01-15T00:29:02Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);", "originalCommit": "8cf373c1505b3d3fb20c830a983d4fd917af958a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjUzODgxMw==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r566538813", "bodyText": "haha yeah i've gone ahead and deleted it.", "author": "Nova-2119", "createdAt": "2021-01-29T02:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NzI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjU0NDM4NQ==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r566544385", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2021-01-29T02:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NzI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODM3MA==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557788370", "bodyText": "can use the primitive type here", "author": "antares1470", "createdAt": "2021-01-15T00:33:00Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);\n+            if (graph.getVertexNeighbourCount(vertexId) >= minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == vertexId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == vertexId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final Map<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+        private Boolean recalculateMagnitude = true;", "originalCommit": "8cf373c1505b3d3fb20c830a983d4fd917af958a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjU0NDQzMw==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r566544433", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2021-01-29T02:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODg0NQ==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r557788845", "bodyText": "can omit == true from if condition", "author": "antares1470", "createdAt": "2021-01-15T00:34:40Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/similarity/CosineSimilarityPlugin.java", "diffHunk": "@@ -109,94 +110,132 @@ public void edit(final GraphWriteMethods graph, final PluginInteraction interact\n \n         // map each vertex to its neighbour count\n         final int vertexCount = graph.getVertexCount();\n-        final int[][] neighbourWeights = new int[vertexCount][vertexCount];\n-        final BitSet[] neighbours = new BitSet[vertexCount];\n-        final BitSet update = new BitSet(vertexCount);\n-        final BitSet selected = new BitSet(vertexCount);\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            neighbours[vertexPosition] = new BitSet(vertexCount);\n-            for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) {\n-                final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n-                final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+        final List<VertexWithNeighbours> verticiesWithNeighbours = new ArrayList<>();\n \n-                if (vertexPosition == neighbourPosition) {\n-                    continue;\n-                }\n+        VertexWithNeighbours currentVertexWithNeighbour;\n+        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) { //For each vertex\n+            currentVertexWithNeighbour = null;\n+            final int vertexId = graph.getVertex(vertexPosition);\n+            \n+            int vertexNeighbourCount = 0;\n+            int bleh = graph.getVertexNeighbourCount(vertexId);\n+            if (graph.getVertexNeighbourCount(vertexId) >= minCommonFeatures){ //Quick defeat, if there arnt enough potential neighbours to achieve the minimal common features then dont process the vertex.\n+                for (int vertexNeighbourPosition = 0; vertexNeighbourPosition < graph.getVertexNeighbourCount(vertexId); vertexNeighbourPosition++) { //For each neighbour\n+                    final int neighbourId = graph.getVertexNeighbour(vertexId, vertexNeighbourPosition);\n+                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n+\n+                    if (vertexPosition == neighbourPosition) {\n+                        // Exclude self  \n+                        continue;\n+                    }\n \n-                final int linkId = graph.getLink(vertexId, neighbourId);\n-                for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n-                    final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n-                    final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                    final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n-                            || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == neighbourId\n-                            || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == neighbourId);\n-                    if (isRequestedDirection) {\n-                        neighbourWeights[vertexPosition][neighbourPosition] += graph.getEdgeTransactionCount(edgeId);\n-                        neighbourWeights[vertexPosition][neighbourPosition] -= SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n-                        neighbours[vertexPosition].set(neighbourPosition, true);\n-                        update.set(vertexPosition, true);\n+                    final int linkId = graph.getLink(vertexId, neighbourId);\n+                    for (int linkEdgePosition = 0; linkEdgePosition < graph.getLinkEdgeCount(linkId); linkEdgePosition++) {\n+                        final int edgeId = graph.getLinkEdge(linkId, linkEdgePosition);\n+                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                        final boolean isRequestedDirection = (treatUndirectedBidirectional && edgeDirection == GraphConstants.UNDIRECTED\n+                                || includeConnectionsIn && graph.getEdgeDestinationVertex(edgeId) == vertexId\n+                                || includeConnectionsOut && graph.getEdgeSourceVertex(edgeId) == vertexId);\n+                        if (isRequestedDirection) { // If it is a neighbour we are interested in, based on whetehr we are interest in incoing or outoing neighbours.\n+                            // neighbour weight vertex-neighbour = Number of transaction of correct direction between them - number of transacions of type similarity.\n+                            if (currentVertexWithNeighbour == null) {\n+                                currentVertexWithNeighbour = new VertexWithNeighbours(vertexId, vertexCount, graph.getBooleanValue(vertexSelectedAttributeId, vertexId));\n+                            }\n+\n+                            final int weight = graph.getEdgeTransactionCount(edgeId) - SimilarityUtilities.countEdgeSimilarityTransactions(graph, edgeId);\n+                            currentVertexWithNeighbour.addNeighbour(neighbourPosition, weight);\n+                            vertexNeighbourCount+=1; // Found  valid neighbour so track this.\n+                        }\n                     }\n                 }\n             }\n-            final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-            selected.set(vertexPosition, vertexSelected);\n+            if (vertexNeighbourCount >= minCommonFeatures) {\n+                // Add vertex to list of verticies with neighbours IFF it has enough neighbours to potentially pass the minCommonFeatures test later.\n+                verticiesWithNeighbours.add(currentVertexWithNeighbour);\n+            }\n         }\n-\n+        // At this point:\n+        // neighbourweights[vertexPosition][neighbourposition] = number of relevant transactions between them - number of transaction of type similarity between them.\n+        // neighbours[vertexPosition] = bitset representing whetehr each vertex is a neighbour or not\n+        // update = bitset representing whether the vertex has any neighbours at all.\n+        \n+        SimilarityUtilities.setGraphAndEnsureAttributes(graph, COSINE_SIMILARITY_ATTRIBUTE);\n         // calculate cosine similarity for every pair of vertices on the graph\n-        final Map<Tuple<Integer, Integer>, Float> cosineSimilarities = new HashMap<>();\n-        for (int vertexOnePosition = update.nextSetBit(0); vertexOnePosition >= 0; vertexOnePosition = update.nextSetBit(vertexOnePosition + 1)) {\n-            for (int vertexTwoPosition = update.nextSetBit(0); vertexTwoPosition >= 0; vertexTwoPosition = update.nextSetBit(vertexTwoPosition + 1)) {\n-                if (!selectedOnly || (selected.get(vertexOnePosition) || selected.get(vertexTwoPosition))) {\n-                    if (vertexOnePosition >= vertexTwoPosition) {\n-                        continue;\n+        for (int leftIndex = 0; leftIndex < verticiesWithNeighbours.size()-1; leftIndex++) {\n+            final VertexWithNeighbours leftVertexWithNeighbours = verticiesWithNeighbours.get(leftIndex);\n+            for (int rightIndex = leftIndex+1; rightIndex < verticiesWithNeighbours.size(); rightIndex++) {\n+                final VertexWithNeighbours rightVertexWithNeighbours = verticiesWithNeighbours.get(rightIndex);\n+                if (!selectedOnly || leftVertexWithNeighbours.selected || rightVertexWithNeighbours.selected) { // if we care about selected ensure that one of the verticies is selected.\n+                    // Get a bitset that tells you which vertexPositions had both verticies as a neighbour.\n+                    final BitSet commonNeighbours = getCommonNeighbours(leftVertexWithNeighbours.neighbours, rightVertexWithNeighbours.neighbours);\n+                    \n+                    if (commonNeighbours.cardinality() >= minCommonFeatures) {\n+                        // If passes minCommonFeatures condition\n+                        final float neighbourDotProduct = getNeighbourDotProduct(leftVertexWithNeighbours, rightVertexWithNeighbours, commonNeighbours);\n+                        final float neighboursMagnitude = leftVertexWithNeighbours.getMagnitude() * rightVertexWithNeighbours.getMagnitude();\n+                        final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n+                        SimilarityUtilities.addScoreToGraph(leftVertexWithNeighbours.vertexId, rightVertexWithNeighbours.vertexId, cosineSimilarity);\n                     }\n-\n-                    final BitSet intersection = (BitSet) neighbours[vertexOnePosition].clone();\n-                    intersection.and(neighbours[vertexTwoPosition]);\n-\n-                    if (intersection.cardinality() < minCommonFeatures) {\n-                        continue;\n-                    }\n-\n-                    final int vertexOneId = graph.getVertex(vertexOnePosition);\n-                    final int[] neighboursOne = neighbourWeights[vertexOnePosition];\n-\n-                    final int vertexTwoId = graph.getVertex(vertexTwoPosition);\n-                    final int[] neighboursTwo = neighbourWeights[vertexTwoPosition];\n-\n-                    final float neighbourDotProduct = dot(neighboursOne, neighboursTwo);\n-                    final float neighboursMagnitude = magnitude(neighboursOne) * magnitude(neighboursTwo);\n-                    final float cosineSimilarity = neighboursMagnitude == 0 ? 0 : neighbourDotProduct / neighboursMagnitude;\n-                    cosineSimilarities.put(Tuple.create(vertexOneId, vertexTwoId), cosineSimilarity);\n                 }\n             }\n         }\n-\n-        // update the graph with cosine similarity values\n-        SimilarityUtilities.addScoresToGraph(graph, cosineSimilarities, COSINE_SIMILARITY_ATTRIBUTE);\n-\n         // complete with schema\n         PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n     }\n-\n-    private float dot(final int[] vectorOne, final int[] vectorTwo) {\n-        assert vectorOne.length == vectorTwo.length;\n-\n-        float dot = 0;\n-        for (int index = 0; index < vectorOne.length; index++) {\n-            dot += vectorOne[index] * vectorTwo[index];\n+    \n+    private class VertexWithNeighbours {\n+        private final int vertexId;\n+        private final Map<Integer, Integer> neighbourWeightsMap;\n+        private BitSet neighbours;\n+        private final boolean selected;\n+        private Float magnitude = null;\n+        private Boolean recalculateMagnitude = true;\n+\n+        public VertexWithNeighbours(final int vertexId, final int vertexCount, final boolean selected) {\n+            this.neighbourWeightsMap = new HashMap<>();\n+            this.vertexId = vertexId;\n+            this.selected = selected;\n+            this.neighbours = new BitSet(vertexCount);\n         }\n-\n-        return dot;\n+           \n+        private void addNeighbour(final int neighbourPosition, final int additionalWeight) {\n+            final int currentWeight = neighbourWeightsMap.getOrDefault(neighbourPosition, 0);\n+            neighbourWeightsMap.put(neighbourPosition,currentWeight + additionalWeight);\n+            neighbours.set(neighbourPosition, true);\n+            recalculateMagnitude = true;\n+        }\n+        \n+        private float getMagnitude() {\n+            if (recalculateMagnitude == true) {", "originalCommit": "8cf373c1505b3d3fb20c830a983d4fd917af958a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjU0NDQ1OA==", "url": "https://github.com/constellation-app/constellation/pull/908#discussion_r566544458", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2021-01-29T02:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODg0NQ=="}], "type": "inlineReview"}, {"oid": "07f7912282fc4605ef4aeee927440f77eba8d7e7", "url": "https://github.com/constellation-app/constellation/commit/07f7912282fc4605ef4aeee927440f77eba8d7e7", "message": ":art: Small changed recommended in PR\n\nRemoved unneeded line\nPrioritize primitve types where possible", "committedDate": "2021-01-29T02:44:45Z", "type": "commit"}, {"oid": "dae956cbc778a45f5d9322ca0d34da798fe76256", "url": "https://github.com/constellation-app/constellation/commit/dae956cbc778a45f5d9322ca0d34da798fe76256", "message": "Merge branch 'master' into performance/28-Cosine", "committedDate": "2021-01-29T02:44:58Z", "type": "commit"}, {"oid": "392033de180d77d20fc3a7e7cd8960292372a709", "url": "https://github.com/constellation-app/constellation/commit/392033de180d77d20fc3a7e7cd8960292372a709", "message": "Merge branch 'master' into performance/28-Cosine", "committedDate": "2021-03-17T22:03:33Z", "type": "commit"}]}