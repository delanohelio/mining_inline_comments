{"pr_number": 879, "pr_title": "Performance/838 multi threading", "pr_createdAt": "2020-10-27T02:56:39Z", "pr_url": "https://github.com/constellation-app/constellation/pull/879", "timeline": [{"oid": "d55f1a802ca28624e5706b12c225079b5835f661", "url": "https://github.com/constellation-app/constellation/commit/d55f1a802ca28624e5706b12c225079b5835f661", "message": ":art: :racehorse: Added updateModCounts method\n\nAdded method updateModCounts to allow for the modification counters to\nbe updated without triggering visual updates. This will be used when\nopening a graph for the first time top avoid unnecessary visual updates.\nGeneralised other update methods to allow for a graph argument to\nfacilitate this.", "committedDate": "2020-09-29T05:07:10Z", "type": "commit"}, {"oid": "5f35f14104e15a48ed654fe4799fc5ced6fbcf52", "url": "https://github.com/constellation-app/constellation/commit/5f35f14104e15a48ed654fe4799fc5ced6fbcf52", "message": ":art: :racehorse: Update modcounts of visualAccess when opening graph\n\nNow updates the modcounts of the GraphVisualAccess when constructing a \nvisualManager. This allows for the updateFromIndigenousChanges listener\nto be added without triggering every single visualUpdate.", "committedDate": "2020-09-29T05:09:22Z", "type": "commit"}, {"oid": "e2a31dec78606f4d2d90ff9bb98998b2d13725df", "url": "https://github.com/constellation-app/constellation/commit/e2a31dec78606f4d2d90ff9bb98998b2d13725df", "message": ":art: :racehorse: Added refreshVisualProcessor call\n\nAdded refreshVisualProcessor call to perform initial render of graph\nto the GLCanavas. This is required now that visualUpdates will not\nautomatically be triggered when opening a new graph. Testing shows this\nto be more performant. This makes sense as now it is performing the\nminimal number of visual updates that will render the graph to the \nscreen whereas perviously it would do more than required (duplicates).", "committedDate": "2020-09-29T05:11:44Z", "type": "commit"}, {"oid": "e95838292f549b4df7858225a90f23aa6e44d4d8", "url": "https://github.com/constellation-app/constellation/commit/e95838292f549b4df7858225a90f23aa6e44d4d8", "message": ":art: Deleted accidental blank line.", "committedDate": "2020-09-29T05:28:41Z", "type": "commit"}, {"oid": "7ce24a82c3a9d15b2e92b51d31e3076fb67ad675", "url": "https://github.com/constellation-app/constellation/commit/7ce24a82c3a9d15b2e92b51d31e3076fb67ad675", "message": ":art: Made variables final where appropriate as per feedback.", "committedDate": "2020-10-02T00:26:59Z", "type": "commit"}, {"oid": "57b7f50e554604767504ce605e659e4e9c70eba9", "url": "https://github.com/constellation-app/constellation/commit/57b7f50e554604767504ce605e659e4e9c70eba9", "message": ":racehorse: Moved rebuild from dispose to reshape.\n\nMoved rebuild from dispose method to reshape method. This will stop a\nrebuild from being triggered when a graph is closed and mean we can\nremove the refresh from VisualGraphTopCOmponent as opening a graph\ncalls reshape (but not dispose).", "committedDate": "2020-10-02T02:49:23Z", "type": "commit"}, {"oid": "b8c148542ba0ca83d9f47049f320658f4b18c969", "url": "https://github.com/constellation-app/constellation/commit/b8c148542ba0ca83d9f47049f320658f4b18c969", "message": ":racehorse: Moved rebuild from reshape to init.\n\nMoved rebuild from reshape method to init method it must be called \nafter a dispose to render the graph back to the screen (where the graph\nhasn't actually been closed). An init must always be called in this\nscenario.", "committedDate": "2020-10-02T05:42:11Z", "type": "commit"}, {"oid": "2da0bbc650dede26716c5f9ee290afaa8befba59", "url": "https://github.com/constellation-app/constellation/commit/2da0bbc650dede26716c5f9ee290afaa8befba59", "message": ":bug: Make addRectImage threadsafe\n\nMade addRectImage more threadsafe by combining check to see if hashCode is contained in memory and the action to add the hadCode to the memory if it isnt. This elimnated multithreading scenario where the same hashcode is added twice ( next check for the presence of the hashcode is completed before it previous check finished adding it to memory) and the ptr values becomes incorrect.", "committedDate": "2020-10-15T22:07:52Z", "type": "commit"}, {"oid": "a8285bd232e1fe538c93b401d3f4ef49e65db247", "url": "https://github.com/constellation-app/constellation/commit/a8285bd232e1fe538c93b401d3f4ef49e65db247", "message": ":art: Created GlyphStreamContext and NodeGlyphStreamContext\n\nCreated a GlyphStreamContext object which holds the information required by a GlyphStream to perform the compulsory methods. This will more easily allow for consistent method signatures across types of GlyphStreams.", "committedDate": "2020-10-15T22:12:35Z", "type": "commit"}, {"oid": "f7b6318bd5d9a349af37f42017c7746d62d939d5", "url": "https://github.com/constellation-app/constellation/commit/f7b6318bd5d9a349af37f42017c7746d62d939d5", "message": ":art: Created NodeGlyphStream\n\nCreated a NodeGlyphStream object which contains logig to adding glyphs to a glyphStream focussed on Nodes. This logic previously resided in NodeLabelBuffer. The creation of this object will allow for the glyphStream to be treated separately to the buffer.", "committedDate": "2020-10-15T22:14:49Z", "type": "commit"}, {"oid": "c304f4fb74d00f80995508c3c8b16322b6af653b", "url": "https://github.com/constellation-app/constellation/commit/c304f4fb74d00f80995508c3c8b16322b6af653b", "message": ":art: Accomodate new NodeGlyphStream and NodeGlyphStreamContext classes\n\nChanges to method signatures to add in new object types NodeGlyphStream and NodeGlyphStreamContext.\nNOTE: This commit does not contain all changes required for this. However other files have additional changes which should be explained in the commit.", "committedDate": "2020-10-15T22:17:34Z", "type": "commit"}, {"oid": "4668c45e0e5b6fcd58281a77de96f57de11e5264", "url": "https://github.com/constellation-app/constellation/commit/4668c45e0e5b6fcd58281a77de96f57de11e5264", "message": ":art: Accomodate new classes, make RenderTextAsLigatures threadsafe.\n\nChanges to method signatures to add in new object types NodeGlyphStream and NodeGlyphStreamContext.\nEliminate the reliance on class object drawing in method renderTextAsLigatures. Combined with changes to the methods which renderTextAsLigatures calls this has the affect of making the method more threadsafe.", "committedDate": "2020-10-15T22:19:45Z", "type": "commit"}, {"oid": "bdd133da9815750e3e4735d3b84254a2a9b52186", "url": "https://github.com/constellation-app/constellation/commit/bdd133da9815750e3e4735d3b84254a2a9b52186", "message": ":racehorse: Add multithreading to methods\n\nMade methods createBatch, fillTopLabels and fillBottomLabels multithreaded. This will improve the performance of these methods enabling faster application of graph changes. In particular refreshing the graph should be much quicker, leading to faster graph opening times.\nNOTE: The branch, including this commit and all previous should work, however there has been limited testing. It is likely that more changes will be made.", "committedDate": "2020-10-15T22:24:50Z", "type": "commit"}, {"oid": "4a3a130a179ec47faa1b879032ff1e0ea3d6b9b0", "url": "https://github.com/constellation-app/constellation/commit/4a3a130a179ec47faa1b879032ff1e0ea3d6b9b0", "message": ":arte: Incorporate GlyphStreamContext class\n\nChange to method signatures and small change to logic to incorporate the new GlyphStreamContextClass. Should have been added to previous commit.", "committedDate": "2020-10-16T06:40:16Z", "type": "commit"}, {"oid": "2e5beb10bfc3b8335f7f4a1467fbe26313c84bbe", "url": "https://github.com/constellation-app/constellation/commit/2e5beb10bfc3b8335f7f4a1467fbe26313c84bbe", "message": ":bug: Stronger synchronized condition to stop rare rendering bug\n\nCombined array specific locks into one stronger lock that ensures\naddition of nodes to both currentFloats and currentInts prior to allowing access to either. This seems to stop a glitch where characters would occasionally not appear in the node label when opening a graph.", "committedDate": "2020-10-20T00:45:49Z", "type": "commit"}, {"oid": "17d0d1a6a1e9046a1734db4b20f2ea88e5cddd64", "url": "https://github.com/constellation-app/constellation/commit/17d0d1a6a1e9046a1734db4b20f2ea88e5cddd64", "message": ":art: Make GlyphStreamContext attributes public, remove get/set\n\nMade GlyphStreamContext and child member variables public to improve\nreadability and ease of use.", "committedDate": "2020-10-20T04:51:13Z", "type": "commit"}, {"oid": "249379260648ecfd6bd68475855102d90012ea61", "url": "https://github.com/constellation-app/constellation/commit/249379260648ecfd6bd68475855102d90012ea61", "message": ":racehorse: Make ConnectionLabelBatcher multithreaded.\n\nUsing the same parent classes and principles used when multithreading NodeLabelBatcher I have multithreaded ConnectionGlyphStream. This improved the rendering time of graphs dominated by connection count rather than node count.", "committedDate": "2020-10-20T04:53:18Z", "type": "commit"}, {"oid": "4a0bdfd17f275b699f202a93afe23ab04b845582", "url": "https://github.com/constellation-app/constellation/commit/4a0bdfd17f275b699f202a93afe23ab04b845582", "message": ":racehorse: Multithread updateTop/BottomLabels\n\nupdateTopLabels and updateBottomLabels now use the multithreaded version of\nFillTopLabels and FillBottomLabels respectively, brining them in line with changes madde to createBatch.", "committedDate": "2020-10-20T20:47:25Z", "type": "commit"}, {"oid": "6e2457aed8d34e925ed56fa9941de09224f9c5b0", "url": "https://github.com/constellation-app/constellation/commit/6e2457aed8d34e925ed56fa9941de09224f9c5b0", "message": ":Art: Removing TODO comment (tried it)\n\nTried refactoring NodeLabelBatcher and NodeGlyphStream to run multiple\nnodeGlyphStreams independently and then combine them to eliminate the need to synchronize on addLock. There was no improvement in speed, however my implementation likely wasn't optimal.", "committedDate": "2020-10-20T21:47:17Z", "type": "commit"}, {"oid": "47adb98d6dcda0e10f488de3b63bcfb122b489a7", "url": "https://github.com/constellation-app/constellation/commit/47adb98d6dcda0e10f488de3b63bcfb122b489a7", "message": ":Art: Removing TODO comments (Done)", "committedDate": "2020-10-20T21:56:14Z", "type": "commit"}, {"oid": "5124a805c4ec20f1658ff01bc3550c77a5c542ac", "url": "https://github.com/constellation-app/constellation/commit/5124a805c4ec20f1658ff01bc3550c77a5c542ac", "message": ":Art: Changed thread pool size to number of cores.\n\nAll three multithreaded methods are entirely CPU dependent. In this scenario the accepted wisdom is to have a number of threads equal to the number of cores. Setting each to the number of cores isn't perfect (as often more than one of these methods will run, such as when opening a graph. There are also potentially threads already running.) however accurately acounting for each scenario is quite involved and as far as I can tell there should be minimal penalty for having a few too many threads.", "committedDate": "2020-10-21T00:37:54Z", "type": "commit"}, {"oid": "1e273a1845c90632eed74449bfc4666be61cc089", "url": "https://github.com/constellation-app/constellation/commit/1e273a1845c90632eed74449bfc4666be61cc089", "message": "Merge branch 'master' into performance/838-MultiThreading", "committedDate": "2020-10-26T21:02:33Z", "type": "commit"}, {"oid": "dd755f4485894f27970c8460446835fd357c9436", "url": "https://github.com/constellation-app/constellation/commit/dd755f4485894f27970c8460446835fd357c9436", "message": ":art: Throw errors up the stack\n\nNow throws interruption errors from the threads buffering the Node and Connection labels up the stack.", "committedDate": "2020-10-27T04:40:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4MjIzNg==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513782236", "bodyText": "add an interrupt to the catch block (Thread.currentThread().interrupt())", "author": "antares1470", "createdAt": "2020-10-28T21:48:31Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/GraphRenderable.java", "diffHunk": "@@ -159,7 +160,11 @@ VisualChangeProcessor getChangeProcessor(VisualProperty property) {\n                     addTask(iconBatcher.disposeBatch());\n                     addTask(iconBatcher.createBatch(access));\n                     addTask(nodeLabelBatcher.disposeBatch());\n-                    addTask(nodeLabelBatcher.createBatch(access));\n+                    try {\n+                        addTask(nodeLabelBatcher.createBatch(access));\n+                    } catch (InterruptedException ex) {", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4MjMyNg==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513782326", "bodyText": "same here", "author": "antares1470", "createdAt": "2020-10-28T21:48:42Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/GraphRenderable.java", "diffHunk": "@@ -179,7 +184,11 @@ VisualChangeProcessor getChangeProcessor(VisualProperty property) {\n                     addTask(loopBatcher.disposeBatch());\n                     addTask(loopBatcher.createBatch(access));\n                     addTask(connectionLabelBatcher.disposeBatch());\n-                    addTask(connectionLabelBatcher.createBatch(access));\n+                    try {\n+                        addTask(connectionLabelBatcher.createBatch(access));\n+                    } catch (InterruptedException ex) {", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4Mjk4Nw==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513782987", "bodyText": "Same here. I won't mark every place this should be done since there are a few more to go but if you could add that to all of those instances that would be good", "author": "antares1470", "createdAt": "2020-10-28T21:50:00Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/GraphRenderable.java", "diffHunk": "@@ -220,8 +229,12 @@ VisualChangeProcessor getChangeProcessor(VisualProperty property) {\n                 return (change, access) -> {\n                     addTask(nodeLabelBatcher.setBottomLabelColors(access));\n                     addTask(nodeLabelBatcher.setBottomLabelSizes(access));\n-                    // Note that updating bottom labels always rebuilds from scratch, so it is not an issue if the batch was not 'ready'.\n-                    addTask(nodeLabelBatcher.updateBottomLabels(access));\n+                    try {\n+                        // Note that updating bottom labels always rebuilds from scratch, so it is not an issue if the batch was not 'ready'.\n+                        addTask(nodeLabelBatcher.updateBottomLabels(access));\n+                    } catch (InterruptedException ex) {", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NDE4MA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513784180", "bodyText": "final", "author": "antares1470", "createdAt": "2020-10-28T21:52:20Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/ConnectionLabelBatcher.java", "diffHunk": "@@ -180,73 +143,64 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-\n-        attributeLabelFloats = new FloatArray();\n-        attributeLabelInts = new IntArray();\n-        summaryLabelFloats = new FloatArray();\n-        summaryLabelInts = new IntArray();\n-        fillLabels(access);\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n \n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NDQzMw==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513784433", "bodyText": "final", "author": "antares1470", "createdAt": "2020-10-28T21:52:54Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/ConnectionLabelBatcher.java", "diffHunk": "@@ -180,73 +143,64 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-\n-        attributeLabelFloats = new FloatArray();\n-        attributeLabelInts = new IntArray();\n-        summaryLabelFloats = new FloatArray();\n-        summaryLabelInts = new IntArray();\n-        fillLabels(access);\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n \n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();\n+        fillLabels(access, glyphStream);\n+        \n         return gl -> {\n-            attributeLabelBatch.initialise(attributeLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            attributeLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(attributeLabelInts.rawArray()));\n-            attributeLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(attributeLabelFloats.rawArray()));\n-            attributeLabelBatch.finalise(gl);\n-            summaryLabelBatch.initialise(summaryLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            summaryLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(summaryLabelInts.rawArray()));\n-            summaryLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(summaryLabelFloats.rawArray()));\n-            summaryLabelBatch.finalise(gl);\n+            labelBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFER_WIDTH);\n+            labelBatch.buffer(gl, intsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n+            labelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            labelBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        attributeLabelFloats.clear();\n-        attributeLabelInts.clear();\n-        fillLabels(access);\n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NTI3OA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513785278", "bodyText": "Either make final and rename to numCores to follow naming convention, or make this a static final constant (leaving the name as is). Whichever you think makes more sense", "author": "antares1470", "createdAt": "2020-10-28T21:54:40Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/ConnectionLabelBatcher.java", "diffHunk": "@@ -180,73 +143,64 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-\n-        attributeLabelFloats = new FloatArray();\n-        attributeLabelInts = new IntArray();\n-        summaryLabelFloats = new FloatArray();\n-        summaryLabelInts = new IntArray();\n-        fillLabels(access);\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n \n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();\n+        fillLabels(access, glyphStream);\n+        \n         return gl -> {\n-            attributeLabelBatch.initialise(attributeLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            attributeLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(attributeLabelInts.rawArray()));\n-            attributeLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(attributeLabelFloats.rawArray()));\n-            attributeLabelBatch.finalise(gl);\n-            summaryLabelBatch.initialise(summaryLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            summaryLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(summaryLabelInts.rawArray()));\n-            summaryLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(summaryLabelFloats.rawArray()));\n-            summaryLabelBatch.finalise(gl);\n+            labelBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFER_WIDTH);\n+            labelBatch.buffer(gl, intsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n+            labelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            labelBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        attributeLabelFloats.clear();\n-        attributeLabelInts.clear();\n-        fillLabels(access);\n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();\n+        fillLabels(access, glyphStream);\n         return gl -> {\n-            attributeLabelBatch.dispose(gl);\n-            attributeLabelBatch.initialise(attributeLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            attributeLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(attributeLabelInts.rawArray()));\n-            attributeLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(attributeLabelFloats.rawArray()));\n-            attributeLabelBatch.finalise(gl);\n-            summaryLabelBatch.dispose(gl);\n-            summaryLabelBatch.initialise(summaryLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            summaryLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(summaryLabelInts.rawArray()));\n-            summaryLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(summaryLabelFloats.rawArray()));\n-            summaryLabelBatch.finalise(gl);\n+            labelBatch.dispose(gl);\n+            labelBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFER_WIDTH);\n+            labelBatch.buffer(gl, intsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n+            labelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            labelBatch.finalise(gl);\n         };\n     }\n \n-    private void fillLabels(final VisualAccess access) {\n+    private void fillLabels(final VisualAccess access, ConnectionGlyphStream glyphStream) throws InterruptedException {\n+        int NUM_CORES = Runtime.getRuntime().availableProcessors();", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NTU3Ng==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513785576", "bodyText": "both of these can be final", "author": "antares1470", "createdAt": "2020-10-28T21:55:17Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/ConnectionLabelBatcher.java", "diffHunk": "@@ -180,73 +143,64 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-\n-        attributeLabelFloats = new FloatArray();\n-        attributeLabelInts = new IntArray();\n-        summaryLabelFloats = new FloatArray();\n-        summaryLabelInts = new IntArray();\n-        fillLabels(access);\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n \n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();\n+        fillLabels(access, glyphStream);\n+        \n         return gl -> {\n-            attributeLabelBatch.initialise(attributeLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            attributeLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(attributeLabelInts.rawArray()));\n-            attributeLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(attributeLabelFloats.rawArray()));\n-            attributeLabelBatch.finalise(gl);\n-            summaryLabelBatch.initialise(summaryLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            summaryLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(summaryLabelInts.rawArray()));\n-            summaryLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(summaryLabelFloats.rawArray()));\n-            summaryLabelBatch.finalise(gl);\n+            labelBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFER_WIDTH);\n+            labelBatch.buffer(gl, intsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n+            labelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            labelBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        attributeLabelFloats.clear();\n-        attributeLabelInts.clear();\n-        fillLabels(access);\n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();\n+        fillLabels(access, glyphStream);\n         return gl -> {\n-            attributeLabelBatch.dispose(gl);\n-            attributeLabelBatch.initialise(attributeLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            attributeLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(attributeLabelInts.rawArray()));\n-            attributeLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(attributeLabelFloats.rawArray()));\n-            attributeLabelBatch.finalise(gl);\n-            summaryLabelBatch.dispose(gl);\n-            summaryLabelBatch.initialise(summaryLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            summaryLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(summaryLabelInts.rawArray()));\n-            summaryLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(summaryLabelFloats.rawArray()));\n-            summaryLabelBatch.finalise(gl);\n+            labelBatch.dispose(gl);\n+            labelBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFER_WIDTH);\n+            labelBatch.buffer(gl, intsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n+            labelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            labelBatch.finalise(gl);\n         };\n     }\n \n-    private void fillLabels(final VisualAccess access) {\n+    private void fillLabels(final VisualAccess access, ConnectionGlyphStream glyphStream) throws InterruptedException {\n+        int NUM_CORES = Runtime.getRuntime().availableProcessors();\n+        ConnectionGlyphStreamContext context = new ConnectionGlyphStreamContext();\n+        ExecutorService pool = Executors.newFixedThreadPool(NUM_CORES);", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NTc1MA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513785750", "bodyText": "both of these can be final", "author": "antares1470", "createdAt": "2020-10-28T21:55:42Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/ConnectionLabelBatcher.java", "diffHunk": "@@ -180,73 +143,64 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-\n-        attributeLabelFloats = new FloatArray();\n-        attributeLabelInts = new IntArray();\n-        summaryLabelFloats = new FloatArray();\n-        summaryLabelInts = new IntArray();\n-        fillLabels(access);\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n \n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();\n+        fillLabels(access, glyphStream);\n+        \n         return gl -> {\n-            attributeLabelBatch.initialise(attributeLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            attributeLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(attributeLabelInts.rawArray()));\n-            attributeLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(attributeLabelFloats.rawArray()));\n-            attributeLabelBatch.finalise(gl);\n-            summaryLabelBatch.initialise(summaryLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            summaryLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(summaryLabelInts.rawArray()));\n-            summaryLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(summaryLabelFloats.rawArray()));\n-            summaryLabelBatch.finalise(gl);\n+            labelBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFER_WIDTH);\n+            labelBatch.buffer(gl, intsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n+            labelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            labelBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        attributeLabelFloats.clear();\n-        attributeLabelInts.clear();\n-        fillLabels(access);\n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();\n+        fillLabels(access, glyphStream);\n         return gl -> {\n-            attributeLabelBatch.dispose(gl);\n-            attributeLabelBatch.initialise(attributeLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            attributeLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(attributeLabelInts.rawArray()));\n-            attributeLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(attributeLabelFloats.rawArray()));\n-            attributeLabelBatch.finalise(gl);\n-            summaryLabelBatch.dispose(gl);\n-            summaryLabelBatch.initialise(summaryLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            summaryLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(summaryLabelInts.rawArray()));\n-            summaryLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(summaryLabelFloats.rawArray()));\n-            summaryLabelBatch.finalise(gl);\n+            labelBatch.dispose(gl);\n+            labelBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFER_WIDTH);\n+            labelBatch.buffer(gl, intsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n+            labelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            labelBatch.finalise(gl);\n         };\n     }\n \n-    private void fillLabels(final VisualAccess access) {\n+    private void fillLabels(final VisualAccess access, ConnectionGlyphStream glyphStream) throws InterruptedException {\n+        int NUM_CORES = Runtime.getRuntime().availableProcessors();\n+        ConnectionGlyphStreamContext context = new ConnectionGlyphStreamContext();\n+        ExecutorService pool = Executors.newFixedThreadPool(NUM_CORES);\n         for (int link = 0; link < access.getLinkCount(); link++) {\n             final int connectionCount = access.getLinkConnectionCount(link);\n-            setCurrentConnection(access.getLinkLowVertex(link), access.getLinkHighVertex(link), connectionCount);\n+            setCurrentConnection(access.getLinkLowVertex(link), access.getLinkHighVertex(link), connectionCount, context);\n             for (int pos = 0; pos < connectionCount; pos++) {\n                 final int connection = access.getLinkConnection(link, pos);\n-                nextParallelConnection((int) (LabelUtilities.NRADIUS_TO_LINE_WIDTH_UNITS * Math.min(LabelUtilities.MAX_TRANSACTION_WIDTH, access.getConnectionWidth(connection))));\n-                currentFloats = access.getIsLabelSummary(connection) ? summaryLabelFloats : attributeLabelFloats;\n-                currentInts = access.getIsLabelSummary(connection) ? summaryLabelInts : attributeLabelInts;\n-                currentLabelInfo = access.getIsLabelSummary(connection) ? summaryLabelInfo : attributeLabelInfoReference;\n-                bufferLabel(connection, access);\n+                nextParallelConnection((int) (LabelUtilities.NRADIUS_TO_LINE_WIDTH_UNITS * Math.min(LabelUtilities.MAX_TRANSACTION_WIDTH, access.getConnectionWidth(connection))), context);\n+                Matrix44f currentLabelInfo = access.getIsLabelSummary(connection) ? summaryLabelInfo : attributeLabelInfoReference;\n+                Thread bufferThread = new BufferLabel(connection, access, glyphStream, currentLabelInfo, context);", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4NjM0MA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513786340", "bodyText": "I know you didn't add this but if you could make this final that would be great", "author": "antares1470", "createdAt": "2020-10-28T21:57:05Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/ConnectionLabelBatcher.java", "diffHunk": "@@ -180,73 +143,64 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-\n-        attributeLabelFloats = new FloatArray();\n-        attributeLabelInts = new IntArray();\n-        summaryLabelFloats = new FloatArray();\n-        summaryLabelInts = new IntArray();\n-        fillLabels(access);\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n \n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();\n+        fillLabels(access, glyphStream);\n+        \n         return gl -> {\n-            attributeLabelBatch.initialise(attributeLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            attributeLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(attributeLabelInts.rawArray()));\n-            attributeLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(attributeLabelFloats.rawArray()));\n-            attributeLabelBatch.finalise(gl);\n-            summaryLabelBatch.initialise(summaryLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            summaryLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(summaryLabelInts.rawArray()));\n-            summaryLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(summaryLabelFloats.rawArray()));\n-            summaryLabelBatch.finalise(gl);\n+            labelBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFER_WIDTH);\n+            labelBatch.buffer(gl, intsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n+            labelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            labelBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        attributeLabelFloats.clear();\n-        attributeLabelInts.clear();\n-        fillLabels(access);\n+        ConnectionGlyphStream glyphStream = new ConnectionGlyphStream();\n+        fillLabels(access, glyphStream);\n         return gl -> {\n-            attributeLabelBatch.dispose(gl);\n-            attributeLabelBatch.initialise(attributeLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            attributeLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(attributeLabelInts.rawArray()));\n-            attributeLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(attributeLabelFloats.rawArray()));\n-            attributeLabelBatch.finalise(gl);\n-            summaryLabelBatch.dispose(gl);\n-            summaryLabelBatch.initialise(summaryLabelFloats.size() / FLOAT_BUFFER_WIDTH);\n-            summaryLabelBatch.buffer(gl, intsTarget, IntBuffer.wrap(summaryLabelInts.rawArray()));\n-            summaryLabelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(summaryLabelFloats.rawArray()));\n-            summaryLabelBatch.finalise(gl);\n+            labelBatch.dispose(gl);\n+            labelBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFER_WIDTH);\n+            labelBatch.buffer(gl, intsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n+            labelBatch.buffer(gl, floatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            labelBatch.finalise(gl);\n         };\n     }\n \n-    private void fillLabels(final VisualAccess access) {\n+    private void fillLabels(final VisualAccess access, ConnectionGlyphStream glyphStream) throws InterruptedException {\n+        int NUM_CORES = Runtime.getRuntime().availableProcessors();\n+        ConnectionGlyphStreamContext context = new ConnectionGlyphStreamContext();\n+        ExecutorService pool = Executors.newFixedThreadPool(NUM_CORES);\n         for (int link = 0; link < access.getLinkCount(); link++) {\n             final int connectionCount = access.getLinkConnectionCount(link);\n-            setCurrentConnection(access.getLinkLowVertex(link), access.getLinkHighVertex(link), connectionCount);\n+            setCurrentConnection(access.getLinkLowVertex(link), access.getLinkHighVertex(link), connectionCount, context);\n             for (int pos = 0; pos < connectionCount; pos++) {\n                 final int connection = access.getLinkConnection(link, pos);\n-                nextParallelConnection((int) (LabelUtilities.NRADIUS_TO_LINE_WIDTH_UNITS * Math.min(LabelUtilities.MAX_TRANSACTION_WIDTH, access.getConnectionWidth(connection))));\n-                currentFloats = access.getIsLabelSummary(connection) ? summaryLabelFloats : attributeLabelFloats;\n-                currentInts = access.getIsLabelSummary(connection) ? summaryLabelInts : attributeLabelInts;\n-                currentLabelInfo = access.getIsLabelSummary(connection) ? summaryLabelInfo : attributeLabelInfoReference;\n-                bufferLabel(connection, access);\n+                nextParallelConnection((int) (LabelUtilities.NRADIUS_TO_LINE_WIDTH_UNITS * Math.min(LabelUtilities.MAX_TRANSACTION_WIDTH, access.getConnectionWidth(connection))), context);\n+                Matrix44f currentLabelInfo = access.getIsLabelSummary(connection) ? summaryLabelInfo : attributeLabelInfoReference;\n+                Thread bufferThread = new BufferLabel(connection, access, glyphStream, currentLabelInfo, context);\n+                pool.submit(bufferThread);\n             }\n+\n         }\n-        attributeLabelFloats.trimToSize();\n-        attributeLabelInts.trimToSize();\n-        summaryLabelFloats.trimToSize();\n-        summaryLabelInts.trimToSize();\n+        pool.shutdown();\n+        pool.awaitTermination(10, TimeUnit.MINUTES);\n+            \n+        glyphStream.trimToSize();\n     }\n \n-    private void bufferLabel(final int pos, final VisualAccess access) {\n+    private void bufferLabel(final int pos, final VisualAccess access, final ConnectionGlyphStream glyphStream, Matrix44f currentLabelInfo, final ConnectionGlyphStreamContext context) {\n         int totalScale = 0;\n-        final float visibility = access.getConnectionVisibility(pos);\n+        context.visibility = access.getConnectionVisibility(pos);\n         for (int label = 0; label < access.getConnectionLabelCount(pos); label++) {\n+            context.labelNumber = label;\n             final String text = access.getConnectionLabelText(pos, label);\n             ArrayList<String> lines = LabelUtilities.splitTextIntoLines(text);", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4ODQwMQ==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513788401", "bodyText": "This and the thread above can be final", "author": "antares1470", "createdAt": "2020-10-28T22:01:41Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -145,99 +124,114 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n+        final NodeGlyphStream topGlyphStream = new NodeGlyphStream();\n+        final NodeGlyphStream bottomGlyphStream = new NodeGlyphStream();\n+        \n+        Thread topLabelThread = new FillTopLabels(access, topGlyphStream);\n+        topLabelThread.start();\n+        \n+        Thread bottomLabelThread = new FillBottomLabels(access, bottomGlyphStream);", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4ODUwMA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513788500", "bodyText": "both final", "author": "antares1470", "createdAt": "2020-10-28T22:01:55Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -145,99 +124,114 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n+        final NodeGlyphStream topGlyphStream = new NodeGlyphStream();\n+        final NodeGlyphStream bottomGlyphStream = new NodeGlyphStream();\n+        \n+        Thread topLabelThread = new FillTopLabels(access, topGlyphStream);\n+        topLabelThread.start();\n+        \n+        Thread bottomLabelThread = new FillBottomLabels(access, bottomGlyphStream);\n+        bottomLabelThread.start();\n+                    \n+        topLabelThread.join();\n+        bottomLabelThread.join();\n         \n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n-        fillBottomLabels(access, bottomLabelFloats, bottomLabelInts);\n-\n         return gl -> {\n-            topBatch.initialise(topLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topLabelFloats.rawArray()));\n-            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topLabelInts.rawArray()));\n+            topBatch.initialise(topGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topGlyphStream.getCurrentFloats().rawArray()));\n+            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topGlyphStream.getCurrentInts().rawArray()));\n             topBatch.finalise(gl);\n-            bottomBatch.initialise(bottomLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomLabelFloats.rawArray()));\n-            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomLabelInts.rawArray()));\n+            bottomBatch.initialise(bottomGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomGlyphStream.getCurrentFloats().rawArray()));\n+            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomGlyphStream.getCurrentInts().rawArray()));\n             bottomBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n+        NodeGlyphStream glyphStream = new NodeGlyphStream();\n+        Thread topLabelThread = new FillTopLabels(access, glyphStream);", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4ODYwNA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513788604", "bodyText": "both final", "author": "antares1470", "createdAt": "2020-10-28T22:02:08Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -145,99 +124,114 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n+        final NodeGlyphStream topGlyphStream = new NodeGlyphStream();\n+        final NodeGlyphStream bottomGlyphStream = new NodeGlyphStream();\n+        \n+        Thread topLabelThread = new FillTopLabels(access, topGlyphStream);\n+        topLabelThread.start();\n+        \n+        Thread bottomLabelThread = new FillBottomLabels(access, bottomGlyphStream);\n+        bottomLabelThread.start();\n+                    \n+        topLabelThread.join();\n+        bottomLabelThread.join();\n         \n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n-        fillBottomLabels(access, bottomLabelFloats, bottomLabelInts);\n-\n         return gl -> {\n-            topBatch.initialise(topLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topLabelFloats.rawArray()));\n-            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topLabelInts.rawArray()));\n+            topBatch.initialise(topGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topGlyphStream.getCurrentFloats().rawArray()));\n+            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topGlyphStream.getCurrentInts().rawArray()));\n             topBatch.finalise(gl);\n-            bottomBatch.initialise(bottomLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomLabelFloats.rawArray()));\n-            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomLabelInts.rawArray()));\n+            bottomBatch.initialise(bottomGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomGlyphStream.getCurrentFloats().rawArray()));\n+            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomGlyphStream.getCurrentInts().rawArray()));\n             bottomBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n+        NodeGlyphStream glyphStream = new NodeGlyphStream();\n+        Thread topLabelThread = new FillTopLabels(access, glyphStream);\n+        topLabelThread.start();\n+\n+        topLabelThread.join();\n+\n         return gl -> {\n             topBatch.dispose(gl);\n-            topBatch.initialise(topLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topLabelFloats.rawArray()));\n-            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topLabelInts.rawArray()));\n+            topBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n             topBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateBottomLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateBottomLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n-        fillBottomLabels(access, bottomLabelFloats, bottomLabelInts);\n+        NodeGlyphStream glyphStream = new NodeGlyphStream();\n+        Thread bottomLabelThread = new FillBottomLabels(access, glyphStream);", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4ODY5MA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513788690", "bodyText": "final", "author": "antares1470", "createdAt": "2020-10-28T22:02:21Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -145,99 +124,114 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n+        final NodeGlyphStream topGlyphStream = new NodeGlyphStream();\n+        final NodeGlyphStream bottomGlyphStream = new NodeGlyphStream();\n+        \n+        Thread topLabelThread = new FillTopLabels(access, topGlyphStream);\n+        topLabelThread.start();\n+        \n+        Thread bottomLabelThread = new FillBottomLabels(access, bottomGlyphStream);\n+        bottomLabelThread.start();\n+                    \n+        topLabelThread.join();\n+        bottomLabelThread.join();\n         \n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n-        fillBottomLabels(access, bottomLabelFloats, bottomLabelInts);\n-\n         return gl -> {\n-            topBatch.initialise(topLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topLabelFloats.rawArray()));\n-            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topLabelInts.rawArray()));\n+            topBatch.initialise(topGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topGlyphStream.getCurrentFloats().rawArray()));\n+            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topGlyphStream.getCurrentInts().rawArray()));\n             topBatch.finalise(gl);\n-            bottomBatch.initialise(bottomLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomLabelFloats.rawArray()));\n-            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomLabelInts.rawArray()));\n+            bottomBatch.initialise(bottomGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomGlyphStream.getCurrentFloats().rawArray()));\n+            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomGlyphStream.getCurrentInts().rawArray()));\n             bottomBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n+        NodeGlyphStream glyphStream = new NodeGlyphStream();\n+        Thread topLabelThread = new FillTopLabels(access, glyphStream);\n+        topLabelThread.start();\n+\n+        topLabelThread.join();\n+\n         return gl -> {\n             topBatch.dispose(gl);\n-            topBatch.initialise(topLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topLabelFloats.rawArray()));\n-            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topLabelInts.rawArray()));\n+            topBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n             topBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateBottomLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateBottomLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n-        fillBottomLabels(access, bottomLabelFloats, bottomLabelInts);\n+        NodeGlyphStream glyphStream = new NodeGlyphStream();\n+        Thread bottomLabelThread = new FillBottomLabels(access, glyphStream);\n+        bottomLabelThread.start();\n+\n+        bottomLabelThread.join();\n+\n         return gl -> {\n             bottomBatch.dispose(gl);\n-            bottomBatch.initialise(bottomLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomLabelFloats.rawArray()));\n-            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomLabelInts.rawArray()));\n+            bottomBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n             bottomBatch.finalise(gl);\n         };\n     }\n     \n-    private void fillTopLabels(final VisualAccess access, final FloatArray topLabelFloats, final IntArray topLabelInts) {\n-        currentFloats = topLabelFloats;\n-        currentInts = topLabelInts;\n+    private void fillTopLabels(final VisualAccess access, NodeGlyphStream glyphStream) throws InterruptedException {\n+        ExecutorService pool = Executors.newFixedThreadPool(NUM_CORES);  ", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4ODczNw==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513788737", "bodyText": "final", "author": "antares1470", "createdAt": "2020-10-28T22:02:29Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -145,99 +124,114 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n+        final NodeGlyphStream topGlyphStream = new NodeGlyphStream();\n+        final NodeGlyphStream bottomGlyphStream = new NodeGlyphStream();\n+        \n+        Thread topLabelThread = new FillTopLabels(access, topGlyphStream);\n+        topLabelThread.start();\n+        \n+        Thread bottomLabelThread = new FillBottomLabels(access, bottomGlyphStream);\n+        bottomLabelThread.start();\n+                    \n+        topLabelThread.join();\n+        bottomLabelThread.join();\n         \n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n-        fillBottomLabels(access, bottomLabelFloats, bottomLabelInts);\n-\n         return gl -> {\n-            topBatch.initialise(topLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topLabelFloats.rawArray()));\n-            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topLabelInts.rawArray()));\n+            topBatch.initialise(topGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topGlyphStream.getCurrentFloats().rawArray()));\n+            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topGlyphStream.getCurrentInts().rawArray()));\n             topBatch.finalise(gl);\n-            bottomBatch.initialise(bottomLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomLabelFloats.rawArray()));\n-            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomLabelInts.rawArray()));\n+            bottomBatch.initialise(bottomGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomGlyphStream.getCurrentFloats().rawArray()));\n+            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomGlyphStream.getCurrentInts().rawArray()));\n             bottomBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n+        NodeGlyphStream glyphStream = new NodeGlyphStream();\n+        Thread topLabelThread = new FillTopLabels(access, glyphStream);\n+        topLabelThread.start();\n+\n+        topLabelThread.join();\n+\n         return gl -> {\n             topBatch.dispose(gl);\n-            topBatch.initialise(topLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topLabelFloats.rawArray()));\n-            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topLabelInts.rawArray()));\n+            topBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n             topBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateBottomLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateBottomLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n-        fillBottomLabels(access, bottomLabelFloats, bottomLabelInts);\n+        NodeGlyphStream glyphStream = new NodeGlyphStream();\n+        Thread bottomLabelThread = new FillBottomLabels(access, glyphStream);\n+        bottomLabelThread.start();\n+\n+        bottomLabelThread.join();\n+\n         return gl -> {\n             bottomBatch.dispose(gl);\n-            bottomBatch.initialise(bottomLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomLabelFloats.rawArray()));\n-            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomLabelInts.rawArray()));\n+            bottomBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n             bottomBatch.finalise(gl);\n         };\n     }\n     \n-    private void fillTopLabels(final VisualAccess access, final FloatArray topLabelFloats, final IntArray topLabelInts) {\n-        currentFloats = topLabelFloats;\n-        currentInts = topLabelInts;\n+    private void fillTopLabels(final VisualAccess access, NodeGlyphStream glyphStream) throws InterruptedException {\n+        ExecutorService pool = Executors.newFixedThreadPool(NUM_CORES);  \n         for (int pos = 0; pos < access.getVertexCount(); pos++) {\n-            bufferTopLabel(pos, access);\n+            Thread thread = new BufferTopLabel(pos, access, glyphStream);", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4ODg2Mw==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513788863", "bodyText": "this and pool can be final", "author": "antares1470", "createdAt": "2020-10-28T22:02:49Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -145,99 +124,114 @@ public void createShader(GL3 gl) throws IOException {\n     }\n \n     @Override\n-    public GLRenderableUpdateTask createBatch(final VisualAccess access) {\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n+    public GLRenderableUpdateTask createBatch(final VisualAccess access) throws InterruptedException {\n+        final NodeGlyphStream topGlyphStream = new NodeGlyphStream();\n+        final NodeGlyphStream bottomGlyphStream = new NodeGlyphStream();\n+        \n+        Thread topLabelThread = new FillTopLabels(access, topGlyphStream);\n+        topLabelThread.start();\n+        \n+        Thread bottomLabelThread = new FillBottomLabels(access, bottomGlyphStream);\n+        bottomLabelThread.start();\n+                    \n+        topLabelThread.join();\n+        bottomLabelThread.join();\n         \n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n-        fillBottomLabels(access, bottomLabelFloats, bottomLabelInts);\n-\n         return gl -> {\n-            topBatch.initialise(topLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topLabelFloats.rawArray()));\n-            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topLabelInts.rawArray()));\n+            topBatch.initialise(topGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topGlyphStream.getCurrentFloats().rawArray()));\n+            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topGlyphStream.getCurrentInts().rawArray()));\n             topBatch.finalise(gl);\n-            bottomBatch.initialise(bottomLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomLabelFloats.rawArray()));\n-            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomLabelInts.rawArray()));\n+            bottomBatch.initialise(bottomGlyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomGlyphStream.getCurrentFloats().rawArray()));\n+            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomGlyphStream.getCurrentInts().rawArray()));\n             bottomBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateTopLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        final FloatArray topLabelFloats = new FloatArray();\n-        final IntArray topLabelInts = new IntArray();\n-        fillTopLabels(access, topLabelFloats, topLabelInts);\n+        NodeGlyphStream glyphStream = new NodeGlyphStream();\n+        Thread topLabelThread = new FillTopLabels(access, glyphStream);\n+        topLabelThread.start();\n+\n+        topLabelThread.join();\n+\n         return gl -> {\n             topBatch.dispose(gl);\n-            topBatch.initialise(topLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(topLabelFloats.rawArray()));\n-            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(topLabelInts.rawArray()));\n+            topBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            topBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            topBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n             topBatch.finalise(gl);\n         };\n     }\n \n-    public GLRenderableUpdateTask updateBottomLabels(final VisualAccess access) {\n+    public GLRenderableUpdateTask updateBottomLabels(final VisualAccess access) throws InterruptedException {\n         // We build the whole batch again - can't update labels in place at this stage.\n-        final FloatArray bottomLabelFloats = new FloatArray();\n-        final IntArray bottomLabelInts = new IntArray();\n-        fillBottomLabels(access, bottomLabelFloats, bottomLabelInts);\n+        NodeGlyphStream glyphStream = new NodeGlyphStream();\n+        Thread bottomLabelThread = new FillBottomLabels(access, glyphStream);\n+        bottomLabelThread.start();\n+\n+        bottomLabelThread.join();\n+\n         return gl -> {\n             bottomBatch.dispose(gl);\n-            bottomBatch.initialise(bottomLabelFloats.size() / FLOAT_BUFFERS_WIDTH);\n-            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(bottomLabelFloats.rawArray()));\n-            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(bottomLabelInts.rawArray()));\n+            bottomBatch.initialise(glyphStream.getCurrentFloats().size() / FLOAT_BUFFERS_WIDTH);\n+            bottomBatch.buffer(gl, labelFloatsTarget, FloatBuffer.wrap(glyphStream.getCurrentFloats().rawArray()));\n+            bottomBatch.buffer(gl, labelIntsTarget, IntBuffer.wrap(glyphStream.getCurrentInts().rawArray()));\n             bottomBatch.finalise(gl);\n         };\n     }\n     \n-    private void fillTopLabels(final VisualAccess access, final FloatArray topLabelFloats, final IntArray topLabelInts) {\n-        currentFloats = topLabelFloats;\n-        currentInts = topLabelInts;\n+    private void fillTopLabels(final VisualAccess access, NodeGlyphStream glyphStream) throws InterruptedException {\n+        ExecutorService pool = Executors.newFixedThreadPool(NUM_CORES);  \n         for (int pos = 0; pos < access.getVertexCount(); pos++) {\n-            bufferTopLabel(pos, access);\n+            Thread thread = new BufferTopLabel(pos, access, glyphStream);\n+            pool.submit(thread);\n         }\n-        topLabelFloats.trimToSize();\n-        topLabelInts.trimToSize();\n+        pool.shutdown();\n+\n+        pool.awaitTermination(10, TimeUnit.MINUTES);\n+\n+        glyphStream.trimToSize();\n     }\n \n-    private void fillBottomLabels(final VisualAccess access, final FloatArray bottomLabelFloats, final IntArray bottomLabelInts) {\n-        currentFloats = bottomLabelFloats;\n-        currentInts = bottomLabelInts;\n+    private void fillBottomLabels(final VisualAccess access, NodeGlyphStream glyphStream) throws InterruptedException {\n+        ExecutorService pool = Executors.newFixedThreadPool(NUM_CORES);  \n+        \n         for (int pos = 0; pos < access.getVertexCount(); pos++) {\n-            bufferBottomLabel(pos, access);\n+            Thread thread = new BufferBottomLabel(pos, access, glyphStream);", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4OTE2Nw==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513789167", "bodyText": "swap the modifiers around on both of these to be private final", "author": "antares1470", "createdAt": "2020-10-28T22:03:36Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -340,4 +334,75 @@ public void drawBatch(final GL3 gl, final Camera camera, final Matrix44f mvMatri\n             }\n         }\n     }\n-}\n+\n+    \n+    class FillTopLabels extends Thread {\n+        final private VisualAccess access;\n+        final private NodeGlyphStream glyphStream;", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4OTIzOA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513789238", "bodyText": "same here", "author": "antares1470", "createdAt": "2020-10-28T22:03:47Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -340,4 +334,75 @@ public void drawBatch(final GL3 gl, final Camera camera, final Matrix44f mvMatri\n             }\n         }\n     }\n-}\n+\n+    \n+    class FillTopLabels extends Thread {\n+        final private VisualAccess access;\n+        final private NodeGlyphStream glyphStream;\n+        \n+        FillTopLabels(final VisualAccess access, final NodeGlyphStream glyphStream) {\n+            this.access = access;\n+            this.glyphStream = glyphStream;\n+        }\n+   \n+        public void run() {\n+            try {\n+                fillTopLabels(access, glyphStream);\n+            } catch (InterruptedException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+    }   \n+    \n+    class FillBottomLabels extends Thread {\n+            final private VisualAccess access;\n+            final private NodeGlyphStream glyphStream;", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4OTMxNQ==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513789315", "bodyText": "same here", "author": "antares1470", "createdAt": "2020-10-28T22:03:57Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -340,4 +334,75 @@ public void drawBatch(final GL3 gl, final Camera camera, final Matrix44f mvMatri\n             }\n         }\n     }\n-}\n+\n+    \n+    class FillTopLabels extends Thread {\n+        final private VisualAccess access;\n+        final private NodeGlyphStream glyphStream;\n+        \n+        FillTopLabels(final VisualAccess access, final NodeGlyphStream glyphStream) {\n+            this.access = access;\n+            this.glyphStream = glyphStream;\n+        }\n+   \n+        public void run() {\n+            try {\n+                fillTopLabels(access, glyphStream);\n+            } catch (InterruptedException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+    }   \n+    \n+    class FillBottomLabels extends Thread {\n+            final private VisualAccess access;\n+            final private NodeGlyphStream glyphStream;\n+\n+            FillBottomLabels(final VisualAccess access, final NodeGlyphStream glyphStream) {\n+                this.access = access;\n+                this.glyphStream = glyphStream;\n+            }\n+\n+            public void run() {\n+                try {\n+                    fillBottomLabels(access, glyphStream);\n+                } catch (InterruptedException ex) {\n+                    Exceptions.printStackTrace(ex);\n+                }\n+            }\n+    }\n+    \n+    class BufferBottomLabel extends Thread {\n+        final private int pos;\n+        final private VisualAccess access;\n+        final private NodeGlyphStream glyphStream;", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4OTM1OA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513789358", "bodyText": "same here", "author": "antares1470", "createdAt": "2020-10-28T22:04:05Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/renderer/batcher/NodeLabelBatcher.java", "diffHunk": "@@ -340,4 +334,75 @@ public void drawBatch(final GL3 gl, final Camera camera, final Matrix44f mvMatri\n             }\n         }\n     }\n-}\n+\n+    \n+    class FillTopLabels extends Thread {\n+        final private VisualAccess access;\n+        final private NodeGlyphStream glyphStream;\n+        \n+        FillTopLabels(final VisualAccess access, final NodeGlyphStream glyphStream) {\n+            this.access = access;\n+            this.glyphStream = glyphStream;\n+        }\n+   \n+        public void run() {\n+            try {\n+                fillTopLabels(access, glyphStream);\n+            } catch (InterruptedException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+    }   \n+    \n+    class FillBottomLabels extends Thread {\n+            final private VisualAccess access;\n+            final private NodeGlyphStream glyphStream;\n+\n+            FillBottomLabels(final VisualAccess access, final NodeGlyphStream glyphStream) {\n+                this.access = access;\n+                this.glyphStream = glyphStream;\n+            }\n+\n+            public void run() {\n+                try {\n+                    fillBottomLabels(access, glyphStream);\n+                } catch (InterruptedException ex) {\n+                    Exceptions.printStackTrace(ex);\n+                }\n+            }\n+    }\n+    \n+    class BufferBottomLabel extends Thread {\n+        final private int pos;\n+        final private VisualAccess access;\n+        final private NodeGlyphStream glyphStream;\n+        \n+        BufferBottomLabel(final int pos, final VisualAccess access, final NodeGlyphStream glyphStream){\n+            this.pos = pos;\n+            this.access = access;\n+            this.glyphStream = glyphStream;\n+        }\n+        \n+        public void run() {\n+            bufferBottomLabel(pos, access, glyphStream);\n+        }\n+        \n+    }\n+\n+    class BufferTopLabel extends Thread {\n+        final private int pos;\n+        final private VisualAccess access;\n+        final private NodeGlyphStream glyphStream;", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4OTQ5Ng==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513789496", "bodyText": "final", "author": "antares1470", "createdAt": "2020-10-28T22:04:22Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/utilities/glyphs/ConnectionGlyphStream.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.visual.opengl.utilities.glyphs;\n+\n+import au.gov.asd.tac.constellation.utilities.graphics.FloatArray;\n+import au.gov.asd.tac.constellation.utilities.graphics.IntArray;\n+import au.gov.asd.tac.constellation.visual.opengl.renderer.batcher.ConnectionLabelBatcher;\n+import static au.gov.asd.tac.constellation.visual.opengl.renderer.batcher.ConnectionLabelBatcher.MAX_STAGGERS;\n+import au.gov.asd.tac.constellation.visual.opengl.utilities.SharedDrawable;\n+\n+/**\n+ *\n+ * @author Nova\n+ */\n+public class ConnectionGlyphStream implements GlyphManager.GlyphStream {\n+    \n+    private final FloatArray currentFloats;\n+    private final IntArray currentInts;\n+    private float currentWidth;\n+    private Object addLock = new Object();\n+\n+    public ConnectionGlyphStream() {\n+        this.currentFloats = new FloatArray();\n+        this.currentInts = new IntArray();\n+    }\n+    \n+    \n+    @Override\n+    public void addGlyph(int glyphPosition, float x, float y, final GlyphStreamContext streamContext) {\n+        if (streamContext instanceof ConnectionGlyphStreamContext) {\n+            ConnectionGlyphStreamContext context = (ConnectionGlyphStreamContext) streamContext;", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4OTU2MA==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513789560", "bodyText": "final", "author": "antares1470", "createdAt": "2020-10-28T22:04:31Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/utilities/glyphs/ConnectionGlyphStream.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.visual.opengl.utilities.glyphs;\n+\n+import au.gov.asd.tac.constellation.utilities.graphics.FloatArray;\n+import au.gov.asd.tac.constellation.utilities.graphics.IntArray;\n+import au.gov.asd.tac.constellation.visual.opengl.renderer.batcher.ConnectionLabelBatcher;\n+import static au.gov.asd.tac.constellation.visual.opengl.renderer.batcher.ConnectionLabelBatcher.MAX_STAGGERS;\n+import au.gov.asd.tac.constellation.visual.opengl.utilities.SharedDrawable;\n+\n+/**\n+ *\n+ * @author Nova\n+ */\n+public class ConnectionGlyphStream implements GlyphManager.GlyphStream {\n+    \n+    private final FloatArray currentFloats;\n+    private final IntArray currentInts;\n+    private float currentWidth;\n+    private Object addLock = new Object();\n+\n+    public ConnectionGlyphStream() {\n+        this.currentFloats = new FloatArray();\n+        this.currentInts = new IntArray();\n+    }\n+    \n+    \n+    @Override\n+    public void addGlyph(int glyphPosition, float x, float y, final GlyphStreamContext streamContext) {\n+        if (streamContext instanceof ConnectionGlyphStreamContext) {\n+            ConnectionGlyphStreamContext context = (ConnectionGlyphStreamContext) streamContext;\n+            synchronized(addLock) {\n+                currentFloats.add(currentWidth, x, y, context.visibility);\n+                currentInts.add(context.currentLowNodeId, context.currentHighNodeId, (context.currentOffset << 16) + (context.totalScale << 2) + context.labelNumber, (glyphPosition << 8) + context.currentStagger * 256 / (Math.min(context.currentLinkLabelCount, ConnectionLabelBatcher.MAX_STAGGERS) + 1));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void newLine(float width, final GlyphStreamContext streamContext) {\n+        if (streamContext instanceof ConnectionGlyphStreamContext) {\n+            ConnectionGlyphStreamContext context = (ConnectionGlyphStreamContext) streamContext;", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4OTk5Ng==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513789996", "bodyText": "final", "author": "antares1470", "createdAt": "2020-10-28T22:05:29Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/utilities/glyphs/NodeGlyphStream.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.visual.opengl.utilities.glyphs;\n+\n+import au.gov.asd.tac.constellation.utilities.graphics.FloatArray;\n+import au.gov.asd.tac.constellation.utilities.graphics.IntArray;\n+import au.gov.asd.tac.constellation.visual.opengl.utilities.SharedDrawable;\n+\n+/**\n+ * Glyph stream used when buffering Node Labels.\n+ * \n+ * @author Nova\n+ */\n+public class NodeGlyphStream implements GlyphManager.GlyphStream {\n+\n+    private final FloatArray currentFloats;\n+    private final IntArray currentInts;\n+    private final Object addLock = new Object();\n+\n+    public NodeGlyphStream() {\n+        this.currentFloats = new FloatArray();\n+        this.currentInts = new IntArray();\n+    }\n+    \n+    \n+    @Override\n+    public void addGlyph(final int glyphPosition, final float x, final float y, final GlyphStreamContext streamContext) {\n+        if (streamContext instanceof NodeGlyphStreamContext){\n+            NodeGlyphStreamContext context = (NodeGlyphStreamContext) streamContext;", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5MDA3Mg==", "url": "https://github.com/constellation-app/constellation/pull/879#discussion_r513790072", "bodyText": "final", "author": "antares1470", "createdAt": "2020-10-28T22:05:37Z", "path": "CoreOpenGLDisplay/src/au/gov/asd/tac/constellation/visual/opengl/utilities/glyphs/NodeGlyphStream.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.visual.opengl.utilities.glyphs;\n+\n+import au.gov.asd.tac.constellation.utilities.graphics.FloatArray;\n+import au.gov.asd.tac.constellation.utilities.graphics.IntArray;\n+import au.gov.asd.tac.constellation.visual.opengl.utilities.SharedDrawable;\n+\n+/**\n+ * Glyph stream used when buffering Node Labels.\n+ * \n+ * @author Nova\n+ */\n+public class NodeGlyphStream implements GlyphManager.GlyphStream {\n+\n+    private final FloatArray currentFloats;\n+    private final IntArray currentInts;\n+    private final Object addLock = new Object();\n+\n+    public NodeGlyphStream() {\n+        this.currentFloats = new FloatArray();\n+        this.currentInts = new IntArray();\n+    }\n+    \n+    \n+    @Override\n+    public void addGlyph(final int glyphPosition, final float x, final float y, final GlyphStreamContext streamContext) {\n+        if (streamContext instanceof NodeGlyphStreamContext){\n+            NodeGlyphStreamContext context = (NodeGlyphStreamContext) streamContext;\n+            synchronized(addLock) {\n+                currentFloats.add(glyphPosition, x, y, context.visibility);\n+                currentInts.add(context.currentNodeID, context.totalScale, context.labelNumber, 0);\n+            }\n+        }\n+        else {\n+            throw new IllegalArgumentException(\"Provided context lacks Node information, please use a NodeGlyphStreamContext\");\n+        }\n+    }\n+\n+    @Override\n+    public void newLine(float width, final GlyphStreamContext streamContext) {\n+        if (streamContext instanceof NodeGlyphStreamContext) {\n+            NodeGlyphStreamContext context = (NodeGlyphStreamContext) streamContext;", "originalCommit": "dd755f4485894f27970c8460446835fd357c9436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "43355e77197bd0cb3ab3f4e7e91953fc95a7f49a", "url": "https://github.com/constellation-app/constellation/commit/43355e77197bd0cb3ab3f4e7e91953fc95a7f49a", "message": "Updates to address review feedback", "committedDate": "2020-11-08T11:03:39Z", "type": "commit"}, {"oid": "1aea8397d2b687fc6a62477407717add6b6cbf81", "url": "https://github.com/constellation-app/constellation/commit/1aea8397d2b687fc6a62477407717add6b6cbf81", "message": ":shirt: Fix some SQ warnings", "committedDate": "2020-11-08T14:11:46Z", "type": "commit"}]}