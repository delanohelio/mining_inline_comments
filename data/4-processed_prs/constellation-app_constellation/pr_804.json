{"pr_number": 804, "pr_title": "Bugfix/issue793 class cast exception", "pr_createdAt": "2020-08-24T03:50:51Z", "pr_url": "https://github.com/constellation-app/constellation/pull/804", "timeline": [{"oid": "1cc12dfa63e3a3bacfb6e110e08912959af3aeeb", "url": "https://github.com/constellation-app/constellation/commit/1cc12dfa63e3a3bacfb6e110e08912959af3aeeb", "message": ":art: Added equals method.\nAdded equals method to ElementTypeParameterValue to allow for accurate\nusage of ArrayList.contains and other similiar methods dependent\non an equals method. Important for compatibility with \nsingleChoiceParameterValue's.", "committedDate": "2020-08-24T03:42:39Z", "type": "commit"}, {"oid": "8e6adfe955a21905f7fb5c91a8a58f4f7dcf2864", "url": "https://github.com/constellation-app/constellation/commit/8e6adfe955a21905f7fb5c91a8a58f4f7dcf2864", "message": ":bug: Casting compatibility check in setObjectValue.\nsetObjectValue now performs an instanceof check prior to trying to \ndown cast an object to a more specific class.\nAdded logic to allow for either a full SingleChoiceParameterValue or\njust a choice to be provided in the method.", "committedDate": "2020-08-24T03:45:59Z", "type": "commit"}, {"oid": "344cfbcfa6713bc95a242091463d52a9f7bf9ce7", "url": "https://github.com/constellation-app/constellation/commit/344cfbcfa6713bc95a242091463d52a9f7bf9ce7", "message": ":art: Added getSpatialReference method\nCan now get the spatialReference value without needing to first return\nit as an object and then cast it.", "committedDate": "2020-08-24T06:46:10Z", "type": "commit"}, {"oid": "166b92e0d0d724a5978ef9471632489092265e05", "url": "https://github.com/constellation-app/constellation/commit/166b92e0d0d724a5978ef9471632489092265e05", "message": ":art: Added getGraphElementType method\nCan now get the graphElement value without needing to first return\nit as an object and then cast it.", "committedDate": "2020-08-24T06:47:00Z", "type": "commit"}, {"oid": "27cde2221f99d6820cf4be79d5d888e1128bda56", "url": "https://github.com/constellation-app/constellation/commit/27cde2221f99d6820cf4be79d5d888e1128bda56", "message": ":bug: Added type asserts before down casting\nAdded assert to ensure type prior to casting.", "committedDate": "2020-08-24T06:47:55Z", "type": "commit"}, {"oid": "dfd4704faf26b055988364d1c126242797a20b87", "url": "https://github.com/constellation-app/constellation/commit/dfd4704faf26b055988364d1c126242797a20b87", "message": ":art: Refactored to use the parameter value\nRefactored part of the code to use the parameterValue and increase\nreadability.", "committedDate": "2020-08-24T22:57:00Z", "type": "commit"}, {"oid": "0df07e55aee704ceeb49af7334f0f67fed1dcd74", "url": "https://github.com/constellation-app/constellation/commit/0df07e55aee704ceeb49af7334f0f67fed1dcd74", "message": "Merge branch 'master' into bugfix/Issue793-classCastException", "committedDate": "2020-08-24T22:57:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjA0Mjc4OQ==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r476042789", "bodyText": "Could be worth a check but potentially you may be able to replace ? with SingleChoiceParameterValue here? If so, this would save the need to do the assert later on (and potentially even the type cast)", "author": "antares1470", "createdAt": "2020-08-25T01:34:29Z", "path": "CorePluginFramework/src/au/gov/asd/tac/constellation/plugins/gui/SingleChoiceInputPane.java", "diffHunk": "@@ -115,42 +115,42 @@ public SingleChoiceInputPane(final PluginParameter<SingleChoiceParameterValue> p\n             SingleChoiceParameterType.setChoiceData(parameter, field.getSelectionModel().getSelectedItem());\n         });\n \n-        parameter.addListener((final PluginParameter<?> parameter1, final ParameterChange change) -> {\n+        parameter.addListener((final PluginParameter<?> scParameter, final ParameterChange change) -> {", "originalCommit": "0df07e55aee704ceeb49af7334f0f67fed1dcd74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk4ODg1Mg==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r476988852", "bodyText": "When I tired it errors on compile :(", "author": "Nova-2119", "createdAt": "2020-08-26T02:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjA0Mjc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyNzEyNA==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r477627124", "bodyText": "ah never mind then", "author": "antares1470", "createdAt": "2020-08-26T22:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjA0Mjc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2NjQ0OQ==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r476966449", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-26T01:50:33Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/geospatial/AbstractGeoExportPlugin.java", "diffHunk": "@@ -1,454 +1,457 @@\n-/*\n- * Copyright 2010-2020 Australian Signals Directorate\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\n-\n-import au.gov.asd.tac.constellation.graph.Graph;\n-import au.gov.asd.tac.constellation.graph.GraphAttribute;\n-import au.gov.asd.tac.constellation.graph.GraphConstants;\n-import au.gov.asd.tac.constellation.graph.GraphElementType;\n-import au.gov.asd.tac.constellation.graph.GraphReadMethods;\n-import au.gov.asd.tac.constellation.graph.ReadableGraph;\n-import au.gov.asd.tac.constellation.graph.manager.GraphManager;\n-import au.gov.asd.tac.constellation.graph.node.GraphNode;\n-import au.gov.asd.tac.constellation.graph.processing.GraphRecordStoreUtilities;\n-import au.gov.asd.tac.constellation.graph.schema.analytic.concept.SpatialConcept;\n-import au.gov.asd.tac.constellation.graph.schema.visual.concept.VisualConcept;\n-import au.gov.asd.tac.constellation.plugins.PluginException;\n-import au.gov.asd.tac.constellation.plugins.PluginInteraction;\n-import au.gov.asd.tac.constellation.plugins.PluginNotificationLevel;\n-import static au.gov.asd.tac.constellation.plugins.importexport.geospatial.AbstractGeoExportPlugin.ELEMENT_TYPE_PARAMETER_ID;\n-import static au.gov.asd.tac.constellation.plugins.importexport.geospatial.AbstractGeoExportPlugin.OUTPUT_PARAMETER_ID;\n-import au.gov.asd.tac.constellation.plugins.logging.ConstellationLoggerHelper;\n-import au.gov.asd.tac.constellation.plugins.parameters.ParameterChange;\n-import au.gov.asd.tac.constellation.plugins.parameters.PluginParameter;\n-import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.BooleanParameterType;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.BooleanParameterType.BooleanParameterValue;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.ElementTypeParameterValue;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.FileParameterType;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.FileParameterType.FileParameterValue;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.GraphAttributeParameterValue;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.MultiChoiceParameterType;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.MultiChoiceParameterType.MultiChoiceParameterValue;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType.SingleChoiceParameterValue;\n-import au.gov.asd.tac.constellation.plugins.templates.SimpleReadPlugin;\n-import au.gov.asd.tac.constellation.utilities.datastructure.Tuple;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape.GeometryType;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-import javafx.stage.FileChooser.ExtensionFilter;\n-import org.apache.commons.lang3.StringUtils;\n-\n-/**\n- * Abstract geo export plugin.\n- *\n- * @author cygnus_x-1\n- */\n-public abstract class AbstractGeoExportPlugin extends SimpleReadPlugin {\n-\n-    public static final String OUTPUT_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"output\");\n-    public static final String SPATIAL_REFERENCE_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"spatial_reference\");\n-    public static final String ELEMENT_TYPE_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"element_type\");\n-    public static final String ATTRIBUTES_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"attributes\");\n-    public static final String SELECTED_ONLY_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"selected_only\");\n-\n-    /**\n-     * A {@link ExtensionFilter} specifying the file extension of the exported\n-     * file.\n-     *\n-     * @return an {@link ExtensionFilter}\n-     */\n-    protected abstract ExtensionFilter getExportType();\n-\n-    /**\n-     *\n-     * @param parameters\n-     * @param uuid\n-     * @param shapes\n-     * @param attributes\n-     * @param output\n-     * @throws IOException\n-     */\n-    protected abstract void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException;\n-\n-    /**\n-     * Determines whether the spatial reference parameter is active for this\n-     * plugin.\n-     *\n-     * @return true is spatial reference should be included, false otherwise\n-     */\n-    protected boolean includeSpatialReference() {\n-        return false;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"fallthrough\") //the fallthrough at the switch statement is intentional\n-    public PluginParameters createParameters() {\n-        final PluginParameters parameters = new PluginParameters();\n-\n-        final PluginParameter<FileParameterValue> outputParameter = FileParameterType.build(OUTPUT_PARAMETER_ID);\n-        outputParameter.setName(\"Output File\");\n-        outputParameter.setDescription(\"The name of the output file\");\n-        FileParameterType.setKind(outputParameter, FileParameterType.FileParameterKind.SAVE);\n-        FileParameterType.setFileFilters(outputParameter, getExportType());\n-        parameters.addParameter(outputParameter);\n-\n-        if (includeSpatialReference()) {\n-            final PluginParameter<SingleChoiceParameterValue> spatialReferenceParameter = SingleChoiceParameterType.build(SPATIAL_REFERENCE_PARAMETER_ID, SpatialReferenceParameterValue.class);\n-            spatialReferenceParameter.setName(\"Spatial Reference\");\n-            spatialReferenceParameter.setDescription(\"The spatial reference to use for the geopackage\");\n-            final List<SpatialReferenceParameterValue> spatialReferences = Arrays.asList(Shape.SpatialReference.values()).stream()\n-                    .map(spatialReference -> new SpatialReferenceParameterValue(spatialReference)).collect(Collectors.toList());\n-            SingleChoiceParameterType.setOptionsData(spatialReferenceParameter, spatialReferences);\n-            SingleChoiceParameterType.setChoiceData(spatialReferenceParameter, spatialReferences.get(0));\n-            parameters.addParameter(spatialReferenceParameter);\n-        }\n-\n-        final PluginParameter<SingleChoiceParameterValue> elementTypeParameter = SingleChoiceParameterType.build(ELEMENT_TYPE_PARAMETER_ID, ElementTypeParameterValue.class);\n-        elementTypeParameter.setName(\"Element Type\");\n-        elementTypeParameter.setDescription(\"The graph element type\");\n-        final List<ElementTypeParameterValue> elementTypes = new ArrayList<>();\n-        elementTypes.add(new ElementTypeParameterValue(GraphElementType.TRANSACTION));\n-        elementTypes.add(new ElementTypeParameterValue(GraphElementType.VERTEX));\n-        SingleChoiceParameterType.setOptionsData(elementTypeParameter, elementTypes);\n-        parameters.addParameter(elementTypeParameter);\n-\n-        final PluginParameter<MultiChoiceParameterValue> attributesParameter = MultiChoiceParameterType.build(ATTRIBUTES_PARAMETER_ID, GraphAttributeParameterValue.class);\n-        attributesParameter.setName(\"Attributes\");\n-        attributesParameter.setDescription(\"The list of attribute names to include in the export\");\n-        attributesParameter.setEnabled(false);\n-        parameters.addParameter(attributesParameter);\n-\n-        final PluginParameter<BooleanParameterValue> selectedOnlyParameter = BooleanParameterType.build(SELECTED_ONLY_PARAMETER_ID);\n-        selectedOnlyParameter.setName(\"Selected Only\");\n-        selectedOnlyParameter.setDescription(\"If True, only export the selected nodes. The default is False.\");\n-        selectedOnlyParameter.setBooleanValue(false);\n-        parameters.addParameter(selectedOnlyParameter);\n-\n-        parameters.addController(ELEMENT_TYPE_PARAMETER_ID, (master, params, change) -> {\n-            if (change == ParameterChange.VALUE) {\n-                final Graph activeGraph = GraphManager.getDefault().getActiveGraph();\n-                if (activeGraph != null) {\n-\n-                    // create options by getting attributes for the chosen element type from the graph\n-                    final List<GraphAttributeParameterValue> attributeOptions = new ArrayList<>();\n-                    final ReadableGraph readableGraph = activeGraph.getReadableGraph();\n-                    try {\n-                        final GraphElementType elementType = (GraphElementType) ((ElementTypeParameterValue) params.get(master.getId()).getObjectValue()).getObjectValue();\n-                        switch (elementType) {\n-                            case TRANSACTION:\n-                                final int transactionAttributeCount = readableGraph.getAttributeCount(GraphElementType.TRANSACTION);\n-                                for (int attributePosition = 0; attributePosition < transactionAttributeCount; attributePosition++) {\n-                                    final int attributeId = readableGraph.getAttribute(GraphElementType.TRANSACTION, attributePosition);\n-                                    final GraphAttribute graphAttribute = new GraphAttribute(readableGraph, attributeId);\n-                                    attributeOptions.add(new GraphAttributeParameterValue(graphAttribute));\n-                                }\n-                            // fall through\n-                            case VERTEX:\n-                                final int vertexAttributeCount = readableGraph.getAttributeCount(GraphElementType.VERTEX);\n-                                for (int attributePosition = 0; attributePosition < vertexAttributeCount; attributePosition++) {\n-                                    final int attributeId = readableGraph.getAttribute(GraphElementType.VERTEX, attributePosition);\n-                                    final GraphAttribute graphAttribute = new GraphAttribute(readableGraph, attributeId);\n-                                    attributeOptions.add(new GraphAttributeParameterValue(graphAttribute));\n-                                }\n-                                break;\n-                            default:\n-                                return;\n-                        }\n-                    } finally {\n-                        readableGraph.release();\n-                    }\n-\n-                    // create choices by deselecting lowercase attributes by default\n-                    final List<GraphAttributeParameterValue> attributeChoices = attributeOptions.stream()\n-                            .filter(attributeOption -> !((GraphAttribute) attributeOption.getObjectValue()).getName().matches(\"[a-z]{1}.*\"))\n-                            .collect(Collectors.toList());\n-\n-                    // sort options and choices lists\n-                    Collections.sort(attributeOptions);\n-                    Collections.sort(attributeChoices);\n-\n-                    // update attributes parameter\n-                    @SuppressWarnings(\"unchecked\") // Attrbutes_Parameter is created as a MultiChoice parameter in this class on line 137.\n-                    final PluginParameter<MultiChoiceParameterValue> updatedAttributesParameter = (PluginParameter<MultiChoiceParameterValue>) params.get(ATTRIBUTES_PARAMETER_ID);\n-                    MultiChoiceParameterType.setOptionsData(updatedAttributesParameter, attributeOptions);\n-                    MultiChoiceParameterType.setChoicesData(updatedAttributesParameter, attributeChoices);\n-                    updatedAttributesParameter.setEnabled(true);\n-                }\n-            }\n-        });\n-\n-        return parameters;\n-    }\n-\n-    @Override\n-    public void read(final GraphReadMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n-        final File output = new File(parameters.getStringValue(OUTPUT_PARAMETER_ID));\n-        final GraphElementType elementType = (GraphElementType) ((ElementTypeParameterValue) parameters.getSingleChoice(ELEMENT_TYPE_PARAMETER_ID)).getObjectValue();\n-        final List<GraphAttribute> graphAttributes = parameters.getMultiChoiceValue(ATTRIBUTES_PARAMETER_ID).getChoicesData().stream()\n-                .map(attributeChoice -> (GraphAttribute) ((GraphAttributeParameterValue) attributeChoice).getObjectValue())\n-                .collect(Collectors.toList());\n-        final boolean selectedOnly = parameters.getBooleanValue(SELECTED_ONLY_PARAMETER_ID);\n-\n-        final int vertexIdentifierAttributeId = VisualConcept.VertexAttribute.IDENTIFIER.get(graph);\n-        final int vertexSelectedAttributeId = VisualConcept.VertexAttribute.SELECTED.get(graph);\n-        final int vertexLatitudeAttributeId = SpatialConcept.VertexAttribute.LATITUDE.get(graph);\n-        final int vertexLongitudeAttributeId = SpatialConcept.VertexAttribute.LONGITUDE.get(graph);\n-        final int vertexShapeAttributeId = SpatialConcept.VertexAttribute.SHAPE.get(graph);\n-        final int transactionIdentifierAttributeId = VisualConcept.TransactionAttribute.IDENTIFIER.get(graph);\n-        final int transactionSelectedAttributeId = VisualConcept.TransactionAttribute.SELECTED.get(graph);\n-        final int transactionLatitudeAttributeId = SpatialConcept.TransactionAttribute.LATITUDE.get(graph);\n-        final int transactionLongitudeAttributeId = SpatialConcept.TransactionAttribute.LONGITUDE.get(graph);\n-        final int transactionShapeAttributeId = SpatialConcept.TransactionAttribute.SHAPE.get(graph);\n-\n-        final Map<String, String> shapes = new HashMap<>();\n-        final Map<String, Map<String, Object>> attributes = new HashMap<>();\n-\n-        switch (elementType) {\n-            case VERTEX:\n-                final int vertexCount = graph.getVertexCount();\n-                for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-                    final int vertexId = graph.getVertex(vertexPosition);\n-                    final boolean vertexSelected = graph.getBooleanValue(vertexSelectedAttributeId, vertexId);\n-                    final String vertexIdentifier = graph.getStringValue(vertexIdentifierAttributeId, vertexId);\n-                    final Float vertexLatitude = vertexLatitudeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getObjectValue(vertexLatitudeAttributeId, vertexId);\n-                    final Float vertexLongitude = vertexLongitudeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getObjectValue(vertexLongitudeAttributeId, vertexId);\n-                    final String vertexShape = vertexShapeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getStringValue(vertexShapeAttributeId, vertexId);\n-\n-                    // if the vertex represents a valid geospatial shape, record it\n-                    boolean shapeFound = false;\n-                    if ((!selectedOnly || vertexSelected) && StringUtils.isNotBlank(vertexShape)\n-                            && Shape.isValidGeoJson(vertexShape)) {\n-                        shapes.put(vertexIdentifier, vertexShape);\n-                        shapeFound = true;\n-                    } else if ((!selectedOnly || vertexSelected) && vertexLatitude != null && vertexLongitude != null) {\n-                        try {\n-                            final String vertexPoint = Shape.generateShape(vertexIdentifier, GeometryType.POINT, Arrays.asList(Tuple.create((double) vertexLongitude, (double) vertexLatitude)));\n-                            shapes.put(vertexIdentifier, vertexPoint);\n-                            shapeFound = true;\n-                        } catch (IOException ex) {\n-                            throw new PluginException(PluginNotificationLevel.ERROR, ex);\n-                        }\n-                    }\n-\n-                    // ... and record all its attributes\n-                    if (shapeFound) {\n-                        final Map<String, Object> attributeMap = new HashMap<>();\n-                        for (final GraphAttribute graphAttribute : graphAttributes) {\n-                            final Object attributeValue = graph.getObjectValue(graphAttribute.getId(), vertexId);\n-                            attributeMap.put(graphAttribute.getName(), attributeValue);\n-                        }\n-                        attributes.put(vertexIdentifier, attributeMap);\n-                    }\n-                }\n-                break;\n-            case TRANSACTION:\n-                final int transactionCount = graph.getTransactionCount();\n-                for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                    final int transactionId = graph.getTransaction(transactionPosition);\n-                    final boolean transactionSelected = graph.getBooleanValue(transactionSelectedAttributeId, transactionId);\n-                    final String transactionIdentifier = graph.getStringValue(transactionIdentifierAttributeId, transactionId);\n-                    final Float transactionLatitude = transactionLatitudeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getObjectValue(transactionLatitudeAttributeId, transactionId);\n-                    final Float transactionLongitude = transactionLongitudeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getObjectValue(transactionLongitudeAttributeId, transactionId);\n-                    final String transactionShape = transactionShapeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getStringValue(transactionShapeAttributeId, transactionId);\n-\n-                    final int sourceVertexId = graph.getTransactionSourceVertex(transactionId);\n-                    final String sourceVertexIdentifier = graph.getStringValue(vertexIdentifierAttributeId, sourceVertexId);\n-                    final Float sourceVertexLatitude = vertexLatitudeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getObjectValue(vertexLatitudeAttributeId, sourceVertexId);\n-                    final Float sourceVertexLongitude = vertexLongitudeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getObjectValue(vertexLongitudeAttributeId, sourceVertexId);\n-                    final String sourceVertexShape = vertexShapeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getStringValue(vertexShapeAttributeId, sourceVertexId);\n-\n-                    final int destinationVertexId = graph.getTransactionDestinationVertex(transactionId);\n-                    final String destinationVertexIdentifier = graph.getStringValue(vertexIdentifierAttributeId, destinationVertexId);\n-                    final Float destinationVertexLatitude = vertexLatitudeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getObjectValue(vertexLatitudeAttributeId, destinationVertexId);\n-                    final Float destinationVertexLongitude = vertexLongitudeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getObjectValue(vertexLongitudeAttributeId, destinationVertexId);\n-                    final String destinationVertexShape = vertexShapeAttributeId == GraphConstants.NOT_FOUND ? null\n-                            : graph.getStringValue(vertexShapeAttributeId, destinationVertexId);\n-\n-                    // if the transaction represents a valid geospatial shape, record it\n-                    boolean shapeFound = false;\n-                    if ((!selectedOnly || transactionSelected) && StringUtils.isNotBlank(transactionShape)\n-                            && Shape.isValidGeoJson(transactionShape)) {\n-                        shapes.put(transactionIdentifier, transactionShape);\n-                        shapeFound = true;\n-                    } else if ((!selectedOnly || transactionSelected) && transactionLatitude != null && transactionLongitude != null) {\n-                        try {\n-                            final String transactionPoint = Shape.generateShape(transactionIdentifier, GeometryType.POINT, Arrays.asList(Tuple.create((double) transactionLongitude, (double) transactionLatitude)));\n-                            shapes.put(transactionIdentifier, transactionPoint);\n-                            shapeFound = true;\n-                        } catch (IOException ex) {\n-                            throw new PluginException(PluginNotificationLevel.ERROR, ex);\n-                        }\n-                    }\n-\n-                    // ... and record all its attributes\n-                    if (shapeFound) {\n-                        final Map<String, Object> attributeMap = new HashMap<>();\n-                        final int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n-                        for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n-                            final int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n-                            final String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n-                            if (Character.isUpperCase(transactionAttributeName.charAt(0))) {\n-                                final Object transactionAttributeValue = graph.getObjectValue(transactionAttributeId, transactionId);\n-                                attributeMap.put(GraphRecordStoreUtilities.TRANSACTION + transactionAttributeName, transactionAttributeValue);\n-                            }\n-                        }\n-                        final int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n-                        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n-                            final int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n-                            final String sourceVertexAttributeName = graph.getAttributeName(vertexAttributeId);\n-                            if (Character.isUpperCase(sourceVertexAttributeName.charAt(0))) {\n-                                final Object sourceVertexAttributeValue = graph.getObjectValue(vertexAttributeId, sourceVertexId);\n-                                attributeMap.put(GraphRecordStoreUtilities.SOURCE + sourceVertexAttributeName, sourceVertexAttributeValue);\n-                            }\n-                            final String destinationVertexAttributeName = graph.getAttributeName(vertexAttributeId);\n-                            if (Character.isUpperCase(destinationVertexAttributeName.charAt(0))) {\n-                                final Object destinationVertexAttributeValue = graph.getObjectValue(vertexAttributeId, destinationVertexId);\n-                                attributeMap.put(GraphRecordStoreUtilities.DESTINATION + destinationVertexAttributeName, destinationVertexAttributeValue);\n-                            }\n-                        }\n-                        attributes.put(transactionIdentifier, attributeMap);\n-                    }\n-\n-                    // if the source vertex represents a valid geospatial shape, record it\n-                    shapeFound = false;\n-                    if ((!selectedOnly || transactionSelected) && StringUtils.isNotBlank(sourceVertexShape)\n-                            && Shape.isValidGeoJson(sourceVertexShape)) {\n-                        shapes.put(sourceVertexIdentifier, sourceVertexShape);\n-                        shapeFound = true;\n-                    } else if ((!selectedOnly || transactionSelected) && sourceVertexLatitude != null && sourceVertexLongitude != null) {\n-                        try {\n-                            final String vertexPoint = Shape.generateShape(sourceVertexIdentifier, GeometryType.POINT, Arrays.asList(Tuple.create((double) sourceVertexLongitude, (double) sourceVertexLatitude)));\n-                            shapes.put(sourceVertexIdentifier, vertexPoint);\n-                            shapeFound = true;\n-                        } catch (IOException ex) {\n-                            throw new PluginException(PluginNotificationLevel.ERROR, ex);\n-                        }\n-                    }\n-\n-                    // ... and record all its attributes\n-                    if (shapeFound) {\n-                        final Map<String, Object> attributeMap = new HashMap<>();\n-                        final int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n-                        for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n-                            final int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n-                            final String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n-                            if (Character.isUpperCase(transactionAttributeName.charAt(0))) {\n-                                final Object transactionAttributeValue = graph.getObjectValue(transactionAttributeId, transactionId);\n-                                attributeMap.put(GraphRecordStoreUtilities.TRANSACTION + transactionAttributeName, transactionAttributeValue);\n-                            }\n-                        }\n-                        final int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n-                        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n-                            final int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n-                            final String sourceVertexAttributeName = graph.getAttributeName(vertexAttributeId);\n-                            if (Character.isUpperCase(sourceVertexAttributeName.charAt(0))) {\n-                                final Object sourceVertexAttributeValue = graph.getObjectValue(vertexAttributeId, sourceVertexId);\n-                                attributeMap.put(GraphRecordStoreUtilities.SOURCE + sourceVertexAttributeName, sourceVertexAttributeValue);\n-                            }\n-                            final String destinationVertexAttributeName = graph.getAttributeName(vertexAttributeId);\n-                            if (Character.isUpperCase(destinationVertexAttributeName.charAt(0))) {\n-                                final Object destinationVertexAttributeValue = graph.getObjectValue(vertexAttributeId, destinationVertexId);\n-                                attributeMap.put(GraphRecordStoreUtilities.DESTINATION + destinationVertexAttributeName, destinationVertexAttributeValue);\n-                            }\n-                        }\n-                        attributes.put(sourceVertexIdentifier, attributeMap);\n-                    }\n-\n-                    // if the destination vertex represents a valid geospatial shape, record it\n-                    shapeFound = false;\n-                    if ((!selectedOnly || transactionSelected) && StringUtils.isNotBlank(destinationVertexShape)\n-                            && Shape.isValidGeoJson(destinationVertexShape)) {\n-                        shapes.put(destinationVertexIdentifier, destinationVertexShape);\n-                        shapeFound = true;\n-                    } else if ((!selectedOnly || transactionSelected) && destinationVertexLatitude != null && destinationVertexLongitude != null) {\n-                        try {\n-                            final String vertexPoint = Shape.generateShape(destinationVertexIdentifier, GeometryType.POINT, Arrays.asList(Tuple.create((double) destinationVertexLongitude, (double) destinationVertexLatitude)));\n-                            shapes.put(destinationVertexIdentifier, vertexPoint);\n-                            shapeFound = true;\n-                        } catch (IOException ex) {\n-                            throw new PluginException(PluginNotificationLevel.ERROR, ex);\n-                        }\n-                    }\n-\n-                    // ... and record all its attributes\n-                    if (shapeFound) {\n-                        final Map<String, Object> attributeMap = new HashMap<>();\n-                        final int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n-                        for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n-                            final int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n-                            final String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n-                            if (Character.isUpperCase(transactionAttributeName.charAt(0))) {\n-                                final Object transactionAttributeValue = graph.getObjectValue(transactionAttributeId, transactionId);\n-                                attributeMap.put(GraphRecordStoreUtilities.TRANSACTION + transactionAttributeName, transactionAttributeValue);\n-                            }\n-                        }\n-                        final int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n-                        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n-                            final int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n-                            final String sourceVertexAttributeName = graph.getAttributeName(vertexAttributeId);\n-                            if (Character.isUpperCase(sourceVertexAttributeName.charAt(0))) {\n-                                final Object sourceVertexAttributeValue = graph.getObjectValue(vertexAttributeId, sourceVertexId);\n-                                attributeMap.put(GraphRecordStoreUtilities.SOURCE + sourceVertexAttributeName, sourceVertexAttributeValue);\n-                            }\n-                            final String destinationVertexAttributeName = graph.getAttributeName(vertexAttributeId);\n-                            if (Character.isUpperCase(destinationVertexAttributeName.charAt(0))) {\n-                                final Object destinationVertexAttributeValue = graph.getObjectValue(vertexAttributeId, destinationVertexId);\n-                                attributeMap.put(GraphRecordStoreUtilities.DESTINATION + destinationVertexAttributeName, destinationVertexAttributeValue);\n-                            }\n-                        }\n-                        attributes.put(destinationVertexIdentifier, attributeMap);\n-                    }\n-                }\n-                break;\n-            default:\n-                throw new PluginException(PluginNotificationLevel.ERROR, \"Invalid element type\");\n-        }\n-\n-        try {\n-            exportGeo(parameters, GraphNode.getGraphNode(graph.getId()).getDisplayName(), shapes, attributes, output);\n-        } catch (IOException ex) {\n-            throw new PluginException(PluginNotificationLevel.ERROR, ex);\n-        }\n-\n-        ConstellationLoggerHelper.exportPropertyBuilder(\n-                this,\n-                GraphRecordStoreUtilities.getVertices(graph, false, false, false).getAll(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.LABEL),\n-                output,\n-                ConstellationLoggerHelper.SUCCESS\n-        );\n-    }\n-}\n+/*\r\n+ * Copyright 2010-2020 Australian Signals Directorate\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\r\n+\r\n+import au.gov.asd.tac.constellation.graph.Graph;\r\n+import au.gov.asd.tac.constellation.graph.GraphAttribute;\r\n+import au.gov.asd.tac.constellation.graph.GraphConstants;\r\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\r\n+import au.gov.asd.tac.constellation.graph.GraphReadMethods;\r\n+import au.gov.asd.tac.constellation.graph.ReadableGraph;\r\n+import au.gov.asd.tac.constellation.graph.manager.GraphManager;\r\n+import au.gov.asd.tac.constellation.graph.node.GraphNode;\r\n+import au.gov.asd.tac.constellation.graph.processing.GraphRecordStoreUtilities;\r\n+import au.gov.asd.tac.constellation.graph.schema.analytic.concept.SpatialConcept;\r\n+import au.gov.asd.tac.constellation.graph.schema.visual.concept.VisualConcept;\r\n+import au.gov.asd.tac.constellation.plugins.PluginException;\r\n+import au.gov.asd.tac.constellation.plugins.PluginInteraction;\r\n+import au.gov.asd.tac.constellation.plugins.PluginNotificationLevel;\r\n+import static au.gov.asd.tac.constellation.plugins.importexport.geospatial.AbstractGeoExportPlugin.ELEMENT_TYPE_PARAMETER_ID;\r\n+import static au.gov.asd.tac.constellation.plugins.importexport.geospatial.AbstractGeoExportPlugin.OUTPUT_PARAMETER_ID;\r\n+import au.gov.asd.tac.constellation.plugins.logging.ConstellationLoggerHelper;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.ParameterChange;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameter;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.BooleanParameterType;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.BooleanParameterType.BooleanParameterValue;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ElementTypeParameterValue;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.FileParameterType;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.FileParameterType.FileParameterValue;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.GraphAttributeParameterValue;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.MultiChoiceParameterType;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.MultiChoiceParameterType.MultiChoiceParameterValue;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ParameterValue;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType.SingleChoiceParameterValue;\r\n+import au.gov.asd.tac.constellation.plugins.templates.SimpleReadPlugin;\r\n+import au.gov.asd.tac.constellation.utilities.datastructure.Tuple;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape.GeometryType;\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.stream.Collectors;\r\n+import javafx.stage.FileChooser.ExtensionFilter;\r\n+import org.apache.commons.lang3.StringUtils;\r\n+\r\n+/**\r\n+ * Abstract geo export plugin.\r\n+ *\r\n+ * @author cygnus_x-1\r\n+ */\r\n+public abstract class AbstractGeoExportPlugin extends SimpleReadPlugin {\r\n+\r\n+    public static final String OUTPUT_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"output\");\r\n+    public static final String SPATIAL_REFERENCE_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"spatial_reference\");\r\n+    public static final String ELEMENT_TYPE_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"element_type\");\r\n+    public static final String ATTRIBUTES_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"attributes\");\r\n+    public static final String SELECTED_ONLY_PARAMETER_ID = PluginParameter.buildId(AbstractGeoExportPlugin.class, \"selected_only\");\r\n+\r\n+    /**\r\n+     * A {@link ExtensionFilter} specifying the file extension of the exported\r\n+     * file.\r\n+     *\r\n+     * @return an {@link ExtensionFilter}\r\n+     */\r\n+    protected abstract ExtensionFilter getExportType();\r\n+\r\n+    /**\r\n+     *\r\n+     * @param parameters\r\n+     * @param uuid\r\n+     * @param shapes\r\n+     * @param attributes\r\n+     * @param output\r\n+     * @throws IOException\r\n+     */\r\n+    protected abstract void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException;\r\n+\r\n+    /**\r\n+     * Determines whether the spatial reference parameter is active for this\r\n+     * plugin.\r\n+     *\r\n+     * @return true is spatial reference should be included, false otherwise\r\n+     */\r\n+    protected boolean includeSpatialReference() {\r\n+        return false;\r\n+    }\r\n+\r\n+    @Override\r\n+    @SuppressWarnings(\"fallthrough\") //the fallthrough at the switch statement is intentional\r\n+    public PluginParameters createParameters() {\r\n+        final PluginParameters parameters = new PluginParameters();\r\n+\r\n+        final PluginParameter<FileParameterValue> outputParameter = FileParameterType.build(OUTPUT_PARAMETER_ID);\r\n+        outputParameter.setName(\"Output File\");\r\n+        outputParameter.setDescription(\"The name of the output file\");\r\n+        FileParameterType.setKind(outputParameter, FileParameterType.FileParameterKind.SAVE);\r\n+        FileParameterType.setFileFilters(outputParameter, getExportType());\r\n+        parameters.addParameter(outputParameter);\r\n+\r\n+        if (includeSpatialReference()) {\r\n+            final PluginParameter<SingleChoiceParameterValue> spatialReferenceParameter = SingleChoiceParameterType.build(SPATIAL_REFERENCE_PARAMETER_ID, SpatialReferenceParameterValue.class);\r\n+            spatialReferenceParameter.setName(\"Spatial Reference\");\r\n+            spatialReferenceParameter.setDescription(\"The spatial reference to use for the geopackage\");\r\n+            final List<SpatialReferenceParameterValue> spatialReferences = Arrays.asList(Shape.SpatialReference.values()).stream()\r\n+                    .map(spatialReference -> new SpatialReferenceParameterValue(spatialReference)).collect(Collectors.toList());\r\n+            SingleChoiceParameterType.setOptionsData(spatialReferenceParameter, spatialReferences);\r\n+            SingleChoiceParameterType.setChoiceData(spatialReferenceParameter, spatialReferences.get(0));\r\n+            parameters.addParameter(spatialReferenceParameter);\r\n+        }\r\n+\r\n+        final PluginParameter<SingleChoiceParameterValue> elementTypeParameter = SingleChoiceParameterType.build(ELEMENT_TYPE_PARAMETER_ID, ElementTypeParameterValue.class);\r\n+        elementTypeParameter.setName(\"Element Type\");\r\n+        elementTypeParameter.setDescription(\"The graph element type\");\r\n+        final List<ElementTypeParameterValue> elementTypes = new ArrayList<>();\r\n+        elementTypes.add(new ElementTypeParameterValue(GraphElementType.TRANSACTION));\r\n+        elementTypes.add(new ElementTypeParameterValue(GraphElementType.VERTEX));\r\n+        SingleChoiceParameterType.setOptionsData(elementTypeParameter, elementTypes);\r\n+        parameters.addParameter(elementTypeParameter);\r\n+\r\n+        final PluginParameter<MultiChoiceParameterValue> attributesParameter = MultiChoiceParameterType.build(ATTRIBUTES_PARAMETER_ID, GraphAttributeParameterValue.class);\r\n+        attributesParameter.setName(\"Attributes\");\r\n+        attributesParameter.setDescription(\"The list of attribute names to include in the export\");\r\n+        attributesParameter.setEnabled(false);\r\n+        parameters.addParameter(attributesParameter);\r\n+\r\n+        final PluginParameter<BooleanParameterValue> selectedOnlyParameter = BooleanParameterType.build(SELECTED_ONLY_PARAMETER_ID);\r\n+        selectedOnlyParameter.setName(\"Selected Only\");\r\n+        selectedOnlyParameter.setDescription(\"If True, only export the selected nodes. The default is False.\");\r\n+        selectedOnlyParameter.setBooleanValue(false);\r\n+        parameters.addParameter(selectedOnlyParameter);\r\n+\r\n+        parameters.addController(ELEMENT_TYPE_PARAMETER_ID, (master, params, change) -> {\r\n+            if (change == ParameterChange.VALUE) {\r\n+                final Graph activeGraph = GraphManager.getDefault().getActiveGraph();\r\n+                if (activeGraph != null) {\r\n+\r\n+                    // create options by getting attributes for the chosen element type from the graph\r\n+                    final List<GraphAttributeParameterValue> attributeOptions = new ArrayList<>();\r\n+                    final ReadableGraph readableGraph = activeGraph.getReadableGraph();\r\n+                    try {\r\n+                        ParameterValue pv = params.get(master.getId()).getSingleChoice();\r", "originalCommit": "0df07e55aee704ceeb49af7334f0f67fed1dcd74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2NjYyMw==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r476966623", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-26T01:50:49Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/geospatial/ExportToGeoPackagePlugin.java", "diffHunk": "@@ -1,57 +1,60 @@\n-/*\n- * Copyright 2010-2020 Australian Signals Directorate\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\n-\n-import au.gov.asd.tac.constellation.plugins.Plugin;\n-import au.gov.asd.tac.constellation.plugins.PluginInfo;\n-import au.gov.asd.tac.constellation.plugins.PluginType;\n-import static au.gov.asd.tac.constellation.plugins.importexport.geospatial.AbstractGeoExportPlugin.SPATIAL_REFERENCE_PARAMETER_ID;\n-import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.Map;\n-import javafx.stage.FileChooser;\n-import javafx.stage.FileChooser.ExtensionFilter;\n-import org.openide.util.NbBundle;\n-import org.openide.util.lookup.ServiceProvider;\n-\n-/**\n- * Export a graph to a GeoPackage file.\n- *\n- * @author cygnus_x-1\n- */\n-@ServiceProvider(service = Plugin.class)\n-@PluginInfo(pluginType = PluginType.EXPORT, tags = {\"EXPORT\"})\n-@NbBundle.Messages(\"ExportToGeoPackagePlugin=Export to GeoPackage\")\n-public class ExportToGeoPackagePlugin extends AbstractGeoExportPlugin {\n-\n-    @Override\n-    protected ExtensionFilter getExportType() {\n-        return new FileChooser.ExtensionFilter(\"GeoPackage\", \"*.gpkg\");\n-    }\n-\n-    @Override\n-    protected void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException {\n-        final Shape.SpatialReference spatialReference = (Shape.SpatialReference) ((SpatialReferenceParameterValue) parameters.getObjectValue(SPATIAL_REFERENCE_PARAMETER_ID)).getObjectValue();\n-        Shape.generateGeoPackage(uuid, shapes, attributes, output, spatialReference);\n-    }\n-\n-    @Override\n-    protected boolean includeSpatialReference() {\n-        return true;\n-    }\n-}\n+/*\r\n+ * Copyright 2010-2020 Australian Signals Directorate\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\r\n+\r\n+import au.gov.asd.tac.constellation.plugins.Plugin;\r\n+import au.gov.asd.tac.constellation.plugins.PluginInfo;\r\n+import au.gov.asd.tac.constellation.plugins.PluginType;\r\n+import static au.gov.asd.tac.constellation.plugins.importexport.geospatial.AbstractGeoExportPlugin.SPATIAL_REFERENCE_PARAMETER_ID;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ParameterValue;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.util.Map;\r\n+import javafx.stage.FileChooser;\r\n+import javafx.stage.FileChooser.ExtensionFilter;\r\n+import org.openide.util.NbBundle;\r\n+import org.openide.util.lookup.ServiceProvider;\r\n+\r\n+/**\r\n+ * Export a graph to a GeoPackage file.\r\n+ *\r\n+ * @author cygnus_x-1\r\n+ */\r\n+@ServiceProvider(service = Plugin.class)\r\n+@PluginInfo(pluginType = PluginType.EXPORT, tags = {\"EXPORT\"})\r\n+@NbBundle.Messages(\"ExportToGeoPackagePlugin=Export to GeoPackage\")\r\n+public class ExportToGeoPackagePlugin extends AbstractGeoExportPlugin {\r\n+\r\n+    @Override\r\n+    protected ExtensionFilter getExportType() {\r\n+        return new FileChooser.ExtensionFilter(\"GeoPackage\", \"*.gpkg\");\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException {\r\n+        ParameterValue spatialReferencePV = parameters.getSingleChoice(SPATIAL_REFERENCE_PARAMETER_ID);\r", "originalCommit": "0df07e55aee704ceeb49af7334f0f67fed1dcd74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2Njc0Nw==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r476966747", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-26T01:50:58Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/geospatial/ExportToShapefilePlugin.java", "diffHunk": "@@ -1,145 +1,156 @@\n-/*\n- * Copyright 2010-2020 Australian Signals Directorate\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\n-\n-import au.gov.asd.tac.constellation.plugins.Plugin;\n-import au.gov.asd.tac.constellation.plugins.PluginInfo;\n-import au.gov.asd.tac.constellation.plugins.PluginType;\n-import au.gov.asd.tac.constellation.plugins.parameters.PluginParameter;\n-import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.ParameterValue;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType.SingleChoiceParameterValue;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape.GeometryType;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape.SpatialReference;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import javafx.stage.FileChooser.ExtensionFilter;\n-import org.openide.util.NbBundle.Messages;\n-import org.openide.util.lookup.ServiceProvider;\n-\n-/**\n- * Export a graph to an ArcGIS compatible Shapefile file.\n- *\n- * @author cygnus_x-1\n- */\n-@ServiceProvider(service = Plugin.class)\n-@PluginInfo(pluginType = PluginType.EXPORT, tags = {\"EXPORT\"})\n-@Messages(\"ExportToShapefilePlugin=Export to Shapefile\")\n-public class ExportToShapefilePlugin extends AbstractGeoExportPlugin {\n-\n-    public static final String GEOMETRY_TYPE_PARAMETER_ID = PluginParameter.buildId(ExportToShapefilePlugin.class, \"shape_type\");\n-\n-    @Override\n-    public PluginParameters createParameters() {\n-        final PluginParameters parameters = super.createParameters();\n-\n-        final PluginParameter<SingleChoiceParameterValue> geometryTypeParameter = SingleChoiceParameterType.build(GEOMETRY_TYPE_PARAMETER_ID, GeometryTypeParameterValue.class);\n-        geometryTypeParameter.setName(\"Geometry Type\");\n-        geometryTypeParameter.setDescription(\"The GeometryType enum value to export\");\n-        final List<GeometryTypeParameterValue> geometryTypeOptions = new ArrayList<>();\n-        Arrays.asList(GeometryType.values()).forEach(geometryType -> geometryTypeOptions.add(new GeometryTypeParameterValue(geometryType)));\n-        SingleChoiceParameterType.setOptionsData(geometryTypeParameter, geometryTypeOptions);\n-        SingleChoiceParameterType.setChoiceData(geometryTypeParameter, geometryTypeOptions.get(0));\n-        parameters.addParameter(geometryTypeParameter);\n-\n-        return parameters;\n-    }\n-\n-    @Override\n-    protected ExtensionFilter getExportType() {\n-        return new ExtensionFilter(\"Shapefile\", \"*.shp\");\n-    }\n-\n-    @Override\n-    protected void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException {\n-        final GeometryType geometryType = (GeometryType) ((GeometryTypeParameterValue) parameters.getObjectValue(GEOMETRY_TYPE_PARAMETER_ID)).getObjectValue();\n-        final SpatialReference spatialReference = (SpatialReference) ((SpatialReferenceParameterValue) parameters.getObjectValue(SPATIAL_REFERENCE_PARAMETER_ID)).getObjectValue();\n-        Shape.generateShapefile(uuid, geometryType, shapes, attributes, output, spatialReference);\n-    }\n-\n-    @Override\n-    protected boolean includeSpatialReference() {\n-        return true;\n-    }\n-\n-    public static final class GeometryTypeParameterValue extends ParameterValue {\n-\n-        private GeometryType geometryType;\n-\n-        public GeometryTypeParameterValue() {\n-            this.geometryType = null;\n-        }\n-\n-        public GeometryTypeParameterValue(final GeometryType geometryType) {\n-            this.geometryType = geometryType;\n-        }\n-\n-        @Override\n-        public final String validateString(final String s) {\n-            try {\n-                GeometryType.valueOf(s);\n-            } catch (IllegalArgumentException ex) {\n-                return String.format(\"%s is not a valid shape type (Expected Box, Line, Multi_Polygon, Point, Polygon).\", s);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public final boolean setStringValue(final String s) {\n-            final GeometryType type = GeometryType.valueOf(s);\n-            final boolean equal = Objects.equals(type, geometryType);\n-            if (!equal) {\n-                geometryType = type;\n-            }\n-            return equal;\n-        }\n-\n-        @Override\n-        public final Object getObjectValue() {\n-            return geometryType;\n-        }\n-\n-        @Override\n-        public final boolean setObjectValue(final Object o) {\n-            if (o instanceof GeometryType) {\n-                final GeometryType type = (GeometryType) o;\n-                final boolean equal = Objects.equals(type, geometryType);\n-                if (!equal) {\n-                    geometryType = type;\n-                }\n-                return equal;\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        protected final ParameterValue createCopy() {\n-            return new GeometryTypeParameterValue(geometryType);\n-        }\n-\n-        @Override\n-        public final String toString() {\n-            return geometryType == null ? \"No Value\" : geometryType.name();\n-        }\n-    }\n-}\n+/*\r\n+ * Copyright 2010-2020 Australian Signals Directorate\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\r\n+\r\n+import au.gov.asd.tac.constellation.plugins.Plugin;\r\n+import au.gov.asd.tac.constellation.plugins.PluginInfo;\r\n+import au.gov.asd.tac.constellation.plugins.PluginType;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameter;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ParameterValue;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType.SingleChoiceParameterValue;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape.GeometryType;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape.SpatialReference;\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+import javafx.stage.FileChooser.ExtensionFilter;\r\n+import org.openide.util.NbBundle.Messages;\r\n+import org.openide.util.lookup.ServiceProvider;\r\n+\r\n+/**\r\n+ * Export a graph to an ArcGIS compatible Shapefile file.\r\n+ *\r\n+ * @author cygnus_x-1\r\n+ */\r\n+@ServiceProvider(service = Plugin.class)\r\n+@PluginInfo(pluginType = PluginType.EXPORT, tags = {\"EXPORT\"})\r\n+@Messages(\"ExportToShapefilePlugin=Export to Shapefile\")\r\n+public class ExportToShapefilePlugin extends AbstractGeoExportPlugin {\r\n+\r\n+    public static final String GEOMETRY_TYPE_PARAMETER_ID = PluginParameter.buildId(ExportToShapefilePlugin.class, \"shape_type\");\r\n+\r\n+    @Override\r\n+    public PluginParameters createParameters() {\r\n+        final PluginParameters parameters = super.createParameters();\r\n+\r\n+        final PluginParameter<SingleChoiceParameterValue> geometryTypeParameter = SingleChoiceParameterType.build(GEOMETRY_TYPE_PARAMETER_ID, GeometryTypeParameterValue.class);\r\n+        geometryTypeParameter.setName(\"Geometry Type\");\r\n+        geometryTypeParameter.setDescription(\"The GeometryType enum value to export\");\r\n+        final List<GeometryTypeParameterValue> geometryTypeOptions = new ArrayList<>();\r\n+        Arrays.asList(GeometryType.values()).forEach(geometryType -> geometryTypeOptions.add(new GeometryTypeParameterValue(geometryType)));\r\n+        SingleChoiceParameterType.setOptionsData(geometryTypeParameter, geometryTypeOptions);\r\n+        SingleChoiceParameterType.setChoiceData(geometryTypeParameter, geometryTypeOptions.get(0));\r\n+        parameters.addParameter(geometryTypeParameter);\r\n+\r\n+        return parameters;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected ExtensionFilter getExportType() {\r\n+        return new ExtensionFilter(\"Shapefile\", \"*.shp\");\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException {\r\n+        ParameterValue geometryTypePV = parameters.getSingleChoice(GEOMETRY_TYPE_PARAMETER_ID);\r", "originalCommit": "0df07e55aee704ceeb49af7334f0f67fed1dcd74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2Njg4OA==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r476966888", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-26T01:51:07Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/geospatial/ExportToShapefilePlugin.java", "diffHunk": "@@ -1,145 +1,156 @@\n-/*\n- * Copyright 2010-2020 Australian Signals Directorate\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\n-\n-import au.gov.asd.tac.constellation.plugins.Plugin;\n-import au.gov.asd.tac.constellation.plugins.PluginInfo;\n-import au.gov.asd.tac.constellation.plugins.PluginType;\n-import au.gov.asd.tac.constellation.plugins.parameters.PluginParameter;\n-import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.ParameterValue;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType;\n-import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType.SingleChoiceParameterValue;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape.GeometryType;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape.SpatialReference;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import javafx.stage.FileChooser.ExtensionFilter;\n-import org.openide.util.NbBundle.Messages;\n-import org.openide.util.lookup.ServiceProvider;\n-\n-/**\n- * Export a graph to an ArcGIS compatible Shapefile file.\n- *\n- * @author cygnus_x-1\n- */\n-@ServiceProvider(service = Plugin.class)\n-@PluginInfo(pluginType = PluginType.EXPORT, tags = {\"EXPORT\"})\n-@Messages(\"ExportToShapefilePlugin=Export to Shapefile\")\n-public class ExportToShapefilePlugin extends AbstractGeoExportPlugin {\n-\n-    public static final String GEOMETRY_TYPE_PARAMETER_ID = PluginParameter.buildId(ExportToShapefilePlugin.class, \"shape_type\");\n-\n-    @Override\n-    public PluginParameters createParameters() {\n-        final PluginParameters parameters = super.createParameters();\n-\n-        final PluginParameter<SingleChoiceParameterValue> geometryTypeParameter = SingleChoiceParameterType.build(GEOMETRY_TYPE_PARAMETER_ID, GeometryTypeParameterValue.class);\n-        geometryTypeParameter.setName(\"Geometry Type\");\n-        geometryTypeParameter.setDescription(\"The GeometryType enum value to export\");\n-        final List<GeometryTypeParameterValue> geometryTypeOptions = new ArrayList<>();\n-        Arrays.asList(GeometryType.values()).forEach(geometryType -> geometryTypeOptions.add(new GeometryTypeParameterValue(geometryType)));\n-        SingleChoiceParameterType.setOptionsData(geometryTypeParameter, geometryTypeOptions);\n-        SingleChoiceParameterType.setChoiceData(geometryTypeParameter, geometryTypeOptions.get(0));\n-        parameters.addParameter(geometryTypeParameter);\n-\n-        return parameters;\n-    }\n-\n-    @Override\n-    protected ExtensionFilter getExportType() {\n-        return new ExtensionFilter(\"Shapefile\", \"*.shp\");\n-    }\n-\n-    @Override\n-    protected void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException {\n-        final GeometryType geometryType = (GeometryType) ((GeometryTypeParameterValue) parameters.getObjectValue(GEOMETRY_TYPE_PARAMETER_ID)).getObjectValue();\n-        final SpatialReference spatialReference = (SpatialReference) ((SpatialReferenceParameterValue) parameters.getObjectValue(SPATIAL_REFERENCE_PARAMETER_ID)).getObjectValue();\n-        Shape.generateShapefile(uuid, geometryType, shapes, attributes, output, spatialReference);\n-    }\n-\n-    @Override\n-    protected boolean includeSpatialReference() {\n-        return true;\n-    }\n-\n-    public static final class GeometryTypeParameterValue extends ParameterValue {\n-\n-        private GeometryType geometryType;\n-\n-        public GeometryTypeParameterValue() {\n-            this.geometryType = null;\n-        }\n-\n-        public GeometryTypeParameterValue(final GeometryType geometryType) {\n-            this.geometryType = geometryType;\n-        }\n-\n-        @Override\n-        public final String validateString(final String s) {\n-            try {\n-                GeometryType.valueOf(s);\n-            } catch (IllegalArgumentException ex) {\n-                return String.format(\"%s is not a valid shape type (Expected Box, Line, Multi_Polygon, Point, Polygon).\", s);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public final boolean setStringValue(final String s) {\n-            final GeometryType type = GeometryType.valueOf(s);\n-            final boolean equal = Objects.equals(type, geometryType);\n-            if (!equal) {\n-                geometryType = type;\n-            }\n-            return equal;\n-        }\n-\n-        @Override\n-        public final Object getObjectValue() {\n-            return geometryType;\n-        }\n-\n-        @Override\n-        public final boolean setObjectValue(final Object o) {\n-            if (o instanceof GeometryType) {\n-                final GeometryType type = (GeometryType) o;\n-                final boolean equal = Objects.equals(type, geometryType);\n-                if (!equal) {\n-                    geometryType = type;\n-                }\n-                return equal;\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        protected final ParameterValue createCopy() {\n-            return new GeometryTypeParameterValue(geometryType);\n-        }\n-\n-        @Override\n-        public final String toString() {\n-            return geometryType == null ? \"No Value\" : geometryType.name();\n-        }\n-    }\n-}\n+/*\r\n+ * Copyright 2010-2020 Australian Signals Directorate\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\r\n+\r\n+import au.gov.asd.tac.constellation.plugins.Plugin;\r\n+import au.gov.asd.tac.constellation.plugins.PluginInfo;\r\n+import au.gov.asd.tac.constellation.plugins.PluginType;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameter;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ParameterValue;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.SingleChoiceParameterType.SingleChoiceParameterValue;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape.GeometryType;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape.SpatialReference;\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Objects;\r\n+import javafx.stage.FileChooser.ExtensionFilter;\r\n+import org.openide.util.NbBundle.Messages;\r\n+import org.openide.util.lookup.ServiceProvider;\r\n+\r\n+/**\r\n+ * Export a graph to an ArcGIS compatible Shapefile file.\r\n+ *\r\n+ * @author cygnus_x-1\r\n+ */\r\n+@ServiceProvider(service = Plugin.class)\r\n+@PluginInfo(pluginType = PluginType.EXPORT, tags = {\"EXPORT\"})\r\n+@Messages(\"ExportToShapefilePlugin=Export to Shapefile\")\r\n+public class ExportToShapefilePlugin extends AbstractGeoExportPlugin {\r\n+\r\n+    public static final String GEOMETRY_TYPE_PARAMETER_ID = PluginParameter.buildId(ExportToShapefilePlugin.class, \"shape_type\");\r\n+\r\n+    @Override\r\n+    public PluginParameters createParameters() {\r\n+        final PluginParameters parameters = super.createParameters();\r\n+\r\n+        final PluginParameter<SingleChoiceParameterValue> geometryTypeParameter = SingleChoiceParameterType.build(GEOMETRY_TYPE_PARAMETER_ID, GeometryTypeParameterValue.class);\r\n+        geometryTypeParameter.setName(\"Geometry Type\");\r\n+        geometryTypeParameter.setDescription(\"The GeometryType enum value to export\");\r\n+        final List<GeometryTypeParameterValue> geometryTypeOptions = new ArrayList<>();\r\n+        Arrays.asList(GeometryType.values()).forEach(geometryType -> geometryTypeOptions.add(new GeometryTypeParameterValue(geometryType)));\r\n+        SingleChoiceParameterType.setOptionsData(geometryTypeParameter, geometryTypeOptions);\r\n+        SingleChoiceParameterType.setChoiceData(geometryTypeParameter, geometryTypeOptions.get(0));\r\n+        parameters.addParameter(geometryTypeParameter);\r\n+\r\n+        return parameters;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected ExtensionFilter getExportType() {\r\n+        return new ExtensionFilter(\"Shapefile\", \"*.shp\");\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException {\r\n+        ParameterValue geometryTypePV = parameters.getSingleChoice(GEOMETRY_TYPE_PARAMETER_ID);\r\n+        assert(geometryTypePV instanceof GeometryTypeParameterValue);\r\n+        final GeometryType geometryType = ((GeometryTypeParameterValue) geometryTypePV).getGeometryType();\r\n+        \r\n+        ParameterValue spatialReferencePV = parameters.getSingleChoice(SPATIAL_REFERENCE_PARAMETER_ID);\r", "originalCommit": "0df07e55aee704ceeb49af7334f0f67fed1dcd74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "817e02eb2f122f47a3665cd8da846dcd29721275", "url": "https://github.com/constellation-app/constellation/commit/817e02eb2f122f47a3665cd8da846dcd29721275", "message": ":art: Added final where applicable\nAdded final modifier in front of variables where applicable.", "committedDate": "2020-08-26T02:35:18Z", "type": "commit"}, {"oid": "8ffca5cc8e1d3784259a37f369db93c1b6eedf65", "url": "https://github.com/constellation-app/constellation/commit/8ffca5cc8e1d3784259a37f369db93c1b6eedf65", "message": "Merge branch 'master' into bugfix/Issue793-classCastException", "committedDate": "2020-08-26T02:36:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMTgzNw==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r477011837", "bodyText": "Given this if statement and the above if statement have the same code block, you could probably merge the 2 conditions together with ||. On a similar note, you can probably turn the if statement into an else if given that the 1st if statement just returns true", "author": "antares1470", "createdAt": "2020-08-26T03:31:03Z", "path": "CorePluginFramework/src/au/gov/asd/tac/constellation/plugins/parameters/types/ElementTypeParameterValue.java", "diffHunk": "@@ -1,85 +1,113 @@\n-/*\n- * Copyright 2010-2020 Australian Signals Directorate\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package au.gov.asd.tac.constellation.plugins.parameters.types;\n-\n-import au.gov.asd.tac.constellation.graph.GraphElementType;\n-import java.util.Objects;\n-\n-/**\n- * Element Type Parameter Value\n- *\n- * @author cygnus_x-1\n- */\n-public class ElementTypeParameterValue extends ParameterValue {\n-\n-    private GraphElementType elementType;\n-\n-    public ElementTypeParameterValue() {\n-        this.elementType = null;\n-    }\n-\n-    public ElementTypeParameterValue(final GraphElementType elementType) {\n-        this.elementType = elementType;\n-    }\n-\n-    @Override\n-    public String validateString(final String s) {\n-        try {\n-            GraphElementType.getValue(s);\n-        } catch (IllegalArgumentException ex) {\n-            return String.format(\"%s is not a valid element type\", s);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean setStringValue(final String s) {\n-        final GraphElementType stringElementType = GraphElementType.getValue(s);\n-        final boolean equal = Objects.equals(stringElementType, elementType);\n-        if (!equal) {\n-            elementType = stringElementType;\n-        }\n-        return equal;\n-    }\n-\n-    @Override\n-    public Object getObjectValue() {\n-        return elementType;\n-    }\n-\n-    @Override\n-    public boolean setObjectValue(final Object o) {\n-        if (o instanceof GraphElementType) {\n-            final GraphElementType type = (GraphElementType) o;\n-            final boolean equal = Objects.equals(type, elementType);\n-            if (!equal) {\n-                elementType = type;\n-            }\n-            return equal;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    protected ParameterValue createCopy() {\n-        return new ElementTypeParameterValue(elementType);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return elementType == null ? \"No Value\" : elementType.getShortLabel();\n-    }\n-}\n+/*\r\n+ * Copyright 2010-2020 Australian Signals Directorate\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package au.gov.asd.tac.constellation.plugins.parameters.types;\r\n+\r\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\r\n+import java.util.Objects;\r\n+\r\n+/**\r\n+ * Element Type Parameter Value\r\n+ *\r\n+ * @author cygnus_x-1\r\n+ */\r\n+public class ElementTypeParameterValue extends ParameterValue {\r\n+\r\n+    private GraphElementType elementType;\r\n+\r\n+    public ElementTypeParameterValue() {\r\n+        this.elementType = null;\r\n+    }\r\n+\r\n+    public ElementTypeParameterValue(final GraphElementType elementType) {\r\n+        this.elementType = elementType;\r\n+    }\r\n+\r\n+    public GraphElementType getGraphElementType() {\r\n+        return elementType;\r\n+    }\r\n+\r\n+    @Override\r\n+    public String validateString(final String s) {\r\n+        try {\r\n+            GraphElementType.getValue(s);\r\n+        } catch (IllegalArgumentException ex) {\r\n+            return String.format(\"%s is not a valid element type\", s);\r\n+        }\r\n+        return null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean setStringValue(final String s) {\r\n+        final GraphElementType stringElementType = GraphElementType.getValue(s);\r\n+        final boolean equal = Objects.equals(stringElementType, elementType);\r\n+        if (!equal) {\r\n+            elementType = stringElementType;\r\n+        }\r\n+        return equal;\r\n+    }\r\n+\r\n+    @Override\r\n+    public Object getObjectValue() {\r\n+        return elementType;\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean setObjectValue(final Object o) {\r\n+        if (o instanceof GraphElementType) {\r\n+            final GraphElementType type = (GraphElementType) o;\r\n+            final boolean equal = Objects.equals(type, elementType);\r\n+            if (!equal) {\r\n+                elementType = type;\r\n+            }\r\n+            return equal;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected ParameterValue createCopy() {\r\n+        return new ElementTypeParameterValue(elementType);\r\n+    }\r\n+\r\n+    @Override\r\n+    public String toString() {\r\n+        return elementType == null ? \"No Value\" : elementType.getShortLabel();\r\n+    }\r\n+\r\n+    @Override\r\n+    public int hashCode() {\r\n+        int hash = 5;\r\n+        hash = 41 * hash + Objects.hashCode(this.elementType);\r\n+        return hash;\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean equals(Object obj) {\r\n+        if (this == obj) {\r\n+            return true;\r\n+        }\r\n+        if (obj == null) {\r\n+            return false;\r\n+        }\r\n+        if (getClass() != obj.getClass()) {\r\n+            return false;\r", "originalCommit": "8ffca5cc8e1d3784259a37f369db93c1b6eedf65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMzU1MA==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r477023550", "bodyText": "This was auto generated code when I did an insert for the hash and equals functions so I didn't look too closely at it.", "author": "Nova-2119", "createdAt": "2020-08-26T04:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0MzYwMQ==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r477043601", "bodyText": "I see what you mean, but after typing in those suggestions I actually think the code is slightly less readable then it is currently. So I am tempted to leave it as it is if that's okay?", "author": "Nova-2119", "createdAt": "2020-08-26T05:31:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYzNjc5Mw==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r477636793", "bodyText": "Having typed it out myself, I agree that it looks slightly less readable but I don't think it's THAT much less readable so I think it may still be worth doing it. Thoughts @arcturus2?\nNote: If this is auto-generated code then if we decide to make changes, perhaps they need to be made further up the chain as well", "author": "antares1470", "createdAt": "2020-08-26T22:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxMDI5OA==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r478210298", "bodyText": "Hey @antares1470 my preference would be to keep the auto generated version and actually hide these blocks of code using code folding in NetBeans, see http://wiki.netbeans.org/SurroundWithCodeFolding. I've documented this idea in #821.", "author": "arcturus2", "createdAt": "2020-08-27T07:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMTgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMzA0OQ==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r477013049", "bodyText": "Is there a reason why hash is initially set to 5 rather than just using 5 in the subsequent statement (i.e. just have one line return 41 * 5 + Objects.hashCode(this.elementType)? I understand we may want to minimise use of straight up numbers in calculations but it seems like redundant code", "author": "antares1470", "createdAt": "2020-08-26T03:35:48Z", "path": "CorePluginFramework/src/au/gov/asd/tac/constellation/plugins/parameters/types/ElementTypeParameterValue.java", "diffHunk": "@@ -1,85 +1,113 @@\n-/*\n- * Copyright 2010-2020 Australian Signals Directorate\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package au.gov.asd.tac.constellation.plugins.parameters.types;\n-\n-import au.gov.asd.tac.constellation.graph.GraphElementType;\n-import java.util.Objects;\n-\n-/**\n- * Element Type Parameter Value\n- *\n- * @author cygnus_x-1\n- */\n-public class ElementTypeParameterValue extends ParameterValue {\n-\n-    private GraphElementType elementType;\n-\n-    public ElementTypeParameterValue() {\n-        this.elementType = null;\n-    }\n-\n-    public ElementTypeParameterValue(final GraphElementType elementType) {\n-        this.elementType = elementType;\n-    }\n-\n-    @Override\n-    public String validateString(final String s) {\n-        try {\n-            GraphElementType.getValue(s);\n-        } catch (IllegalArgumentException ex) {\n-            return String.format(\"%s is not a valid element type\", s);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean setStringValue(final String s) {\n-        final GraphElementType stringElementType = GraphElementType.getValue(s);\n-        final boolean equal = Objects.equals(stringElementType, elementType);\n-        if (!equal) {\n-            elementType = stringElementType;\n-        }\n-        return equal;\n-    }\n-\n-    @Override\n-    public Object getObjectValue() {\n-        return elementType;\n-    }\n-\n-    @Override\n-    public boolean setObjectValue(final Object o) {\n-        if (o instanceof GraphElementType) {\n-            final GraphElementType type = (GraphElementType) o;\n-            final boolean equal = Objects.equals(type, elementType);\n-            if (!equal) {\n-                elementType = type;\n-            }\n-            return equal;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    protected ParameterValue createCopy() {\n-        return new ElementTypeParameterValue(elementType);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return elementType == null ? \"No Value\" : elementType.getShortLabel();\n-    }\n-}\n+/*\r\n+ * Copyright 2010-2020 Australian Signals Directorate\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package au.gov.asd.tac.constellation.plugins.parameters.types;\r\n+\r\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\r\n+import java.util.Objects;\r\n+\r\n+/**\r\n+ * Element Type Parameter Value\r\n+ *\r\n+ * @author cygnus_x-1\r\n+ */\r\n+public class ElementTypeParameterValue extends ParameterValue {\r\n+\r\n+    private GraphElementType elementType;\r\n+\r\n+    public ElementTypeParameterValue() {\r\n+        this.elementType = null;\r\n+    }\r\n+\r\n+    public ElementTypeParameterValue(final GraphElementType elementType) {\r\n+        this.elementType = elementType;\r\n+    }\r\n+\r\n+    public GraphElementType getGraphElementType() {\r\n+        return elementType;\r\n+    }\r\n+\r\n+    @Override\r\n+    public String validateString(final String s) {\r\n+        try {\r\n+            GraphElementType.getValue(s);\r\n+        } catch (IllegalArgumentException ex) {\r\n+            return String.format(\"%s is not a valid element type\", s);\r\n+        }\r\n+        return null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean setStringValue(final String s) {\r\n+        final GraphElementType stringElementType = GraphElementType.getValue(s);\r\n+        final boolean equal = Objects.equals(stringElementType, elementType);\r\n+        if (!equal) {\r\n+            elementType = stringElementType;\r\n+        }\r\n+        return equal;\r\n+    }\r\n+\r\n+    @Override\r\n+    public Object getObjectValue() {\r\n+        return elementType;\r\n+    }\r\n+\r\n+    @Override\r\n+    public boolean setObjectValue(final Object o) {\r\n+        if (o instanceof GraphElementType) {\r\n+            final GraphElementType type = (GraphElementType) o;\r\n+            final boolean equal = Objects.equals(type, elementType);\r\n+            if (!equal) {\r\n+                elementType = type;\r\n+            }\r\n+            return equal;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    @Override\r\n+    protected ParameterValue createCopy() {\r\n+        return new ElementTypeParameterValue(elementType);\r\n+    }\r\n+\r\n+    @Override\r\n+    public String toString() {\r\n+        return elementType == null ? \"No Value\" : elementType.getShortLabel();\r\n+    }\r\n+\r\n+    @Override\r\n+    public int hashCode() {\r\n+        int hash = 5;\r\n+        hash = 41 * hash + Objects.hashCode(this.elementType);\r\n+        return hash;\r", "originalCommit": "8ffca5cc8e1d3784259a37f369db93c1b6eedf65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMzU2NA==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r477023564", "bodyText": "This was auto generated code when I did an insert for the hash and equals functions so I didn't look too closely at it.", "author": "Nova-2119", "createdAt": "2020-08-26T04:16:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMzA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0MzcyMA==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r477043720", "bodyText": "Yeah that seems completely redundant and I have made the change.", "author": "Nova-2119", "createdAt": "2020-08-26T05:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxMzA0OQ=="}], "type": "inlineReview"}, {"oid": "0629f0f114dc4fa3a446c6ac965ecf83417d5a5d", "url": "https://github.com/constellation-app/constellation/commit/0629f0f114dc4fa3a446c6ac965ecf83417d5a5d", "message": "Merge branch 'master' into bugfix/Issue793-classCastException", "committedDate": "2020-08-26T05:11:50Z", "type": "commit"}, {"oid": "0ebe2b4c25d17882331a80c5bf2e959df6b01950", "url": "https://github.com/constellation-app/constellation/commit/0ebe2b4c25d17882331a80c5bf2e959df6b01950", "message": ":art: Removed redundant variable assignment.", "committedDate": "2020-08-26T05:33:21Z", "type": "commit"}, {"oid": "6ad5d930f12e37d902f4bfec8b24a20a1484ac06", "url": "https://github.com/constellation-app/constellation/commit/6ad5d930f12e37d902f4bfec8b24a20a1484ac06", "message": "Merge branch 'bugfix/Issue793-classCastException' of https://github.com/constellation-app/constellation into bugfix/Issue793-classCastException", "committedDate": "2020-08-26T05:36:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NDY1Mw==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r478784653", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-28T01:41:59Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/geospatial/ExportToGeoPackagePlugin.java", "diffHunk": "@@ -1,57 +1,60 @@\n-/*\n- * Copyright 2010-2020 Australian Signals Directorate\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\n-\n-import au.gov.asd.tac.constellation.plugins.Plugin;\n-import au.gov.asd.tac.constellation.plugins.PluginInfo;\n-import au.gov.asd.tac.constellation.plugins.PluginType;\n-import static au.gov.asd.tac.constellation.plugins.importexport.geospatial.AbstractGeoExportPlugin.SPATIAL_REFERENCE_PARAMETER_ID;\n-import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n-import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\n-import java.io.File;\n-import java.io.IOException;\n-import java.util.Map;\n-import javafx.stage.FileChooser;\n-import javafx.stage.FileChooser.ExtensionFilter;\n-import org.openide.util.NbBundle;\n-import org.openide.util.lookup.ServiceProvider;\n-\n-/**\n- * Export a graph to a GeoPackage file.\n- *\n- * @author cygnus_x-1\n- */\n-@ServiceProvider(service = Plugin.class)\n-@PluginInfo(pluginType = PluginType.EXPORT, tags = {\"EXPORT\"})\n-@NbBundle.Messages(\"ExportToGeoPackagePlugin=Export to GeoPackage\")\n-public class ExportToGeoPackagePlugin extends AbstractGeoExportPlugin {\n-\n-    @Override\n-    protected ExtensionFilter getExportType() {\n-        return new FileChooser.ExtensionFilter(\"GeoPackage\", \"*.gpkg\");\n-    }\n-\n-    @Override\n-    protected void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException {\n-        final Shape.SpatialReference spatialReference = (Shape.SpatialReference) ((SpatialReferenceParameterValue) parameters.getObjectValue(SPATIAL_REFERENCE_PARAMETER_ID)).getObjectValue();\n-        Shape.generateGeoPackage(uuid, shapes, attributes, output, spatialReference);\n-    }\n-\n-    @Override\n-    protected boolean includeSpatialReference() {\n-        return true;\n-    }\n-}\n+/*\r\n+ * Copyright 2010-2020 Australian Signals Directorate\r\n+ *\r\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+ * you may not use this file except in compliance with the License.\r\n+ * You may obtain a copy of the License at\r\n+ *\r\n+ *     http://www.apache.org/licenses/LICENSE-2.0\r\n+ *\r\n+ * Unless required by applicable law or agreed to in writing, software\r\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+ * See the License for the specific language governing permissions and\r\n+ * limitations under the License.\r\n+ */\r\n+package au.gov.asd.tac.constellation.plugins.importexport.geospatial;\r\n+\r\n+import au.gov.asd.tac.constellation.plugins.Plugin;\r\n+import au.gov.asd.tac.constellation.plugins.PluginInfo;\r\n+import au.gov.asd.tac.constellation.plugins.PluginType;\r\n+import static au.gov.asd.tac.constellation.plugins.importexport.geospatial.AbstractGeoExportPlugin.SPATIAL_REFERENCE_PARAMETER_ID;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\r\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ParameterValue;\r\n+import au.gov.asd.tac.constellation.utilities.geospatial.Shape;\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.util.Map;\r\n+import javafx.stage.FileChooser;\r\n+import javafx.stage.FileChooser.ExtensionFilter;\r\n+import org.openide.util.NbBundle;\r\n+import org.openide.util.lookup.ServiceProvider;\r\n+\r\n+/**\r\n+ * Export a graph to a GeoPackage file.\r\n+ *\r\n+ * @author cygnus_x-1\r\n+ */\r\n+@ServiceProvider(service = Plugin.class)\r\n+@PluginInfo(pluginType = PluginType.EXPORT, tags = {\"EXPORT\"})\r\n+@NbBundle.Messages(\"ExportToGeoPackagePlugin=Export to GeoPackage\")\r\n+public class ExportToGeoPackagePlugin extends AbstractGeoExportPlugin {\r\n+\r\n+    @Override\r\n+    protected ExtensionFilter getExportType() {\r\n+        return new FileChooser.ExtensionFilter(\"GeoPackage\", \"*.gpkg\");\r\n+    }\r\n+\r\n+    @Override\r\n+    protected void exportGeo(final PluginParameters parameters, final String uuid, final Map<String, String> shapes, final Map<String, Map<String, Object>> attributes, final File output) throws IOException {\r\n+        final ParameterValue spatialReferencePV = parameters.getSingleChoice(SPATIAL_REFERENCE_PARAMETER_ID);\r\n+        assert(spatialReferencePV instanceof SpatialReferenceParameterValue);\r\n+        Shape.SpatialReference spatialReference = ((SpatialReferenceParameterValue) spatialReferencePV).getSpatialReference();\r", "originalCommit": "6ad5d930f12e37d902f4bfec8b24a20a1484ac06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgzODM2NQ==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r478838365", "bodyText": "Indeed", "author": "Nova-2119", "createdAt": "2020-08-28T05:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NDY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NDc3Mg==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r478784772", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-28T01:42:32Z", "path": "CorePluginFramework/src/au/gov/asd/tac/constellation/plugins/gui/SingleChoiceInputPane.java", "diffHunk": "@@ -115,42 +115,42 @@ public SingleChoiceInputPane(final PluginParameter<SingleChoiceParameterValue> p\n             SingleChoiceParameterType.setChoiceData(parameter, field.getSelectionModel().getSelectedItem());\n         });\n \n-        parameter.addListener((final PluginParameter<?> parameter1, final ParameterChange change) -> {\n+        parameter.addListener((final PluginParameter<?> scParameter, final ParameterChange change) -> {\n             Platform.runLater(() -> {\n-                @SuppressWarnings(\"unchecked\") //scParameter1 is SingleChoiceParameter\n-                PluginParameter<SingleChoiceParameterValue> scParameter1 = (PluginParameter<SingleChoiceParameterValue>) parameter1;\n+                assert(scParameter.getParameterValue() instanceof SingleChoiceParameterValue);\n+                SingleChoiceParameterValue scParameterValue = (SingleChoiceParameterValue) scParameter.getParameterValue();", "originalCommit": "6ad5d930f12e37d902f4bfec8b24a20a1484ac06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgzODYzMQ==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r478838631", "bodyText": "So final. The final final.\nThanks for being so thorough in your review! Evidently I need to pay more attention to when things can be final.", "author": "Nova-2119", "createdAt": "2020-08-28T05:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NDc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg0NDc0MQ==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r478844741", "bodyText": "No worries. Evidently so do I else I wouldn't need to do more than one review :)", "author": "antares1470", "createdAt": "2020-08-28T05:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NDc3Mg=="}], "type": "inlineReview"}, {"oid": "3ce1bb3b8b5a03be2ddfefd2ed8c8907e051ec2c", "url": "https://github.com/constellation-app/constellation/commit/3ce1bb3b8b5a03be2ddfefd2ed8c8907e051ec2c", "message": "Merge branch 'master' into bugfix/Issue793-classCastException", "committedDate": "2020-08-28T04:47:50Z", "type": "commit"}, {"oid": "2049a24a894a7f628a7342063f82cf83dbbe4fc8", "url": "https://github.com/constellation-app/constellation/commit/2049a24a894a7f628a7342063f82cf83dbbe4fc8", "message": ":art: Made variables final", "committedDate": "2020-08-28T05:29:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyNjI0NA==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r480426244", "bodyText": "Hey @Nova-2119 what change in your PR required the introduction of the hash and equals methods? Is it the call to instanceof ?", "author": "arcturus2", "createdAt": "2020-08-31T22:08:38Z", "path": "CorePluginFramework/src/au/gov/asd/tac/constellation/plugins/parameters/types/ElementTypeParameterValue.java", "diffHunk": "@@ -82,4 +86,26 @@ protected ParameterValue createCopy() {\n     public String toString() {\n         return elementType == null ? \"No Value\" : elementType.getShortLabel();\n     }\n+\n+    @Override\n+    public int hashCode() {\n+        return 41 * 5 + Objects.hashCode(this.elementType);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final ElementTypeParameterValue other = (ElementTypeParameterValue) obj;\n+        return this.elementType == other.elementType;\n+    }", "originalCommit": "2049a24a894a7f628a7342063f82cf83dbbe4fc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3NTg5Nw==", "url": "https://github.com/constellation-app/constellation/pull/804#discussion_r480475897", "bodyText": "SingloeChoiceParameterValue.setChoiceData(ParameterValue) uses the .contains method so for any ParameterValue to work properly with it we need to override equals.\nPreviously this was causing issues because two identical ElementTypeParamaterValues weren't considered equal as they weren't the same object.", "author": "Nova-2119", "createdAt": "2020-08-31T23:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyNjI0NA=="}], "type": "inlineReview"}]}