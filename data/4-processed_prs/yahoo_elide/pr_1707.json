{"pr_number": 1707, "pr_title": "Dynamic Model Extends: Inherit Table Properties", "pr_createdAt": "2020-12-03T18:21:28Z", "pr_url": "https://github.com/yahoo/elide/pull/1707", "timeline": [{"oid": "eacb473893827885805b37a6e54cf4ab665a7fcc", "url": "https://github.com/yahoo/elide/commit/eacb473893827885805b37a6e54cf4ab665a7fcc", "message": "Initial", "committedDate": "2020-12-03T18:21:43Z", "type": "forcePushed"}, {"oid": "5fae23633206107b6dba14479623499d7c28bd9d", "url": "https://github.com/yahoo/elide/commit/5fae23633206107b6dba14479623499d7c28bd9d", "message": "Initial", "committedDate": "2020-12-04T16:50:01Z", "type": "commit"}, {"oid": "5fae23633206107b6dba14479623499d7c28bd9d", "url": "https://github.com/yahoo/elide/commit/5fae23633206107b6dba14479623499d7c28bd9d", "message": "Initial", "committedDate": "2020-12-04T16:50:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNTE4MA==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536815180", "bodyText": "Don't use object here.  We should use generics.", "author": "aklish", "createdAt": "2020-12-05T16:09:11Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {\n+                            tab.getMeasures().forEach(measure -> {\n+                                if (!((Map<String, Measure>) result).containsKey(measure.getName())) {\n+                                    ((Map<String, Measure>) result).put(measure.getName(), measure);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setMeasures(new ArrayList<Measure>(measures.values()));\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n+                Map<String, Dimension> dimensions = (Map<String, Dimension>) getInheritedAttribute(table,\n+                        new HashMap<String, Dimension>(), (tab, result) -> {\n+                            tab.getDimensions().forEach(dim -> {\n+                                if (!((Map<String, Dimension>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Dimension>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n+                Map<String, Join> joins = (Map<String, Join>) getInheritedAttribute(table,\n+                        new HashMap<String, Join>(), (tab, result) -> {\n+                            tab.getJoins().forEach(dim -> {\n+                                if (!((Map<String, Join>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Join>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setJoins(new ArrayList<Join>(joins.values()));\n-            }\n-        }\n-    }\n \n-    private Map<String, Measure> getInheritedMeasures(Table table, Map<String, Measure> measures) {\n-        table.getMeasures().forEach(m -> {\n-            if (!measures.containsKey(m.getName())) {\n-                measures.put(m.getName(), m);\n+                String schema = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSchema();\n+                        }, true\n+                );\n+                table.setSchema(schema);\n+\n+                String dbConnectionName = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getDbConnectionName();\n+                        }, true\n+                );\n+                table.setDbConnectionName(dbConnectionName);\n+\n+                String readAccess = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getReadAccess();\n+                        }, true\n+                );\n+                table.setReadAccess(readAccess);\n+\n+                String sql = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSql();\n+                        }, true\n+                );\n+                table.setSql(sql);\n+\n+                String tableName = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getTable();\n+                        }, true\n+                );\n+                table.setTable(tableName);\n             }\n-        });\n-        if (table.hasParent()) {\n-            getInheritedMeasures(table.getParent(this.elideTableConfig), measures);\n         }\n-        return measures;\n     }\n \n-    private Map<String, Dimension> getInheritedDimensions(Table table, Map<String, Dimension> dimensions) {\n-        table.getDimensions().forEach(dim -> {\n-            if (!dimensions.containsKey(dim.getName())) {\n-                dimensions.put(dim.getName(), dim);\n-            }\n-        });\n-        if (table.hasParent()) {\n-            getInheritedDimensions(table.getParent(this.elideTableConfig), dimensions);\n-        }\n-        return dimensions;\n-    }\n \n-    private Map<String, Join> getInheritedJoins(Table table, Map<String, Join> joins) {\n-        table.getJoins().forEach(join -> {\n-            if (!joins.containsKey(join.getName())) {\n-                joins.put(join.getName(), join);\n-            }\n-        });\n+    private Object getInheritedAttribute(Table table, Object result, Inheritance action, boolean recurseOnlyIfNull) {", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNTMxMw==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536815313", "bodyText": "We should leave the methods getInheritedMeasures and getInheritedDimensions, etc.  They improve readability.  Those functions can return the correct type and in turn call getInheritedAttribute with the appropriate Inherit method.", "author": "aklish", "createdAt": "2020-12-05T16:10:07Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNTc3OQ==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536815779", "bodyText": "There are two standard ways to ensure ancestors are processed before decedents:\n\nStandard DFS algorithm with a visited set and toVisit stack.\nTail Recursion.\n\nLet's not do this with a single data structure that we both add and remove from.", "author": "aklish", "createdAt": "2020-12-05T16:13:18Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNTk3NQ==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536815975", "bodyText": "Why not just call parent.hasParent here?  It improves readability", "author": "aklish", "createdAt": "2020-12-05T16:14:23Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjM2Mw==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536816363", "bodyText": "You technically don't need to add a table parameter (tab) here because it is available through closure.", "author": "aklish", "createdAt": "2020-12-05T16:16:57Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjQyNw==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536816427", "bodyText": "Having both tab and table looks odd.", "author": "aklish", "createdAt": "2020-12-05T16:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjcwOQ==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536816709", "bodyText": "These should all be separate functions.  Having embedded lambdas all together like this in one function makes this hard to read.", "author": "aklish", "createdAt": "2020-12-05T16:19:18Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {\n+                            tab.getMeasures().forEach(measure -> {\n+                                if (!((Map<String, Measure>) result).containsKey(measure.getName())) {\n+                                    ((Map<String, Measure>) result).put(measure.getName(), measure);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setMeasures(new ArrayList<Measure>(measures.values()));\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n+                Map<String, Dimension> dimensions = (Map<String, Dimension>) getInheritedAttribute(table,\n+                        new HashMap<String, Dimension>(), (tab, result) -> {\n+                            tab.getDimensions().forEach(dim -> {\n+                                if (!((Map<String, Dimension>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Dimension>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n+                Map<String, Join> joins = (Map<String, Join>) getInheritedAttribute(table,\n+                        new HashMap<String, Join>(), (tab, result) -> {\n+                            tab.getJoins().forEach(dim -> {\n+                                if (!((Map<String, Join>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Join>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setJoins(new ArrayList<Join>(joins.values()));\n-            }\n-        }\n-    }\n \n-    private Map<String, Measure> getInheritedMeasures(Table table, Map<String, Measure> measures) {\n-        table.getMeasures().forEach(m -> {\n-            if (!measures.containsKey(m.getName())) {\n-                measures.put(m.getName(), m);\n+                String schema = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSchema();\n+                        }, true\n+                );\n+                table.setSchema(schema);\n+\n+                String dbConnectionName = (String) getInheritedAttribute(table, null,", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjgyOA==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536816828", "bodyText": "null as second parameter seems like the abstraction to commonize this code is not working.", "author": "aklish", "createdAt": "2020-12-05T16:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNjcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNzMwNg==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536817306", "bodyText": "The last parameter recurseOnlyIfNull is a tell that this really ought to be two separate functions.", "author": "aklish", "createdAt": "2020-12-05T16:23:00Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {\n+                            tab.getMeasures().forEach(measure -> {\n+                                if (!((Map<String, Measure>) result).containsKey(measure.getName())) {\n+                                    ((Map<String, Measure>) result).put(measure.getName(), measure);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setMeasures(new ArrayList<Measure>(measures.values()));\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n+                Map<String, Dimension> dimensions = (Map<String, Dimension>) getInheritedAttribute(table,\n+                        new HashMap<String, Dimension>(), (tab, result) -> {\n+                            tab.getDimensions().forEach(dim -> {\n+                                if (!((Map<String, Dimension>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Dimension>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n+                Map<String, Join> joins = (Map<String, Join>) getInheritedAttribute(table,\n+                        new HashMap<String, Join>(), (tab, result) -> {\n+                            tab.getJoins().forEach(dim -> {\n+                                if (!((Map<String, Join>) result).containsKey(dim.getName())) {\n+                                    ((Map<String, Join>) result).put(dim.getName(), dim);\n+                                }\n+                            });\n+                            return result;\n+                        }, false\n+                );\n                 table.setJoins(new ArrayList<Join>(joins.values()));\n-            }\n-        }\n-    }\n \n-    private Map<String, Measure> getInheritedMeasures(Table table, Map<String, Measure> measures) {\n-        table.getMeasures().forEach(m -> {\n-            if (!measures.containsKey(m.getName())) {\n-                measures.put(m.getName(), m);\n+                String schema = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSchema();\n+                        }, true\n+                );\n+                table.setSchema(schema);\n+\n+                String dbConnectionName = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getDbConnectionName();\n+                        }, true\n+                );\n+                table.setDbConnectionName(dbConnectionName);\n+\n+                String readAccess = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getReadAccess();\n+                        }, true\n+                );\n+                table.setReadAccess(readAccess);\n+\n+                String sql = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getSql();\n+                        }, true\n+                );\n+                table.setSql(sql);\n+\n+                String tableName = (String) getInheritedAttribute(table, null,\n+                        (tab, result) -> {\n+                            return tab.getTable();\n+                        }, true\n+                );\n+                table.setTable(tableName);\n             }\n-        });\n-        if (table.hasParent()) {\n-            getInheritedMeasures(table.getParent(this.elideTableConfig), measures);\n         }\n-        return measures;\n     }\n \n-    private Map<String, Dimension> getInheritedDimensions(Table table, Map<String, Dimension> dimensions) {\n-        table.getDimensions().forEach(dim -> {\n-            if (!dimensions.containsKey(dim.getName())) {\n-                dimensions.put(dim.getName(), dim);\n-            }\n-        });\n-        if (table.hasParent()) {\n-            getInheritedDimensions(table.getParent(this.elideTableConfig), dimensions);\n-        }\n-        return dimensions;\n-    }\n \n-    private Map<String, Join> getInheritedJoins(Table table, Map<String, Join> joins) {\n-        table.getJoins().forEach(join -> {\n-            if (!joins.containsKey(join.getName())) {\n-                joins.put(join.getName(), join);\n-            }\n-        });\n+    private Object getInheritedAttribute(Table table, Object result, Inheritance action, boolean recurseOnlyIfNull) {", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxNzUzOA==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536817538", "bodyText": "Lots of casting like this makes the code hard to read (and generally can be removed through other means).", "author": "aklish", "createdAt": "2020-12-05T16:24:43Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -174,57 +175,114 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n+\n+        List<Table> tables = elideTableConfig.getTables().stream().collect(Collectors.toList());\n+        while (!tables.isEmpty()) {\n+            Table table = tables.remove(0);\n             if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+\n+                Table parent = table.getParent(elideTableConfig);\n+                // If parent also extends, ensure parent is processed first.\n+                if (parent.getExtend() != null && parent.getSql() == null && parent.getTable() == null) {\n+                    tables.add(table);\n+                    continue;\n+                }\n+\n+                Map<String, Measure> measures = (Map<String, Measure>) getInheritedAttribute(table,\n+                        new HashMap<String, Measure>(), (tab, result) -> {\n+                            tab.getMeasures().forEach(measure -> {\n+                                if (!((Map<String, Measure>) result).containsKey(measure.getName())) {", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxODA3Ng==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536818076", "bodyText": "I thought there was already a test for this.", "author": "aklish", "createdAt": "2020-12-05T16:28:21Z", "path": "elide-model-config/src/test/resources/validator/infinite_loop_cyclic_dependency_inheritance/models/tables/tableA.hjson", "diffHunk": "@@ -0,0 +1,18 @@\n+{\n+  tables:\n+  [\n+    {\n+      name: A\n+      extend: B\n+      description: A extends B (which extends A) - an invalid cycle.", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxODA4NA==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536818084", "bodyText": "Same comment.", "author": "aklish", "createdAt": "2020-12-05T16:28:34Z", "path": "elide-model-config/src/test/resources/validator/infinite_loop_cyclic_dependency_inheritance/models/tables/tableB.hjson", "diffHunk": "@@ -0,0 +1,18 @@\n+{\n+  tables:\n+  [\n+    {\n+      name: B\n+      extend: A\n+      description: B extends A (which extends B) - an invalid cycle.", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxODEyOQ==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536818129", "bodyText": "Same comment.", "author": "aklish", "createdAt": "2020-12-05T16:28:48Z", "path": "elide-model-config/src/test/resources/validator/infinite_loop_missing_parent_inheritance/models/tables/tableA.hjson", "diffHunk": "@@ -0,0 +1,18 @@\n+{\n+  tables:\n+  [\n+    {\n+      name: A\n+      extend: B\n+      description: A extends B (which doesn't exist)", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxODIzOQ==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536818239", "bodyText": "Don't we already have an extends test?  I'm confused why we needed to create so many new HJSON test files.", "author": "aklish", "createdAt": "2020-12-05T16:29:30Z", "path": "elide-model-config/src/test/resources/validator/table_sql_both_inheritance/models/tables/player_stats_extends.hjson", "diffHunk": "@@ -0,0 +1,36 @@\n+{\n+  tables:\n+  [\n+    {\n+      name: PlayerStatsChild\n+      extend: PlayerStats", "originalCommit": "5fae23633206107b6dba14479623499d7c28bd9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MjYzNA==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r536882634", "bodyText": "These tests are the same as those, but I wanted to have a test case specifically testing the infinite loop and issues related to that in case someone edits those validation methods and test files to work differently.", "author": "moizarafat", "createdAt": "2020-12-05T19:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgxODIzOQ=="}], "type": "inlineReview"}, {"oid": "bf1d1d84cf0581c3b6a17cda450cc4b4d948cff1", "url": "https://github.com/yahoo/elide/commit/bf1d1d84cf0581c3b6a17cda450cc4b4d948cff1", "message": "Review", "committedDate": "2020-12-07T03:34:42Z", "type": "commit"}, {"oid": "ecb4de91751bfc42b4138715c60c12cd4a8ab0df", "url": "https://github.com/yahoo/elide/commit/ecb4de91751bfc42b4138715c60c12cd4a8ab0df", "message": "Update pom.xml", "committedDate": "2020-12-07T03:38:12Z", "type": "commit"}, {"oid": "dc099d8931088345b54c2b444ea02f376baeb671", "url": "https://github.com/yahoo/elide/commit/dc099d8931088345b54c2b444ea02f376baeb671", "message": "Merge branch 'elide-5.x' into extends_features", "committedDate": "2020-12-07T18:21:32Z", "type": "commit"}, {"oid": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227", "url": "https://github.com/yahoo/elide/commit/b1e9eb50fee402f31cf6433abd8d7dc3b2103227", "message": "review", "committedDate": "2020-12-07T18:24:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4OTk2OQ==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537689969", "bodyText": "Why do we need this dependency?", "author": "aklish", "createdAt": "2020-12-07T17:28:26Z", "path": "elide-spring/elide-spring-boot-autoconfigure/pom.xml", "diffHunk": "@@ -209,6 +209,12 @@\n             <scope>test</scope>\n         </dependency>\n \n+        <dependency>", "originalCommit": "ecb4de91751bfc42b4138715c60c12cd4a8ab0df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MjQ0Ng==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537782446", "bodyText": "Earlier JUnit was pulled from an artifact within spring-boot-starter-test. But with latest version of spring-boot-dependencies that's not the case anymore.", "author": "moizarafat", "createdAt": "2020-12-07T19:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4OTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2NDI0NQ==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537764245", "bodyText": "Nitpick - but I would invert this if condition and return early if the opposite is true.  Then the entire function doesn't have to be nested inside this if block (it helps with line length and readability).", "author": "aklish", "createdAt": "2020-12-07T19:19:04Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -252,56 +251,156 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n     }\n \n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n-            if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n-                table.setMeasures(new ArrayList<Measure>(measures.values()));\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n-                table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n+        Set<Table> processed = new HashSet<Table>();\n+        elideTableConfig.getTables().stream().forEach(table -> {\n+            populateInheritance(table, processed);\n+        });\n+    }\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n-                table.setJoins(new ArrayList<Join>(joins.values()));\n+    private void populateInheritance(Table table, Set<Table> processed) {\n+        if (table.hasParent() && !processed.contains(table)) {", "originalCommit": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2OTg0NQ==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537769845", "bodyText": "shouldn't this be called on the parent rather than table?  Similar comment for other calls below.", "author": "aklish", "createdAt": "2020-12-07T19:27:46Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -252,56 +251,156 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n     }\n \n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n-            if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n-                table.setMeasures(new ArrayList<Measure>(measures.values()));\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n-                table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n+        Set<Table> processed = new HashSet<Table>();\n+        elideTableConfig.getTables().stream().forEach(table -> {\n+            populateInheritance(table, processed);\n+        });\n+    }\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n-                table.setJoins(new ArrayList<Join>(joins.values()));\n+    private void populateInheritance(Table table, Set<Table> processed) {\n+        if (table.hasParent() && !processed.contains(table)) {\n+            Table parent = table.getParent(this.elideTableConfig);\n+            // If parent also extends, ensure parent is processed first.\n+            if (parent.hasParent()) {\n+                populateInheritance(parent, processed);\n             }\n+\n+            Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());", "originalCommit": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4OTk0Nw==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537789947", "bodyText": "We first retrieve the measure list from current table and populate in the new HashMap in the getInheritedMeasures method. And in the same method we call it for Parent class too. Refer L-315.", "author": "moizarafat", "createdAt": "2020-12-07T19:56:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2OTg0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxMjc2Mw==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537812763", "bodyText": "But we shouldn't need to add the measures for the current table (as they are already defined in the table).  We only need to add the inherited measures.  This reads like we are duplicating what's already defined in the current table.", "author": "aklish", "createdAt": "2020-12-07T20:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2OTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3NDA5OA==", "url": "https://github.com/yahoo/elide/pull/1707#discussion_r537774098", "bodyText": "Do we really need to cast to String here?", "author": "aklish", "createdAt": "2020-12-07T19:33:12Z", "path": "elide-model-config/src/main/java/com/yahoo/elide/modelconfig/validator/DynamicConfigValidator.java", "diffHunk": "@@ -252,56 +251,156 @@ private static void validateInheritance(ElideTableConfig tables, Table table, Se\n     }\n \n     private void populateInheritance(ElideTableConfig elideTableConfig) {\n-        for (Table table : elideTableConfig.getTables()) {\n-            if (table.hasParent()) {\n-                Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n-                table.setMeasures(new ArrayList<Measure>(measures.values()));\n+        //ensures validation is run before populate always.\n+        validateInheritance(this.elideTableConfig);\n \n-                Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n-                table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n+        Set<Table> processed = new HashSet<Table>();\n+        elideTableConfig.getTables().stream().forEach(table -> {\n+            populateInheritance(table, processed);\n+        });\n+    }\n \n-                Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n-                table.setJoins(new ArrayList<Join>(joins.values()));\n+    private void populateInheritance(Table table, Set<Table> processed) {\n+        if (table.hasParent() && !processed.contains(table)) {\n+            Table parent = table.getParent(this.elideTableConfig);\n+            // If parent also extends, ensure parent is processed first.\n+            if (parent.hasParent()) {\n+                populateInheritance(parent, processed);\n             }\n+\n+            Map<String, Measure> measures = getInheritedMeasures(table, new HashMap<String, Measure>());\n+            table.setMeasures(new ArrayList<Measure>(measures.values()));\n+\n+            Map<String, Dimension> dimensions = getInheritedDimensions(table, new HashMap<String, Dimension>());\n+            table.setDimensions(new ArrayList<Dimension>(dimensions.values()));\n+\n+            Map<String, Join> joins = getInheritedJoins(table, new HashMap<String, Join>());\n+            table.setJoins(new ArrayList<Join>(joins.values()));\n+\n+            String schema = getInheritedSchema(table);\n+            table.setSchema(schema);\n+\n+            String dbConnectionName = (String) getInheritedConnection(table);\n+            table.setDbConnectionName(dbConnectionName);\n+\n+            String sql = (String) getInheritedSql(table);\n+            table.setSql(sql);\n+\n+            String tableName = (String) getInheritedTable(table);\n+            table.setTable(tableName);\n+\n+            // isFact, isHidden, ReadAccess have default Values in schema, so can not be inherited.\n+            // Other properties (tags, cardinality, etc.) have been categorized as non-inheritable too.\n         }\n+        processed.add(table);\n+    }\n+\n+\n+    @FunctionalInterface\n+    public interface Inheritance<T> {\n+        public T inherit();\n     }\n \n     private Map<String, Measure> getInheritedMeasures(Table table, Map<String, Measure> measures) {\n-        table.getMeasures().forEach(m -> {\n-            if (!measures.containsKey(m.getName())) {\n-                measures.put(m.getName(), m);\n-            }\n-        });\n+        Inheritance action = () -> {\n+                table.getMeasures().forEach(measure -> {\n+                    if (!measures.containsKey(measure.getName())) {\n+                        measures.put(measure.getName(), measure);\n+                    }\n+                });\n+                return measures;\n+        };\n+\n+        action.inherit();\n         if (table.hasParent()) {\n-            getInheritedMeasures(table.getParent(this.elideTableConfig), measures);\n+            getInheritedMeasures(table.getParent(elideTableConfig), measures);\n         }\n         return measures;\n     }\n \n     private Map<String, Dimension> getInheritedDimensions(Table table, Map<String, Dimension> dimensions) {\n-        table.getDimensions().forEach(dim -> {\n-            if (!dimensions.containsKey(dim.getName())) {\n-                dimensions.put(dim.getName(), dim);\n-            }\n-        });\n+        Inheritance action = () -> {\n+            table.getDimensions().forEach(dimension -> {\n+                if (!dimensions.containsKey(dimension.getName())) {\n+                    dimensions.put(dimension.getName(), dimension);\n+                }\n+            });\n+            return dimensions;\n+        };\n+        action.inherit();\n         if (table.hasParent()) {\n-            getInheritedDimensions(table.getParent(this.elideTableConfig), dimensions);\n+            getInheritedDimensions(table.getParent(elideTableConfig), dimensions);\n         }\n         return dimensions;\n     }\n \n     private Map<String, Join> getInheritedJoins(Table table, Map<String, Join> joins) {\n-        table.getJoins().forEach(join -> {\n-            if (!joins.containsKey(join.getName())) {\n-                joins.put(join.getName(), join);\n-            }\n-        });\n+        Inheritance action = () -> {\n+            table.getJoins().forEach(join -> {\n+                if (!joins.containsKey(join.getName())) {\n+                    joins.put(join.getName(), join);\n+                }\n+            });\n+            return joins;\n+        };\n+        action.inherit();\n         if (table.hasParent()) {\n-            getInheritedJoins(table.getParent(this.elideTableConfig), joins);\n+            getInheritedJoins(table.getParent(elideTableConfig), joins);\n         }\n         return joins;\n     }\n \n+    private String getInheritedSchema(Table table) {\n+        Inheritance action = () -> {\n+            return table.getSchema();\n+        };\n+\n+        String schema = (String) action.inherit();\n+\n+        if (schema == null && table.hasParent()) {\n+            schema = getInheritedSchema(table.getParent(elideTableConfig));\n+        }\n+        return schema;\n+    }\n+\n+    private String getInheritedConnection(Table table) {\n+        Inheritance action = () -> {\n+            return table.getDbConnectionName();\n+        };\n+\n+        String conn = (String) action.inherit();", "originalCommit": "b1e9eb50fee402f31cf6433abd8d7dc3b2103227", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3218a3290b789fa6792becda0da1843308ddbcef", "url": "https://github.com/yahoo/elide/commit/3218a3290b789fa6792becda0da1843308ddbcef", "message": "review", "committedDate": "2020-12-07T21:33:49Z", "type": "commit"}, {"oid": "f01c8ed3d835d286128b643d36013048087d40d3", "url": "https://github.com/yahoo/elide/commit/f01c8ed3d835d286128b643d36013048087d40d3", "message": "review", "committedDate": "2020-12-07T21:37:47Z", "type": "commit"}, {"oid": "35960f69ba7eda1f050996602c72b47504f468fc", "url": "https://github.com/yahoo/elide/commit/35960f69ba7eda1f050996602c72b47504f468fc", "message": "review", "committedDate": "2020-12-07T22:08:39Z", "type": "commit"}, {"oid": "4fe50d0bf2565fc8ea2f2ea5dd048b231584fecb", "url": "https://github.com/yahoo/elide/commit/4fe50d0bf2565fc8ea2f2ea5dd048b231584fecb", "message": "CVE errors for tomcat embed", "committedDate": "2020-12-07T22:52:59Z", "type": "commit"}]}