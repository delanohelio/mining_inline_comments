{"pr_number": 1319, "pr_title": "Add caching support to SQLQueryEngine", "pr_createdAt": "2020-05-12T23:41:31Z", "pr_url": "https://github.com/yahoo/elide/pull/1319", "timeline": [{"oid": "671b0e1da42ac92fe17eeef5146a49fa4edb7244", "url": "https://github.com/yahoo/elide/commit/671b0e1da42ac92fe17eeef5146a49fa4edb7244", "message": "Add SQLQueryEngine cache unit tests", "committedDate": "2020-05-13T16:28:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2NDQ4MQ==", "url": "https://github.com/yahoo/elide/pull/1319#discussion_r424664481", "bodyText": "Ideally, I think this is where the cache ought to be queried for entries.  This would allow the same cache to be used for multiple engines (Fili, SQL, etc).  I think the cache key generation logic itself could be common as well.  The key could be derived from the Query object itself (rather than the generated SQL) plus data freshness key (which the query engine could surface).", "author": "aklish", "createdAt": "2020-05-13T19:00:35Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/AggregationDataStoreTransaction.java", "diffHunk": "@@ -53,7 +53,7 @@ public void createObject(Object entity, RequestScope scope) {\n     @Override\n     public Iterable<Object> loadObjects(EntityProjection entityProjection, RequestScope scope) {\n         Query query = buildQuery(entityProjection, scope);\n-        return queryEngine.executeQuery(query, true);\n+        return queryEngine.executeQuery(query);", "originalCommit": "671b0e1da42ac92fe17eeef5146a49fa4edb7244", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2NTkyNQ==", "url": "https://github.com/yahoo/elide/pull/1319#discussion_r424665925", "bodyText": "TableVersion as a string would be more flexible.", "author": "aklish", "createdAt": "2020-05-13T19:03:10Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -177,6 +184,56 @@ public MetricProjection constructMetricProjection(Metric metric,\n         }\n     }\n \n+    private long getPageTotal(Query query, SQLQuery sql, EntityManager entityManager, int tableVersion) {\n+        String paginationSQL = toPageTotalSQL(sql).toString();\n+\n+        // check cache first\n+        String paginationCacheKey = null;\n+        if (cache != null && !query.isBypassingCache()) {\n+            paginationCacheKey = tableVersion + \" \" + paginationSQL;\n+            Object pageTotalResult = cache.get(paginationCacheKey);\n+            if (pageTotalResult != null) {\n+                return (Long) pageTotalResult;\n+            }\n+        }\n+\n+        javax.persistence.Query pageTotalQuery =\n+                entityManager.createNativeQuery(paginationSQL)\n+                        .setHint(QueryHints.HINT_READONLY, true);\n+\n+        //Supply the query parameters to the query\n+        supplyFilterQueryParameters(query, pageTotalQuery);\n+\n+        //Run the Pagination query and log the time spent.\n+        long total = new TimedFunction<>(\n+                () -> CoerceUtil.coerce(pageTotalQuery.getSingleResult(), Long.class),\n+                \"Running Query: \" + paginationSQL\n+        ).get();\n+\n+        if (paginationCacheKey != null) {\n+            cache.put(paginationCacheKey, total);\n+        }\n+        return total;\n+    }\n+\n+    private int getTableVersion(EntityManager entityManager, Query query) {", "originalCommit": "671b0e1da42ac92fe17eeef5146a49fa4edb7244", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2NjAxNw==", "url": "https://github.com/yahoo/elide/pull/1319#discussion_r424666017", "bodyText": "2020", "author": "aklish", "createdAt": "2020-05-13T19:03:21Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/annotation/VersionQuery.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2019, Yahoo Inc.", "originalCommit": "671b0e1da42ac92fe17eeef5146a49fa4edb7244", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e1b377837311dcf5092bd7a1df135995289ebbd2", "url": "https://github.com/yahoo/elide/commit/e1b377837311dcf5092bd7a1df135995289ebbd2", "message": "Add SQLQueryEngine cache unit tests", "committedDate": "2020-05-20T23:10:48Z", "type": "forcePushed"}, {"oid": "ca834a3bb8c910b77c8ebba053628c15fd84ddbc", "url": "https://github.com/yahoo/elide/commit/ca834a3bb8c910b77c8ebba053628c15fd84ddbc", "message": "Declare query dimensions / metrics non-null", "committedDate": "2020-05-26T17:23:26Z", "type": "forcePushed"}, {"oid": "b1ad3eacd4d9a451a498fc7328b6ab14ed48b1df", "url": "https://github.com/yahoo/elide/commit/b1ad3eacd4d9a451a498fc7328b6ab14ed48b1df", "message": "Declare query dimensions / metrics non-null", "committedDate": "2020-05-26T17:25:46Z", "type": "forcePushed"}, {"oid": "43fe07875808278e23a4d7394bb8a7ecf00777a4", "url": "https://github.com/yahoo/elide/commit/43fe07875808278e23a4d7394bb8a7ecf00777a4", "message": "Support caching in SQLQueryEngine", "committedDate": "2020-06-05T00:30:27Z", "type": "commit"}, {"oid": "30536fa403489202094f30bf8032ff97bc892963", "url": "https://github.com/yahoo/elide/commit/30536fa403489202094f30bf8032ff97bc892963", "message": "Allow SQLUnitTest.init to set cache", "committedDate": "2020-06-05T00:30:27Z", "type": "commit"}, {"oid": "f83c3ae2445f5f80e5deb7ee561283ab82c12e6d", "url": "https://github.com/yahoo/elide/commit/f83c3ae2445f5f80e5deb7ee561283ab82c12e6d", "message": "Add SQLQueryEngine cache unit tests", "committedDate": "2020-06-05T00:30:27Z", "type": "commit"}, {"oid": "a0a519458664445cd90d6fdb3f25216e3def5273", "url": "https://github.com/yahoo/elide/commit/a0a519458664445cd90d6fdb3f25216e3def5273", "message": "Declare query dimensions / metrics non-null", "committedDate": "2020-06-05T00:30:27Z", "type": "commit"}, {"oid": "d058b68b8e8f61a9e6d350a231d0121e130ad48f", "url": "https://github.com/yahoo/elide/commit/d058b68b8e8f61a9e6d350a231d0121e130ad48f", "message": "Handle table version as String", "committedDate": "2020-06-05T00:30:27Z", "type": "commit"}, {"oid": "e5bbde3fd6281a256379f8db71a44854375429ce", "url": "https://github.com/yahoo/elide/commit/e5bbde3fd6281a256379f8db71a44854375429ce", "message": "Polish QueryKeyExtractor", "committedDate": "2020-06-05T00:30:27Z", "type": "commit"}, {"oid": "92c684650eb57b8d9fd26098703f77f392425cdc", "url": "https://github.com/yahoo/elide/commit/92c684650eb57b8d9fd26098703f77f392425cdc", "message": "Add QueryKeyExtractor UTs", "committedDate": "2020-06-05T00:30:27Z", "type": "commit"}, {"oid": "b335876a0d77375095c11405e6c430d78df9f503", "url": "https://github.com/yahoo/elide/commit/b335876a0d77375095c11405e6c430d78df9f503", "message": "Manage QueryEngine.Transaction in AggregationDataStoreTransaction", "committedDate": "2020-06-05T00:31:49Z", "type": "forcePushed"}, {"oid": "02793dd214e2aa305502b02dbefc3274f9839670", "url": "https://github.com/yahoo/elide/commit/02793dd214e2aa305502b02dbefc3274f9839670", "message": "Manage QueryEngine.Transaction in AggregationDataStoreTransaction", "committedDate": "2020-06-08T21:06:00Z", "type": "commit"}, {"oid": "02793dd214e2aa305502b02dbefc3274f9839670", "url": "https://github.com/yahoo/elide/commit/02793dd214e2aa305502b02dbefc3274f9839670", "message": "Manage QueryEngine.Transaction in AggregationDataStoreTransaction", "committedDate": "2020-06-08T21:06:00Z", "type": "forcePushed"}, {"oid": "e149baba7ff14065e4a73dbdb46bb38b1fb09912", "url": "https://github.com/yahoo/elide/commit/e149baba7ff14065e4a73dbdb46bb38b1fb09912", "message": "Fix UTs", "committedDate": "2020-06-09T21:51:37Z", "type": "commit"}, {"oid": "caf7ce2dc06efc30ae0240d16ea5fae3caf67e1d", "url": "https://github.com/yahoo/elide/commit/caf7ce2dc06efc30ae0240d16ea5fae3caf67e1d", "message": "Fix assertEquals in existing UT", "committedDate": "2020-06-09T21:52:52Z", "type": "commit"}, {"oid": "972bb1916af7fa6e8c2db57f60093576545d0d47", "url": "https://github.com/yahoo/elide/commit/972bb1916af7fa6e8c2db57f60093576545d0d47", "message": "Move caching to AggregationDataStoreTransaction", "committedDate": "2020-06-11T18:56:21Z", "type": "commit"}, {"oid": "aa3c852a1932c79a384683e3359db79a0b2f4f7c", "url": "https://github.com/yahoo/elide/commit/aa3c852a1932c79a384683e3359db79a0b2f4f7c", "message": "Change getTableVersion to take table argument", "committedDate": "2020-06-11T19:46:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMTAwNw==", "url": "https://github.com/yahoo/elide/pull/1319#discussion_r439511007", "bodyText": "I think we'll need some Javadoc here so the linter won't warn.", "author": "aklish", "createdAt": "2020-06-12T16:10:15Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryEngine.java", "diffHunk": "@@ -156,14 +151,32 @@ private void populateMetaData(MetaDataStore metaDataStore) {\n                 .forEach(metaDataStore::addTable);\n     }\n \n+    public interface Transaction extends AutoCloseable {", "originalCommit": "aa3c852a1932c79a384683e3359db79a0b2f4f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMTkxNw==", "url": "https://github.com/yahoo/elide/pull/1319#discussion_r439511917", "bodyText": "Same.  Also we are adding a cancel method in another PR.  Do see these as the same thing?  For cancel, the expectation is the method is thread safe.  If we consolidate them - we'll need the same comment here.", "author": "aklish", "createdAt": "2020-06-12T16:11:21Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryEngine.java", "diffHunk": "@@ -156,14 +151,32 @@ private void populateMetaData(MetaDataStore metaDataStore) {\n                 .forEach(metaDataStore::addTable);\n     }\n \n+    public interface Transaction extends AutoCloseable {\n+        @Override\n+        void close();", "originalCommit": "aa3c852a1932c79a384683e3359db79a0b2f4f7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwODk1OA==", "url": "https://github.com/yahoo/elide/pull/1319#discussion_r439608958", "bodyText": "I assume if cancel() is called on a AggregationDataStoreTransaction that it ends the whole transaction, not just any pending calls such as loadObjects? (There won't be a use case for aborting loadObjects but still being able to use the same AggregationDataStoreTransaction after.)", "author": "john-karp", "createdAt": "2020-06-12T19:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMTkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMzA0Nw==", "url": "https://github.com/yahoo/elide/pull/1319#discussion_r439513047", "bodyText": "You might want to mention that if one is not available, returns null which disables caching.", "author": "aklish", "createdAt": "2020-06-12T16:12:48Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryEngine.java", "diffHunk": "@@ -156,14 +151,32 @@ private void populateMetaData(MetaDataStore metaDataStore) {\n                 .forEach(metaDataStore::addTable);\n     }\n \n+    public interface Transaction extends AutoCloseable {\n+        @Override\n+        void close();\n+    }\n+\n+    public abstract Transaction beginTransaction();\n+\n     /**\n      * Executes the specified {@link Query} against a specific persistent storage, which understand the provided\n      * {@link Query}. Results may be taken from a cache, if configured.\n      *\n      * @param query The query customized for a particular persistent storage or storage client\n+     * @param transaction\n      * @return query results\n      */\n-    public abstract QueryResult executeQuery(Query query);\n+    public abstract QueryResult executeQuery(Query query, Transaction transaction);\n+\n+    /**\n+     * Get a serial number or other token indicating the version of the data in the table.\n+     * No particular semantics are required, though it must change if the data changes.\n+     * If one is not available, returns null.", "originalCommit": "aa3c852a1932c79a384683e3359db79a0b2f4f7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUyNzE0Ng==", "url": "https://github.com/yahoo/elide/pull/1319#discussion_r439527146", "bodyText": "Does this test execution depend on the prior test executing first?  I think we should make each test stand on its own.", "author": "aklish", "createdAt": "2020-06-12T16:38:03Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/AggregationDataStoreTransactionTest.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+\n+package com.yahoo.elide.datastores.aggregation;\n+\n+import static com.yahoo.elide.request.Pagination.DEFAULT_PAGE_LIMIT;\n+import static com.yahoo.elide.request.Pagination.MAX_PAGE_LIMIT;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.pagination.PaginationImpl;\n+import com.yahoo.elide.datastores.aggregation.example.PlayerStats;\n+import com.yahoo.elide.datastores.aggregation.framework.SQLUnitTest;\n+import com.yahoo.elide.datastores.aggregation.query.Cache;\n+import com.yahoo.elide.datastores.aggregation.query.Query;\n+import com.yahoo.elide.datastores.aggregation.query.QueryKeyExtractor;\n+import com.yahoo.elide.datastores.aggregation.query.QueryResult;\n+import com.yahoo.elide.request.EntityProjection;\n+import com.yahoo.elide.request.Pagination;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Collections;\n+\n+@ExtendWith(MockitoExtension.class)\n+class AggregationDataStoreTransactionTest extends SQLUnitTest {\n+\n+    @Mock private QueryEngine queryEngine;\n+    @Mock private QueryEngine.Transaction qeTransaction;\n+    @Mock private RequestScope scope;\n+    @Mock private Cache cache;\n+\n+    private Query query = Query.builder().table(playerStatsTable).build();\n+    private final String queryKey = QueryKeyExtractor.extractKey(query);\n+    private static final Iterable<Object> DATA = Collections.singletonList(\"xyzzy\");\n+\n+    // inject our own query instead of using buildQuery impl\n+    private class MyAggregationDataStoreTransaction extends AggregationDataStoreTransaction {\n+\n+        public MyAggregationDataStoreTransaction(QueryEngine queryEngine, Cache cache) {\n+            super(queryEngine, cache);\n+        }\n+\n+        @Override\n+        protected Query buildQuery(EntityProjection entityProjection, RequestScope scope) {\n+            return query;\n+        }\n+    }\n+\n+    @BeforeAll\n+    public static void beforeAllTests() {\n+        SQLUnitTest.init();\n+    }\n+\n+    @BeforeEach\n+    public void setUp() {\n+        when(queryEngine.beginTransaction()).thenReturn(qeTransaction);\n+    }\n+\n+    @Test\n+    void loadObjectsPopulatesCache() {\n+        QueryResult queryResult = QueryResult.builder().data(DATA).build();\n+        when(queryEngine.getTableVersion(playerStatsTable, qeTransaction)).thenReturn(\"foo\");\n+        when(queryEngine.executeQuery(query, qeTransaction)).thenReturn(queryResult);\n+        AggregationDataStoreTransaction transaction = new MyAggregationDataStoreTransaction(queryEngine, cache);\n+        EntityProjection entityProjection = EntityProjection.builder().type(PlayerStats.class).build();\n+\n+        assertEquals(DATA, transaction.loadObjects(entityProjection, scope));\n+\n+        String cacheKey = \"foo;\" + queryKey;\n+        Mockito.verify(cache).get(cacheKey);\n+        Mockito.verify(cache).put(cacheKey, queryResult);\n+        Mockito.verifyNoMoreInteractions(cache);\n+    }\n+\n+    @Test\n+    void loadObjectsUsesCache() {\n+        QueryResult queryResult = QueryResult.builder().data(DATA).build();", "originalCommit": "aa3c852a1932c79a384683e3359db79a0b2f4f7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU2MjI2OA==", "url": "https://github.com/yahoo/elide/pull/1319#discussion_r439562268", "bodyText": "No, the fields annotated with @Mock, such as the cache, get reset for each test, and the rest of the fields used in the tests are immutable. So loadObjectsUsesCache is inserting a cache entry before this test with when(cache.get(anyString())).thenReturn(queryResult);.", "author": "john-karp", "createdAt": "2020-06-12T17:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUyNzE0Ng=="}], "type": "inlineReview"}, {"oid": "559c960e3b99ed75ad8322b464017fa2d1ffd272", "url": "https://github.com/yahoo/elide/commit/559c960e3b99ed75ad8322b464017fa2d1ffd272", "message": "Address review comments", "committedDate": "2020-06-12T18:01:14Z", "type": "commit"}]}