{"pr_number": 1523, "pr_title": "Query Engine and Aggregation Store Changes for Multi Data Source Support", "pr_createdAt": "2020-09-08T16:31:37Z", "pr_url": "https://github.com/yahoo/elide/pull/1523", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2ODkzNA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485068934", "bodyText": "I think ENUM would be better in the long run.", "author": "moizarafat", "createdAt": "2020-09-08T17:02:13Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/resources/elideDBConfigSchema.json", "diffHunk": "@@ -70,9 +70,9 @@\n                         \"type\": \"string\",\n                         \"title\": \"Elide Dialect\",\n                         \"description\": \"The Elide Dialect to use for query generation.\",\n-                        \"pattern\": \"^([0-9A-Za-z_]+[.]?)+$\",\n+                        \"pattern\": \"^([h|H]2|[h|H][i|I][v|V][e|E]|[p|P][r|R][e|E][s|S][t|T][o|O])$\",", "originalCommit": "33066ea45b06474cf68125d9bea8663fc9406d15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwNjM3OQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485106379", "bodyText": "changed to ENUM, will allow upper case only", "author": "rishi-aga", "createdAt": "2020-09-08T18:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2ODkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3NDc0MA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485074740", "bodyText": "since there are no plans to support this, we can remove it from here and the abstract class.", "author": "moizarafat", "createdAt": "2020-09-08T17:12:40Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLEntityHydrator.java", "diffHunk": "@@ -9,78 +9,37 @@\n import com.yahoo.elide.datastores.aggregation.QueryEngine;\n import com.yahoo.elide.datastores.aggregation.query.Query;\n import com.yahoo.elide.datastores.aggregation.queryengines.AbstractEntityHydrator;\n-import com.yahoo.elide.utils.coerce.CoerceUtil;\n-import lombok.AccessLevel;\n-import lombok.Getter;\n \n-import java.util.AbstractMap;\n+import java.sql.ResultSet;\n import java.util.Collections;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.persistence.EntityManager;\n \n /**\n  * {@link SQLEntityHydrator} hydrates the entity loaded by\n  * {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}.\n  */\n public class SQLEntityHydrator extends AbstractEntityHydrator {\n \n-    @Getter(AccessLevel.PRIVATE)\n-    private final EntityManager entityManager;\n-\n     /**\n      * Constructor.\n      *\n      * @param results The loaded objects from {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}\n      * @param query  The query passed to {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)} to load the\n      *               objects\n      * @param entityDictionary  An object that sets entity instance values and provides entity metadata info\n-     * @param entityManager  An service that issues JPQL queries to load relationship objects\n      */\n     public SQLEntityHydrator(\n-            List<Object> results,\n+            ResultSet results,\n             Query query,\n-            EntityDictionary entityDictionary,\n-            EntityManager entityManager\n+            EntityDictionary entityDictionary\n     ) {\n         super(results, query, entityDictionary);\n-        this.entityManager = entityManager;\n     }\n \n     @Override\n-    protected Map<Object, Object> getRelationshipValues(\n-            Class<?> relationshipType,\n-            List<Object> joinFieldIds\n-    ) {\n-        if (joinFieldIds.isEmpty()) {\n-            return Collections.emptyMap();\n-        }\n-\n-        List<Object> uniqueIds = joinFieldIds.stream()\n-                .distinct()\n-                .collect(Collectors.toCollection(LinkedList::new));\n-\n-        List<Object> loaded = getEntityManager()\n-                .createQuery(\n-                        String.format(\n-                                \"SELECT e FROM %s e WHERE %s IN (:idList)\",\n-                                relationshipType.getCanonicalName(),\n-                                getEntityDictionary().getIdFieldName(relationshipType)\n-                        )\n-                )\n-                .setParameter(\"idList\", uniqueIds)\n-                .getResultList();\n-\n-        return loaded.stream()\n-                .map(obj -> new AbstractMap.SimpleImmutableEntry<>(\n-                        CoerceUtil.coerce(\n-                                (Object) getEntityDictionary().getId(obj),\n-                                getEntityDictionary().getIdType(relationshipType)\n-                        ),\n-                        obj))\n-                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    protected Map<Object, Object> getRelationshipValues(Class<?> relationshipType, List<Object> joinFieldIds) {", "originalCommit": "33066ea45b06474cf68125d9bea8663fc9406d15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwNjUxNQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485106515", "bodyText": "removed related methods.", "author": "rishi-aga", "createdAt": "2020-09-08T18:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3NDc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0ODY2Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485248663", "bodyText": "should we close the connection before throwing the exception or connection close is going to be handled some place else?", "author": "moizarafat", "createdAt": "2020-09-08T23:24:48Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +144,209 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private final Connection conn;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+        private final SQLDialect dialect;\n+\n+        SqlTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n+            stmts.forEach(stmt -> {\n+                try {\n+                    if (stmt != null && !stmt.isClosed()) {\n+                        stmt.close();\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalStateException(e);", "originalCommit": "33066ea45b06474cf68125d9bea8663fc9406d15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxNzU5NA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485617594", "bodyText": "Updated it to just log the exception instead of throwing it.", "author": "rishi-aga", "createdAt": "2020-09-09T13:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0ODY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1MDA3MA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485250070", "bodyText": "Same as above, we should close the connection as well.", "author": "moizarafat", "createdAt": "2020-09-08T23:29:31Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +144,209 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private final Connection conn;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+        private final SQLDialect dialect;\n+\n+        SqlTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n+            stmts.forEach(stmt -> {\n+                try {\n+                    if (stmt != null && !stmt.isClosed()) {\n+                        stmt.close();\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+            try {\n+                if (conn != null) {\n+                    conn.close();\n+                }\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> {\n+                try {\n+                    if (stmt != null && !stmt.isClosed()) {\n+                        stmt.cancel();\n+                    }\n+                } catch (SQLException e) {\n+                    throw new IllegalStateException(e);\n+                }", "originalCommit": "2cb30cf498da691be1dec47cbf872296f18249cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxNjkyOQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485616929", "bodyText": "I am assuming, connection closing will be handled by close method and cancel method is for stopping the running queries.", "author": "rishi-aga", "createdAt": "2020-09-09T13:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1MDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NDE5OA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485254198", "bodyText": "Lets check with Aaron, I think this method seems very specific to SQLQueryEngine, so not a good candidate to be included in the interface here. We can just have it created and used in SQLQuery Engine itself.", "author": "moizarafat", "createdAt": "2020-09-08T23:43:02Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryEngine.java", "diffHunk": "@@ -167,6 +167,8 @@ private void populateMetaData(MetaDataStore metaDataStore) {\n \n     public abstract Transaction beginTransaction();\n \n+    public abstract Transaction beginTransaction(String dbConnectionName);", "originalCommit": "2cb30cf498da691be1dec47cbf872296f18249cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxOTQzOA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485619438", "bodyText": "this is called from AggregationDataStoreTransaction which uses QueryEngine interface so had to add it here.", "author": "rishi-aga", "createdAt": "2020-09-09T13:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NDE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMTcyMQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486411721", "bodyText": "I tend to agree with Moiz.  Everything inside dynamic config is tightly coupled with with the SQLQueryEngine.  Other query engines might have a totally different configuration (like Fili for example).", "author": "aklish", "createdAt": "2020-09-10T14:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NDE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NDY4Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487084683", "bodyText": "created a new class SQLAggregationDataStoreTransaction which extends AggregationDataStoreTransaction (which is abstract now)", "author": "rishi-aga", "createdAt": "2020-09-11T14:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NDE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NDI1NQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485254255", "bodyText": "Same comment as other method.", "author": "moizarafat", "createdAt": "2020-09-08T23:43:16Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/QueryEngine.java", "diffHunk": "@@ -219,4 +221,13 @@ public Table getTable(TableId tableId) {\n      */\n     public abstract List<String> explain(Query query);\n \n+    /**\n+     * Returns the actual query string(s) that would be executed for the input {@link Query}.\n+     *\n+     * @param query The query customized for a particular persistent storage or storage client.\n+     * @param connectionName Connection Name for this storage\n+     * @return List of SQL string(s) corresponding to the given query.\n+     */\n+    public abstract List<String> explain(Query query, String connectionName);", "originalCommit": "2cb30cf498da691be1dec47cbf872296f18249cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NTYxNg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485255616", "bodyText": "\" OFFSET \"  and \" LIMIT \" can be made static variables and reused.", "author": "moizarafat", "createdAt": "2020-09-08T23:47:47Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/dialects/AbstractSqlDialect.java", "diffHunk": "@@ -14,7 +14,13 @@ public boolean useAliasForOrderByClause() {\n         return false;\n     }\n \n+    @Override\n     public String generateCountDistinctClause(String dimensions) {\n         return String.format(\"COUNT(DISTINCT(%s))\", dimensions);\n     }\n+\n+    @Override\n+    public String appendOffsetLimit(String sql, int offset, int limit) {\n+        return sql + \" OFFSET \" + offset + \" LIMIT \" + limit;", "originalCommit": "2cb30cf498da691be1dec47cbf872296f18249cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxNTgzMA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485615830", "bodyText": "\ud83d\udc4d", "author": "rishi-aga", "createdAt": "2020-09-09T13:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1NTYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1Nzk2OA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485257968", "bodyText": "this could call the constructor with 4 args instead.", "author": "moizarafat", "createdAt": "2020-09-08T23:55:42Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/AggregationDataStoreTestHarness.java", "diffHunk": "@@ -11,31 +11,49 @@\n import com.yahoo.elide.datastores.aggregation.core.NoopQueryLogger;\n import com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore;\n import com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.SQLDialectFactory;\n import com.yahoo.elide.datastores.jpa.JpaDataStore;\n import com.yahoo.elide.datastores.jpa.transaction.NonJtaTransaction;\n import com.yahoo.elide.datastores.multiplex.MultiplexManager;\n \n import org.hibernate.Session;\n \n+import lombok.AllArgsConstructor;\n+\n+import java.util.Collections;\n+import java.util.Map;\n import java.util.function.Consumer;\n \n import javax.persistence.EntityManager;\n import javax.persistence.EntityManagerFactory;\n+import javax.sql.DataSource;\n \n+@AllArgsConstructor\n public class AggregationDataStoreTestHarness implements DataStoreTestHarness {\n     private EntityManagerFactory entityManagerFactory;\n+    private DataSource defaultDataSource;\n+    private Map<String, DataSource> dataSourceMap;\n+    private String defaultDialect;\n+    private Map<String, String> dialectMap;\n+\n+    public AggregationDataStoreTestHarness(EntityManagerFactory entityManagerFactory, DataSource defaultDataSource) {\n+        this(entityManagerFactory, defaultDataSource, Collections.emptyMap(),", "originalCommit": "2cb30cf498da691be1dec47cbf872296f18249cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxNTUzNg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485615536", "bodyText": "updated to call the constructor with 3 args.", "author": "rishi-aga", "createdAt": "2020-09-09T13:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1Nzk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1OTAzMw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485259033", "bodyText": "This can still take Argument of Type SQLDialect", "author": "moizarafat", "createdAt": "2020-09-08T23:59:15Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/SQLUnitTest.java", "diffHunk": "@@ -298,14 +299,19 @@ public Query getQuery() {\n \n     protected Pattern repeatedWhitespacePattern = Pattern.compile(\"\\\\s\\\\s*\");\n \n-    public static void init(SQLDialect sqlDialect) {\n+    public static void init(String sqlDialect) {", "originalCommit": "2cb30cf498da691be1dec47cbf872296f18249cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxNTAwNg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r485615006", "bodyText": "yes, I left it as it was used in other test classes but can be removed if required.", "author": "rishi-aga", "createdAt": "2020-09-09T13:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI1OTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQwNjcxNw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486406717", "bodyText": "Cleaner to have a single map that stores a new class that includes both the data source and its dialect.  Then there is no way for state to get out of sync.", "author": "aklish", "createdAt": "2020-09-10T14:50:39Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/compile/ElideDynamicEntityCompiler.java", "diffHunk": "@@ -41,6 +47,8 @@\n \n     private Map<String, String> tableClasses = new HashMap<String, String>();\n     private Map<String, String> securityClasses = new HashMap<String, String>();\n+    @Getter private final Map<String, DataSource> dataSourceMap = new HashMap<String, DataSource>();", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NTUyMw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487085523", "bodyText": "updated.", "author": "rishi-aga", "createdAt": "2020-09-11T14:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQwNjcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQwODYwMA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486408600", "bodyText": "A fixed enum makes this hard to extend if someone wants to customize for their own database.  I would recommend we configure the elide Dialect class here.", "author": "aklish", "createdAt": "2020-09-10T14:53:08Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/resources/elideDBConfigSchema.json", "diffHunk": "@@ -70,9 +70,13 @@\n                         \"type\": \"string\",\n                         \"title\": \"Elide Dialect\",\n                         \"description\": \"The Elide Dialect to use for query generation.\",\n-                        \"pattern\": \"^([0-9A-Za-z_]+[.]?)+$\",\n+                        \"enum\": [\n+                            \"HIVE\",", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1ODEwNg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487058106", "bodyText": "ok.", "author": "rishi-aga", "createdAt": "2020-09-11T13:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQwODYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMjM5OQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486412399", "bodyText": "I don't think we need the stitchList anymore - that was for populating relationships.", "author": "aklish", "createdAt": "2020-09-10T14:58:10Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/AbstractEntityHydrator.java", "diffHunk": "@@ -86,48 +88,37 @@ public AbstractEntityHydrator(List<Object> results, Query query, EntityDictionar\n         });\n     }\n \n-    /**\n-     * Loads a map of relationship object ID to relationship object instance.\n-     * <p>\n-     * Note the relationship cannot be toMany. This method will be invoked for every relationship field of the\n-     * requested entity. Its implementation should return the result of the following query\n-     * <p>\n-     * <b>Given a relationship with type {@code relationshipType} in an entity, loads all relationship\n-     * objects whose foreign keys are one of the specified list, {@code joinFieldIds}</b>.\n-     * <p>\n-     * For example, when the relationship is loaded from SQL and we have the following example identity:\n-     * <pre>\n-     * public class PlayerStats {\n-     *     private String id;\n-     *     private Country country;\n-     *\n-     *     &#64;OneToOne\n-     *     &#64;JoinColumn(name = \"country_id\")\n-     *     public Country getCountry() {\n-     *         return country;\n-     *     }\n-     * }\n-     * </pre>\n-     * In this case {@code relationshipType = Country.class}. If {@code country} is\n-     * requested in {@code PlayerStats} query and 3 stats, for example, are found in database whose country ID's are\n-     * {@code joinFieldIds = [840, 344, 840]}, then this method should effectively run the following query (JPQL as\n-     * example)\n-     * <pre>\n-     * {@code\n-     *     SELECT e FROM country_table e WHERE country_id IN (840, 344);\n-     * }\n-     * </pre>\n-     * and returns the map of [840: Country(id:840), 344: Country(id:344)]\n-     *\n-     * @param relationshipType  The type of relationship\n-     * @param joinFieldIds  The specified list of join ID's against the relationship\n-     *\n-     * @return a list of hydrating values\n-     */\n-    protected abstract Map<Object, Object> getRelationshipValues(\n-            Class<?> relationshipType,\n-            List<Object> joinFieldIds\n-    );\n+    public AbstractEntityHydrator(ResultSet rs, Query query, EntityDictionary entityDictionary) {\n+        this.stitchList = new StitchList(entityDictionary);", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NTczMA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487085730", "bodyText": "removed StitchList class.", "author": "rishi-aga", "createdAt": "2020-09-11T14:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMjM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMzk0MQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486413941", "bodyText": "Why do we still need an entityManagerFactory if we are using Hikari and JDBC directly?", "author": "aklish", "createdAt": "2020-09-10T15:00:14Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/AggregationDataStoreTestHarness.java", "diffHunk": "@@ -11,31 +11,48 @@\n import com.yahoo.elide.datastores.aggregation.core.NoopQueryLogger;\n import com.yahoo.elide.datastores.aggregation.metadata.MetaDataStore;\n import com.yahoo.elide.datastores.aggregation.queryengines.sql.SQLQueryEngine;\n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.SQLDialectFactory;\n import com.yahoo.elide.datastores.jpa.JpaDataStore;\n import com.yahoo.elide.datastores.jpa.transaction.NonJtaTransaction;\n import com.yahoo.elide.datastores.multiplex.MultiplexManager;\n \n import org.hibernate.Session;\n \n+import lombok.AllArgsConstructor;\n+\n+import java.util.Collections;\n+import java.util.Map;\n import java.util.function.Consumer;\n \n import javax.persistence.EntityManager;\n import javax.persistence.EntityManagerFactory;\n+import javax.sql.DataSource;\n \n+@AllArgsConstructor\n public class AggregationDataStoreTestHarness implements DataStoreTestHarness {\n     private EntityManagerFactory entityManagerFactory;\n+    private DataSource defaultDataSource;", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1Nzg5MA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487057890", "bodyText": "entityManagerFactory is still required for JPA datastore.", "author": "rishi-aga", "createdAt": "2020-09-11T13:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxMzk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxNjM5NQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486416395", "bodyText": "Maybe we can merge this with AbstractEntityHyrdator now that this doesn't do anything.", "author": "aklish", "createdAt": "2020-09-10T15:03:36Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLEntityHydrator.java", "diffHunk": "@@ -9,78 +9,28 @@\n import com.yahoo.elide.datastores.aggregation.QueryEngine;\n import com.yahoo.elide.datastores.aggregation.query.Query;\n import com.yahoo.elide.datastores.aggregation.queryengines.AbstractEntityHydrator;\n-import com.yahoo.elide.utils.coerce.CoerceUtil;\n-import lombok.AccessLevel;\n-import lombok.Getter;\n \n-import java.util.AbstractMap;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.persistence.EntityManager;\n+import java.sql.ResultSet;\n \n /**\n  * {@link SQLEntityHydrator} hydrates the entity loaded by\n  * {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}.\n  */\n public class SQLEntityHydrator extends AbstractEntityHydrator {\n \n-    @Getter(AccessLevel.PRIVATE)\n-    private final EntityManager entityManager;\n-\n     /**\n      * Constructor.\n      *\n      * @param results The loaded objects from {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)}\n      * @param query  The query passed to {@link QueryEngine#executeQuery(Query, QueryEngine.Transaction)} to load the\n      *               objects\n      * @param entityDictionary  An object that sets entity instance values and provides entity metadata info\n-     * @param entityManager  An service that issues JPQL queries to load relationship objects\n      */\n     public SQLEntityHydrator(\n-            List<Object> results,\n+            ResultSet results,", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxNjg1Mg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486416852", "bodyText": "We can just call it EntityHydrator.", "author": "aklish", "createdAt": "2020-09-10T15:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxNjM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NjM4Mg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487086382", "bodyText": "removed SQLEntityHydrator and renamed AbstractEntityHyrdator -> EntityHydrator", "author": "rishi-aga", "createdAt": "2020-09-11T14:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQxNjM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyMzAyNg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486423026", "bodyText": "You could commonize this code with a template function that takes another function with a result set argument\n<T> runQuery(String query, Function<ResultSet, T> resultSetMapper)\nor something along those lines.", "author": "aklish", "createdAt": "2020-09-10T15:12:27Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +144,187 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private final Connection conn;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+        private final SQLDialect dialect;\n+\n+        SqlTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction(defaultDataSource, defaultDialect);\n+    }\n+\n+    @Override\n+    public Transaction beginTransaction(String dbConnectionName) {\n+        DataSource dataSource = Optional.ofNullable(dataSourceMap.get(dbConnectionName))\n+                        .orElseThrow(() -> new IllegalStateException(\n+                                        \"DataSource or DB Configuration undefined for DB Connection Name: \"\n+                                                        + dbConnectionName));\n+        SQLDialect dialect = Optional.ofNullable(dialectMap.get(dbConnectionName))\n+                        .orElseThrow(() -> new IllegalStateException(\n+                                        \"SQL Dialect Type undefined for DB Connection Name: \"\n+                                                        + dbConnectionName));\n+        return new SqlTransaction(dataSource, dialect);\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+        SQLDialect dialect = sqlTransaction.dialect;\n \n         // Translate the query into SQL.\n         SQLQuery sql = toSQL(query, dialect);\n         String queryString = sql.toString();\n-        log.debug(\"SQL Query: \" + queryString);\n-        javax.persistence.Query jpaQuery = entityManager.createNativeQuery(queryString);\n \n         QueryResult.QueryResultBuilder resultBuilder = QueryResult.builder();\n+        NamedParamPreparedStatement stmt;\n \n         Pagination pagination = query.getPagination();\n         if (pagination != null) {\n-            jpaQuery.setFirstResult(pagination.getOffset());\n-            jpaQuery.setMaxResults(pagination.getLimit());\n+            queryString = appendOffsetLimit(queryString, dialect, pagination.getOffset(), pagination.getLimit());\n             if (pagination.returnPageTotals()) {\n-                resultBuilder.pageTotals(getPageTotal(query, sql, entityManager));\n+                resultBuilder.pageTotals(getPageTotal(query, sql, sqlTransaction));\n             }\n         }\n \n+        log.debug(\"SQL Query: \" + queryString);\n+        stmt = sqlTransaction.initializeStatement(queryString);\n+\n         // Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, jpaQuery);\n+        supplyFilterQueryParameters(query, stmt);\n \n         // Run the primary query and log the time spent.\n-        List<Object> results = new TimedFunction<List<Object>>(\n-                () -> jpaQuery.setHint(QueryHints.HINT_READONLY, true).getResultList(),\n-                \"Running Query: \" + queryString).get();\n+        ResultSet resultSet = new TimedFunction<ResultSet>(() -> {\n+            try {\n+                return stmt.executeQuery();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }, \"Running Query: \" + queryString\n+        ).get();\n \n-        resultBuilder.data(new SQLEntityHydrator(results, query, getMetadataDictionary(), entityManager).hydrate());\n+        resultBuilder.data(new SQLEntityHydrator(resultSet, query, getMetadataDictionary()).hydrate());\n         return resultBuilder.build();\n     }\n \n-    private long getPageTotal(Query query, SQLQuery sql, EntityManager entityManager) {\n-        String paginationSQL = toPageTotalSQL(sql, dialect).toString();\n-\n-        javax.persistence.Query pageTotalQuery =\n-                entityManager.createNativeQuery(paginationSQL)\n-                        .setHint(QueryHints.HINT_READONLY, true);\n+    private long getPageTotal(Query query, SQLQuery sql, SqlTransaction sqlTransaction) {\n+        String paginationSQL = toPageTotalSQL(sql, sqlTransaction.dialect).toString();\n \n-        //Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, pageTotalQuery);\n+        NamedParamPreparedStatement stmt = sqlTransaction.initializeStatement(paginationSQL);\n \n-        //Run the Pagination query and log the time spent.\n-        return new TimedFunction<>(\n-                () -> CoerceUtil.coerce(pageTotalQuery.getSingleResult(), Long.class),\n-                \"Running Query: \" + paginationSQL\n+        // Supply the query parameters to the query\n+        supplyFilterQueryParameters(query, stmt);\n+\n+        // Run the Pagination query and log the time spent.\n+        return new TimedFunction<>(() -> {\n+            try {\n+                ResultSet rs = stmt.executeQuery();\n+                if (rs.next()) {\n+                    return rs.getLong(1);\n+                } else {\n+                    return null;\n+                }\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }, \"Running Query: \" + paginationSQL\n         ).get();\n     }\n \n     @Override\n     public String getTableVersion(Table table, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n \n         String tableVersion = null;\n         Class<?> tableClass = getMetadataDictionary().getEntityClass(table.getName(), table.getVersion());\n         VersionQuery versionAnnotation = tableClass.getAnnotation(VersionQuery.class);\n         if (versionAnnotation != null) {\n             String versionQueryString = versionAnnotation.sql();\n-            javax.persistence.Query versionQuery =\n-                    entityManager.createNativeQuery(versionQueryString)\n-                            .setHint(QueryHints.HINT_READONLY, true);\n-            tableVersion = new TimedFunction<>(\n-                    () -> CoerceUtil.coerce(versionQuery.getSingleResult(), String.class),\n-                    \"Running Query: \" + versionQueryString\n+            NamedParamPreparedStatement stmt = sqlTransaction.initializeStatement(versionQueryString);\n+            tableVersion = new TimedFunction<>(() -> {", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA5NzgyMw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487097823", "bodyText": "updated.", "author": "rishi-aga", "createdAt": "2020-09-11T14:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyMzAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyNDU1Ng==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486424556", "bodyText": "Instead of instantiation via string name, we could pass the class name here and use reflection to load the dialect like a plugin.", "author": "aklish", "createdAt": "2020-09-10T15:14:33Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/dialects/SQLDialectFactory.java", "diffHunk": "@@ -13,19 +13,36 @@\n  * A class with static methods to create an instance of all Dialects.\n  */\n public class SQLDialectFactory {\n+\n+    private static final SQLDialect H2_DIALECT = new H2Dialect();\n+    private static final SQLDialect HIVE_DIALECT = new HiveDialect();\n+    private static final SQLDialect PRESTO_DIALECT = new PrestoDialect();\n+\n     public static SQLDialect getDefaultDialect() {\n-        return new H2Dialect();\n+        return getH2Dialect();\n     }\n \n     public static SQLDialect getH2Dialect() {\n-        return new H2Dialect();\n+        return H2_DIALECT;\n     }\n \n     public static SQLDialect getHiveDialect() {\n-        return new HiveDialect();\n+        return HIVE_DIALECT;\n     }\n \n     public static SQLDialect getPrestoDialect() {\n-        return new PrestoDialect();\n+        return PRESTO_DIALECT;\n+    }\n+\n+    public static SQLDialect getDialect(String type) {", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NzU2Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487057563", "bodyText": "ok.", "author": "rishi-aga", "createdAt": "2020-09-11T13:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyNDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyNjIxNQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486426215", "bodyText": "Can you explain what this is for?", "author": "aklish", "createdAt": "2020-09-10T15:16:44Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/AggregationDataStoreTransactionTest.java", "diffHunk": "@@ -74,8 +76,10 @@ public static void beforeAllTests() {\n     }\n \n     @BeforeEach\n-    public void setUp() {\n-        when(queryEngine.beginTransaction()).thenReturn(qeTransaction);\n+    public void setUp(TestInfo info) {\n+        if (!info.getTags().contains(\"SkipBeforeEach\")) {", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NzM5Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487057393", "bodyText": "one of test case was failing for \"Extra Stubbing\" error after the changes, so had to skip \"BeforeEach\" method for it to pass.", "author": "rishi-aga", "createdAt": "2020-09-11T13:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyNjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA4NzY5Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487087693", "bodyText": "removed this logic and added annotation \"@MockitoSettings(strictness = Strictness.LENIENT)\"", "author": "rishi-aga", "createdAt": "2020-09-11T14:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyNjIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyODU2NQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486428565", "bodyText": "It would be nice if we removed all the entity manager factory code from Aggregation Store and its tests.  We should just use JDBC directly.", "author": "aklish", "createdAt": "2020-09-10T15:19:39Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/SQLUnitTest.java", "diffHunk": "@@ -298,14 +299,19 @@ public Query getQuery() {\n \n     protected Pattern repeatedWhitespacePattern = Pattern.compile(\"\\\\s\\\\s*\");\n \n-    public static void init(SQLDialect sqlDialect) {\n+    public static void init(String sqlDialect) {\n         emf = Persistence.createEntityManagerFactory(\"aggregationStore\");\n         EntityManager em = emf.createEntityManager();\n         em.getTransaction().begin();\n         em.createNativeQuery(\"DROP ALL OBJECTS;\").executeUpdate();\n         em.createNativeQuery(\"RUNSCRIPT FROM 'classpath:create_tables.sql'\").executeUpdate();\n         em.getTransaction().commit();\n \n+        HikariConfig config = new HikariConfig();", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA5ODY1OQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487098659", "bodyText": "using org.apache.ibatis.jdbc.ScriptRunner for executing SQL.\nFor creating datasource, still using emf and persistence.xml. Should I create a new properties file for creating datasource ?", "author": "rishi-aga", "createdAt": "2020-09-11T14:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyODU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NjI1Nw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487146257", "bodyText": "Can we use an HJSON config for that?", "author": "aklish", "createdAt": "2020-09-11T16:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyODU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0Njk1Nw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487146957", "bodyText": "If persistence.xml is just using H2 database, there is a way to run scripts using H2 script runner - or alternatively you can run a script in the JDBC connection URL.", "author": "aklish", "createdAt": "2020-09-11T16:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyODU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgxMjA1Nw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488812057", "bodyText": "working on HJSON config", "author": "rishi-aga", "createdAt": "2020-09-15T16:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyODU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyOTgyNQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r486429825", "bodyText": "This looks like a problem.  EntityManager had a way to cancel a query and tear down the resources.  Is there a way to do something similar with JDBC?", "author": "aklish", "createdAt": "2020-09-10T15:21:17Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/framework/SQLUnitTest.java", "diffHunk": "@@ -321,8 +327,8 @@ public static void init(SQLDialect sqlDialect) {\n         filterParser = new RSQLFilterDialect(dictionary);\n \n         metaDataStore.populateEntityDictionary(dictionary);\n-        Consumer<EntityManager> txCancel = (entityManager) -> { entityManager.unwrap(Session.class).cancelQuery(); };\n-        engine = new SQLQueryEngine(metaDataStore, emf, txCancel, sqlDialect);\n+", "originalCommit": "1dea9221e4970c498c5b51e96ca6a46302f2ba75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NjI1OQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487056259", "bodyText": "JDBC supports Statement.cancel() for killing the running queries on DB. I am calling it in transaction's cancel method", "author": "rishi-aga", "createdAt": "2020-09-11T13:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyOTgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MjY1Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487142653", "bodyText": "I can see why you switched to enums earlier.  \"com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.impl.HiveDialect\" is a beast to type in.\nMaybe we can have the best of both worlds - an enum for dialects we support - and the ability to override with a custom class.  I'm fine if we want to make that work a separate PR.", "author": "aklish", "createdAt": "2020-09-11T16:03:50Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/resources/elideDBConfigSchema.json", "diffHunk": "@@ -128,7 +128,7 @@\n                     \"url\": \"jdbc:mysql://localhost/elide?serverTimezone=UTC\",\n                     \"driver\": \"com.mysql.jdbc.Driver\",\n                     \"user\": \"guest1\",\n-                    \"dialect\": \"org.hibernate.dialect.MySQL5Dialect\"\n+                    \"dialect\": \"com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.impl.HiveDialect\"", "originalCommit": "a9c968d8f1496f42508f6faeed562104aafa97c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgxMjI2Nw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488812267", "bodyText": "updated to have both", "author": "rishi-aga", "createdAt": "2020-09-15T16:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MjY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NDM0MA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487144340", "bodyText": "Why are we doing this here?  I don't think we want AggregationDataStore to know about its subclasses.", "author": "aklish", "createdAt": "2020-09-11T16:06:42Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/AggregationDataStore.java", "diffHunk": "@@ -63,6 +65,9 @@ public void populateEntityDictionary(EntityDictionary dictionary) {\n \n     @Override\n     public DataStoreTransaction beginTransaction() {\n-        return new AggregationDataStoreTransaction(queryEngine, cache, queryLogger);\n+        if (queryEngine.getClass().equals(SQLQueryEngine.class)) {", "originalCommit": "a9c968d8f1496f42508f6faeed562104aafa97c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgxMjQwOA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488812408", "bodyText": "reverted.", "author": "rishi-aga", "createdAt": "2020-09-15T16:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NDM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NzQ1MA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r487147450", "bodyText": "What does this do?", "author": "aklish", "createdAt": "2020-09-11T16:12:23Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/AggregationDataStoreTransactionTest.java", "diffHunk": "@@ -255,6 +260,7 @@ public void loadObjectsExceptionThrownTest() throws Exception {\n     }\n \n     @Test\n+    @MockitoSettings(strictness = Strictness.LENIENT)", "originalCommit": "a9c968d8f1496f42508f6faeed562104aafa97c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgxNDU2MQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488814561", "bodyText": "reverted it, no longer required after after reverting the changes to base class. Earlier I was getting this error: Unnecessary stubbings detected. Please remove unnecessary stubbings or use 'lenient' strictness.", "author": "rishi-aga", "createdAt": "2020-09-15T16:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NzQ1MA=="}], "type": "inlineReview"}, {"oid": "4a6ebd4628c5c937e91081de9405ab861f97e366", "url": "https://github.com/yahoo/elide/commit/4a6ebd4628c5c937e91081de9405ab861f97e366", "message": "Rebased and fix MetaDataStoreIntegrationTest", "committedDate": "2020-09-11T21:55:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3NDIwMg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488874202", "bodyText": "May be the dialect should be renamed to PrestoDB dialect to highlight the fact that we have 2 flavors of Presto?", "author": "moizarafat", "createdAt": "2020-09-15T18:23:48Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/dialects/impl/PrestoDialect.java", "diffHunk": "@@ -20,4 +20,10 @@ public String getDialectType() {\n     public boolean useAliasForOrderByClause() {\n         return true;\n     }\n+\n+    @Override\n+    public String appendOffsetLimit(String sql, int offset, int limit) {\n+        // offset is supported in prestosql but not in prestodb", "originalCommit": "ee7efe7046771fdab838716f7f2289b3b14d0c5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA3Mzc4OQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489073789", "bodyText": "renamed to PrestoDB", "author": "rishi-aga", "createdAt": "2020-09-15T23:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3NDIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMzkxMA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488903910", "bodyText": "instead of asking user to put new/duplicate dialect property can we use from the JPAProperties?", "author": "moizarafat", "createdAt": "2020-09-15T19:09:37Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/ElideAutoConfiguration.java", "diffHunk": "@@ -64,28 +69,49 @@\n     @Autowired(required = false)\n     private MeterRegistry meterRegistry;\n \n+    @Value(\"${spring.dialect}\")", "originalCommit": "ee7efe7046771fdab838716f7f2289b3b14d0c5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3Njc1MQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488976751", "bodyText": "The dialects are different classes though.  I think the spring dialect is a JPA dialect, whereas our default dialect is an Elide concept.  I'm not sure we can do this.", "author": "aklish", "createdAt": "2020-09-15T21:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMzkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA3MzcwNw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489073707", "bodyText": "added default-dialect property to elide.aggregation-store", "author": "rishi-aga", "createdAt": "2020-09-15T23:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNjM4Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488906383", "bodyText": "Instead of 2 return statements, We can have 1 return. In this block, we can populate the Map else the default Empty map is passed.", "author": "moizarafat", "createdAt": "2020-09-15T19:14:20Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/ElideAutoConfiguration.java", "diffHunk": "@@ -159,18 +185,18 @@ public void inject(Object entity) {\n     @Bean\n     @ConditionalOnMissingBean\n     @ConditionalOnProperty(name = \"elide.aggregation-store.enabled\", havingValue = \"true\")\n-    public QueryEngine buildQueryEngine(EntityManagerFactory entityManagerFactory,\n+    public QueryEngine buildQueryEngine(DataSource defaultDataSource,\n             ObjectProvider<ElideDynamicEntityCompiler> dynamicCompiler, ElideConfigProperties settings)\n             throws ClassNotFoundException {\n \n-        MetaDataStore metaDataStore = null;\n         if (isDynamicConfigEnabled(settings)) {\n-            metaDataStore = new MetaDataStore(dynamicCompiler.getIfAvailable());\n+            MetaDataStore metaDataStore = new MetaDataStore(dynamicCompiler.getIfAvailable());\n+            return new SQLQueryEngine(metaDataStore, defaultDataSource, defaultDialect,", "originalCommit": "ee7efe7046771fdab838716f7f2289b3b14d0c5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0ODgwOQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488948809", "bodyText": "static", "author": "aklish", "createdAt": "2020-09-15T20:19:39Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/compile/ElideDynamicEntityCompiler.java", "diffHunk": "@@ -75,6 +87,44 @@ public ElideDynamicEntityCompiler(String path) throws Exception {\n                 new ElideDynamicInMemoryClassLoader(ClassLoader.getSystemClassLoader(),\n                         Sets.newHashSet(classNames)));\n         compile();\n+\n+        elideSQLDBConfig.getDbconfigs().forEach(config -> {\n+            connectionDetailsMap.put(config.getName(),\n+                            new ConnectionDetails(getDataSource(config, dbPasswordExtractor), config.getDialect()));\n+        });\n+\n+    }\n+\n+    /**\n+     * Parse dynamic config path and provides default implementation for DB Password Extractor.\n+     * @param path : Dynamic config hjsons root location.\n+     * @throws Exception Exception thrown.\n+     */\n+    public ElideDynamicEntityCompiler(String path) throws Exception {\n+        this(path, new DBPasswordExtractor() {\n+            @Override\n+            public String getDBPassword(DBConfig config) {\n+                return StringUtils.EMPTY;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Generates DataSource for provided configuration.\n+     * @param dbConfig DB Configuration pojo.\n+     * @param dbPasswordExtractor DB Password Extractor Implementation.\n+     * @return DataSource Object.\n+     */\n+    private DataSource getDataSource(DBConfig dbConfig, DBPasswordExtractor dbPasswordExtractor) {", "originalCommit": "9d0f414511b474f4d7cdb49dcc356ebf6d4c6de7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4MjMzNA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488982334", "bodyText": "updated.", "author": "rishi-aga", "createdAt": "2020-09-15T21:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0ODgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0OTA5NA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488949094", "bodyText": "You can use @value to make this immutable.", "author": "aklish", "createdAt": "2020-09-15T20:20:06Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/compile/ConnectionDetails.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.contrib.dynamicconfighelpers.compile;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+\n+import javax.sql.DataSource;\n+\n+/**\n+ * Custom class to abstract {@link DataSource} and name of Dialect class.\n+ */\n+@AllArgsConstructor\n+@Getter", "originalCommit": "9d0f414511b474f4d7cdb49dcc356ebf6d4c6de7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4MjQwMw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488982403", "bodyText": "updated.", "author": "rishi-aga", "createdAt": "2020-09-15T21:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0OTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1NjYxOA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488956618", "bodyText": "Why not use ConnectionDetails here?", "author": "aklish", "createdAt": "2020-09-15T20:34:21Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -41,45 +43,72 @@\n import com.yahoo.elide.request.Pagination;\n import com.yahoo.elide.utils.coerce.CoerceUtil;\n \n-import org.hibernate.jpa.QueryHints;\n-\n import lombok.extern.slf4j.Slf4j;\n \n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.Set;\n-import java.util.function.Consumer;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n-import javax.persistence.EntityManager;\n-import javax.persistence.EntityManagerFactory;\n-import javax.persistence.EntityTransaction;\n+import javax.sql.DataSource;\n \n /**\n  * QueryEngine for SQL backed stores.\n  */\n @Slf4j\n public class SQLQueryEngine extends QueryEngine {\n-    private final EntityManagerFactory entityManagerFactory;\n-    private final Consumer<EntityManager> transactionCancel;\n     private final SQLReferenceTable referenceTable;\n-    private final SQLDialect dialect;\n-\n-    public SQLQueryEngine(MetaDataStore metaDataStore, EntityManagerFactory eMFactory, Consumer<EntityManager> txC) {\n-        this(metaDataStore, eMFactory, txC, SQLDialectFactory.getDefaultDialect());\n-    }\n+    private final DataSource defaultDataSource;\n+    private final Map<String, DataSource> dataSourceMap = new HashMap<>();", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA3MTg4MQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489071881", "bodyText": "added additional ConnectionDetails class in aggregation module with dialect of type SQLDialect.", "author": "rishi-aga", "createdAt": "2020-09-15T23:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1NjYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1NzIyMw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488957223", "bodyText": "I wonder if we should make this SQLDialect instead of String.", "author": "aklish", "createdAt": "2020-09-15T20:35:29Z", "path": "elide-contrib/elide-dynamic-config-helpers/src/main/java/com/yahoo/elide/contrib/dynamicconfighelpers/compile/ConnectionDetails.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.contrib.dynamicconfighelpers.compile;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+\n+import javax.sql.DataSource;\n+\n+/**\n+ * Custom class to abstract {@link DataSource} and name of Dialect class.\n+ */\n+@AllArgsConstructor\n+@Getter\n+public class ConnectionDetails {\n+    private DataSource dataSource;\n+    private String dialect;", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA3MjM2Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489072363", "bodyText": "SQLDialect is not available in contrib module. added the workaround for now.", "author": "rishi-aga", "createdAt": "2020-09-15T23:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1NzIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1OTcwNg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488959706", "bodyText": "Now that we are adding offset and limit directly, I feel like this functionality (appending the offset & limit string) should move to the SQLQueryConstructor", "author": "aklish", "createdAt": "2020-09-15T20:40:12Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +158,165 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private Connection conn;\n+        private SQLDialect dialect;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+\n+        public void initializeTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction();\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+\n+        String connectionName = query.getTable().getDbConnectionName();\n+        DataSource dataSource = getDataSource(connectionName);\n+        SQLDialect dialect = getSQLDialect(connectionName);\n+        sqlTransaction.initializeTransaction(dataSource, dialect);\n \n         // Translate the query into SQL.\n         SQLQuery sql = toSQL(query, dialect);\n         String queryString = sql.toString();\n-        log.debug(\"SQL Query: \" + queryString);\n-        javax.persistence.Query jpaQuery = entityManager.createNativeQuery(queryString);\n \n         QueryResult.QueryResultBuilder resultBuilder = QueryResult.builder();\n+        NamedParamPreparedStatement stmt;\n \n         Pagination pagination = query.getPagination();\n         if (pagination != null) {\n-            jpaQuery.setFirstResult(pagination.getOffset());\n-            jpaQuery.setMaxResults(pagination.getLimit());\n+            queryString = appendOffsetLimit(queryString, dialect, pagination.getOffset(), pagination.getLimit());", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY2NjYyNA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489666624", "bodyText": "moved it to SQLQueryConstructor.", "author": "rishi-aga", "createdAt": "2020-09-16T18:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1OTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MDcxOQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488960719", "bodyText": "Same comment.", "author": "aklish", "createdAt": "2020-09-15T20:42:12Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +158,165 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private Connection conn;\n+        private SQLDialect dialect;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+\n+        public void initializeTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction();\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+\n+        String connectionName = query.getTable().getDbConnectionName();\n+        DataSource dataSource = getDataSource(connectionName);\n+        SQLDialect dialect = getSQLDialect(connectionName);\n+        sqlTransaction.initializeTransaction(dataSource, dialect);\n \n         // Translate the query into SQL.\n         SQLQuery sql = toSQL(query, dialect);\n         String queryString = sql.toString();\n-        log.debug(\"SQL Query: \" + queryString);\n-        javax.persistence.Query jpaQuery = entityManager.createNativeQuery(queryString);\n \n         QueryResult.QueryResultBuilder resultBuilder = QueryResult.builder();\n+        NamedParamPreparedStatement stmt;\n \n         Pagination pagination = query.getPagination();\n         if (pagination != null) {\n-            jpaQuery.setFirstResult(pagination.getOffset());\n-            jpaQuery.setMaxResults(pagination.getLimit());\n+            queryString = appendOffsetLimit(queryString, dialect, pagination.getOffset(), pagination.getLimit());\n             if (pagination.returnPageTotals()) {\n-                resultBuilder.pageTotals(getPageTotal(query, sql, entityManager));\n+                resultBuilder.pageTotals(getPageTotal(query, sql, sqlTransaction));\n             }\n         }\n \n+        log.debug(\"SQL Query: \" + queryString);\n+        stmt = sqlTransaction.initializeStatement(queryString);\n+\n         // Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, jpaQuery);\n+        supplyFilterQueryParameters(query, stmt);\n \n         // Run the primary query and log the time spent.\n-        List<Object> results = new TimedFunction<List<Object>>(\n-                () -> jpaQuery.setHint(QueryHints.HINT_READONLY, true).getResultList(),\n-                \"Running Query: \" + queryString).get();\n+        ResultSet resultSet = new TimedFunction<>(() -> {\n+            try {\n+                return stmt.executeQuery();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }, \"Running Query: \" + queryString\n+        ).get();\n \n-        resultBuilder.data(new SQLEntityHydrator(results, query, getMetadataDictionary(), entityManager).hydrate());\n+        resultBuilder.data(new EntityHydrator(resultSet, query, getMetadataDictionary()).hydrate());\n         return resultBuilder.build();\n     }\n \n-    private long getPageTotal(Query query, SQLQuery sql, EntityManager entityManager) {\n-        String paginationSQL = toPageTotalSQL(sql, dialect).toString();\n+    private long getPageTotal(Query query, SQLQuery sql, SqlTransaction sqlTransaction) {\n+        String paginationSQL = toPageTotalSQL(sql, sqlTransaction.dialect).toString();\n \n-        javax.persistence.Query pageTotalQuery =\n-                entityManager.createNativeQuery(paginationSQL)\n-                        .setHint(QueryHints.HINT_READONLY, true);\n+        NamedParamPreparedStatement stmt = sqlTransaction.initializeStatement(paginationSQL);\n \n-        //Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, pageTotalQuery);\n+        // Supply the query parameters to the query\n+        supplyFilterQueryParameters(query, stmt);\n \n-        //Run the Pagination query and log the time spent.\n-        return new TimedFunction<>(\n-                () -> CoerceUtil.coerce(pageTotalQuery.getSingleResult(), Long.class),\n-                \"Running Query: \" + paginationSQL\n-        ).get();\n+        // Run the Pagination query and log the time spent.\n+        return CoerceUtil.coerce(runQuery(stmt, paginationSQL, SINGLE_RESULT_MAPPER), Long.class);\n     }\n \n     @Override\n     public String getTableVersion(Table table, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n \n         String tableVersion = null;\n         Class<?> tableClass = getMetadataDictionary().getEntityClass(table.getName(), table.getVersion());\n         VersionQuery versionAnnotation = tableClass.getAnnotation(VersionQuery.class);\n         if (versionAnnotation != null) {\n             String versionQueryString = versionAnnotation.sql();\n-            javax.persistence.Query versionQuery =\n-                    entityManager.createNativeQuery(versionQueryString)\n-                            .setHint(QueryHints.HINT_READONLY, true);\n-            tableVersion = new TimedFunction<>(\n-                    () -> CoerceUtil.coerce(versionQuery.getSingleResult(), String.class),\n-                    \"Running Query: \" + versionQueryString\n-            ).get();\n+            String connectionName = table.getDbConnectionName();\n+            sqlTransaction.initializeTransaction(getDataSource(connectionName), getSQLDialect(connectionName));\n+            NamedParamPreparedStatement stmt = sqlTransaction.initializeStatement(versionQueryString);\n+            tableVersion = CoerceUtil.coerce(runQuery(stmt, versionQueryString, SINGLE_RESULT_MAPPER), String.class);\n         }\n         return tableVersion;\n     }\n \n-    @Override\n-    public List<String> explain(Query query) {\n+    private <R> R runQuery(NamedParamPreparedStatement stmt, String queryString, Function<ResultSet, R> resultMapper) {\n+\n+        // Run the query and log the time spent.\n+        return new TimedFunction<>(() -> {\n+            try {\n+                ResultSet rs = stmt.executeQuery();\n+                return resultMapper.apply(rs);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }, \"Running Query: \" + queryString\n+        ).get();\n+    }\n+\n+    /**\n+     * Returns the actual query string(s) that would be executed for the input {@link Query}.\n+     *\n+     * @param query The query customized for a particular persistent storage or storage client.\n+     * @param dialect SQL dialect to use for this storage.\n+     * @return List of SQL string(s) corresponding to the given query.\n+     */\n+    public List<String> explain(Query query, SQLDialect dialect) {\n         List<String> queries = new ArrayList<String>();\n         SQLQuery sql = toSQL(query, dialect);\n \n         Pagination pagination = query.getPagination();\n-        if (pagination != null && pagination.returnPageTotals()) {\n-            queries.add(toPageTotalSQL(sql, dialect).toString());\n+        if (pagination != null) {\n+            if (pagination.returnPageTotals()) {\n+                queries.add(toPageTotalSQL(sql, dialect).toString());\n+            }\n+            queries.add(appendOffsetLimit(sql.toString(), dialect, pagination.getOffset(), pagination.getLimit()));", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MTg4Mg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488961882", "bodyText": "Why doesn't this use the new runQuery method you added with an identity mapper?", "author": "aklish", "createdAt": "2020-09-15T20:44:37Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +158,165 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private Connection conn;\n+        private SQLDialect dialect;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+\n+        public void initializeTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction();\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+\n+        String connectionName = query.getTable().getDbConnectionName();\n+        DataSource dataSource = getDataSource(connectionName);\n+        SQLDialect dialect = getSQLDialect(connectionName);\n+        sqlTransaction.initializeTransaction(dataSource, dialect);\n \n         // Translate the query into SQL.\n         SQLQuery sql = toSQL(query, dialect);\n         String queryString = sql.toString();\n-        log.debug(\"SQL Query: \" + queryString);\n-        javax.persistence.Query jpaQuery = entityManager.createNativeQuery(queryString);\n \n         QueryResult.QueryResultBuilder resultBuilder = QueryResult.builder();\n+        NamedParamPreparedStatement stmt;\n \n         Pagination pagination = query.getPagination();\n         if (pagination != null) {\n-            jpaQuery.setFirstResult(pagination.getOffset());\n-            jpaQuery.setMaxResults(pagination.getLimit());\n+            queryString = appendOffsetLimit(queryString, dialect, pagination.getOffset(), pagination.getLimit());\n             if (pagination.returnPageTotals()) {\n-                resultBuilder.pageTotals(getPageTotal(query, sql, entityManager));\n+                resultBuilder.pageTotals(getPageTotal(query, sql, sqlTransaction));\n             }\n         }\n \n+        log.debug(\"SQL Query: \" + queryString);\n+        stmt = sqlTransaction.initializeStatement(queryString);\n+\n         // Supply the query parameters to the query\n-        supplyFilterQueryParameters(query, jpaQuery);\n+        supplyFilterQueryParameters(query, stmt);\n \n         // Run the primary query and log the time spent.\n-        List<Object> results = new TimedFunction<List<Object>>(\n-                () -> jpaQuery.setHint(QueryHints.HINT_READONLY, true).getResultList(),\n-                \"Running Query: \" + queryString).get();\n+        ResultSet resultSet = new TimedFunction<>(() -> {", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ5NDk1Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489494953", "bodyText": "updated.", "author": "rishi-aga", "createdAt": "2020-09-16T14:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MTg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NTgwMA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488965800", "bodyText": "InitializeTransaction is called twice in this file (once here and once to get the table version).  The transaction should only be initialized once because it involves getting a DB connection.  I recommend we have state about whether or not  the transaction is initialized.  One other possibility is to do the initialization lazily inside the Transaction when a new statement is created.  Then you could remove the need to initialize both the transaction and the statement in multiple places.", "author": "aklish", "createdAt": "2020-09-15T20:52:10Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -129,127 +158,165 @@ public MetricProjection constructMetricProjection(Metric metric,\n     /**\n      * State needed for SQLQueryEngine to execute queries.\n      */\n-    static class SqlTransaction implements QueryEngine.Transaction  {\n-\n-        private final EntityManager entityManager;\n-        private final EntityTransaction transaction;\n-        private final Consumer<EntityManager> transactionCancel;\n-\n-        SqlTransaction(EntityManagerFactory emf, Consumer<EntityManager> transactionCancel) {\n+    static class SqlTransaction implements QueryEngine.Transaction {\n+\n+        private Connection conn;\n+        private SQLDialect dialect;\n+        private final List<NamedParamPreparedStatement> stmts = new ArrayList<>();\n+\n+        public void initializeTransaction(DataSource dataSource, SQLDialect dialect) {\n+            this.dialect = dialect;\n+            try {\n+                this.conn = dataSource.getConnection();\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n \n-            entityManager = emf.createEntityManager();\n-            transaction = entityManager.getTransaction();\n-            this.transactionCancel = transactionCancel;\n-            if (!transaction.isActive()) {\n-                transaction.begin();\n+        public NamedParamPreparedStatement initializeStatement(String namedParamQuery) {\n+            NamedParamPreparedStatement stmt;\n+            try {\n+                stmt = new NamedParamPreparedStatement(conn, namedParamQuery);\n+                stmts.add(stmt);\n+            } catch (SQLException e) {\n+                throw new IllegalStateException(e);\n             }\n+            return stmt;\n         }\n \n         @Override\n         public void close() {\n-            if (transaction != null && transaction.isActive()) {\n-                transaction.commit();\n-            }\n-            if (entityManager != null) {\n-                entityManager.close();\n-            }\n+            stmts.forEach(stmt -> cancelAndCloseSoftly(stmt));\n+            closeSoftly(conn);\n         }\n \n         @Override\n         public void cancel() {\n-            transactionCancel.accept(entityManager);\n+            stmts.forEach(stmt -> cancelSoftly(stmt));\n         }\n-\n     }\n \n     @Override\n     public QueryEngine.Transaction beginTransaction() {\n-        return new SqlTransaction(entityManagerFactory, transactionCancel);\n+        return new SqlTransaction();\n     }\n \n     @Override\n     public QueryResult executeQuery(Query query, Transaction transaction) {\n-        EntityManager entityManager = ((SqlTransaction) transaction).entityManager;\n+        SqlTransaction sqlTransaction = (SqlTransaction) transaction;\n+\n+        String connectionName = query.getTable().getDbConnectionName();\n+        DataSource dataSource = getDataSource(connectionName);\n+        SQLDialect dialect = getSQLDialect(connectionName);\n+        sqlTransaction.initializeTransaction(dataSource, dialect);", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ5NTg2Nw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489495867", "bodyText": "updated to initialization lazily inside the Transaction when a new statement is created.", "author": "rishi-aga", "createdAt": "2020-09-16T14:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NzE0OQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488967149", "bodyText": "It might be better to do the appending outside the dialect.  If there are nested subqueries, we may want to apply offset and limit on an inner query.  The calling code will know how to stitch in the fragment.", "author": "aklish", "createdAt": "2020-09-15T20:54:49Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/dialects/AbstractSqlDialect.java", "diffHunk": "@@ -9,12 +9,22 @@\n  * Common code for {@link SQLDialect} implementations.\n  */\n public abstract class AbstractSqlDialect implements SQLDialect {\n+\n+    public static final String OFFSET = \" OFFSET \";\n+    public static final String LIMIT = \" LIMIT \";\n+\n     @Override\n     public boolean useAliasForOrderByClause() {\n         return false;\n     }\n \n+    @Override\n     public String generateCountDistinctClause(String dimensions) {\n         return String.format(\"COUNT(DISTINCT(%s))\", dimensions);\n     }\n+\n+    @Override\n+    public String appendOffsetLimit(String sql, int offset, int limit) {\n+        return sql + OFFSET + offset + LIMIT + limit;", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY2NjAzMQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489666031", "bodyText": "this method is now called from SQLQueryConstructor.", "author": "rishi-aga", "createdAt": "2020-09-16T18:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NzE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2Nzg0OA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488967848", "bodyText": "TestInfo looks unused.", "author": "aklish", "createdAt": "2020-09-15T20:56:11Z", "path": "elide-datastore/elide-datastore-aggregation/src/test/java/com/yahoo/elide/datastores/aggregation/AggregationDataStoreTransactionTest.java", "diffHunk": "@@ -74,7 +76,7 @@ public static void beforeAllTests() {\n     }\n \n     @BeforeEach\n-    public void setUp() {\n+    public void setUp(TestInfo info) {", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4Mzc2NQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488983765", "bodyText": "updated.", "author": "rishi-aga", "createdAt": "2020-09-15T21:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2Nzg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3MDg4NQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488970885", "bodyText": "Let's move all of this test infrastructure into AggregationStore instead of duplicating it in Spring and Standalone.", "author": "aklish", "createdAt": "2020-09-15T21:02:06Z", "path": "elide-standalone/src/test/resources/configs/models/tables/SalesView.hjson", "diffHunk": "@@ -0,0 +1,75 @@\n+{\n+  tables:", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA2OTQwNA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489069404", "bodyText": "Removed the tests from Spring and Standalone.", "author": "rishi-aga", "createdAt": "2020-09-15T23:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3MDg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NjAzMg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488976032", "bodyText": "Why does Async need the DBPassword config?", "author": "aklish", "createdAt": "2020-09-15T21:12:21Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/test/java/example/tests/AsyncTest.java", "diffHunk": "@@ -39,6 +39,7 @@\n                 + \"\\t\\t('com.example.repository','Example Repository','The code for this project', false);\")\n @Sql(executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD,\n         statements = \"DELETE FROM ArtifactVersion; DELETE FROM ArtifactProduct; DELETE FROM ArtifactGroup;\")\n+@Import(DBPasswordExtractorSetup.class)", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4ODg4OA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488988888", "bodyText": "this test uses shared application.yaml where dynamic config is enabled so it tries to parse DB and hjson and create DataSource object.\nWithout it, it will run fine independently but will fail when all tests are run together for incorrect password as it will use default implementation.", "author": "rishi-aga", "createdAt": "2020-09-15T21:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NjAzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA2OTA4Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489069083", "bodyText": "this is no longer required after removing db connection hjson", "author": "rishi-aga", "createdAt": "2020-09-15T23:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NjAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NzgwOA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488977808", "bodyText": "Does Spring provide the DataSource for us?", "author": "aklish", "createdAt": "2020-09-15T21:16:04Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/ElideAutoConfiguration.java", "diffHunk": "@@ -159,18 +185,18 @@ public void inject(Object entity) {\n     @Bean\n     @ConditionalOnMissingBean\n     @ConditionalOnProperty(name = \"elide.aggregation-store.enabled\", havingValue = \"true\")\n-    public QueryEngine buildQueryEngine(EntityManagerFactory entityManagerFactory,\n+    public QueryEngine buildQueryEngine(DataSource defaultDataSource,", "originalCommit": "17fd81a5da0873e15cb613e74945aeccbb574bc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4NjI4NQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r488986285", "bodyText": "yes, we are not creating DataSource anywhere.", "author": "rishi-aga", "createdAt": "2020-09-15T21:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NzgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMDE1Mg==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489730152", "bodyText": "Indentation is off", "author": "moizarafat", "createdAt": "2020-09-16T20:18:54Z", "path": "elide-datastore/elide-datastore-aggregation/src/main/java/com/yahoo/elide/datastores/aggregation/queryengines/sql/SQLQueryEngine.java", "diffHunk": "@@ -66,31 +63,30 @@\n @Slf4j\n public class SQLQueryEngine extends QueryEngine {\n     private final SQLReferenceTable referenceTable;\n-    private final DataSource defaultDataSource;\n-    private final Map<String, DataSource> dataSourceMap = new HashMap<>();\n-    private final SQLDialect defaultDialect;\n-    private final Map<String, SQLDialect> dialectMap = new HashMap<>();\n+    private final ConnectionDetails defaultConnectionDetails;\n+    private final Map<String, ConnectionDetails> connectionDetailsMap = new HashMap<>();\n \n-    public SQLQueryEngine(MetaDataStore metaDataStore, DataSource defaultDataSource, String defaultDialect) {\n+    public SQLQueryEngine(MetaDataStore metaDataStore,\n+                    com.yahoo.elide.contrib.dynamicconfighelpers.compile.ConnectionDetails defaultConnectionDetails) {\n         super(metaDataStore);\n         this.referenceTable = new SQLReferenceTable(metaDataStore);\n-        this.defaultDataSource = defaultDataSource;\n-        this.defaultDialect = SQLDialectFactory.getDialect(defaultDialect);\n+        this.defaultConnectionDetails = new ConnectionDetails(defaultConnectionDetails.getDataSource(),\n+                        SQLDialectFactory.getDialect(defaultConnectionDetails.getDialect()));", "originalCommit": "3458c01de2508bd2c25469357512292f585f7706", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczNzE2Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489737163", "bodyText": "its same line.", "author": "rishi-aga", "createdAt": "2020-09-16T20:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMDE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMjg3Mw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489732873", "bodyText": "This import is unused.", "author": "moizarafat", "createdAt": "2020-09-16T20:24:24Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AggregationStoreProperties.java", "diffHunk": "@@ -5,6 +5,8 @@\n  */\n package com.yahoo.elide.spring.config;\n \n+import com.yahoo.elide.datastores.aggregation.queryengines.sql.dialects.SQLDialect;", "originalCommit": "3458c01de2508bd2c25469357512292f585f7706", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczNjYzMw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489736633", "bodyText": "its used in javadoc", "author": "rishi-aga", "createdAt": "2020-09-16T20:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMjg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjUzNw==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r490416537", "bodyText": "ah okie :)", "author": "moizarafat", "createdAt": "2020-09-17T16:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMjg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMjk4MQ==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489732981", "bodyText": "We should set to one of the supported values.", "author": "moizarafat", "createdAt": "2020-09-16T20:24:37Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AggregationStoreProperties.java", "diffHunk": "@@ -18,4 +20,8 @@\n      */\n     private boolean enabled = false;\n \n+    /**\n+     * {@link SQLDialect} type for default DataSource Object.\n+     */\n+    private String defaultDialect = \"MYSQL\";", "originalCommit": "3458c01de2508bd2c25469357512292f585f7706", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM5MDIwOA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r490390208", "bodyText": "changed to Hive.", "author": "rishi-aga", "createdAt": "2020-09-17T16:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMjk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMzUwMA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489733500", "bodyText": "use one of the supported types.", "author": "moizarafat", "createdAt": "2020-09-16T20:25:32Z", "path": "elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java", "diffHunk": "@@ -375,6 +376,15 @@ public String getDBPassword(DBConfig config) {\n         };\n     }\n \n+    /**\n+     * Provides the default SQLDialect type.\n+     *\n+     * @return {@link SQLDialect} type for default DataSource Object.\n+     */\n+    default String getDefaultDialect() {\n+        return \"MYSQL\";", "originalCommit": "3458c01de2508bd2c25469357512292f585f7706", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczNzYyOA==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r489737628", "bodyText": "wanted to ensure override works properly.", "author": "rishi-aga", "createdAt": "2020-09-16T20:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMzUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM5MDQ3Ng==", "url": "https://github.com/yahoo/elide/pull/1523#discussion_r490390476", "bodyText": "changed to Hive.", "author": "rishi-aga", "createdAt": "2020-09-17T16:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTczMzUwMA=="}], "type": "inlineReview"}, {"oid": "8be2b7ffe2aff0309c0d31f8fd9588245a1575dc", "url": "https://github.com/yahoo/elide/commit/8be2b7ffe2aff0309c0d31f8fd9588245a1575dc", "message": "Query Engine and Aggregation Store Changes for Multi Data Source Support", "committedDate": "2020-09-16T21:25:41Z", "type": "commit"}, {"oid": "d9533291c7c0459182cb5d3b2a5806628348bc1c", "url": "https://github.com/yahoo/elide/commit/d9533291c7c0459182cb5d3b2a5806628348bc1c", "message": "minor updates", "committedDate": "2020-09-16T21:25:41Z", "type": "commit"}, {"oid": "c663a02f086186aa8e22b374b8061ecc235fe9a1", "url": "https://github.com/yahoo/elide/commit/c663a02f086186aa8e22b374b8061ecc235fe9a1", "message": "Review Comments: Change Dialect to Enum", "committedDate": "2020-09-16T21:25:41Z", "type": "commit"}, {"oid": "fa95290812c67c8b7bf2fbebebd3f5ffdfc6d252", "url": "https://github.com/yahoo/elide/commit/fa95290812c67c8b7bf2fbebebd3f5ffdfc6d252", "message": "Review Comment: Remove references for getRelationshipValues from EntityHydrator", "committedDate": "2020-09-16T21:25:41Z", "type": "commit"}, {"oid": "664ed6b057089f2015af078948af6d6d7d7a2a58", "url": "https://github.com/yahoo/elide/commit/664ed6b057089f2015af078948af6d6d7d7a2a58", "message": "Review Comments", "committedDate": "2020-09-16T21:25:41Z", "type": "commit"}, {"oid": "2b9f9aed822872dc4639271d5fe69f1e6496b60f", "url": "https://github.com/yahoo/elide/commit/2b9f9aed822872dc4639271d5fe69f1e6496b60f", "message": "Review Comments", "committedDate": "2020-09-16T21:25:41Z", "type": "commit"}, {"oid": "4709e99c004bdf9713e59e9c6cf4e09251a3dc4a", "url": "https://github.com/yahoo/elide/commit/4709e99c004bdf9713e59e9c6cf4e09251a3dc4a", "message": "Revert changes to AggregationDataStore and AggregationDataStoreTransaction", "committedDate": "2020-09-16T21:25:41Z", "type": "commit"}, {"oid": "42fcc4f783bff6be0334a35793d1c5e12686cee2", "url": "https://github.com/yahoo/elide/commit/42fcc4f783bff6be0334a35793d1c5e12686cee2", "message": "Rebased and fix MetaDataStoreIntegrationTest", "committedDate": "2020-09-16T21:26:20Z", "type": "commit"}, {"oid": "286b895c6160dec8eccb54d4dc962ed4c7a2f56b", "url": "https://github.com/yahoo/elide/commit/286b895c6160dec8eccb54d4dc962ed4c7a2f56b", "message": "Elide StandAlone Changes", "committedDate": "2020-09-16T21:26:20Z", "type": "commit"}, {"oid": "69854b2d7b710de47d2d6541a443558f6c865a95", "url": "https://github.com/yahoo/elide/commit/69854b2d7b710de47d2d6541a443558f6c865a95", "message": "Refactoring and Spring changes", "committedDate": "2020-09-16T21:26:20Z", "type": "commit"}, {"oid": "ded581ce81830bdfc13e1d4379a7d7f6ebe84196", "url": "https://github.com/yahoo/elide/commit/ded581ce81830bdfc13e1d4379a7d7f6ebe84196", "message": "Minor", "committedDate": "2020-09-16T21:26:20Z", "type": "commit"}, {"oid": "e4591d599576816c58f6cafb0ad03e404ea0e7b6", "url": "https://github.com/yahoo/elide/commit/e4591d599576816c58f6cafb0ad03e404ea0e7b6", "message": "Final Pass", "committedDate": "2020-09-16T21:26:20Z", "type": "commit"}, {"oid": "7c8f7edc74bb95eb371d9ed3809942a7ab2c79aa", "url": "https://github.com/yahoo/elide/commit/7c8f7edc74bb95eb371d9ed3809942a7ab2c79aa", "message": "Remove emf from SQLUNIT", "committedDate": "2020-09-16T21:27:21Z", "type": "commit"}, {"oid": "e50b44ec2b0c5241e688ca40b32166fde8f1f0d9", "url": "https://github.com/yahoo/elide/commit/e50b44ec2b0c5241e688ca40b32166fde8f1f0d9", "message": "Add missing file", "committedDate": "2020-09-16T21:27:21Z", "type": "commit"}, {"oid": "98328e3419976c6b9deb6f7f4ce0d28825286710", "url": "https://github.com/yahoo/elide/commit/98328e3419976c6b9deb6f7f4ce0d28825286710", "message": "Review Comments: Refactor Connection Details, Remove duplicate tests from Slring and Standalone", "committedDate": "2020-09-16T21:27:22Z", "type": "commit"}, {"oid": "ae647b5050b99f6129f4810329d9114408a3c25f", "url": "https://github.com/yahoo/elide/commit/ae647b5050b99f6129f4810329d9114408a3c25f", "message": "Review Comments: Lazily Initialize Transaction", "committedDate": "2020-09-16T21:27:22Z", "type": "commit"}, {"oid": "f8774463648ef8593cd6c069933effe65e79b73d", "url": "https://github.com/yahoo/elide/commit/f8774463648ef8593cd6c069933effe65e79b73d", "message": "Minor changes", "committedDate": "2020-09-16T21:27:22Z", "type": "commit"}, {"oid": "861ddacd41352e79a7a90ac99f8d1f330c8c731e", "url": "https://github.com/yahoo/elide/commit/861ddacd41352e79a7a90ac99f8d1f330c8c731e", "message": "Review Comments: Move Offset/Limit to SQLQueryConstructor", "committedDate": "2020-09-16T21:27:22Z", "type": "commit"}, {"oid": "083c4cc27a896d73fcd8456379d014f07c56f304", "url": "https://github.com/yahoo/elide/commit/083c4cc27a896d73fcd8456379d014f07c56f304", "message": "Minor changes", "committedDate": "2020-09-16T21:27:22Z", "type": "commit"}, {"oid": "03f02a317999ef082bbc8a57e4ceba337b008fd5", "url": "https://github.com/yahoo/elide/commit/03f02a317999ef082bbc8a57e4ceba337b008fd5", "message": "Minor changes", "committedDate": "2020-09-16T21:27:22Z", "type": "commit"}, {"oid": "7a9b1a27a8a2bfb24748962037b7380e1e251a9c", "url": "https://github.com/yahoo/elide/commit/7a9b1a27a8a2bfb24748962037b7380e1e251a9c", "message": "Minor changes", "committedDate": "2020-09-16T21:27:22Z", "type": "commit"}, {"oid": "7a9b1a27a8a2bfb24748962037b7380e1e251a9c", "url": "https://github.com/yahoo/elide/commit/7a9b1a27a8a2bfb24748962037b7380e1e251a9c", "message": "Minor changes", "committedDate": "2020-09-16T21:27:22Z", "type": "forcePushed"}, {"oid": "7eee714a83a300b5bb33dbcdecd0c6939e39db7c", "url": "https://github.com/yahoo/elide/commit/7eee714a83a300b5bb33dbcdecd0c6939e39db7c", "message": "Review Comments", "committedDate": "2020-09-17T16:20:30Z", "type": "commit"}]}