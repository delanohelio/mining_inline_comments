{"pr_number": 623, "pr_title": "[eclipse/xtext#1777] ported xtend code to java", "pr_createdAt": "2020-06-29T16:43:27Z", "pr_url": "https://github.com/eclipse/xtext-extras/pull/623", "timeline": [{"oid": "a38fbef1992e9c57c3e7c84b1a43995296a86865", "url": "https://github.com/eclipse/xtext-extras/commit/a38fbef1992e9c57c3e7c84b1a43995296a86865", "message": "[eclipse/xtext#1777] ported xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-29T16:52:18Z", "type": "forcePushed"}, {"oid": "2e6f0b822a195e7665a672ecbf5735b945b79cba", "url": "https://github.com/eclipse/xtext-extras/commit/2e6f0b822a195e7665a672ecbf5735b945b79cba", "message": "[eclipse/xtext#1777] ported xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-29T17:05:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0NzM5Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/623#discussion_r447147397", "bodyText": "I know it's not really the scope of this PR, but return getErrors().iterator().hasNext() avoid a little bit of duplication here. Or even !Iterables.isEmpty(getErrors())", "author": "szarnekow", "createdAt": "2020-06-29T17:50:08Z", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ErrorSafeExtensions.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmSpecializedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.common.types.JvmUnknownTypeReference;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.compiler.BrokenTypeRefDetector;\n+import org.eclipse.xtext.xbase.compiler.IElementIssueProvider;\n+import org.eclipse.xtext.xbase.compiler.LoopParams;\n+import org.eclipse.xtext.xbase.compiler.TypeReferenceSerializer;\n+import org.eclipse.xtext.xbase.compiler.output.ErrorTreeAppendable;\n+import org.eclipse.xtext.xbase.compiler.output.ITreeAppendable;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ObjectExtensions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+/**\n+ * @author Jan Koehnlein\n+ */\n+public class ErrorSafeExtensions {\n+\t@Inject\n+\tprivate TypeReferenceSerializer typeReferenceSerializer;\n+\n+\t@Inject\n+\tprivate IElementIssueProvider.Factory issueProviderFactory;\n+\n+\tpublic Iterable<Issue> getErrors(EObject element) {\n+\t\tIElementIssueProvider issueProvider = issueProviderFactory.get(element.eResource());\n+\t\treturn Iterables.filter(issueProvider.getIssues(element), it -> Severity.ERROR.equals(it.getSeverity()));\n+\t}\n+\n+\tpublic boolean hasErrors(EObject element) {\n+\t\tIElementIssueProvider issueProvider = issueProviderFactory.get(element.eResource());", "originalCommit": "2e6f0b822a195e7665a672ecbf5735b945b79cba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0ODU5NA==", "url": "https://github.com/eclipse/xtext-extras/pull/623#discussion_r447148594", "bodyText": "Unnecessary explicit unboxing.", "author": "szarnekow", "createdAt": "2020-06-29T17:52:08Z", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/ErrorSafeExtensions.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmAnnotationReference;\n+import org.eclipse.xtext.common.types.JvmSpecializedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.common.types.JvmUnknownTypeReference;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.compiler.BrokenTypeRefDetector;\n+import org.eclipse.xtext.xbase.compiler.IElementIssueProvider;\n+import org.eclipse.xtext.xbase.compiler.LoopParams;\n+import org.eclipse.xtext.xbase.compiler.TypeReferenceSerializer;\n+import org.eclipse.xtext.xbase.compiler.output.ErrorTreeAppendable;\n+import org.eclipse.xtext.xbase.compiler.output.ITreeAppendable;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ObjectExtensions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+/**\n+ * @author Jan Koehnlein\n+ */\n+public class ErrorSafeExtensions {\n+\t@Inject\n+\tprivate TypeReferenceSerializer typeReferenceSerializer;\n+\n+\t@Inject\n+\tprivate IElementIssueProvider.Factory issueProviderFactory;\n+\n+\tpublic Iterable<Issue> getErrors(EObject element) {\n+\t\tIElementIssueProvider issueProvider = issueProviderFactory.get(element.eResource());\n+\t\treturn Iterables.filter(issueProvider.getIssues(element), it -> Severity.ERROR.equals(it.getSeverity()));\n+\t}\n+\n+\tpublic boolean hasErrors(EObject element) {\n+\t\tIElementIssueProvider issueProvider = issueProviderFactory.get(element.eResource());\n+\t\treturn IterableExtensions.exists(issueProvider.getIssues(element),\n+\t\t\t\tit -> Severity.ERROR.equals(it.getSeverity()));\n+\t}\n+\n+\tpublic <T extends EObject> void forEachSafely(ITreeAppendable appendable, Iterable<T> elements,\n+\t\t\tProcedure1<? super LoopParams> loopInitializer, Procedure2<? super T, ? super ITreeAppendable> body) {\n+\t\tif (Iterables.isEmpty(elements)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tLoopParams loopParams = ObjectExtensions.operator_doubleArrow(new LoopParams(), loopInitializer);\n+\t\tboolean allElementsBroken = Iterables\n+\t\t\t\t.size(Iterables.<T>filter(elements, (T it) -> hasErrors(it))) == Iterables.size(elements);\n+\t\tITreeAppendable currentAppendable = null;\n+\t\tif (allElementsBroken) {\n+\t\t\tcurrentAppendable = openErrorAppendable(appendable, null);\n+\t\t} else {\n+\t\t\tcurrentAppendable = appendable;\n+\t\t}\n+\t\tloopParams.appendPrefix(currentAppendable);\n+\t\tboolean isFirst = true;\n+\t\tboolean isFirstBroken = true;\n+\t\tfor (T element : elements) {\n+\t\t\tif (!hasErrors(element)) {\n+\t\t\t\tcurrentAppendable = closeErrorAppendable(appendable, currentAppendable);\n+\t\t\t\tif (!isFirst) {\n+\t\t\t\t\tloopParams.appendSeparator(appendable);\n+\t\t\t\t}\n+\t\t\t\tisFirst = false;\n+\t\t\t\tbody.apply(element, appendable);\n+\t\t\t} else {\n+\t\t\t\tif (!allElementsBroken) {\n+\t\t\t\t\tcurrentAppendable = openErrorAppendable(appendable, currentAppendable);\n+\t\t\t\t}\n+\t\t\t\tif (!isFirst || !isFirstBroken) {\n+\t\t\t\t\tloopParams.appendSeparator(currentAppendable);\n+\t\t\t\t}\n+\t\t\t\tisFirstBroken = false;\n+\t\t\t\ttry {\n+\t\t\t\t\tbody.apply(element, currentAppendable);\n+\t\t\t\t} catch (Exception ignoreMe) {\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (!allElementsBroken) {\n+\t\t\tcurrentAppendable = closeErrorAppendable(appendable, currentAppendable);\n+\t\t}\n+\t\tloopParams.appendSuffix(currentAppendable);\n+\t\tcloseErrorAppendable(appendable, currentAppendable);\n+\t}\n+\n+\tprotected ITreeAppendable openErrorAppendable(ITreeAppendable parent, ITreeAppendable child) {\n+\t\tif (child instanceof ErrorTreeAppendable) {\n+\t\t\treturn child;\n+\t\t} else {\n+\t\t\treturn parent.errorChild().append(\"/* \");\n+\t\t}\n+\t}\n+\n+\tprotected ITreeAppendable closeErrorAppendable(ITreeAppendable parent, ITreeAppendable child) {\n+\t\tif (child instanceof ErrorTreeAppendable && !Objects.equal(child, parent)) {\n+\t\t\tchild.append(\" */\");\n+\t\t}\n+\t\treturn parent;\n+\t}\n+\n+\tpublic void serializeSafely(JvmTypeReference typeRef, ITreeAppendable appendable) {\n+\t\tserializeSafely(typeRef, null, appendable);\n+\t}\n+\n+\tpublic void serializeSafely(JvmTypeReference typeRef, String surrogateType, ITreeAppendable appendable) {\n+\t\tif (typeRef == null || typeRef.getType() == null) {\n+\t\t\tif (typeRef instanceof JvmSpecializedTypeReference) {\n+\t\t\t\tserializeSafely(((JvmSpecializedTypeReference) typeRef).getEquivalent(), surrogateType, appendable);\n+\t\t\t} else if (typeRef instanceof JvmUnknownTypeReference) {\n+\t\t\t\tappendable.append(((JvmUnknownTypeReference) typeRef).getQualifiedName());\n+\t\t\t} else {\n+\t\t\t\tappendable.append(\"Object\");\n+\t\t\t\tITreeAppendable errorChild = openErrorAppendable(appendable, appendable);\n+\t\t\t\terrorChild.append(\"type is 'null'\");\n+\t\t\t\tcloseErrorAppendable(appendable, errorChild);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (typeRef.accept(new BrokenTypeRefDetector()).booleanValue()) {", "originalCommit": "2e6f0b822a195e7665a672ecbf5735b945b79cba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE1MDE5OQ==", "url": "https://github.com/eclipse/xtext-extras/pull/623#discussion_r447150199", "bodyText": "Unnecessary qualification.", "author": "szarnekow", "createdAt": "2020-06-29T17:54:54Z", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/util/PropertyUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.util;\n+\n+import java.beans.Introspector;\n+import java.util.Locale;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.Strings;\n+\n+/**\n+ * @author kosyakov - Initial contribution and API\n+ */\n+public class PropertyUtil {\n+\tpublic static String getPropertyName(JvmFeature feature) {\n+\t\tif (feature.isStatic()) {\n+\t\t\treturn PropertyUtil.getPropertyName(feature, feature.getSimpleName(), 1, 2);", "originalCommit": "2e6f0b822a195e7665a672ecbf5735b945b79cba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE1MTE0Mw==", "url": "https://github.com/eclipse/xtext-extras/pull/623#discussion_r447151143", "bodyText": "Thank you for keeping the comments", "author": "szarnekow", "createdAt": "2020-06-29T17:56:31Z", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/util/PropertyUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.util;\n+\n+import java.beans.Introspector;\n+import java.util.Locale;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.Strings;\n+\n+/**\n+ * @author kosyakov - Initial contribution and API\n+ */\n+public class PropertyUtil {\n+\tpublic static String getPropertyName(JvmFeature feature) {\n+\t\tif (feature.isStatic()) {\n+\t\t\treturn PropertyUtil.getPropertyName(feature, feature.getSimpleName(), 1, 2);\n+\t\t} else {\n+\t\t\treturn PropertyUtil.getPropertyName(feature, feature.getSimpleName(), 0, 1);\n+\t\t}\n+\t}\n+\n+\tpublic static String getPropertyName(JvmFeature feature, String methodName, int getterParams, int setterParams) {\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tJvmOperation operation = (JvmOperation) feature;\n+\t\t\tString propertyName = PropertyUtil.getPropertyName(operation, methodName, \"get\", getterParams);\n+\t\t\tif (propertyName != null) {\n+\t\t\t\treturn propertyName;\n+\t\t\t}\n+\t\t\tpropertyName = PropertyUtil.getPropertyName(operation, methodName, \"set\", setterParams);\n+\t\t\tif (propertyName != null) {\n+\t\t\t\treturn propertyName;\n+\t\t\t}\n+\t\t\treturn PropertyUtil.getPropertyName(operation, methodName, \"is\", getterParams);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected static String getPropertyName(JvmOperation operation, String methodName, String prefix, int params) {\n+\t\tint prefixLength = prefix.length();\n+\t\tif (PropertyUtil.startsWithPrefix(methodName, prefix, prefixLength)\n+\t\t\t\t&& operation.getParameters().size() == params) {\n+\t\t\treturn Introspector.decapitalize(methodName.substring(prefixLength));\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected static boolean startsWithPrefix(String methodName, String prefix, int prefixLength) {\n+\t\treturn methodName.length() > prefixLength && methodName.startsWith(prefix)\n+\t\t\t\t&& Character.isUpperCase(methodName.charAt(prefixLength));\n+\t}\n+\n+\t/**\n+\t * @Nullable\n+\t */\n+\tpublic static String tryGetShorthandName(String fullName) {\n+\t\tString name = null;\n+\t\tif (fullName.startsWith(\"get\") || fullName.startsWith(\"set\")) {\n+\t\t\tname = fullName.substring(3);\n+\t\t} else {\n+\t\t\tif (fullName.startsWith(\"is\")) {\n+\t\t\t\tname = fullName.substring(2);\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t\tif (name.length() == 1) { // e.g. Point.getX()\n+\t\t\treturn name.toLowerCase(Locale.ENGLISH);\n+\t\t} else {\n+\t\t\tif (name.length() > 1) {\n+\t\t\t\tif (Character.isUpperCase(name.charAt(1))) {\n+\t\t\t\t\t// if second char is uppercase, the name itself is the", "originalCommit": "2e6f0b822a195e7665a672ecbf5735b945b79cba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cf621cdabf54f1035f2cad34e968996617a96ad7", "url": "https://github.com/eclipse/xtext-extras/commit/cf621cdabf54f1035f2cad34e968996617a96ad7", "message": "[eclipse/xtext#1777] ported xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-29T19:20:52Z", "type": "commit"}, {"oid": "cf621cdabf54f1035f2cad34e968996617a96ad7", "url": "https://github.com/eclipse/xtext-extras/commit/cf621cdabf54f1035f2cad34e968996617a96ad7", "message": "[eclipse/xtext#1777] ported xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-29T19:20:52Z", "type": "forcePushed"}]}