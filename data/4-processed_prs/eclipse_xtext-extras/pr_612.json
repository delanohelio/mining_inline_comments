{"pr_number": 612, "pr_title": "[eclipse/xtext#1777] ported old gen: xtend 2 java + parts of xbase", "pr_createdAt": "2020-05-25T15:30:19Z", "pr_url": "https://github.com/eclipse/xtext-extras/pull/612", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyOTU1Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430029552", "bodyText": "No need for this", "author": "tivervac", "createdAt": "2020-05-25T17:38:30Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/adapter/Generator2AdapterSetup.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.adapter;\n+\n+import org.eclipse.xpand2.XpandExecutionContext;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.generator.Generator;\n+import org.eclipse.xtext.generator.LanguageConfig;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.generator.CodeConfig;\n+import org.eclipse.xtext.xtext.generator.DefaultGeneratorModule;\n+import org.eclipse.xtext.xtext.generator.IXtextGeneratorLanguage;\n+import org.eclipse.xtext.xtext.generator.XtextGeneratorLanguage;\n+import org.eclipse.xtext.xtext.generator.XtextGeneratorNaming;\n+import org.eclipse.xtext.xtext.generator.model.project.StandardProjectConfig;\n+import org.eclipse.xtext.xtext.generator.model.project.XtextProjectConfig;\n+\n+import com.google.common.base.Joiner;\n+import com.google.inject.Binder;\n+import com.google.inject.Guice;\n+import com.google.inject.Injector;\n+\n+/**\n+ * @since 2.9\n+ */\n+@Deprecated\n+public class Generator2AdapterSetup {\n+\tprivate LanguageConfig languageConfig;\n+\n+\tprivate XpandExecutionContext xpandContext;\n+\n+\tprivate Naming naming;\n+\n+\tprivate Injector injector;\n+\n+\tprivate com.google.inject.Module additionalGeneratorBindings = (Binder it) -> {\n+\t};\n+\n+\tprivate com.google.inject.Module additionalLanguageBindings = (Binder it) -> {\n+\t};\n+\n+\tpublic Generator2AdapterSetup(LanguageConfig languageConfig, XpandExecutionContext xpandContext, Naming naming) {\n+\t\tthis.languageConfig = languageConfig;\n+\t\tthis.xpandContext = xpandContext;\n+\t\tthis.naming = naming;\n+\t}\n+\n+\tpublic Injector getInjector() {\n+\t\tif (this.injector == null) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMTkyNA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430031924", "bodyText": "s/identifier/identifiers/", "author": "tivervac", "createdAt": "2020-05-25T17:48:26Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMTk5MQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430031991", "bodyText": "s/segments/segment/", "author": "tivervac", "createdAt": "2020-05-25T17:48:45Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjE0NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032145", "bodyText": "Uppercasing every segment's first char would be PascalCase though", "author": "tivervac", "createdAt": "2020-05-25T17:49:29Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjM1Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032352", "bodyText": "s/idetifier/identifier/", "author": "tivervac", "createdAt": "2020-05-25T17:50:11Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjY2NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032665", "bodyText": "s/full qulified/fully qualified/\n{@link GrammarAccess}", "author": "tivervac", "createdAt": "2020-05-25T17:51:25Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjg0NA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032844", "bodyText": "s/full/fully/", "author": "tivervac", "createdAt": "2020-05-25T17:52:17Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMjkwNg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430032906", "bodyText": "{@link}", "author": "tivervac", "createdAt": "2020-05-25T17:52:32Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzAwOA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430033008", "bodyText": "Here as well", "author": "tivervac", "createdAt": "2020-05-25T17:52:51Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzQxOA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430033418", "bodyText": "There's a lot of places in this class which should get a javadoc link", "author": "tivervac", "createdAt": "2020-05-25T17:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODY4OA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058688", "bodyText": "wont spent to much optimization for a deprecated class", "author": "cdietrich", "createdAt": "2020-05-25T19:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzMzY2Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430033667", "bodyText": "s/accesor/accessor/", "author": "tivervac", "createdAt": "2020-05-25T17:55:26Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDE1Ng==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034156", "bodyText": "Is this API? if not, s/Methode/Method/", "author": "tivervac", "createdAt": "2020-05-25T17:57:37Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODg5OA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058898", "bodyText": "assume it is", "author": "cdietrich", "createdAt": "2020-05-25T19:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDI5Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034297", "bodyText": "Is this API? if not, s/Identifyer/Identifier/", "author": "tivervac", "createdAt": "2020-05-25T17:58:03Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODE1OA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058158", "bodyText": "i assume it is", "author": "cdietrich", "createdAt": "2020-05-25T19:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDMwOQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034309", "bodyText": "Is this API? if not, s/Identifyer/Identifier/", "author": "tivervac", "createdAt": "2020-05-25T17:58:07Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODEzMg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058132", "bodyText": "i assume it is", "author": "cdietrich", "createdAt": "2020-05-25T19:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDQ0Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034447", "bodyText": "Is this API? if not, s/Accesor/Accessor/", "author": "tivervac", "createdAt": "2020-05-25T17:58:37Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {\n+\t\treturn \"get\" + gaElementIdentifyer(element);\n+\t}\n+\n+\t/**\n+\t * Returns the simple class name of a rule's facade. A GrammarAccess\n+\t * implementation has a facade for each parser rule, which contains the\n+\t * methods for accessing the rule's elements.\n+\t * \n+\t * @param rule ruleName\n+\t * @return the simple class name\n+\t */\n+\tpublic String gaRuleAccesorClassName(AbstractRule rule) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1ODk0Ng==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430058946", "bodyText": "i assume it is", "author": "cdietrich", "createdAt": "2020-05-25T19:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDUxNg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034516", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-05-25T17:58:53Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {\n+\t\treturn \"get\" + gaElementIdentifyer(element);\n+\t}\n+\n+\t/**\n+\t * Returns the simple class name of a rule's facade. A GrammarAccess\n+\t * implementation has a facade for each parser rule, which contains the\n+\t * methods for accessing the rule's elements.\n+\t * \n+\t * @param rule ruleName\n+\t * @return the simple class name\n+\t */\n+\tpublic String gaRuleAccesorClassName(AbstractRule rule) {\n+\t\treturn gaRuleIdentifyer(rule) + \"Elements\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the rule accessor method as Java statement.\n+\t * \n+\t * @param rule the rule\n+\t * @return The java statement\n+\t */\n+\tpublic String gaRuleAccessor(AbstractRule rule) {\n+\t\treturn gaRuleAccessMethodName(rule) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the rule's content accessor method as Java\n+\t * statement.\n+\t * \n+\t * @param rule the rule\n+\t * @return The java statement\n+\t */\n+\tpublic String gaElementsAccessor(AbstractRule rule) {\n+\t\treturn gaRuleElementsMethodName(rule) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as Java statement.\n+\t * The called method is implemented by the rule's facade. Example:\n+\t * ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaElementAccessor(AbstractElement ele) {\n+\t\treturn gaElementAccessMethodeName(ele) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method for a GrammarAccess\n+\t * as Java statement. Example: prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaRuleElementAccessor(AbstractElement ele) {\n+\t\treturn gaElementsAccessor(GrammarUtil.containingRule(ele)) + \".\" + gaElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of an element or rule accessor, including the\n+\t * .getType() call. Example1: getFooRule().getType() Example2:\n+\t * getBarRule().getFooAction().getType()\n+\t */\n+\tpublic String gaTypeAccessor(TypeRef ele) {\n+\t\tEObject cnt = ele.eContainer();\n+\t\tif (cnt instanceof AbstractElement) {\n+\t\t\treturn gaRuleElementAccessor((AbstractElement) cnt) + \".getType()\";\n+\t\t} else if (cnt instanceof AbstractRule) {\n+\t\t\treturn gaRuleAccessor((AbstractRule) cnt) + \".getType()\";\n+\t\t} else {\n+\t\t\treturn (\"<error: unknown type \" + ele.eContainer().eClass().getName()) + \">\";\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of an element or rule accessor. Example1:\n+\t * getFooRule() Example2: getBarRule().getFooAction()\n+\t */\n+\tpublic String gaAccessor(EObject ele) {\n+\t\tif (ele instanceof AbstractElement) {\n+\t\t\treturn gaRuleElementAccessor(((AbstractElement) ele));", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDUyOA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034528", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-05-25T17:58:58Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccess.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*******************************************************************************\n+ * Copyright (c) 2010, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator.grammarAccess;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.TypeRef;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.xtext.RuleNames;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * This API can be used by other templates to generate code that has hard\n+ * references to grammar rules/elements\n+ * \n+ * @author Moritz Eysholdt\n+ */\n+@Deprecated\n+public class GrammarAccess {\n+\t@Inject\n+\tprivate Naming naming;\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as full qualified\n+\t * Java statement. Example: return\n+\t * FowlerDslTestLanguageGrammarAccess.INSTANCE.prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaFullAccessor(AbstractElement ele) {\n+\t\treturn gaSimpleName(GrammarUtil.getGrammar(ele)) + \".INSTANCE.\" + gaRuleElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Converts an arbitary string to a valid Java identifier. The string is\n+\t * split up along the the characters that are not valid as Java identifier.\n+\t * The first character of each segments is made upper case which leads to a\n+\t * camel-case style.\n+\t * \n+\t * @param text the string\n+\t * @param uppercaseFirst whether the first character of the returned\n+\t * identifier should be uppercase or lowercase\n+\t * @return the java identifier\n+\t */\n+\tpublic String toJavaIdentifier(String text, boolean uppercaseFirst) {\n+\t\treturn GrammarAccessUtil.toJavaIdentifier(text, Boolean.valueOf(uppercaseFirst));\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for a Rule which is a valid Java idetifier and\n+\t * unique within the Rule's grammar.\n+\t * \n+\t * @param rule the Rule\n+\t * @return the identifier\n+\t */\n+\tpublic String gaRuleIdentifyer(AbstractRule rule) {\n+\t\tString plainName = RuleNames.getRuleNames(rule).getUniqueRuleName(rule);\n+\t\treturn toJavaIdentifier(plainName, true);\n+\t}\n+\n+\t/**\n+\t * Creates an identifier for an AbstractElement which is a valid Java\n+\t * identifier and which is unique whithin the element's rule. The identifier\n+\t * tries to be as human-readable as possible.\n+\t * \n+\t * @param element the element\n+\t * @return the element's identifier\n+\t */\n+\tpublic String gaElementIdentifyer(AbstractElement element) {\n+\t\treturn GrammarAccessUtil.getUniqueElementName(element);\n+\t}\n+\n+\t/**\n+\t * Returns the full qulified Java class name of a GrammarAccess\n+\t * implementation for a grammar.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' full qualified Java class name\n+\t */\n+\tpublic String gaFQName(Grammar grammar) {\n+\t\treturn GrammarAccessUtil.getGrammarAccessFQName(grammar, naming);\n+\t}\n+\n+\t/**\n+\t * Returns the simple Java class name of a GrammarAccess implementation for\n+\t * a Grammar. The simple class name is defined as the class' name without\n+\t * any package names.\n+\t * \n+\t * @param grammar the grammar\n+\t * @return the GrammarAccess' simple class name\n+\t */\n+\tpublic String gaSimpleName(Grammar grammar) {\n+\t\treturn naming.toSimpleName(gaFQName(grammar));\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleAccessMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Rule\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing a rule's content via a\n+\t * ParseRuleAccess implementation.\n+\t * \n+\t * @param rule the rule for which the accessor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaRuleElementsMethodName(AbstractRule rule) {\n+\t\treturn \"get\" + gaRuleIdentifyer(rule) + \"Access\";\n+\t}\n+\n+\t/**\n+\t * Returns the method name for accessing an element via a GrammarAccess\n+\t * implementation.\n+\t * \n+\t * @param element the element for which the accesor method is needed\n+\t * @return the method's name.\n+\t */\n+\tpublic String gaElementAccessMethodeName(AbstractElement element) {\n+\t\treturn \"get\" + gaElementIdentifyer(element);\n+\t}\n+\n+\t/**\n+\t * Returns the simple class name of a rule's facade. A GrammarAccess\n+\t * implementation has a facade for each parser rule, which contains the\n+\t * methods for accessing the rule's elements.\n+\t * \n+\t * @param rule ruleName\n+\t * @return the simple class name\n+\t */\n+\tpublic String gaRuleAccesorClassName(AbstractRule rule) {\n+\t\treturn gaRuleIdentifyer(rule) + \"Elements\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the rule accessor method as Java statement.\n+\t * \n+\t * @param rule the rule\n+\t * @return The java statement\n+\t */\n+\tpublic String gaRuleAccessor(AbstractRule rule) {\n+\t\treturn gaRuleAccessMethodName(rule) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the rule's content accessor method as Java\n+\t * statement.\n+\t * \n+\t * @param rule the rule\n+\t * @return The java statement\n+\t */\n+\tpublic String gaElementsAccessor(AbstractRule rule) {\n+\t\treturn gaRuleElementsMethodName(rule) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method as Java statement.\n+\t * The called method is implemented by the rule's facade. Example:\n+\t * ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaElementAccessor(AbstractElement ele) {\n+\t\treturn gaElementAccessMethodeName(ele) + \"()\";\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of the element accessor method for a GrammarAccess\n+\t * as Java statement. Example: prStatemachine().ele1AssignmentStates()\n+\t * \n+\t * @param ele the element\n+\t * @return The java statement\n+\t */\n+\tpublic String gaRuleElementAccessor(AbstractElement ele) {\n+\t\treturn gaElementsAccessor(GrammarUtil.containingRule(ele)) + \".\" + gaElementAccessor(ele);\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of an element or rule accessor, including the\n+\t * .getType() call. Example1: getFooRule().getType() Example2:\n+\t * getBarRule().getFooAction().getType()\n+\t */\n+\tpublic String gaTypeAccessor(TypeRef ele) {\n+\t\tEObject cnt = ele.eContainer();\n+\t\tif (cnt instanceof AbstractElement) {\n+\t\t\treturn gaRuleElementAccessor((AbstractElement) cnt) + \".getType()\";\n+\t\t} else if (cnt instanceof AbstractRule) {\n+\t\t\treturn gaRuleAccessor((AbstractRule) cnt) + \".getType()\";\n+\t\t} else {\n+\t\t\treturn (\"<error: unknown type \" + ele.eContainer().eClass().getName()) + \">\";\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Returns the invocation of an element or rule accessor. Example1:\n+\t * getFooRule() Example2: getBarRule().getFooAction()\n+\t */\n+\tpublic String gaAccessor(EObject ele) {\n+\t\tif (ele instanceof AbstractElement) {\n+\t\t\treturn gaRuleElementAccessor(((AbstractElement) ele));\n+\t\t} else if (ele instanceof AbstractRule) {\n+\t\t\treturn gaRuleAccessor(((AbstractRule) ele));", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDY5Mw==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034693", "bodyText": "No need for this\nThere's a lot of this in this class", "author": "tivervac", "createdAt": "2020-05-25T17:59:40Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/parser/antlr/AbstractAntlrXtendGeneratorFragment.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.parser.antlr;\n+\n+import java.util.List;\n+\n+import org.eclipse.xpand2.XpandExecutionContext;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.IGrammarAccess;\n+import org.eclipse.xtext.generator.Naming;\n+import org.eclipse.xtext.generator.Xtend2ExecutionContext;\n+import org.eclipse.xtext.generator.Xtend2GeneratorFragment;\n+\n+import com.google.inject.Binder;\n+import com.google.inject.Guice;\n+\n+/**\n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.8\n+ */\n+@Deprecated\n+public abstract class AbstractAntlrXtendGeneratorFragment extends AbstractAntlrGeneratorFragment {\n+\tprotected com.google.inject.Module createModule(Grammar grammar) {\n+\t\treturn new com.google.inject.Module() {\n+\t\t\t@Override\n+\t\t\tpublic void configure(Binder binder) {\n+\t\t\t\tbinder.bind(Grammar.class).toInstance(grammar);\n+\t\t\t\tbinder.bind(Naming.class).toInstance(getNaming());\n+\t\t\t\tbinder.bind(IGrammarAccess.class).toInstance(new Xtend2GeneratorFragment.GenericGrammarAccess(grammar));\n+\t\t\t\taddLocalBindings(binder);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addLocalBindings(Binder binder) {\n+\t}\n+\n+\t@Override\n+\tpublic void generate(Grammar grammar, XpandExecutionContext ctx) {\n+\t\tthis.checkGrammar(grammar);", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDk0Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430034942", "bodyText": "Off topic, why is there an @since 2.8 on a private field? For documentation?", "author": "tivervac", "createdAt": "2020-05-25T18:00:44Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/serializer/SerializerFragment.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.serializer;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xpand2.XpandExecutionContext;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.generator.BindFactory;\n+import org.eclipse.xtext.generator.Binding;\n+import org.eclipse.xtext.generator.IStubGenerating;\n+import org.eclipse.xtext.generator.LanguageConfig;\n+import org.eclipse.xtext.generator.Xtend2ExecutionContext;\n+import org.eclipse.xtext.generator.Xtend2GeneratorFragment;\n+import org.eclipse.xtext.generator.adapter.Generator2AdapterSetup;\n+import org.eclipse.xtext.generator.parser.antlr.ex.wsAware.SyntheticTerminalAwareFragmentHelper;\n+import org.eclipse.xtext.generator.terminals.SyntheticTerminalDetector;\n+import org.eclipse.xtext.parser.antlr.AbstractSplittingTokenSource;\n+import org.eclipse.xtext.serializer.ISerializer;\n+import org.eclipse.xtext.serializer.impl.Serializer;\n+import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;\n+import org.eclipse.xtext.serializer.sequencer.ISyntacticSequencer;\n+import org.eclipse.xtext.xtext.generator.CodeConfig;\n+import org.eclipse.xtext.xtext.generator.serializer.SerializerFragment2;\n+\n+import com.google.common.collect.Lists;\n+import com.google.inject.Binder;\n+import com.google.inject.Inject;\n+import com.google.inject.name.Names;\n+\n+/**\n+ * @author Moritz Eyshold - Initial contribution and API\n+ */\n+@Deprecated\n+public class SerializerFragment extends Xtend2GeneratorFragment\n+\t\timplements IStubGenerating, IStubGenerating.XtendOption {\n+\t@Inject\n+\tprivate SerializerGenFileNames names;\n+\n+\tprivate boolean generateDebugData = false;\n+\n+\tprivate boolean srcGenOnly = false;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tprivate boolean detectSyntheticTerminals = true;", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTI1Ng==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430059256", "bodyText": "no idea", "author": "cdietrich", "createdAt": "2020-05-25T19:50:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTMwMQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430059301", "bodyText": "assume so", "author": "cdietrich", "createdAt": "2020-05-25T19:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNDk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNTQ5Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430035492", "bodyText": "{@plainlink}", "author": "tivervac", "createdAt": "2020-05-25T18:03:11Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/contentAssist/ContentAssistFragmentExtensions.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ui.generator.contentAssist;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.StringExtensions;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Created for https://bugs.eclipse.org/bugs/show_bug.cgi?id=471434", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNjM4NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430036385", "bodyText": "Using xbase utils here", "author": "tivervac", "createdAt": "2020-05-25T18:05:31Z", "path": "org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/contentAssist/ContentAssistFragmentExtensions.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ui.generator.contentAssist;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.Grammar;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.StringExtensions;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Created for https://bugs.eclipse.org/bugs/show_bug.cgi?id=471434\n+ * \n+ * @author Lorenzo Bettini - Initial contribution and API\n+ * @since 2.8\n+ * @noreference This class is not intended to be referenced by clients.\n+ */\n+public class ContentAssistFragmentExtensions {\n+\tpublic static String getFqFeatureName(Assignment it) {\n+\t\treturn StringExtensions.toFirstUpper(GrammarUtil.containingParserRule(it).getName()) + \"_\"\n+\t\t\t\t+ StringExtensions.toFirstUpper(it.getFeature());\n+\t}\n+\n+\tpublic static String getFqFeatureName(AbstractRule it) {\n+\t\treturn \"_\" + it.getName();\n+\t}\n+\n+\tpublic static Grammar getSuperGrammar(Grammar grammar) {\n+\t\treturn Iterables.getFirst(grammar.getUsedGrammars(), null);\n+\t}\n+\n+\tpublic static Set<String> getFqFeatureNamesToExclude(Grammar grammar) {\n+\t\tSet<String> toExclude = new HashSet<>();\n+\t\tGrammar superGrammar = ContentAssistFragmentExtensions.getSuperGrammar(grammar);\n+\t\tif (superGrammar != null) {\n+\t\t\tSet<String> superGrammarsFqFeatureNames = ContentAssistFragmentExtensions\n+\t\t\t\t\t.computeFqFeatureNamesFromSuperGrammars(grammar);\n+\t\t\tSet<String> thisGrammarFqFeatureNames = IterableExtensions", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTkzNQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430059935", "bodyText": "yes. dont know better alternative", "author": "cdietrich", "createdAt": "2020-05-25T19:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNjM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNzA5NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430037095", "bodyText": "No need for parentheses", "author": "tivervac", "createdAt": "2020-05-25T18:08:52Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/ClasspathBasedIdeTypesProposalProvider.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.Collections;\n+\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.common.types.descriptions.ClasspathScanner;\n+import org.eclipse.xtext.common.types.descriptions.ITypeDescriptor;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IIdeContentProposalAcceptor;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeContentProposalCreator;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeContentProposalPriorities;\n+import org.eclipse.xtext.naming.IQualifiedNameConverter;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.ReplaceRegion;\n+import org.eclipse.xtext.xbase.imports.IImportsConfiguration;\n+import org.eclipse.xtext.xbase.imports.ImportSectionRegionUtil;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xtype.XImportDeclaration;\n+import org.eclipse.xtext.xtype.XImportSection;\n+import org.eclipse.xtext.xtype.XtypePackage;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class ClasspathBasedIdeTypesProposalProvider implements IIdeTypesProposalProvider {\n+\t@Inject\n+\tprivate ClassLoader classLoader;\n+\n+\t@Inject\n+\tprivate ClasspathScanner classpathScanner;\n+\n+\t@Inject\n+\tprivate IdeContentProposalCreator proposalCreator;\n+\n+\t@Inject\n+\tprivate IdeContentProposalPriorities proposalPriorities;\n+\n+\t@Inject\n+\tprivate IQualifiedNameConverter qualifiedNameConverter;\n+\n+\t@Inject\n+\tprivate IImportsConfiguration importsConfiguration;\n+\n+\t@Inject\n+\tprivate ImportSectionRegionUtil importSectionRegionUtil;\n+\n+\t@Override\n+\tpublic void createTypeProposals(EReference reference, ContentAssistContext context,\n+\t\t\tPredicate<? super ITypeDescriptor> filter, IIdeContentProposalAcceptor acceptor) {\n+\t\tITextRegion importSectionRegion = null;\n+\t\tXImportSection importSection = null;\n+\t\tif (!isImportDeclaration(reference, context)) {\n+\t\t\timportSection = importsConfiguration.getImportSection(context.getResource());\n+\t\t\timportSectionRegion = importSectionRegionUtil.computeRegion(context.getResource());\n+\t\t}\n+\t\tfor (ITypeDescriptor typeDesc : getTypeDescriptors(context)) {\n+\t\t\tif (!acceptor.canAcceptMoreProposals()) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (canPropose(typeDesc, context, filter)) {\n+\t\t\t\tContentAssistEntry entry = createProposal(reference, typeDesc, context, importSection,\n+\t\t\t\t\t\timportSectionRegion);\n+\t\t\t\tint priority = ((XbaseIdeContentProposalPriorities) proposalPriorities).getTypeRefPriority(typeDesc,\n+\t\t\t\t\t\tentry);\n+\t\t\t\tacceptor.accept(entry, priority);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<ITypeDescriptor> getTypeDescriptors(ContentAssistContext context) {\n+\t\tIterable<ITypeDescriptor> bootClasspath = classpathScanner\n+\t\t\t\t.getBootClasspathDescriptors(Lists.newArrayList(\"java\"));\n+\t\tIterable<ITypeDescriptor> appClasspath = classpathScanner.getDescriptors(getClassLoader(context),\n+\t\t\t\tCollections.emptyList());\n+\t\treturn Iterables.concat(bootClasspath, appClasspath);\n+\t}\n+\n+\tprotected ClassLoader getClassLoader(ContentAssistContext context) {\n+\t\tResourceSet resourceSet = context.getResource().getResourceSet();\n+\t\tif (resourceSet instanceof XtextResourceSet) {\n+\t\t\tObject ctx = ((XtextResourceSet) resourceSet).getClasspathURIContext();\n+\t\t\tif (ctx != null) {\n+\t\t\t\tif (ctx instanceof Class<?>) {\n+\t\t\t\t\treturn ((Class<?>) ctx).getClassLoader();\n+\t\t\t\t}\n+\t\t\t\tif (ctx instanceof ClassLoader) {\n+\t\t\t\t\treturn ((ClassLoader) ctx);", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNzU2NA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430037564", "bodyText": "s/9/\"java.lang\".length/", "author": "tivervac", "createdAt": "2020-05-25T18:10:46Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/ClasspathBasedIdeTypesProposalProvider.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.Collections;\n+\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.common.types.descriptions.ClasspathScanner;\n+import org.eclipse.xtext.common.types.descriptions.ITypeDescriptor;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IIdeContentProposalAcceptor;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeContentProposalCreator;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeContentProposalPriorities;\n+import org.eclipse.xtext.naming.IQualifiedNameConverter;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.ReplaceRegion;\n+import org.eclipse.xtext.xbase.imports.IImportsConfiguration;\n+import org.eclipse.xtext.xbase.imports.ImportSectionRegionUtil;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xtype.XImportDeclaration;\n+import org.eclipse.xtext.xtype.XImportSection;\n+import org.eclipse.xtext.xtype.XtypePackage;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+\n+public class ClasspathBasedIdeTypesProposalProvider implements IIdeTypesProposalProvider {\n+\t@Inject\n+\tprivate ClassLoader classLoader;\n+\n+\t@Inject\n+\tprivate ClasspathScanner classpathScanner;\n+\n+\t@Inject\n+\tprivate IdeContentProposalCreator proposalCreator;\n+\n+\t@Inject\n+\tprivate IdeContentProposalPriorities proposalPriorities;\n+\n+\t@Inject\n+\tprivate IQualifiedNameConverter qualifiedNameConverter;\n+\n+\t@Inject\n+\tprivate IImportsConfiguration importsConfiguration;\n+\n+\t@Inject\n+\tprivate ImportSectionRegionUtil importSectionRegionUtil;\n+\n+\t@Override\n+\tpublic void createTypeProposals(EReference reference, ContentAssistContext context,\n+\t\t\tPredicate<? super ITypeDescriptor> filter, IIdeContentProposalAcceptor acceptor) {\n+\t\tITextRegion importSectionRegion = null;\n+\t\tXImportSection importSection = null;\n+\t\tif (!isImportDeclaration(reference, context)) {\n+\t\t\timportSection = importsConfiguration.getImportSection(context.getResource());\n+\t\t\timportSectionRegion = importSectionRegionUtil.computeRegion(context.getResource());\n+\t\t}\n+\t\tfor (ITypeDescriptor typeDesc : getTypeDescriptors(context)) {\n+\t\t\tif (!acceptor.canAcceptMoreProposals()) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (canPropose(typeDesc, context, filter)) {\n+\t\t\t\tContentAssistEntry entry = createProposal(reference, typeDesc, context, importSection,\n+\t\t\t\t\t\timportSectionRegion);\n+\t\t\t\tint priority = ((XbaseIdeContentProposalPriorities) proposalPriorities).getTypeRefPriority(typeDesc,\n+\t\t\t\t\t\tentry);\n+\t\t\t\tacceptor.accept(entry, priority);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<ITypeDescriptor> getTypeDescriptors(ContentAssistContext context) {\n+\t\tIterable<ITypeDescriptor> bootClasspath = classpathScanner\n+\t\t\t\t.getBootClasspathDescriptors(Lists.newArrayList(\"java\"));\n+\t\tIterable<ITypeDescriptor> appClasspath = classpathScanner.getDescriptors(getClassLoader(context),\n+\t\t\t\tCollections.emptyList());\n+\t\treturn Iterables.concat(bootClasspath, appClasspath);\n+\t}\n+\n+\tprotected ClassLoader getClassLoader(ContentAssistContext context) {\n+\t\tResourceSet resourceSet = context.getResource().getResourceSet();\n+\t\tif (resourceSet instanceof XtextResourceSet) {\n+\t\t\tObject ctx = ((XtextResourceSet) resourceSet).getClasspathURIContext();\n+\t\t\tif (ctx != null) {\n+\t\t\t\tif (ctx instanceof Class<?>) {\n+\t\t\t\t\treturn ((Class<?>) ctx).getClassLoader();\n+\t\t\t\t}\n+\t\t\t\tif (ctx instanceof ClassLoader) {\n+\t\t\t\t\treturn ((ClassLoader) ctx);\n+\t\t\t\t}\n+\t\t\t\treturn ctx.getClass().getClassLoader();\n+\t\t\t}\n+\t\t}\n+\t\treturn classLoader;\n+\t}\n+\n+\tprotected boolean canPropose(ITypeDescriptor typeDesc, ContentAssistContext context,\n+\t\t\tPredicate<? super ITypeDescriptor> filter) {\n+\t\treturn isVisible(typeDesc, context) && filter.apply(typeDesc);\n+\t}\n+\n+\tprotected boolean isVisible(ITypeDescriptor typeDesc, ContentAssistContext context) {\n+\t\treturn Modifier.isPublic(typeDesc.getModifiers());\n+\t}\n+\n+\tprotected ContentAssistEntry createProposal(EReference reference, ITypeDescriptor typeDesc,\n+\t\t\tContentAssistContext context, XImportSection importSection, ITextRegion importSectionRegion) {\n+\t\tboolean importDecl = isImportDeclaration(reference, context);\n+\t\tString qualifiedName = qualifiedNameConverter.toString(typeDesc.getQualifiedName());\n+\t\tString proposal;\n+\t\tif (importDecl) {\n+\t\t\tproposal = qualifiedName;\n+\t\t} else {\n+\t\t\tproposal = typeDesc.getSimpleName();\n+\t\t}\n+\t\treturn proposalCreator.createProposal(proposal, context, (ContentAssistEntry it) -> {\n+\t\t\tit.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\tif (importDecl) {\n+\t\t\t\tit.setLabel(typeDesc.getSimpleName());\n+\t\t\t\tit.setDescription(proposal);\n+\t\t\t} else {\n+\t\t\t\tit.setDescription(qualifiedName);\n+\t\t\t\tif (importSectionRegion != null\n+\t\t\t\t\t\t&& isImportDeclarationRequired(typeDesc, qualifiedName, context, importSection)) {\n+\t\t\t\t\taddImportDeclaration(it, importSectionRegion, typeDesc, qualifiedName, context);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprotected boolean isImportDeclaration(EReference reference, ContentAssistContext context) {\n+\t\treturn XtypePackage.Literals.XIMPORT_DECLARATION__IMPORTED_TYPE.equals(reference);\n+\t}\n+\n+\tprotected boolean isImportDeclarationRequired(ITypeDescriptor typeDesc, String qualifiedName,\n+\t\t\tContentAssistContext context, XImportSection importSection) {\n+\t\treturn !(typeDesc.getName().startsWith(\"java.lang\") && typeDesc.getName().lastIndexOf('.') == 9)", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNzg3Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430037877", "bodyText": ".equals?", "author": "tivervac", "createdAt": "2020-05-25T18:12:02Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.util.ContextualVisibilityHelper;\n+import org.eclipse.xtext.xbase.typesystem.util.IVisibilityHelper;\n+\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+\n+public class OverrideProposalUtil {\n+\t@Inject\n+\tprivate IGeneratorConfigProvider generatorConfigProvider;\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IVisibilityHelper visibilityHelper;\n+\n+\tpublic List<IResolvedExecutable> getImplementationCandidates(JvmDeclaredType type, boolean isAnonymous) {\n+\t\tif (type == null || !(type instanceof JvmGenericType)) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tJavaVersion sourceVersion = generatorConfigProvider.get(type).getJavaSourceVersion();\n+\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(type, sourceVersion);\n+\t\tList<IResolvedExecutable> result = new ArrayList<>();\n+\t\tContextualVisibilityHelper contextualVisibilityHelper = new ContextualVisibilityHelper(visibilityHelper,\n+\t\t\t\tresolvedFeatures.getType());\n+\t\taddOperationCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\tif (!isAnonymous && !((JvmGenericType) type).isInterface()) {\n+\t\t\taddConstructorCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected void addOperationCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tList<IResolvedOperation> allOperations = resolvedFeatures.getAllOperations();\n+\t\tLightweightTypeReference inferredType = resolvedFeatures.getType();\n+\t\tfor (IResolvedOperation operation : allOperations) {\n+\t\t\tif (isCandidate(inferredType, operation, visibilityHelper)) {\n+\t\t\t\tresult.add(operation);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void addConstructorCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tLightweightTypeReference typeReference = resolvedFeatures.getType();\n+\t\tList<LightweightTypeReference> superTypes = typeReference.getSuperTypes();\n+\t\tfor (LightweightTypeReference superType : superTypes) {\n+\t\t\tif (!superType.isInterfaceType()) {\n+\t\t\t\tList<IResolvedConstructor> declaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t\t\tSet<String> erasedSignatures = Sets.<String>newHashSet();\n+\t\t\t\tfor (IResolvedConstructor constructor : declaredConstructors) {\n+\t\t\t\t\terasedSignatures.add(constructor.getResolvedErasureSignature());\n+\t\t\t\t}\n+\t\t\t\tResolvedFeatures superClass = overrideHelper.getResolvedFeatures(superType);\n+\t\t\t\tfor (IResolvedConstructor superclassConstructor : superClass.getDeclaredConstructors()) {\n+\t\t\t\t\tIResolvedConstructor overriddenConstructor = new ResolvedConstructor(\n+\t\t\t\t\t\t\tsuperclassConstructor.getDeclaration(), typeReference);\n+\t\t\t\t\tif (isCandidate(typeReference, overriddenConstructor, visibilityHelper)) {\n+\t\t\t\t\t\tif (erasedSignatures.add(superclassConstructor.getResolvedErasureSignature())) {\n+\t\t\t\t\t\t\tresult.add(overriddenConstructor);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean isCandidate(LightweightTypeReference type, IResolvedExecutable executable,\n+\t\t\tIVisibilityHelper visibilityHelper) {\n+\t\tJvmDeclaredType declaringType = executable.getDeclaration().getDeclaringType();\n+\t\tif (type.getType() != declaringType && isVisible(executable, visibilityHelper)) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MDQ3Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430060477", "bodyText": "was like this before", "author": "cdietrich", "createdAt": "2020-05-25T19:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzNzg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODA5MA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430038090", "bodyText": "Unneeded parentheses", "author": "tivervac", "createdAt": "2020-05-25T18:12:49Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.util.ContextualVisibilityHelper;\n+import org.eclipse.xtext.xbase.typesystem.util.IVisibilityHelper;\n+\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+\n+public class OverrideProposalUtil {\n+\t@Inject\n+\tprivate IGeneratorConfigProvider generatorConfigProvider;\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IVisibilityHelper visibilityHelper;\n+\n+\tpublic List<IResolvedExecutable> getImplementationCandidates(JvmDeclaredType type, boolean isAnonymous) {\n+\t\tif (type == null || !(type instanceof JvmGenericType)) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tJavaVersion sourceVersion = generatorConfigProvider.get(type).getJavaSourceVersion();\n+\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(type, sourceVersion);\n+\t\tList<IResolvedExecutable> result = new ArrayList<>();\n+\t\tContextualVisibilityHelper contextualVisibilityHelper = new ContextualVisibilityHelper(visibilityHelper,\n+\t\t\t\tresolvedFeatures.getType());\n+\t\taddOperationCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\tif (!isAnonymous && !((JvmGenericType) type).isInterface()) {\n+\t\t\taddConstructorCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected void addOperationCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tList<IResolvedOperation> allOperations = resolvedFeatures.getAllOperations();\n+\t\tLightweightTypeReference inferredType = resolvedFeatures.getType();\n+\t\tfor (IResolvedOperation operation : allOperations) {\n+\t\t\tif (isCandidate(inferredType, operation, visibilityHelper)) {\n+\t\t\t\tresult.add(operation);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void addConstructorCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tLightweightTypeReference typeReference = resolvedFeatures.getType();\n+\t\tList<LightweightTypeReference> superTypes = typeReference.getSuperTypes();\n+\t\tfor (LightweightTypeReference superType : superTypes) {\n+\t\t\tif (!superType.isInterfaceType()) {\n+\t\t\t\tList<IResolvedConstructor> declaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t\t\tSet<String> erasedSignatures = Sets.<String>newHashSet();\n+\t\t\t\tfor (IResolvedConstructor constructor : declaredConstructors) {\n+\t\t\t\t\terasedSignatures.add(constructor.getResolvedErasureSignature());\n+\t\t\t\t}\n+\t\t\t\tResolvedFeatures superClass = overrideHelper.getResolvedFeatures(superType);\n+\t\t\t\tfor (IResolvedConstructor superclassConstructor : superClass.getDeclaredConstructors()) {\n+\t\t\t\t\tIResolvedConstructor overriddenConstructor = new ResolvedConstructor(\n+\t\t\t\t\t\t\tsuperclassConstructor.getDeclaration(), typeReference);\n+\t\t\t\t\tif (isCandidate(typeReference, overriddenConstructor, visibilityHelper)) {\n+\t\t\t\t\t\tif (erasedSignatures.add(superclassConstructor.getResolvedErasureSignature())) {\n+\t\t\t\t\t\t\tresult.add(overriddenConstructor);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean isCandidate(LightweightTypeReference type, IResolvedExecutable executable,\n+\t\t\tIVisibilityHelper visibilityHelper) {\n+\t\tJvmDeclaredType declaringType = executable.getDeclaration().getDeclaringType();\n+\t\tif (type.getType() != declaringType && isVisible(executable, visibilityHelper)) {\n+\t\t\tJvmExecutable rawExecutable = executable.getDeclaration();\n+\t\t\tif (rawExecutable instanceof JvmOperation) {\n+\t\t\t\tJvmOperation operation = ((JvmOperation) rawExecutable);", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODE2NA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430038164", "bodyText": "More parentheses", "author": "tivervac", "createdAt": "2020-05-25T18:13:08Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/OverrideProposalUtil.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedExecutable;\n+import org.eclipse.xtext.xbase.typesystem.override.IResolvedOperation;\n+import org.eclipse.xtext.xbase.typesystem.override.OverrideHelper;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedConstructor;\n+import org.eclipse.xtext.xbase.typesystem.override.ResolvedFeatures;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.util.ContextualVisibilityHelper;\n+import org.eclipse.xtext.xbase.typesystem.util.IVisibilityHelper;\n+\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+\n+public class OverrideProposalUtil {\n+\t@Inject\n+\tprivate IGeneratorConfigProvider generatorConfigProvider;\n+\n+\t@Inject\n+\tprivate OverrideHelper overrideHelper;\n+\n+\t@Inject\n+\tprivate IVisibilityHelper visibilityHelper;\n+\n+\tpublic List<IResolvedExecutable> getImplementationCandidates(JvmDeclaredType type, boolean isAnonymous) {\n+\t\tif (type == null || !(type instanceof JvmGenericType)) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tJavaVersion sourceVersion = generatorConfigProvider.get(type).getJavaSourceVersion();\n+\t\tResolvedFeatures resolvedFeatures = overrideHelper.getResolvedFeatures(type, sourceVersion);\n+\t\tList<IResolvedExecutable> result = new ArrayList<>();\n+\t\tContextualVisibilityHelper contextualVisibilityHelper = new ContextualVisibilityHelper(visibilityHelper,\n+\t\t\t\tresolvedFeatures.getType());\n+\t\taddOperationCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\tif (!isAnonymous && !((JvmGenericType) type).isInterface()) {\n+\t\t\taddConstructorCandidates(resolvedFeatures, contextualVisibilityHelper, result);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected void addOperationCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tList<IResolvedOperation> allOperations = resolvedFeatures.getAllOperations();\n+\t\tLightweightTypeReference inferredType = resolvedFeatures.getType();\n+\t\tfor (IResolvedOperation operation : allOperations) {\n+\t\t\tif (isCandidate(inferredType, operation, visibilityHelper)) {\n+\t\t\t\tresult.add(operation);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void addConstructorCandidates(ResolvedFeatures resolvedFeatures, IVisibilityHelper visibilityHelper,\n+\t\t\tList<IResolvedExecutable> result) {\n+\t\tLightweightTypeReference typeReference = resolvedFeatures.getType();\n+\t\tList<LightweightTypeReference> superTypes = typeReference.getSuperTypes();\n+\t\tfor (LightweightTypeReference superType : superTypes) {\n+\t\t\tif (!superType.isInterfaceType()) {\n+\t\t\t\tList<IResolvedConstructor> declaredConstructors = resolvedFeatures.getDeclaredConstructors();\n+\t\t\t\tSet<String> erasedSignatures = Sets.<String>newHashSet();\n+\t\t\t\tfor (IResolvedConstructor constructor : declaredConstructors) {\n+\t\t\t\t\terasedSignatures.add(constructor.getResolvedErasureSignature());\n+\t\t\t\t}\n+\t\t\t\tResolvedFeatures superClass = overrideHelper.getResolvedFeatures(superType);\n+\t\t\t\tfor (IResolvedConstructor superclassConstructor : superClass.getDeclaredConstructors()) {\n+\t\t\t\t\tIResolvedConstructor overriddenConstructor = new ResolvedConstructor(\n+\t\t\t\t\t\t\tsuperclassConstructor.getDeclaration(), typeReference);\n+\t\t\t\t\tif (isCandidate(typeReference, overriddenConstructor, visibilityHelper)) {\n+\t\t\t\t\t\tif (erasedSignatures.add(superclassConstructor.getResolvedErasureSignature())) {\n+\t\t\t\t\t\t\tresult.add(overriddenConstructor);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean isCandidate(LightweightTypeReference type, IResolvedExecutable executable,\n+\t\t\tIVisibilityHelper visibilityHelper) {\n+\t\tJvmDeclaredType declaringType = executable.getDeclaration().getDeclaringType();\n+\t\tif (type.getType() != declaringType && isVisible(executable, visibilityHelper)) {\n+\t\t\tJvmExecutable rawExecutable = executable.getDeclaration();\n+\t\t\tif (rawExecutable instanceof JvmOperation) {\n+\t\t\t\tJvmOperation operation = ((JvmOperation) rawExecutable);\n+\t\t\t\tif (operation.isFinal() || operation.isStatic()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (type.getType() instanceof JvmGenericType && ((JvmGenericType) type.getType()).isInterface()) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MDY1NA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430060654", "bodyText": "?", "author": "cdietrich", "createdAt": "2020-05-25T19:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODQ3NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430038475", "bodyText": "No need for fqn", "author": "tivervac", "createdAt": "2020-05-25T18:14:35Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzODk0Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430038942", "bodyText": "Just a list is probably fine", "author": "tivervac", "createdAt": "2020-05-25T18:16:30Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTA2Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039062", "bodyText": "Make this an elsif", "author": "tivervac", "createdAt": "2020-05-25T18:17:05Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTE4MQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039181", "bodyText": "parentheses", "author": "tivervac", "createdAt": "2020-05-25T18:17:31Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTQxMw==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039413", "bodyText": "parentheses", "author": "tivervac", "createdAt": "2020-05-25T18:18:21Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t}\n+\t\t\tJvmTypeReference returnType = ((JvmOperation) feature).getReturnType();\n+\t\t\tif (returnType != null && returnType.getSimpleName() != null) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tlabelBuilder.append(converter.toLightweightReference(returnType).getHumanReadableName());\n+\t\t\t}\n+\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\tconverter.toPlainTypeReference(((JvmOperation) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\tif (!withParents) {\n+\t\t\t\tdescriptionBuilder.append(\".\");\n+\t\t\t\tdescriptionBuilder.append(((JvmOperation) feature).getSimpleName());\n+\t\t\t\tdescriptionBuilder.append(\"()\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (feature instanceof JvmField) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tif ((((JvmField) feature).getType() != null)) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTQ4MA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039480", "bodyText": "probably want to make the casted version a local variable", "author": "tivervac", "createdAt": "2020-05-25T18:18:40Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t}\n+\t\t\tJvmTypeReference returnType = ((JvmOperation) feature).getReturnType();\n+\t\t\tif (returnType != null && returnType.getSimpleName() != null) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tlabelBuilder.append(converter.toLightweightReference(returnType).getHumanReadableName());\n+\t\t\t}\n+\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\tconverter.toPlainTypeReference(((JvmOperation) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\tif (!withParents) {\n+\t\t\t\tdescriptionBuilder.append(\".\");\n+\t\t\t\tdescriptionBuilder.append(((JvmOperation) feature).getSimpleName());\n+\t\t\t\tdescriptionBuilder.append(\"()\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (feature instanceof JvmField) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tif ((((JvmField) feature).getType() != null)) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTU3Mw==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039573", "bodyText": "Just a list should be fine", "author": "tivervac", "createdAt": "2020-05-25T18:19:10Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t}\n+\t\t\tJvmTypeReference returnType = ((JvmOperation) feature).getReturnType();\n+\t\t\tif (returnType != null && returnType.getSimpleName() != null) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tlabelBuilder.append(converter.toLightweightReference(returnType).getHumanReadableName());\n+\t\t\t}\n+\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\tconverter.toPlainTypeReference(((JvmOperation) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\tif (!withParents) {\n+\t\t\t\tdescriptionBuilder.append(\".\");\n+\t\t\t\tdescriptionBuilder.append(((JvmOperation) feature).getSimpleName());\n+\t\t\t\tdescriptionBuilder.append(\"()\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (feature instanceof JvmField) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tif ((((JvmField) feature).getType() != null)) {\n+\t\t\t\t\tString fieldType = converter.toLightweightReference(((JvmField) feature).getType())\n+\t\t\t\t\t\t\t.getHumanReadableName();\n+\t\t\t\t\tif (fieldType != null) {\n+\t\t\t\t\t\tlabelBuilder.append(fieldType);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\t\tconverter.toPlainTypeReference(((JvmField) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\t} else if (feature instanceof JvmConstructor) {\n+\t\t\t\tif (withParents) {\n+\t\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tentry.setLabel(labelBuilder.toString());\n+\t\tentry.setDescription(descriptionBuilder.toString());\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, EObject element, String qualifiedNameAsString,\n+\t\t\tString shortName) {\n+\t\tQualifiedName qualifiedName = getQualifiedNameConverter().toQualifiedName(qualifiedNameAsString);\n+\t\tif (qualifiedName.getSegmentCount() > 1) {\n+\t\t\tentry.setLabel(qualifiedName.getLastSegment());\n+\t\t\tentry.setDescription(qualifiedNameAsString);\n+\t\t} else {\n+\t\t\tentry.setLabel(qualifiedNameAsString);\n+\t\t}\n+\t}\n+\n+\tprotected void appendParameters(StringBuilder result, JvmExecutable executable, int insignificantParameters,\n+\t\t\tLightweightTypeReferenceFactory ownedConverter) {\n+\t\tEList<JvmFormalParameter> declaredParameters = executable.getParameters();", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTYwNA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039604", "bodyText": "parentheses", "author": "tivervac", "createdAt": "2020-05-25T18:19:16Z", "path": "org.eclipse.xtext.xbase.ide/src/org/eclipse/xtext/xbase/ide/contentassist/XbaseIdeCrossrefProposalProvider.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.ide.contentassist;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.common.types.JvmConstructor;\n+import org.eclipse.xtext.common.types.JvmExecutable;\n+import org.eclipse.xtext.common.types.JvmFeature;\n+import org.eclipse.xtext.common.types.JvmField;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.common.types.JvmOperation;\n+import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;\n+import org.eclipse.xtext.common.types.JvmTypeReference;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext;\n+import org.eclipse.xtext.ide.editor.contentassist.ContentAssistEntry;\n+import org.eclipse.xtext.ide.editor.contentassist.IdeCrossrefProposalProvider;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReferenceFactory;\n+import org.eclipse.xtext.xbase.typesystem.references.StandardTypeReferenceOwner;\n+import org.eclipse.xtext.xbase.typesystem.util.CommonTypeComputationServices;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+public class XbaseIdeCrossrefProposalProvider extends IdeCrossrefProposalProvider {\n+\tpublic static class ProposalBracketInfo {\n+\t\tprivate String brackets = \"\";\n+\n+\t\tprivate int selectionOffset = 0;\n+\n+\t\tprivate int selectionLength = 0;\n+\n+\t\tprivate int caretOffset = 0;\n+\t}\n+\n+\t@Inject\n+\tprivate CommonTypeComputationServices typeComputationServices;\n+\n+\t@Override\n+\tpublic ContentAssistEntry createProposal(IEObjectDescription candidate, CrossReference crossRef,\n+\t\t\tContentAssistContext context) {\n+\t\tif (hasIdRule(crossRef)) {\n+\t\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo bracketInfo = getProposalBracketInfo(candidate,\n+\t\t\t\t\tcontext);\n+\t\t\tString proposalString = getQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets;\n+\t\t\tfinal int insignificantParameters;\n+\t\t\tif (candidate instanceof IIdentifiableElementDescription) {\n+\t\t\t\tinsignificantParameters = ((IIdentifiableElementDescription) candidate)\n+\t\t\t\t\t\t.getNumberOfIrrelevantParameters();\n+\t\t\t} else {\n+\t\t\t\tinsignificantParameters = 0;\n+\t\t\t}\n+\t\t\tLightweightTypeReferenceFactory converter = getTypeConverter(context.getResource());\n+\t\t\tEObject objectOrProxy = candidate.getEObjectOrProxy();\n+\t\t\treturn getProposalCreator().createProposal(proposalString, context, (ContentAssistEntry result) -> {\n+\t\t\t\tresult.setKind(ContentAssistEntry.KIND_REFERENCE);\n+\t\t\t\tif (objectOrProxy instanceof JvmFeature) {\n+\t\t\t\t\tif (bracketInfo.brackets.startsWith(\" =\")) {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy, false, insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()) + bracketInfo.brackets,\n+\t\t\t\t\t\t\t\tconverter);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddNameAndDescription(result, (JvmFeature) objectOrProxy,\n+\t\t\t\t\t\t\t\t!Strings.isNullOrEmpty(bracketInfo.brackets), insignificantParameters,\n+\t\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()), converter);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\taddNameAndDescription(result, objectOrProxy,\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getQualifiedName()),\n+\t\t\t\t\t\t\tgetQualifiedNameConverter().toString(candidate.getName()));\n+\t\t\t\t}\n+\t\t\t\tint offset = context.getOffset() - context.getPrefix().length() + proposalString.length();\n+\t\t\t\tresult.setEscapePosition(offset + bracketInfo.caretOffset);\n+\t\t\t\tif (bracketInfo.selectionOffset != 0) {\n+\t\t\t\t\toffset = offset + bracketInfo.selectionOffset;\n+\t\t\t\t\tresult.getEditPositions().add(new TextRegion(offset, bracketInfo.selectionLength));\n+\t\t\t\t}\n+\t\t\t\tif (objectOrProxy instanceof JvmExecutable) {\n+\t\t\t\t\tStringBuilder parameterList = new StringBuilder();\n+\t\t\t\t\tappendParameters(parameterList, (JvmExecutable) objectOrProxy, insignificantParameters, converter);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\treturn super.createProposal(candidate, crossRef, context);\n+\t}\n+\n+\tprotected boolean hasIdRule(CrossReference crossRef) {\n+\t\tif (crossRef.getTerminal() instanceof RuleCall) {\n+\t\t\tString ruleName = ((RuleCall) crossRef.getTerminal()).getRule().getName();\n+\t\t\treturn \"IdOrSuper\".equals(ruleName) || \"ValidID\".equals(ruleName) || \"FeatureCallID\".equals(ruleName);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprotected XbaseIdeCrossrefProposalProvider.ProposalBracketInfo getProposalBracketInfo(\n+\t\t\tIEObjectDescription proposedDescription, ContentAssistContext contentAssistContext) {\n+\t\tXbaseIdeCrossrefProposalProvider.ProposalBracketInfo info = new XbaseIdeCrossrefProposalProvider.ProposalBracketInfo();\n+\t\tif (proposedDescription instanceof IIdentifiableElementDescription) {\n+\t\t\tJvmIdentifiableElement jvmFeature = ((IIdentifiableElementDescription) proposedDescription)\n+\t\t\t\t\t.getElementOrProxy();\n+\t\t\tif (jvmFeature instanceof JvmExecutable) {\n+\t\t\t\tEList<JvmFormalParameter> parameters = ((JvmExecutable) jvmFeature).getParameters();\n+\t\t\t\tif (((IIdentifiableElementDescription) proposedDescription).getNumberOfParameters() == 1) {\n+\t\t\t\t\tif (((JvmExecutable) jvmFeature).getSimpleName().startsWith(\"set\")\n+\t\t\t\t\t\t\t&& !((IIdentifiableElementDescription) proposedDescription).getName().getFirstSegment()\n+\t\t\t\t\t\t\t\t\t.startsWith(\"set\")) {\n+\t\t\t\t\t\tinfo.brackets = \" = value\";\n+\t\t\t\t\t\tinfo.selectionOffset = -\"value\".length();\n+\t\t\t\t\t\tinfo.selectionLength = \"value\".length();\n+\t\t\t\t\t\treturn info;\n+\t\t\t\t\t}\n+\t\t\t\t\tJvmTypeReference parameterType = IterableExtensions.<JvmFormalParameter>last(parameters)\n+\t\t\t\t\t\t\t.getParameterType();\n+\t\t\t\t\tLightweightTypeReference light = getTypeConverter(contentAssistContext.getResource())\n+\t\t\t\t\t\t\t.toLightweightReference(parameterType);\n+\t\t\t\t\tif (light.isFunctionType()) {\n+\t\t\t\t\t\tint numParameters = light.getAsFunctionTypeReference().getParameterTypes().size();\n+\t\t\t\t\t\tif (numParameters == 1) {\n+\t\t\t\t\t\t\tinfo.brackets = \"[]\";\n+\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (numParameters == 0) {\n+\t\t\t\t\t\t\t\tinfo.brackets = \"[|]\";\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder();\n+\t\t\t\t\t\t\t\tfor (int i = 0; (i < numParameters); i++) {\n+\t\t\t\t\t\t\t\t\tif (i != 0) {\n+\t\t\t\t\t\t\t\t\t\tb.append(\", \");\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tb.append(\"p\" + (i + 1));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tinfo.brackets = (\"[\" + b.toString() + \"|]\");\n+\t\t\t\t\t\t\t\tinfo.caretOffset = -1;\n+\t\t\t\t\t\t\t\tinfo.selectionOffset = (-b.length()) - 2;\n+\t\t\t\t\t\t\t\tinfo.selectionLength = b.length();\n+\t\t\t\t\t\t\t\treturn info;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isExplicitOperationCall((IIdentifiableElementDescription) proposedDescription)) {\n+\t\t\t\tinfo.brackets = \"()\";\n+\t\t\t\tinfo.selectionOffset = -1;\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\n+\tprotected LightweightTypeReferenceFactory getTypeConverter(XtextResource context) {\n+\t\treturn new LightweightTypeReferenceFactory(new StandardTypeReferenceOwner(typeComputationServices,\n+\t\t\t\tcontext)) {\n+\t\t\t@Override\n+\t\t\tpublic LightweightTypeReference doVisitParameterizedTypeReference(JvmParameterizedTypeReference reference) {\n+\t\t\t\tLightweightTypeReference result = super.doVisitParameterizedTypeReference(reference);\n+\t\t\t\tif (result.isFunctionType()) {\n+\t\t\t\t\treturn result.tryConvertToFunctionTypeReference(false);\n+\t\t\t\t}\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, JvmFeature feature, boolean withParents,\n+\t\t\tint insignificantParameters, String shortName, LightweightTypeReferenceFactory converter) {\n+\t\tStringBuilder labelBuilder = new StringBuilder(shortName);\n+\t\tStringBuilder descriptionBuilder = new StringBuilder();\n+\t\tif (feature instanceof JvmOperation) {\n+\t\t\tif (withParents) {\n+\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t}\n+\t\t\tJvmTypeReference returnType = ((JvmOperation) feature).getReturnType();\n+\t\t\tif (returnType != null && returnType.getSimpleName() != null) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tlabelBuilder.append(converter.toLightweightReference(returnType).getHumanReadableName());\n+\t\t\t}\n+\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\tconverter.toPlainTypeReference(((JvmOperation) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\tif (!withParents) {\n+\t\t\t\tdescriptionBuilder.append(\".\");\n+\t\t\t\tdescriptionBuilder.append(((JvmOperation) feature).getSimpleName());\n+\t\t\t\tdescriptionBuilder.append(\"()\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (feature instanceof JvmField) {\n+\t\t\t\tlabelBuilder.append(\" : \");\n+\t\t\t\tif ((((JvmField) feature).getType() != null)) {\n+\t\t\t\t\tString fieldType = converter.toLightweightReference(((JvmField) feature).getType())\n+\t\t\t\t\t\t\t.getHumanReadableName();\n+\t\t\t\t\tif (fieldType != null) {\n+\t\t\t\t\t\tlabelBuilder.append(fieldType);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tdescriptionBuilder.append(\n+\t\t\t\t\t\tconverter.toPlainTypeReference(((JvmField) feature).getDeclaringType()).getHumanReadableName());\n+\t\t\t} else if (feature instanceof JvmConstructor) {\n+\t\t\t\tif (withParents) {\n+\t\t\t\t\tlabelBuilder.append(\"(\");\n+\t\t\t\t\tappendParameters(labelBuilder, ((JvmExecutable) feature), insignificantParameters, converter);\n+\t\t\t\t\tlabelBuilder.append(\")\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tentry.setLabel(labelBuilder.toString());\n+\t\tentry.setDescription(descriptionBuilder.toString());\n+\t}\n+\n+\tprotected void addNameAndDescription(ContentAssistEntry entry, EObject element, String qualifiedNameAsString,\n+\t\t\tString shortName) {\n+\t\tQualifiedName qualifiedName = getQualifiedNameConverter().toQualifiedName(qualifiedNameAsString);\n+\t\tif (qualifiedName.getSegmentCount() > 1) {\n+\t\t\tentry.setLabel(qualifiedName.getLastSegment());\n+\t\t\tentry.setDescription(qualifiedNameAsString);\n+\t\t} else {\n+\t\t\tentry.setLabel(qualifiedNameAsString);\n+\t\t}\n+\t}\n+\n+\tprotected void appendParameters(StringBuilder result, JvmExecutable executable, int insignificantParameters,\n+\t\t\tLightweightTypeReferenceFactory ownedConverter) {\n+\t\tEList<JvmFormalParameter> declaredParameters = executable.getParameters();\n+\t\tList<JvmFormalParameter> relevantParameters = declaredParameters\n+\t\t\t\t.subList(Math.min(insignificantParameters, declaredParameters.size()), declaredParameters.size());\n+\t\tfor (int i = 0; (i < relevantParameters.size()); i++) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAzOTg4NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430039885", "bodyText": "This does nothing in java :(", "author": "tivervac", "createdAt": "2020-05-25T18:20:30Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/JavaSource.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class JavaSource {\n+\tprivate String fileName;\n+\n+\tprivate String code;\n+\n+\tpublic JavaSource(String fileName, String code) {\n+\t\tthis.fileName = fileName;\n+\t\tthis.code = code;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tfinal int prime = 31;\n+\t\tint result = 1;\n+\t\tresult = prime * result + ((code == null) ? 0 : code.hashCode());\n+\t\tresult = prime * result + ((fileName == null) ? 0 : fileName.hashCode());\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tJavaSource other = (JavaSource) obj;\n+\t\tif (code == null) {\n+\t\t\tif (other.code != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!code.equals(other.code))\n+\t\t\treturn false;\n+\t\tif (fileName == null) {\n+\t\t\tif (other.fileName != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!fileName.equals(other.fileName))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Pure", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA0MDE4Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430040182", "bodyText": "s/5/\".java\".length/", "author": "tivervac", "createdAt": "2020-05-25T18:21:55Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/RegisteringFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.generator.InMemoryFileSystemAccess;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.7\n+ */\n+public class RegisteringFileSystemAccess extends InMemoryFileSystemAccess {\n+\t/**\n+\t * @noreference This class is not intended to be referenced by clients.\n+\t */\n+\tpublic static class GeneratedFile {\n+\t\tprivate String path;\n+\n+\t\tprivate String javaClassName;\n+\n+\t\tprivate CharSequence contents;\n+\n+\t\tpublic GeneratedFile(String path, String javaClassName, CharSequence contents) {\n+\t\t\tthis.path = path;\n+\t\t\tthis.javaClassName = javaClassName;\n+\t\t\tthis.contents = contents;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((contents == null) ? 0 : contents.hashCode());\n+\t\t\tresult = prime * result + ((javaClassName == null) ? 0 : javaClassName.hashCode());\n+\t\t\tresult = prime * result + ((path == null) ? 0 : path.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tGeneratedFile other = (GeneratedFile) obj;\n+\t\t\tif (contents == null) {\n+\t\t\t\tif (other.contents != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!contents.equals(other.contents))\n+\t\t\t\treturn false;\n+\t\t\tif (javaClassName == null) {\n+\t\t\t\tif (other.javaClassName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!javaClassName.equals(other.javaClassName))\n+\t\t\t\treturn false;\n+\t\t\tif (path == null) {\n+\t\t\t\tif (other.path != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!path.equals(other.path))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"path\", path);\n+\t\t\tb.add(\"javaClassName\", javaClassName);\n+\t\t\tb.add(\"contents\", contents);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getPath() {\n+\t\t\treturn path;\n+\t\t}\n+\n+\t\tpublic String getJavaClassName() {\n+\t\t\treturn javaClassName;\n+\t\t}\n+\n+\t\tpublic CharSequence getContents() {\n+\t\t\treturn contents;\n+\t\t}\n+\t}\n+\n+\tprivate Set<RegisteringFileSystemAccess.GeneratedFile> generatedFiles = new HashSet<>();\n+\n+\tprivate String projectName;\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputConfigurationName, CharSequence contents) {\n+\t\tsuper.generateFile(fileName, outputConfigurationName, contents);\n+\t\tString path = getPath(fileName, outputConfigurationName);\n+\t\tString javaName = null;\n+\t\tif (fileName.endsWith(\".java\")) {\n+\t\t\tjavaName = fileName.substring(0, fileName.length() - 5).replace('/', '.');", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA0MDIzMA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430040230", "bodyText": "No need for FQN", "author": "tivervac", "createdAt": "2020-05-25T18:22:08Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/RegisteringFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.generator.InMemoryFileSystemAccess;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.7\n+ */\n+public class RegisteringFileSystemAccess extends InMemoryFileSystemAccess {\n+\t/**\n+\t * @noreference This class is not intended to be referenced by clients.\n+\t */\n+\tpublic static class GeneratedFile {\n+\t\tprivate String path;\n+\n+\t\tprivate String javaClassName;\n+\n+\t\tprivate CharSequence contents;\n+\n+\t\tpublic GeneratedFile(String path, String javaClassName, CharSequence contents) {\n+\t\t\tthis.path = path;\n+\t\t\tthis.javaClassName = javaClassName;\n+\t\t\tthis.contents = contents;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((contents == null) ? 0 : contents.hashCode());\n+\t\t\tresult = prime * result + ((javaClassName == null) ? 0 : javaClassName.hashCode());\n+\t\t\tresult = prime * result + ((path == null) ? 0 : path.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tGeneratedFile other = (GeneratedFile) obj;\n+\t\t\tif (contents == null) {\n+\t\t\t\tif (other.contents != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!contents.equals(other.contents))\n+\t\t\t\treturn false;\n+\t\t\tif (javaClassName == null) {\n+\t\t\t\tif (other.javaClassName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!javaClassName.equals(other.javaClassName))\n+\t\t\t\treturn false;\n+\t\t\tif (path == null) {\n+\t\t\t\tif (other.path != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!path.equals(other.path))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"path\", path);\n+\t\t\tb.add(\"javaClassName\", javaClassName);\n+\t\t\tb.add(\"contents\", contents);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getPath() {\n+\t\t\treturn path;\n+\t\t}\n+\n+\t\tpublic String getJavaClassName() {\n+\t\t\treturn javaClassName;\n+\t\t}\n+\n+\t\tpublic CharSequence getContents() {\n+\t\t\treturn contents;\n+\t\t}\n+\t}\n+\n+\tprivate Set<RegisteringFileSystemAccess.GeneratedFile> generatedFiles = new HashSet<>();\n+\n+\tprivate String projectName;\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputConfigurationName, CharSequence contents) {\n+\t\tsuper.generateFile(fileName, outputConfigurationName, contents);\n+\t\tString path = getPath(fileName, outputConfigurationName);\n+\t\tString javaName = null;\n+\t\tif (fileName.endsWith(\".java\")) {\n+\t\t\tjavaName = fileName.substring(0, fileName.length() - 5).replace('/', '.');\n+\t\t}\n+\t\tgeneratedFiles.add(new RegisteringFileSystemAccess.GeneratedFile(path, javaName, contents));\n+\t}\n+\n+\tprotected String getPath(String fileName, String outputConfigurationName) {\n+\t\tString path = getPathes().get(outputConfigurationName);\n+\t\treturn \"/\" + projectName + \"/\" + path + \"/\" + fileName;\n+\t}\n+\n+\tpublic Set<RegisteringFileSystemAccess.GeneratedFile> getGeneratedFiles() {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA0MDc0MA==", "url": "https://github.com/eclipse/xtext-extras/pull/612#discussion_r430040740", "bodyText": "Make the casted var a local var", "author": "tivervac", "createdAt": "2020-05-25T18:24:26Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/typesystem/Oven.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2013, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing.typesystem;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.eclipse.emf.common.util.TreeIterator;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.common.types.JvmFormalParameter;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.testing.util.ParseHelper;\n+import org.eclipse.xtext.xbase.XAbstractFeatureCall;\n+import org.eclipse.xtext.xbase.XClosure;\n+import org.eclipse.xtext.xbase.XExpression;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.util.ReflectExtensions;\n+import org.eclipse.xtext.xbase.typesystem.IBatchTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.internal.CompoundReentrantTypeResolver;\n+import org.eclipse.xtext.xbase.typesystem.internal.RootResolvedTypes;\n+import org.eclipse.xtext.xbase.typesystem.internal.TypeData;\n+import org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\n+import org.junit.Assert;\n+import org.junit.ComparisonFailure;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Utility to check a given expression for exceptions and integrity after it was\n+ * processed by the {@link IBatchTypeResolver}\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+@Beta\n+@Singleton\n+public class Oven extends Assert {\n+\t@Inject\n+\tprivate IBatchTypeResolver typeResolver;\n+\n+\t@Inject\n+\tprivate ReflectExtensions reflectExtensions;\n+\n+\t@Inject\n+\tprivate ParseHelper<EObject> parseHelper;\n+\n+\tpublic void fireproof(CharSequence input) throws Exception {\n+\t\tfireproof(input.toString());\n+\t}\n+\n+\tpublic void fireproof(String input) throws Exception {\n+\t\ttry {\n+\t\t\tEObject file = parseHelper.parse(input);\n+\t\t\tIResolvedTypes resolvedTypes = typeResolver.resolveTypes(file);\n+\t\t\tAssert.assertNotNull(resolvedTypes);\n+\t\t\tif (file != null) {\n+\t\t\t\tTreeIterator<EObject> allContents = file.eAllContents();\n+\t\t\t\twhile (allContents.hasNext()) {\n+\t\t\t\t\tEObject content = allContents.next();\n+\t\t\t\t\tif (content instanceof XAbstractFeatureCall) {\n+\t\t\t\t\t\tassertExpressionTypeIsResolved(((XExpression) content), resolvedTypes);\n+\t\t\t\t\t\tif (((XAbstractFeatureCall) content).getImplicitReceiver() != null) {", "originalCommit": "45a9263e3eb4ad89d1a8c218609ed55562f3fcb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "86d309d9c126511cfc26191fe27b95813f8f6ac0", "url": "https://github.com/eclipse/xtext-extras/commit/86d309d9c126511cfc26191fe27b95813f8f6ac0", "message": "[eclipse/xtext#1777] ported old gen: xtend 2 java + parts of xbase\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-05-25T20:04:52Z", "type": "commit"}, {"oid": "86d309d9c126511cfc26191fe27b95813f8f6ac0", "url": "https://github.com/eclipse/xtext-extras/commit/86d309d9c126511cfc26191fe27b95813f8f6ac0", "message": "[eclipse/xtext#1777] ported old gen: xtend 2 java + parts of xbase\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-05-25T20:04:52Z", "type": "forcePushed"}]}