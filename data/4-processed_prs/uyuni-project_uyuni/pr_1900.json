{"pr_number": 1900, "pr_title": "Remove oracle", "pr_createdAt": "2020-02-10T16:54:25Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/1900", "timeline": [{"oid": "acc1362961ec17bdda9829d2be719cad0585b6a1", "url": "https://github.com/uyuni-project/uyuni/commit/acc1362961ec17bdda9829d2be719cad0585b6a1", "message": "Remove Oracle-only MessageQueueEventListener", "committedDate": "2020-02-11T10:11:48Z", "type": "forcePushed"}, {"oid": "48b6d8717a02911f60db41a6f254dd9c10bcf61f", "url": "https://github.com/uyuni-project/uyuni/commit/48b6d8717a02911f60db41a6f254dd9c10bcf61f", "message": "Remove Oracle-only MessageQueueEventListener", "committedDate": "2020-02-11T12:26:50Z", "type": "forcePushed"}, {"oid": "12e085cf42bce2fb24c2a47932d23f8c3e15309e", "url": "https://github.com/uyuni-project/uyuni/commit/12e085cf42bce2fb24c2a47932d23f8c3e15309e", "message": "comvert all sqlsyntax to postgres format for all versions > 1.2 which support postregs", "committedDate": "2020-02-12T09:15:12Z", "type": "forcePushed"}, {"oid": "b9ea7a9d896b0d43d36efc19df60553ea1fcdc2e", "url": "https://github.com/uyuni-project/uyuni/commit/b9ea7a9d896b0d43d36efc19df60553ea1fcdc2e", "message": "update changelog", "committedDate": "2020-02-14T10:13:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2NTkzNA==", "url": "https://github.com/uyuni-project/uyuni/pull/1900#discussion_r380765934", "bodyText": "Some comments like this now look a bit funny :-)\nNot sure if it's worth to fix them though.", "author": "moio", "createdAt": "2020-02-18T15:57:54Z", "path": "schema/spacewalk/upgrade/spacewalk-schema-1.3-to-spacewalk-schema-1.4/022-rhn_entitlements.sql", "diffHunk": "@@ -0,0 +1,1750 @@\n+\n+-- Note: this file is not a full equivalent of the Oracle sources.\n+-- Neither the flex stuff nor the update_family_countsYN was fully migrated.\n+-- Migrated functions or code paths:\n+--\n+-- can_entitle_server\n+-- entitle_server\n+-- code path of simple rhn-satellite-activate\n+--\n+--\n+-- Copyright (c) 2008--2011 Red Hat, Inc.\n+--\n+-- This software is licensed to you under the GNU General Public License,\n+-- version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+-- implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+-- FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+-- along with this software; if not, see\n+-- http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+--\n+-- Red Hat trademarks are not licensed under GPLv2. No permission is\n+-- granted to use or replicate Red Hat trademarks that are incorporated\n+-- in this software or its documentation.\n+--\n+\n+-- create schema rhn_entitlements;\n+\n+-- setup search_path so that these functions are created in appropriate schema.\n+update pg_settings set setting = 'rhn_entitlements,' || setting where name = 'search_path';\n+\n+   create or replace function find_compatible_sg (\n+      server_id_in in numeric,\n+      type_label_in in varchar\n+   )\n+   returns numeric\n+as $$\n+    declare\n+      servergroups cursor for\n+         select sg.id\n+           from rhnServerGroupType             sgt,\n+                rhnServerGroup                 sg,\n+                rhnServer                     s,\n+                rhnServerServerGroupArchCompat ssgac\n+          where s.id = server_id_in\n+            and s.org_id = sg.org_id\n+            and sgt.label = type_label_in\n+            and sg.group_type = sgt.id\n+            and ssgac.server_group_type = sgt.id\n+            and ssgac.server_arch_id = s.server_arch_id\n+            and not exists (\n+                     select 1\n+                      from rhnServerGroupMembers sgm\n+                     where sgm.server_group_id = sg.id\n+                       and sgm.server_id = s.id);\n+\n+\n+   begin\n+      for servergroup in servergroups loop\n+         return servergroup.id;\n+      end loop;\n+\n+      --no servergroup found\n+      return NULL;\n+   end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: remove_org_entitlements\n+    --\n+    -- Removes both system entitlements and channel subscriptions\n+    -- that are currently assigned to an org and re-assigns to the\n+    -- master org (org_id = 1).\n+    --\n+    -- When we call this we expect everything to already be unentitled\n+    -- which shoul be handled by delete_org.\n+    --\n+    -- Called by: delete_org\n+    -- *******************************************************************\n+    create or replace function remove_org_entitlements (\n+        org_id_in numeric\n+    ) returns void\n+as $$\n+    declare\n+        system_ents cursor for\n+        select sg.id, sg.max_members, sg.group_type\n+        from rhnServerGroup sg\n+        where group_type is not null\n+          and org_id = org_id_in;\n+\n+        channel_subs cursor for\n+        select pcf.channel_family_id, pcf.max_members\n+        from rhnChannelFamily cf,\n+             rhnPrivateChannelFamily pcf\n+        where pcf.org_id = org_id_in\n+          and pcf.channel_family_id = cf.id\n+          and cf.org_id is null;\n+\n+    begin\n+\n+        for system_ent in system_ents loop\n+            update rhnServerGroup\n+            set max_members = max_members + system_ent.max_members\n+            where org_id = 1\n+              and group_type = system_ent.group_type;\n+        end loop;\n+\n+        update rhnServerGroup\n+        set max_members = 0\n+        where org_id = org_id_in;\n+\n+        for channel_sub in channel_subs loop\n+            update rhnPrivateChannelFamily\n+            set max_members = max_members + channel_sub.max_members\n+            where org_id = 1\n+              and channel_family_id = channel_sub.channel_family_id;\n+        end loop;\n+\n+        update rhnPrivateChannelFamily\n+        set max_members = 0\n+        where org_id = org_id_in;\n+\n+    end$$\n+language plpgsql;\n+\n+    create or replace function entitlement_grants_service (\n+        entitlement_in in varchar,\n+        service_level_in in varchar\n+    ) returns numeric\n+as $$\n+    begin\n+        if service_level_in = 'provisioning' then\n+            if entitlement_in = 'provisioning_entitled' then\n+                return 1;\n+            else\n+                return 0;\n+            end if;\n+        elsif service_level_in = 'management' then\n+            if entitlement_in = 'enterprise_entitled' then\n+                return 1;\n+            else\n+                return 0;\n+            end if;\n+        elsif service_level_in = 'monitoring' then\n+            if entitlement_in = 'monitoring_entitled' then\n+                return 1;\n+            end if;\n+        elsif service_level_in = 'updates' then\n+            return 1;\n+        else\n+            return 0;\n+        end if;\n+    end$$\n+language plpgsql;\n+\n+    create or replace function lookup_entitlement_group (\n+        org_id_in in numeric,\n+        type_label_in in varchar default 'sw_mgr_entitled'\n+    ) returns numeric\n+as $$\n+    declare\n+        server_groups cursor for\n+            select  sg.id               server_group_id\n+            from    rhnServerGroup      sg,\n+                    rhnServerGroupType  sgt\n+            where   sgt.label = type_label_in\n+                and sgt.id = sg.group_type\n+                and sg.org_id = org_id_in;\n+    begin\n+        for sg in server_groups loop\n+            return sg.server_group_id;\n+        end loop;\n+        return rhn_entitlements.create_entitlement_group(\n+                org_id_in,\n+                type_label_in\n+            );\n+    end$$\n+language plpgsql;\n+\n+    create or replace function create_entitlement_group (\n+        org_id_in in numeric,\n+        type_label_in in varchar default 'sw_mgr_entitled'\n+    ) returns numeric\n+as $$\n+    declare\n+        sg_id_val numeric;\n+    begin\n+        select  nextval('rhn_server_group_id_seq')\n+        into    sg_id_val;\n+\n+        insert into rhnServerGroup (\n+                id, name, description, max_members, current_members,\n+                group_type, org_id\n+            ) (\n+                select  sg_id_val, sgt.label, sgt.label,\n+                        0, 0, sgt.id, org_id_in\n+                from    rhnServerGroupType sgt\n+                where   sgt.label = type_label_in\n+            );\n+\n+        return sg_id_val;\n+    end$$\n+language plpgsql;\n+\n+   create or replace function can_entitle_server (\n+      server_id_in   in numeric,\n+      type_label_in  in varchar\n+   )\n+   returns numeric\n+as $$\n+    declare\n+      addon_servergroups cursor (base_label_in varchar,\n+                                 addon_label_in varchar) for\n+         select\n+            addon_id\n+         from\n+            rhnSGTypeBaseAddonCompat\n+         where base_id = lookup_sg_type (base_label_in)\n+           and addon_id = lookup_sg_type (addon_label_in);\n+\n+      previous_ent        varchar[];\n+      is_base_in          char   := 'N';\n+      is_base_current     char   := 'N';\n+      i                   numeric := 0;\n+      sgid                numeric := 0;\n+\n+   begin\n+\n+      previous_ent := rhn_entitlements.get_server_entitlement(server_id_in);\n+\n+      select distinct is_base\n+      into is_base_in\n+      from rhnServerGroupType\n+      where label = type_label_in;\n+\n+      if array_upper(previous_ent, 1) is null or array_upper(previous_ent, 1) = 0 then\n+         if is_base_in = 'Y' then\n+            sgid := rhn_entitlements.find_compatible_sg (server_id_in, type_label_in);\n+            if sgid is not null then\n+              -- rhn_server.insert_into_servergroup (server_id_in, sgid);\n+              return 1;\n+            else\n+              -- rhn_exception.raise_exception ('invalid_base_entitlement');\n+              return 0;\n+            end if;\n+         else\n+            -- rhn_exception.raise_exception ('invalid_base_entitlement');\n+            return 0;\n+         end if;\n+\n+      -- there are previous ents, first make sure we're not trying to entitle a base ent\n+      elsif is_base_in = 'Y' then\n+         -- rhn_exception.raise_exception ('invalid_addon_entitlement');\n+         return 0;\n+\n+      -- it must be an addon, so proceed with the entitlement\n+      else\n+\n+         -- find the servers base ent\n+         is_base_current := 'N';\n+         i := 0;\n+         while is_base_current = 'N' and i < array_upper(previous_ent, 1)\n+         loop\n+            i := i + 1;\n+            select is_base\n+            into is_base_current\n+            from rhnServerGroupType\n+            where label = previous_ent[i];\n+         end loop;\n+\n+         -- never found a base ent, that would be strange\n+         if is_base_current  = 'N' then\n+            -- rhn_exception.raise_exception ('invalid_base_entitlement');\n+            return 0;\n+         end if;\n+\n+         -- this for loop verifies the validity of the addon path\n+         for addon_servergroup in addon_servergroups  (previous_ent[i], type_label_in) loop\n+            -- find an appropriate sgid for the addon and entitle the server\n+            sgid := rhn_entitlements.find_compatible_sg (server_id_in, type_label_in);\n+            if sgid is not null then\n+               -- rhn_server.insert_into_servergroup (server_id_in, sgid);\n+               return 1;\n+            else\n+               -- rhn_exception.raise_exception ('invalid_addon_entitlement');\n+               return 0;\n+            end if;\n+         end loop;\n+\n+      end if;\n+\n+      return 0;\n+\n+   end$$\n+language plpgsql;\n+\n+   create or replace function can_switch_base (\n+      server_id_in   in    integer,\n+      type_label_in  in    varchar\n+   )\n+   returns numeric\n+as $$\n+   declare\n+      type_label_in_is_base   char(1);\n+      sgid                    numeric;\n+\n+   begin\n+\n+       select is_base into type_label_in_is_base\n+       from rhnServerGroupType\n+       where label = type_label_in;\n+\n+       if not found then\n+          perform rhn_exception.raise_exception ( 'invalid_entitlement' );\n+       end if;\n+\n+      if type_label_in_is_base = 'N' then\n+         perform rhn_exception.raise_exception ( 'invalid_entitlement' );\n+      else\n+         sgid := rhn_entitlements.find_compatible_sg ( server_id_in,\n+                                                       type_label_in );\n+         if sgid is not null then\n+           return 1;\n+         else\n+           return 0;\n+         end if;\n+      end if;\n+\n+   end$$\n+language plpgsql;\n+\n+    create or replace function entitle_server (\n+        server_id_in in numeric,\n+        type_label_in in varchar default 'sw_mgr_entitled'\n+    ) returns void\n+as $$\n+    declare\n+      sgid  numeric := 0;\n+      is_virt numeric := 0;\n+\n+    begin\n+\n+      select 1 into is_virt\n+        from rhnServerEntitlementView\n+        where server_id = server_id_in\n+          and label in ('virtualization_host', 'virtualization_host_platform');\n+\n+      if not found then\n+          is_virt := 0;\n+      end if;\n+\n+      if is_virt = 0 and (type_label_in = 'virtualization_host' or\n+                          type_label_in = 'virtualization_host_platform') then\n+\n+        is_virt := 1;\n+      end if;\n+\n+      if rhn_entitlements.can_entitle_server(server_id_in,\n+                                             type_label_in) = 1 then\n+         sgid := rhn_entitlements.find_compatible_sg (server_id_in,\n+                                                      type_label_in);\n+         if sgid is not null then\n+            insert into rhnServerHistory ( id, server_id, summary, details )\n+            values ( nextval('rhn_event_id_seq'), server_id_in,\n+                     'added system entitlement ',\n+                      case type_label_in\n+                       when 'enterprise_entitled' then 'Management'\n+                       when 'sw_mgr_entitled' then 'Update'\n+                       when 'provisioning_entitled' then 'Provisioning'\n+                       when 'monitoring_entitled' then 'Monitoring'\n+                       when 'virtualization_host' then 'Virtualization'\n+                       when 'virtualization_host_platform' then\n+                            'Virtualization Platform' end  );\n+\n+            perform rhn_server.insert_into_servergroup (server_id_in, sgid);\n+\n+            if is_virt = 1 then\n+              perform rhn_entitlements.repoll_virt_guest_entitlements(server_id_in);\n+            end if;\n+\n+         else\n+            perform rhn_exception.raise_exception ('no_available_server_group');\n+         end if;\n+      else\n+         perform rhn_exception.raise_exception ('invalid_entitlement');\n+      end if;\n+   end$$\n+language plpgsql;\n+\n+    create or replace function remove_server_entitlement (\n+        server_id_in in numeric,\n+        type_label_in in varchar default 'sw_mgr_entitled',\n+        repoll_virt_guests in numeric default 1\n+    ) returns void\n+as $$\n+    declare\n+      group_id numeric;\n+      type_is_base char;\n+      is_virt numeric := 0;\n+    begin\n+      -- would be nice if there were a virt attribute of entitlement types, not have to specify 2 different ones...\n+        select 1 into is_virt\n+          from rhnServerEntitlementView\n+          where server_id = server_id_in\n+            and label in ('virtualization_host', 'virtualization_host_platform');\n+        if not found then\n+            is_virt := 0;\n+        end if;\n+\n+        select  sg.id, sgt.is_base\n+        into group_id, type_is_base\n+        from    rhnServerGroupType sgt,\n+            rhnServerGroup sg,\n+                rhnServerGroupMembers sgm,\n+                rhnServer s\n+        where   s.id = server_id_in\n+            and s.id = sgm.server_id\n+            and sgm.server_group_id = sg.id\n+            and sg.org_id = s.org_id\n+            and sgt.label = type_label_in\n+            and sgt.id = sg.group_type;\n+\n+        if not found then\n+          perform rhn_exception.raise_exception('invalid_server_group_member');\n+        end if;\n+\n+      if ( type_is_base = 'Y' ) then\n+         -- unentitle_server should handle everything, don't really need to do anything else special here\n+         perform rhn_entitlements.unentitle_server ( server_id_in );\n+      else\n+\n+         insert into rhnServerHistory ( id, server_id, summary, details )\n+         values ( nextval('rhn_event_id_seq'), server_id_in,\n+                  'removed system entitlement ',\n+                   case type_label_in\n+                    when 'enterprise_entitled' then 'Management'\n+                    when 'sw_mgr_entitled' then 'Update'\n+                    when 'provisioning_entitled' then 'Provisioning'\n+                    when 'monitoring_entitled' then 'Monitoring'\n+                    when 'virtualization_host' then 'Virtualization'\n+                    when 'virtualization_host_platform' then\n+                         'Virtualization Platforrm' end  );\n+\n+         perform rhn_server.delete_from_servergroup(server_id_in, group_id);\n+\n+         -- special case: clean up related monitoring data\n+         if type_label_in = 'monitoring_entitled' then\n+           DELETE\n+             FROM state_change\n+            WHERE o_id IN (SELECT probe_id::varchar\n+                             FROM rhn_check_probe\n+                            WHERE host_id = server_id_in);\n+           DELETE\n+             FROM time_series\n+            WHERE substring(o_id FROM position('-' IN o_id) + 1\n+                            FOR position('-' IN substring(o_id FROM position('-' IN o_id) + 1)) - 1)\n+              IN (SELECT probe_id::text\n+                    FROM rhn_check_probe\n+                   WHERE host_id = server_id_in);\n+           DELETE\n+             FROM rhn_probe\n+            WHERE recid IN (SELECT probe_id\n+                              FROM rhn_check_probe\n+                             WHERE host_id = server_id_in);\n+         end if;\n+\n+         if is_virt = 1 and repoll_virt_guests = 1 then\n+           perform rhn_entitlements.repoll_virt_guest_entitlements(server_id_in);\n+         end if;\n+      end if;\n+\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unentitle_server (\n+        server_id_in in numeric\n+    ) returns void\n+as $$\n+    declare\n+      servergroups cursor for\n+         select distinct sgt.label, sg.id server_group_id\n+         from  rhnServerGroupType sgt,\n+               rhnServerGroup sg,\n+               rhnServer s,\n+               rhnServerGroupMembers sgm\n+         where s.id = server_id_in\n+            and s.org_id = sg.org_id\n+            and sg.group_type = sgt.id\n+            and sgm.server_group_id = sg.id\n+            and sgm.server_id = s.id;\n+\n+     is_virt numeric := 0;\n+\n+   begin\n+\n+      select 1 into is_virt\n+        from rhnServerEntitlementView\n+        where server_id = server_id_in\n+         and label in ('virtualization_host', 'virtualization_host_platform');\n+\n+      if not found then\n+          is_virt := 0;\n+      end if;\n+\n+      for servergroup in servergroups loop\n+\n+         insert into rhnServerHistory ( id, server_id, summary, details )\n+         values ( nextval('rhn_event_id_seq'), server_id_in,\n+                  'removed system entitlement ',\n+                   case servergroup.label\n+                    when 'enterprise_entitled' then 'Management'\n+                    when 'sw_mgr_entitled' then 'Update'\n+                    when 'provisioning_entitled' then 'Provisioning'\n+                    when 'monitoring_entitled' then 'Monitoring'\n+                    when 'virtualization_host' then 'Virtualization'\n+                    when 'virtualization_host_platform' then\n+                         'Virtualization Platform' end  );\n+\n+         perform rhn_server.delete_from_servergroup(server_id_in,\n+                                            servergroup.server_group_id );\n+      end loop;\n+\n+      if is_virt = 1 then\n+        perform rhn_entitlements.repoll_virt_guest_entitlements(server_id_in);\n+      end if;\n+\n+   end$$\n+language plpgsql;\n+\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: repoll_virt_guest_entitlements\n+    --\n+    --   Whenever we add/remove a virtualization_host* entitlement from\n+    --   a host, we can call this procedure to update what type of slots\n+    --   the guests are consuming.\n+    --\n+    --   If you're removing the entitlement, it's\n+    --   possible the guests will become unentitled if you don't have enough\n+    --   physical slots to cover them.\n+    --\n+    --   If you're adding the entitlement, you end up freeing up physical\n+    --   slots for other systems.\n+    --\n+    -- *******************************************************************\n+    create or replace function repoll_virt_guest_entitlements(\n+        server_id_in in numeric\n+    ) returns void\n+as $$\n+    declare\n+        -- All channel families associated with the guests of server_id_in\n+        families cursor for\n+            select distinct cfs.channel_family_id\n+            from\n+                rhnChannelFamilyServers cfs,\n+                rhnVirtualInstance vi\n+            where\n+                vi.host_system_id = server_id_in\n+                and vi.virtual_system_id = cfs.server_id;\n+\n+        -- All of server group types associated with the guests of\n+        -- server_id_in\n+        group_types cursor for\n+            select distinct sg.group_type, sgt.label\n+            from\n+                rhnServerGroupType sgt,\n+                rhnServerGroup sg,\n+                rhnServerGroupMembers sgm,\n+                rhnVirtualInstance vi\n+            where\n+                vi.host_system_id = server_id_in\n+                and vi.virtual_system_id = sgm.server_id\n+                and sgm.server_group_id = sg.id\n+                and sg.group_type = sgt.id;\n+\n+        -- Virtual servers from a certain family belonging to a specific\n+        -- host that are consuming physical channel slots over the limit.\n+        virt_servers_cfam cursor(family_id_in numeric, quantity_in numeric) for\n+                select vi.virtual_system_id\n+                from\n+                    rhnChannelFamilyMembers cfm,\n+                    rhnServerChannel sc,\n+                    rhnVirtualInstance vi\n+                where\n+                    vi.host_system_id = server_id_in\n+                    and vi.virtual_system_id = sc.server_id\n+                    and sc.channel_id = cfm.channel_id\n+                    and cfm.channel_family_id = family_id_in\n+                order by sc.modified desc\n+                limit quantity_in;\n+\n+        -- Virtual servers from a certain family belonging to a specific\n+        -- host that are consuming physical system slots over the limit.\n+        virt_servers_sgt cursor(group_type_in numeric, quantity_in numeric) for\n+                select vi.virtual_system_id\n+                from\n+                    rhnServerGroup sg,\n+                    rhnServerGroupMembers sgm,\n+                    rhnVirtualInstance vi\n+                where\n+                    vi.host_system_id = server_id_in\n+                    and vi.virtual_system_id = sgm.server_id\n+                    and sgm.server_group_id = sg.id\n+                    and sg.group_type = group_type_in\n+                order by sgm.modified desc\n+                limit quantity_in;\n+\n+        org_id_val numeric;\n+        max_members_val numeric;\n+        current_members_calc numeric;\n+        sg_id numeric;\n+\n+    begin\n+\n+        select org_id\n+        into org_id_val\n+        from rhnServer\n+        where id = server_id_in;\n+\n+        -- deal w/ channel entitlements first ...\n+        for family in families loop\n+            -- get the current (physical) members of the family\n+            current_members_calc :=\n+                rhn_channel.channel_family_current_members(family.channel_family_id,\n+                                                           org_id_val); -- fixed transposed args\n+\n+            -- get the max members of the family\n+            select max_members\n+            into max_members_val\n+            from rhnPrivateChannelFamily\n+            where channel_family_id = family.channel_family_id\n+            and org_id = org_id_val;\n+\n+            if current_members_calc > max_members_val then\n+                -- A virtualization_host* ent must have been removed, so we'll\n+                -- unsubscribe guests from the host first.\n+\n+                -- hm, i don't think max_members - current_members_calc yielding a negative NUMERIC\n+                -- will work w/ rownum, swaping 'em in the body of this if...\n+                for virt_server in virt_servers_cfam(family.channel_family_id,\n+                                current_members_calc - max_members_val) loop\n+\n+                    perform rhn_channel.unsubscribe_server_from_family(\n+                                virt_server.virtual_system_id,\n+                                family.channel_family_id);\n+                end loop;\n+\n+                -- if we're still over the limit, which would be odd,\n+                -- just prune the group to max_members\n+                --\n+                -- er... wouldn't we actually have to refresh the values of\n+                -- current_members_calc and max_members_val to actually ever\n+                -- *skip this??\n+                if current_members_calc > max_members_val then\n+                    -- argh, transposed again?!\n+                    perform rhn_entitlements.set_family_count(org_id_val,\n+                                     family.channel_family_id,\n+                                     max_members_val);\n+                end if;\n+\n+           end if;\n+\n+            -- update current_members for the family.  This will set the value\n+            -- to reflect adding/removing the entitlement.\n+            --\n+            -- what's the difference of doing this vs the unavoidable set_family_count above?\n+            perform rhn_channel.update_family_counts(family.channel_family_id,\n+                                             org_id_val);\n+        end loop;\n+\n+        for a_group_type in group_types loop\n+          -- get the current *physical* members of the system entitlement type for the org...\n+          --\n+          -- unlike channel families, it appears the standard rhnServerGroup.max_members represents\n+          -- *physical* slots, vs physical+virt ... boy that's confusing...\n+\n+          select max_members, id\n+            into max_members_val, sg_id\n+            from rhnServerGroup\n+            where group_type = a_group_type.group_type\n+            and org_id = org_id_val;\n+\n+\n+      select count(sep.server_id) into current_members_calc\n+            from rhnServerEntitlementPhysical sep\n+           where sep.server_group_id = sg_id\n+             and sep.server_group_type_id = a_group_type.group_type;\n+\n+          if current_members_calc > max_members_val then\n+            -- A virtualization_host* ent must have been removed, and we're over the limit, so unsubscribe guests\n+            for virt_server in virt_servers_sgt(a_group_type.group_type,\n+                                                current_members_calc - max_members_val) loop\n+              perform rhn_entitlements.remove_server_entitlement(virt_server.virtual_system_id, a_group_type.label);\n+\n+              -- decrement current_members_calc, we'll use it to reset current_members for the group at the end...\n+              current_members_calc := current_members_calc - 1;\n+            end loop;\n+\n+          end if;\n+\n+          update rhnServerGroup set current_members = current_members_calc\n+           where org_id = org_id_val\n+             and group_type = a_group_type.group_type;\n+\n+          -- I think that's all the house-keeping we have to do...\n+        end loop;\n+\n+    end$$\n+language plpgsql;\n+\n+    create or replace function get_server_entitlement (\n+        server_id_in in numeric\n+    ) returns varchar[]\n+as $$\n+    declare\n+        server_groups cursor for\n+            select  sgt.label\n+            from    rhnServerGroupType      sgt,\n+                    rhnServerGroup          sg,\n+                    rhnServerGroupMembers   sgm\n+            where   1=1\n+                and sgm.server_id = server_id_in\n+                and sg.id = sgm.server_group_id\n+                and sgt.id = sg.group_type\n+                and sgt.label in (\n+                    'sw_mgr_entitled','enterprise_entitled',\n+                    'provisioning_entitled', 'nonlinux_entitled',\n+                    'monitoring_entitled', 'virtualization_host',\n+                                        'virtualization_host_platform'\n+                    );\n+\n+         ent_array varchar[];\n+\n+    begin\n+\n+      ent_array := '{}';\n+\n+      for sg in server_groups loop\n+         ent_array := ent_array || sg.label;\n+      end loop;\n+\n+      return ent_array;\n+\n+    end$$\n+language plpgsql;\n+\n+    -- this desperately needs to be table driven.\n+    create or replace function modify_org_service (\n+        org_id_in in numeric,\n+        service_label_in in varchar,\n+        enable_in in char\n+    ) returns void\n+as $$\n+    declare\n+        roles_to_process varchar[];\n+        roles cursor(role_label_in varchar) for\n+            select  label, id\n+            from    rhnUserGroupType\n+            where   label = role_label_in;\n+        org_roles cursor(role_label_in varchar) for\n+            select  1\n+            from    rhnUserGroup ug,\n+                    rhnUserGroupType ugt\n+            where   ugt.label = role_label_in\n+                and ug.org_id = org_id_in\n+                and ugt.id = ug.group_type;\n+\n+        ents_to_process varchar[];\n+        ents cursor(ent_label_in varchar) for\n+            select  label, id\n+            from    rhnOrgEntitlementType\n+            where   label = ent_label_in;\n+        org_ents cursor(ent_label_in varchar) for\n+            select  1\n+            from    rhnOrgEntitlements oe,\n+                    rhnOrgEntitlementType oet\n+            where   oet.label = ent_label_in\n+                and oe.org_id = org_id_in\n+                and oet.id = oe.entitlement_id;\n+        create_row char(1);\n+    begin\n+        ents_to_process := '{}';\n+        roles_to_process := '{}';\n+        -- a bit kludgy, but only for 3.4 really.  Certainly no\n+        -- worse than the old code...\n+        if service_label_in = 'enterprise' or\n+           service_label_in = 'management' then\n+            ents_to_process := array_append(ents_to_process, 'sw_mgr_enterprise');\n+\n+            roles_to_process := array_append(roles_to_process, 'org_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'system_group_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'activation_key_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'org_applicant');\n+        elsif service_label_in = 'provisioning' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_provisioning');\n+\n+            roles_to_process := array_append(roles_to_process, 'system_group_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'activation_key_admin');\n+\n+            roles_to_process := array_append(roles_to_process, 'config_admin');\n+            -- another nasty special case...\n+            if enable_in = 'Y' then\n+                ents_to_process := array_append(ents_to_process, 'sw_mgr_enterprise');\n+            end if;\n+        elsif service_label_in = 'monitoring' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_monitor');\n+\n+            roles_to_process := array_append(roles_to_process, 'monitoring_admin');\n+        elsif service_label_in = 'virtualization' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_virtualization');\n+\n+            roles_to_process := array_append(roles_to_process, 'config_admin');\n+        elsif service_label_in = 'virtualization_platform' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_virtualization_platform');\n+            roles_to_process := array_append(roles_to_process, 'config_admin');\n+    elsif service_label_in = 'nonlinux' then\n+            ents_to_process := array_append(ents_to_process, 'rhn_nonlinux');\n+            roles_to_process := array_append(roles_to_process, 'config_admin');\n+        end if;\n+\n+        if enable_in = 'Y' then\n+            for i in 1..array_upper(ents_to_process, 1) loop\n+                for ent in ents(ents_to_process[i]) loop\n+                    create_row := 'Y';\n+                    for oe in org_ents(ent.label) loop\n+                        create_row := 'N';\n+                    end loop;\n+                    if create_row = 'Y' then\n+                        insert into rhnOrgEntitlements(org_id, entitlement_id)\n+                            values (org_id_in, ent.id);\n+                    end if;\n+                end loop;\n+            end loop;\n+            for i in 1..array_upper(roles_to_process, 1) loop\n+                for role in roles(roles_to_process[i]) loop\n+                    create_row := 'Y';\n+                    for o_r in org_roles(role.label) loop\n+                        create_row := 'N';\n+                    end loop;\n+                    if create_row = 'Y' then\n+                        insert into rhnUserGroup(\n+                                id, name, description, current_members,\n+                                group_type, org_id\n+                            ) (\n+                                select  nextval('rhn_user_group_id_seq'),\n+                                        ugt.name || 's',\n+                                        ugt.name || 's for Org ' ||\n+                                            o.name || ' ('|| o.id ||')',\n+                                        0, ugt.id, o.id\n+                                from    rhnUserGroupType ugt,\n+                                        web_customer o\n+                                where   o.id = org_id_in\n+                                    and ugt.id = role.id\n+                            );\n+                    end if;\n+                end loop;\n+            end loop;\n+        else\n+            for i in 1..coalesce(array_upper(ents_to_process, 1), 0) loop\n+                for ent in ents(ents_to_process[i]) loop\n+                    delete from rhnOrgEntitlements\n+                     where org_id = org_id_in\n+                       and entitlement_id = ent.id;\n+                end loop;\n+            end loop;\n+        end if;\n+    end$$\n+language plpgsql;\n+\n+    create or replace function set_customer_enterprise (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'enterprise', 'Y');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function set_customer_provisioning (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'provisioning', 'Y');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function set_customer_monitoring (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'monitoring', 'Y');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function set_customer_nonlinux (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'nonlinux', 'Y');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unset_customer_enterprise (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'enterprise', 'N');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unset_customer_provisioning (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'provisioning', 'N');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unset_customer_monitoring (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'monitoring', 'N');\n+    end$$\n+language plpgsql;\n+\n+    create or replace function unset_customer_nonlinux (\n+        customer_id_in in numeric\n+    ) returns void\n+as $$\n+    begin\n+        perform rhn_entitlements.modify_org_service(customer_id_in, 'nonlinux', 'N');\n+    end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: prune_group\n+    -- Unsubscribes servers consuming physical slots that over the org's\n+    --   limit.\n+    -- Called by: set_group_count, repoll_virt_guest_entitlements\n+    -- *******************************************************************\n+    create or replace function prune_group (\n+        group_id_in in numeric,\n+        type_in in char,\n+        quantity_in in numeric,\n+        update_family_countsYN in numeric default 1\n+    ) returns void\n+as $$\n+    declare\n+        ugrecord record;\n+        sgrecord record;\n+      type_is_base char;\n+    begin\n+        if type_in = 'U' then\n+            update      rhnUserGroup\n+                set     max_members = quantity_in\n+                where   id = group_id_in;\n+\n+            for ugrecord in (\n+\t\t    select  user_id, user_group_id, ugt.label\n+\t\t    from    rhnUserGroupType    ugt,\n+\t\t\t    rhnUserGroup        ug,\n+\t\t\t    rhnUserGroupMembers ugm\n+\t\t    where   1=1\n+\t\t\tand ugm.user_group_id = group_id_in\n+\t\t\tand ugm.user_id in (\n+\t\t\t\t    select  user_id\n+\t\t\t\t    from    rhnUserGroupMembers\n+\t\t\t\t    where   user_group_id = group_id_in\n+\t\t\t\t    order by modified asc\n+\t\t\t\t    offset quantity_in\n+\t\t\t\t)\n+\t\t\tand ugm.user_group_id = ug.id\n+\t\t\tand ug.group_type = ugt.id\n+\t    ) loop\n+                perform rhn_user.remove_from_usergroup(ugrecord.user_id, ugrecord.user_group_id);\n+            end loop;\n+        elsif type_in = 'S' then\n+            update      rhnServerGroup\n+                set     max_members = quantity_in\n+                where   id = group_id_in;\n+\n+            for sgrecord in (\n+\t\t   select  server_id, server_group_id, sgt.id as group_type_id, sgt.label\n+\t\t    from    rhnServerGroupType              sgt,\n+\t\t\t\t    rhnServerGroup                  sg,\n+\t\t\t\t    rhnServerGroupMembers   sgm\n+\t\t    where   1=1\n+\t\t\t    and sgm.server_group_id = group_id_in\n+\t\t\t    and sgm.server_id in (\n+\t\t\t\t    select  sep.server_id\n+\t\t\t\t    from\n+\t\t\t\t\trhnServerEntitlementPhysical sep\n+\t\t\t\t    where\n+\t\t\t\t\tsep.server_group_id = group_id_in\n+\t\t\t\t    order by sep.modified asc\n+\t\t\t\t    offset quantity_in\n+\t\t\t\t)\n+\t\t\t    and sgm.server_group_id = sg.id\n+\t\t\t    and sg.group_type = sgt.id\n+\t    ) loop\n+                perform rhn_entitlements.remove_server_entitlement(sgrecord.server_id, sgrecord.label);\n+\n+            select is_base\n+            into type_is_base\n+            from rhnServerGroupType sgt\n+            where sgt.id = sgrecord.group_type_id;\n+\n+            -- if we're removing a base ent, then be sure to\n+            -- remove the server's channel subscriptions.\n+            if ( type_is_base = 'Y' ) then\n+                   perform rhn_channel.clear_subscriptions(sgrecord.server_id, update_family_countsYN);\n+            end if;\n+\n+            end loop;\n+        end if;\n+    end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: assign_system_entitlement\n+    --\n+    -- Moves system entitlements from from_org_id_in to to_org_id_in.\n+    -- Can raise not_enough_entitlements_in_base_org if from_org_id_in\n+    -- does not have enough entitlements to cover the move.\n+    -- Takes care of unentitling systems if necessary by calling\n+    -- set_group_count\n+    -- *******************************************************************\n+    create or replace function assign_system_entitlement(\n+        group_label_in in varchar,\n+        from_org_id_in in numeric,\n+        to_org_id_in in numeric,\n+        quantity_in in numeric\n+    ) returns void\n+as $$\n+    declare\n+        prev_ent_count numeric;\n+    to_org_prev_ent_count numeric;\n+        new_ent_count numeric;\n+    new_quantity numeric;\n+        group_type numeric;\n+    begin\n+\n+            select max_members\n+            into prev_ent_count\n+            from rhnServerGroupType sgt,\n+                 rhnServerGroup sg\n+            where sg.org_id = from_org_id_in\n+              and sg.group_type = sgt.id\n+              and sgt.label = group_label_in;\n+\n+            if not found then\n+                perform rhn_exception.raise_exception(\n+                              'not_enough_entitlements_in_base_org');\n+            end if;\n+\n+            select max_members\n+            into to_org_prev_ent_count\n+            from rhnServerGroupType sgt,\n+                 rhnServerGroup sg\n+            where sg.org_id = to_org_id_in\n+              and sg.group_type = sgt.id\n+              and sgt.label = group_label_in;\n+\n+            if not found then\n+                to_org_prev_ent_count := 0;\n+            end if;\n+\n+            select id\n+            into group_type\n+            from rhnServerGroupType\n+            where label = group_label_in;\n+\n+            if not found then\n+                perform rhn_exception.raise_exception(\n+                              'invalid_server_group');\n+            end if;\n+\n+        new_ent_count := prev_ent_count - quantity_in;\n+\n+        if prev_ent_count > new_ent_count then\n+            new_quantity := to_org_prev_ent_count + quantity_in;\n+        end if;\n+\n+        if new_ent_count < 0 then\n+            perform rhn_exception.raise_exception(\n+                          'not_enough_entitlements_in_base_org');\n+        end if;\n+\n+\n+        perform rhn_entitlements.set_group_count(from_org_id_in,\n+                                         'S',\n+                                         group_type,\n+                                         new_ent_count);\n+\n+        perform rhn_entitlements.set_group_count(to_org_id_in,\n+                                         'S',\n+                                         group_type,\n+                                         new_quantity);\n+\n+        -- Create or delete the entries in rhnOrgEntitlementType\n+        if group_label_in = 'enterprise_entitled' then\n+            if new_quantity > 0 then\n+                perform rhn_entitlements.set_customer_enterprise(to_org_id_in);\n+            else\n+                perform rhn_entitlements.unset_customer_enterprise(to_org_id_in);\n+            end if;\n+        end if;\n+\n+        if group_label_in = 'provisioning_entitled' then\n+            if new_quantity > 0 then\n+                perform rhn_entitlements.set_customer_provisioning(to_org_id_in);\n+            else\n+                perform rhn_entitlements.unset_customer_provisioning(to_org_id_in);\n+            end if;\n+        end if;\n+\n+        if group_label_in = 'monitoring_entitled' then\n+            if new_quantity > 0 then\n+                perform rhn_entitlements.set_customer_monitoring(to_org_id_in);\n+            else\n+                perform rhn_entitlements.unset_customer_monitoring(to_org_id_in);\n+            end if;\n+        end if;\n+\n+    end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: assign_channel_entitlement\n+    --\n+    -- Moves channel entitlements from from_org_id_in to to_org_id_in.\n+    -- Can raise not_enough_entitlements_in_base_org if from_org_id_in\n+    -- does not have enough entitlements to cover the move.\n+    -- Takes care of unentitling systems if necessary by calling\n+    -- set_family_count\n+    -- *******************************************************************\n+    create or replace function assign_channel_entitlement(\n+        channel_family_label_in in varchar,\n+        from_org_id_in in numeric,\n+        to_org_id_in in numeric,\n+        quantity_in in numeric\n+    ) returns void\n+as $$\n+    declare\n+        prev_ent_count numeric;\n+        new_ent_count numeric;\n+    to_org_prev_ent_count numeric;\n+    new_quantity numeric;\n+        cfam_id       numeric;\n+    begin\n+\n+            select max_members\n+            into prev_ent_count\n+            from rhnChannelFamily cf,\n+                 rhnPrivateChannelFamily pcf\n+            where pcf.org_id = from_org_id_in\n+              and pcf.channel_family_id = cf.id\n+              and cf.label = channel_family_label_in;\n+\n+            if not found then\n+                perform rhn_exception.raise_exception(\n+                              'not_enough_entitlements_in_base_org');\n+            end if;\n+\n+            select max_members\n+            into to_org_prev_ent_count\n+            from rhnChannelFamily cf,\n+                 rhnPrivateChannelFamily pcf\n+            where pcf.org_id = to_org_id_in\n+              and pcf.channel_family_id = cf.id\n+              and cf.label = channel_family_label_in;\n+\n+            if not found then\n+                to_org_prev_ent_count := 0;\n+            end if;\n+\n+            select id\n+            into cfam_id\n+            from rhnChannelFamily\n+            where label = channel_family_label_in;\n+\n+            if not found then\n+                perform rhn_exception.raise_exception(\n+                              'invalid_channel_family');\n+            end if;\n+\n+        new_ent_count := prev_ent_count - quantity_in;\n+\n+    if prev_ent_count > new_ent_count then\n+            new_quantity := to_org_prev_ent_count + quantity_in;\n+    end if;\n+\n+\n+        if new_ent_count < 0 then\n+            perform rhn_exception.raise_exception(\n+                          'not_enough_entitlements_in_base_org');\n+        end if;\n+\n+        perform rhn_entitlements.set_family_count(from_org_id_in,\n+                                          cfam_id,\n+                                          new_ent_count);\n+\n+        perform rhn_entitlements.set_family_count(to_org_id_in,\n+                                          cfam_id,\n+                                          new_quantity);\n+\n+    end$$\n+language plpgsql;\n+\n+    -- *******************************************************************\n+    -- PROCEDURE: activate_system_entitlement\n+    --\n+    -- Sets the values in rhnServerGroup for a given rhnServerGroupType.\n+    --\n+    -- Calls: set_group_count to update, prune, or create the group.\n+    -- Called by: the code that activates a satellite cert.\n+    --\n+    -- Raises not_enough_entitlements_in_base_org if all entitlements\n+    -- in the org are used so the free entitlements would not cover\n+    -- the difference when descreasing the NUMERIC of entitlements.", "originalCommit": "b9ea7a9d896b0d43d36efc19df60553ea1fcdc2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2ODEyOA==", "url": "https://github.com/uyuni-project/uyuni/pull/1900#discussion_r381168128", "bodyText": "I fixed the one I could find.", "author": "mcalmer", "createdAt": "2020-02-19T09:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc2NTkzNA=="}], "type": "inlineReview"}, {"oid": "01be1dd75ab246eb0918c2faa07221ff2b87c5bd", "url": "https://github.com/uyuni-project/uyuni/commit/01be1dd75ab246eb0918c2faa07221ff2b87c5bd", "message": "fix comments", "committedDate": "2020-02-19T09:24:09Z", "type": "forcePushed"}, {"oid": "a36e883e5ce84a0ed42a06917f06cee2d8ba74e2", "url": "https://github.com/uyuni-project/uyuni/commit/a36e883e5ce84a0ed42a06917f06cee2d8ba74e2", "message": "convert common/tables to postgresql syntax", "committedDate": "2020-02-19T16:58:37Z", "type": "commit"}, {"oid": "09bab0144f3a7cf3e8e3e0bbbcd38816fad256a9", "url": "https://github.com/uyuni-project/uyuni/commit/09bab0144f3a7cf3e8e3e0bbbcd38816fad256a9", "message": "remove oracle subdir", "committedDate": "2020-02-19T16:58:37Z", "type": "commit"}, {"oid": "f830347f70dc9c94afe637a45003a8046e73d5ce", "url": "https://github.com/uyuni-project/uyuni/commit/f830347f70dc9c94afe637a45003a8046e73d5ce", "message": "remove oracle schema migrations and copy postgresql to global migrations for spacewalk schema", "committedDate": "2020-02-19T16:58:37Z", "type": "commit"}, {"oid": "e6b6fea1946c798a2a8baad4ba3d836b167f18e7", "url": "https://github.com/uyuni-project/uyuni/commit/e6b6fea1946c798a2a8baad4ba3d836b167f18e7", "message": "remove oracle migrations and copy postgresql to global for susemanager schema", "committedDate": "2020-02-19T16:58:37Z", "type": "commit"}, {"oid": "f4ca2be5903e6c195f00247bd89ba58aae184482", "url": "https://github.com/uyuni-project/uyuni/commit/f4ca2be5903e6c195f00247bd89ba58aae184482", "message": "remove empty files", "committedDate": "2020-02-19T16:58:37Z", "type": "commit"}, {"oid": "f5be4fd2a1c4abfa9363785fdd90977eccfe5f80", "url": "https://github.com/uyuni-project/uyuni/commit/f5be4fd2a1c4abfa9363785fdd90977eccfe5f80", "message": "fix not empty files", "committedDate": "2020-02-19T16:58:37Z", "type": "commit"}, {"oid": "6413c1ff717392caf54ccb121ecd460cd3de4f8e", "url": "https://github.com/uyuni-project/uyuni/commit/6413c1ff717392caf54ccb121ecd460cd3de4f8e", "message": "remove \"oracle equivalent\" line", "committedDate": "2020-02-19T16:58:37Z", "type": "commit"}, {"oid": "b33f3cd8c308d98406e3b956520567829fc28cf3", "url": "https://github.com/uyuni-project/uyuni/commit/b33f3cd8c308d98406e3b956520567829fc28cf3", "message": "remove \"oracle equivalent\" and \"retrieved from\" headers", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "3228a46874370a866e99f07995d481faf32f3f6e", "url": "https://github.com/uyuni-project/uyuni/commit/3228a46874370a866e99f07995d481faf32f3f6e", "message": "drop oracle from scripts", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "7a912073fdb03d856af17921b2c341adef9949e9", "url": "https://github.com/uyuni-project/uyuni/commit/7a912073fdb03d856af17921b2c341adef9949e9", "message": "join dblink migrations", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "8ff06173bb59e209b91c31c5c42d28f6dab2e85a", "url": "https://github.com/uyuni-project/uyuni/commit/8ff06173bb59e209b91c31c5c42d28f6dab2e85a", "message": "fix Makefiles", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "6966e8ffefc16f2a585f222e1c8ab97c6cfa867f", "url": "https://github.com/uyuni-project/uyuni/commit/6966e8ffefc16f2a585f222e1c8ab97c6cfa867f", "message": "add DB backend suffix", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "530999ff25811904725575a67e1d684080a89c0f", "url": "https://github.com/uyuni-project/uyuni/commit/530999ff25811904725575a67e1d684080a89c0f", "message": "Remove Oracle-only MessageQueueEventListener", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "9961ebbff7c27ad8ea21c48e62760a958d75eac8", "url": "https://github.com/uyuni-project/uyuni/commit/9961ebbff7c27ad8ea21c48e62760a958d75eac8", "message": "drop oracle from spacewalk-backend", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "088007607a1b8b086f0be684c0f5fa65f4e08094", "url": "https://github.com/uyuni-project/uyuni/commit/088007607a1b8b086f0be684c0f5fa65f4e08094", "message": "remove oracle from test tooling", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "4926f838be04841625ba32a7a28f6a0bf851ad16", "url": "https://github.com/uyuni-project/uyuni/commit/4926f838be04841625ba32a7a28f6a0bf851ad16", "message": "drop oracle from java code", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "bea44be2ef44ef8b9a38ebf54c43af8f3730607f", "url": "https://github.com/uyuni-project/uyuni/commit/bea44be2ef44ef8b9a38ebf54c43af8f3730607f", "message": "remove oracle db backend from supportutils plugin", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "3ad2112a07de6edf5f823a9d8e598f3ab828744a", "url": "https://github.com/uyuni-project/uyuni/commit/3ad2112a07de6edf5f823a9d8e598f3ab828744a", "message": "remove oracle from susmanager tooling\n\n- oracle2postgresql must be executed on a system which still has oracle\n  (3.2 or earlier)\n- no new setups supported anymore - remove the code", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "1d081c185bdb5783f4353246c500347266b10426", "url": "https://github.com/uyuni-project/uyuni/commit/1d081c185bdb5783f4353246c500347266b10426", "message": "more oracle removals from schema package", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "910b64ee37d60a48e0115a7778b3e177d669f44b", "url": "https://github.com/uyuni-project/uyuni/commit/910b64ee37d60a48e0115a7778b3e177d669f44b", "message": "remove oracle DB support from reporting", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "0ef8067996653b7f4efd6743e266dd8014ae3938", "url": "https://github.com/uyuni-project/uyuni/commit/0ef8067996653b7f4efd6743e266dd8014ae3938", "message": "remove oracle subpackage from spacewalk", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "9b476a5ba3aef8d504aa0ef0f52f6595133949e6", "url": "https://github.com/uyuni-project/uyuni/commit/9b476a5ba3aef8d504aa0ef0f52f6595133949e6", "message": "comvert all sqlsyntax to postgres format for all versions > 1.2 which support postregs", "committedDate": "2020-02-19T16:58:38Z", "type": "commit"}, {"oid": "1431c459c1976955af39c718e197ec054cb5c8ad", "url": "https://github.com/uyuni-project/uyuni/commit/1431c459c1976955af39c718e197ec054cb5c8ad", "message": "update changelog", "committedDate": "2020-02-19T16:59:09Z", "type": "commit"}, {"oid": "f6fe60bcefb6d6d8842403cadcc447cfac0af084", "url": "https://github.com/uyuni-project/uyuni/commit/f6fe60bcefb6d6d8842403cadcc447cfac0af084", "message": "fix comments", "committedDate": "2020-02-19T16:59:09Z", "type": "commit"}, {"oid": "f6fe60bcefb6d6d8842403cadcc447cfac0af084", "url": "https://github.com/uyuni-project/uyuni/commit/f6fe60bcefb6d6d8842403cadcc447cfac0af084", "message": "fix comments", "committedDate": "2020-02-19T16:59:09Z", "type": "forcePushed"}]}