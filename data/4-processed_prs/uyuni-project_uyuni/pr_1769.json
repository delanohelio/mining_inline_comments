{"pr_number": 1769, "pr_title": "mgr-libmod", "pr_createdAt": "2020-01-07T15:50:59Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/1769", "timeline": [{"oid": "f6634a718b17ff47980d65823fe9f42d72386a1c", "url": "https://github.com/uyuni-project/uyuni/commit/f6634a718b17ff47980d65823fe9f42d72386a1c", "message": "Add setup.py", "committedDate": "2020-01-07T15:48:02Z", "type": "commit"}, {"oid": "0e61e54e463d6c08a40db4c7a4dc2265551cf39b", "url": "https://github.com/uyuni-project/uyuni/commit/0e61e54e463d6c08a40db4c7a4dc2265551cf39b", "message": "Define package name", "committedDate": "2020-01-07T15:48:53Z", "type": "commit"}, {"oid": "7dbb8f965a7bdac7572b6273209c04e62193619d", "url": "https://github.com/uyuni-project/uyuni/commit/7dbb8f965a7bdac7572b6273209c04e62193619d", "message": "Add package type input", "committedDate": "2020-01-07T15:49:09Z", "type": "commit"}, {"oid": "55dee6207bb3abbccf3ac37eecc8789ad0e49a09", "url": "https://github.com/uyuni-project/uyuni/commit/55dee6207bb3abbccf3ac37eecc8789ad0e49a09", "message": "Add main script (initial)", "committedDate": "2020-01-07T15:49:19Z", "type": "commit"}, {"oid": "1cb7efb046a819747a725c045e9dfe413e02c914", "url": "https://github.com/uyuni-project/uyuni/commit/1cb7efb046a819747a725c045e9dfe413e02c914", "message": "Update docstrings", "committedDate": "2020-01-07T16:06:04Z", "type": "commit"}, {"oid": "d680b1f3fdfdc29ed9371d0e3fe003cdbb0012e6", "url": "https://github.com/uyuni-project/uyuni/commit/d680b1f3fdfdc29ed9371d0e3fe003cdbb0012e6", "message": "Add JSON input example", "committedDate": "2020-01-08T14:03:44Z", "type": "commit"}, {"oid": "527d905c5fd7a1ebd96342c92c49dfe38773d0eb", "url": "https://github.com/uyuni-project/uyuni/commit/527d905c5fd7a1ebd96342c92c49dfe38773d0eb", "message": "Add simple CLI app", "committedDate": "2020-01-08T14:05:34Z", "type": "commit"}, {"oid": "cfca447bc4eb9c4aacef6c1610584c8c5bb62e43", "url": "https://github.com/uyuni-project/uyuni/commit/cfca447bc4eb9c4aacef6c1610584c8c5bb62e43", "message": "Update input and response types", "committedDate": "2020-01-08T16:37:39Z", "type": "commit"}, {"oid": "498c9d52b3e405eab6257894442d46b2032fcdd1", "url": "https://github.com/uyuni-project/uyuni/commit/498c9d52b3e405eab6257894442d46b2032fcdd1", "message": "Update input samples", "committedDate": "2020-01-09T10:31:07Z", "type": "commit"}, {"oid": "4dbff7fb0d18a4a2bd773c5efbd5dc8b789c8b15", "url": "https://github.com/uyuni-project/uyuni/commit/4dbff7fb0d18a4a2bd773c5efbd5dc8b789c8b15", "message": "Add YAML samples, update input requests", "committedDate": "2020-01-09T10:51:22Z", "type": "commit"}, {"oid": "8318c153fc871a35c0bd802d5d369d4f7696775b", "url": "https://github.com/uyuni-project/uyuni/commit/8318c153fc871a35c0bd802d5d369d4f7696775b", "message": "User pure STDIN for the input so the arguments may be used", "committedDate": "2020-01-09T14:21:31Z", "type": "commit"}, {"oid": "9c7e76dc2b0b4c84353f12d4733280078ab4fa03", "url": "https://github.com/uyuni-project/uyuni/commit/9c7e76dc2b0b4c84353f12d4733280078ab4fa03", "message": "Add get_function method for the input type", "committedDate": "2020-01-09T14:22:31Z", "type": "commit"}, {"oid": "0ac6190a56c8a018af1035bbb0dc17642c2d5b28", "url": "https://github.com/uyuni-project/uyuni/commit/0ac6190a56c8a018af1035bbb0dc17642c2d5b28", "message": "Fix type for get_streams method", "committedDate": "2020-01-09T14:23:08Z", "type": "commit"}, {"oid": "b5711f2e91673508583e6483bd1d154e130946d1", "url": "https://github.com/uyuni-project/uyuni/commit/b5711f2e91673508583e6483bd1d154e130946d1", "message": "Formatting autofixes", "committedDate": "2020-01-09T14:23:28Z", "type": "commit"}, {"oid": "bceb694f01765a596639c39302ad912ca63bf3df", "url": "https://github.com/uyuni-project/uyuni/commit/bceb694f01765a596639c39302ad912ca63bf3df", "message": "Add resolver process class", "committedDate": "2020-01-09T14:24:06Z", "type": "commit"}, {"oid": "034863be5b584f5e87f6b8f00c2b0468b2794367", "url": "https://github.com/uyuni-project/uyuni/commit/034863be5b584f5e87f6b8f00c2b0468b2794367", "message": "Reorganise main lib class for the CLI app", "committedDate": "2020-01-09T14:24:30Z", "type": "commit"}, {"oid": "4a3708cf2c95f2b34f3650f3ce6455213fbc568a", "url": "https://github.com/uyuni-project/uyuni/commit/4a3708cf2c95f2b34f3650f3ce6455213fbc568a", "message": "Add stream type", "committedDate": "2020-01-10T11:07:37Z", "type": "commit"}, {"oid": "3f675b24ac744e5e8673af213add427843dc0f79", "url": "https://github.com/uyuni-project/uyuni/commit/3f675b24ac744e5e8673af213add427843dc0f79", "message": "Print pretty formatted output", "committedDate": "2020-01-10T14:37:00Z", "type": "commit"}, {"oid": "16e13c2abcd27bbd3a44be708859869300974b6a", "url": "https://github.com/uyuni-project/uyuni/commit/16e13c2abcd27bbd3a44be708859869300974b6a", "message": "Fix typo", "committedDate": "2020-01-10T14:37:37Z", "type": "commit"}, {"oid": "8eb816d3a930c385158e2267e8da047aeded13b9", "url": "https://github.com/uyuni-project/uyuni/commit/8eb816d3a930c385158e2267e8da047aeded13b9", "message": "Add serialisable replacement for Set type.", "committedDate": "2020-01-10T14:38:02Z", "type": "commit"}, {"oid": "ebdd689746282209a2f297b258eef746e0c5d7f3", "url": "https://github.com/uyuni-project/uyuni/commit/ebdd689746282209a2f297b258eef746e0c5d7f3", "message": "Add initial implementation of the dep resolver", "committedDate": "2020-01-10T14:38:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMTI4MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365921281", "bodyText": "This should be el8, not e18 (stands for Enterprise Linux 8).\nThe module named \"platform\" is a pseudo-module to specify the actual OS in the modules world. So if a module depends on platform:el8, it just means it's built for RHEL 8.\nI'm not completely happy hardcoding this here, the values will surely change in the future.", "author": "cbbayburt", "createdAt": "2020-01-13T17:09:39Z", "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?\n+        all_deps = []  # type: ignore\n+        for m in dep.get_runtime_modules():\n+            deps = dep.get_runtime_streams(m)\n+            if deps:\n+                all_deps.append((m, deps[0],))  # XXX: why just first?\n+        return all_deps\n+\n+    def get_actual_stream(self, name: str):\n+        if name == \"platform\":\n+            return \"e18\"", "originalCommit": "ebdd689746282209a2f297b258eef746e0c5d7f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3Mjk2Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365972963", "bodyText": "Of course. But it is WP. I will surely update this better, once it works at all properly.", "author": "isbm", "createdAt": "2020-01-13T19:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMTI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNzc2Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365927766", "bodyText": "get_dependencies() returns a Modulemd.Dependencies object wrapped in a list, rather than returning a list of dependencies directly. And this list is always a 1 element array. But I guess it wouldn't hurt to foolproof this by looping to operate on the whole array (there's no info on this in the API docs)", "author": "cbbayburt", "createdAt": "2020-01-13T17:23:21Z", "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?", "originalCommit": "ebdd689746282209a2f297b258eef746e0c5d7f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MTM1NA==", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365971354", "bodyText": "Yeah, I already figured that out, actually. And yes, I am looping it over, because who knows. Just need to push. :-)", "author": "isbm", "createdAt": "2020-01-13T18:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNzc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyODgxNw==", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365928817", "bodyText": "we're calling get_runtime_streams(m) per module, and by definition, there cannot be more than 1 stream enabled for a module at the same time. Therefore, it's not possible for a module to depend on multiple streams of a same module. So in the end, this should also always be a 1 element array.\nBut again, I'm not against foolproofing this either.", "author": "cbbayburt", "createdAt": "2020-01-13T17:25:37Z", "path": "susemanager-utils/mgr-libmod/mgrlibmod/mllib.py", "diffHunk": "@@ -0,0 +1,330 @@\n+\"\"\"\n+libmod operations\n+\"\"\"\n+import os\n+import gzip\n+import json\n+import argparse\n+import binascii\n+\n+from typing import Any, Dict, List, Set\n+from mgrlibmod import mltypes\n+\n+import gi  # type: ignore\n+\n+gi.require_version(\"Modulemd\", \"2.0\")\n+from gi.repository import Modulemd  # type: ignore\n+\n+\n+class MLLibmodProc:\n+    \"\"\"\n+    Libmod process.\n+    \"\"\"\n+\n+    RESERVED_STREAMS = [\"platform\"]\n+\n+    def __init__(self, metadata: List[str]):\n+        \"\"\"\n+        __init__\n+\n+        :param metadata: paths of the metadata.\n+        :type metadata: List[str]\n+        \"\"\"\n+        self.metadata = metadata\n+        self._mod_index: Modulemd.ModuleIndex = None\n+        assert gi is not None and Modulemd is not None, \"No libmodulemd found\"\n+        self._enabled_stream_modules: Dict = {}\n+\n+    def _is_stream_enabled(self, s_type: mltypes.MLStreamType) -> bool:\n+        \"\"\"\n+        _is_stream_enabled -- returns True if stream is enabled. NOTE: \"platform\" is always enabled.\n+\n+        :param s_type: stream type object\n+        :type s_type: MLStreamType\n+        :return: True, if stream is enabled.\n+        :rtype: bool\n+        \"\"\"\n+        return s_type.name in self._enabled_stream_modules\n+\n+    def _is_meta_compressed(self, path: str) -> bool:\n+        \"\"\"\n+        _is_meta_compressed -- detect if metafile is plain text YAML or compressed.\n+\n+        :param path: path to the meta file.\n+        :type path: str\n+        :return: True, if meta is GNU Zip compressed.\n+        :rtype: bool\n+        \"\"\"\n+        with open(path, \"rb\") as metafile:\n+            return binascii.hexlify(metafile.read(2)) == b\"1f8b\"  # Almost reliable :-)\n+\n+    def enable_stream(self, s_obj) -> None:\n+        self._enabled_stream_modules[s_obj.get_module_name()] = s_obj\n+\n+    def disable(self, name: str) -> None:\n+        if name not in MLLibmodProc.RESERVED_STREAMS:\n+            self._enabled_stream_modules.pop(name, None)\n+\n+    def get_module_streams(self, name: str) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get module streams: module index not found\"\n+\n+        streams: Set = set()\n+        module = self._mod_index.get_module(name)\n+        if module:\n+            for s_obj in module.get_all_streams():\n+                streams.add(s_obj.get_stream_name())\n+\n+        return list(streams)\n+\n+    def get_stream_contexts(self, s_type: mltypes.MLStreamType) -> List:\n+        if self._mod_index is None:\n+            self.index_modules()\n+        assert self._mod_index is not None, \"Unable to get stream contexts: module index not found\"\n+        contexts: List = []\n+        module = self._mod_index.get_module(s_type.name)\n+        if module:\n+            for stream in module.get_all_streams():\n+                if stream.get_stream_name() == s_type.stream:\n+                    contexts.append(stream)\n+\n+        return contexts\n+\n+    def get_stream_dependencies(self, ctx: Modulemd.ModuleStreamV2) -> List[str]:\n+        \"\"\"\n+        get_stream_dependencies -- get stream dependencies.\n+\n+        :param ctx: module stream context\n+        :type ctx: Modulemd.ModuleStreamV2\n+        :return: list of dependency names.\n+        :rtype: List[str]\n+        \"\"\"\n+        deps: List[str] = []\n+        s_deps: List[Modulemd.Dependencies] = ctx.get_dependencies() or []\n+        dep: Modulemd.Dependencies\n+        for dep in s_deps:\n+            deps.extend(dep.get_runtime_modules())\n+\n+        return deps\n+\n+    def index_modules(self) -> None:\n+        \"\"\"\n+        index_modules -- loads given metadata and indexes modules from there.\n+        \"\"\"\n+        if self._mod_index is None:\n+            mgr: Modulemd.ModuleIndex = Modulemd.ModuleIndexMerger.new()\n+            for path in self.metadata:\n+                idx = Modulemd.ModuleIndex.new()\n+                if self._is_meta_compressed(path):\n+                    with gzip.open(path) as gzmeta:\n+                        idx.update_from_string(gzmeta.read().decode(\"utf-8\"), True)\n+                else:\n+                    idx.update_from_file(path, True)\n+                mgr.associate_index(idx, 0)\n+            self._mod_index = mgr.resolve()\n+\n+    def get_default_stream(self, name: str):\n+        assert self._mod_index is not None, \"Unable to access module index when resolving default stream\"\n+        module = self._mod_index.get_module(name)\n+        if not module:\n+            raise ValueError(\"Module {} not found\".format(name))\n+        defaults = module.get_detaults()\n+        if defaults:\n+            return defaults.get_default_stream()\n+\n+        return module.get_all_streams()[0].get_stream_name()\n+\n+    def get_dep_streams(self, s_obj):\n+        dep = s_obj.get_dependencies()[0]  # XXX: Why just always first?\n+        all_deps = []  # type: ignore\n+        for m in dep.get_runtime_modules():\n+            deps = dep.get_runtime_streams(m)\n+            if deps:\n+                all_deps.append((m, deps[0],))  # XXX: why just first?", "originalCommit": "ebdd689746282209a2f297b258eef746e0c5d7f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MjA4NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1769#discussion_r365972085", "bodyText": "Yeah, let's foolproof. Usually the foo[idx] code in Python world considered evil, unless you really know what you are doing. E.g. in unit tests it is OK, but in code like that, maybe OK. I am still wondering why they are returning array with one element than just element... Having for loops all over the place is also not great. Maybe I can wrap that thing into a property, so we don't have loops but we don't access that by an index either.", "author": "isbm", "createdAt": "2020-01-13T18:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyODgxNw=="}], "type": "inlineReview"}, {"oid": "964c731f5335ae44c13d49b49ead330122d16fc1", "url": "https://github.com/uyuni-project/uyuni/commit/964c731f5335ae44c13d49b49ead330122d16fc1", "message": "Add module_packages function request", "committedDate": "2020-01-14T16:56:22Z", "type": "commit"}, {"oid": "059ba956edf5717efb09e2254a3c9c6df7a01230", "url": "https://github.com/uyuni-project/uyuni/commit/059ba956edf5717efb09e2254a3c9c6df7a01230", "message": "Fix a typo", "committedDate": "2020-01-14T16:56:47Z", "type": "commit"}, {"oid": "79fc0df8c4d1e70f25b6395b6f2da76e75c14b87", "url": "https://github.com/uyuni-project/uyuni/commit/79fc0df8c4d1e70f25b6395b6f2da76e75c14b87", "message": "Implement module lister", "committedDate": "2020-01-14T16:57:13Z", "type": "commit"}, {"oid": "aec64c1e14758da904ec2a5ff82543f000e624f2", "url": "https://github.com/uyuni-project/uyuni/commit/aec64c1e14758da904ec2a5ff82543f000e624f2", "message": "Update list_packages response format", "committedDate": "2020-01-14T16:57:42Z", "type": "commit"}, {"oid": "05aaf314c63b7948ec48e4db34d74f3e2b15aa7e", "url": "https://github.com/uyuni-project/uyuni/commit/05aaf314c63b7948ec48e4db34d74f3e2b15aa7e", "message": "Lintfix", "committedDate": "2020-01-14T16:58:01Z", "type": "commit"}, {"oid": "ada174cfc9c58a2fb962872a062b6b928145ccc6", "url": "https://github.com/uyuni-project/uyuni/commit/ada174cfc9c58a2fb962872a062b6b928145ccc6", "message": "Add return type, update docstring", "committedDate": "2020-01-14T16:58:19Z", "type": "commit"}, {"oid": "1cc24c866165c434d5991c26706bf56374597c88", "url": "https://github.com/uyuni-project/uyuni/commit/1cc24c866165c434d5991c26706bf56374597c88", "message": "Add apis and selected artifacts", "committedDate": "2020-01-15T16:47:34Z", "type": "commit"}, {"oid": "afbd955e07f628224b1db2ea9a0a4e61e2cd0080", "url": "https://github.com/uyuni-project/uyuni/commit/afbd955e07f628224b1db2ea9a0a4e61e2cd0080", "message": "Use module name instead of artifact's one", "committedDate": "2020-01-16T11:05:29Z", "type": "commit"}, {"oid": "674bcece25166336cadfeef0a13493fb74791dfe", "url": "https://github.com/uyuni-project/uyuni/commit/674bcece25166336cadfeef0a13493fb74791dfe", "message": "Stage all packages known to the stream, filter-out source packages", "committedDate": "2020-01-29T15:55:38Z", "type": "commit"}, {"oid": "5114879434e2762c32d911936114a1ebb21109ca", "url": "https://github.com/uyuni-project/uyuni/commit/5114879434e2762c32d911936114a1ebb21109ca", "message": "Fix typo", "committedDate": "2020-01-29T16:47:42Z", "type": "commit"}, {"oid": "0d28a7616177f5a1e63926ab93addfc768cbf0a3", "url": "https://github.com/uyuni-project/uyuni/commit/0d28a7616177f5a1e63926ab93addfc768cbf0a3", "message": "Remove restriction on streams in input type", "committedDate": "2020-01-29T16:48:33Z", "type": "commit"}, {"oid": "da8e9784e22af6c303d2536893c20f4a84f8c663", "url": "https://github.com/uyuni-project/uyuni/commit/da8e9784e22af6c303d2536893c20f4a84f8c663", "message": "Write error notification to the STDERR", "committedDate": "2020-01-29T16:49:34Z", "type": "commit"}, {"oid": "ae89ea16f8ab1020f6cf8bd7cc11c13c9b5f6ca7", "url": "https://github.com/uyuni-project/uyuni/commit/ae89ea16f8ab1020f6cf8bd7cc11c13c9b5f6ca7", "message": "Refactor \"api_provides\" method", "committedDate": "2020-01-29T16:50:04Z", "type": "commit"}, {"oid": "d88f6b40f2ef9151d856417b4d2c58116a94db7b", "url": "https://github.com/uyuni-project/uyuni/commit/d88f6b40f2ef9151d856417b4d2c58116a94db7b", "message": "Show all selected stream contexts", "committedDate": "2020-01-30T13:14:14Z", "type": "commit"}, {"oid": "25692b573ff030583392eaa075e81c6d784dc336", "url": "https://github.com/uyuni-project/uyuni/commit/25692b573ff030583392eaa075e81c6d784dc336", "message": "Process multiple streams update", "committedDate": "2020-01-30T16:31:00Z", "type": "commit"}, {"oid": "47f6d32e795528c4c1c6d5ba26da72f7f44c7e6a", "url": "https://github.com/uyuni-project/uyuni/commit/47f6d32e795528c4c1c6d5ba26da72f7f44c7e6a", "message": "Remove comments", "committedDate": "2020-01-30T16:31:20Z", "type": "commit"}, {"oid": "462f859116fa1f98aebd5b3240c3f9b860f21d55", "url": "https://github.com/uyuni-project/uyuni/commit/462f859116fa1f98aebd5b3240c3f9b860f21d55", "message": "Add initial unit test for mlstreamlib", "committedDate": "2020-02-06T14:52:28Z", "type": "commit"}, {"oid": "2b885e976318662df20ca4821e2d3805567dbd53", "url": "https://github.com/uyuni-project/uyuni/commit/2b885e976318662df20ca4821e2d3805567dbd53", "message": "Add unit test for meta is compressed", "committedDate": "2020-02-06T15:44:37Z", "type": "commit"}, {"oid": "c925d9d4ca616d69f79ef6e965d0ae87d4cc602e", "url": "https://github.com/uyuni-project/uyuni/commit/c925d9d4ca616d69f79ef6e965d0ae87d4cc602e", "message": "add unit test for enabling stream", "committedDate": "2020-02-06T15:44:51Z", "type": "commit"}, {"oid": "39b3a8308c5c1438eddf95004e1bfee1b47bffea", "url": "https://github.com/uyuni-project/uyuni/commit/39b3a8308c5c1438eddf95004e1bfee1b47bffea", "message": "Update doscstrings", "committedDate": "2020-02-06T15:47:17Z", "type": "commit"}, {"oid": "49e4628b9c99d703970dda0d56cb3997e4042447", "url": "https://github.com/uyuni-project/uyuni/commit/49e4628b9c99d703970dda0d56cb3997e4042447", "message": "Add unit test for disable stream", "committedDate": "2020-02-06T15:49:52Z", "type": "commit"}, {"oid": "12045c8d9c15b6dcaed94bf71901b408d6a6a12e", "url": "https://github.com/uyuni-project/uyuni/commit/12045c8d9c15b6dcaed94bf71901b408d6a6a12e", "message": "Add initial commit to the version", "committedDate": "2020-02-07T10:00:35Z", "type": "commit"}, {"oid": "f0684498de205d1f9291ffebe0f6715770256e08", "url": "https://github.com/uyuni-project/uyuni/commit/f0684498de205d1f9291ffebe0f6715770256e08", "message": "Add initial version of spec", "committedDate": "2020-02-07T10:02:26Z", "type": "commit"}, {"oid": "5153d8ec2d9ceeb696a8ba2099df4439bfa46ea0", "url": "https://github.com/uyuni-project/uyuni/commit/5153d8ec2d9ceeb696a8ba2099df4439bfa46ea0", "message": "Remove %files from spec", "committedDate": "2020-02-07T10:09:16Z", "type": "commit"}, {"oid": "4e09a51fa54fb6ec5d46a23459201fec11983391", "url": "https://github.com/uyuni-project/uyuni/commit/4e09a51fa54fb6ec5d46a23459201fec11983391", "message": "Automatic commit of package [mgr-libmod] release [0.2-1].", "committedDate": "2020-02-07T10:14:35Z", "type": "commit"}, {"oid": "c76ecaf4c080697d93e10be10b7969471f42e90b", "url": "https://github.com/uyuni-project/uyuni/commit/c76ecaf4c080697d93e10be10b7969471f42e90b", "message": "Add license file", "committedDate": "2020-02-07T11:02:19Z", "type": "commit"}, {"oid": "b3806be90e09a5d0ef2c21e6776db8c610177d7d", "url": "https://github.com/uyuni-project/uyuni/commit/b3806be90e09a5d0ef2c21e6776db8c610177d7d", "message": "Remove license", "committedDate": "2020-02-07T12:02:01Z", "type": "commit"}, {"oid": "8903f448831c4ae7777ddcc93735cb7b80a90813", "url": "https://github.com/uyuni-project/uyuni/commit/8903f448831c4ae7777ddcc93735cb7b80a90813", "message": "fix shebang for the main exec", "committedDate": "2020-02-07T13:50:01Z", "type": "commit"}, {"oid": "88a9b45604e34e291b2062d10912bb44b996b918", "url": "https://github.com/uyuni-project/uyuni/commit/88a9b45604e34e291b2062d10912bb44b996b918", "message": "Update example documentation", "committedDate": "2020-02-07T14:10:59Z", "type": "commit"}, {"oid": "18d3bc801fe7f0f676c16c5149bcaba31bb7f430", "url": "https://github.com/uyuni-project/uyuni/commit/18d3bc801fe7f0f676c16c5149bcaba31bb7f430", "message": "Add list of supported functions", "committedDate": "2020-02-07T14:11:29Z", "type": "commit"}, {"oid": "f1118a916956da5583cc8a337ec3aab70320ad3b", "url": "https://github.com/uyuni-project/uyuni/commit/f1118a916956da5583cc8a337ec3aab70320ad3b", "message": "Add license file", "committedDate": "2020-02-07T14:15:48Z", "type": "commit"}, {"oid": "1bb0b1aca55846048fd034f5de04a334918cf43d", "url": "https://github.com/uyuni-project/uyuni/commit/1bb0b1aca55846048fd034f5de04a334918cf43d", "message": "Update spec", "committedDate": "2020-02-07T14:20:17Z", "type": "commit"}, {"oid": "0f1f3ce41ed1d3dd09eab3c2d990e90fc8b0fb24", "url": "https://github.com/uyuni-project/uyuni/commit/0f1f3ce41ed1d3dd09eab3c2d990e90fc8b0fb24", "message": "Add license to the spec", "committedDate": "2020-02-07T14:23:13Z", "type": "commit"}]}