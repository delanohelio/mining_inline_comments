{"pr_number": 7485, "pr_title": "[1.16] Vanilla packet splitting", "pr_createdAt": "2020-11-12T23:26:09Z", "pr_url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485", "timeline": [{"oid": "b66d1f5e78d81309e9663f1582e81e9ac3e51d96", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/b66d1f5e78d81309e9663f1582e81e9ac3e51d96", "message": "Packet splitting for vanilla packets on Forge connections.\nCurrently only for SUpdateRecipesPacket and STagsListPacket that blow up with huge datapacks", "committedDate": "2020-11-12T23:15:24Z", "type": "commit"}, {"oid": "045443c38875a8e8374072d0c567722f78510194", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/045443c38875a8e8374072d0c567722f78510194", "message": "Some Javadocs", "committedDate": "2020-11-12T23:20:02Z", "type": "commit"}, {"oid": "487720b501679ef93cd18beb58806fba65653b30", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/487720b501679ef93cd18beb58806fba65653b30", "message": "Don't split on local connections", "committedDate": "2020-11-12T23:27:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU1NDk3OA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#discussion_r522554978", "bodyText": "This event must be ServerCustomPayloadEvent to receive clientbound packets.", "author": "pau101", "createdAt": "2020-11-13T01:40:20Z", "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package net.minecraftforge.network;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import io.netty.buffer.Unpooled;\n+import net.minecraft.client.Minecraft;\n+import net.minecraft.client.network.play.ClientPlayNetHandler;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.network.PacketDirection;\n+import net.minecraft.network.ProtocolType;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import net.minecraft.network.play.server.STagsListPacket;\n+import net.minecraft.network.play.server.SUpdateRecipesPacket;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.network.NetworkDirection;\n+import net.minecraftforge.fml.network.NetworkEvent;\n+import net.minecraftforge.fml.network.NetworkRegistry;\n+import net.minecraftforge.fml.network.event.EventNetworkChannel;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * A custom payload channel that allows sending vanilla server-to-client packets, even if they would normally\n+ * be too large for the vanilla protocol. This is achieved by splitting them into multiple custom payload packets.\n+ */\n+public class VanillaPacketSplitter\n+{\n+\n+    private static final Logger LOGGER = LogManager.getLogger();\n+\n+    private static final ResourceLocation CHANNEL = new ResourceLocation(\"forge\", \"split\");\n+    private static final String VERSION = \"1.0\";\n+\n+    private static final Set<Class<? extends IPacket<?>>> ALLOWED_PACKETS = ImmutableSet.of(\n+            SUpdateRecipesPacket.class,\n+            STagsListPacket.class\n+    );\n+\n+    private static final int PROTOCOL_MAX = 2097152;\n+\n+    private static final int PAYLOAD_TO_CLIENT_MAX = 1048576;\n+    // 1 byte for state, 5 byte for VarInt PacketID\n+    private static final int PART_SIZE = PAYLOAD_TO_CLIENT_MAX - 1 - 5;\n+\n+    private static final byte STATE_FIRST = 1;\n+    private static final byte STATE_LAST = 2;\n+\n+    public static void register()\n+    {\n+        EventNetworkChannel channel = NetworkRegistry.newEventChannel(CHANNEL, () -> VERSION, VERSION::equals, VERSION::equals);\n+        channel.addListener(VanillaPacketSplitter::onClientPacket);\n+    }\n+\n+    /**\n+     * Append the given packet to the given list. If the packet needs to be split, multiple packets will be appened.\n+     * Otherwise only the packet itself.\n+     */\n+    public static void appendPackets(ProtocolType protocol, PacketDirection direction, IPacket<?> packet, List<? super IPacket<?>> out)\n+    {\n+        if (heuristicIsDefinitelySmallEnough(packet))\n+        {\n+            out.add(packet);\n+        }\n+        else\n+        {\n+            PacketBuffer buf = new PacketBuffer(Unpooled.buffer());\n+            try\n+            {\n+                packet.writePacketData(buf);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new UncheckedIOException(e);\n+            }\n+            if (buf.readableBytes() <= PROTOCOL_MAX)\n+            {\n+                out.add(packet);\n+            }\n+            else\n+            {\n+                int parts = (int)Math.ceil(((double)buf.readableBytes()) / PART_SIZE);\n+                if (parts == 1)\n+                {\n+                    out.add(packet);\n+                }\n+                else\n+                {\n+                    for (int part = 0; part < parts; part++)\n+                    {\n+                        PacketBuffer partBuf = new PacketBuffer(Unpooled.buffer());\n+                        if (part == 0)\n+                        {\n+                            partBuf.writeByte(STATE_FIRST);\n+                            partBuf.writeVarInt(protocol.getPacketId(direction, packet));\n+                        }\n+                        else\n+                        {\n+                            partBuf.writeByte(part == parts - 1 ? STATE_LAST : 0);\n+                        }\n+                        partBuf.writeBytes(buf, Math.min(PART_SIZE, buf.readableBytes()));\n+                        out.add(new SCustomPayloadPlayPacket(CHANNEL, partBuf));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean heuristicIsDefinitelySmallEnough(IPacket<?> packet)\n+    {\n+        // todo: improve this\n+        return false;\n+    }\n+\n+    private static final List<PacketBuffer> receivedBuffers = new ArrayList<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void onClientPacket(NetworkEvent.ClientCustomPayloadEvent event)", "originalCommit": "487720b501679ef93cd18beb58806fba65653b30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3MTk0Nw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#discussion_r522571947", "bodyText": "This buffer is released after this packet is processed*, either a copy of the buffer should be created or a switch to writing buffer bytes to a single cumulation buffer should be made.\n*should be released, as after confirming this, it is not in fact due to a patch port error introducing a memory leak for what it was intended to fix, new issue report in progress.", "author": "pau101", "createdAt": "2020-11-13T02:28:15Z", "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package net.minecraftforge.network;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import io.netty.buffer.Unpooled;\n+import net.minecraft.client.Minecraft;\n+import net.minecraft.client.network.play.ClientPlayNetHandler;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.network.PacketDirection;\n+import net.minecraft.network.ProtocolType;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import net.minecraft.network.play.server.STagsListPacket;\n+import net.minecraft.network.play.server.SUpdateRecipesPacket;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.network.NetworkDirection;\n+import net.minecraftforge.fml.network.NetworkEvent;\n+import net.minecraftforge.fml.network.NetworkRegistry;\n+import net.minecraftforge.fml.network.event.EventNetworkChannel;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * A custom payload channel that allows sending vanilla server-to-client packets, even if they would normally\n+ * be too large for the vanilla protocol. This is achieved by splitting them into multiple custom payload packets.\n+ */\n+public class VanillaPacketSplitter\n+{\n+\n+    private static final Logger LOGGER = LogManager.getLogger();\n+\n+    private static final ResourceLocation CHANNEL = new ResourceLocation(\"forge\", \"split\");\n+    private static final String VERSION = \"1.0\";\n+\n+    private static final Set<Class<? extends IPacket<?>>> ALLOWED_PACKETS = ImmutableSet.of(\n+            SUpdateRecipesPacket.class,\n+            STagsListPacket.class\n+    );\n+\n+    private static final int PROTOCOL_MAX = 2097152;\n+\n+    private static final int PAYLOAD_TO_CLIENT_MAX = 1048576;\n+    // 1 byte for state, 5 byte for VarInt PacketID\n+    private static final int PART_SIZE = PAYLOAD_TO_CLIENT_MAX - 1 - 5;\n+\n+    private static final byte STATE_FIRST = 1;\n+    private static final byte STATE_LAST = 2;\n+\n+    public static void register()\n+    {\n+        EventNetworkChannel channel = NetworkRegistry.newEventChannel(CHANNEL, () -> VERSION, VERSION::equals, VERSION::equals);\n+        channel.addListener(VanillaPacketSplitter::onClientPacket);\n+    }\n+\n+    /**\n+     * Append the given packet to the given list. If the packet needs to be split, multiple packets will be appened.\n+     * Otherwise only the packet itself.\n+     */\n+    public static void appendPackets(ProtocolType protocol, PacketDirection direction, IPacket<?> packet, List<? super IPacket<?>> out)\n+    {\n+        if (heuristicIsDefinitelySmallEnough(packet))\n+        {\n+            out.add(packet);\n+        }\n+        else\n+        {\n+            PacketBuffer buf = new PacketBuffer(Unpooled.buffer());\n+            try\n+            {\n+                packet.writePacketData(buf);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new UncheckedIOException(e);\n+            }\n+            if (buf.readableBytes() <= PROTOCOL_MAX)\n+            {\n+                out.add(packet);\n+            }\n+            else\n+            {\n+                int parts = (int)Math.ceil(((double)buf.readableBytes()) / PART_SIZE);\n+                if (parts == 1)\n+                {\n+                    out.add(packet);\n+                }\n+                else\n+                {\n+                    for (int part = 0; part < parts; part++)\n+                    {\n+                        PacketBuffer partBuf = new PacketBuffer(Unpooled.buffer());\n+                        if (part == 0)\n+                        {\n+                            partBuf.writeByte(STATE_FIRST);\n+                            partBuf.writeVarInt(protocol.getPacketId(direction, packet));\n+                        }\n+                        else\n+                        {\n+                            partBuf.writeByte(part == parts - 1 ? STATE_LAST : 0);\n+                        }\n+                        partBuf.writeBytes(buf, Math.min(PART_SIZE, buf.readableBytes()));\n+                        out.add(new SCustomPayloadPlayPacket(CHANNEL, partBuf));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean heuristicIsDefinitelySmallEnough(IPacket<?> packet)\n+    {\n+        // todo: improve this\n+        return false;\n+    }\n+\n+    private static final List<PacketBuffer> receivedBuffers = new ArrayList<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void onClientPacket(NetworkEvent.ClientCustomPayloadEvent event)\n+    {\n+        NetworkEvent.Context ctx = event.getSource().get();\n+        PacketDirection direction = ctx.getDirection() == NetworkDirection.PLAY_TO_CLIENT ? PacketDirection.CLIENTBOUND : PacketDirection.SERVERBOUND;\n+        ProtocolType protocol = ProtocolType.PLAY;\n+\n+        PacketBuffer buf = event.getPayload();\n+\n+        byte state = buf.readByte();\n+        if (state == STATE_FIRST)\n+        {\n+            receivedBuffers.clear();\n+        }\n+        receivedBuffers.add(buf);", "originalCommit": "487720b501679ef93cd18beb58806fba65653b30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU5MTY2NQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/7485#discussion_r522591665", "bodyText": "A call to ctx.setPacketHandled(true) is missing, meaning the log will get filled with \"unknown custom packet.\"", "author": "pau101", "createdAt": "2020-11-13T03:31:27Z", "path": "src/main/java/net/minecraftforge/network/VanillaPacketSplitter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package net.minecraftforge.network;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import io.netty.buffer.Unpooled;\n+import net.minecraft.client.Minecraft;\n+import net.minecraft.client.network.play.ClientPlayNetHandler;\n+import net.minecraft.network.IPacket;\n+import net.minecraft.network.PacketBuffer;\n+import net.minecraft.network.PacketDirection;\n+import net.minecraft.network.ProtocolType;\n+import net.minecraft.network.play.server.SCustomPayloadPlayPacket;\n+import net.minecraft.network.play.server.STagsListPacket;\n+import net.minecraft.network.play.server.SUpdateRecipesPacket;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraftforge.fml.network.NetworkDirection;\n+import net.minecraftforge.fml.network.NetworkEvent;\n+import net.minecraftforge.fml.network.NetworkRegistry;\n+import net.minecraftforge.fml.network.event.EventNetworkChannel;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * A custom payload channel that allows sending vanilla server-to-client packets, even if they would normally\n+ * be too large for the vanilla protocol. This is achieved by splitting them into multiple custom payload packets.\n+ */\n+public class VanillaPacketSplitter\n+{\n+\n+    private static final Logger LOGGER = LogManager.getLogger();\n+\n+    private static final ResourceLocation CHANNEL = new ResourceLocation(\"forge\", \"split\");\n+    private static final String VERSION = \"1.0\";\n+\n+    private static final Set<Class<? extends IPacket<?>>> ALLOWED_PACKETS = ImmutableSet.of(\n+            SUpdateRecipesPacket.class,\n+            STagsListPacket.class\n+    );\n+\n+    private static final int PROTOCOL_MAX = 2097152;\n+\n+    private static final int PAYLOAD_TO_CLIENT_MAX = 1048576;\n+    // 1 byte for state, 5 byte for VarInt PacketID\n+    private static final int PART_SIZE = PAYLOAD_TO_CLIENT_MAX - 1 - 5;\n+\n+    private static final byte STATE_FIRST = 1;\n+    private static final byte STATE_LAST = 2;\n+\n+    public static void register()\n+    {\n+        EventNetworkChannel channel = NetworkRegistry.newEventChannel(CHANNEL, () -> VERSION, VERSION::equals, VERSION::equals);\n+        channel.addListener(VanillaPacketSplitter::onClientPacket);\n+    }\n+\n+    /**\n+     * Append the given packet to the given list. If the packet needs to be split, multiple packets will be appened.\n+     * Otherwise only the packet itself.\n+     */\n+    public static void appendPackets(ProtocolType protocol, PacketDirection direction, IPacket<?> packet, List<? super IPacket<?>> out)\n+    {\n+        if (heuristicIsDefinitelySmallEnough(packet))\n+        {\n+            out.add(packet);\n+        }\n+        else\n+        {\n+            PacketBuffer buf = new PacketBuffer(Unpooled.buffer());\n+            try\n+            {\n+                packet.writePacketData(buf);\n+            }\n+            catch (IOException e)\n+            {\n+                throw new UncheckedIOException(e);\n+            }\n+            if (buf.readableBytes() <= PROTOCOL_MAX)\n+            {\n+                out.add(packet);\n+            }\n+            else\n+            {\n+                int parts = (int)Math.ceil(((double)buf.readableBytes()) / PART_SIZE);\n+                if (parts == 1)\n+                {\n+                    out.add(packet);\n+                }\n+                else\n+                {\n+                    for (int part = 0; part < parts; part++)\n+                    {\n+                        PacketBuffer partBuf = new PacketBuffer(Unpooled.buffer());\n+                        if (part == 0)\n+                        {\n+                            partBuf.writeByte(STATE_FIRST);\n+                            partBuf.writeVarInt(protocol.getPacketId(direction, packet));\n+                        }\n+                        else\n+                        {\n+                            partBuf.writeByte(part == parts - 1 ? STATE_LAST : 0);\n+                        }\n+                        partBuf.writeBytes(buf, Math.min(PART_SIZE, buf.readableBytes()));\n+                        out.add(new SCustomPayloadPlayPacket(CHANNEL, partBuf));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean heuristicIsDefinitelySmallEnough(IPacket<?> packet)\n+    {\n+        // todo: improve this\n+        return false;\n+    }\n+\n+    private static final List<PacketBuffer> receivedBuffers = new ArrayList<>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void onClientPacket(NetworkEvent.ClientCustomPayloadEvent event)\n+    {\n+        NetworkEvent.Context ctx = event.getSource().get();\n+        PacketDirection direction = ctx.getDirection() == NetworkDirection.PLAY_TO_CLIENT ? PacketDirection.CLIENTBOUND : PacketDirection.SERVERBOUND;\n+        ProtocolType protocol = ProtocolType.PLAY;\n+\n+        PacketBuffer buf = event.getPayload();\n+\n+        byte state = buf.readByte();\n+        if (state == STATE_FIRST)\n+        {\n+            receivedBuffers.clear();\n+        }\n+        receivedBuffers.add(buf);\n+        if (state == STATE_LAST)\n+        {\n+            PacketBuffer full = new PacketBuffer(Unpooled.wrappedBuffer(receivedBuffers.toArray(new PacketBuffer[0])));\n+            int packetId = full.readVarInt();\n+            IPacket<?> packet = protocol.getPacket(direction, packetId);\n+            if (packet == null)\n+            {\n+                LOGGER.error(\"Received invalid packet ID {} in forge:split\", packetId);\n+            }\n+            else if (!ALLOWED_PACKETS.contains(packet.getClass()))\n+            {\n+                LOGGER.error(\"Received not allowed packet type {} in forge:split\", packet);\n+            }\n+            else\n+            {\n+                try\n+                {\n+                    packet.readPacketData(full);\n+                }\n+                catch (IOException e)\n+                {\n+                    throw new UncheckedIOException(e);\n+                }\n+                ctx.enqueueWork(() -> ((IPacket<ClientPlayNetHandler>)packet).processPacket(Minecraft.getInstance().getConnection()));", "originalCommit": "487720b501679ef93cd18beb58806fba65653b30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f56767e75c63db2d9cb02d7b719fd5f00d36e8f", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/0f56767e75c63db2d9cb02d7b719fd5f00d36e8f", "message": "Fix packet not actually doing anything\nProperly release/retain ByteBufs\nreduce ByteBuf copying", "committedDate": "2020-11-13T08:47:33Z", "type": "commit"}, {"oid": "983f7c91dfe945ab2860fa83e9371976ee85183b", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/983f7c91dfe945ab2860fa83e9371976ee85183b", "message": "Merge remote-tracking branch 'upstream/1.16.x' into vanilla-packet-splitting\n\n# Conflicts:\n#\tsrc/main/java/net/minecraftforge/network/VanillaConnectionNetworkFilter.java", "committedDate": "2021-01-11T09:39:25Z", "type": "commit"}, {"oid": "032565965fdb3c4b7f191eea30d26e98c20ea993", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/032565965fdb3c4b7f191eea30d26e98c20ea993", "message": "Remove todo", "committedDate": "2021-01-11T09:42:39Z", "type": "commit"}]}