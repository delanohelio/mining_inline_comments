{"pr_number": 6401, "pr_title": "Global Loot Funcs on 1.15.x", "pr_createdAt": "2020-01-01T03:39:50Z", "pr_url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401", "timeline": [{"oid": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/45c4f43904902afa50265ec7e23dbe02aea9eb35", "message": "Global Loot Funcs on 1.15.x", "committedDate": "2020-01-01T03:38:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MDQ1NQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363960455", "bodyText": "This doesn't seem to address re-processing new list entries added by modifiers.\nSuch as re-running a smelting modifier after modifier that converts gravel to sand.\nIs that something we want to care about at all?", "author": "LexManos", "createdAt": "2020-01-07T21:31:06Z", "path": "src/main/java/net/minecraftforge/common/ForgeHooks.java", "diffHunk": "@@ -1210,4 +1210,12 @@ public static synchronized void updateBurns()\n         FurnaceTileEntity.getBurnTimes().entrySet().forEach(e -> VANILLA_BURNS.put(e.getKey().delegate, e.getValue()));\n     }\n \n+    public static List<ItemStack> modifyLoot(List<ItemStack> list, LootContext context) {\n+        LootModifierManager man = LootModifierManager.getInstance();\n+        for(IGlobalLootModifier mod : man.getAllLootMods()) {", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk3NDUyMg==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363974522", "bodyText": "I don't know if we want to handle it or not. I'm sure someone will eventually have a use-case, but it was not in the list of things people cared about when I was writing the system. Such processing would have to cleanly handle probabalistic alterations (e.g. if gravel is converted to sand 10% of the time (first pass: fail) and the list gets re-processed, it should not attempt to recheck that element). I'm worried that this becomes non-trivial quickly.", "author": "Draco18s", "createdAt": "2020-01-07T22:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MDQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk3NjEyNg==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363976126", "bodyText": "That is the entire issue of why I didn't work on this yet.\nBut, because things are being designed, and this is most definitely going to be a breaking change {processing entries, instead of the full list} it needs to be addressed.\nPerhaps the processor should be List<ItemStack> process(ItemStack);", "author": "LexManos", "createdAt": "2020-01-07T22:10:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MDQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAwMzMxNQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r364003315", "bodyText": "I have a specific use-case that requires the full list, not just individual entries. One of the test mods (WheatSeedsConverterModifier) shows one such an example.", "author": "Draco18s", "createdAt": "2020-01-07T23:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MDQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MDYzMw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363960633", "bodyText": "This seems to be the core of the system, yet ZERO docs?", "author": "LexManos", "createdAt": "2020-01-07T21:31:30Z", "path": "src/main/java/net/minecraftforge/common/loot/IGlobalLootModifier.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package net.minecraftforge.common.loot;\n+\n+import java.util.List;\n+\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.world.storage.loot.LootContext;\n+\n+public interface IGlobalLootModifier {\n+    List<ItemStack> apply(List<ItemStack> generatedLoot, LootContext context);", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4NjA1Mg==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363986052", "bodyText": "I'll address this. I didn't even want to open a PR originally because I was bashing around blindly, but I got zero feedback.", "author": "Draco18s", "createdAt": "2020-01-07T22:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MDc0Ng==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363960746", "bodyText": "Again, docs.", "author": "LexManos", "createdAt": "2020-01-07T21:31:46Z", "path": "src/main/java/net/minecraftforge/common/loot/IGlobalLootModifierSerializer.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package net.minecraftforge.common.loot;\n+\n+import com.google.gson.JsonObject;\n+\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraftforge.registries.IForgeRegistryEntry;\n+\n+public interface IGlobalLootModifierSerializer<T extends IGlobalLootModifier> extends IForgeRegistryEntry<IGlobalLootModifierSerializer<?>> {", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MTA1OA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363961058", "bodyText": "This needs a valid value.", "author": "LexManos", "createdAt": "2020-01-07T21:32:32Z", "path": "src/main/java/net/minecraftforge/common/loot/IGlobalLootModifierSerializer.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package net.minecraftforge.common.loot;\n+\n+import com.google.gson.JsonObject;\n+\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraftforge.registries.IForgeRegistryEntry;\n+\n+public interface IGlobalLootModifierSerializer<T extends IGlobalLootModifier> extends IForgeRegistryEntry<IGlobalLootModifierSerializer<?>> {\n+    public abstract T read(ResourceLocation location, JsonObject object, ILootCondition[] ailootcondition);\n+\n+    @Override\n+    public default Class<IGlobalLootModifierSerializer<?>> getRegistryType() {", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk3NjczOA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363976738", "bodyText": "Good point. I looked at it a day or so ago (I saw that it was returning null and went \"this probably should not do that\") but I have been unable to determine what it should return. The existing implementations don't help (there being only two: one is (Class<V>)token.getRawType(); and the other is Serializer.<IRecipeSerializer<?>>castClass(IRecipeSerializer.class);, attempting to mimic either one just generates compile-time errors).", "author": "Draco18s", "createdAt": "2020-01-07T22:12:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MTA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk3ODgyNA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363978824", "bodyText": "The one to mimic, due to generics, would be IRecipeSerializer. But you may have to do some finessing with generics to get it correct. Or, you could just make IGlobalLootModifierSerializer non-generic.", "author": "LexManos", "createdAt": "2020-01-07T22:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MTA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4ODM3NA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363988374", "bodyText": "Yeah, I was trying to play with the IRecipeSerializer one, but it kept fighting me. IRecipeSerializer contains within it a Serializer definition, which I don't have.", "author": "Draco18s", "createdAt": "2020-01-07T22:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MTA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAwMzY4OQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r364003689", "bodyText": "Figured this one out. Involved moving the functionality down to the base class instead of in the interface default, but that's fine. There had been a part of the implementation in IRecipeSerializer that I overlooked.", "author": "Draco18s", "createdAt": "2020-01-07T23:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MTA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2Mjg4MA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363962880", "bodyText": "This system is completely messed up, you're creating a new instance every time a MinecraftServer is created, such as whenever a single player world is loaded.\nBetter to stop using a static context and instead give some other way of getting the manager.", "author": "LexManos", "createdAt": "2020-01-07T21:37:01Z", "path": "src/main/java/net/minecraftforge/common/loot/LootModifierManager.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package net.minecraftforge.common.loot;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+//import static net.minecraft.client.resources.JsonReloadListener.LOGGER;\n+\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraft.world.storage.loot.conditions.LootConditionManager;\n+import net.minecraft.world.storage.loot.functions.ILootFunction;\n+import net.minecraft.world.storage.loot.functions.LootFunctionManager;\n+import net.minecraftforge.fml.LogicalSide;\n+import net.minecraftforge.fml.common.thread.EffectiveSide;\n+import net.minecraftforge.registries.ForgeRegistries;\n+\n+public class LootModifierManager extends JsonReloadListener {\n+    private static LootModifierManager instance;\n+    public static final Logger LOGGER = LogManager.getLogger();\n+    private static final Gson GSON_INSTANCE = (new GsonBuilder()).registerTypeHierarchyAdapter(ILootFunction.class, new LootFunctionManager.Serializer()).registerTypeHierarchyAdapter(ILootCondition.class, new LootConditionManager.Serializer()).create();\n+\n+    private Map<ResourceLocation, IGlobalLootModifier> registeredLootModifiers = ImmutableMap.of();\n+\n+    public LootModifierManager() {\n+        super(GSON_INSTANCE, \"loot_modifiers\");\n+        instance = this;\n+    }\n+\n+    public static LootModifierManager getInstance() {", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4MTg3Nw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363981877", "bodyText": "The only other option is to request it from the MinecraftServer instance. Which I didn't do as it would both make it annoying to get at or make the patch to MinecraftServer larger. I'm open to alternatives.", "author": "Draco18s", "createdAt": "2020-01-07T22:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2Mjg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4MzIxMw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363983213", "bodyText": "What would it take to get the server instance to where it needs to be?\nAnd the 'larger' patch would just be a 2 line accessor.", "author": "LexManos", "createdAt": "2020-01-07T22:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2Mjg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4Njc3Mg==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363986772", "bodyText": "MinecraftServer does not have an accessor except via a World object (and a ServerWorld at that). I'm fine going that route, but I'm in the dark about what's \"best practice\" here.", "author": "Draco18s", "createdAt": "2020-01-07T22:39:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2Mjg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4OTQ5NA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363989494", "bodyText": "If world accessible in context? Then ya, go through it. Going through several getters isn't that big of a deal.", "author": "LexManos", "createdAt": "2020-01-07T22:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2Mjg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2MzU2Mw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363963563", "bodyText": "This is a custom class, which means we don't have to use the same parameter names. So... use real names here... splashList is DEFINITLY not a list of splashes", "author": "LexManos", "createdAt": "2020-01-07T21:38:43Z", "path": "src/main/java/net/minecraftforge/common/loot/LootModifierManager.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package net.minecraftforge.common.loot;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+//import static net.minecraft.client.resources.JsonReloadListener.LOGGER;\n+\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+\n+import net.minecraft.client.resources.JsonReloadListener;\n+import net.minecraft.profiler.IProfiler;\n+import net.minecraft.resources.IResourceManager;\n+import net.minecraft.server.MinecraftServer;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraft.world.storage.loot.conditions.LootConditionManager;\n+import net.minecraft.world.storage.loot.functions.ILootFunction;\n+import net.minecraft.world.storage.loot.functions.LootFunctionManager;\n+import net.minecraftforge.fml.LogicalSide;\n+import net.minecraftforge.fml.common.thread.EffectiveSide;\n+import net.minecraftforge.registries.ForgeRegistries;\n+\n+public class LootModifierManager extends JsonReloadListener {\n+    private static LootModifierManager instance;\n+    public static final Logger LOGGER = LogManager.getLogger();\n+    private static final Gson GSON_INSTANCE = (new GsonBuilder()).registerTypeHierarchyAdapter(ILootFunction.class, new LootFunctionManager.Serializer()).registerTypeHierarchyAdapter(ILootCondition.class, new LootConditionManager.Serializer()).create();\n+\n+    private Map<ResourceLocation, IGlobalLootModifier> registeredLootModifiers = ImmutableMap.of();\n+\n+    public LootModifierManager() {\n+        super(GSON_INSTANCE, \"loot_modifiers\");\n+        instance = this;\n+    }\n+\n+    public static LootModifierManager getInstance() {\n+        return instance;\n+    }\n+\n+    @Override\n+    protected void apply(Map<ResourceLocation, JsonObject> splashList, IResourceManager resourceManagerIn, IProfiler profilerIn) {", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2NDUyMA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363964520", "bodyText": "no", "author": "LexManos", "createdAt": "2020-01-07T21:41:10Z", "path": "src/test/java/net/minecraftforge/debug/gameplay/loot/GlobalLootModifiersTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package net.minecraftforge.debug.gameplay.loot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.google.gson.JsonObject;\n+\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.enchantment.Enchantment.Rarity;\n+import net.minecraft.enchantment.EnchantmentHelper;\n+import net.minecraft.enchantment.EnchantmentType;\n+import net.minecraft.enchantment.Enchantments;\n+import net.minecraft.inventory.EquipmentSlotType;\n+import net.minecraft.inventory.Inventory;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.crafting.FurnaceRecipe;\n+import net.minecraft.item.crafting.IRecipeType;\n+import net.minecraft.util.JSONUtils;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.LootContext;\n+import net.minecraft.world.storage.loot.LootParameterSets;\n+import net.minecraft.world.storage.loot.LootParameters;\n+import net.minecraft.world.storage.loot.LootTable;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraftforge.common.ModDimension;\n+import net.minecraftforge.common.loot.IGlobalLootModifierSerializer;\n+import net.minecraftforge.common.loot.LootModifier;\n+import net.minecraftforge.event.RegistryEvent;\n+import net.minecraftforge.eventbus.api.SubscribeEvent;\n+import net.minecraftforge.fml.common.Mod;\n+import net.minecraftforge.fml.common.Mod.EventBusSubscriber;\n+import net.minecraftforge.items.ItemHandlerHelper;\n+import net.minecraftforge.registries.ForgeRegistries;\n+import net.minecraftforge.registries.ObjectHolder;\n+\n+@Mod(GlobalLootModifiersTest.MODID)\n+public class GlobalLootModifiersTest {\n+    public static final String MODID = \"global_loot_test\";\n+    public static final boolean ENABLE = true;\n+    @ObjectHolder(value = MODID)\n+    public static final Enchantment smelt = null;\n+    public GlobalLootModifiersTest() { }\n+\n+    @EventBusSubscriber(modid = MODID, bus = EventBusSubscriber.Bus.MOD)\n+    public static class EventHandlers {\n+        @SubscribeEvent\n+        public static void registerEnchantments(@Nonnull final RegistryEvent.Register<Enchantment> event) {\n+            if (ENABLE) {\n+                event.getRegistry().register(new SmelterEnchantment(Rarity.UNCOMMON, EnchantmentType.DIGGER, new EquipmentSlotType[] {EquipmentSlotType.MAINHAND}).setRegistryName(new ResourceLocation(MODID,\"smelt\")));\n+            }\n+        }\n+\n+        @SubscribeEvent\n+        public static void registerModifierSerializers(@Nonnull final RegistryEvent.Register<IGlobalLootModifierSerializer<?>> event) {\n+            if (ENABLE) {\n+                event.getRegistry().register(\n+                \t\tnew WheatSeedsConverterModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"wheat_harvest\"))\n+                );\n+                event.getRegistry().register(new SmeltingEnchantmentModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"smelting\")));\n+                event.getRegistry().register(new SilkTouchTestModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"silk_touch_bamboo\")));\n+            }\n+        }\n+    }\n+\n+    private static class SmelterEnchantment extends Enchantment {\n+        protected SmelterEnchantment(Rarity rarityIn, EnchantmentType typeIn, EquipmentSlotType[] slots) {\n+            super(rarityIn, typeIn, slots);\n+        }\n+    }\n+\n+    /**\n+     * The smelting enchantment causes this modifier to be invoked, via the smelting loot_modifier json\n+     * @author Draco18s", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4MTQ0MQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363981441", "bodyText": "No what? \"Don't put javadoc\" \"don't put @author\"? What am I doing wrong?", "author": "Draco18s", "createdAt": "2020-01-07T22:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2NDUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4Mjg1Mg==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363982852", "bodyText": "I did ti specifically on the author line, so it's about the @author, we don't do that in Forge.\nJavadocs are good, Ego stroking is bad. {Not saying that's what you're doing but you get enough credit in the git log it doesn't need to be in the source}", "author": "LexManos", "createdAt": "2020-01-07T22:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2NDUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4NzIzNg==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363987236", "bodyText": "The comment widget includes four lines of code and doesn't indicate exactly which line you pinged. Removing @author, got it. Thanks. I didn't put it to stoke my ego, it was added automatically when I inserted the javadoc.", "author": "Draco18s", "createdAt": "2020-01-07T22:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2NDUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4ODY1Mg==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363988652", "bodyText": "Just for future reference, the widget will always show on the line that it was commented on, the 3 lines above it are for context.", "author": "LexManos", "createdAt": "2020-01-07T22:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2NDUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk5MDAxMA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363990010", "bodyText": "Fair enough. Just with the Github UI was a little better, I guess. Anyway, removing those lines is easy enough.", "author": "Draco18s", "createdAt": "2020-01-07T22:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2NDUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2NzU1MA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363967550", "bodyText": "No", "author": "LexManos", "createdAt": "2020-01-07T21:48:48Z", "path": "src/test/java/net/minecraftforge/debug/gameplay/loot/GlobalLootModifiersTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package net.minecraftforge.debug.gameplay.loot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.google.gson.JsonObject;\n+\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.enchantment.Enchantment.Rarity;\n+import net.minecraft.enchantment.EnchantmentHelper;\n+import net.minecraft.enchantment.EnchantmentType;\n+import net.minecraft.enchantment.Enchantments;\n+import net.minecraft.inventory.EquipmentSlotType;\n+import net.minecraft.inventory.Inventory;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.crafting.FurnaceRecipe;\n+import net.minecraft.item.crafting.IRecipeType;\n+import net.minecraft.util.JSONUtils;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.LootContext;\n+import net.minecraft.world.storage.loot.LootParameterSets;\n+import net.minecraft.world.storage.loot.LootParameters;\n+import net.minecraft.world.storage.loot.LootTable;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraftforge.common.ModDimension;\n+import net.minecraftforge.common.loot.IGlobalLootModifierSerializer;\n+import net.minecraftforge.common.loot.LootModifier;\n+import net.minecraftforge.event.RegistryEvent;\n+import net.minecraftforge.eventbus.api.SubscribeEvent;\n+import net.minecraftforge.fml.common.Mod;\n+import net.minecraftforge.fml.common.Mod.EventBusSubscriber;\n+import net.minecraftforge.items.ItemHandlerHelper;\n+import net.minecraftforge.registries.ForgeRegistries;\n+import net.minecraftforge.registries.ObjectHolder;\n+\n+@Mod(GlobalLootModifiersTest.MODID)\n+public class GlobalLootModifiersTest {\n+    public static final String MODID = \"global_loot_test\";\n+    public static final boolean ENABLE = true;\n+    @ObjectHolder(value = MODID)\n+    public static final Enchantment smelt = null;\n+    public GlobalLootModifiersTest() { }\n+\n+    @EventBusSubscriber(modid = MODID, bus = EventBusSubscriber.Bus.MOD)\n+    public static class EventHandlers {\n+        @SubscribeEvent\n+        public static void registerEnchantments(@Nonnull final RegistryEvent.Register<Enchantment> event) {\n+            if (ENABLE) {\n+                event.getRegistry().register(new SmelterEnchantment(Rarity.UNCOMMON, EnchantmentType.DIGGER, new EquipmentSlotType[] {EquipmentSlotType.MAINHAND}).setRegistryName(new ResourceLocation(MODID,\"smelt\")));\n+            }\n+        }\n+\n+        @SubscribeEvent\n+        public static void registerModifierSerializers(@Nonnull final RegistryEvent.Register<IGlobalLootModifierSerializer<?>> event) {\n+            if (ENABLE) {\n+                event.getRegistry().register(\n+                \t\tnew WheatSeedsConverterModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"wheat_harvest\"))\n+                );\n+                event.getRegistry().register(new SmeltingEnchantmentModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"smelting\")));\n+                event.getRegistry().register(new SilkTouchTestModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"silk_touch_bamboo\")));\n+            }\n+        }\n+    }\n+\n+    private static class SmelterEnchantment extends Enchantment {\n+        protected SmelterEnchantment(Rarity rarityIn, EnchantmentType typeIn, EquipmentSlotType[] slots) {\n+            super(rarityIn, typeIn, slots);\n+        }\n+    }\n+\n+    /**\n+     * The smelting enchantment causes this modifier to be invoked, via the smelting loot_modifier json\n+     * @author Draco18s\n+     *\n+     */\n+    private static class SmeltingEnchantmentModifier extends LootModifier {\n+        public SmeltingEnchantmentModifier(ResourceLocation name, ILootCondition[] conditionsIn) {\n+            super(conditionsIn);\n+\n+        }\n+\n+        @Override\n+        public List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context) {\n+            ArrayList<ItemStack> ret = new ArrayList<ItemStack>();\n+            generatedLoot.forEach((stack) -> ret.add(smelt(stack, context)));\n+            return ret;\n+        }\n+\n+        private static ItemStack smelt(ItemStack stack, LootContext context) {\n+            return context.getWorld().getRecipeManager().getRecipe(IRecipeType.SMELTING, new Inventory(stack), context.getWorld())\n+                    .map(FurnaceRecipe::getRecipeOutput)\n+                    .filter(itemStack -> !itemStack.isEmpty())\n+                    .map(itemStack -> ItemHandlerHelper.copyStackWithSize(itemStack, stack.getCount() * itemStack.getCount()))\n+                    .orElse(stack);\n+        }\n+\n+        private static class Serializer extends LootModifier.Serializer<SmeltingEnchantmentModifier> {\n+            @Override\n+            public SmeltingEnchantmentModifier read(ResourceLocation name, JsonObject json, ILootCondition[] conditionsIn) {\n+                return new SmeltingEnchantmentModifier(name, conditionsIn);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When harvesting blocks with bamboo, this modifier is invoked, via the silk_touch_bamboo loot_modifier json\n+     * @author Draco18s", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2ODA4NA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363968084", "bodyText": "What is the point of this?", "author": "LexManos", "createdAt": "2020-01-07T21:50:06Z", "path": "src/test/java/net/minecraftforge/debug/gameplay/loot/GlobalLootModifiersTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package net.minecraftforge.debug.gameplay.loot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.google.gson.JsonObject;\n+\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.enchantment.Enchantment.Rarity;\n+import net.minecraft.enchantment.EnchantmentHelper;\n+import net.minecraft.enchantment.EnchantmentType;\n+import net.minecraft.enchantment.Enchantments;\n+import net.minecraft.inventory.EquipmentSlotType;\n+import net.minecraft.inventory.Inventory;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.crafting.FurnaceRecipe;\n+import net.minecraft.item.crafting.IRecipeType;\n+import net.minecraft.util.JSONUtils;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.LootContext;\n+import net.minecraft.world.storage.loot.LootParameterSets;\n+import net.minecraft.world.storage.loot.LootParameters;\n+import net.minecraft.world.storage.loot.LootTable;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraftforge.common.ModDimension;\n+import net.minecraftforge.common.loot.IGlobalLootModifierSerializer;\n+import net.minecraftforge.common.loot.LootModifier;\n+import net.minecraftforge.event.RegistryEvent;\n+import net.minecraftforge.eventbus.api.SubscribeEvent;\n+import net.minecraftforge.fml.common.Mod;\n+import net.minecraftforge.fml.common.Mod.EventBusSubscriber;\n+import net.minecraftforge.items.ItemHandlerHelper;\n+import net.minecraftforge.registries.ForgeRegistries;\n+import net.minecraftforge.registries.ObjectHolder;\n+\n+@Mod(GlobalLootModifiersTest.MODID)\n+public class GlobalLootModifiersTest {\n+    public static final String MODID = \"global_loot_test\";\n+    public static final boolean ENABLE = true;\n+    @ObjectHolder(value = MODID)\n+    public static final Enchantment smelt = null;\n+    public GlobalLootModifiersTest() { }\n+\n+    @EventBusSubscriber(modid = MODID, bus = EventBusSubscriber.Bus.MOD)\n+    public static class EventHandlers {\n+        @SubscribeEvent\n+        public static void registerEnchantments(@Nonnull final RegistryEvent.Register<Enchantment> event) {\n+            if (ENABLE) {\n+                event.getRegistry().register(new SmelterEnchantment(Rarity.UNCOMMON, EnchantmentType.DIGGER, new EquipmentSlotType[] {EquipmentSlotType.MAINHAND}).setRegistryName(new ResourceLocation(MODID,\"smelt\")));\n+            }\n+        }\n+\n+        @SubscribeEvent\n+        public static void registerModifierSerializers(@Nonnull final RegistryEvent.Register<IGlobalLootModifierSerializer<?>> event) {\n+            if (ENABLE) {\n+                event.getRegistry().register(\n+                \t\tnew WheatSeedsConverterModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"wheat_harvest\"))\n+                );\n+                event.getRegistry().register(new SmeltingEnchantmentModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"smelting\")));\n+                event.getRegistry().register(new SilkTouchTestModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"silk_touch_bamboo\")));\n+            }\n+        }\n+    }\n+\n+    private static class SmelterEnchantment extends Enchantment {\n+        protected SmelterEnchantment(Rarity rarityIn, EnchantmentType typeIn, EquipmentSlotType[] slots) {\n+            super(rarityIn, typeIn, slots);\n+        }\n+    }\n+\n+    /**\n+     * The smelting enchantment causes this modifier to be invoked, via the smelting loot_modifier json\n+     * @author Draco18s\n+     *\n+     */\n+    private static class SmeltingEnchantmentModifier extends LootModifier {\n+        public SmeltingEnchantmentModifier(ResourceLocation name, ILootCondition[] conditionsIn) {\n+            super(conditionsIn);\n+\n+        }\n+\n+        @Override\n+        public List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context) {\n+            ArrayList<ItemStack> ret = new ArrayList<ItemStack>();\n+            generatedLoot.forEach((stack) -> ret.add(smelt(stack, context)));\n+            return ret;\n+        }\n+\n+        private static ItemStack smelt(ItemStack stack, LootContext context) {\n+            return context.getWorld().getRecipeManager().getRecipe(IRecipeType.SMELTING, new Inventory(stack), context.getWorld())\n+                    .map(FurnaceRecipe::getRecipeOutput)\n+                    .filter(itemStack -> !itemStack.isEmpty())\n+                    .map(itemStack -> ItemHandlerHelper.copyStackWithSize(itemStack, stack.getCount() * itemStack.getCount()))\n+                    .orElse(stack);\n+        }\n+\n+        private static class Serializer extends LootModifier.Serializer<SmeltingEnchantmentModifier> {\n+            @Override\n+            public SmeltingEnchantmentModifier read(ResourceLocation name, JsonObject json, ILootCondition[] conditionsIn) {\n+                return new SmeltingEnchantmentModifier(name, conditionsIn);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When harvesting blocks with bamboo, this modifier is invoked, via the silk_touch_bamboo loot_modifier json\n+     * @author Draco18s\n+     *\n+     */\n+    private static class SilkTouchTestModifier extends LootModifier {\n+        public SilkTouchTestModifier(ResourceLocation name, ILootCondition[] conditionsIn) {\n+            super(conditionsIn);\n+        }\n+\n+        @Override\n+        public List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context) {\n+            ItemStack ctxTool = context.get(LootParameters.TOOL);\n+            ItemStack fakeTool = ctxTool.copy();\n+            fakeTool.addEnchantment(Enchantments.SILK_TOUCH, 1);\n+            if(ItemStack.areItemsEqual(ctxTool, fakeTool) && EnchantmentHelper.getEnchantments(ctxTool).containsKey(Enchantments.SILK_TOUCH)) return generatedLoot;", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4MDQ4MQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363980481", "bodyText": "This goes back to comments @williewillus made. Boils down to \"you can't just get the block's item form.\"\n#5871 (comment)\nIf I've implemented a test mod incorrectly, I'm not sure what to say. Its a stand-in for something a modder would do, its not shipped code.", "author": "Draco18s", "createdAt": "2020-01-07T22:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2ODA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4MjM3OQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363982379", "bodyText": "Test mods also are used as examples, and unfortunately copy/pasted by idiot modders.\nPerhaps this particular modifier would be better served as a pre-processor, something that can always add the enchantment for silk touch to the context? Instead of trying to figure out how to reproduce something after the fact.", "author": "LexManos", "createdAt": "2020-01-07T22:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2ODA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4ODk4Mg==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363988982", "bodyText": "LootContext objects are private final, so there's no way to \"add\" to it. Yes, it could be modified with reflection, but I don't think that's the appropriate action to take.\n(But I'm fine being wrong)", "author": "Draco18s", "createdAt": "2020-01-07T22:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2ODA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2ODQwNA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363968404", "bodyText": "This seems super bad, why are you rebuilding the entire context? How can you possibly know the context and what parts need copying?", "author": "LexManos", "createdAt": "2020-01-07T21:50:48Z", "path": "src/test/java/net/minecraftforge/debug/gameplay/loot/GlobalLootModifiersTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package net.minecraftforge.debug.gameplay.loot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.google.gson.JsonObject;\n+\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.enchantment.Enchantment.Rarity;\n+import net.minecraft.enchantment.EnchantmentHelper;\n+import net.minecraft.enchantment.EnchantmentType;\n+import net.minecraft.enchantment.Enchantments;\n+import net.minecraft.inventory.EquipmentSlotType;\n+import net.minecraft.inventory.Inventory;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.crafting.FurnaceRecipe;\n+import net.minecraft.item.crafting.IRecipeType;\n+import net.minecraft.util.JSONUtils;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.LootContext;\n+import net.minecraft.world.storage.loot.LootParameterSets;\n+import net.minecraft.world.storage.loot.LootParameters;\n+import net.minecraft.world.storage.loot.LootTable;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraftforge.common.ModDimension;\n+import net.minecraftforge.common.loot.IGlobalLootModifierSerializer;\n+import net.minecraftforge.common.loot.LootModifier;\n+import net.minecraftforge.event.RegistryEvent;\n+import net.minecraftforge.eventbus.api.SubscribeEvent;\n+import net.minecraftforge.fml.common.Mod;\n+import net.minecraftforge.fml.common.Mod.EventBusSubscriber;\n+import net.minecraftforge.items.ItemHandlerHelper;\n+import net.minecraftforge.registries.ForgeRegistries;\n+import net.minecraftforge.registries.ObjectHolder;\n+\n+@Mod(GlobalLootModifiersTest.MODID)\n+public class GlobalLootModifiersTest {\n+    public static final String MODID = \"global_loot_test\";\n+    public static final boolean ENABLE = true;\n+    @ObjectHolder(value = MODID)\n+    public static final Enchantment smelt = null;\n+    public GlobalLootModifiersTest() { }\n+\n+    @EventBusSubscriber(modid = MODID, bus = EventBusSubscriber.Bus.MOD)\n+    public static class EventHandlers {\n+        @SubscribeEvent\n+        public static void registerEnchantments(@Nonnull final RegistryEvent.Register<Enchantment> event) {\n+            if (ENABLE) {\n+                event.getRegistry().register(new SmelterEnchantment(Rarity.UNCOMMON, EnchantmentType.DIGGER, new EquipmentSlotType[] {EquipmentSlotType.MAINHAND}).setRegistryName(new ResourceLocation(MODID,\"smelt\")));\n+            }\n+        }\n+\n+        @SubscribeEvent\n+        public static void registerModifierSerializers(@Nonnull final RegistryEvent.Register<IGlobalLootModifierSerializer<?>> event) {\n+            if (ENABLE) {\n+                event.getRegistry().register(\n+                \t\tnew WheatSeedsConverterModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"wheat_harvest\"))\n+                );\n+                event.getRegistry().register(new SmeltingEnchantmentModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"smelting\")));\n+                event.getRegistry().register(new SilkTouchTestModifier.Serializer().setRegistryName(new ResourceLocation(MODID,\"silk_touch_bamboo\")));\n+            }\n+        }\n+    }\n+\n+    private static class SmelterEnchantment extends Enchantment {\n+        protected SmelterEnchantment(Rarity rarityIn, EnchantmentType typeIn, EquipmentSlotType[] slots) {\n+            super(rarityIn, typeIn, slots);\n+        }\n+    }\n+\n+    /**\n+     * The smelting enchantment causes this modifier to be invoked, via the smelting loot_modifier json\n+     * @author Draco18s\n+     *\n+     */\n+    private static class SmeltingEnchantmentModifier extends LootModifier {\n+        public SmeltingEnchantmentModifier(ResourceLocation name, ILootCondition[] conditionsIn) {\n+            super(conditionsIn);\n+\n+        }\n+\n+        @Override\n+        public List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context) {\n+            ArrayList<ItemStack> ret = new ArrayList<ItemStack>();\n+            generatedLoot.forEach((stack) -> ret.add(smelt(stack, context)));\n+            return ret;\n+        }\n+\n+        private static ItemStack smelt(ItemStack stack, LootContext context) {\n+            return context.getWorld().getRecipeManager().getRecipe(IRecipeType.SMELTING, new Inventory(stack), context.getWorld())\n+                    .map(FurnaceRecipe::getRecipeOutput)\n+                    .filter(itemStack -> !itemStack.isEmpty())\n+                    .map(itemStack -> ItemHandlerHelper.copyStackWithSize(itemStack, stack.getCount() * itemStack.getCount()))\n+                    .orElse(stack);\n+        }\n+\n+        private static class Serializer extends LootModifier.Serializer<SmeltingEnchantmentModifier> {\n+            @Override\n+            public SmeltingEnchantmentModifier read(ResourceLocation name, JsonObject json, ILootCondition[] conditionsIn) {\n+                return new SmeltingEnchantmentModifier(name, conditionsIn);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When harvesting blocks with bamboo, this modifier is invoked, via the silk_touch_bamboo loot_modifier json\n+     * @author Draco18s\n+     *\n+     */\n+    private static class SilkTouchTestModifier extends LootModifier {\n+        public SilkTouchTestModifier(ResourceLocation name, ILootCondition[] conditionsIn) {\n+            super(conditionsIn);\n+        }\n+\n+        @Override\n+        public List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context) {\n+            ItemStack ctxTool = context.get(LootParameters.TOOL);\n+            ItemStack fakeTool = ctxTool.copy();\n+            fakeTool.addEnchantment(Enchantments.SILK_TOUCH, 1);\n+            if(ItemStack.areItemsEqual(ctxTool, fakeTool) && EnchantmentHelper.getEnchantments(ctxTool).containsKey(Enchantments.SILK_TOUCH)) return generatedLoot;\n+            LootContext.Builder builder = new LootContext.Builder(context.getWorld())\n+                    .withParameter(LootParameters.BLOCK_STATE, context.get(LootParameters.BLOCK_STATE))\n+                    .withRandom(context.getWorld().rand)\n+                    .withParameter(LootParameters.POSITION, context.get(LootParameters.POSITION))\n+                    .withParameter(LootParameters.TOOL, fakeTool)\n+                    .withNullableParameter(LootParameters.BLOCK_ENTITY, context.get(LootParameters.BLOCK_ENTITY));\n+            if(context.has(LootParameters.THIS_ENTITY)) {\n+                builder.withParameter(LootParameters.THIS_ENTITY, context.get(LootParameters.THIS_ENTITY));\n+            }", "originalCommit": "45c4f43904902afa50265ec7e23dbe02aea9eb35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk4MTIwNA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r363981204", "bodyText": "Again, test mod code, not shippable.", "author": "Draco18s", "createdAt": "2020-01-07T22:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2ODQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAwNTA3MA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r364005070", "bodyText": "And if there's a better way, I'd be happy to do it. This was what came up in the prior conversation. LootContext objects are private final and the context has to be cloned in order for the functionality to work, as the original context should not be modified (as it will get passed to future LootModifier handlers). If that means we need to patch in a Builder.FromContext of some kind, then fine, I'll do that.", "author": "Draco18s", "createdAt": "2020-01-07T23:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2ODQwNA=="}], "type": "inlineReview"}, {"oid": "e47219448ad08bcb2470ff36dc6749e5255ce318", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/e47219448ad08bcb2470ff36dc6749e5255ce318", "message": "Updates based on Lex's comments\n\nRemoved @author\nAdded a LootContext.Builder constructor that can clone a context object\nAdded javadoc\nMade LootModifierManager not a singleton", "committedDate": "2020-01-09T23:49:27Z", "type": "commit"}, {"oid": "9b0acd437905cfdb5b4df7ec3a4dc28c907f105f", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/9b0acd437905cfdb5b4df7ec3a4dc28c907f105f", "message": "Missing json files", "committedDate": "2020-01-13T19:46:46Z", "type": "commit"}, {"oid": "6807fd852ce35771460c6c1bc8e7407f0b8284f3", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/6807fd852ce35771460c6c1bc8e7407f0b8284f3", "message": "Refactor to read layered config file\n\nReads all.json to determine what loot modifiers to load. Functions like tags.", "committedDate": "2020-01-15T18:27:25Z", "type": "commit"}, {"oid": "444deb497617a7281ce73c625bb483bcef1c8110", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/444deb497617a7281ce73c625bb483bcef1c8110", "message": "Further refactor\n\nUpdated EntityLiving's call\nUpdated LootTable to mark previous entityliving entry as deprecated\nRenamed all.json to global_loot_modifiers.json\nRelocated test mod data resources to generated_test\nFixed setRegistryName implementation\nTabs to spaces\nRefactored json loading system making it simpler and less round about.", "committedDate": "2020-01-16T03:00:43Z", "type": "commit"}, {"oid": "3c18f0473503cca9e241d788898c6729f08924a5", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/3c18f0473503cca9e241d788898c6729f08924a5", "message": "Docs clean\n\nCleaned up javadoc wording in several places\nMade setRegistryName final", "committedDate": "2020-01-16T04:26:23Z", "type": "commit"}, {"oid": "92bf134434d0e7c6eb5c612aa2315927b1c368dc", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/92bf134434d0e7c6eb5c612aa2315927b1c368dc", "message": "Wordsmithing\n\nAdjusted javadoc, added @nonnull annotations", "committedDate": "2020-01-18T03:15:56Z", "type": "commit"}, {"oid": "0b402ce23c60ea45d7718352c69c8f852c368959", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/0b402ce23c60ea45d7718352c69c8f852c368959", "message": "Merge branch '1.15.x' into Global-Loot-Funcs-1.15\n\n# Conflicts:\n#\tpatches/minecraft/net/minecraft/entity/LivingEntity.java.patch\n#\tpatches/minecraft/net/minecraft/server/MinecraftServer.java.patch\n#\tsrc/test/resources/META-INF/mods.toml", "committedDate": "2020-01-30T23:18:54Z", "type": "commit"}, {"oid": "7e08eba6ba1dfcdb9d2272728fa6a1343367b6be", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/7e08eba6ba1dfcdb9d2272728fa6a1343367b6be", "message": "Merge branch '1.15.x' into Global-Loot-Funcs-1.15", "committedDate": "2020-02-15T20:26:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxNzA5Nw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r381317097", "bodyText": "Shouldn't this be extending ForgeRegistryEntry<IGlobalLootModifierSerializer<?>> instead of implementing IForgeRegsitryEntry<T> by hand?\nActually, I wonder if it wouldn't be best to make IGlobalLootModifierSerializer an abstract class instead, then subclasses wouldn't need to worry about IForgeRegsitryEntry", "author": "gigaherz", "createdAt": "2020-02-19T14:16:48Z", "path": "src/main/java/net/minecraftforge/common/loot/LootModifier.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package net.minecraftforge.common.loot;\n+\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.google.gson.JsonObject;\n+\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.util.ResourceLocation;\n+import net.minecraft.world.storage.loot.LootContext;\n+import net.minecraft.world.storage.loot.conditions.ILootCondition;\n+import net.minecraft.world.storage.loot.conditions.LootConditionManager;\n+import net.minecraftforge.registries.GameData;\n+\n+/**\n+ * A base implementation of a Global Loot Modifier for modders to extend.\n+ * Takes care of ILootCondition matching and comes with a base serializer\n+ * implementation that takes care of Forge registry things.\n+ */\n+public abstract class LootModifier implements IGlobalLootModifier {\n+    protected final ILootCondition[] conditions;\n+    private final Predicate<LootContext> combinedConditions;\n+    \n+    /**\n+     * Constructs a LootModifier.\n+     * @param conditionsIn the ILootConditions that need to be matched before the loot is modified.\n+     */\n+    protected LootModifier(ILootCondition[] conditionsIn) {\n+        this.conditions = conditionsIn;\n+        this.combinedConditions = LootConditionManager.and(conditionsIn);\n+    }\n+    \n+    @Nonnull\n+    @Override\n+    public final List<ItemStack> apply(List<ItemStack> generatedLoot, LootContext context) {\n+        return this.combinedConditions.test(context) ? this.doApply(generatedLoot, context) : generatedLoot;\n+    }\n+    \n+    /**\n+     * Applies the modifier to the generated loot (all loot conditions have already been checked\n+     * and have returned true).\n+     * @param generatedLoot the list of ItemStacks that will be dropped, generated by loot tables\n+     * @param context the LootContext, identical to what is passed to loot tables\n+     * @return modified loot drops\n+     */\n+    @Nonnull\n+    protected abstract List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context);\n+    \n+    /**\n+     * Abstract base deserializer for LootModifiers. Takes care of Forge registry things.<br/>\n+     * Modders should extend this class to return their modifier and implement the abstract\n+     * <code>read</code> method to deserialize from json.\n+     * @param <T> the final Type\n+     */\n+    public abstract static class Serializer<T extends LootModifier> implements IGlobalLootModifierSerializer<T> {", "originalCommit": "7e08eba6ba1dfcdb9d2272728fa6a1343367b6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM0MjUyOA==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r381342528", "bodyText": "Hmm, cursory check shows that that is doable (it ran and didn't crash, can't check more than that at this instant).", "author": "Draco18s", "createdAt": "2020-02-19T14:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxNzA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NzQ2OQ==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r381597469", "bodyText": "Yep, it works fine that way (had just wanted to verify that things were still being loaded and the test mod working). I personally don't care if its an interface or an abstract class, but it does seem cleaner/easier on the modder as the abstract class.", "author": "Draco18s", "createdAt": "2020-02-19T23:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxNzA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMTM2Ng==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r381601366", "bodyText": "The main reason to use an interface over an abstract class, is that you don't force users into a specific implementation, since they can implement that interface anywhere they like.\nHowever I'd argue that in this case, there isn't much point of keeping it an interface? People shouldn't be making any random object their loot modifier serializer.", "author": "gigaherz", "createdAt": "2020-02-19T23:11:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxNzA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMzU4Nw==", "url": "https://github.com/MinecraftForge/MinecraftForge/pull/6401#discussion_r381603587", "bodyText": "Yep, agreed. There was nothing in the abstract implementation that a modder needed to touch, so I pushed it upwards and made it final.", "author": "Draco18s", "createdAt": "2020-02-19T23:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxNzA5Nw=="}], "type": "inlineReview"}, {"oid": "e07b29bce91fed25f06efc5a5a4807c45d5361b0", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/e07b29bce91fed25f06efc5a5a4807c45d5361b0", "message": "Changed from Interface to Abstract Class\n\nGlobalLootModifierSerializer is now an abstract class and the abstract implementation in LootModifier was no longer needed.", "committedDate": "2020-02-19T23:17:21Z", "type": "commit"}, {"oid": "d4b6540746ce5676a9a2efe24b87debb3f79dfe7", "url": "https://github.com/MinecraftForge/MinecraftForge/commit/d4b6540746ce5676a9a2efe24b87debb3f79dfe7", "message": "Stray tab", "committedDate": "2020-02-20T01:54:57Z", "type": "commit"}]}