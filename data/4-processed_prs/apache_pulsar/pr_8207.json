{"pr_number": 8207, "pr_title": "Remove unnecessary locks", "pr_createdAt": "2020-10-06T02:44:58Z", "pr_url": "https://github.com/apache/pulsar/pull/8207", "timeline": [{"oid": "ac48262d4fa431de0364391cc585c9694fefd581", "url": "https://github.com/apache/pulsar/commit/ac48262d4fa431de0364391cc585c9694fefd581", "message": "remove lock", "committedDate": "2020-10-06T02:38:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2Nzg3NA==", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500767874", "bodyText": "we are now using only writeLock so we could use a simple ReentrantLock and not a ReentrantReadWriteLock", "author": "eolivelli", "createdAt": "2020-10-07T06:33:39Z", "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java", "diffHunk": "@@ -219,51 +219,44 @@ private void receiveMessageFromConsumer(ConsumerImpl<T> consumer) {\n             messageReceived(consumer, message);\n \n             // we're modifying pausedConsumers\n-            lock.writeLock().lock();\n-            try {\n-                int size = incomingMessages.size();\n-                if (size >= maxReceiverQueueSize\n-                        || (size > sharedQueueResumeThreshold && !pausedConsumers.isEmpty())) {\n-                    // mark this consumer to be resumed later: if No more space left in shared queue,\n-                    // or if any consumer is already paused (to create fair chance for already paused consumers)\n-                    pausedConsumers.add(consumer);\n-                } else {\n-                    // Schedule next receiveAsync() if the incoming queue is not full. Use a different thread to avoid\n-                    // recursion and stack overflow\n-                    client.eventLoopGroup().execute(() -> {\n-                        receiveMessageFromConsumer(consumer);\n-                    });\n-                }\n-            } finally {\n-                lock.writeLock().unlock();\n+            int size = incomingMessages.size();\n+            if (size >= maxReceiverQueueSize\n+                    || (size > sharedQueueResumeThreshold && !pausedConsumers.isEmpty())) {\n+                // mark this consumer to be resumed later: if No more space left in shared queue,\n+                // or if any consumer is already paused (to create fair chance for already paused consumers)\n+                pausedConsumers.add(consumer);\n+            } else {\n+                // Schedule next receiveAsync() if the incoming queue is not full. Use a different thread to avoid\n+                // recursion and stack overflow\n+                client.eventLoopGroup().execute(() -> {\n+                    receiveMessageFromConsumer(consumer);\n+                });\n             }\n         });\n     }\n \n     private void messageReceived(ConsumerImpl<T> consumer, Message<T> message) {\n         checkArgument(message instanceof MessageImpl);\n-        lock.writeLock().lock();\n-        try {\n-            TopicMessageImpl<T> topicMessage = new TopicMessageImpl<>(\n+        TopicMessageImpl<T> topicMessage = new TopicMessageImpl<>(\n                 consumer.getTopic(), consumer.getTopicNameWithoutPartition(), message);\n \n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}][{}] Received message from topics-consumer {}\",\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}][{}] Received message from topics-consumer {}\",\n                     topic, subscription, message.getMessageId());\n-            }\n+        }\n \n-            // if asyncReceive is waiting : return message to callback without adding to incomingMessages queue\n-            if (!pendingReceives.isEmpty()) {\n-                CompletableFuture<Message<T>> receivedFuture = pendingReceives.poll();\n-                unAckedMessageTracker.add(topicMessage.getMessageId());\n-                listenerExecutor.execute(() -> receivedFuture.complete(topicMessage));\n-            } else if (enqueueMessageAndCheckBatchReceive(topicMessage)) {\n-                if (hasPendingBatchReceive()) {\n-                    notifyPendingBatchReceivedCallBack();\n-                }\n+        // if asyncReceive is waiting : return message to callback without adding to incomingMessages queue\n+        CompletableFuture<Message<T>> receivedFuture = pendingReceives.poll();\n+        if (receivedFuture != null) {\n+            unAckedMessageTracker.add(topicMessage.getMessageId());\n+            listenerExecutor.execute(() -> receivedFuture.complete(topicMessage));\n+        } else if (enqueueMessageAndCheckBatchReceive(topicMessage) && hasPendingBatchReceive()) {\n+            try {\n+                lock.writeLock().lock();", "originalCommit": "ac48262d4fa431de0364391cc585c9694fefd581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2ODExMw==", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500768113", "bodyText": "not every call of this notifyPendingBatchReceivedCallBack method are guarded by the lock, do we need to use the lock here ?", "author": "eolivelli", "createdAt": "2020-10-07T06:34:17Z", "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java", "diffHunk": "@@ -219,51 +219,44 @@ private void receiveMessageFromConsumer(ConsumerImpl<T> consumer) {\n             messageReceived(consumer, message);\n \n             // we're modifying pausedConsumers\n-            lock.writeLock().lock();\n-            try {\n-                int size = incomingMessages.size();\n-                if (size >= maxReceiverQueueSize\n-                        || (size > sharedQueueResumeThreshold && !pausedConsumers.isEmpty())) {\n-                    // mark this consumer to be resumed later: if No more space left in shared queue,\n-                    // or if any consumer is already paused (to create fair chance for already paused consumers)\n-                    pausedConsumers.add(consumer);\n-                } else {\n-                    // Schedule next receiveAsync() if the incoming queue is not full. Use a different thread to avoid\n-                    // recursion and stack overflow\n-                    client.eventLoopGroup().execute(() -> {\n-                        receiveMessageFromConsumer(consumer);\n-                    });\n-                }\n-            } finally {\n-                lock.writeLock().unlock();\n+            int size = incomingMessages.size();\n+            if (size >= maxReceiverQueueSize\n+                    || (size > sharedQueueResumeThreshold && !pausedConsumers.isEmpty())) {\n+                // mark this consumer to be resumed later: if No more space left in shared queue,\n+                // or if any consumer is already paused (to create fair chance for already paused consumers)\n+                pausedConsumers.add(consumer);\n+            } else {\n+                // Schedule next receiveAsync() if the incoming queue is not full. Use a different thread to avoid\n+                // recursion and stack overflow\n+                client.eventLoopGroup().execute(() -> {\n+                    receiveMessageFromConsumer(consumer);\n+                });\n             }\n         });\n     }\n \n     private void messageReceived(ConsumerImpl<T> consumer, Message<T> message) {\n         checkArgument(message instanceof MessageImpl);\n-        lock.writeLock().lock();\n-        try {\n-            TopicMessageImpl<T> topicMessage = new TopicMessageImpl<>(\n+        TopicMessageImpl<T> topicMessage = new TopicMessageImpl<>(\n                 consumer.getTopic(), consumer.getTopicNameWithoutPartition(), message);\n \n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}][{}] Received message from topics-consumer {}\",\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}][{}] Received message from topics-consumer {}\",\n                     topic, subscription, message.getMessageId());\n-            }\n+        }\n \n-            // if asyncReceive is waiting : return message to callback without adding to incomingMessages queue\n-            if (!pendingReceives.isEmpty()) {\n-                CompletableFuture<Message<T>> receivedFuture = pendingReceives.poll();\n-                unAckedMessageTracker.add(topicMessage.getMessageId());\n-                listenerExecutor.execute(() -> receivedFuture.complete(topicMessage));\n-            } else if (enqueueMessageAndCheckBatchReceive(topicMessage)) {\n-                if (hasPendingBatchReceive()) {\n-                    notifyPendingBatchReceivedCallBack();\n-                }\n+        // if asyncReceive is waiting : return message to callback without adding to incomingMessages queue\n+        CompletableFuture<Message<T>> receivedFuture = pendingReceives.poll();\n+        if (receivedFuture != null) {\n+            unAckedMessageTracker.add(topicMessage.getMessageId());\n+            listenerExecutor.execute(() -> receivedFuture.complete(topicMessage));\n+        } else if (enqueueMessageAndCheckBatchReceive(topicMessage) && hasPendingBatchReceive()) {\n+            try {\n+                lock.writeLock().lock();\n+                notifyPendingBatchReceivedCallBack();", "originalCommit": "ac48262d4fa431de0364391cc585c9694fefd581", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc5MTY5Ng==", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500791696", "bodyText": "This is a good suggestion, thank you very much", "author": "315157973", "createdAt": "2020-10-07T07:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2ODExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2ODUwOA==", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500768508", "bodyText": "probably this comment is no more useful", "author": "eolivelli", "createdAt": "2020-10-07T06:35:15Z", "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java", "diffHunk": "@@ -219,51 +219,44 @@ private void receiveMessageFromConsumer(ConsumerImpl<T> consumer) {\n             messageReceived(consumer, message);\n \n             // we're modifying pausedConsumers", "originalCommit": "ac48262d4fa431de0364391cc585c9694fefd581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "675b28d1755f8968ec51032f80543023d523465d", "url": "https://github.com/apache/pulsar/commit/675b28d1755f8968ec51032f80543023d523465d", "message": "Reduce lock range", "committedDate": "2020-10-07T08:46:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg0NzAzNA==", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500847034", "bodyText": "can you please explain the reason for this 'synchronized' block ?", "author": "eolivelli", "createdAt": "2020-10-07T08:54:00Z", "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerBase.java", "diffHunk": "@@ -677,19 +677,16 @@ protected void notifyPendingBatchReceivedCallBack() {\n         if (opBatchReceive == null || opBatchReceive.future == null) {\n             return;\n         }\n-        notifyPendingBatchReceivedCallBack(opBatchReceive);\n+        synchronized (incomingMessages) {", "originalCommit": "675b28d1755f8968ec51032f80543023d523465d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg1MjMzMg==", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500852332", "bodyText": "Not every call needs to be locked, so I reduced the scope of the lock. Do you think using ReentrantLock is better than using synchronized?", "author": "315157973", "createdAt": "2020-10-07T09:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg0NzAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDkwOTMzOQ==", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500909339", "bodyText": "can you please explain the reason for this 'synchronized' block ?\n\nThe notifyPendingBatchReceivedCallBack(OpBatchReceive<T> opBatchReceive) called in notifyPendingBatchReceivedCallBack() is not thread-safe, so locking is necessary.\nBut not every call to notifyPendingBatchReceivedCallBack() needs to be locked, only when there is an opBatchReceive that meets the conditions.\nThe scenarios where thread is not safe are as follows:\nThread A calls incomingMessages.peek(), finds that message A meets the conditions, can join the Messages collection, and is preparing to poll. At this time, thread B polls the message A first. The message polled by thread A is actually message B, but message B does not meet the conditions for joining the Messages set of thread A.\nLook forward to your advice.", "author": "315157973", "createdAt": "2020-10-07T10:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg0NzAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExODI5NA==", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r501118294", "bodyText": "incomingMessages is already a concurrent data structure and it does not need this synchronized block\nAlso if you use synchronized once you must guard it always with this facility, otherwise you will fall into an inconsistent synchronization.\nI don't know very well this code but it looks like there is no other instance of synchronized over  incomingMessages", "author": "eolivelli", "createdAt": "2020-10-07T15:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg0NzAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzMjMxMA==", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r501132310", "bodyText": "incomingMessages is already a concurrent data structure and it does not need this synchronized block\nAlso if you use synchronized once you must guard it always with this facility, otherwise you will fall into an inconsistent synchronization.\nI don't know very well this code but it looks like there is no other instance of synchronized over incomingMessages\n\nThanks.\nI use synchronized (incomingMessages), just to allow synchronized to have a final object that can be locked, because I see no other place to use this object to compete for lock.\nI reflected on it, this code can be very confusing, it is better to use ReentrantLock.", "author": "315157973", "createdAt": "2020-10-07T16:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg0NzAzNA=="}], "type": "inlineReview"}, {"oid": "b69abcfec3879b6adfcb3bd1be3573ead8813ddf", "url": "https://github.com/apache/pulsar/commit/b69abcfec3879b6adfcb3bd1be3573ead8813ddf", "message": "use ReentrantLock", "committedDate": "2020-10-07T16:25:27Z", "type": "commit"}]}