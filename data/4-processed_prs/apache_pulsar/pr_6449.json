{"pr_number": 6449, "pr_title": "Support Consumers Set Custom Retry Delay", "pr_createdAt": "2020-03-01T08:08:16Z", "pr_url": "https://github.com/apache/pulsar/pull/6449", "timeline": [{"oid": "4d9dfedab4c20632751a0a158e2fc91cecf9ae6e", "url": "https://github.com/apache/pulsar/commit/4d9dfedab4c20632751a0a158e2fc91cecf9ae6e", "message": "Support Consumers Set Custom Retry Delay", "committedDate": "2020-04-05T04:07:28Z", "type": "commit"}, {"oid": "467d8519b411c99714839ec8a3f92b5bfdf65d03", "url": "https://github.com/apache/pulsar/commit/467d8519b411c99714839ec8a3f92b5bfdf65d03", "message": "add flink PulsarConsumerSourceTests no impl", "committedDate": "2020-04-05T04:07:28Z", "type": "commit"}, {"oid": "b5938ba288b252e948a2f5d25f3169ccfc40094d", "url": "https://github.com/apache/pulsar/commit/b5938ba288b252e948a2f5d25f3169ccfc40094d", "message": "add Tests", "committedDate": "2020-04-05T04:07:28Z", "type": "commit"}, {"oid": "68b425dd9b91dbb432e5dc5d8b954484d7c6f43e", "url": "https://github.com/apache/pulsar/commit/68b425dd9b91dbb432e5dc5d8b954484d7c6f43e", "message": "add retryTopicTests", "committedDate": "2020-04-05T04:09:02Z", "type": "commit"}, {"oid": "68b425dd9b91dbb432e5dc5d8b954484d7c6f43e", "url": "https://github.com/apache/pulsar/commit/68b425dd9b91dbb432e5dc5d8b954484d7c6f43e", "message": "add retryTopicTests", "committedDate": "2020-04-05T04:09:02Z", "type": "forcePushed"}, {"oid": "5db9fa0c9124b0b16968a1c8ea215d65a809e572", "url": "https://github.com/apache/pulsar/commit/5db9fa0c9124b0b16968a1c8ea215d65a809e572", "message": "add retryTopicTests", "committedDate": "2020-04-05T06:46:45Z", "type": "commit"}, {"oid": "b8a7421e47b6c0da5e5a213a3c47ec139460e117", "url": "https://github.com/apache/pulsar/commit/b8a7421e47b6c0da5e5a213a3c47ec139460e117", "message": "add retryTopicTests", "committedDate": "2020-04-05T06:56:26Z", "type": "commit"}, {"oid": "8a5a82529c6d945db1807941076f98c4a9c9bdf4", "url": "https://github.com/apache/pulsar/commit/8a5a82529c6d945db1807941076f98c4a9c9bdf4", "message": "add retryTopicTests", "committedDate": "2020-04-05T11:45:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM5NDY1OA==", "url": "https://github.com/apache/pulsar/pull/6449#discussion_r455394658", "bodyText": "Does anyone know what is the point of this line? The logic of sending message to dead letter queue is described within more than twenty lines below as well as message acknowledgment, why is it done twice?", "author": "Lanayx", "createdAt": "2020-07-15T22:11:23Z", "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerImpl.java", "diffHunk": "@@ -511,6 +527,129 @@ boolean markAckForBatchMessage(BatchMessageIdImpl batchMessageId, AckType ackTyp\n         return sendAcknowledge(messageId, ackType, properties, txnImpl);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    protected CompletableFuture<Void> doReconsumeLater(Message<?> message, AckType ackType,\n+                                                       Map<String,Long> properties, \n+                                                       long delayTime,\n+                                                       TimeUnit unit) {\n+        MessageId messageId = message.getMessageId();\n+        if(messageId instanceof TopicMessageIdImpl) {\n+            messageId = ((TopicMessageIdImpl)messageId).getInnerMessageId();\n+        }\n+        checkArgument(messageId instanceof MessageIdImpl);\n+        if (getState() != State.Ready && getState() != State.Connecting) {\n+            stats.incrementNumAcksFailed();\n+            PulsarClientException exception = new PulsarClientException(\"Consumer not ready. State: \" + getState());\n+            if (AckType.Individual.equals(ackType)) {\n+                onAcknowledge(messageId, exception);\n+            } else if (AckType.Cumulative.equals(ackType)) {\n+                onAcknowledgeCumulative(messageId, exception);\n+            }\n+            return FutureUtil.failedFuture(exception);\n+        }\n+        if (delayTime < 0) {\n+            delayTime = 0;\n+        }\n+        if (retryLetterProducer == null) {\n+            try {\n+                createProducerLock.writeLock().lock();\n+                if (retryLetterProducer == null) {\n+                    retryLetterProducer = client.newProducer(schema)\n+                            .topic(this.deadLetterPolicy.getRetryLetterTopic())\n+                            .enableBatching(false)\n+                            .blockIfQueueFull(false)\n+                            .create();\n+                }\n+            } catch (Exception e) {\n+                log.error(\"Create retry letter producer exception with topic: {}\", deadLetterPolicy.getRetryLetterTopic(), e);\n+            } finally {\n+                createProducerLock.writeLock().unlock();\n+            }\n+        }\n+        if (retryLetterProducer != null) {\n+            try {\n+                MessageImpl<T> retryMessage = null;\n+                String originMessageIdStr = null;\n+                String originTopicNameStr = null;\n+                if (message instanceof TopicMessageImpl) {\n+                    retryMessage = (MessageImpl<T>) ((TopicMessageImpl<T>) message).getMessage();\n+                    originMessageIdStr = ((TopicMessageIdImpl) message.getMessageId()).getInnerMessageId().toString();\n+                    originTopicNameStr = ((TopicMessageIdImpl) message.getMessageId()).getTopicName();\n+                } else if (message instanceof MessageImpl) {\n+                    retryMessage = (MessageImpl<T>) message;\n+                    originMessageIdStr = ((MessageImpl<T>) message).getMessageId().toString();\n+                    originTopicNameStr =  ((MessageImpl<T>) message).getTopicName();\n+                }\n+                SortedMap<String, String> propertiesMap = new TreeMap<>();\n+                int reconsumetimes = 1;\n+                if (message.getProperties() != null) {\n+                    propertiesMap.putAll(message.getProperties());\n+                }\n+\n+                if (propertiesMap.containsKey(RetryMessageUtil.SYSTEM_PROPERTY_RECONSUMETIMES)) {\n+                    reconsumetimes = Integer.valueOf(propertiesMap.get(RetryMessageUtil.SYSTEM_PROPERTY_RECONSUMETIMES));\n+                    reconsumetimes = reconsumetimes + 1;\n+                   \n+                } else {\n+                    propertiesMap.put(RetryMessageUtil.SYSTEM_PROPERTY_REAL_TOPIC, originTopicNameStr);\n+                    propertiesMap.put(RetryMessageUtil.SYSTEM_PROPERTY_ORIGIN_MESSAGE_ID, originMessageIdStr);\n+                }\n+\n+                propertiesMap.put(RetryMessageUtil.SYSTEM_PROPERTY_RECONSUMETIMES, String.valueOf(reconsumetimes));\n+                propertiesMap.put(RetryMessageUtil.SYSTEM_PROPERTY_DELAY_TIME, String.valueOf(unit.toMillis(delayTime)));\n+                \n+               if (reconsumetimes > this.deadLetterPolicy.getMaxRedeliverCount()) {\n+                   processPossibleToDLQ((MessageIdImpl)messageId);", "originalCommit": "8a5a82529c6d945db1807941076f98c4a9c9bdf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}