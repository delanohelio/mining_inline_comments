{"pr_number": 6105, "pr_title": "[pulsar-function-go] Add statistics and Prometheus to Go Function instances for production readiness", "pr_createdAt": "2020-01-21T04:11:12Z", "pr_url": "https://github.com/apache/pulsar/pull/6105", "timeline": [{"oid": "2acad2723d688fc48a4f6fffc80b6da1efa89d3d", "url": "https://github.com/apache/pulsar/commit/2acad2723d688fc48a4f6fffc80b6da1efa89d3d", "message": "Enabled grpc plugin to gRPC generate.sh script to fix issues causing omission of methods for gRPC server registration in generated gRPC files for Go. (#4175)\n\nGenerated updated gRPC files that contain service registration methods for creating gRPC service in Go. Also, upgraded proto version to 3. (#4175)\n\nFixed build errors by prefixing pulsar-function-go/pb with pb alias. (#4175).\n\nAdded instanceControlServicer.go as the servicer responsible for serving the gRPC service for the Go Function instances (#4175). Rough draft right now.\n\nAdded changes to show intent behind passing port value to Start in function.go. Also, added some code to support healthcheck and added methods to support instanceConrolServicer. Just needed to commit changes to allow reproducible test errors. (#4175).\n\nUpdated function.go Start method to make it more clear where we need to provide a port value (#4175).\n\nAdded port and expectedHealthCheckInterval to use of function context. Updated all references. (#4175)\n\nAdded Apache license to gRPC-generated files in attempt to get license check test to pass (#4175).\n\nCreated instanceControlServicer_test.go to test gRPC server and validate that HealthCheck method returns true as expected (#4175).\n\nFixed bug in FunctionContext (and context_test.go) where the inputTopics field was being referenced when it wasn't getting populated. Updated GetInputTopics method to get input topics from the source location (#4175).\n\nFixed bug in FunctionContext (and context_test.go) where the inputTopics field was being referenced when it wasn't getting populated. Updated GetInputTopics method to get input topics from the source location. (Should have been part of previous commit.) Also, added expectedHealthCheckInterval to conf.yaml for testing. (#4175).\n\nFixed license formatting by running mvn license:format (#4175).\n\nAdded logic and tests to allow healthCheck to kill instances that aren't receiving their regular health checks. Still needs an end-to-end test involving FunctionManager to check for possible issues that could kill instances incorrectly (#4175).\n\nRemoved inputTopics field from FunctionContext (#4175).\n\nAdding the progress I've made so far on migrating the Prometheus code to Go... currently blocked due to missing methods from the Go client. Waiting for information from the Prometheus maintainers to find a workaround. (#4175).\n\nFixed license check. (#4175)\n\nReverting the last two commits since they should go into a separate PR. (#4174).\n\nRe-added test file that was accidentially deleted (#4175).\n\nAdded a few comments to make review easier (#4175).\n\nMade minor (non-functional) changes as per PR review (#4175).\n\nFixed print statements (#4175).\n\nRe-added comment after getting maven license formatting correct (#4175).\n\nRemoved comment that I forgot to remove (#4175).\n\nFixed formatting issues for style check (#4175).\n\nUpdated gRPC test to no longer use deprecated method (#4175).\n\nFixed more formatting issues by using goimports (#4175).\n\nFixed even more formatting issues (#4175).\n\nFixed yet even more formatting issues (#4175).\n\nAdded statistics functionality for supporting Prometheus and stats and status commands on Go functions. Needs testing. Also, needs review of specific locations of stats method calls to ensure we're collecting data in the right places. Also, still needs the 1m interval stats to be created. Upstream Prometheus changes prevented us from using the existing approaches for collecting these stats.", "committedDate": "2020-02-17T20:40:13Z", "type": "commit"}, {"oid": "2acad2723d688fc48a4f6fffc80b6da1efa89d3d", "url": "https://github.com/apache/pulsar/commit/2acad2723d688fc48a4f6fffc80b6da1efa89d3d", "message": "Enabled grpc plugin to gRPC generate.sh script to fix issues causing omission of methods for gRPC server registration in generated gRPC files for Go. (#4175)\n\nGenerated updated gRPC files that contain service registration methods for creating gRPC service in Go. Also, upgraded proto version to 3. (#4175)\n\nFixed build errors by prefixing pulsar-function-go/pb with pb alias. (#4175).\n\nAdded instanceControlServicer.go as the servicer responsible for serving the gRPC service for the Go Function instances (#4175). Rough draft right now.\n\nAdded changes to show intent behind passing port value to Start in function.go. Also, added some code to support healthcheck and added methods to support instanceConrolServicer. Just needed to commit changes to allow reproducible test errors. (#4175).\n\nUpdated function.go Start method to make it more clear where we need to provide a port value (#4175).\n\nAdded port and expectedHealthCheckInterval to use of function context. Updated all references. (#4175)\n\nAdded Apache license to gRPC-generated files in attempt to get license check test to pass (#4175).\n\nCreated instanceControlServicer_test.go to test gRPC server and validate that HealthCheck method returns true as expected (#4175).\n\nFixed bug in FunctionContext (and context_test.go) where the inputTopics field was being referenced when it wasn't getting populated. Updated GetInputTopics method to get input topics from the source location (#4175).\n\nFixed bug in FunctionContext (and context_test.go) where the inputTopics field was being referenced when it wasn't getting populated. Updated GetInputTopics method to get input topics from the source location. (Should have been part of previous commit.) Also, added expectedHealthCheckInterval to conf.yaml for testing. (#4175).\n\nFixed license formatting by running mvn license:format (#4175).\n\nAdded logic and tests to allow healthCheck to kill instances that aren't receiving their regular health checks. Still needs an end-to-end test involving FunctionManager to check for possible issues that could kill instances incorrectly (#4175).\n\nRemoved inputTopics field from FunctionContext (#4175).\n\nAdding the progress I've made so far on migrating the Prometheus code to Go... currently blocked due to missing methods from the Go client. Waiting for information from the Prometheus maintainers to find a workaround. (#4175).\n\nFixed license check. (#4175)\n\nReverting the last two commits since they should go into a separate PR. (#4174).\n\nRe-added test file that was accidentially deleted (#4175).\n\nAdded a few comments to make review easier (#4175).\n\nMade minor (non-functional) changes as per PR review (#4175).\n\nFixed print statements (#4175).\n\nRe-added comment after getting maven license formatting correct (#4175).\n\nRemoved comment that I forgot to remove (#4175).\n\nFixed formatting issues for style check (#4175).\n\nUpdated gRPC test to no longer use deprecated method (#4175).\n\nFixed more formatting issues by using goimports (#4175).\n\nFixed even more formatting issues (#4175).\n\nFixed yet even more formatting issues (#4175).\n\nAdded statistics functionality for supporting Prometheus and stats and status commands on Go functions. Needs testing. Also, needs review of specific locations of stats method calls to ensure we're collecting data in the right places. Also, still needs the 1m interval stats to be created. Upstream Prometheus changes prevented us from using the existing approaches for collecting these stats.", "committedDate": "2020-02-17T20:40:13Z", "type": "forcePushed"}, {"oid": "7e0a75d6faefc88b55c859acc0a648b2732fbae6", "url": "https://github.com/apache/pulsar/commit/7e0a75d6faefc88b55c859acc0a648b2732fbae6", "message": "Improved formatting of Go code. Also, added some required comments to get golint to pass. #6105", "committedDate": "2020-02-17T21:29:52Z", "type": "commit"}, {"oid": "2cdf00aa8f61c6263e5e99295f8189752d05da02", "url": "https://github.com/apache/pulsar/commit/2cdf00aa8f61c6263e5e99295f8189752d05da02", "message": "Fixed more Go formatting issues. #6105", "committedDate": "2020-02-17T21:49:57Z", "type": "commit"}, {"oid": "9c89e04c3c4a897dd8e6b8ca946992e05f0cbb92", "url": "https://github.com/apache/pulsar/commit/9c89e04c3c4a897dd8e6b8ca946992e05f0cbb92", "message": "Fixed more formatting issues. #6105", "committedDate": "2020-02-17T22:37:50Z", "type": "commit"}, {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "url": "https://github.com/apache/pulsar/commit/73e3c922c7c5192424e82ba5a53d85e53b930d26", "message": "Ran 'gofmt -s -w .' #6105", "committedDate": "2020-02-17T22:57:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMzA5OA==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r402223098", "bodyText": "Could this be removed?", "author": "jiazhai", "createdAt": "2020-04-02T10:51:21Z", "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){", "originalCommit": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNTc2Mg==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410815762", "bodyText": "@devinbost please remove these comments if we don't need the test case", "author": "wolfstudy", "createdAt": "2020-04-19T04:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMzA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMzQwOA==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r402223408", "bodyText": "Could this be removed?", "author": "jiazhai", "createdAt": "2020-04-02T10:51:59Z", "path": "pulsar-function-go/pf/stats.go", "diffHunk": "@@ -0,0 +1,316 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"strconv\"\n+\t\"time\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t//\"strings\"\n+\t//\"github.com/prometheus/common/expfmt\"\n+\t//\"time\"\n+)\n+\n+var metricsLabelNames = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+var exceptionLabelNames = []string{\"error\", \"ts\"}\n+var exceptionMetricsLabelNames = append(metricsLabelNames, exceptionLabelNames...)\n+\n+const (\n+\tPulsarFunctionMetricsPrefix = \"pulsar_function_\"\n+\n+\tTotalSuccessfullyProcessed = \"processed_successfully_total\"\n+\tTotalSystemExceptions      = \"system_exceptions_total\"\n+\tTotalUserExceptions        = \"user_exceptions_total\"\n+\tProcessLatencyMs           = \"process_latency_ms\"\n+\tLastInvocation             = \"last_invocation\"\n+\tTotalReceived              = \"received_total\"\n+\n+\tTotalSuccessfullyProcessed1min = \"processed_successfully_total_1min\"\n+\tTotalSystemExceptions1min      = \"system_exceptions_total_1min\"\n+\tTotalUserExceptions1min        = \"user_exceptions_total_1min\"\n+\tProcessLatencyMs1min           = \"process_latency_ms_1min\"\n+\tTotalReceived1min              = \"received_total_1min\"\n+)\n+\n+// Declare Prometheus\n+var statTotalProcessedSuccessfully = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed,\n+\t\tHelp: \"Total number of messages processed successfully.\"},\n+\tmetricsLabelNames)\n+var statTotalSysExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSystemExceptions,\n+\t\tHelp: \"Total number of system exceptions.\"},\n+\tmetricsLabelNames)\n+var statTotalUserExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalUserExceptions,\n+\t\tHelp: \"Total number of user exceptions.\"},\n+\tmetricsLabelNames)\n+\n+var statProcessLatencyMs = prometheus.NewSummaryVec(\n+\tprometheus.SummaryOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + ProcessLatencyMs,\n+\t\tHelp: \"Process latency in milliseconds.\"}, metricsLabelNames)\n+\n+var statLastInvocation = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + LastInvocation,\n+\t\tHelp: \"The timestamp of the last invocation of the function.\"}, metricsLabelNames)\n+\n+var statTotalReceived = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalReceived,\n+\t\tHelp: \"Total number of messages received from source.\"}, metricsLabelNames)\n+\n+// 1min windowed metrics\n+var statTotalProcessedSuccessfully1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed1min,\n+\t\tHelp: \"Total number of messages processed successfully in the last 1 minute.\"}, metricsLabelNames)\n+var statTotalSysExceptions1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSystemExceptions1min,\n+\t\tHelp: \"Total number of system exceptions in the last 1 minute.\"},\n+\tmetricsLabelNames)\n+var statTotalUserExceptions1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalUserExceptions1min,\n+\t\tHelp: \"Total number of user exceptions in the last 1 minute.\"},\n+\tmetricsLabelNames)\n+\n+var statProcessLatencyMs1min = prometheus.NewSummaryVec(\n+\tprometheus.SummaryOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + ProcessLatencyMs1min,\n+\t\tHelp: \"Process latency in milliseconds in the last 1 minute.\"}, metricsLabelNames)\n+\n+var statTotalReceived1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalReceived1min,\n+\t\tHelp: \"Total number of messages received from source in the last 1 minute.\"}, metricsLabelNames)\n+\n+// exceptions\n+var userExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + \"user_exception\",\n+\t\tHelp: \"Exception from user code.\"}, exceptionMetricsLabelNames)\n+\n+var systemExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + \"system_exception\",\n+\t\tHelp: \"Exception from system code.\"}, exceptionMetricsLabelNames)\n+\n+var reg *prometheus.Registry\n+\n+func init() {\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(statTotalProcessedSuccessfully)\n+\treg.MustRegister(statTotalSysExceptions)\n+\treg.MustRegister(statTotalUserExceptions)\n+\treg.MustRegister(statProcessLatencyMs)\n+\treg.MustRegister(statLastInvocation)\n+\treg.MustRegister(statTotalReceived)\n+\treg.MustRegister(statTotalProcessedSuccessfully1min)\n+\treg.MustRegister(statTotalSysExceptions1min)\n+\treg.MustRegister(statTotalUserExceptions1min)\n+\treg.MustRegister(statProcessLatencyMs1min)\n+\treg.MustRegister(statTotalReceived1min)\n+\treg.MustRegister(userExceptions)\n+\treg.MustRegister(systemExceptions)\n+\n+}\n+\n+type LatestException struct {\n+\texception error\n+\ttimestamp int64\n+}\n+\n+// Be sure to use the constructor method: NewStatWithLabelValues\n+type StatWithLabelValues struct {\n+\tstatTotalProcessedSuccessfully     prometheus.Gauge\n+\tstatTotalSysExceptions             prometheus.Gauge\n+\tstatTotalUserExceptions            prometheus.Gauge\n+\tstatProcessLatencyMs               prometheus.Observer\n+\tstatLastInvocation                 prometheus.Gauge\n+\tstatTotalReceived                  prometheus.Gauge\n+\tstatTotalProcessedSuccessfully1min prometheus.Gauge\n+\tstatTotalSysExceptions1min         prometheus.Gauge\n+\tstatTotalUserExceptions1min        prometheus.Gauge\n+\t//_stat_process_latency_ms_1min prometheus.Observer\n+\tstatTotalReceived1min prometheus.Gauge\n+\tlatestUserException   []LatestException\n+\tlatestSysException    []LatestException\n+\tprocessStartTime      int64\n+\tmetricsLabels         []string\n+}\n+\n+func NewStatWithLabelValues(metricsLabels ...string) StatWithLabelValues {\n+\t// as optimization\n+\tvar statTotalProcessedSuccessfully = statTotalProcessedSuccessfully.WithLabelValues(metricsLabels...)\n+\tvar statTotalSysExceptions = statTotalSysExceptions.WithLabelValues(metricsLabels...)\n+\tvar statTotalUserExceptions = statTotalUserExceptions.WithLabelValues(metricsLabels...)\n+\tvar statProcessLatencyMs = statProcessLatencyMs.WithLabelValues(metricsLabels...)\n+\tvar statLastInvocation = statLastInvocation.WithLabelValues(metricsLabels...)\n+\tvar statTotalReceived = statTotalReceived.WithLabelValues(metricsLabels...)\n+\tvar statTotalProcessedSuccessfully1min = statTotalProcessedSuccessfully1min.WithLabelValues(metricsLabels...)\n+\tvar statTotalSysExceptions1min = statTotalSysExceptions1min.WithLabelValues(metricsLabels...)\n+\tvar statTotalUserExceptions1min = statTotalUserExceptions1min.WithLabelValues(metricsLabels...)\n+\t//var _stat_process_latency_ms_1min = stat_process_latency_ms_1min.WithLabelValues(metrics_labels...)\n+\tvar statTotalReceived1min = statTotalReceived1min.WithLabelValues(metricsLabels...)\n+\n+\tstatObj := StatWithLabelValues{\n+\t\tstatTotalProcessedSuccessfully,\n+\t\tstatTotalSysExceptions,\n+\t\tstatTotalUserExceptions,\n+\t\tstatProcessLatencyMs,\n+\t\tstatLastInvocation,\n+\t\tstatTotalReceived,\n+\t\tstatTotalProcessedSuccessfully1min,\n+\t\tstatTotalSysExceptions1min,\n+\t\tstatTotalUserExceptions1min,\n+\t\t//_stat_process_latency_ms_1min,\n+\t\tstatTotalReceived1min,\n+\t\t[]LatestException{},\n+\t\t[]LatestException{},\n+\t\t0,\n+\t\tmetricsLabels,\n+\t}\n+\treturn statObj\n+}\n+\n+func filter(\n+\tss []*io_prometheus_client.MetricFamily,\n+\ttest func(*io_prometheus_client.MetricFamily) bool) (ret []*io_prometheus_client.MetricFamily) {\n+\tfor _, s := range ss {\n+\t\tif test(s) {\n+\t\t\tret = append(ret, s)\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func getFirstMatch(\n+\tmetrics []*io_prometheus_client.Metric,\n+\ttest func(*io_prometheus_client.LabelPair) bool) *io_prometheus_client.Metric {\n+\tfor _, met := range metrics {\n+\t\tfor _, lbl := range met.Label {\n+\t\t\tif test(lbl) {\n+\t\t\t\treturn met\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (stat *StatWithLabelValues) setLastInvocation() {\n+\tnow := time.Now()\n+\tstat.statLastInvocation.Set(float64(now.UnixNano()))\n+}\n+\n+func (stat *StatWithLabelValues) processTimeStart() {\n+\tnow := time.Now()\n+\tstat.processStartTime = now.UnixNano()\n+}\n+\n+func (stat *StatWithLabelValues) processTimeEnd() {\n+\tif stat.processStartTime != 0 {\n+\t\tnow := time.Now()\n+\t\tduration := now.UnixNano() - stat.processStartTime\n+\t\tstat.statProcessLatencyMs.Observe(float64(duration))\n+\t\t//stat._stat_process_latency_ms_1min.Observe(float64(duration))\n+\t}\n+}\n+\n+func (stat *StatWithLabelValues) incrTotalUserExceptions(err error) {\n+\tstat.statTotalUserExceptions.Inc()\n+\tstat.statTotalUserExceptions1min.Inc()\n+\tstat.addUserException(err)\n+}\n+\n+func (stat *StatWithLabelValues) addUserException(err error) {\n+\tnow := time.Now()\n+\tts := now.UnixNano()\n+\terrorTs := LatestException{err, ts}\n+\tstat.latestUserException = append(stat.latestUserException, errorTs)\n+\tif len(stat.latestUserException) > 10 {\n+\t\tstat.latestUserException = stat.latestUserException[1:]\n+\t}\n+\t// report exception via prometheus\n+\tstat.reportUserExceptionPrometheus(err, ts)\n+}\n+\n+//@limits(calls=5, period=60)\n+func (stat *StatWithLabelValues) reportUserExceptionPrometheus(exception error, ts int64) {\n+\terrorTs := []string{exception.Error(), strconv.FormatInt(ts, 10)}\n+\texceptionMetricLabels := append(stat.metricsLabels, errorTs...)\n+\tuserExceptions.WithLabelValues(exceptionMetricLabels...).Set(1.0)\n+}\n+\n+func (stat *StatWithLabelValues) incrTotalProcessedSuccessfully() {\n+\tstat.statTotalProcessedSuccessfully.Inc()\n+\tstat.statTotalProcessedSuccessfully1min.Inc()\n+}\n+\n+func (stat *StatWithLabelValues) incrTotalSysExceptions(exception error) {\n+\tstat.statTotalSysExceptions.Inc()\n+\tstat.statTotalSysExceptions1min.Inc()\n+\tstat.addSysException(exception)\n+}\n+\n+func (stat *StatWithLabelValues) addSysException(exception error) {\n+\tnow := time.Now()\n+\tts := now.UnixNano()\n+\terrorTs := LatestException{exception, ts}\n+\tstat.latestSysException = append(stat.latestSysException, errorTs)\n+\tif len(stat.latestSysException) > 10 {\n+\t\tstat.latestSysException = stat.latestSysException[1:]\n+\t}\n+\t// report exception via prometheus\n+\tstat.reportSystemExceptionPrometheus(exception, ts)\n+}\n+\n+//@limits(calls=5, period=60)", "originalCommit": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMzY0Mw==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r402223643", "bodyText": "could this be removed?", "author": "jiazhai", "createdAt": "2020-04-02T10:52:28Z", "path": "pulsar-function-go/pf/stats.go", "diffHunk": "@@ -0,0 +1,316 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"strconv\"\n+\t\"time\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t//\"strings\"\n+\t//\"github.com/prometheus/common/expfmt\"\n+\t//\"time\"\n+)\n+\n+var metricsLabelNames = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+var exceptionLabelNames = []string{\"error\", \"ts\"}\n+var exceptionMetricsLabelNames = append(metricsLabelNames, exceptionLabelNames...)\n+\n+const (\n+\tPulsarFunctionMetricsPrefix = \"pulsar_function_\"\n+\n+\tTotalSuccessfullyProcessed = \"processed_successfully_total\"\n+\tTotalSystemExceptions      = \"system_exceptions_total\"\n+\tTotalUserExceptions        = \"user_exceptions_total\"\n+\tProcessLatencyMs           = \"process_latency_ms\"\n+\tLastInvocation             = \"last_invocation\"\n+\tTotalReceived              = \"received_total\"\n+\n+\tTotalSuccessfullyProcessed1min = \"processed_successfully_total_1min\"\n+\tTotalSystemExceptions1min      = \"system_exceptions_total_1min\"\n+\tTotalUserExceptions1min        = \"user_exceptions_total_1min\"\n+\tProcessLatencyMs1min           = \"process_latency_ms_1min\"\n+\tTotalReceived1min              = \"received_total_1min\"\n+)\n+\n+// Declare Prometheus\n+var statTotalProcessedSuccessfully = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed,\n+\t\tHelp: \"Total number of messages processed successfully.\"},\n+\tmetricsLabelNames)\n+var statTotalSysExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSystemExceptions,\n+\t\tHelp: \"Total number of system exceptions.\"},\n+\tmetricsLabelNames)\n+var statTotalUserExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalUserExceptions,\n+\t\tHelp: \"Total number of user exceptions.\"},\n+\tmetricsLabelNames)\n+\n+var statProcessLatencyMs = prometheus.NewSummaryVec(\n+\tprometheus.SummaryOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + ProcessLatencyMs,\n+\t\tHelp: \"Process latency in milliseconds.\"}, metricsLabelNames)\n+\n+var statLastInvocation = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + LastInvocation,\n+\t\tHelp: \"The timestamp of the last invocation of the function.\"}, metricsLabelNames)\n+\n+var statTotalReceived = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalReceived,\n+\t\tHelp: \"Total number of messages received from source.\"}, metricsLabelNames)\n+\n+// 1min windowed metrics\n+var statTotalProcessedSuccessfully1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed1min,\n+\t\tHelp: \"Total number of messages processed successfully in the last 1 minute.\"}, metricsLabelNames)\n+var statTotalSysExceptions1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSystemExceptions1min,\n+\t\tHelp: \"Total number of system exceptions in the last 1 minute.\"},\n+\tmetricsLabelNames)\n+var statTotalUserExceptions1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalUserExceptions1min,\n+\t\tHelp: \"Total number of user exceptions in the last 1 minute.\"},\n+\tmetricsLabelNames)\n+\n+var statProcessLatencyMs1min = prometheus.NewSummaryVec(\n+\tprometheus.SummaryOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + ProcessLatencyMs1min,\n+\t\tHelp: \"Process latency in milliseconds in the last 1 minute.\"}, metricsLabelNames)\n+\n+var statTotalReceived1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalReceived1min,\n+\t\tHelp: \"Total number of messages received from source in the last 1 minute.\"}, metricsLabelNames)\n+\n+// exceptions\n+var userExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + \"user_exception\",\n+\t\tHelp: \"Exception from user code.\"}, exceptionMetricsLabelNames)\n+\n+var systemExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + \"system_exception\",\n+\t\tHelp: \"Exception from system code.\"}, exceptionMetricsLabelNames)\n+\n+var reg *prometheus.Registry\n+\n+func init() {\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(statTotalProcessedSuccessfully)\n+\treg.MustRegister(statTotalSysExceptions)\n+\treg.MustRegister(statTotalUserExceptions)\n+\treg.MustRegister(statProcessLatencyMs)\n+\treg.MustRegister(statLastInvocation)\n+\treg.MustRegister(statTotalReceived)\n+\treg.MustRegister(statTotalProcessedSuccessfully1min)\n+\treg.MustRegister(statTotalSysExceptions1min)\n+\treg.MustRegister(statTotalUserExceptions1min)\n+\treg.MustRegister(statProcessLatencyMs1min)\n+\treg.MustRegister(statTotalReceived1min)\n+\treg.MustRegister(userExceptions)\n+\treg.MustRegister(systemExceptions)\n+\n+}\n+\n+type LatestException struct {\n+\texception error\n+\ttimestamp int64\n+}\n+\n+// Be sure to use the constructor method: NewStatWithLabelValues\n+type StatWithLabelValues struct {\n+\tstatTotalProcessedSuccessfully     prometheus.Gauge\n+\tstatTotalSysExceptions             prometheus.Gauge\n+\tstatTotalUserExceptions            prometheus.Gauge\n+\tstatProcessLatencyMs               prometheus.Observer\n+\tstatLastInvocation                 prometheus.Gauge\n+\tstatTotalReceived                  prometheus.Gauge\n+\tstatTotalProcessedSuccessfully1min prometheus.Gauge\n+\tstatTotalSysExceptions1min         prometheus.Gauge\n+\tstatTotalUserExceptions1min        prometheus.Gauge\n+\t//_stat_process_latency_ms_1min prometheus.Observer\n+\tstatTotalReceived1min prometheus.Gauge\n+\tlatestUserException   []LatestException\n+\tlatestSysException    []LatestException\n+\tprocessStartTime      int64\n+\tmetricsLabels         []string\n+}\n+\n+func NewStatWithLabelValues(metricsLabels ...string) StatWithLabelValues {\n+\t// as optimization\n+\tvar statTotalProcessedSuccessfully = statTotalProcessedSuccessfully.WithLabelValues(metricsLabels...)\n+\tvar statTotalSysExceptions = statTotalSysExceptions.WithLabelValues(metricsLabels...)\n+\tvar statTotalUserExceptions = statTotalUserExceptions.WithLabelValues(metricsLabels...)\n+\tvar statProcessLatencyMs = statProcessLatencyMs.WithLabelValues(metricsLabels...)\n+\tvar statLastInvocation = statLastInvocation.WithLabelValues(metricsLabels...)\n+\tvar statTotalReceived = statTotalReceived.WithLabelValues(metricsLabels...)\n+\tvar statTotalProcessedSuccessfully1min = statTotalProcessedSuccessfully1min.WithLabelValues(metricsLabels...)\n+\tvar statTotalSysExceptions1min = statTotalSysExceptions1min.WithLabelValues(metricsLabels...)\n+\tvar statTotalUserExceptions1min = statTotalUserExceptions1min.WithLabelValues(metricsLabels...)\n+\t//var _stat_process_latency_ms_1min = stat_process_latency_ms_1min.WithLabelValues(metrics_labels...)\n+\tvar statTotalReceived1min = statTotalReceived1min.WithLabelValues(metricsLabels...)\n+\n+\tstatObj := StatWithLabelValues{\n+\t\tstatTotalProcessedSuccessfully,\n+\t\tstatTotalSysExceptions,\n+\t\tstatTotalUserExceptions,\n+\t\tstatProcessLatencyMs,\n+\t\tstatLastInvocation,\n+\t\tstatTotalReceived,\n+\t\tstatTotalProcessedSuccessfully1min,\n+\t\tstatTotalSysExceptions1min,\n+\t\tstatTotalUserExceptions1min,\n+\t\t//_stat_process_latency_ms_1min,\n+\t\tstatTotalReceived1min,\n+\t\t[]LatestException{},\n+\t\t[]LatestException{},\n+\t\t0,\n+\t\tmetricsLabels,\n+\t}\n+\treturn statObj\n+}\n+\n+func filter(\n+\tss []*io_prometheus_client.MetricFamily,\n+\ttest func(*io_prometheus_client.MetricFamily) bool) (ret []*io_prometheus_client.MetricFamily) {\n+\tfor _, s := range ss {\n+\t\tif test(s) {\n+\t\t\tret = append(ret, s)\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func getFirstMatch(\n+\tmetrics []*io_prometheus_client.Metric,\n+\ttest func(*io_prometheus_client.LabelPair) bool) *io_prometheus_client.Metric {\n+\tfor _, met := range metrics {\n+\t\tfor _, lbl := range met.Label {\n+\t\t\tif test(lbl) {\n+\t\t\t\treturn met\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (stat *StatWithLabelValues) setLastInvocation() {\n+\tnow := time.Now()\n+\tstat.statLastInvocation.Set(float64(now.UnixNano()))\n+}\n+\n+func (stat *StatWithLabelValues) processTimeStart() {\n+\tnow := time.Now()\n+\tstat.processStartTime = now.UnixNano()\n+}\n+\n+func (stat *StatWithLabelValues) processTimeEnd() {\n+\tif stat.processStartTime != 0 {\n+\t\tnow := time.Now()\n+\t\tduration := now.UnixNano() - stat.processStartTime\n+\t\tstat.statProcessLatencyMs.Observe(float64(duration))\n+\t\t//stat._stat_process_latency_ms_1min.Observe(float64(duration))\n+\t}\n+}\n+\n+func (stat *StatWithLabelValues) incrTotalUserExceptions(err error) {\n+\tstat.statTotalUserExceptions.Inc()\n+\tstat.statTotalUserExceptions1min.Inc()\n+\tstat.addUserException(err)\n+}\n+\n+func (stat *StatWithLabelValues) addUserException(err error) {\n+\tnow := time.Now()\n+\tts := now.UnixNano()\n+\terrorTs := LatestException{err, ts}\n+\tstat.latestUserException = append(stat.latestUserException, errorTs)\n+\tif len(stat.latestUserException) > 10 {\n+\t\tstat.latestUserException = stat.latestUserException[1:]\n+\t}\n+\t// report exception via prometheus\n+\tstat.reportUserExceptionPrometheus(err, ts)\n+}\n+\n+//@limits(calls=5, period=60)", "originalCommit": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyNTMwMw==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r402225303", "bodyText": "Do we still need this?", "author": "jiazhai", "createdAt": "2020-04-02T10:55:44Z", "path": "pulsar-function-go/pf/instance.go", "diffHunk": "@@ -374,17 +409,201 @@ func (gi *goInstance) healthCheck() *pb.HealthCheckResult {\n }\n \n func (gi *goInstance) getFunctionStatus() *pb.FunctionStatus {\n-\treturn nil // Not implemented until we add the statistics features\n+\tstatus := pb.FunctionStatus{}\n+\tstatus.Running = true\n+\ttotalReceived := gi.getTotalReceived()\n+\ttotalProcessedSuccessfully := gi.getTotalProcessedSuccessfully()\n+\ttotalUserExceptions := gi.getTotalUserExceptions()\n+\ttotalSysExceptions := gi.getTotalSysExceptions()\n+\tavgProcessLatencyMs := gi.getAvgProcessLatency()\n+\tlastInvocation := gi.getLastInvocation()\n+\n+\tstatus.NumReceived = int64(totalReceived)\n+\tstatus.NumSuccessfullyProcessed = int64(totalProcessedSuccessfully)\n+\tstatus.NumUserExceptions = int64(totalUserExceptions)\n+\tstatus.InstanceId = strconv.Itoa(gi.context.instanceConf.instanceID)\n+\n+\tstatus.NumUserExceptions = int64(totalUserExceptions)\n+\tfor _, exPair := range gi.stats.latestUserException {\n+\t\ttoAdd := pb.FunctionStatus_ExceptionInformation{}\n+\t\ttoAdd.ExceptionString = exPair.exception.Error()\n+\t\ttoAdd.MsSinceEpoch = exPair.timestamp\n+\t\tstatus.LatestUserExceptions = append(status.LatestUserExceptions, &toAdd)\n+\t}\n+\n+\tstatus.NumSystemExceptions = int64(totalSysExceptions)\n+\tfor _, exPair := range gi.stats.latestSysException {\n+\t\ttoAdd := pb.FunctionStatus_ExceptionInformation{}\n+\t\ttoAdd.ExceptionString = exPair.exception.Error()\n+\t\ttoAdd.MsSinceEpoch = exPair.timestamp\n+\t\tstatus.LatestSystemExceptions = append(status.LatestSystemExceptions, &toAdd)\n+\t}\n+\tstatus.AverageLatency = float64(avgProcessLatencyMs)\n+\tstatus.LastInvocationTime = int64(lastInvocation)\n+\treturn &status\n+}\n+\n+func (gi *goInstance) getMetrics() *pb.MetricsData {\n+\ttotalReceived := gi.getTotalReceived()\n+\ttotalProcessedSuccessfully := gi.getTotalProcessedSuccessfully()\n+\ttotalUserExceptions := gi.getTotalUserExceptions()\n+\ttotalSysExceptions := gi.getTotalSysExceptions()\n+\tavgProcessLatencyMs := gi.getAvgProcessLatency()\n+\tlastInvocation := gi.getLastInvocation()\n+\n+\ttotalReceived1min := gi.getTotalReceived1min()\n+\ttotalProcessedSuccessfully1min := gi.getTotalProcessedSuccessfully1min()\n+\ttotalUserExceptions1min := gi.getTotalUserExceptions1min()\n+\ttotalSysExceptions1min := gi.getTotalSysExceptions1min()\n+\t//avg_process_latency_ms_1min := gi.get_avg_process_latency_1min()\n+\n+\tmetricsData := pb.MetricsData{}\n+\t// total metrics\n+\tmetricsData.ReceivedTotal = int64(totalReceived)\n+\tmetricsData.ProcessedSuccessfullyTotal = int64(totalProcessedSuccessfully)\n+\tmetricsData.SystemExceptionsTotal = int64(totalSysExceptions)\n+\tmetricsData.UserExceptionsTotal = int64(totalUserExceptions)\n+\tmetricsData.AvgProcessLatency = float64(avgProcessLatencyMs)\n+\tmetricsData.LastInvocation = int64(lastInvocation)\n+\t// 1min metrics\n+\tmetricsData.ReceivedTotal_1Min = int64(totalReceived1min)\n+\tmetricsData.ProcessedSuccessfullyTotal_1Min = int64(totalProcessedSuccessfully1min)\n+\tmetricsData.SystemExceptionsTotal_1Min = int64(totalSysExceptions1min)\n+\tmetricsData.UserExceptionsTotal_1Min = int64(totalUserExceptions1min)\n+\t//metrics_data.AvgProcessLatency_1Min = avg_process_latency_ms_1min\n+\n+\t// get any user metrics\n+\t// Not sure yet where these are stored.\n+\t/*\n+\t   user_metrics := self.contextimpl.get_metrics()\n+\t   for metric_name, value in user_metrics.items():\n+\t     metrics_data.userMetrics[metric_name] = value\n+\t*/\n+\n+\treturn &metricsData\n }\n \n func (gi *goInstance) getAndResetMetrics() *pb.MetricsData {\n-\treturn nil // Not implemented until we add the statistics features\n+\tmetricsData := gi.getMetrics()\n+\tgi.resetMetrics()\n+\treturn metricsData\n }\n \n func (gi *goInstance) resetMetrics() *empty.Empty {\n-\treturn nil // Not implemented until we add the statistics features\n+\tgi.stats.reset()\n+\treturn &empty.Empty{}\n }\n \n-func (gi *goInstance) getMetrics() *pb.MetricsData {\n-\treturn nil // Not implemented until we add the statistics features\n+// This method is used to get the required metrics for Prometheus.\n+// Note that this doesn't distinguish between parallel function instances!\n+func (gi *goInstance) getMatchingMetricFunc() func(lbl *io_prometheus_client.LabelPair) bool {\n+\tmatchMetricFunc := func(lbl *io_prometheus_client.LabelPair) bool {\n+\t\treturn *lbl.Name == \"fqfn\" && *lbl.Value == gi.context.GetTenantAndNamespaceAndName()\n+\t}\n+\treturn matchMetricFunc\n+}\n+\n+// e.g. metricName = \"pulsar_function_process_latency_ms\"\n+func (gi *goInstance) getMatchingMetricFromRegistry(metricName string) io_prometheus_client.Metric {\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil {\n+\t\tlog.Error(\"Something went wrong when calling reg.Gather() in getMatchingMetricFromRegistry(..) for \" + metricName)\n+\t}\n+\tmatchFamilyFunc := func(vect *io_prometheus_client.MetricFamily) bool {\n+\t\treturn *vect.Name == metricName\n+\t}\n+\tfiteredMetricFamilies := filter(metricFamilies, matchFamilyFunc)\n+\tif len(fiteredMetricFamilies) > 1 {\n+\t\t// handle this.\n+\t\tlog.Error(\"Too many metric families for metricName = \" + metricName)\n+\t\t// Should we panic here instead of report an error since it reflects a code problem, not a user problem?\n+\t}\n+\tmetricFunc := gi.getMatchingMetricFunc()\n+\tmatchingMetric := getFirstMatch(fiteredMetricFamilies[0].Metric, metricFunc)\n+\treturn *matchingMetric\n+}\n+\n+func (gi *goInstance) getTotalReceived() float32 {\n+\t// \"pulsar_function_\" + \"received_total\", NewGaugeVec.\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalReceived)\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+func (gi *goInstance) getTotalProcessedSuccessfully() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed)\n+\t// \"pulsar_function_\" + \"processed_successfully_total\", NewGaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+func (gi *goInstance) getTotalSysExceptions() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSystemExceptions)\n+\t// \"pulsar_function_\"+ \"system_exceptions_total\", NewGaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalUserExceptions() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalUserExceptions)\n+\t// \"pulsar_function_\" + \"user_exceptions_total\", NewGaugeVec\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getAvgProcessLatency() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + ProcessLatencyMs)\n+\t// \"pulsar_function_\" + \"process_latency_ms\", SummaryVec.\n+\tcount := metric.GetSummary().SampleCount\n+\tsum := metric.GetSummary().SampleSum\n+\tif *count <= 0.0 {\n+\t\treturn 0.0\n+\t}\n+\treturn float32(*sum) / float32(*count)\n+}\n+\n+func (gi *goInstance) getLastInvocation() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + LastInvocation)\n+\t// \"pulsar_function_\" + \"last_invocation\", GaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalProcessedSuccessfully1min() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed1min)\n+\t// \"pulsar_function_\" + \"processed_successfully_total_1min\", GaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalSysExceptions1min() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSystemExceptions1min)\n+\t// \"pulsar_function_\" + \"system_exceptions_total_1min\", GaugeVec\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalUserExceptions1min() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalUserExceptions1min)\n+\t// \"pulsar_function_\" + \"user_exceptions_total_1min\", GaugeVec\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+/*\n+func (gi *goInstance) get_avg_process_latency_1min() float32 {", "originalCommit": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM0OTU0OQ==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r406349549", "bodyText": "@jiazhai This is a method that isn't available due to the Prometheus architecture change they rolled out to their Go library. So, we need to find another way to capture the 1 min metrics. The comment was to note that this feature is currently missing.", "author": "devinbost", "createdAt": "2020-04-09T17:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyNTMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4OTY1OA==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r406389658", "bodyText": "I think this should be called before processResult.", "author": "sijie", "createdAt": "2020-04-09T18:17:27Z", "path": "pulsar-function-go/pf/instance.go", "diffHunk": "@@ -128,20 +146,27 @@ CLOSE:\n \t\t\tif autoAck && atMostOnce {\n \t\t\t\tgi.ackInputMessage(msgInput)\n \t\t\t}\n-\n+\t\t\tgi.stats.incrTotalReceived()\n \t\t\tgi.addLogTopicHandler()\n \n+\t\t\tgi.stats.setLastInvocation()\n+\t\t\tgi.stats.processTimeStart()\n+\n \t\t\toutput, err := gi.handlerMsg(msgInput)\n \t\t\tif err != nil {\n \t\t\t\tlog.Errorf(\"handler message error:%v\", err)\n \t\t\t\tif autoAck && atLeastOnce {\n \t\t\t\t\tgi.nackInputMessage(msgInput)\n \t\t\t\t}\n+\t\t\t\tgi.stats.incrTotalUserExceptions(err)\n \t\t\t\treturn err\n \t\t\t}\n \n \t\t\tgi.processResult(msgInput, output)\n \n+\t\t\tgi.stats.processTimeEnd() // Should this be called here or before processResult(..)?", "originalCommit": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNjQxOQ==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410816419", "bodyText": "Please replace panic with t.Fatal()", "author": "wolfstudy", "createdAt": "2020-04-19T05:02:22Z", "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){\n+\tvar metrics_label_names = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+\tvar exception_label_names = []string{\"error\", \"ts\"}\n+\tvar exception_metrics_label_names = append(metrics_label_names, exception_label_names...)\n+\tvar stat_process_latency_ms = prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName: PULSAR_FUNCTION_METRICS_PREFIX + PROCESS_LATENCY_MS,\n+\t\t\tHelp: \"Process latency in milliseconds.\"}, metrics_label_names)\n+\tvar reg *prometheus.Registry\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(stat_process_latency_ms)\n+\tmetrics_labels := []string{\"test-tenant\",\"test-tenant/test-namespace\", \"test-name\", \"1234\", \"test-cluster\",\n+\t\t\"test-tenant/test-namespace/test-name\"}\n+\t// 1234 is instanceId\n+\t// ['test-tenant', 'test-tenant/test-namespace', 'test-name',1234,\n+    //    'test-cluster', 'test-tenant/test-namespace/test-name']\n+\t//var _stat_process_latency_ms = stat_process_latency_ms.WithLabelValues(metrics_labels...)\n+\t//process_latency_ms_count := stat._stat_process_latency_ms._count.get()\n+\t//process_latency_ms_sum := stat._stat_process_latency_ms._sum.get()\n+}\n+func  (stat *StatWithLabelValues) getTotalReceived() float32 {\n+\tgathering, _ := reg.Gather()\n+\tout := &bytes.Buffer{}\n+\tfor _, mf := range gathering {\n+\t\tif _, err := expfmt.MetricFamilyToText(out, mf); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tfmt.Print(out.String())\n+\tfmt.Println(\"----------\")\n+}\n+*/\n+func TestExampleSummaryVec(t *testing.T) {\n+\n+\ttemps := prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName:       \"pond_temperature_celsius\",\n+\t\t\tHelp:       \"The temperature of the frog pond.\",\n+\t\t\tObjectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n+\t\t},\n+\t\t[]string{\"species\"},\n+\t)\n+\t// Simulate some observations.\n+\tfor i := 0; i < 1000; i++ {\n+\t\ttemps.WithLabelValues(\"litoria-caerulea\").Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)\n+\t\ttemps.WithLabelValues(\"lithobates-catesbeianus\").Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10)\n+\t}\n+\n+\t// Create a Summary without any observations.\n+\ttemps.WithLabelValues(\"leiopelma-hochstetteri\")\n+\n+\t// Just for demonstration, let's check the state of the summary vector\n+\t// by registering it with a custom registry and then let it collect the\n+\t// metrics.\n+\treg := prometheus.NewRegistry()\n+\treg.MustRegister(temps)\n+\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil || len(metricFamilies) != 1 {\n+\t\tpanic(\"unexpected behavior of custom test registry\")", "originalCommit": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNjQ0OQ==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410816449", "bodyText": "Please replace panic with t.Fatal()", "author": "wolfstudy", "createdAt": "2020-04-19T05:02:38Z", "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){\n+\tvar metrics_label_names = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+\tvar exception_label_names = []string{\"error\", \"ts\"}\n+\tvar exception_metrics_label_names = append(metrics_label_names, exception_label_names...)\n+\tvar stat_process_latency_ms = prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName: PULSAR_FUNCTION_METRICS_PREFIX + PROCESS_LATENCY_MS,\n+\t\t\tHelp: \"Process latency in milliseconds.\"}, metrics_label_names)\n+\tvar reg *prometheus.Registry\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(stat_process_latency_ms)\n+\tmetrics_labels := []string{\"test-tenant\",\"test-tenant/test-namespace\", \"test-name\", \"1234\", \"test-cluster\",\n+\t\t\"test-tenant/test-namespace/test-name\"}\n+\t// 1234 is instanceId\n+\t// ['test-tenant', 'test-tenant/test-namespace', 'test-name',1234,\n+    //    'test-cluster', 'test-tenant/test-namespace/test-name']\n+\t//var _stat_process_latency_ms = stat_process_latency_ms.WithLabelValues(metrics_labels...)\n+\t//process_latency_ms_count := stat._stat_process_latency_ms._count.get()\n+\t//process_latency_ms_sum := stat._stat_process_latency_ms._sum.get()\n+}\n+func  (stat *StatWithLabelValues) getTotalReceived() float32 {\n+\tgathering, _ := reg.Gather()\n+\tout := &bytes.Buffer{}\n+\tfor _, mf := range gathering {\n+\t\tif _, err := expfmt.MetricFamilyToText(out, mf); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tfmt.Print(out.String())\n+\tfmt.Println(\"----------\")\n+}\n+*/\n+func TestExampleSummaryVec(t *testing.T) {\n+\n+\ttemps := prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName:       \"pond_temperature_celsius\",\n+\t\t\tHelp:       \"The temperature of the frog pond.\",\n+\t\t\tObjectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n+\t\t},\n+\t\t[]string{\"species\"},\n+\t)\n+\t// Simulate some observations.\n+\tfor i := 0; i < 1000; i++ {\n+\t\ttemps.WithLabelValues(\"litoria-caerulea\").Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)\n+\t\ttemps.WithLabelValues(\"lithobates-catesbeianus\").Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10)\n+\t}\n+\n+\t// Create a Summary without any observations.\n+\ttemps.WithLabelValues(\"leiopelma-hochstetteri\")\n+\n+\t// Just for demonstration, let's check the state of the summary vector\n+\t// by registering it with a custom registry and then let it collect the\n+\t// metrics.\n+\treg := prometheus.NewRegistry()\n+\treg.MustRegister(temps)\n+\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil || len(metricFamilies) != 1 {\n+\t\tpanic(\"unexpected behavior of custom test registry\")\n+\t}\n+\tmatch := func(vect *io_prometheus_client.MetricFamily) bool {\n+\t\treturn *vect.Name == \"pond_temperature_celsius\"\n+\t}\n+\tfiteredMetricFamilies := filter(metricFamilies, match)\n+\n+\tif len(fiteredMetricFamilies) > 1 {\n+\t\tpanic(\"Too many metric families\")", "originalCommit": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNjU1OA==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410816558", "bodyText": "Why don't we use assert to compare whether the expected value and the actual value are equal? If my understanding is correct, this test case will succeed at any time, right?\nE.g:\nassert.Equal(t, x, y)", "author": "wolfstudy", "createdAt": "2020-04-19T05:03:08Z", "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){\n+\tvar metrics_label_names = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+\tvar exception_label_names = []string{\"error\", \"ts\"}\n+\tvar exception_metrics_label_names = append(metrics_label_names, exception_label_names...)\n+\tvar stat_process_latency_ms = prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName: PULSAR_FUNCTION_METRICS_PREFIX + PROCESS_LATENCY_MS,\n+\t\t\tHelp: \"Process latency in milliseconds.\"}, metrics_label_names)\n+\tvar reg *prometheus.Registry\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(stat_process_latency_ms)\n+\tmetrics_labels := []string{\"test-tenant\",\"test-tenant/test-namespace\", \"test-name\", \"1234\", \"test-cluster\",\n+\t\t\"test-tenant/test-namespace/test-name\"}\n+\t// 1234 is instanceId\n+\t// ['test-tenant', 'test-tenant/test-namespace', 'test-name',1234,\n+    //    'test-cluster', 'test-tenant/test-namespace/test-name']\n+\t//var _stat_process_latency_ms = stat_process_latency_ms.WithLabelValues(metrics_labels...)\n+\t//process_latency_ms_count := stat._stat_process_latency_ms._count.get()\n+\t//process_latency_ms_sum := stat._stat_process_latency_ms._sum.get()\n+}\n+func  (stat *StatWithLabelValues) getTotalReceived() float32 {\n+\tgathering, _ := reg.Gather()\n+\tout := &bytes.Buffer{}\n+\tfor _, mf := range gathering {\n+\t\tif _, err := expfmt.MetricFamilyToText(out, mf); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tfmt.Print(out.String())\n+\tfmt.Println(\"----------\")\n+}\n+*/\n+func TestExampleSummaryVec(t *testing.T) {\n+\n+\ttemps := prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName:       \"pond_temperature_celsius\",\n+\t\t\tHelp:       \"The temperature of the frog pond.\",\n+\t\t\tObjectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n+\t\t},\n+\t\t[]string{\"species\"},\n+\t)\n+\t// Simulate some observations.\n+\tfor i := 0; i < 1000; i++ {\n+\t\ttemps.WithLabelValues(\"litoria-caerulea\").Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)\n+\t\ttemps.WithLabelValues(\"lithobates-catesbeianus\").Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10)\n+\t}\n+\n+\t// Create a Summary without any observations.\n+\ttemps.WithLabelValues(\"leiopelma-hochstetteri\")\n+\n+\t// Just for demonstration, let's check the state of the summary vector\n+\t// by registering it with a custom registry and then let it collect the\n+\t// metrics.\n+\treg := prometheus.NewRegistry()\n+\treg.MustRegister(temps)\n+\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil || len(metricFamilies) != 1 {\n+\t\tpanic(\"unexpected behavior of custom test registry\")\n+\t}\n+\tmatch := func(vect *io_prometheus_client.MetricFamily) bool {\n+\t\treturn *vect.Name == \"pond_temperature_celsius\"\n+\t}\n+\tfiteredMetricFamilies := filter(metricFamilies, match)\n+\n+\tif len(fiteredMetricFamilies) > 1 {\n+\t\tpanic(\"Too many metric families\")\n+\t}\n+\t// Then, we need to filter the metrics in the family to one that matches our label.\n+\n+\tfmt.Println(proto.MarshalTextString(metricFamilies[0]))", "originalCommit": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNjY2Mg==", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410816662", "bodyText": "Please remove these comments if we don't need", "author": "wolfstudy", "createdAt": "2020-04-19T05:03:35Z", "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){\n+\tvar metrics_label_names = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+\tvar exception_label_names = []string{\"error\", \"ts\"}\n+\tvar exception_metrics_label_names = append(metrics_label_names, exception_label_names...)\n+\tvar stat_process_latency_ms = prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName: PULSAR_FUNCTION_METRICS_PREFIX + PROCESS_LATENCY_MS,\n+\t\t\tHelp: \"Process latency in milliseconds.\"}, metrics_label_names)\n+\tvar reg *prometheus.Registry\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(stat_process_latency_ms)\n+\tmetrics_labels := []string{\"test-tenant\",\"test-tenant/test-namespace\", \"test-name\", \"1234\", \"test-cluster\",\n+\t\t\"test-tenant/test-namespace/test-name\"}\n+\t// 1234 is instanceId\n+\t// ['test-tenant', 'test-tenant/test-namespace', 'test-name',1234,\n+    //    'test-cluster', 'test-tenant/test-namespace/test-name']\n+\t//var _stat_process_latency_ms = stat_process_latency_ms.WithLabelValues(metrics_labels...)\n+\t//process_latency_ms_count := stat._stat_process_latency_ms._count.get()\n+\t//process_latency_ms_sum := stat._stat_process_latency_ms._sum.get()\n+}\n+func  (stat *StatWithLabelValues) getTotalReceived() float32 {\n+\tgathering, _ := reg.Gather()\n+\tout := &bytes.Buffer{}\n+\tfor _, mf := range gathering {\n+\t\tif _, err := expfmt.MetricFamilyToText(out, mf); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tfmt.Print(out.String())\n+\tfmt.Println(\"----------\")\n+}\n+*/\n+func TestExampleSummaryVec(t *testing.T) {\n+\n+\ttemps := prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName:       \"pond_temperature_celsius\",\n+\t\t\tHelp:       \"The temperature of the frog pond.\",\n+\t\t\tObjectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n+\t\t},\n+\t\t[]string{\"species\"},\n+\t)\n+\t// Simulate some observations.\n+\tfor i := 0; i < 1000; i++ {\n+\t\ttemps.WithLabelValues(\"litoria-caerulea\").Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)\n+\t\ttemps.WithLabelValues(\"lithobates-catesbeianus\").Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10)\n+\t}\n+\n+\t// Create a Summary without any observations.\n+\ttemps.WithLabelValues(\"leiopelma-hochstetteri\")\n+\n+\t// Just for demonstration, let's check the state of the summary vector\n+\t// by registering it with a custom registry and then let it collect the\n+\t// metrics.\n+\treg := prometheus.NewRegistry()\n+\treg.MustRegister(temps)\n+\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil || len(metricFamilies) != 1 {\n+\t\tpanic(\"unexpected behavior of custom test registry\")\n+\t}\n+\tmatch := func(vect *io_prometheus_client.MetricFamily) bool {\n+\t\treturn *vect.Name == \"pond_temperature_celsius\"\n+\t}\n+\tfiteredMetricFamilies := filter(metricFamilies, match)\n+\n+\tif len(fiteredMetricFamilies) > 1 {\n+\t\tpanic(\"Too many metric families\")\n+\t}\n+\t// Then, we need to filter the metrics in the family to one that matches our label.\n+\n+\tfmt.Println(proto.MarshalTextString(metricFamilies[0]))\n+\n+\t// Output:\n+\t// name: \"pond_temperature_celsius\"\n+\t// help: \"The temperature of the frog pond.\"\n+\t// type: SUMMARY\n+\t// metric: <\n+\t//   label: <\n+\t//     name: \"species\"\n+\t//     value: \"leiopelma-hochstetteri\"\n+\t//   >\n+\t//   summary: <\n+\t//     sample_count: 0\n+\t//     sample_sum: 0\n+\t//     quantile: <\n+\t//       quantile: 0.5\n+\t//       value: nan\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.9\n+\t//       value: nan\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.99\n+\t//       value: nan\n+\t//     >\n+\t//   >\n+\t// >\n+\t// metric: <\n+\t//   label: <\n+\t//     name: \"species\"\n+\t//     value: \"lithobates-catesbeianus\"\n+\t//   >\n+\t//   summary: <\n+\t//     sample_count: 1000\n+\t//     sample_sum: 31956.100000000017\n+\t//     quantile: <\n+\t//       quantile: 0.5\n+\t//       value: 32.4\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.9\n+\t//       value: 41.4\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.99\n+\t//       value: 41.9\n+\t//     >\n+\t//   >\n+\t// >\n+\t// metric: <\n+\t//   label: <\n+\t//     name: \"species\"\n+\t//     value: \"litoria-caerulea\"\n+\t//   >\n+\t//   summary: <\n+\t//     sample_count: 1000\n+\t//     sample_sum: 29969.50000000001\n+\t//     quantile: <\n+\t//       quantile: 0.5\n+\t//       value: 31.1\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.9\n+\t//       value: 41.3\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.99\n+\t//       value: 41.9\n+\t//     >\n+\t//   >\n+\t// >", "originalCommit": "73e3c922c7c5192424e82ba5a53d85e53b930d26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}