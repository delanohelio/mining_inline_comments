{"pr_number": 6791, "pr_title": "Use consistent hashing in KeyShared distribution", "pr_createdAt": "2020-04-22T02:10:05Z", "pr_url": "https://github.com/apache/pulsar/pull/6791", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5NDg5MQ==", "url": "https://github.com/apache/pulsar/pull/6791#discussion_r413394891", "bodyText": "\"numberOfPoints\"", "author": "jerrypeng", "createdAt": "2020-04-22T23:13:12Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/HashRangeAutoSplitStickyKeyConsumerSelector.java", "diffHunk": "@@ -18,86 +18,64 @@\n  */\n package org.apache.pulsar.broker.service;\n \n-import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerAssignException;\n-import org.apache.pulsar.common.util.Murmur3_32Hash;\n-\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerAssignException;\n+import org.apache.pulsar.common.util.Murmur3_32Hash;\n \n /**\n  * This is a consumer selector based fixed hash range.\n  *\n- * 1.Each consumer serves a fixed range of hash value\n- * 2.The whole range of hash value could be covered by all the consumers.\n- * 3.Once a consumer is removed, the left consumers could still serve the whole range.\n- *\n- * Initializing with a fixed hash range, by default 2 << 5.\n- * First consumer added, hash range looks like:\n- *\n- * 0 -> 65536(consumer-1)\n- *\n- * Second consumer added, will find a biggest range to split:\n- *\n- * 0 -> 32768(consumer-2) -> 65536(consumer-1)\n- *\n- * While a consumer removed, The range for this consumer will be taken over\n- * by other consumer, consumer-2 removed:\n- *\n- * 0 -> 65536(consumer-1)\n- *\n- * In this approach use skip list map to maintain the hash range and consumers.\n- *\n- * Select consumer will return the ceiling key of message key hashcode % range size.\n- *\n+ * The implementation uses consistent hashing to evenly split, the\n+ * number of keys assigned to each consumer.\n  */\n public class HashRangeAutoSplitStickyKeyConsumerSelector implements StickyKeyConsumerSelector {\n \n-    private final int rangeSize;\n+    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n \n-    private final ConcurrentSkipListMap<Integer, Consumer> rangeMap;\n-    private final Map<Consumer, Integer> consumerRange;\n+    // Consistent-Hash ring\n+    private final NavigableMap<Integer, Consumer> hashRing;\n \n-    public HashRangeAutoSplitStickyKeyConsumerSelector() {\n-        this(DEFAULT_RANGE_SIZE);\n-    }\n+    private final int numberOfPOints;\n \n-    public HashRangeAutoSplitStickyKeyConsumerSelector(int rangeSize) {\n-        if (rangeSize < 2) {\n-            throw new IllegalArgumentException(\"range size must greater than 2\");\n-        }\n-        if (!is2Power(rangeSize)) {\n-            throw new IllegalArgumentException(\"range size must be nth power with 2\");\n-        }\n-        this.rangeMap = new ConcurrentSkipListMap<>();\n-        this.consumerRange = new HashMap<>();\n-        this.rangeSize = rangeSize;\n+    public HashRangeAutoSplitStickyKeyConsumerSelector(int numberOfPOints) {\n+        this.hashRing = new TreeMap<>();\n+        this.numberOfPOints = numberOfPOints;\n     }\n \n     @Override\n-    public synchronized void addConsumer(Consumer consumer) throws ConsumerAssignException {\n-        if (rangeMap.size() == 0) {\n-            rangeMap.put(rangeSize, consumer);\n-            consumerRange.put(consumer, rangeSize);\n-        } else {\n-            splitRange(findBiggestRange(), consumer);\n+    public void addConsumer(Consumer consumer) throws ConsumerAssignException {\n+        rwLock.writeLock().lock();\n+        try {\n+            // Insert multiple points on the hash ring for every consumer\n+            // The points are deterministically added based on the hash of the consumer name\n+            for (int i = 0; i < numberOfPOints; i++) {", "originalCommit": "de02daa34d51b92fe535f3470ad9ab328553fc66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5NTQ4MA==", "url": "https://github.com/apache/pulsar/pull/6791#discussion_r413395480", "bodyText": "When removing consumers from the hash ring, is it necessary to check if the value of the key we are removing is also equals the consumer?  In what case, will that not be true?", "author": "jerrypeng", "createdAt": "2020-04-22T23:14:45Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/HashRangeAutoSplitStickyKeyConsumerSelector.java", "diffHunk": "@@ -18,86 +18,64 @@\n  */\n package org.apache.pulsar.broker.service;\n \n-import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerAssignException;\n-import org.apache.pulsar.common.util.Murmur3_32Hash;\n-\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerAssignException;\n+import org.apache.pulsar.common.util.Murmur3_32Hash;\n \n /**\n  * This is a consumer selector based fixed hash range.\n  *\n- * 1.Each consumer serves a fixed range of hash value\n- * 2.The whole range of hash value could be covered by all the consumers.\n- * 3.Once a consumer is removed, the left consumers could still serve the whole range.\n- *\n- * Initializing with a fixed hash range, by default 2 << 5.\n- * First consumer added, hash range looks like:\n- *\n- * 0 -> 65536(consumer-1)\n- *\n- * Second consumer added, will find a biggest range to split:\n- *\n- * 0 -> 32768(consumer-2) -> 65536(consumer-1)\n- *\n- * While a consumer removed, The range for this consumer will be taken over\n- * by other consumer, consumer-2 removed:\n- *\n- * 0 -> 65536(consumer-1)\n- *\n- * In this approach use skip list map to maintain the hash range and consumers.\n- *\n- * Select consumer will return the ceiling key of message key hashcode % range size.\n- *\n+ * The implementation uses consistent hashing to evenly split, the\n+ * number of keys assigned to each consumer.\n  */\n public class HashRangeAutoSplitStickyKeyConsumerSelector implements StickyKeyConsumerSelector {\n \n-    private final int rangeSize;\n+    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n \n-    private final ConcurrentSkipListMap<Integer, Consumer> rangeMap;\n-    private final Map<Consumer, Integer> consumerRange;\n+    // Consistent-Hash ring\n+    private final NavigableMap<Integer, Consumer> hashRing;\n \n-    public HashRangeAutoSplitStickyKeyConsumerSelector() {\n-        this(DEFAULT_RANGE_SIZE);\n-    }\n+    private final int numberOfPOints;\n \n-    public HashRangeAutoSplitStickyKeyConsumerSelector(int rangeSize) {\n-        if (rangeSize < 2) {\n-            throw new IllegalArgumentException(\"range size must greater than 2\");\n-        }\n-        if (!is2Power(rangeSize)) {\n-            throw new IllegalArgumentException(\"range size must be nth power with 2\");\n-        }\n-        this.rangeMap = new ConcurrentSkipListMap<>();\n-        this.consumerRange = new HashMap<>();\n-        this.rangeSize = rangeSize;\n+    public HashRangeAutoSplitStickyKeyConsumerSelector(int numberOfPOints) {\n+        this.hashRing = new TreeMap<>();\n+        this.numberOfPOints = numberOfPOints;\n     }\n \n     @Override\n-    public synchronized void addConsumer(Consumer consumer) throws ConsumerAssignException {\n-        if (rangeMap.size() == 0) {\n-            rangeMap.put(rangeSize, consumer);\n-            consumerRange.put(consumer, rangeSize);\n-        } else {\n-            splitRange(findBiggestRange(), consumer);\n+    public void addConsumer(Consumer consumer) throws ConsumerAssignException {\n+        rwLock.writeLock().lock();\n+        try {\n+            // Insert multiple points on the hash ring for every consumer\n+            // The points are deterministically added based on the hash of the consumer name\n+            for (int i = 0; i < numberOfPOints; i++) {\n+                String key = consumer.consumerName() + i;\n+                int hash = Murmur3_32Hash.getInstance().makeHash(key.getBytes());\n+                hashRing.put(hash, consumer);\n+            }\n+        } finally {\n+            rwLock.writeLock().unlock();\n         }\n     }\n \n     @Override\n-    public synchronized void removeConsumer(Consumer consumer) {\n-        Integer removeRange = consumerRange.remove(consumer);\n-        if (removeRange != null) {\n-            if (removeRange == rangeSize && rangeMap.size() > 1) {\n-                Map.Entry<Integer, Consumer> lowerEntry = rangeMap.lowerEntry(removeRange);\n-                rangeMap.put(removeRange, lowerEntry.getValue());\n-                rangeMap.remove(lowerEntry.getKey());\n-                consumerRange.put(lowerEntry.getValue(), removeRange);\n-            } else {\n-                rangeMap.remove(removeRange);\n+    public void removeConsumer(Consumer consumer) {\n+        rwLock.writeLock().lock();\n+        try {\n+            // Remove all the points that were added for this consumer\n+            for (int i = 0; i < numberOfPOints; i++) {\n+                String key = consumer.consumerName() + i;\n+                int hash = Murmur3_32Hash.getInstance().makeHash(key.getBytes());\n+                hashRing.remove(hash, consumer);", "originalCommit": "de02daa34d51b92fe535f3470ad9ab328553fc66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5ODczOQ==", "url": "https://github.com/apache/pulsar/pull/6791#discussion_r413398739", "bodyText": "It's necessary because there can be a hash conflict. When that happens, the point will only be assigned to one consumer.\nIt is not a problem since we have multiple points in the ring, though when we remove c1 we need to be sure we're not removing a point that was actually assigned to c2.", "author": "merlimat", "createdAt": "2020-04-22T23:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5NTQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxNjM2NA==", "url": "https://github.com/apache/pulsar/pull/6791#discussion_r413416364", "bodyText": "I see thanks for the explanation", "author": "jerrypeng", "createdAt": "2020-04-23T00:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5NTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNTM5NQ==", "url": "https://github.com/apache/pulsar/pull/6791#discussion_r413405395", "bodyText": "Why are we deleting this whole test?", "author": "jerrypeng", "createdAt": "2020-04-22T23:39:55Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/client/api/NonPersistentKeySharedSubscriptionTest.java", "diffHunk": "@@ -1,482 +0,0 @@\n-/**", "originalCommit": "de02daa34d51b92fe535f3470ad9ab328553fc66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMTUwMA==", "url": "https://github.com/apache/pulsar/pull/6791#discussion_r413411500", "bodyText": "I've removed the duplicated code for the non-persistent tests. Instead I've added a matrix of tests at https://github.com/apache/pulsar/pull/6791/files#diff-57c959d83bcb0f61a1de2014e9ea8a30R63", "author": "merlimat", "createdAt": "2020-04-22T23:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNTM5NQ=="}], "type": "inlineReview"}, {"oid": "7c5ca21346bc8bcb655964155d56499ae1811699", "url": "https://github.com/apache/pulsar/commit/7c5ca21346bc8bcb655964155d56499ae1811699", "message": "Use consistent hashing in KeyShared distribution", "committedDate": "2020-05-27T23:25:24Z", "type": "commit"}, {"oid": "3724dfcac8c12f17d89b26445ca9fd577a646b58", "url": "https://github.com/apache/pulsar/commit/3724dfcac8c12f17d89b26445ca9fd577a646b58", "message": "Added configuration option to enable consistent hashing", "committedDate": "2020-05-27T23:37:25Z", "type": "forcePushed"}, {"oid": "bf2833c26d87967354150d765e552e63f214e10c", "url": "https://github.com/apache/pulsar/commit/bf2833c26d87967354150d765e552e63f214e10c", "message": "Added configuration option to enable consistent hashing", "committedDate": "2020-05-27T23:53:36Z", "type": "commit"}, {"oid": "bf2833c26d87967354150d765e552e63f214e10c", "url": "https://github.com/apache/pulsar/commit/bf2833c26d87967354150d765e552e63f214e10c", "message": "Added configuration option to enable consistent hashing", "committedDate": "2020-05-27T23:53:36Z", "type": "forcePushed"}, {"oid": "d3fe0b0f2d186cb62a7064d0b7ab0d1cf9727df1", "url": "https://github.com/apache/pulsar/commit/d3fe0b0f2d186cb62a7064d0b7ab0d1cf9727df1", "message": "Merge remote-tracking branch 'apache/master' into key-shared-master", "committedDate": "2020-05-29T05:40:36Z", "type": "commit"}]}