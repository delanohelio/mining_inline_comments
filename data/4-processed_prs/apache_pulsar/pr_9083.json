{"pr_number": 9083, "pr_title": "Issue 9082: Broker expires messages one at a time after topic unload", "pr_createdAt": "2020-12-29T13:35:28Z", "pr_url": "https://github.com/apache/pulsar/pull/9083", "timeline": [{"oid": "8ea72366c95cff6d91778a976b9ab86c9849ade8", "url": "https://github.com/apache/pulsar/commit/8ea72366c95cff6d91778a976b9ab86c9849ade8", "message": "Message TTL expires 1 message at a time", "committedDate": "2020-12-23T10:23:03Z", "type": "commit"}, {"oid": "68e03cc8dd05f64d61f58849cd4b115190406d9e", "url": "https://github.com/apache/pulsar/commit/68e03cc8dd05f64d61f58849cd4b115190406d9e", "message": "Fix message expiration in case of topic unload", "committedDate": "2020-12-29T12:16:26Z", "type": "commit"}, {"oid": "5dae9528e5683d5da608c0ce060cd8a6de5ed71b", "url": "https://github.com/apache/pulsar/commit/5dae9528e5683d5da608c0ce060cd8a6de5ed71b", "message": "clean log", "committedDate": "2020-12-29T12:17:20Z", "type": "commit"}, {"oid": "9d82838bc593ff2255745e4214ddb3a80be08e39", "url": "https://github.com/apache/pulsar/commit/9d82838bc593ff2255745e4214ddb3a80be08e39", "message": "Merge branch 'fix/expire-batch' into fix/expire-more-messages", "committedDate": "2020-12-29T12:54:54Z", "type": "commit"}, {"oid": "22d814b7caa5d40e7a7d6e14bcf7ea0695f34d90", "url": "https://github.com/apache/pulsar/commit/22d814b7caa5d40e7a7d6e14bcf7ea0695f34d90", "message": "add end-to-end tests", "committedDate": "2020-12-29T13:21:15Z", "type": "commit"}, {"oid": "0b1b02868d5dda63a5d82f896d53513104c1320c", "url": "https://github.com/apache/pulsar/commit/0b1b02868d5dda63a5d82f896d53513104c1320c", "message": "remove debug", "committedDate": "2020-12-29T13:23:40Z", "type": "commit"}, {"oid": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "url": "https://github.com/apache/pulsar/commit/7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "message": "Add unit test", "committedDate": "2020-12-29T14:08:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTAzNg==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549781036", "bodyText": "add this to a if (log.isDebugEnabled()) block.", "author": "sijie", "createdAt": "2020-12-29T17:09:14Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/OpFindNewest.java", "diffHunk": "@@ -92,10 +94,14 @@ public void readEntryComplete(Entry entry, Object ctx) {\n                 return;\n             } else {\n                 lastMatchedPosition = position;\n-\n                 // check last entry\n                 state = State.checkLast;\n+                PositionImpl lastPosition = ledger.getLastPosition();\n                 searchPosition = ledger.getPositionAfterN(searchPosition, max, PositionBound.startExcluded);\n+                if (lastPosition.compareTo(searchPosition) < 0) {\n+                    log.debug(\"first position {} matches, last should be {}, but moving to lastPos {}\", position, searchPosition, lastPosition);", "originalCommit": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDExNTY4NQ==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550115685", "bodyText": "done", "author": "eolivelli", "createdAt": "2020-12-30T10:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTUxMg==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549781512", "bodyText": "This test doesn't make any sense to me. You are adding 5 entries with the same content.", "author": "sijie", "createdAt": "2020-12-29T17:10:58Z", "path": "managed-ledger/src/test/java/org/apache/bookkeeper/mledger/impl/ManagedCursorTest.java", "diffHunk": "@@ -2140,6 +2141,28 @@ void testIndividuallyDeletedMessages3(boolean useOpenRangeSet) throws Exception\n         assertTrue(c1.isIndividuallyDeletedEntriesEmpty());\n     }\n \n+    @Test(timeOut = 20000)\n+    void testFindNewestMatchingAfterLedgerRollover() throws Exception {\n+        ManagedLedgerImpl ledger = (ManagedLedgerImpl) factory.open(\"my_test_ledger\");\n+        ManagedCursorImpl c1 = (ManagedCursorImpl) ledger.openCursor(\"c1\");\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        ledger.addEntry(\"expired\".getBytes(Encoding));\n+        Position last = ledger.addEntry(\"expired\".getBytes(Encoding));\n+\n+        // roll a new ledger\n+        int numLedgersBefore = ledger.getLedgersInfo().size();\n+        ledger.getConfig().setMaxEntriesPerLedger(1);\n+        ledger.rollCurrentLedgerIfFull();\n+        Awaitility.await().atMost(20, TimeUnit.SECONDS)\n+                .until(() -> ledger.getLedgersInfo().size() > numLedgersBefore);\n+\n+        assertEquals(last,\n+                c1.findNewestMatching(entry -> Arrays.equals(entry.getDataAndRelease(), \"expired\".getBytes(Encoding))));", "originalCommit": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4NzQ2Nw==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549787467", "bodyText": "it is the same thing that happens with \"expired\" messages.\nIf you have all of the messages \"expired\" the condition evaluates to true for every message (\"message is expired\"), and in that case findNewestMatching must return the last message in the topic.", "author": "eolivelli", "createdAt": "2020-12-29T17:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDEzMTMyNA==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550131324", "bodyText": "But you can't tell if \"expired\" message is the last message. Because all the messages have the same content.", "author": "sijie", "createdAt": "2020-12-30T10:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDEzMjE2NQ==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550132165", "bodyText": "I see your point, let me update the test. thanks for the clarification", "author": "eolivelli", "createdAt": "2020-12-30T10:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTg4Nw==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549781887", "bodyText": "Can we avoid using Thread.sleep?", "author": "sijie", "createdAt": "2020-12-29T17:12:10Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);", "originalCommit": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4OTUzMg==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549789532", "bodyText": "I cannot do it, because with this sleep all of the messages will be considered \"expired\"\nAKAIF there is no framework/tool in Pulsar Codebase to simulate wall clock time, if we want to do something better we will have to introduce it.\nProbably it is overkill for this patch.\nIn this case we are not \"waiting\" for something, we just have to let the time pass (so Awaitility won't help).", "author": "eolivelli", "createdAt": "2020-12-29T17:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MTg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjA0Ng==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549782046", "bodyText": "How does this make the test easier and predictable?", "author": "sijie", "createdAt": "2020-12-29T17:12:46Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+        \n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable", "originalCommit": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4NzkyOA==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549787928", "bodyText": "because I want to see that the Consumer pre-fetched one message, and so it can \"see\" an expired message,\nthis is what happens and I want to test it in order to prevent behaviour changes in the future.", "author": "eolivelli", "createdAt": "2020-12-29T17:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDEzMzY2MA==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550133660", "bodyText": "I don't think so. If you are testing TTL, it doesn't really matter how large is your receiver queue. Messages are expired at the broker side, not in the consumer side. Such code introduces confusion.", "author": "sijie", "createdAt": "2020-12-30T10:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDEzNDYzOA==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550134638", "bodyText": "I will rework the test", "author": "eolivelli", "createdAt": "2020-12-30T10:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE2MDA2NQ==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550160065", "bodyText": "I have dropped the test, it. simply reproduced a case from one of my users.\nno need to keep it here, it does not cover the fix", "author": "eolivelli", "createdAt": "2020-12-30T11:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjYxNQ==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549782615", "bodyText": "You just use this consumer to create a subscription. Why setting receiverQueueSize makes the test easier and predictable?", "author": "sijie", "createdAt": "2020-12-29T17:14:34Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable", "originalCommit": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4NzYzNQ==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549787635", "bodyText": "it is only a copy/paste from the test below. I will drop this line, it does not matter", "author": "eolivelli", "createdAt": "2020-12-29T17:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MjYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MzY1NQ==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549783655", "bodyText": "This doesn't make any sense to me. It will result in the test waiting for 10 seconds.\nA deterministic approach is using getLastMessageId to check if the messages are expired.", "author": "sijie", "createdAt": "2020-12-29T17:17:38Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+        \n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe();\n+        Message<byte[]> msg = consumer.receive(10, java.util.concurrent.TimeUnit.SECONDS);", "originalCommit": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc5MDg4MQ==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549790881", "bodyText": "I am not sure I understand, getLastMessageId is returning a non-null MessageId here", "author": "eolivelli", "createdAt": "2020-12-29T17:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MzY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDEzNDU0MQ==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550134541", "bodyText": "You can compare the last message id with the published message-ids to determine if a message is expired or not.", "author": "sijie", "createdAt": "2020-12-30T10:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MzY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE1NDI5OQ==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550154299", "bodyText": "I am sorry @sijie but in this point of the execution the consumer is returning the same messageId as the messageId of the last written message, even if the message is expired.\nI added a debug message locally and this is the result:\nINFO  org.apache.pulsar.broker.service.MessageTTLTest - lastMessageID written 3:49:-1, lastMessageIdForConsumer 3:49:-1", "author": "eolivelli", "createdAt": "2020-12-30T11:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MzY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4Mzc0Mw==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r549783743", "bodyText": "Same comment as above.", "author": "sijie", "createdAt": "2020-12-29T17:17:56Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.awaitility.Awaitility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        \n+        pulsarClient.newConsumer()\n+                .topic(topicName).subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe()\n+                .close();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);        \n+        admin.topics().getStats(topicName);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+        \n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe();\n+        Message<byte[]> msg = consumer.receive(10, java.util.concurrent.TimeUnit.SECONDS);\n+        assertNull(msg);\n+        consumer.close();\n+    }\n+\n+    \n+    @Test\n+    public void testStandardMessageExpiry() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionName(subscriptionName)\n+                .subscriptionType(SubscriptionType.Key_Shared) // this has not effect, Exclusive mode works as well\n+                .receiverQueueSize(1) // this makes the test easier and predictable\n+                .subscribe();\n+        \n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+       \n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        \n+        Message<byte[]> msg = consumer.receive(10, java.util.concurrent.TimeUnit.SECONDS);\n+        assertNotNull(msg);\n+        consumer.acknowledge(msg);\n+       \n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        this.runMessageExpiryCheck();\n+        \n+        Message<byte[]> msg2 = consumer.receive(1, java.util.concurrent.TimeUnit.SECONDS);\n+        // the consumer prefetched a message (or a batch of messages in case of enableBatching(true))\n+        assertNotNull(msg);\n+        consumer.acknowledge(msg2);\n+        // all messages expired, so we expect to see a null here\n+        Message<byte[]> msg3 = consumer.receive(1, java.util.concurrent.TimeUnit.SECONDS);", "originalCommit": "7fed230aa722c49ede426c1dc66b7e66b7fb6e32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8c9c6f141f0f75aac110cb7ec668d4a708e7485b", "url": "https://github.com/apache/pulsar/commit/8c9c6f141f0f75aac110cb7ec668d4a708e7485b", "message": "Address part of Sijie's comments", "committedDate": "2020-12-29T17:41:35Z", "type": "commit"}, {"oid": "24a06b4c78ee66903f856d036e70b923d7075edb", "url": "https://github.com/apache/pulsar/commit/24a06b4c78ee66903f856d036e70b923d7075edb", "message": "decrease timeout", "committedDate": "2020-12-29T17:43:06Z", "type": "commit"}, {"oid": "f7a0c7ce8e83c6c7c89cf95d7d505b31baba84ca", "url": "https://github.com/apache/pulsar/commit/f7a0c7ce8e83c6c7c89cf95d7d505b31baba84ca", "message": "address more comments", "committedDate": "2020-12-30T11:22:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE2MTI1NA==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r550161254", "bodyText": "these two values are the same, even if the messages are expired", "author": "eolivelli", "createdAt": "2020-12-30T11:26:44Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/MessageTTLTest.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+\n+import com.google.common.collect.Lists;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.MessageId;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class MessageTTLTest extends BrokerTestBase {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MessageTTLTest.class);\n+    @BeforeClass\n+    @Override\n+    protected void setup() throws Exception {\n+        this.conf.setTtlDurationDefaultInSeconds(1);\n+        this.conf.setBrokerDeleteInactiveTopicsEnabled(false);\n+        super.baseSetup();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    @Test\n+    public void testMessageExpiryAfterTopicUnload() throws Exception {\n+        int numMsgs = 50;\n+        final String topicName = \"persistent://prop/ns-abc/testttl\";\n+        final String subscriptionName = \"ttl-sub-1\";\n+\n+        pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .subscribe()\n+                .close();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .enableBatching(false) // this makes the test easier and predictable\n+                .create();\n+\n+        List<CompletableFuture<MessageId>> sendFutureList = Lists.newArrayList();\n+        for (int i = 0; i < numMsgs; i++) {\n+            byte[] message = (\"my-message-\" + i).getBytes();\n+            sendFutureList.add(producer.sendAsync(message));\n+        }\n+        FutureUtil.waitForAll(sendFutureList).get();\n+        producer.close();\n+        MessageId lastMessageId = sendFutureList.get(sendFutureList.size() - 1).get();\n+\n+        // unload a reload the topic\n+        // this action created a new ledger\n+        // having a managed ledger with more than one\n+        // ledger should not impact message expiration\n+        admin.topics().unload(topicName);\n+        admin.topics().getStats(topicName);\n+\n+        AbstractTopic topic = (AbstractTopic) pulsar.getBrokerService().getTopicReference(topicName).get();\n+        // wall clock time, we have to make the message to be considered \"expired\"\n+        Thread.sleep(this.conf.getTtlDurationDefaultInSeconds() * 2000);\n+        log.info(\"***** run message expiry now\");\n+        this.runMessageExpiryCheck();\n+\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer()\n+                .topic(topicName)\n+                .subscriptionName(subscriptionName)\n+                .subscribe();\n+\n+        MessageId lastMessageIdOnConsumer = consumer.getLastMessageId();\n+        log.info(\"lastMessageID written {}, lastMessageIdForConsumer {}\", lastMessageId, lastMessageIdOnConsumer);", "originalCommit": "f7a0c7ce8e83c6c7c89cf95d7d505b31baba84ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjUwNjA3MA==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r552506070", "bodyText": "You are right. I think you can get stats-internal to get the internal stats to get the markDeletePosition. If you see the markDeletePosition is moved, it means TTL is taking effect.", "author": "sijie", "createdAt": "2021-01-06T10:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE2MTI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE3NjUzMw==", "url": "https://github.com/apache/pulsar/pull/9083#discussion_r553176533", "bodyText": "very good @sijie\nI have updated the test", "author": "eolivelli", "createdAt": "2021-01-07T08:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE2MTI1NA=="}], "type": "inlineReview"}, {"oid": "e78c0bb3956acf0fe7acc8a405261fea101afe82", "url": "https://github.com/apache/pulsar/commit/e78c0bb3956acf0fe7acc8a405261fea101afe82", "message": "Merge remote-tracking branch 'origin/master' into fix/expire-more-messages", "committedDate": "2021-01-05T09:51:21Z", "type": "commit"}, {"oid": "cf927dd0b88b2ebc1505f629259085d0ea058068", "url": "https://github.com/apache/pulsar/commit/cf927dd0b88b2ebc1505f629259085d0ea058068", "message": "Merge remote-tracking branch 'origin/master' into fix/expire-more-messages", "committedDate": "2021-01-07T07:58:23Z", "type": "commit"}, {"oid": "20ddd5f7edd44035aa15f43200bd7f854239fa6b", "url": "https://github.com/apache/pulsar/commit/20ddd5f7edd44035aa15f43200bd7f854239fa6b", "message": "Enhance test", "committedDate": "2021-01-07T08:29:50Z", "type": "commit"}]}