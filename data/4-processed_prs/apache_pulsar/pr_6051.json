{"pr_number": 6051, "pr_title": "Expose lastConsumedTimestamp and lastAckedTimestamp to consumer stats", "pr_createdAt": "2020-01-14T11:59:38Z", "pr_url": "https://github.com/apache/pulsar/pull/6051", "timeline": [{"oid": "d22242bd43c31d980ed3999ec691069f60871228", "url": "https://github.com/apache/pulsar/commit/d22242bd43c31d980ed3999ec691069f60871228", "message": "Expose lastConsumedTimestamp and lastAckedTimestamp to consumer stats\n---\n\nMaster Issue: #6046\n\n*Motivation*\n\nMake people can use the timestamp to tell if acknowledge and consumption\nare happening.\n\n*Modifications*\n\n- Add lastConsumedTimestamp and lastAckedTimestamp to consume stats\n\n*Verify this change*\n\n- Pass the test `testConsumerStatsLastTimestamp`", "committedDate": "2020-01-14T11:54:11Z", "type": "commit"}, {"oid": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389", "url": "https://github.com/apache/pulsar/commit/567e6e5b343da5a4f4285e10b5d9feb2dbc1b389", "message": "* Expose the stats to the subscription stats", "committedDate": "2020-01-15T05:48:03Z", "type": "commit"}, {"oid": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389", "url": "https://github.com/apache/pulsar/commit/567e6e5b343da5a4f4285e10b5d9feb2dbc1b389", "message": "* Expose the stats to the subscription stats", "committedDate": "2020-01-15T05:48:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0OTM4Mw==", "url": "https://github.com/apache/pulsar/pull/6051#discussion_r368249383", "bodyText": "don't you need to call #receive to ensure the message is dispatched to the consumer? Otherwise this can easily become a flaky test.", "author": "sijie", "createdAt": "2020-01-18T21:25:49Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "diffHunk": "@@ -948,4 +952,98 @@ public void testCreateNamespaceWithNoClusters() throws PulsarAdminException {\n         assertEquals(admin.namespaces().getNamespaceReplicationClusters(namespace),\n                 Collections.singletonList(localCluster));\n     }\n+\n+    @Test(timeOut = 30000)\n+    public void testConsumerStatsLastTimestamp() throws PulsarClientException, PulsarAdminException, InterruptedException {\n+        long timestamp = System.currentTimeMillis();\n+        final String topicName = \"consumer-stats-\" + timestamp;\n+        final String subscribeName = topicName + \"-test-stats-sub\";\n+        final String topic = \"persistent://prop-xyz/ns1/\" + topicName;\n+        final String producerName = \"producer-\" + topicName;\n+\n+        @Cleanup\n+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsar.getWebServiceAddress()).build();\n+        Producer<byte[]> producer = client.newProducer().topic(topic)\n+            .enableBatching(false)\n+            .producerName(producerName)\n+            .create();\n+\n+        // a. Send a message to the topic.\n+        producer.send(\"message-1\".getBytes(StandardCharsets.UTF_8));\n+\n+        // b. Create a consumer, because there was a message in the topic, the consumer will receive the message pushed\n+        // by the broker, the lastConsumedTimestamp will as the consume subscribe time.\n+        Consumer<byte[]> consumer = client.newConsumer().topic(topic)\n+            .subscriptionName(subscribeName)\n+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n+            .subscribe();\n+\n+        // Get the consumer stats.\n+        TopicStats topicStats = admin.topics().getStats(topic);", "originalCommit": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0OTQwOA==", "url": "https://github.com/apache/pulsar/pull/6051#discussion_r368249408", "bodyText": "move this to the line 979", "author": "sijie", "createdAt": "2020-01-18T21:26:19Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "diffHunk": "@@ -948,4 +952,98 @@ public void testCreateNamespaceWithNoClusters() throws PulsarAdminException {\n         assertEquals(admin.namespaces().getNamespaceReplicationClusters(namespace),\n                 Collections.singletonList(localCluster));\n     }\n+\n+    @Test(timeOut = 30000)\n+    public void testConsumerStatsLastTimestamp() throws PulsarClientException, PulsarAdminException, InterruptedException {\n+        long timestamp = System.currentTimeMillis();\n+        final String topicName = \"consumer-stats-\" + timestamp;\n+        final String subscribeName = topicName + \"-test-stats-sub\";\n+        final String topic = \"persistent://prop-xyz/ns1/\" + topicName;\n+        final String producerName = \"producer-\" + topicName;\n+\n+        @Cleanup\n+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsar.getWebServiceAddress()).build();\n+        Producer<byte[]> producer = client.newProducer().topic(topic)\n+            .enableBatching(false)\n+            .producerName(producerName)\n+            .create();\n+\n+        // a. Send a message to the topic.\n+        producer.send(\"message-1\".getBytes(StandardCharsets.UTF_8));\n+\n+        // b. Create a consumer, because there was a message in the topic, the consumer will receive the message pushed\n+        // by the broker, the lastConsumedTimestamp will as the consume subscribe time.\n+        Consumer<byte[]> consumer = client.newConsumer().topic(topic)\n+            .subscriptionName(subscribeName)\n+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n+            .subscribe();\n+\n+        // Get the consumer stats.\n+        TopicStats topicStats = admin.topics().getStats(topic);\n+        SubscriptionStats subscriptionStats = topicStats.subscriptions.get(subscribeName);\n+        long startConsumedFlowTimestamp = subscriptionStats.lastConsumedFlowTimestamp;\n+        long startAckedTimestampInSubStats = subscriptionStats.lastAckedTimestamp;\n+        ConsumerStats consumerStats = subscriptionStats.consumers.get(0);\n+        long startConsumedTimestampInConsumerStats = consumerStats.lastConsumedTimestamp;\n+        long startAckedTimestampInConsumerStats = consumerStats.lastAckedTimestamp;\n+\n+        // Because the message was pushed by the broker, the consumedTimestamp should not as 0.\n+        assertNotEquals(0, startConsumedTimestampInConsumerStats);\n+        // There is no consumer ack the message, so the lastAckedTimestamp still as 0.\n+        assertEquals(0, startAckedTimestampInConsumerStats);\n+        assertNotEquals(0, startConsumedFlowTimestamp);\n+        assertEquals(0, startAckedTimestampInSubStats);\n+\n+        // c. The Consumer receives the message and acks the message.\n+        Message<byte[]> message = consumer.receive();", "originalCommit": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0OTQ0MA==", "url": "https://github.com/apache/pulsar/pull/6051#discussion_r368249440", "bodyText": "I wouldn't suggest using sleep here. We should periodically getting the consumer stats until the lastAckedTimestamp get updated.", "author": "sijie", "createdAt": "2020-01-18T21:27:16Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "diffHunk": "@@ -948,4 +952,98 @@ public void testCreateNamespaceWithNoClusters() throws PulsarAdminException {\n         assertEquals(admin.namespaces().getNamespaceReplicationClusters(namespace),\n                 Collections.singletonList(localCluster));\n     }\n+\n+    @Test(timeOut = 30000)\n+    public void testConsumerStatsLastTimestamp() throws PulsarClientException, PulsarAdminException, InterruptedException {\n+        long timestamp = System.currentTimeMillis();\n+        final String topicName = \"consumer-stats-\" + timestamp;\n+        final String subscribeName = topicName + \"-test-stats-sub\";\n+        final String topic = \"persistent://prop-xyz/ns1/\" + topicName;\n+        final String producerName = \"producer-\" + topicName;\n+\n+        @Cleanup\n+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsar.getWebServiceAddress()).build();\n+        Producer<byte[]> producer = client.newProducer().topic(topic)\n+            .enableBatching(false)\n+            .producerName(producerName)\n+            .create();\n+\n+        // a. Send a message to the topic.\n+        producer.send(\"message-1\".getBytes(StandardCharsets.UTF_8));\n+\n+        // b. Create a consumer, because there was a message in the topic, the consumer will receive the message pushed\n+        // by the broker, the lastConsumedTimestamp will as the consume subscribe time.\n+        Consumer<byte[]> consumer = client.newConsumer().topic(topic)\n+            .subscriptionName(subscribeName)\n+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n+            .subscribe();\n+\n+        // Get the consumer stats.\n+        TopicStats topicStats = admin.topics().getStats(topic);\n+        SubscriptionStats subscriptionStats = topicStats.subscriptions.get(subscribeName);\n+        long startConsumedFlowTimestamp = subscriptionStats.lastConsumedFlowTimestamp;\n+        long startAckedTimestampInSubStats = subscriptionStats.lastAckedTimestamp;\n+        ConsumerStats consumerStats = subscriptionStats.consumers.get(0);\n+        long startConsumedTimestampInConsumerStats = consumerStats.lastConsumedTimestamp;\n+        long startAckedTimestampInConsumerStats = consumerStats.lastAckedTimestamp;\n+\n+        // Because the message was pushed by the broker, the consumedTimestamp should not as 0.\n+        assertNotEquals(0, startConsumedTimestampInConsumerStats);\n+        // There is no consumer ack the message, so the lastAckedTimestamp still as 0.\n+        assertEquals(0, startAckedTimestampInConsumerStats);\n+        assertNotEquals(0, startConsumedFlowTimestamp);\n+        assertEquals(0, startAckedTimestampInSubStats);\n+\n+        // c. The Consumer receives the message and acks the message.\n+        Message<byte[]> message = consumer.receive();\n+        consumer.acknowledge(message);\n+        // Waiting for the ack command send to the broker.\n+        TimeUnit.SECONDS.sleep(5);", "originalCommit": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0OTQ2NA==", "url": "https://github.com/apache/pulsar/pull/6051#discussion_r368249464", "bodyText": "same comments as above", "author": "sijie", "createdAt": "2020-01-18T21:27:34Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "diffHunk": "@@ -948,4 +952,98 @@ public void testCreateNamespaceWithNoClusters() throws PulsarAdminException {\n         assertEquals(admin.namespaces().getNamespaceReplicationClusters(namespace),\n                 Collections.singletonList(localCluster));\n     }\n+\n+    @Test(timeOut = 30000)\n+    public void testConsumerStatsLastTimestamp() throws PulsarClientException, PulsarAdminException, InterruptedException {\n+        long timestamp = System.currentTimeMillis();\n+        final String topicName = \"consumer-stats-\" + timestamp;\n+        final String subscribeName = topicName + \"-test-stats-sub\";\n+        final String topic = \"persistent://prop-xyz/ns1/\" + topicName;\n+        final String producerName = \"producer-\" + topicName;\n+\n+        @Cleanup\n+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsar.getWebServiceAddress()).build();\n+        Producer<byte[]> producer = client.newProducer().topic(topic)\n+            .enableBatching(false)\n+            .producerName(producerName)\n+            .create();\n+\n+        // a. Send a message to the topic.\n+        producer.send(\"message-1\".getBytes(StandardCharsets.UTF_8));\n+\n+        // b. Create a consumer, because there was a message in the topic, the consumer will receive the message pushed\n+        // by the broker, the lastConsumedTimestamp will as the consume subscribe time.\n+        Consumer<byte[]> consumer = client.newConsumer().topic(topic)\n+            .subscriptionName(subscribeName)\n+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n+            .subscribe();\n+\n+        // Get the consumer stats.\n+        TopicStats topicStats = admin.topics().getStats(topic);\n+        SubscriptionStats subscriptionStats = topicStats.subscriptions.get(subscribeName);\n+        long startConsumedFlowTimestamp = subscriptionStats.lastConsumedFlowTimestamp;\n+        long startAckedTimestampInSubStats = subscriptionStats.lastAckedTimestamp;\n+        ConsumerStats consumerStats = subscriptionStats.consumers.get(0);\n+        long startConsumedTimestampInConsumerStats = consumerStats.lastConsumedTimestamp;\n+        long startAckedTimestampInConsumerStats = consumerStats.lastAckedTimestamp;\n+\n+        // Because the message was pushed by the broker, the consumedTimestamp should not as 0.\n+        assertNotEquals(0, startConsumedTimestampInConsumerStats);\n+        // There is no consumer ack the message, so the lastAckedTimestamp still as 0.\n+        assertEquals(0, startAckedTimestampInConsumerStats);\n+        assertNotEquals(0, startConsumedFlowTimestamp);\n+        assertEquals(0, startAckedTimestampInSubStats);\n+\n+        // c. The Consumer receives the message and acks the message.\n+        Message<byte[]> message = consumer.receive();\n+        consumer.acknowledge(message);\n+        // Waiting for the ack command send to the broker.\n+        TimeUnit.SECONDS.sleep(5);\n+\n+        // Get the consumer stats.\n+        topicStats = admin.topics().getStats(topic);\n+        subscriptionStats = topicStats.subscriptions.get(subscribeName);\n+        long consumedFlowTimestamp = subscriptionStats.lastConsumedFlowTimestamp;\n+        long ackedTimestampInSubStats = subscriptionStats.lastAckedTimestamp;\n+        consumerStats = subscriptionStats.consumers.get(0);\n+        long consumedTimestamp = consumerStats.lastConsumedTimestamp;\n+        long ackedTimestamp = consumerStats.lastAckedTimestamp;\n+\n+        // The lastConsumedTimestamp should same as the last time because the broker does not push any messages and the\n+        // consumer does not pull any messages.\n+        assertEquals(startConsumedTimestampInConsumerStats, consumedTimestamp);\n+        assertTrue(startAckedTimestampInConsumerStats < ackedTimestamp);\n+        assertNotEquals(0, consumedFlowTimestamp);\n+        assertTrue(startAckedTimestampInSubStats < ackedTimestampInSubStats);\n+\n+        // d. Send another messages. The lastConsumedTimestamp should be updated.\n+        producer.send(\"message-2\".getBytes(StandardCharsets.UTF_8));\n+\n+        // e. Receive the message and ack it.\n+        message = consumer.receive();", "originalCommit": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1711c4c1960db24b022a03dccc31ce25b3f09e6d", "url": "https://github.com/apache/pulsar/commit/1711c4c1960db24b022a03dccc31ce25b3f09e6d", "message": "* Address comments", "committedDate": "2020-01-21T08:15:57Z", "type": "commit"}, {"oid": "1711c4c1960db24b022a03dccc31ce25b3f09e6d", "url": "https://github.com/apache/pulsar/commit/1711c4c1960db24b022a03dccc31ce25b3f09e6d", "message": "* Address comments", "committedDate": "2020-01-21T08:15:57Z", "type": "forcePushed"}]}