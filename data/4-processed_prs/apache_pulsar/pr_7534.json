{"pr_number": 7534, "pr_title": "[docs] Improve configuration details of functions worker", "pr_createdAt": "2020-07-14T21:10:09Z", "pr_url": "https://github.com/apache/pulsar/pull/7534", "timeline": [{"oid": "1df035f1ef59529b3e3b29f927c225d79318adc7", "url": "https://github.com/apache/pulsar/commit/1df035f1ef59529b3e3b29f927c225d79318adc7", "message": "[docs] Improve configuration details of functions worker\n\nThis document expands the details for how to configure the functions\nworker based on a variety of scenarios.", "committedDate": "2020-07-14T21:05:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1Nzg1MQ==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454757851", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Kubernetes runtime works by having the functions-worker generate and apply kubernetes manifests. In the event that the functions worker is running on Kubernetes already, it can use the `serviceAccount` that is associated with the pod the functions worker is running in. Otherwise, it can be configured to communicate with a Kubernetes cluster.\n          \n          \n            \n            The Kubernetes runtime works by having the functions worker generate and apply Kubernetes manifests. In the event that the functions worker is running on Kubernetes already, it can use the `serviceAccount` that is associated with the pod the functions worker is running in. Otherwise, it can be configured to communicate with a Kubernetes cluster.", "author": "Anonymitaet", "createdAt": "2020-07-15T02:47:28Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -46,6 +46,17 @@ processContainerFactory:\n \n ## Configure Kubernetes runtime\n \n+\n+### How it works\n+\n+The Kubernetes runtime works by having the functions-worker generate and apply kubernetes manifests. In the event that the functions worker is running on Kubernetes already, it can use the `serviceAccount` that is associated with the pod the functions worker is running in. Otherwise, it can be configured to communicate with a Kubernetes cluster.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1ODUzMA==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454758530", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The manifests which the functions worker generates include a `StatefulSet`, a `Service (which is used to communicate with the pods), and a `Secret` for auth credentials (when applicable). The StatefulSet manifest (by default) has a single pod, with the number of replicas determined by the \"parallelism\" of the function. On pod boot, the pod will download the function payload (via the functions worker REST API). The pod's container image is configurable, but must have the functions runtime.\n          \n          \n            \n            The manifests which the functions worker generates include a `StatefulSet`, a `Service` (which is used to communicate with the pods), and a `Secret` for auth credentials (when applicable). The `StatefulSet` manifest (by default) has a single pod, with the number of replicas determined by the \"parallelism\" of the function. On pod boot, the pod downloads the function payload (via the functions worker REST API). The pod's container image is configurable, but must have the functions runtime.\n          \n      \n    \n    \n  \n\nUse present tense if you are covering facts that were, are, and forever shall be true.\nAlways use the present tense in technical writing by default. Only use past or future tenses when you\u2019re actually writing about something that happened in the past or will happen in the future.", "author": "Anonymitaet", "createdAt": "2020-07-15T02:50:14Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -46,6 +46,17 @@ processContainerFactory:\n \n ## Configure Kubernetes runtime\n \n+\n+### How it works\n+\n+The Kubernetes runtime works by having the functions-worker generate and apply kubernetes manifests. In the event that the functions worker is running on Kubernetes already, it can use the `serviceAccount` that is associated with the pod the functions worker is running in. Otherwise, it can be configured to communicate with a Kubernetes cluster.\n+\n+The manifests which the functions worker generates include a `StatefulSet`, a `Service (which is used to communicate with the pods), and a `Secret` for auth credentials (when applicable). The StatefulSet manifest (by default) has a single pod, with the number of replicas determined by the \"parallelism\" of the function. On pod boot, the pod will download the function payload (via the functions worker REST API). The pod's container image is configurable, but must have the functions runtime.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1OTE0Mw==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454759143", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Kubernetes runtime also has supports for secrets, with the end user being able to create a kubernetes secret and have it be exposed as an environment variable in the pod (described below). Additionally, the Kubernetes runtime fairly extensible, with the user being able to implement classes that customize the way kubernetes manifests get generated, how auth data is passed to pods, and how secrets can be integrated.\n          \n          \n            \n            The Kubernetes runtime also supports secrets, with the end user being able to create a Kubernetes secret and have it be exposed as an environment variable in the pod (described below). Additionally, the Kubernetes runtime fairly extensible, with the user being able to implement classes that customize the way Kubernetes manifests get generated, how auth data is passed to pods, and how secrets can be integrated.", "author": "Anonymitaet", "createdAt": "2020-07-15T02:52:22Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -46,6 +46,17 @@ processContainerFactory:\n \n ## Configure Kubernetes runtime\n \n+\n+### How it works\n+\n+The Kubernetes runtime works by having the functions-worker generate and apply kubernetes manifests. In the event that the functions worker is running on Kubernetes already, it can use the `serviceAccount` that is associated with the pod the functions worker is running in. Otherwise, it can be configured to communicate with a Kubernetes cluster.\n+\n+The manifests which the functions worker generates include a `StatefulSet`, a `Service (which is used to communicate with the pods), and a `Secret` for auth credentials (when applicable). The StatefulSet manifest (by default) has a single pod, with the number of replicas determined by the \"parallelism\" of the function. On pod boot, the pod will download the function payload (via the functions worker REST API). The pod's container image is configurable, but must have the functions runtime.\n+\n+The Kubernetes runtime also has supports for secrets, with the end user being able to create a kubernetes secret and have it be exposed as an environment variable in the pod (described below). Additionally, the Kubernetes runtime fairly extensible, with the user being able to implement classes that customize the way kubernetes manifests get generated, how auth data is passed to pods, and how secrets can be integrated.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc1OTUxNA==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454759514", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As stated earlier, If you already run your Functions Worker embedded in a Broker on Kubernetes, you can keep many of these settings as their default.\n          \n          \n            \n            As stated earlier, if you already run your functions worker embedded in a broker on Kubernetes, you can keep many of these settings as default.", "author": "Anonymitaet", "createdAt": "2020-07-15T02:53:28Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -78,9 +89,23 @@ kubernetesContainerFactory:\n   percentMemoryPadding: 10\n ```\n \n-If you have already run a Pulsar cluster on Kubernetes, you can keep the settings unchanged at most of time.\n+As stated earlier, If you already run your Functions Worker embedded in a Broker on Kubernetes, you can keep many of these settings as their default.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2MDMxMg==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454760312", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you run your Functions Worker standalone (i.e. not embedded) on Kubernetes, you will need to configure `pulsarSerivceUrl` to be the URL of the\n          \n          \n            \n            If you run your Functions Worker standalone (that is, not embedded) on Kubernetes, you need to configure `pulsarSerivceUrl` to be the URL of the\n          \n      \n    \n    \n  \n\nIBM Writing Style Guide: Do not use Latin abbreviations, such as e.g., etc., and i.e.", "author": "Anonymitaet", "createdAt": "2020-07-15T02:56:22Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -78,9 +89,23 @@ kubernetesContainerFactory:\n   percentMemoryPadding: 10\n ```\n \n-If you have already run a Pulsar cluster on Kubernetes, you can keep the settings unchanged at most of time.\n+As stated earlier, If you already run your Functions Worker embedded in a Broker on Kubernetes, you can keep many of these settings as their default.\n+\n+### Standalone Functions Worker on K8S\n+\n+If you run your Functions Worker standalone (i.e. not embedded) on Kubernetes, you will need to configure `pulsarSerivceUrl` to be the URL of the", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2MDcwNQ==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454760705", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As an example, suppose both our Pulsar Brokers and Function Workers are run in the `pulsar` K8S namespace. Additionally, assuming the Brokers have a service called `brokers` and the Functions Worker has a service called `func-worker`, then the settings would be:\n          \n          \n            \n            As an example, suppose both our Pulsar brokers and Function Workers run in the `pulsar` K8S namespace. Additionally, assuming the brokers have a service called `brokers` and the Functions Worker has a service called `func-worker`, then the settings would be:", "author": "Anonymitaet", "createdAt": "2020-07-15T02:57:57Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -78,9 +89,23 @@ kubernetesContainerFactory:\n   percentMemoryPadding: 10\n ```\n \n-If you have already run a Pulsar cluster on Kubernetes, you can keep the settings unchanged at most of time.\n+As stated earlier, If you already run your Functions Worker embedded in a Broker on Kubernetes, you can keep many of these settings as their default.\n+\n+### Standalone Functions Worker on K8S\n+\n+If you run your Functions Worker standalone (i.e. not embedded) on Kubernetes, you will need to configure `pulsarSerivceUrl` to be the URL of the\n+broker and `pulsarAdminUrl` as the URL to the Functions Worker.\n+\n+As an example, suppose both our Pulsar Brokers and Function Workers are run in the `pulsar` K8S namespace. Additionally, assuming the Brokers have a service called `brokers` and the Functions Worker has a service called `func-worker`, then the settings would be:", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2MTU1OA==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454761558", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then, you can create a secret in the namespace where your functions will be deployed. As an example, suppose we are deploying functions to the `pulsar-func` Kubernetes namespace, and we have a secret named `database-creds` with a field name `password`, which we want to mount in the pod as an environment variable called `DATABASE_PASSWORD`.\n          \n          \n            \n            Then, you can create a secret in the namespace where your functions are deployed. As an example, suppose we are deploying functions to the `pulsar-func` Kubernetes namespace, and we have a secret named `database-creds` with a field name `password`, which we want to mount in the pod as an environment variable called `DATABASE_PASSWORD`.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:01:09Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -138,20 +149,75 @@ roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n   name: functions-worker\n-subjects:\n+subjectsKubernetesSec:\n - kind: ServiceAccount\n   name: functions-worker\n ```\n \n+If the service-account is not properly configured, you may see an error message similar to this:\n+```bash\n+22:04:27.696 [Timer-0] ERROR org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory - Error while trying to fetch configmap example-pulsar-4qvmb5gur3c6fc9dih0x1xn8b-function-worker-config at namespace pulsar\n+io.kubernetes.client.ApiException: Forbidden\n+\tat io.kubernetes.client.ApiClient.handleResponse(ApiClient.java:882) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.ApiClient.execute(ApiClient.java:798) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMapWithHttpInfo(CoreV1Api.java:23673) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMap(CoreV1Api.java:23655) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory.fetchConfigMap(KubernetesRuntimeFactory.java:284) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory$1.run(KubernetesRuntimeFactory.java:275) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat java.util.TimerThread.mainLoop(Timer.java:555) [?:1.8.0_212]\n+\tat java.util.TimerThread.run(Timer.java:505) [?:1.8.0_212]\n+```\n+\n+### Kubernetes Secrets integration\n+\n+In order to safely distribute secrets, Pulasr Functions can reference Kubernetes secrets. To enable this, set the `secretsProviderConfiguratorClassName` to `org.apache.pulsar.functions.secretsproviderconfigurator.KubernetesSecretsProviderConfigurator`.\n+\n+Then, you can create a secret in the namespace where your functions will be deployed. As an example, suppose we are deploying functions to the `pulsar-func` Kubernetes namespace, and we have a secret named `database-creds` with a field name `password`, which we want to mount in the pod as an environment variable called `DATABASE_PASSWORD`.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2MTY3OA==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454761678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When your Pulsar cluster uses authentication, the pod running your function needs a mechanism to authenticate with the Broker.\n          \n          \n            \n            When your Pulsar cluster uses authentication, the pod running your function needs a mechanism to authenticate with the broker.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:01:38Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -138,20 +149,75 @@ roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n   name: functions-worker\n-subjects:\n+subjectsKubernetesSec:\n - kind: ServiceAccount\n   name: functions-worker\n ```\n \n+If the service-account is not properly configured, you may see an error message similar to this:\n+```bash\n+22:04:27.696 [Timer-0] ERROR org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory - Error while trying to fetch configmap example-pulsar-4qvmb5gur3c6fc9dih0x1xn8b-function-worker-config at namespace pulsar\n+io.kubernetes.client.ApiException: Forbidden\n+\tat io.kubernetes.client.ApiClient.handleResponse(ApiClient.java:882) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.ApiClient.execute(ApiClient.java:798) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMapWithHttpInfo(CoreV1Api.java:23673) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMap(CoreV1Api.java:23655) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory.fetchConfigMap(KubernetesRuntimeFactory.java:284) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory$1.run(KubernetesRuntimeFactory.java:275) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat java.util.TimerThread.mainLoop(Timer.java:555) [?:1.8.0_212]\n+\tat java.util.TimerThread.run(Timer.java:505) [?:1.8.0_212]\n+```\n+\n+### Kubernetes Secrets integration\n+\n+In order to safely distribute secrets, Pulasr Functions can reference Kubernetes secrets. To enable this, set the `secretsProviderConfiguratorClassName` to `org.apache.pulsar.functions.secretsproviderconfigurator.KubernetesSecretsProviderConfigurator`.\n+\n+Then, you can create a secret in the namespace where your functions will be deployed. As an example, suppose we are deploying functions to the `pulsar-func` Kubernetes namespace, and we have a secret named `database-creds` with a field name `password`, which we want to mount in the pod as an environment variable called `DATABASE_PASSWORD`.\n+\n+The following functions configuration would then allow us to reference that secret and have the value be mounted as an environment variable in the pod.\n+\n+```Yaml\n+tenant: \"mytenant\"\n+namespace: \"mynamespace\"\n+name: \"myfunction\"\n+topicName: \"persistent://mytenant/mynamespace/myfuncinput\"\n+className: \"com.company.pulsar.myfunction\"\n+\n+secrets:\n+  # the secret will be mounted from the `password` field in the `database-creds` secret as an env var called `DATABASE_PASSWORD`\n+  DATABASE_PASSWORD:\n+    path: \"database-creds\"\n+    key: \"password\"\n+\n+```\n+\n+### Kubernetes Functions authentication\n+\n+\n+When your Pulsar cluster uses authentication, the pod running your function needs a mechanism to authenticate with the Broker.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2MjAzNg==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454762036", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For custom auth or TLS, the user will need to implement this interface (or use an alternative mechanism to provide auth)\n          \n          \n            \n            For custom authentication or TLS, you need to implement this interface (or use an alternative mechanism to provide authentication)", "author": "Anonymitaet", "createdAt": "2020-07-15T03:02:57Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -138,20 +149,75 @@ roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n   name: functions-worker\n-subjects:\n+subjectsKubernetesSec:\n - kind: ServiceAccount\n   name: functions-worker\n ```\n \n+If the service-account is not properly configured, you may see an error message similar to this:\n+```bash\n+22:04:27.696 [Timer-0] ERROR org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory - Error while trying to fetch configmap example-pulsar-4qvmb5gur3c6fc9dih0x1xn8b-function-worker-config at namespace pulsar\n+io.kubernetes.client.ApiException: Forbidden\n+\tat io.kubernetes.client.ApiClient.handleResponse(ApiClient.java:882) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.ApiClient.execute(ApiClient.java:798) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMapWithHttpInfo(CoreV1Api.java:23673) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMap(CoreV1Api.java:23655) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory.fetchConfigMap(KubernetesRuntimeFactory.java:284) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory$1.run(KubernetesRuntimeFactory.java:275) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat java.util.TimerThread.mainLoop(Timer.java:555) [?:1.8.0_212]\n+\tat java.util.TimerThread.run(Timer.java:505) [?:1.8.0_212]\n+```\n+\n+### Kubernetes Secrets integration\n+\n+In order to safely distribute secrets, Pulasr Functions can reference Kubernetes secrets. To enable this, set the `secretsProviderConfiguratorClassName` to `org.apache.pulsar.functions.secretsproviderconfigurator.KubernetesSecretsProviderConfigurator`.\n+\n+Then, you can create a secret in the namespace where your functions will be deployed. As an example, suppose we are deploying functions to the `pulsar-func` Kubernetes namespace, and we have a secret named `database-creds` with a field name `password`, which we want to mount in the pod as an environment variable called `DATABASE_PASSWORD`.\n+\n+The following functions configuration would then allow us to reference that secret and have the value be mounted as an environment variable in the pod.\n+\n+```Yaml\n+tenant: \"mytenant\"\n+namespace: \"mynamespace\"\n+name: \"myfunction\"\n+topicName: \"persistent://mytenant/mynamespace/myfuncinput\"\n+className: \"com.company.pulsar.myfunction\"\n+\n+secrets:\n+  # the secret will be mounted from the `password` field in the `database-creds` secret as an env var called `DATABASE_PASSWORD`\n+  DATABASE_PASSWORD:\n+    path: \"database-creds\"\n+    key: \"password\"\n+\n+```\n+\n+### Kubernetes Functions authentication\n+\n+\n+When your Pulsar cluster uses authentication, the pod running your function needs a mechanism to authenticate with the Broker.\n+\n+An interface, `org.apache.pulsar.functions.auth.KubernetesFunctionAuthProvider`, can be extended to provide support for any authentication mechanism. The `functionAuthProviderClassName` in `function-worker.yml` is used to specify your path to this implementation.\n+\n+Pulsar includes an implementation of this interface that is suitable for token auth, which should be configured like the following in the configuration:\n+```Yaml\n+functionAuthProviderClassName: org.apache.pulsar.functions.auth.KubernetesSecretsTokenAuthProvider\n+```\n+\n+For custom auth or TLS, the user will need to implement this interface (or use an alternative mechanism to provide auth)", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2MzEzMw==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454763133", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Kubernetes integration also includes the ability for the user to implement a class which will customize how manifests will be generated. This is configured by setting the `runtimeCustomizerClassName` in the `functions-worker.yml` to the fully qualified class name. The interface the user must implement is the `org.apache.pulsar.functions.runtime.kubernetes.KubernetesManifestCustomizer` interface.\n          \n          \n            \n            The Kubernetes integration also includes the ability for the user to implement a class which customizes how manifests is generated. This is configured by setting the `runtimeCustomizerClassName` in the `functions-worker.yml` to the fully qualified class name. The interface the you must implement is the `org.apache.pulsar.functions.runtime.kubernetes.KubernetesManifestCustomizer` interface.\n          \n      \n    \n    \n  \n\nIBM Writing Style Guide: Use the second-person pronoun you as much as possible. The subject of an imperative sentence is understood to be you.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:07:04Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -138,20 +149,75 @@ roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n   name: functions-worker\n-subjects:\n+subjectsKubernetesSec:\n - kind: ServiceAccount\n   name: functions-worker\n ```\n \n+If the service-account is not properly configured, you may see an error message similar to this:\n+```bash\n+22:04:27.696 [Timer-0] ERROR org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory - Error while trying to fetch configmap example-pulsar-4qvmb5gur3c6fc9dih0x1xn8b-function-worker-config at namespace pulsar\n+io.kubernetes.client.ApiException: Forbidden\n+\tat io.kubernetes.client.ApiClient.handleResponse(ApiClient.java:882) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.ApiClient.execute(ApiClient.java:798) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMapWithHttpInfo(CoreV1Api.java:23673) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMap(CoreV1Api.java:23655) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory.fetchConfigMap(KubernetesRuntimeFactory.java:284) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory$1.run(KubernetesRuntimeFactory.java:275) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat java.util.TimerThread.mainLoop(Timer.java:555) [?:1.8.0_212]\n+\tat java.util.TimerThread.run(Timer.java:505) [?:1.8.0_212]\n+```\n+\n+### Kubernetes Secrets integration\n+\n+In order to safely distribute secrets, Pulasr Functions can reference Kubernetes secrets. To enable this, set the `secretsProviderConfiguratorClassName` to `org.apache.pulsar.functions.secretsproviderconfigurator.KubernetesSecretsProviderConfigurator`.\n+\n+Then, you can create a secret in the namespace where your functions will be deployed. As an example, suppose we are deploying functions to the `pulsar-func` Kubernetes namespace, and we have a secret named `database-creds` with a field name `password`, which we want to mount in the pod as an environment variable called `DATABASE_PASSWORD`.\n+\n+The following functions configuration would then allow us to reference that secret and have the value be mounted as an environment variable in the pod.\n+\n+```Yaml\n+tenant: \"mytenant\"\n+namespace: \"mynamespace\"\n+name: \"myfunction\"\n+topicName: \"persistent://mytenant/mynamespace/myfuncinput\"\n+className: \"com.company.pulsar.myfunction\"\n+\n+secrets:\n+  # the secret will be mounted from the `password` field in the `database-creds` secret as an env var called `DATABASE_PASSWORD`\n+  DATABASE_PASSWORD:\n+    path: \"database-creds\"\n+    key: \"password\"\n+\n+```\n+\n+### Kubernetes Functions authentication\n+\n+\n+When your Pulsar cluster uses authentication, the pod running your function needs a mechanism to authenticate with the Broker.\n+\n+An interface, `org.apache.pulsar.functions.auth.KubernetesFunctionAuthProvider`, can be extended to provide support for any authentication mechanism. The `functionAuthProviderClassName` in `function-worker.yml` is used to specify your path to this implementation.\n+\n+Pulsar includes an implementation of this interface that is suitable for token auth, which should be configured like the following in the configuration:\n+```Yaml\n+functionAuthProviderClassName: org.apache.pulsar.functions.auth.KubernetesSecretsTokenAuthProvider\n+```\n+\n+For custom auth or TLS, the user will need to implement this interface (or use an alternative mechanism to provide auth)\n+\n+For token authentication, the way this works is that the functions worker captures the token that was used to deploy (or update) the function. This token is then saved as a secret and mounted into the pod.\n+\n+One thing to keep in mind is that if you use tokens that expire when deploying functions, these tokens will expire.\n+\n+\n ### Kubernetes CustomRuntimeOptions\n \n-The functions (and sinks/sources) API provides a flag, `customRuntimeOptions` which can be used to pass options to the runtime to customize how the runtime operates.\n+The Kubernetes integration also includes the ability for the user to implement a class which will customize how manifests will be generated. This is configured by setting the `runtimeCustomizerClassName` in the `functions-worker.yml` to the fully qualified class name. The interface the user must implement is the `org.apache.pulsar.functions.runtime.kubernetes.KubernetesManifestCustomizer` interface.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NDM5NA==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454764394", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The functions (and sinks/sources) API provides a flag, `customRuntimeOptions` which will be passed to this interface.\n          \n          \n            \n            The functions (and sinks/sources) API provides a flag, `customRuntimeOptions`, which is passed to this interface.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:12:21Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -138,20 +149,75 @@ roleRef:\n   apiGroup: rbac.authorization.k8s.io\n   kind: ClusterRole\n   name: functions-worker\n-subjects:\n+subjectsKubernetesSec:\n - kind: ServiceAccount\n   name: functions-worker\n ```\n \n+If the service-account is not properly configured, you may see an error message similar to this:\n+```bash\n+22:04:27.696 [Timer-0] ERROR org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory - Error while trying to fetch configmap example-pulsar-4qvmb5gur3c6fc9dih0x1xn8b-function-worker-config at namespace pulsar\n+io.kubernetes.client.ApiException: Forbidden\n+\tat io.kubernetes.client.ApiClient.handleResponse(ApiClient.java:882) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.ApiClient.execute(ApiClient.java:798) ~[io.kubernetes-client-java-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMapWithHttpInfo(CoreV1Api.java:23673) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat io.kubernetes.client.apis.CoreV1Api.readNamespacedConfigMap(CoreV1Api.java:23655) ~[io.kubernetes-client-java-api-2.0.0.jar:?]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory.fetchConfigMap(KubernetesRuntimeFactory.java:284) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat org.apache.pulsar.functions.runtime.KubernetesRuntimeFactory$1.run(KubernetesRuntimeFactory.java:275) [org.apache.pulsar-pulsar-functions-runtime-2.4.0-42c3bf949.jar:2.4.0-42c3bf949]\n+\tat java.util.TimerThread.mainLoop(Timer.java:555) [?:1.8.0_212]\n+\tat java.util.TimerThread.run(Timer.java:505) [?:1.8.0_212]\n+```\n+\n+### Kubernetes Secrets integration\n+\n+In order to safely distribute secrets, Pulasr Functions can reference Kubernetes secrets. To enable this, set the `secretsProviderConfiguratorClassName` to `org.apache.pulsar.functions.secretsproviderconfigurator.KubernetesSecretsProviderConfigurator`.\n+\n+Then, you can create a secret in the namespace where your functions will be deployed. As an example, suppose we are deploying functions to the `pulsar-func` Kubernetes namespace, and we have a secret named `database-creds` with a field name `password`, which we want to mount in the pod as an environment variable called `DATABASE_PASSWORD`.\n+\n+The following functions configuration would then allow us to reference that secret and have the value be mounted as an environment variable in the pod.\n+\n+```Yaml\n+tenant: \"mytenant\"\n+namespace: \"mynamespace\"\n+name: \"myfunction\"\n+topicName: \"persistent://mytenant/mynamespace/myfuncinput\"\n+className: \"com.company.pulsar.myfunction\"\n+\n+secrets:\n+  # the secret will be mounted from the `password` field in the `database-creds` secret as an env var called `DATABASE_PASSWORD`\n+  DATABASE_PASSWORD:\n+    path: \"database-creds\"\n+    key: \"password\"\n+\n+```\n+\n+### Kubernetes Functions authentication\n+\n+\n+When your Pulsar cluster uses authentication, the pod running your function needs a mechanism to authenticate with the Broker.\n+\n+An interface, `org.apache.pulsar.functions.auth.KubernetesFunctionAuthProvider`, can be extended to provide support for any authentication mechanism. The `functionAuthProviderClassName` in `function-worker.yml` is used to specify your path to this implementation.\n+\n+Pulsar includes an implementation of this interface that is suitable for token auth, which should be configured like the following in the configuration:\n+```Yaml\n+functionAuthProviderClassName: org.apache.pulsar.functions.auth.KubernetesSecretsTokenAuthProvider\n+```\n+\n+For custom auth or TLS, the user will need to implement this interface (or use an alternative mechanism to provide auth)\n+\n+For token authentication, the way this works is that the functions worker captures the token that was used to deploy (or update) the function. This token is then saved as a secret and mounted into the pod.\n+\n+One thing to keep in mind is that if you use tokens that expire when deploying functions, these tokens will expire.\n+\n+\n ### Kubernetes CustomRuntimeOptions\n \n-The functions (and sinks/sources) API provides a flag, `customRuntimeOptions` which can be used to pass options to the runtime to customize how the runtime operates.\n+The Kubernetes integration also includes the ability for the user to implement a class which will customize how manifests will be generated. This is configured by setting the `runtimeCustomizerClassName` in the `functions-worker.yml` to the fully qualified class name. The interface the user must implement is the `org.apache.pulsar.functions.runtime.kubernetes.KubernetesManifestCustomizer` interface.\n+\n+The functions (and sinks/sources) API provides a flag, `customRuntimeOptions` which will be passed to this interface.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NTY4OA==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454765688", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions\n          \n          \n            \n            If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster. Otherwise, the function\n          \n      \n    \n    \n  \n\nIBM Writing Style Guide:\nDo not punctuate sentences with exclamation points because their tone can be interpreted negatively,\nfor example, as aggressive, condescending, or overly informal.\nConvey urgency or emphasis with the appropriate words, not with exclamation points. To call\nattention to important hints, tips, guidance, restrictions, or advice that might be overlooked, consider\nusing a note that has a meaningful label.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:17:32Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -183,3 +249,68 @@ for the `runtimeCustomerClassName` property. This implementation takes the follo\n   }\n }\n ```\n+\n+## Other configuration considerations\n+\n+\n+### In a cluster with geo-replication\n+\n+If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NTczMA==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454765730", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            will share a namespace and potentially schedule across clusters.\n          \n          \n            \n            shares a namespace and potentially schedule across clusters.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:17:43Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -183,3 +249,68 @@ for the `runtimeCustomerClassName` property. This implementation takes the follo\n   }\n }\n ```\n+\n+## Other configuration considerations\n+\n+\n+### In a cluster with geo-replication\n+\n+If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions\n+will share a namespace and potentially schedule across clusters.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NjAxNg==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454766016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This ensures the two different Function Workers will use distinct sets of topics for their internal co-ordination.\n          \n          \n            \n            This ensures the two different Function Workers use distinct sets of topics for their internal coordination.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:18:47Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -183,3 +249,68 @@ for the `runtimeCustomerClassName` property. This implementation takes the follo\n   }\n }\n ```\n+\n+## Other configuration considerations\n+\n+\n+### In a cluster with geo-replication\n+\n+If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions\n+will share a namespace and potentially schedule across clusters.\n+\n+As an example, suppose we have clusters east-1 and west-1, we would configure the Functions Worker in east-1 like:\n+```Yaml\n+pulsarFunctionsCluster: east-1\n+pulsarFunctionsNamespace: public/functions-east-1\n+```\n+\n+and the cluster in west-1 like:\n+```Yaml\n+pulsarFunctionsCluster: west-1\n+pulsarFunctionsNamespace: public/functions-west-1\n+```\n+\n+This ensures the two different Function Workers will use distinct sets of topics for their internal co-ordination.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NjA3Mw==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454766073", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Configuring Standalone Functions Worker\n          \n          \n            \n            ### Configure standalone Functions Worker", "author": "Anonymitaet", "createdAt": "2020-07-15T03:18:59Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -183,3 +249,68 @@ for the `runtimeCustomerClassName` property. This implementation takes the follo\n   }\n }\n ```\n+\n+## Other configuration considerations\n+\n+\n+### In a cluster with geo-replication\n+\n+If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions\n+will share a namespace and potentially schedule across clusters.\n+\n+As an example, suppose we have clusters east-1 and west-1, we would configure the Functions Worker in east-1 like:\n+```Yaml\n+pulsarFunctionsCluster: east-1\n+pulsarFunctionsNamespace: public/functions-east-1\n+```\n+\n+and the cluster in west-1 like:\n+```Yaml\n+pulsarFunctionsCluster: west-1\n+pulsarFunctionsNamespace: public/functions-west-1\n+```\n+\n+This ensures the two different Function Workers will use distinct sets of topics for their internal co-ordination.\n+\n+### Configuring Standalone Functions Worker", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NjIxNA==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454766214", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            to communicate with the Broker. This requires many of the same properties to be set that the Broker requires, especially when using TLS.\n          \n          \n            \n            to communicate with the broker. This requires many of the same properties to be set that the broker requires, especially when using TLS.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:19:22Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -183,3 +249,68 @@ for the `runtimeCustomerClassName` property. This implementation takes the follo\n   }\n }\n ```\n+\n+## Other configuration considerations\n+\n+\n+### In a cluster with geo-replication\n+\n+If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions\n+will share a namespace and potentially schedule across clusters.\n+\n+As an example, suppose we have clusters east-1 and west-1, we would configure the Functions Worker in east-1 like:\n+```Yaml\n+pulsarFunctionsCluster: east-1\n+pulsarFunctionsNamespace: public/functions-east-1\n+```\n+\n+and the cluster in west-1 like:\n+```Yaml\n+pulsarFunctionsCluster: west-1\n+pulsarFunctionsNamespace: public/functions-west-1\n+```\n+\n+This ensures the two different Function Workers will use distinct sets of topics for their internal co-ordination.\n+\n+### Configuring Standalone Functions Worker\n+\n+When configuring a standalone Functions Worker, you need to specify a few properties in order for the Functions Worker to be able\n+to communicate with the Broker. This requires many of the same properties to be set that the Broker requires, especially when using TLS.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NjI3Ng==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454766276", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #### With Authentication\n          \n          \n            \n            #### With authentication", "author": "Anonymitaet", "createdAt": "2020-07-15T03:19:32Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -183,3 +249,68 @@ for the `runtimeCustomerClassName` property. This implementation takes the follo\n   }\n }\n ```\n+\n+## Other configuration considerations\n+\n+\n+### In a cluster with geo-replication\n+\n+If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions\n+will share a namespace and potentially schedule across clusters.\n+\n+As an example, suppose we have clusters east-1 and west-1, we would configure the Functions Worker in east-1 like:\n+```Yaml\n+pulsarFunctionsCluster: east-1\n+pulsarFunctionsNamespace: public/functions-east-1\n+```\n+\n+and the cluster in west-1 like:\n+```Yaml\n+pulsarFunctionsCluster: west-1\n+pulsarFunctionsNamespace: public/functions-west-1\n+```\n+\n+This ensures the two different Function Workers will use distinct sets of topics for their internal co-ordination.\n+\n+### Configuring Standalone Functions Worker\n+\n+When configuring a standalone Functions Worker, you need to specify a few properties in order for the Functions Worker to be able\n+to communicate with the Broker. This requires many of the same properties to be set that the Broker requires, especially when using TLS.\n+\n+The following properties are the baseline of what is required:\n+\n+```Yaml\n+workerPort: 8080\n+workerPortTls: 8443 # when using TLS\n+tlsCertificateFilePath: /etc/pulsar/tls/tls.crt # when using TLS\n+tlsKeyFilePath: /etc/pulsar/tls/tls.key # when using TLS\n+tlsTrustCertsFilePath: /etc/pulsar/tls/ca.crt # when using TLS\n+pulsarServiceUrl: pulsar://broker.pulsar:6650/ # or pulsar+ssl://pulsar-prod-broker.pulsar:6651/ when using TLS\n+pulsarWebServiceUrl: http://broker.pulsar:8080/ # or https://pulsar-prod-broker.pulsar:8443/ when using TLS\n+useTls: true # when using TLS, critical!\n+\n+```\n+\n+#### With Authentication", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NzA1Mw==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454767053", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When running a Functions Worker in a standalone process (i.e. not embedded in the Broker) in a cluster with authentication, you must configure your Functions Worker to both be able to interact with the Broker *and* also to authenticate incoming requests as well. This requires many of the same properties to be set that the Broker requires for authentication/authorization.\n          \n          \n            \n            When running a Functions Worker in a standalone process (that is, not embedded in the broker) in a cluster with authentication, you must configure your Functions Worker to both be able to interact with the broker *and* also to authenticate incoming requests as well. This requires many of the same properties to be set that the broker requires for authentication or authorization.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:22:47Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -183,3 +249,68 @@ for the `runtimeCustomerClassName` property. This implementation takes the follo\n   }\n }\n ```\n+\n+## Other configuration considerations\n+\n+\n+### In a cluster with geo-replication\n+\n+If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions\n+will share a namespace and potentially schedule across clusters.\n+\n+As an example, suppose we have clusters east-1 and west-1, we would configure the Functions Worker in east-1 like:\n+```Yaml\n+pulsarFunctionsCluster: east-1\n+pulsarFunctionsNamespace: public/functions-east-1\n+```\n+\n+and the cluster in west-1 like:\n+```Yaml\n+pulsarFunctionsCluster: west-1\n+pulsarFunctionsNamespace: public/functions-west-1\n+```\n+\n+This ensures the two different Function Workers will use distinct sets of topics for their internal co-ordination.\n+\n+### Configuring Standalone Functions Worker\n+\n+When configuring a standalone Functions Worker, you need to specify a few properties in order for the Functions Worker to be able\n+to communicate with the Broker. This requires many of the same properties to be set that the Broker requires, especially when using TLS.\n+\n+The following properties are the baseline of what is required:\n+\n+```Yaml\n+workerPort: 8080\n+workerPortTls: 8443 # when using TLS\n+tlsCertificateFilePath: /etc/pulsar/tls/tls.crt # when using TLS\n+tlsKeyFilePath: /etc/pulsar/tls/tls.key # when using TLS\n+tlsTrustCertsFilePath: /etc/pulsar/tls/ca.crt # when using TLS\n+pulsarServiceUrl: pulsar://broker.pulsar:6650/ # or pulsar+ssl://pulsar-prod-broker.pulsar:6651/ when using TLS\n+pulsarWebServiceUrl: http://broker.pulsar:8080/ # or https://pulsar-prod-broker.pulsar:8443/ when using TLS\n+useTls: true # when using TLS, critical!\n+\n+```\n+\n+#### With Authentication\n+\n+When running a Functions Worker in a standalone process (i.e. not embedded in the Broker) in a cluster with authentication, you must configure your Functions Worker to both be able to interact with the Broker *and* also to authenticate incoming requests as well. This requires many of the same properties to be set that the Broker requires for authentication/authorization.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NzMzNg==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454767336", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As an example, assuming we want to use token authentication, here is an example of properties we need to set in `function-worker.yml`\n          \n          \n            \n            As an example, assuming you want to use token authentication. Here is an example of properties you need to set in `function-worker.yml`\n          \n      \n    \n    \n  \n\nIBM Writing Style Guide:\n\u2022 Avoid the first-person pronouns I and we, except in these situations:\n\u00b0 In the question portion of frequently asked questions (FAQs)\n\u00b0 In articles, white papers, or documents that have listed authors and in which the authors describe their own actions or opinions", "author": "Anonymitaet", "createdAt": "2020-07-15T03:24:08Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -183,3 +249,68 @@ for the `runtimeCustomerClassName` property. This implementation takes the follo\n   }\n }\n ```\n+\n+## Other configuration considerations\n+\n+\n+### In a cluster with geo-replication\n+\n+If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions\n+will share a namespace and potentially schedule across clusters.\n+\n+As an example, suppose we have clusters east-1 and west-1, we would configure the Functions Worker in east-1 like:\n+```Yaml\n+pulsarFunctionsCluster: east-1\n+pulsarFunctionsNamespace: public/functions-east-1\n+```\n+\n+and the cluster in west-1 like:\n+```Yaml\n+pulsarFunctionsCluster: west-1\n+pulsarFunctionsNamespace: public/functions-west-1\n+```\n+\n+This ensures the two different Function Workers will use distinct sets of topics for their internal co-ordination.\n+\n+### Configuring Standalone Functions Worker\n+\n+When configuring a standalone Functions Worker, you need to specify a few properties in order for the Functions Worker to be able\n+to communicate with the Broker. This requires many of the same properties to be set that the Broker requires, especially when using TLS.\n+\n+The following properties are the baseline of what is required:\n+\n+```Yaml\n+workerPort: 8080\n+workerPortTls: 8443 # when using TLS\n+tlsCertificateFilePath: /etc/pulsar/tls/tls.crt # when using TLS\n+tlsKeyFilePath: /etc/pulsar/tls/tls.key # when using TLS\n+tlsTrustCertsFilePath: /etc/pulsar/tls/ca.crt # when using TLS\n+pulsarServiceUrl: pulsar://broker.pulsar:6650/ # or pulsar+ssl://pulsar-prod-broker.pulsar:6651/ when using TLS\n+pulsarWebServiceUrl: http://broker.pulsar:8080/ # or https://pulsar-prod-broker.pulsar:8443/ when using TLS\n+useTls: true # when using TLS, critical!\n+\n+```\n+\n+#### With Authentication\n+\n+When running a Functions Worker in a standalone process (i.e. not embedded in the Broker) in a cluster with authentication, you must configure your Functions Worker to both be able to interact with the Broker *and* also to authenticate incoming requests as well. This requires many of the same properties to be set that the Broker requires for authentication/authorization.\n+\n+As an example, assuming we want to use token authentication, here is an example of properties we need to set in `function-worker.yml`", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc2NzYwNw==", "url": "https://github.com/apache/pulsar/pull/7534#discussion_r454767607", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Notice that we must configure both the Function Worker authz/authn for the server to proper auth requests and configure the client to be authenticated to communicate with the broker.\n          \n          \n            \n            > #### Note \n          \n          \n            \n            >\n          \n          \n            \n            > You must configure both the Function Worker authorization or authentication for the server to proper authentication requests and configure the client to be authenticated to communicate with the broker.", "author": "Anonymitaet", "createdAt": "2020-07-15T03:25:11Z", "path": "site2/docs/functions-runtime.md", "diffHunk": "@@ -183,3 +249,68 @@ for the `runtimeCustomerClassName` property. This implementation takes the follo\n   }\n }\n ```\n+\n+## Other configuration considerations\n+\n+\n+### In a cluster with geo-replication\n+\n+If you are running multiple clusters tied together with geo-replication, it is important to use a different function namespace for each cluster! Otherwise, the functions\n+will share a namespace and potentially schedule across clusters.\n+\n+As an example, suppose we have clusters east-1 and west-1, we would configure the Functions Worker in east-1 like:\n+```Yaml\n+pulsarFunctionsCluster: east-1\n+pulsarFunctionsNamespace: public/functions-east-1\n+```\n+\n+and the cluster in west-1 like:\n+```Yaml\n+pulsarFunctionsCluster: west-1\n+pulsarFunctionsNamespace: public/functions-west-1\n+```\n+\n+This ensures the two different Function Workers will use distinct sets of topics for their internal co-ordination.\n+\n+### Configuring Standalone Functions Worker\n+\n+When configuring a standalone Functions Worker, you need to specify a few properties in order for the Functions Worker to be able\n+to communicate with the Broker. This requires many of the same properties to be set that the Broker requires, especially when using TLS.\n+\n+The following properties are the baseline of what is required:\n+\n+```Yaml\n+workerPort: 8080\n+workerPortTls: 8443 # when using TLS\n+tlsCertificateFilePath: /etc/pulsar/tls/tls.crt # when using TLS\n+tlsKeyFilePath: /etc/pulsar/tls/tls.key # when using TLS\n+tlsTrustCertsFilePath: /etc/pulsar/tls/ca.crt # when using TLS\n+pulsarServiceUrl: pulsar://broker.pulsar:6650/ # or pulsar+ssl://pulsar-prod-broker.pulsar:6651/ when using TLS\n+pulsarWebServiceUrl: http://broker.pulsar:8080/ # or https://pulsar-prod-broker.pulsar:8443/ when using TLS\n+useTls: true # when using TLS, critical!\n+\n+```\n+\n+#### With Authentication\n+\n+When running a Functions Worker in a standalone process (i.e. not embedded in the Broker) in a cluster with authentication, you must configure your Functions Worker to both be able to interact with the Broker *and* also to authenticate incoming requests as well. This requires many of the same properties to be set that the Broker requires for authentication/authorization.\n+\n+As an example, assuming we want to use token authentication, here is an example of properties we need to set in `function-worker.yml`\n+\n+```Yaml\n+clientAuthenticationPlugin: org.apache.pulsar.client.impl.auth.AuthenticationToken\n+clientAuthenticationParameters: file:///etc/pulsar/token/admin-token.txt\n+configurationStoreServers: zookeeper-cluster:2181 # auth requires a connection to zookeeper\n+authenticationProviders:\n+ - \"org.apache.pulsar.broker.authentication.AuthenticationProviderToken\"\n+authorizationEnabled: true\n+authenticationEnabled: true\n+superUserRoles:\n+  - superuser\n+  - proxy\n+properties:\n+  tokenSecretKey: file:///etc/pulsar/jwt/secret # if using a secret token\n+  tokenPublicKey: file:///etc/pulsar/jwt/public.key # if using public/private key tokens\n+```\n+\n+Notice that we must configure both the Function Worker authz/authn for the server to proper auth requests and configure the client to be authenticated to communicate with the broker.", "originalCommit": "1df035f1ef59529b3e3b29f927c225d79318adc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "af43240276b7923c6bcf3209a4d3aa898c2f4c64", "url": "https://github.com/apache/pulsar/commit/af43240276b7923c6bcf3209a4d3aa898c2f4c64", "message": "Apply suggestions from code review\n\nCo-authored-by: Yu Liu <50226895+Anonymitaet@users.noreply.github.com>", "committedDate": "2020-07-15T17:12:48Z", "type": "commit"}, {"oid": "8bb6758e969c5dee91741a2cfbc5712472d3bd8d", "url": "https://github.com/apache/pulsar/commit/8bb6758e969c5dee91741a2cfbc5712472d3bd8d", "message": "Functions Worker -> functions worker", "committedDate": "2020-07-15T17:14:36Z", "type": "commit"}]}