{"pr_number": 7236, "pr_title": "Fixed readers backlog stats after data is skipped", "pr_createdAt": "2020-06-10T17:33:11Z", "pr_url": "https://github.com/apache/pulsar/pull/7236", "timeline": [{"oid": "c7b71400e217e47157023eb39ec1fdade42a4663", "url": "https://github.com/apache/pulsar/commit/c7b71400e217e47157023eb39ec1fdade42a4663", "message": "Fixed readers backlog after data is skipped", "committedDate": "2020-06-10T17:31:00Z", "type": "commit"}, {"oid": "fee69014fdce3d6fb3eddb89a4f7fb9a792481d2", "url": "https://github.com/apache/pulsar/commit/fee69014fdce3d6fb3eddb89a4f7fb9a792481d2", "message": "Fixed merge error", "committedDate": "2020-06-10T17:50:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MDMxNQ==", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r438490315", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    long firstNonDeletedLedger = ledgers\n          \n          \n            \n                            .ceilingKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId() + 1);\n          \n          \n            \n                    long firstNonDeletedLedger = ledgers\n          \n          \n            \n                            .higherKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId());", "author": "codelipenghui", "createdAt": "2020-06-11T01:16:12Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java", "diffHunk": "@@ -2125,6 +2128,37 @@ public void operationFailed(MetaStoreException e) {\n         }\n     }\n \n+    /**\n+     * Non-durable cursors have to be moved forward when data is trimmed since they are not retain that data.\n+     * This is to make sure that the `consumedEntries` counter is correctly updated with the number of skipped\n+     * entries and the stats are reported correctly.\n+     */\n+    private void advanceNonDurableCursors(List<LedgerInfo> ledgersToDelete) {\n+        if (ledgersToDelete.isEmpty()) {\n+            return;\n+        }\n+\n+        long firstNonDeletedLedger = ledgers\n+                .ceilingKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId() + 1);", "originalCommit": "fee69014fdce3d6fb3eddb89a4f7fb9a792481d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MDU3Ng==", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r438490576", "bodyText": "Shall we need to add check for non-durable cursor?", "author": "codelipenghui", "createdAt": "2020-06-11T01:17:14Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java", "diffHunk": "@@ -2125,6 +2128,37 @@ public void operationFailed(MetaStoreException e) {\n         }\n     }\n \n+    /**\n+     * Non-durable cursors have to be moved forward when data is trimmed since they are not retain that data.\n+     * This is to make sure that the `consumedEntries` counter is correctly updated with the number of skipped\n+     * entries and the stats are reported correctly.\n+     */\n+    private void advanceNonDurableCursors(List<LedgerInfo> ledgersToDelete) {\n+        if (ledgersToDelete.isEmpty()) {\n+            return;\n+        }\n+\n+        long firstNonDeletedLedger = ledgers\n+                .ceilingKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId() + 1);\n+        PositionImpl highestPositionToDelete = new PositionImpl(firstNonDeletedLedger, -1);\n+\n+        cursors.forEach(cursor -> {\n+            if (highestPositionToDelete.compareTo((PositionImpl) cursor.getMarkDeletedPosition()) > 0) {", "originalCommit": "fee69014fdce3d6fb3eddb89a4f7fb9a792481d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNDQ3NA==", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r439014474", "bodyText": "No need for that, a durable cursor would have been already moved ahead, otherwise we wouldn't be trimming that ledger.", "author": "merlimat", "createdAt": "2020-06-11T19:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MTczNQ==", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r438491735", "bodyText": "Why durable cursor has 5 backlogs, non-durable cursor has 6 backlogs? Shouldn't they be the same?", "author": "codelipenghui", "createdAt": "2020-06-11T01:21:56Z", "path": "managed-ledger/src/test/java/org/apache/bookkeeper/mledger/impl/NonDurableCursorTest.java", "diffHunk": "@@ -678,6 +681,48 @@ public void testGetSlowestConsumer() throws Exception {\n         ledger.close();\n     }\n \n+    @Test\n+    public void testBacklogStatsWhenDroppingData() throws Exception {\n+        ManagedLedgerImpl ledger = (ManagedLedgerImpl) factory.open(\"testBacklogStatsWhenDroppingData\",\n+                new ManagedLedgerConfig().setMaxEntriesPerLedger(1));\n+        ManagedCursor c1 = ledger.openCursor(\"c1\");\n+        ManagedCursor nonDurableCursor = ledger.newNonDurableCursor(PositionImpl.earliest);\n+\n+        assertEquals(nonDurableCursor.getNumberOfEntries(), 0);\n+        assertEquals(nonDurableCursor.getNumberOfEntriesInBacklog(true), 0);\n+\n+        List<Position> positions = Lists.newArrayList();\n+        for (int i = 0; i < 10; i++) {\n+            positions.add(ledger.addEntry((\"entry-\" + i).getBytes(UTF_8)));\n+        }\n+\n+        assertEquals(nonDurableCursor.getNumberOfEntries(), 10);\n+        assertEquals(nonDurableCursor.getNumberOfEntriesInBacklog(true), 10);\n+\n+        c1.markDelete(positions.get(4));\n+        assertEquals(c1.getNumberOfEntries(), 5);\n+        assertEquals(c1.getNumberOfEntriesInBacklog(true), 5);\n+\n+        // Since the durable cursor has moved, the data will be trimmed\n+        CompletableFuture<Void> promise = new CompletableFuture<>();\n+        ledger.internalTrimConsumedLedgers(promise);\n+        promise.join();\n+\n+        assertEquals(nonDurableCursor.getNumberOfEntries(), 6);\n+        assertEquals(nonDurableCursor.getNumberOfEntriesInBacklog(true), 6);", "originalCommit": "fee69014fdce3d6fb3eddb89a4f7fb9a792481d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNDQyMQ==", "url": "https://github.com/apache/pulsar/pull/7236#discussion_r439014421", "bodyText": "That's because the other cursor is positioned at the end of the 5th ledger, but not on the 6th. That means that only 4 ledgers are deleted. That cursor would move forward on the next mark-delete.\nWhen advancing the non-durable cursor, we advance to the first available ledger and that might be before the durable cursor mark-delete position, but that's ok.", "author": "merlimat", "createdAt": "2020-06-11T19:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MTczNQ=="}], "type": "inlineReview"}, {"oid": "ff5b1d4162dcf285d78dbe7366fe5d14170cdcf8", "url": "https://github.com/apache/pulsar/commit/ff5b1d4162dcf285d78dbe7366fe5d14170cdcf8", "message": "Update managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java\n\nCo-authored-by: lipenghui <penghui@apache.org>", "committedDate": "2020-06-11T19:19:10Z", "type": "commit"}]}