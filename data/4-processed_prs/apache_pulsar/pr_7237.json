{"pr_number": 7237, "pr_title": "Fix leader/scheduler assignment processing lag problem", "pr_createdAt": "2020-06-10T20:17:19Z", "pr_url": "https://github.com/apache/pulsar/pull/7237", "timeline": [{"oid": "8a54e0f55e3ef0a536c560174a4f4a0241348084", "url": "https://github.com/apache/pulsar/commit/8a54e0f55e3ef0a536c560174a4f4a0241348084", "message": "Fix leader/scheduler assignment processing lag problem", "committedDate": "2020-06-10T20:33:45Z", "type": "commit"}, {"oid": "8a54e0f55e3ef0a536c560174a4f4a0241348084", "url": "https://github.com/apache/pulsar/commit/8a54e0f55e3ef0a536c560174a4f4a0241348084", "message": "Fix leader/scheduler assignment processing lag problem", "committedDate": "2020-06-10T20:33:45Z", "type": "forcePushed"}, {"oid": "540676151843d2e6c75b7abef423b96f8c9166da", "url": "https://github.com/apache/pulsar/commit/540676151843d2e6c75b7abef423b96f8c9166da", "message": "add license header", "committedDate": "2020-06-10T21:04:45Z", "type": "commit"}, {"oid": "65c23f8a61f1480c28dd61e7c2be177420299f6d", "url": "https://github.com/apache/pulsar/commit/65c23f8a61f1480c28dd61e7c2be177420299f6d", "message": "adding more comments", "committedDate": "2020-06-11T22:02:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDYzNg==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439174636", "bodyText": "this isn't right?", "author": "srkukarni", "createdAt": "2020-06-12T02:31:21Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -70,33 +78,64 @@ public FunctionAssignmentTailer(\n                             log.warn(\"Encountered error when assignment tailer is not running\", th);\n                         }\n                     }\n-\n                 }\n             }\n+            log.info(\"tailer thread exiting...\");\n+            hasExited.complete(null);\n         });\n         this.tailerThread.setName(\"assignment-tailer-thread\");\n     }\n \n-    public void start() {\n-        isRunning = true;\n-        tailerThread.start();\n+    public CompletableFuture<Void> triggerReadToTheEndAndExit() {\n+        exitOnEndOfTopic = true;\n+        return this.hasExited;\n+    }\n+\n+    public synchronized void start() throws PulsarClientException {\n+        if (!isRunning) {\n+            isRunning = true;\n+            if (reader == null) {\n+                reader = createReader();\n+            }\n+            tailerThread.start();\n+        }\n     }\n+    \n \n     @Override\n-    public void close() {\n-        log.info(\"Stopping function assignment tailer\");\n+    public synchronized void close() {\n+        log.info(\"Closing function assignment tailer\");\n         try {\n             isRunning = false;\n-            if (tailerThread != null && tailerThread.isAlive()) {\n-                tailerThread.interrupt();\n-            }\n+\n+            if (tailerThread != null) {\n+                while (true) {\n+                    tailerThread.interrupt();\n+\n+                    try {\n+                        tailerThread.join(5000, 0);\n+                    } catch (InterruptedException e) {\n+                        log.warn(\"Waiting for assignment tailer thread to stop is interrupted\", e);\n+                    }\n+\n+                    if (tailerThread.isAlive()) {\n+                        log.warn(\"Assignment tailer thread is still alive.  Will attempt to interrupt again.\");\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }            \n             if (reader != null) {\n                 reader.close();\n+                reader = null;\n             }\n+\n+            hasExited = new CompletableFuture<>();", "originalCommit": "540676151843d2e6c75b7abef423b96f8c9166da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI2NjQ2Nw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439266467", "bodyText": "it is re-initializing the variable, so if we can \"start\" again, the completeable future is not already completed", "author": "jerrypeng", "createdAt": "2020-06-12T07:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2NjUxMw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439866513", "bodyText": "Do you think its better to recreate the object? That way this re-create logic becomes simpler", "author": "srkukarni", "createdAt": "2020-06-14T20:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNzUxNQ==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439937515", "bodyText": "Creating a new FunctionAssignmentTailer doesn't really simplify the logic much.  \"hasExited\" is needed regardless of whether we recreate the object from scratch or not.  We are also keeping the track of the \"lastMessageId\" in FunctionAssignmentTailer.", "author": "jerrypeng", "createdAt": "2020-06-15T05:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDEzMw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441874133", "bodyText": "Then maybe we can create this at start instead?", "author": "srkukarni", "createdAt": "2020-06-17T22:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDI1Nw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441874257", "bodyText": "I just dislike creating new objects in something like close. Seems like not the usual pattern", "author": "srkukarni", "createdAt": "2020-06-17T22:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MDMwOQ==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441890309", "bodyText": "ok I re-initialize it in the start method", "author": "jerrypeng", "createdAt": "2020-06-17T23:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NDYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTAyMg==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439175022", "bodyText": "This should be abstracted out from leaderservice to respective class(in this case functionruntimemanager)", "author": "srkukarni", "createdAt": "2020-06-12T02:32:57Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/LeaderService.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.functions.worker;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.ConsumerEventListener;\n+import org.apache.pulsar.client.api.PulsarClient;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.client.impl.ConsumerImpl;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@Slf4j\n+public class LeaderService implements AutoCloseable, ConsumerEventListener {\n+\n+    private final String consumerName;\n+    private final FunctionAssignmentTailer functionAssignmentTailer;\n+    private final ErrorNotifier errorNotifier;\n+    private ConsumerImpl<byte[]> consumer;\n+    private final WorkerConfig workerConfig;\n+    private final PulsarClient pulsarClient;\n+    private final AtomicBoolean isLeader = new AtomicBoolean(false);\n+\n+    static final String COORDINATION_TOPIC_SUBSCRIPTION = \"participants\";\n+\n+    private static String WORKER_IDENTIFIER = \"id\";\n+    \n+    public LeaderService(WorkerService workerService,\n+                         PulsarClient pulsarClient,\n+                         FunctionAssignmentTailer functionAssignmentTailer,\n+                         ErrorNotifier errorNotifier) {\n+        this.workerConfig = workerService.getWorkerConfig();\n+        this.pulsarClient = pulsarClient;\n+        this.functionAssignmentTailer = functionAssignmentTailer;\n+        this.errorNotifier = errorNotifier;\n+        consumerName = String.format(\n+                \"%s:%s:%d\",\n+                workerConfig.getWorkerId(),\n+                workerConfig.getWorkerHostname(),\n+                workerConfig.getWorkerPort()\n+        );\n+\n+    }\n+\n+    public void start() throws PulsarClientException {\n+        // the leaders service is using a `coordination` topic for leader election.\n+        // we don't produce any messages into this topic, we only use the `failover` subscription\n+        // to elect an active consumer as the leader worker. The leader worker will be responsible\n+        // for scheduling snapshots for FMT and doing task assignment.\n+        consumer = (ConsumerImpl<byte[]>) pulsarClient.newConsumer()\n+                .topic(workerConfig.getClusterCoordinationTopic())\n+                .subscriptionName(COORDINATION_TOPIC_SUBSCRIPTION)\n+                .subscriptionType(SubscriptionType.Failover)\n+                .consumerEventListener(this)\n+                .property(WORKER_IDENTIFIER, consumerName)\n+                .subscribe();\n+\n+    }\n+\n+    @Override\n+    public void becameActive(Consumer<?> consumer, int partitionId) {\n+        if (isLeader.compareAndSet(false, true)) {\n+            log.info(\"Worker {} became the leader.\", consumerName);\n+            try {\n+                // trigger read to the end of the topic and exit\n+                // Since the leader can just update its in memory assignments cache directly\n+                functionAssignmentTailer.triggerReadToTheEndAndExit().get();", "originalCommit": "540676151843d2e6c75b7abef423b96f8c9166da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTMzNg==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439175336", "bodyText": "Also we need to create the producer here right?", "author": "srkukarni", "createdAt": "2020-06-12T02:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI2Nzc3Ng==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439267776", "bodyText": "This should be abstracted out from leaderservice to respective class(in this case functionruntimemanager)\n\nyup done\n\nAlso we need to create the producer here right?\n\nWhy do we need to create a producer? To start producing to the assignment topic?  We initialize the producer in the constructor.  I guess we don't need to do that and only when the worker becomes the leader will it create the producer and close the producer when it looses leadership", "author": "jerrypeng", "createdAt": "2020-06-12T07:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0MjYzMA==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439542630", "bodyText": "Yup. That is the same pattern in #7255 as well", "author": "srkukarni", "createdAt": "2020-06-12T17:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTAyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5OTgxMw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439699813", "bodyText": "done", "author": "jerrypeng", "createdAt": "2020-06-13T02:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTY2Mw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439175663", "bodyText": "I think we need to simplify this massively.\nI think part of the pr that I'm working on wrt metadata simplification will impact this as well.", "author": "srkukarni", "createdAt": "2020-06-12T02:35:49Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/SchedulerManager.java", "diffHunk": "@@ -137,25 +165,35 @@ public SchedulerManager(WorkerConfig workerConfig, PulsarClient pulsarClient, Pu\n     }\n \n     public Future<?> schedule() {\n-        return executorService.submit(() -> {\n-            synchronized (SchedulerManager.this) {\n-                boolean isLeader = membershipManager.isLeader();\n-                if (isLeader) {\n-                    try {\n-                        invokeScheduler();\n-                    } catch (Exception e) {\n-                        log.warn(\"Failed to invoke scheduler\", e);\n-                        throw e;\n+        try {", "originalCommit": "540676151843d2e6c75b7abef423b96f8c9166da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI2Njk0Mw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439266943", "bodyText": "What are you thinking?  What is the complexity here?", "author": "jerrypeng", "createdAt": "2020-06-12T07:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3NTY2Mw=="}], "type": "inlineReview"}, {"oid": "66de46e3b5669acf6ddfb413fc8c5b4f0878bad6", "url": "https://github.com/apache/pulsar/commit/66de46e3b5669acf6ddfb413fc8c5b4f0878bad6", "message": "improving impl", "committedDate": "2020-06-12T07:54:32Z", "type": "commit"}, {"oid": "4189de276ee4ca29fe4243805903a64d1098c8df", "url": "https://github.com/apache/pulsar/commit/4189de276ee4ca29fe4243805903a64d1098c8df", "message": "fixing bugs", "committedDate": "2020-06-12T21:58:24Z", "type": "commit"}, {"oid": "9d2ec82feb72eb4dde92fa72f8e1c84a98bc9fe0", "url": "https://github.com/apache/pulsar/commit/9d2ec82feb72eb4dde92fa72f8e1c84a98bc9fe0", "message": "improving impl", "committedDate": "2020-06-13T02:01:41Z", "type": "commit"}, {"oid": "4557156902ab323ad431a140b17d471012f62e2b", "url": "https://github.com/apache/pulsar/commit/4557156902ab323ad431a140b17d471012f62e2b", "message": "fixing tests", "committedDate": "2020-06-13T02:08:10Z", "type": "commit"}, {"oid": "85d3c0add33aa1fe1d57401ecfd393df6426f18f", "url": "https://github.com/apache/pulsar/commit/85d3c0add33aa1fe1d57401ecfd393df6426f18f", "message": "adding comments", "committedDate": "2020-06-13T02:14:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2NjU3Nw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439866577", "bodyText": "should we check for exitOnEndofTopic as well?", "author": "srkukarni", "createdAt": "2020-06-14T20:53:56Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -116,4 +147,51 @@ public void processAssignment(Message<byte[]> msg) {\n             this.functionRuntimeManager.processAssignment(assignment);\n         }\n     }\n+    \n+    private Reader<byte[]> createReader() throws PulsarClientException {\n+        MessageId startMessageId = lastMessageId == null ? MessageId.earliest : lastMessageId;\n+        log.info(\"Assignment tailer will start reading from message id {}\", startMessageId);\n+\n+        return readerBuilder\n+                .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-assignment-tailer\")\n+                .readerName(workerConfig.getWorkerId() + \"-function-assignment-tailer\")\n+                .topic(workerConfig.getFunctionAssignmentTopic())\n+                .readCompacted(true)\n+                .startMessageId(startMessageId)\n+                .create();\n+    }\n+\n+    private Thread getTailerThread() {\n+        Thread t = new Thread(() -> {\n+            while (isRunning) {\n+                try {\n+                    Message<byte[]> msg = reader.readNext(5, TimeUnit.SECONDS);\n+                    if (msg == null) {\n+                        if (exitOnEndOfTopic && !reader.hasMessageAvailable()) {\n+                            break;\n+                        }\n+                    } else {\n+                        processAssignment(msg);\n+                        // keep track of the last message read\n+                        lastMessageId = msg.getMessageId();\n+                    }\n+                } catch (Throwable th) {\n+                    if (isRunning) {", "originalCommit": "85d3c0add33aa1fe1d57401ecfd393df6426f18f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzOTA3MA==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r439939070", "bodyText": "I don't think we need to since even if \"exitOnEndOfTopic\" is set ,\"isRunning\" will still be set to true and any error will be bubbled up as expected", "author": "jerrypeng", "createdAt": "2020-06-15T05:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2NjU3Nw=="}], "type": "inlineReview"}, {"oid": "c10a5211f0a56c638fda0846999517991e537773", "url": "https://github.com/apache/pulsar/commit/c10a5211f0a56c638fda0846999517991e537773", "message": "add more testing", "committedDate": "2020-06-15T05:04:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3MzU4Mw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441873583", "bodyText": "maybe defer this till start?", "author": "srkukarni", "createdAt": "2020-06-17T22:43:56Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -28,75 +29,105 @@\n import org.apache.pulsar.functions.proto.Function.Assignment;\n \n import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n \n+/**\n+ * This class is responsible for reading assignments from the 'assignments' functions internal topic.\n+ * Only functions worker leader writes to the topic while other workers read from the topic.\n+ * When a worker become a leader, the worker will read to the end of the assignments topic and close its reader to the topic.\n+ * Then the worker and new leader will be in charge of computing new assignments when necessary.\n+ * The leader does not need to listen to the assignments topic because it can just update its in memory assignments map directly\n+ * after it computes a new scheduling.  When a worker loses leadership, the worker is start reading from the assignments topic again.\n+ */\n @Slf4j\n public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n+    private final ReaderBuilder readerBuilder;\n+    private final WorkerConfig workerConfig;\n+    private final ErrorNotifier errorNotifier;\n     @Getter\n-    private final Reader<byte[]> reader;\n+    private Reader<byte[]> reader;\n     private volatile boolean isRunning = false;\n+    private volatile boolean exitOnEndOfTopic = false;\n+    private CompletableFuture<Void> hasExited;\n \n-    private final Thread tailerThread;\n+    private Thread tailerThread;\n+\n+    @Getter\n+    @Setter\n+    private MessageId lastMessageId = null;\n     \n     public FunctionAssignmentTailer(\n             FunctionRuntimeManager functionRuntimeManager,\n             ReaderBuilder readerBuilder,\n             WorkerConfig workerConfig,\n             ErrorNotifier errorNotifier) throws PulsarClientException {\n         this.functionRuntimeManager = functionRuntimeManager;\n+        this.hasExited = new CompletableFuture<>();\n+        this.readerBuilder = readerBuilder;\n+        this.workerConfig = workerConfig;\n+        this.errorNotifier = errorNotifier;\n+        this.reader = createReader();\n         \n-        this.reader = readerBuilder\n-          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n-          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n-          .topic(workerConfig.getFunctionAssignmentTopic())\n-          .readCompacted(true)\n-          .startMessageId(MessageId.earliest)\n-          .create();\n-        \n-        this.tailerThread = new Thread(() -> {\n-            while(isRunning) {\n-                try {\n-                    Message<byte[]> msg = reader.readNext();\n-                    processAssignment(msg);\n-                } catch (Throwable th) {\n-                    if (isRunning) {\n-                        log.error(\"Encountered error in assignment tailer\", th);\n-                        // trigger fatal error\n-                        isRunning = false;\n-                        errorNotifier.triggerError(th);\n-                    } else {\n-                        if (!(th instanceof InterruptedException || th.getCause() instanceof InterruptedException)) {\n-                            log.warn(\"Encountered error when assignment tailer is not running\", th);\n-                        }\n-                    }\n+        this.tailerThread = getTailerThread();", "originalCommit": "c10a5211f0a56c638fda0846999517991e537773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4OTU4NA==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441889584", "bodyText": "sure", "author": "jerrypeng", "createdAt": "2020-06-17T23:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3MzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NTA1Mg==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441875052", "bodyText": "Why are we adding this here? I'm not seeing any usages", "author": "srkukarni", "createdAt": "2020-06-17T22:48:47Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionRuntimeManager.java", "diffHunk": "@@ -130,6 +132,8 @@ public int size() {\n     private final FunctionMetaDataManager functionMetaDataManager;\n \n     private final ErrorNotifier errorNotifier;\n+", "originalCommit": "c10a5211f0a56c638fda0846999517991e537773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMzczNA==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441913734", "bodyText": "Its not being used and will remove", "author": "jerrypeng", "createdAt": "2020-06-18T01:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NTA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NTYxNg==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441875616", "bodyText": "Can you instead call functionRunTimeManager.acquireLeadership() and functionRunTimeManager.giveupLeadership()", "author": "srkukarni", "createdAt": "2020-06-17T22:50:41Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/LeaderService.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.functions.worker;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.ConsumerEventListener;\n+import org.apache.pulsar.client.api.PulsarClient;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.client.impl.ConsumerImpl;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@Slf4j\n+public class LeaderService implements AutoCloseable, ConsumerEventListener {\n+\n+    private final String consumerName;\n+    private final FunctionRuntimeManager functionRuntimeManager;\n+    private final ErrorNotifier errorNotifier;\n+    private final SchedulerManager schedulerManager;\n+    private ConsumerImpl<byte[]> consumer;\n+    private final WorkerConfig workerConfig;\n+    private final PulsarClient pulsarClient;\n+    private final AtomicBoolean isLeader = new AtomicBoolean(false);\n+\n+    static final String COORDINATION_TOPIC_SUBSCRIPTION = \"participants\";\n+\n+    private static String WORKER_IDENTIFIER = \"id\";\n+    \n+    public LeaderService(WorkerService workerService,\n+                         PulsarClient pulsarClient,\n+                         FunctionRuntimeManager functionRuntimeManager,\n+                         SchedulerManager schedulerManager,\n+                         ErrorNotifier errorNotifier) {\n+        this.workerConfig = workerService.getWorkerConfig();\n+        this.pulsarClient = pulsarClient;\n+        this.functionRuntimeManager = functionRuntimeManager;\n+        this.schedulerManager = schedulerManager;\n+        this.errorNotifier = errorNotifier;\n+        consumerName = String.format(\n+                \"%s:%s:%d\",\n+                workerConfig.getWorkerId(),\n+                workerConfig.getWorkerHostname(),\n+                workerConfig.getWorkerPort()\n+        );\n+\n+    }\n+\n+    public void start() throws PulsarClientException {\n+        // the leaders service is using a `coordination` topic for leader election.\n+        // we don't produce any messages into this topic, we only use the `failover` subscription\n+        // to elect an active consumer as the leader worker. The leader worker will be responsible\n+        // for scheduling snapshots for FMT and doing task assignment.\n+        consumer = (ConsumerImpl<byte[]>) pulsarClient.newConsumer()\n+                .topic(workerConfig.getClusterCoordinationTopic())\n+                .subscriptionName(COORDINATION_TOPIC_SUBSCRIPTION)\n+                .subscriptionType(SubscriptionType.Failover)\n+                .consumerEventListener(this)\n+                .property(WORKER_IDENTIFIER, consumerName)\n+                .consumerName(consumerName)\n+                .subscribe();\n+\n+    }\n+\n+    @Override\n+    public void becameActive(Consumer<?> consumer, int partitionId) {\n+        if (isLeader.compareAndSet(false, true)) {\n+            log.info(\"Worker {} became the leader.\", consumerName);\n+            try {\n+                // trigger read to the end of the topic and exit\n+                // Since the leader can just update its in memory assignments cache directly\n+                functionRuntimeManager.stopReadingAssignments();", "originalCommit": "c10a5211f0a56c638fda0846999517991e537773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4ODEyNA==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441888124", "bodyText": "doesn't make to call \"schedulerManager.initialize();\" there or add the SchedulerManager as a dependency in FunctionRuntimeManager just for this", "author": "jerrypeng", "createdAt": "2020-06-17T23:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NTYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4Njg4Mw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441886883", "bodyText": "I think the better way is to make scheduler aware of the leadership changes(just like runtime manger) and call acquireLeadership and giveupLeadership", "author": "srkukarni", "createdAt": "2020-06-17T23:27:14Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/LeaderService.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.functions.worker;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.ConsumerEventListener;\n+import org.apache.pulsar.client.api.PulsarClient;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.client.impl.ConsumerImpl;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+@Slf4j\n+public class LeaderService implements AutoCloseable, ConsumerEventListener {\n+\n+    private final String consumerName;\n+    private final FunctionRuntimeManager functionRuntimeManager;\n+    private final ErrorNotifier errorNotifier;\n+    private final SchedulerManager schedulerManager;\n+    private ConsumerImpl<byte[]> consumer;\n+    private final WorkerConfig workerConfig;\n+    private final PulsarClient pulsarClient;\n+    private final AtomicBoolean isLeader = new AtomicBoolean(false);\n+\n+    static final String COORDINATION_TOPIC_SUBSCRIPTION = \"participants\";\n+\n+    private static String WORKER_IDENTIFIER = \"id\";\n+    \n+    public LeaderService(WorkerService workerService,\n+                         PulsarClient pulsarClient,\n+                         FunctionRuntimeManager functionRuntimeManager,\n+                         SchedulerManager schedulerManager,\n+                         ErrorNotifier errorNotifier) {\n+        this.workerConfig = workerService.getWorkerConfig();\n+        this.pulsarClient = pulsarClient;\n+        this.functionRuntimeManager = functionRuntimeManager;\n+        this.schedulerManager = schedulerManager;\n+        this.errorNotifier = errorNotifier;\n+        consumerName = String.format(\n+                \"%s:%s:%d\",\n+                workerConfig.getWorkerId(),\n+                workerConfig.getWorkerHostname(),\n+                workerConfig.getWorkerPort()\n+        );\n+\n+    }\n+\n+    public void start() throws PulsarClientException {\n+        // the leaders service is using a `coordination` topic for leader election.\n+        // we don't produce any messages into this topic, we only use the `failover` subscription\n+        // to elect an active consumer as the leader worker. The leader worker will be responsible\n+        // for scheduling snapshots for FMT and doing task assignment.\n+        consumer = (ConsumerImpl<byte[]>) pulsarClient.newConsumer()\n+                .topic(workerConfig.getClusterCoordinationTopic())\n+                .subscriptionName(COORDINATION_TOPIC_SUBSCRIPTION)\n+                .subscriptionType(SubscriptionType.Failover)\n+                .consumerEventListener(this)\n+                .property(WORKER_IDENTIFIER, consumerName)\n+                .consumerName(consumerName)\n+                .subscribe();\n+\n+    }\n+\n+    @Override\n+    public void becameActive(Consumer<?> consumer, int partitionId) {\n+        if (isLeader.compareAndSet(false, true)) {\n+            log.info(\"Worker {} became the leader.\", consumerName);\n+            try {\n+                // trigger read to the end of the topic and exit\n+                // Since the leader can just update its in memory assignments cache directly\n+                functionRuntimeManager.stopReadingAssignments();\n+\n+                // make sure scheduler is initialized because this worker\n+                // is the leader and may need to start computing and writing assignments\n+                schedulerManager.initialize();\n+            } catch (Throwable th) {\n+                log.error(\"Encountered error when initializing to become leader\", th);\n+                errorNotifier.triggerError(th);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void becameInactive(Consumer<?> consumer, int partitionId) {\n+        if (isLeader.compareAndSet(true, false)) {\n+            log.info(\"Worker {} lost the leadership.\", consumerName);\n+            // when a worker has lost leadership it needs to start reading from the assignment topic again\n+            try {\n+                // acquire scheduler lock to make sure a scheduling is not in process\n+                schedulerManager.getSchedulerLock().lock();", "originalCommit": "c10a5211f0a56c638fda0846999517991e537773", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NzU5NQ==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r441887595", "bodyText": "This is a way to do that.  You will need synchronization somewhere and someone will have to wait", "author": "jerrypeng", "createdAt": "2020-06-17T23:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4Njg4Mw=="}], "type": "inlineReview"}, {"oid": "61f1c2bb73ec982ff4c818f39ce68bc9f8be8e62", "url": "https://github.com/apache/pulsar/commit/61f1c2bb73ec982ff4c818f39ce68bc9f8be8e62", "message": "addressing comments", "committedDate": "2020-06-18T01:08:29Z", "type": "commit"}, {"oid": "1c8f55419f554d466c34f3412763fc41c9a6d74c", "url": "https://github.com/apache/pulsar/commit/1c8f55419f554d466c34f3412763fc41c9a6d74c", "message": "cleaning up", "committedDate": "2020-06-18T01:10:46Z", "type": "commit"}, {"oid": "67c082e0eececb89879f2af8f4d38ca5c6d62741", "url": "https://github.com/apache/pulsar/commit/67c082e0eececb89879f2af8f4d38ca5c6d62741", "message": "refactoring implementation", "committedDate": "2020-06-19T01:55:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MTY1NQ==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442641655", "bodyText": "exitFuture might be a better name", "author": "srkukarni", "createdAt": "2020-06-19T05:42:40Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -25,95 +25,157 @@\n import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n import org.apache.pulsar.client.api.ReaderBuilder;\n-import org.apache.pulsar.functions.proto.Function.Assignment;\n \n import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n \n+/**\n+ * This class is responsible for reading assignments from the 'assignments' functions internal topic.\n+ * Only functions worker leader writes to the topic while other workers read from the topic.\n+ * When a worker become a leader, the worker will read to the end of the assignments topic and close its reader to the topic.\n+ * Then the worker and new leader will be in charge of computing new assignments when necessary.\n+ * The leader does not need to listen to the assignments topic because it can just update its in memory assignments map directly\n+ * after it computes a new scheduling.  When a worker loses leadership, the worker is start reading from the assignments topic again.\n+ */\n @Slf4j\n public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n-    @Getter\n-    private final Reader<byte[]> reader;\n+    private final ReaderBuilder readerBuilder;\n+    private final WorkerConfig workerConfig;\n+    private final ErrorNotifier errorNotifier;\n+    private Reader<byte[]> reader;\n     private volatile boolean isRunning = false;\n+    private volatile boolean exitOnEndOfTopic = false;\n+    private CompletableFuture<Void> hasExited;", "originalCommit": "67c082e0eececb89879f2af8f4d38ca5c6d62741", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2MjExNg==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442662116", "bodyText": "sure", "author": "jerrypeng", "createdAt": "2020-06-19T06:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MTY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MTc5MA==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442641790", "bodyText": "Shouldn' t we init this to MessageId.earliest?", "author": "srkukarni", "createdAt": "2020-06-19T05:43:16Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -25,95 +25,157 @@\n import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n import org.apache.pulsar.client.api.ReaderBuilder;\n-import org.apache.pulsar.functions.proto.Function.Assignment;\n \n import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n \n+/**\n+ * This class is responsible for reading assignments from the 'assignments' functions internal topic.\n+ * Only functions worker leader writes to the topic while other workers read from the topic.\n+ * When a worker become a leader, the worker will read to the end of the assignments topic and close its reader to the topic.\n+ * Then the worker and new leader will be in charge of computing new assignments when necessary.\n+ * The leader does not need to listen to the assignments topic because it can just update its in memory assignments map directly\n+ * after it computes a new scheduling.  When a worker loses leadership, the worker is start reading from the assignments topic again.\n+ */\n @Slf4j\n public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n-    @Getter\n-    private final Reader<byte[]> reader;\n+    private final ReaderBuilder readerBuilder;\n+    private final WorkerConfig workerConfig;\n+    private final ErrorNotifier errorNotifier;\n+    private Reader<byte[]> reader;\n     private volatile boolean isRunning = false;\n+    private volatile boolean exitOnEndOfTopic = false;\n+    private CompletableFuture<Void> hasExited;\n+    private Thread tailerThread;\n \n-    private final Thread tailerThread;\n+    @Getter\n+    private MessageId lastMessageId = null;", "originalCommit": "67c082e0eececb89879f2af8f4d38ca5c6d62741", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1OTY1Ng==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442659656", "bodyText": "No", "author": "jerrypeng", "createdAt": "2020-06-19T06:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MTc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MjQzMA==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442642430", "bodyText": "I think its cleaner to consolidate this and above method to start(MessageId) { ... }", "author": "srkukarni", "createdAt": "2020-06-19T05:45:44Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -25,95 +25,157 @@\n import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n import org.apache.pulsar.client.api.ReaderBuilder;\n-import org.apache.pulsar.functions.proto.Function.Assignment;\n \n import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n \n+/**\n+ * This class is responsible for reading assignments from the 'assignments' functions internal topic.\n+ * Only functions worker leader writes to the topic while other workers read from the topic.\n+ * When a worker become a leader, the worker will read to the end of the assignments topic and close its reader to the topic.\n+ * Then the worker and new leader will be in charge of computing new assignments when necessary.\n+ * The leader does not need to listen to the assignments topic because it can just update its in memory assignments map directly\n+ * after it computes a new scheduling.  When a worker loses leadership, the worker is start reading from the assignments topic again.\n+ */\n @Slf4j\n public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n-    @Getter\n-    private final Reader<byte[]> reader;\n+    private final ReaderBuilder readerBuilder;\n+    private final WorkerConfig workerConfig;\n+    private final ErrorNotifier errorNotifier;\n+    private Reader<byte[]> reader;\n     private volatile boolean isRunning = false;\n+    private volatile boolean exitOnEndOfTopic = false;\n+    private CompletableFuture<Void> hasExited;\n+    private Thread tailerThread;\n \n-    private final Thread tailerThread;\n+    @Getter\n+    private MessageId lastMessageId = null;\n     \n     public FunctionAssignmentTailer(\n             FunctionRuntimeManager functionRuntimeManager,\n             ReaderBuilder readerBuilder,\n             WorkerConfig workerConfig,\n-            ErrorNotifier errorNotifier) throws PulsarClientException {\n+            ErrorNotifier errorNotifier) {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        \n-        this.reader = readerBuilder\n-          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n-          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n-          .topic(workerConfig.getFunctionAssignmentTopic())\n-          .readCompacted(true)\n-          .startMessageId(MessageId.earliest)\n-          .create();\n-        \n-        this.tailerThread = new Thread(() -> {\n-            while(isRunning) {\n-                try {\n-                    Message<byte[]> msg = reader.readNext();\n-                    processAssignment(msg);\n-                } catch (Throwable th) {\n-                    if (isRunning) {\n-                        log.error(\"Encountered error in assignment tailer\", th);\n-                        // trigger fatal error\n-                        isRunning = false;\n-                        errorNotifier.triggerError(th);\n-                    } else {\n-                        if (!(th instanceof InterruptedException || th.getCause() instanceof InterruptedException)) {\n-                            log.warn(\"Encountered error when assignment tailer is not running\", th);\n-                        }\n-                    }\n+        this.hasExited = new CompletableFuture<>();\n+        this.readerBuilder = readerBuilder;\n+        this.workerConfig = workerConfig;\n+        this.errorNotifier = errorNotifier;\n+    }\n \n-                }\n+    public synchronized CompletableFuture<Void> triggerReadToTheEndAndExit() {\n+        exitOnEndOfTopic = true;\n+        return this.hasExited;\n+    }\n+\n+    public void startFromMessage(MessageId startMessageId) throws PulsarClientException {\n+        log.info(\"Function assignment tailer start reading from topic {} at {}\",\n+                workerConfig.getFunctionAssignmentTopic(), startMessageId);\n+        if (!isRunning) {\n+            isRunning = true;\n+            if (reader == null) {\n+                reader = createReader(startMessageId);\n             }\n-        });\n-        this.tailerThread.setName(\"assignment-tailer-thread\");\n+            if (tailerThread == null || !tailerThread.isAlive()) {\n+                tailerThread = getTailerThread();\n+            }\n+            hasExited = new CompletableFuture<>();\n+            tailerThread.start();\n+        }\n     }\n \n-    public void start() {\n-        isRunning = true;\n-        tailerThread.start();\n+    public synchronized void start() throws PulsarClientException {", "originalCommit": "67c082e0eececb89879f2af8f4d38ca5c6d62741", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0Mjc0NQ==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442642745", "bodyText": "I also think that some logic will be simpler if we create Tailer object every time we go thru leadership transistion", "author": "srkukarni", "createdAt": "2020-06-19T05:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MjQzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1OTYxMw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442659613", "bodyText": "I also think that some logic will be simpler if we create Tailer object every time we go thru leadership transition\n\nThat is not correct.  The functionAssignmentTailer is also responsible for keeping track of a message id.  If a worker becomes a leader and then loses leadership prior to creating any assignments, we shouldn't just start reading the assignment topic from the beginning.  We should resume from the message id stored in the functionAssignmentTailer", "author": "jerrypeng", "createdAt": "2020-06-19T06:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MjQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MzMwMw==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442643303", "bodyText": "is it simpler if we do\nwhile(isRunning) {\nif (exitOnEndOfTopic && !available) break;\ntry { read message... }", "author": "srkukarni", "createdAt": "2020-06-19T05:48:58Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionAssignmentTailer.java", "diffHunk": "@@ -25,95 +25,157 @@\n import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.Reader;\n import org.apache.pulsar.client.api.ReaderBuilder;\n-import org.apache.pulsar.functions.proto.Function.Assignment;\n \n import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n \n+/**\n+ * This class is responsible for reading assignments from the 'assignments' functions internal topic.\n+ * Only functions worker leader writes to the topic while other workers read from the topic.\n+ * When a worker become a leader, the worker will read to the end of the assignments topic and close its reader to the topic.\n+ * Then the worker and new leader will be in charge of computing new assignments when necessary.\n+ * The leader does not need to listen to the assignments topic because it can just update its in memory assignments map directly\n+ * after it computes a new scheduling.  When a worker loses leadership, the worker is start reading from the assignments topic again.\n+ */\n @Slf4j\n public class FunctionAssignmentTailer implements AutoCloseable {\n \n     private final FunctionRuntimeManager functionRuntimeManager;\n-    @Getter\n-    private final Reader<byte[]> reader;\n+    private final ReaderBuilder readerBuilder;\n+    private final WorkerConfig workerConfig;\n+    private final ErrorNotifier errorNotifier;\n+    private Reader<byte[]> reader;\n     private volatile boolean isRunning = false;\n+    private volatile boolean exitOnEndOfTopic = false;\n+    private CompletableFuture<Void> hasExited;\n+    private Thread tailerThread;\n \n-    private final Thread tailerThread;\n+    @Getter\n+    private MessageId lastMessageId = null;\n     \n     public FunctionAssignmentTailer(\n             FunctionRuntimeManager functionRuntimeManager,\n             ReaderBuilder readerBuilder,\n             WorkerConfig workerConfig,\n-            ErrorNotifier errorNotifier) throws PulsarClientException {\n+            ErrorNotifier errorNotifier) {\n         this.functionRuntimeManager = functionRuntimeManager;\n-        \n-        this.reader = readerBuilder\n-          .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n-          .readerName(workerConfig.getWorkerId() + \"-function-runtime-manager\")\n-          .topic(workerConfig.getFunctionAssignmentTopic())\n-          .readCompacted(true)\n-          .startMessageId(MessageId.earliest)\n-          .create();\n-        \n-        this.tailerThread = new Thread(() -> {\n-            while(isRunning) {\n-                try {\n-                    Message<byte[]> msg = reader.readNext();\n-                    processAssignment(msg);\n-                } catch (Throwable th) {\n-                    if (isRunning) {\n-                        log.error(\"Encountered error in assignment tailer\", th);\n-                        // trigger fatal error\n-                        isRunning = false;\n-                        errorNotifier.triggerError(th);\n-                    } else {\n-                        if (!(th instanceof InterruptedException || th.getCause() instanceof InterruptedException)) {\n-                            log.warn(\"Encountered error when assignment tailer is not running\", th);\n-                        }\n-                    }\n+        this.hasExited = new CompletableFuture<>();\n+        this.readerBuilder = readerBuilder;\n+        this.workerConfig = workerConfig;\n+        this.errorNotifier = errorNotifier;\n+    }\n \n-                }\n+    public synchronized CompletableFuture<Void> triggerReadToTheEndAndExit() {\n+        exitOnEndOfTopic = true;\n+        return this.hasExited;\n+    }\n+\n+    public void startFromMessage(MessageId startMessageId) throws PulsarClientException {\n+        log.info(\"Function assignment tailer start reading from topic {} at {}\",\n+                workerConfig.getFunctionAssignmentTopic(), startMessageId);\n+        if (!isRunning) {\n+            isRunning = true;\n+            if (reader == null) {\n+                reader = createReader(startMessageId);\n             }\n-        });\n-        this.tailerThread.setName(\"assignment-tailer-thread\");\n+            if (tailerThread == null || !tailerThread.isAlive()) {\n+                tailerThread = getTailerThread();\n+            }\n+            hasExited = new CompletableFuture<>();\n+            tailerThread.start();\n+        }\n     }\n \n-    public void start() {\n-        isRunning = true;\n-        tailerThread.start();\n+    public synchronized void start() throws PulsarClientException {\n+        MessageId startMessageId = lastMessageId == null ? MessageId.earliest : lastMessageId;\n+        startFromMessage(startMessageId);\n     }\n \n     @Override\n-    public void close() {\n-        log.info(\"Stopping function assignment tailer\");\n+    public synchronized void close() {\n+        log.info(\"Closing function assignment tailer\");\n         try {\n             isRunning = false;\n-            if (tailerThread != null && tailerThread.isAlive()) {\n-                tailerThread.interrupt();\n+\n+            if (tailerThread != null) {\n+                while (true) {\n+                    tailerThread.interrupt();\n+\n+                    try {\n+                        tailerThread.join(5000, 0);\n+                    } catch (InterruptedException e) {\n+                        log.warn(\"Waiting for assignment tailer thread to stop is interrupted\", e);\n+                    }\n+\n+                    if (tailerThread.isAlive()) {\n+                        log.warn(\"Assignment tailer thread is still alive.  Will attempt to interrupt again.\");\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                tailerThread = null;\n             }\n             if (reader != null) {\n                 reader.close();\n+                reader = null;\n             }\n+\n+            hasExited = null;\n+            exitOnEndOfTopic = false;\n+            \n         } catch (IOException e) {\n             log.error(\"Failed to stop function assignment tailer\", e);\n         }\n-        log.info(\"Stopped function assignment tailer\");\n+    }\n+    \n+    private Reader<byte[]> createReader(MessageId startMessageId) throws PulsarClientException {\n+        log.info(\"Assignment tailer will start reading from message id {}\", startMessageId);\n+\n+        return readerBuilder\n+                .subscriptionRolePrefix(workerConfig.getWorkerId() + \"-function-assignment-tailer\")\n+                .readerName(workerConfig.getWorkerId() + \"-function-assignment-tailer\")\n+                .topic(workerConfig.getFunctionAssignmentTopic())\n+                .readCompacted(true)\n+                .startMessageId(startMessageId)\n+                .create();\n     }\n \n-    public void processAssignment(Message<byte[]> msg) {\n-\n-        if(msg.getData()==null || (msg.getData().length==0)) {\n-            log.info(\"Received assignment delete: {}\", msg.getKey());\n-            this.functionRuntimeManager.deleteAssignment(msg.getKey());\n-        } else {\n-            Assignment assignment;\n-            try {\n-                assignment = Assignment.parseFrom(msg.getData());\n-            } catch (IOException e) {\n-                log.error(\"[{}] Received bad assignment update at message {}\", reader.getTopic(), msg.getMessageId(), e);\n-                throw new RuntimeException(e);\n+    private Thread getTailerThread() {\n+        Thread t = new Thread(() -> {\n+            while (isRunning) {\n+                try {\n+                    Message<byte[]> msg = reader.readNext(5, TimeUnit.SECONDS);\n+                    if (msg == null) {\n+                        if (exitOnEndOfTopic && !reader.hasMessageAvailable()) {\n+                            break;\n+                        }", "originalCommit": "67c082e0eececb89879f2af8f4d38ca5c6d62741", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2MzA4Mg==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442663082", "bodyText": "It's safer to wait for a timeout period to make sure no messages just arrived late", "author": "jerrypeng", "createdAt": "2020-06-19T06:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MzMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MzUxNQ==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442643515", "bodyText": "initialize and start? what cannot be done during constructor?", "author": "srkukarni", "createdAt": "2020-06-19T05:49:55Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -99,16 +98,20 @@ public void initialize() {\n                 this.functionMetaDataTopicTailer.processRequest(this.functionMetaDataTopicTailer.getReader().readNext());\n             }\n             this.setInitializePhase(false);\n-            // schedule functions if necessary\n-            this.schedulerManager.schedule();\n-            // start function metadata tailer\n-            this.functionMetaDataTopicTailer.start();\n+            \n \n         } catch (Exception e) {\n             log.error(\"Failed to initialize meta data store\", e);\n             throw new RuntimeException(e);\n         }\n     }\n+    \n+    public void start() {", "originalCommit": "67c082e0eececb89879f2af8f4d38ca5c6d62741", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzA1OA==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442673058", "bodyText": "because we cannot start prior to the SchedulerManager is setup since function metadata manager can invoke the scheduler.  We can initialize prior to to setting up the SchedulerManager but we cannot start", "author": "jerrypeng", "createdAt": "2020-06-19T07:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0MzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NDAwOQ==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442644009", "bodyText": "I like that we are no longer using FunctionAssignmenttailer here. However maybe a static method that consolidates. this reader creation and the one in assignment tailer?", "author": "srkukarni", "createdAt": "2020-06-19T05:51:27Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionRuntimeManager.java", "diffHunk": "@@ -210,21 +210,25 @@ public FunctionRuntimeManager(WorkerConfig workerConfig, WorkerService workerSer\n      * 2. After current assignments are read, assignments belonging to this worker will be processed\n      */\n     public void initialize() {\n-        log.info(\"/** Initializing Runtime Manager **/\");\n         try {\n-            this.functionAssignmentTailer = new FunctionAssignmentTailer(\n-                    this,\n-                    this.getWorkerService().getClient().newReader(),\n-                    this.workerConfig,\n-                    this.errorNotifier);\n+", "originalCommit": "67c082e0eececb89879f2af8f4d38ca5c6d62741", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY2NjM5MQ==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442666391", "bodyText": "sure", "author": "jerrypeng", "createdAt": "2020-06-19T07:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NDAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NTU2MQ==", "url": "https://github.com/apache/pulsar/pull/7237#discussion_r442645561", "bodyText": "remove?", "author": "srkukarni", "createdAt": "2020-06-19T05:57:19Z", "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/WorkerUtils.java", "diffHunk": "@@ -33,8 +33,11 @@\n import org.apache.pulsar.client.admin.PulsarAdmin;\n import org.apache.pulsar.client.admin.PulsarAdminBuilder;\n import org.apache.pulsar.client.api.ClientBuilder;\n+import org.apache.pulsar.client.api.MessageId;", "originalCommit": "67c082e0eececb89879f2af8f4d38ca5c6d62741", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0d31bf593b40c034bfe4eb7e4c3ca0eec09065c8", "url": "https://github.com/apache/pulsar/commit/0d31bf593b40c034bfe4eb7e4c3ca0eec09065c8", "message": "addressing comments", "committedDate": "2020-06-19T07:07:35Z", "type": "commit"}]}