{"pr_number": 2107, "pr_title": "[CALCITE-4113] Support LEFT join in EnumerableMergeJoin", "pr_createdAt": "2020-08-12T16:16:20Z", "pr_url": "https://github.com/apache/calcite/pull/2107", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg3NTQ5OA==", "url": "https://github.com/apache/calcite/pull/2107#discussion_r471875498", "bodyText": "Could we merge these two if conditions?", "author": "chunweilei", "createdAt": "2020-08-18T02:22:52Z", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -4223,8 +4227,10 @@ private boolean advanceLeft(TSource left, TKey leftKey) {\n         TKey leftKey2 = outerKeySelector.apply(left);\n         if (leftKey2 == null) {\n           // mergeJoin assumes inputs sorted in ascending order with nulls last,\n-          // if we reach a null key, we are done\n-          break;\n+          // if we reach a null key, we are done (except LEFT join, that needs to process LHS fully)\n+          if (joinType != JoinType.LEFT) {\n+            break;\n+          }\n         }", "originalCommit": "613f0d417d890cb71550d32714a327afe71cb4e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2MzM4MQ==", "url": "https://github.com/apache/calcite/pull/2107#discussion_r471963381", "bodyText": "well spotted, thanks.\ndone.", "author": "rubenada", "createdAt": "2020-08-18T07:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg3NTQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NTAzNg==", "url": "https://github.com/apache/calcite/pull/2107#discussion_r471985036", "bodyText": "I am bit concerned about some of the \"new\" plans in sub-query.iq, which introduce EnumerableMergeJoin (with joinType=left), but only one of the join inputs is sorted with an EnumerableSort (in this example the left input). The other input (in this case, the right) does not contain the Sort operator, so this could be a problem.", "author": "rubenada", "createdAt": "2020-08-18T07:51:36Z", "path": "core/src/test/resources/sql/sub-query.iq", "diffHunk": "@@ -1761,9 +1761,10 @@ select sal from \"scott\".emp e\n \n !ok\n EnumerableCalc(expr#0..4=[{inputs}], expr#5=[NOT($t4)], expr#6=[IS NOT NULL($t4)], expr#7=[OR($t5, $t6)], expr#8=[IS NOT TRUE($t7)], SAL=[$t1], $condition=[$t8])\n-  EnumerableHashJoin(condition=[=($2, $3)], joinType=[left])\n-    EnumerableCalc(expr#0..7=[{inputs}], EMPNO=[$t0], SAL=[$t5], DEPTNO=[$t7])\n-      EnumerableTableScan(table=[[scott, EMP]])\n+  EnumerableMergeJoin(condition=[=($2, $3)], joinType=[left])", "originalCommit": "f8a6d2351557467ed835c90d53dc10b72e22d2d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI5OTM1OA==", "url": "https://github.com/apache/calcite/pull/2107#discussion_r474299358", "bodyText": "Agreed. In fact, I am actually thinking this is a case of wrong plan (more serious than a \"concern\"). Because for merge join implementation (not only Enumerables but other system's implementation), I think assuming sorted inputs is reasonable. So for systems that only use Calcite as a planner, they might see surprising plans", "author": "amaliujia", "createdAt": "2020-08-20T22:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwMTQxNQ==", "url": "https://github.com/apache/calcite/pull/2107#discussion_r474301415", "bodyText": "Top-down optimization could fix this problem though (which is not enabled by default). The top-down opt can enforce collations by inserting Sort.", "author": "amaliujia", "createdAt": "2020-08-20T22:13:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5MTI2NQ==", "url": "https://github.com/apache/calcite/pull/2107#discussion_r474691265", "bodyText": "I have looked in the debugger, and everything seems ok.\nIt seems that \"scott\" tables (like scott.emp and scott.dep in this example) are already sorted by default by their keys (their Scan operator contain already the trait Collation[0]).\nSince Collation[0] is the required collation for the right input of this EnumerableMergeJoin, there is no need to use a sort operator on the right. However, since the left input requires Collation[2], an EnumerableSort is required on the left.", "author": "rubenada", "createdAt": "2020-08-21T13:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1NzE3NA==", "url": "https://github.com/apache/calcite/pull/2107#discussion_r474857174", "bodyText": "Thanks for the investigation. So no sort on the right side is an optimization of Calcite (thus intended behavior). If so it is no longer a concern.", "author": "amaliujia", "createdAt": "2020-08-21T18:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NTAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwNDg1NA==", "url": "https://github.com/apache/calcite/pull/2107#discussion_r474304854", "bodyText": "Just an observation, looks like in many cases, Calcite believes merge join are better than hash join.", "author": "amaliujia", "createdAt": "2020-08-20T22:23:08Z", "path": "core/src/test/resources/sql/blank.iq", "diffHunk": "@@ -90,16 +90,20 @@ insert into table2 values (NULL, 1), (2, 1);\n !set lateDecorrelate true\n select i, j from table1 where table1.j NOT IN (select i from table2 where table1.i=table2.j);\n EnumerableCalc(expr#0..7=[{inputs}], expr#8=[0], expr#9=[=($t3, $t8)], expr#10=[IS NULL($t1)], expr#11=[IS NOT NULL($t7)], expr#12=[<($t4, $t3)], expr#13=[OR($t10, $t11, $t12)], expr#14=[IS NOT TRUE($t13)], expr#15=[OR($t9, $t14)], proj#0..1=[{exprs}], $condition=[$t15])\n-  EnumerableHashJoin(condition=[AND(=($0, $6), =($1, $5))], joinType=[left])\n-    EnumerableHashJoin(condition=[=($0, $2)], joinType=[left])\n-      EnumerableTableScan(table=[[BLANK, TABLE1]])\n-      EnumerableAggregate(group=[{1}], c=[COUNT()], ck=[COUNT($0)])\n-        EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NOT NULL($t1)], proj#0..1=[{exprs}], $condition=[$t2])\n-          EnumerableTableScan(table=[[BLANK, TABLE2]])\n-    EnumerableCalc(expr#0..1=[{inputs}], expr#2=[true], proj#0..2=[{exprs}])\n-      EnumerableAggregate(group=[{0, 1}])\n-        EnumerableCalc(expr#0..1=[{inputs}], expr#2=[IS NOT NULL($t1)], expr#3=[IS NOT NULL($t0)], expr#4=[AND($t2, $t3)], proj#0..1=[{exprs}], $condition=[$t4])\n-          EnumerableTableScan(table=[[BLANK, TABLE2]])\n+  EnumerableMergeJoin(condition=[AND(=($0, $6), =($1, $5))], joinType=[left])", "originalCommit": "f8a6d2351557467ed835c90d53dc10b72e22d2d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4NjU5MA==", "url": "https://github.com/apache/calcite/pull/2107#discussion_r474486590", "bodyText": "Yes, you are correct, that is the cost-based model decision (same thing happens already with INNER joins).", "author": "rubenada", "createdAt": "2020-08-21T07:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwNDg1NA=="}], "type": "inlineReview"}, {"oid": "0e4de2aca8a55d4ce2294088bf9a9022fb156d42", "url": "https://github.com/apache/calcite/commit/0e4de2aca8a55d4ce2294088bf9a9022fb156d42", "message": "[CALCITE-4113] Support LEFT join in EnumerableMergeJoin", "committedDate": "2020-08-24T07:07:59Z", "type": "commit"}, {"oid": "0e4de2aca8a55d4ce2294088bf9a9022fb156d42", "url": "https://github.com/apache/calcite/commit/0e4de2aca8a55d4ce2294088bf9a9022fb156d42", "message": "[CALCITE-4113] Support LEFT join in EnumerableMergeJoin", "committedDate": "2020-08-24T07:07:59Z", "type": "forcePushed"}]}