{"pr_number": 1918, "pr_title": "[CALCITE-3926] CannotPlanException when an empty LogicalValues requires a certain collation", "pr_createdAt": "2020-04-15T17:21:38Z", "pr_url": "https://github.com/apache/calcite/pull/1918", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409027990", "bodyText": "Not only sort, but all the operators can have the same issue.\nWe should update emptyValues to have the same traits with single. Just collation is not enough, should be all the traits.", "author": "hsyuan", "createdAt": "2020-04-15T17:54:49Z", "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "originalCommit": "d9a3b7da738bc63daac9eea38241e1ae72e0538b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzNzA1NQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409037055", "bodyText": "Maybe we should put the trait logic in RelBuilder#empty ?", "author": "rubenada", "createdAt": "2020-04-15T18:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0NDI2Mg==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409044262", "bodyText": "we can try. But if only empty() considers the trait logic, the other methods don't, that might look odd.", "author": "hsyuan", "createdAt": "2020-04-15T18:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA3MDA0NQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409070045", "bodyText": "Agree with @hsyuan . This trait replacement is a one-off thing just for PruneEmptyRule. I am not convinced it should be available in RelBuilder.", "author": "xndai", "createdAt": "2020-04-15T19:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1Mzg1Ng==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409353856", "bodyText": "Done. Trait propagation applied to all RemoveEmptySingleRule instances (AGGREGATE, FILTER, PROJECT, SORT) + SORT_FETCH_ZERO_INSTANCE.\nWhat about the rest of PruneEmptyRules (MINUS, UNION, INTERSECT, JOIN_LEFT, JOIN_RIGHT)?", "author": "rubenada", "createdAt": "2020-04-16T07:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MzUwMA==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410053500", "bodyText": "Propagating all traits does not seem a good solution. Right now there are some tests failing because of the following scenario: we have an enumerable single rel + logical empty values, so we replace the whole thing with an empty values (which in our case is a LogicalValues, as returned by RelBuilder#empty). If we try to propagate all traits it will fail, because we would be trying to propagate the EnumerableConvention towards a LogicalValues. So what should be our strategy here? Should we propagate all traits except the convention? Am I missing something in the trait propagation process?", "author": "rubenada", "createdAt": "2020-04-17T07:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzY0Ng==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410073646", "bodyText": "Moreover, what happens with e.g. Distribution? If we replace a SingleRel + EmptyValues = EmptyValues. Should the resulting EmptyValues have a values' distribution, or the SingleRel's distribution? What makes more sense?", "author": "rubenada", "createdAt": "2020-04-17T08:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDExMzMyNQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410113325", "bodyText": "I'm confused, EmptyValues has no data, so what's the meaning of collation and distribution on it ?", "author": "danny0405", "createdAt": "2020-04-17T09:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDEyOTU0Mw==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410129543", "bodyText": "Collation is required in order to solve this bug, since we are removing the Sort:\nSort + EmptyValues => EmptyValues\nif the resulting empty values does not have the sort's collation, we get a CannotPlanException. See https://issues.apache.org/jira/browse/CALCITE-3926 for more details.\nTherefore, in order to fix this problem it seems clear that we need to propagate the collation into the EmptyValues. Another discussion would be what about other traits, like distribution....", "author": "rubenada", "createdAt": "2020-04-17T10:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU0NTc5OA==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410545798", "bodyText": "Therefore, in order to fix this problem it seems clear that we need to propagate the collation into the EmptyValues.\n\nNot really from my side, to me, it seems that the traits check should be tweaked for EmptyValues, it should satisfy all the required traits, the EmptyValues itself does nothing wrong.", "author": "danny0405", "createdAt": "2020-04-18T01:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3NjEyNQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410676125", "bodyText": "Thanks an interesting approach @danny0405 . I guess we could tweak EmptyValues to satisfy any collation... will work on that", "author": "rubenada", "createdAt": "2020-04-18T09:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE5NDkxNg==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r411194916", "bodyText": "Unfortunately, I cannot find a clean way of tweaking EmptyValues' collation to satisfy any collation. Since propagating all traits into EmptyValues did not work either, I am going back to the original solution of propagating just collation into EmptyValues if we are removing a Sort from the plan.", "author": "rubenada", "createdAt": "2020-04-20T08:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODQxMw==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409028413", "bodyText": "Can you also compare the plan?", "author": "hsyuan", "createdAt": "2020-04-15T17:55:30Z", "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3426,4 +3426,24 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n             builder.literal(5));\n     assertThat(call.toStringRaw(), is(\"BETWEEN ASYMMETRIC($0, 1, 5)\"));\n   }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3926\">[CALCITE-3926]\n+   * CannotPlanException when an empty LogicalValues requires a certain collation</a>. */\n+  @Test void testEmptyValuesWithCollation() throws Exception {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder\n+            .scan(\"DEPT\")\n+            .filter(builder.literal(false))\n+            .sort(\n+                builder.field(\"DNAME\"),\n+                builder.field(\"DEPTNO\"))\n+            .build();\n+    try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n+      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String result = \"\";\n+      assertThat(s, is(result));", "originalCommit": "d9a3b7da738bc63daac9eea38241e1ae72e0538b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MDEyNw==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409350127", "bodyText": "Done", "author": "rubenada", "createdAt": "2020-04-16T07:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1NzE0MA==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409357140", "bodyText": "I mean the final plan generated by planner, not by the RelBuilder.", "author": "hsyuan", "createdAt": "2020-04-16T07:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1NDU2Mg==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409054562", "bodyText": "Instead of doing this, can we just modify copy(traitset, inputs) method to just return new EnumerableValues(getCluster(), rowType, tuples, traitSet);?", "author": "hsyuan", "createdAt": "2020-04-15T18:40:24Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "diffHunk": "@@ -65,6 +65,19 @@ public static EnumerableValues create(RelOptCluster cluster,\n     return new EnumerableValues(cluster, rowType, tuples, traitSet);\n   }\n \n+  /** Creates an EnumerableValues. */\n+  public static EnumerableValues create(Values input) {\n+    final RelOptCluster cluster = input.getCluster();\n+    final ImmutableList<ImmutableList<RexLiteral>> tuples = input.getTuples();\n+    final RelDataType rowType = input.getRowType();\n+    final RelTraitSet traitSet =\n+        input.getTraitSet()\n+            .replace(EnumerableConvention.INSTANCE)\n+            .replaceIf(RelDistributionTraitDef.INSTANCE,\n+                () -> RelMdDistribution.values(rowType, tuples));\n+    return new EnumerableValues(cluster, rowType, tuples, traitSet);\n+  }", "originalCommit": "d9a3b7da738bc63daac9eea38241e1ae72e0538b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409351678", "bodyText": "This is not expected. That means the rule or something else doesn't work.", "author": "hsyuan", "createdAt": "2020-04-16T07:50:41Z", "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3440,10 +3440,14 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n                 builder.field(\"DNAME\"),\n                 builder.field(\"DEPTNO\"))\n             .build();\n+    final String expectedTree = \"\"\n+        + \"LogicalSort(sort0=[$1], sort1=[$0], dir0=[ASC], dir1=[ASC])\\n\"\n+        + \"  LogicalValues(tuples=[[]])\\n\";\n+    assertThat(root, hasTree(expectedTree));\n     try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n-      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n-      final String result = \"\";\n-      assertThat(s, is(result));\n+      final String result = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String expectedResult = \"\";\n+      assertThat(result, is(expectedResult));", "originalCommit": "468911f1df6a960a8498115bda6d17a797aa99e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1NTI2Mw==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409355263", "bodyText": "I mean the expected plan should not have sort operator.", "author": "hsyuan", "createdAt": "2020-04-16T07:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM4ODA4Mg==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409388082", "bodyText": "This is the expected plan built by the RelBuilder, before any PruneEmptyRules is applied.", "author": "rubenada", "createdAt": "2020-04-16T08:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgwODI3NQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409808275", "bodyText": "I guess we only care about plan generated by planner, not the builder.", "author": "hsyuan", "createdAt": "2020-04-16T19:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg3NDI1OQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409874259", "bodyText": "OK, I found that it is not able to compare the final plan here.", "author": "hsyuan", "createdAt": "2020-04-16T22:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0Njk1Nw==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410046957", "bodyText": "I added another test in RelOptRulesTest to check the plan before and after the rule is applied", "author": "rubenada", "createdAt": "2020-04-17T07:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MjUxNg==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409352516", "bodyText": "If you change PruneEmptyRule's autoPruneOld to false, you might be able to see another error.", "author": "hsyuan", "createdAt": "2020-04-16T07:52:03Z", "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -402,12 +404,8 @@ private static boolean isEmpty(RelNode node) {\n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n       RelNode emptyValues = call.builder().push(single).empty().build();\n-      if (single instanceof Sort) {\n-        emptyValues = emptyValues.copy(\n-            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n-            Collections.emptyList());\n-      }\n-      call.transformTo(emptyValues);\n+      RelNode result = emptyValues.copy(single.getTraitSet(), Collections.emptyList());", "originalCommit": "468911f1df6a960a8498115bda6d17a797aa99e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM3MDQ0Ng==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409370446", "bodyText": "That's rigth, in that case I get:\njava.lang.AssertionError\n\tat org.apache.calcite.rel.logical.LogicalValues.copy(LogicalValues.java:95)\n\nWhich refers to the following line:\n@Override public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {\n    assert traitSet.containsIfApplicable(Convention.NONE);  // <--\n    ...", "author": "rubenada", "createdAt": "2020-04-16T08:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MjUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxMzYzNg==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409413636", "bodyText": "Actually, we can solve the problem with a different approach, and it would take just one line of code, which is returning false in PruneEmptyRule's autoPruneOld (or just remove the method to not override the default SubstitutionRule's behavior):\n  protected abstract static class PruneEmptyRule extends RelOptRule\n      implements SubstitutionRule {\n    ...\n    @Override public boolean autoPruneOld() {\n      return false; // this solves the problem!\n    }\n  }", "author": "rubenada", "createdAt": "2020-04-16T09:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MjUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgxMDI4OQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409810289", "bodyText": "It will just hide the issue of the rule. We still get a sort in the plan.", "author": "hsyuan", "createdAt": "2020-04-16T19:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MjUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MzQ4OA==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410053488", "bodyText": "Always use create instead of new directly.", "author": "danny0405", "createdAt": "2020-04-17T07:53:32Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "diffHunk": "@@ -46,7 +46,7 @@\n  * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}. */\n public class EnumerableValues extends Values implements EnumerableRel {\n   /** Creates an EnumerableValues. */\n-  private EnumerableValues(RelOptCluster cluster, RelDataType rowType,\n+  EnumerableValues(RelOptCluster cluster, RelDataType rowType,\n       ImmutableList<ImmutableList<RexLiteral>> tuples, RelTraitSet traitSet) {", "originalCommit": "52fcec7eb089e34dca2332b74fa31ecdf3a95800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1NTc4MQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410055781", "bodyText": "Agree, calling directly the constructor is generally an anti-pattern. The problem here is that, in order to solve this bug, we need to propagate the traitSet from the LogicalValues to the EnumerableValues, at right now this is not possible via create method. I could define a new overloaded create method (I had done it previously in this PR and then removed it).", "author": "rubenada", "createdAt": "2020-04-17T07:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MzQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDU4MQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410074581", "bodyText": "Changed back: constructor is private again.", "author": "rubenada", "createdAt": "2020-04-17T08:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MzQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2Nzc2NQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417867765", "bodyText": "How about we modify the other create to support an explicit traitSet param ?", "author": "danny0405", "createdAt": "2020-04-30T09:10:57Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "diffHunk": "@@ -65,9 +65,20 @@ public static EnumerableValues create(RelOptCluster cluster,\n     return new EnumerableValues(cluster, rowType, tuples, traitSet);\n   }\n \n+  /** Creates an EnumerableValues. */\n+  public static EnumerableValues create(Values input) {\n+    final RelOptCluster cluster = input.getCluster();", "originalCommit": "826af564c8160bc1b5558a6518eeb64a374215c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg3OTkxMg==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417879912", "bodyText": "I think the copy method should be handling that scenario", "author": "rubenada", "createdAt": "2020-04-30T09:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2Nzc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2OTYzMQ==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417869631", "bodyText": "Why only copy the Collation trait ?", "author": "danny0405", "createdAt": "2020-04-30T09:14:08Z", "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -277,7 +278,11 @@ private static boolean isEmpty(RelNode node) {\n           if (sort.fetch != null\n               && !(sort.fetch instanceof RexDynamicParam)\n               && RexLiteral.intValue(sort.fetch) == 0) {\n-            call.transformTo(call.builder().push(sort).empty().build());\n+            RelNode emptyValues = call.builder().push(sort).empty().build();\n+            emptyValues = emptyValues.copy(\n+                emptyValues.getTraitSet().replace(sort.getCollation()),\n+                Collections.emptyList());", "originalCommit": "826af564c8160bc1b5558a6518eeb64a374215c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg3NzQyNw==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417877427", "bodyText": "The (non propagation of) Collation trait is the root cause of this issue. So propagating just the Collation seems the easiest way to fix this bug (but arguably maybe not the \"most correct\" one).\nPreviously, I tried to propagate other traits as well, but it did not work as expected:\nPropagating all traits does not seem a good solution. [...] there are some tests failing because of the following scenario: we have an enumerable single rel + logical empty values, so we replace the whole thing with an empty values (which in our case is a LogicalValues, as returned by RelBuilder#empty). If we try to propagate all traits it will fail, because we would be trying to propagate the EnumerableConvention towards a LogicalValues. So what should be our strategy here? Should we propagate all traits except the convention? Am I missing something in the trait propagation process?", "author": "rubenada", "createdAt": "2020-04-30T09:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2OTYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg5NDMyNA==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417894324", "bodyText": "Thanks @rubenada , i have gave a fix in [1] based on your code, hope it helps ~\n[1] https://github.com/danny0405/calcite/tree/rubenada-CALCITE-3926", "author": "danny0405", "createdAt": "2020-04-30T09:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2OTYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkwNTkxOA==", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417905918", "bodyText": "Thanks @danny0405 , I have added a comment in there.", "author": "rubenada", "createdAt": "2020-04-30T10:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2OTYzMQ=="}], "type": "inlineReview"}, {"oid": "e7b7c7e3c390d8c5aae449eb2cd40d1cde97a7a7", "url": "https://github.com/apache/calcite/commit/e7b7c7e3c390d8c5aae449eb2cd40d1cde97a7a7", "message": "[CALCITE-3926] CannotPlanException when an empty LogicalValues requires a certain collation", "committedDate": "2020-05-06T07:27:09Z", "type": "commit"}, {"oid": "e7b7c7e3c390d8c5aae449eb2cd40d1cde97a7a7", "url": "https://github.com/apache/calcite/commit/e7b7c7e3c390d8c5aae449eb2cd40d1cde97a7a7", "message": "[CALCITE-3926] CannotPlanException when an empty LogicalValues requires a certain collation", "committedDate": "2020-05-06T07:27:09Z", "type": "forcePushed"}]}