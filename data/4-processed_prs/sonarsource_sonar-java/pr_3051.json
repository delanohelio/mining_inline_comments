{"pr_number": 3051, "pr_title": "SONARJAVA-3422 RSPEC-5860 Names of regular expressions named groups should be used", "pr_createdAt": "2020-06-22T12:33:30Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3051", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMzg2MA==", "url": "https://github.com/SonarSource/sonar-java/pull/3051#discussion_r443613860", "bodyText": "This seems like a good opportunity to re-introduce the RegexBaseVisitor.before method and use that instead of the constructor to set target. That way you don't have to pass the regex to both the constructor and the visit method.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-06-22T14:46:37Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/UnusedGroupNamesCheck.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.model.ExpressionUtils;\n+import org.sonar.java.regex.RegexCheck;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.BackReferenceTree;\n+import org.sonar.java.regex.ast.CapturingGroupTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.java.regex.ast.RegexTree;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.ReturnStatementTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5860\")\n+public class UnusedGroupNamesCheck extends AbstractRegexCheck {\n+\n+  private static final String ISSUE_NO_GROUP_WITH_SUCH_NAME = \"There is no group named '%s' in the regular expression.\";\n+  private static final String ISSUE_USE_NAME_INSTEAD_OF_NUMBER = \"Directly use '%s' instead of its group number.\";\n+  private static final String ISSUE_USE_GROUPS_OR_REMOVE = \"Use the named groups of this regex or remove the names.\";\n+\n+  private static final String JAVA_UTIL_REGEX_PATTERN = \"java.util.regex.Pattern\";\n+  private static final String JAVA_UTIL_REGEX_MATCHER = \"java.util.regex.Matcher\";\n+\n+  private static final MethodMatchers PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\n+      JAVA_UTIL_REGEX_PATTERN)\n+    .names(\"matcher\")\n+    .addParametersMatcher(\"java.lang.CharSequence\")\n+    .build();\n+  private static final MethodMatchers MATCHER_GROUP = MethodMatchers.create()\n+    .ofTypes(\n+      JAVA_UTIL_REGEX_MATCHER)\n+    .names(\"group\")\n+    // covers both 'group(String)' and 'group(int)'\n+    .addParametersMatcher(JAVA_LANG_STRING)\n+    .addParametersMatcher(\"int\")\n+    .build();\n+\n+  private final Map<Symbol.VariableSymbol, KnownGroupsCollector> knownPatternsWithGroups = new HashMap<>();\n+  private final Map<Symbol.VariableSymbol, Symbol.VariableSymbol> matcherToPattern = new HashMap<>();\n+\n+  private final Set<Symbol.VariableSymbol> returnedVariables = new HashSet<>();\n+  private final Set<RegexTree> usedGroupsRegexes = new HashSet<>();\n+\n+  @Override\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    // extends default regex methods with matcher-related methods\n+    return MethodMatchers.or(REGEX_METHODS, PATTERN_MATCHER, MATCHER_GROUP);\n+  }\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    List<Tree.Kind> nodes = new ArrayList<>(super.nodesToVisit());\n+    // visit more nodes than method invocations\n+    nodes.add(Tree.Kind.COMPILATION_UNIT);\n+    nodes.add(Tree.Kind.RETURN_STATEMENT);\n+    return nodes;\n+  }\n+\n+  @Override\n+  public void leaveNode(Tree tree) {\n+    if (tree.is(Tree.Kind.RETURN_STATEMENT)) {\n+      collectReturnedVariables(((ReturnStatementTree) tree).expression());\n+    } else if (tree.is(Tree.Kind.COMPILATION_UNIT)) {\n+      checkNotUsingAnyNamedGroup();\n+\n+      // clear all the structures used during analysis to start fresh in next file\n+      knownPatternsWithGroups.clear();\n+      matcherToPattern.clear();\n+      usedGroupsRegexes.clear();\n+      returnedVariables.clear();\n+    }\n+  }\n+\n+  private void collectReturnedVariables(@Nullable ExpressionTree returnedExpression) {\n+    if (returnedExpression == null || !returnedExpression.is(Tree.Kind.IDENTIFIER)) {\n+      return;\n+    }\n+    Symbol returnedSymbol = ((IdentifierTree) returnedExpression).symbol();\n+    if (!isPrivateVariable(returnedSymbol)) {\n+      return;\n+    }\n+    Type returnedType = returnedSymbol.type();\n+    if (returnedType.is(JAVA_UTIL_REGEX_MATCHER) || returnedType.is(JAVA_UTIL_REGEX_PATTERN)) {\n+      returnedVariables.add((Symbol.VariableSymbol) returnedSymbol);\n+    }\n+  }\n+\n+  private static boolean isPrivateVariable(Symbol returnedSymbol) {\n+    return (returnedSymbol.isPrivate() || returnedSymbol.owner().isMethodSymbol()) && returnedSymbol.isVariableSymbol();\n+  }\n+\n+  private void checkNotUsingAnyNamedGroup() {\n+    knownPatternsWithGroups.entrySet().stream()\n+      .filter(e -> isNotReturned(e.getKey()))\n+      .map(Map.Entry::getValue)\n+      .filter(this::isNotCallingGroups)\n+      .filter(UnusedGroupNamesCheck::isNotUsingBackReferences)\n+      .forEach(knownGroups -> {\n+        List<CapturingGroupTree> namedGroups = new ArrayList<>(knownGroups.groupsByName.values());\n+        List<RegexIssueLocation> secondaries = namedGroups.stream()\n+          .map(group -> toLocation(group, \"Named group '%s'\", g -> g.getName().get()))\n+          .collect(Collectors.toList());\n+        reportIssue(namedGroups.get(0), ISSUE_USE_GROUPS_OR_REMOVE, null, secondaries);\n+      });\n+  }\n+\n+  private boolean isNotReturned(Symbol.VariableSymbol regex) {\n+    if (returnedVariables.contains(regex)) {\n+      // a known pattern is returned\n+      return false;\n+    }\n+    return matcherToPattern.entrySet().stream()\n+      // a known matcher associated with a known pattern is returned\n+      .noneMatch(e -> returnedVariables.contains(e.getKey()) && e.getValue().equals(regex));\n+  }\n+\n+  private boolean isNotCallingGroups(KnownGroupsCollector knownGroups) {\n+    return !usedGroupsRegexes.contains(knownGroups.target);\n+  }\n+\n+  private static boolean isNotUsingBackReferences(KnownGroupsCollector knownGroups) {\n+    // kill the noise\n+    return !knownGroups.usesBackReferences;\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    String methodName = mit.symbol().name();\n+    if (PATTERN_MATCHER.matches(mit)) {\n+      collectPattern(mit);\n+    } else if (MATCHER_GROUP.matches(mit)) {\n+      checkGroupUsage(mit);\n+    } else if (\"compile\".equals(methodName)) {\n+      // only interested in compiled patterns\n+      super.onMethodInvocationFound(mit);\n+    }\n+  }\n+\n+  private void collectPattern(MethodInvocationTree mit) {\n+    for (Symbol.VariableSymbol knownPattern : knownPatternsWithGroups.keySet()) {\n+      if (ExpressionUtils.isInvocationOnVariable(mit, knownPattern, false)) {\n+        getAssignedPrivateVariable(mit).ifPresent(knownMatcher -> matcherToPattern.put(knownMatcher, knownPattern));\n+        break;\n+      }\n+    }\n+  }\n+\n+  private void checkGroupUsage(MethodInvocationTree mit) {\n+    matcherToPattern.forEach((knownMatcher, knownPattern) -> {\n+      if (!ExpressionUtils.isInvocationOnVariable(mit, knownMatcher, false)) {\n+        return;\n+      }\n+      KnownGroupsCollector knownGroups = knownPatternsWithGroups.get(knownPattern);\n+      usedGroupsRegexes.add(knownGroups.target);\n+      ExpressionTree arg0 = mit.arguments().get(0);\n+      Type arg0Type = arg0.symbolType();\n+      if (arg0Type.is(\"int\")) {\n+        checkUsingNumberInsteadOfName(knownGroups, arg0);\n+      } else if (arg0Type.is(JAVA_LANG_STRING)) {\n+        checkNoSuchName(knownGroups, arg0);\n+      }\n+    });\n+  }\n+\n+  private void checkUsingNumberInsteadOfName(KnownGroupsCollector knownGroups, ExpressionTree arg0) {\n+    Optional<Integer> groupNumber = arg0.asConstant(Integer.class);\n+    if (!groupNumber.isPresent()) {\n+      return;\n+    }\n+    Integer groupNumberValue = groupNumber.get();\n+    CapturingGroupTree capturingGroupTree = knownGroups.groupsByNumber.get(groupNumberValue);\n+    if (capturingGroupTree == null) {\n+      return;\n+    }\n+    String message = String.format(ISSUE_USE_NAME_INSTEAD_OF_NUMBER, capturingGroupTree.getName().orElse(\"?\"));\n+    RegexIssueLocation secondary = toLocation(capturingGroupTree, \"Group %d\", g -> groupNumberValue);\n+    reportIssue(arg0, message, null, Collections.singletonList(secondary));\n+  }\n+\n+  private void checkNoSuchName(KnownGroupsCollector knownGroups, ExpressionTree arg0) {\n+    Optional<String> groupName = arg0.asConstant(String.class);\n+    if (!groupName.isPresent()) {\n+      return;\n+    }\n+    String groupNameValue = groupName.get();\n+    if (!knownGroups.groupsByName.keySet().contains(groupNameValue)) {\n+      String message = String.format(ISSUE_NO_GROUP_WITH_SUCH_NAME, groupNameValue);\n+      List<RegexIssueLocation> secondaries = knownGroups.groupsByName.values()\n+        .stream()\n+        .map(group -> toLocation(group, \"Named group '%s'\", g -> g.getName().get()))\n+        .collect(Collectors.toList());\n+      reportIssue(arg0, message, null, secondaries);\n+    }\n+  }\n+\n+  private static RegexCheck.RegexIssueLocation toLocation(CapturingGroupTree group, String message, Function<CapturingGroupTree, Object> arg) {\n+    return new RegexCheck.RegexIssueLocation(group, String.format(message, arg.apply(group)));\n+  }\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    getAssignedPrivateVariable(mit)\n+      .ifPresent(variableSymbol -> collectGroups(regexForLiterals)\n+        .ifPresent(knownGroups -> knownPatternsWithGroups.put(variableSymbol, knownGroups)));\n+  }\n+\n+  private static Optional<Symbol.VariableSymbol> getAssignedPrivateVariable(MethodInvocationTree mit) {\n+    Tree parent = mit.parent();\n+    if (parent.is(Tree.Kind.VARIABLE)) {\n+      Symbol variableSymbol = ((VariableTree) parent).symbol();\n+      if (isPrivateVariable(variableSymbol)) {\n+        return Optional.of((Symbol.VariableSymbol) variableSymbol);\n+      }\n+    }\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<KnownGroupsCollector> collectGroups(RegexParseResult regex) {\n+    KnownGroupsCollector visitor = new KnownGroupsCollector(regex);\n+    visitor.visit(regex);\n+    if (!visitor.groupsByName.isEmpty()) {\n+      return Optional.of(visitor);\n+    }\n+    return Optional.empty();\n+  }\n+\n+  private static class KnownGroupsCollector extends RegexBaseVisitor {\n+\n+    private final RegexTree target;\n+    private Map<String, CapturingGroupTree> groupsByName = new HashMap<>();\n+    private Map<Integer, CapturingGroupTree> groupsByNumber = new HashMap<>();\n+    private boolean usesBackReferences = false;\n+\n+    public KnownGroupsCollector(RegexParseResult regex) {", "originalCommit": "e59404e921ec6f4bac966e69543bfd34718dcadb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYzNzg3MA==", "url": "https://github.com/SonarSource/sonar-java/pull/3051#discussion_r443637870", "bodyText": "Damn, you are right... I'll re-introduce it then. :)", "author": "m-g-sonar", "createdAt": "2020-06-22T15:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMzg2MA=="}], "type": "inlineReview"}, {"oid": "2cd13594eee951a50142ebfaab9a1cf2d8697326", "url": "https://github.com/SonarSource/sonar-java/commit/2cd13594eee951a50142ebfaab9a1cf2d8697326", "message": "SONARJAVA-3422 RSPEC-5860 Names of regular expressions named groups should be used", "committedDate": "2020-06-23T07:11:31Z", "type": "forcePushed"}, {"oid": "71c731dc63b994c1b07a16913cd68f5d04963b78", "url": "https://github.com/SonarSource/sonar-java/commit/71c731dc63b994c1b07a16913cd68f5d04963b78", "message": "[REGEX] Add before() method in RegexBaseVisitor", "committedDate": "2020-06-23T07:28:09Z", "type": "commit"}, {"oid": "a5d5bfc4a43e307c799c0ee45b4ff0e61887f63b", "url": "https://github.com/SonarSource/sonar-java/commit/a5d5bfc4a43e307c799c0ee45b4ff0e61887f63b", "message": "SONARJAVA-3422 RSPEC-5860 Names of regular expressions named groups should be used", "committedDate": "2020-06-23T07:28:09Z", "type": "commit"}, {"oid": "a5d5bfc4a43e307c799c0ee45b4ff0e61887f63b", "url": "https://github.com/SonarSource/sonar-java/commit/a5d5bfc4a43e307c799c0ee45b4ff0e61887f63b", "message": "SONARJAVA-3422 RSPEC-5860 Names of regular expressions named groups should be used", "committedDate": "2020-06-23T07:28:09Z", "type": "forcePushed"}]}