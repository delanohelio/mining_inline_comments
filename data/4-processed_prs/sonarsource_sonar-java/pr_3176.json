{"pr_number": 3176, "pr_title": "SONARJAVA-3513 Improve S5810 to support static and test methods with return values", "pr_createdAt": "2020-09-14T12:13:08Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3176", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDA4OA==", "url": "https://github.com/SonarSource/sonar-java/pull/3176#discussion_r488040088", "bodyText": "In addition to removing hasSemantic() check, you can also remove this test.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-14T15:50:15Z", "path": "java-checks/src/test/java/org/sonar/java/checks/tests/JUnit5DefaultPackageClassAndMethodCheckTest.java", "diffHunk": "@@ -34,7 +34,10 @@ void test() {\n       .onFile(testSourcePath)\n       .withCheck(new JUnit5DefaultPackageClassAndMethodCheck())\n       .verifyIssues();\n+  }\n \n+  @Test\n+  void test_without_semantic() {", "originalCommit": "7bae5061155923a469545c46d1bafccf36fbc3dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcwNDkxNw==", "url": "https://github.com/SonarSource/sonar-java/pull/3176#discussion_r488704917", "bodyText": "Nope. Even if we remove the hasSemantic() check, we still want to check how the rule implementation behaves with a lot of unknown symbols. So .withoutSemantic() is still useful. #UnknownSymbolsMatter", "author": "alban-auzeill", "createdAt": "2020-09-15T14:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDI3Mw==", "url": "https://github.com/SonarSource/sonar-java/pull/3176#discussion_r488040273", "bodyText": "Same here, you can remove it.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-14T15:50:34Z", "path": "java-checks/src/test/java/org/sonar/java/checks/tests/JUnit5SilentlyIgnoreClassAndMethodCheckTest.java", "diffHunk": "@@ -22,24 +22,36 @@\n import org.junit.jupiter.api.Test;\n import org.sonar.java.checks.verifier.JavaCheckVerifier;\n \n+import static org.sonar.java.CheckTestUtils.nonCompilingTestSourcesPath;\n import static org.sonar.java.CheckTestUtils.testSourcesPath;\n \n-class JUnit5PrivateClassAndMethodCheckTest {\n+class JUnit5SilentlyIgnoreClassAndMethodCheckTest {\n \n-  private static final String testSourcePath = testSourcesPath(\"checks/JUnit5PrivateClassAndMethodCheck.java\");\n+  private static final String SOURCE_PATH = \"checks/JUnit5SilentlyIgnoreClassAndMethodCheck.java\";\n \n   @Test\n   void test() {\n     JavaCheckVerifier.newVerifier()\n-      .onFile(testSourcePath)\n-      .withCheck(new JUnit5PrivateClassAndMethodCheck())\n+      .onFile(testSourcesPath(SOURCE_PATH))\n+      .withCheck(new JUnit5SilentlyIgnoreClassAndMethodCheck())\n       .verifyIssues();\n+  }\n \n+  @Test\n+  void test_without_semantic() {", "originalCommit": "7bae5061155923a469545c46d1bafccf36fbc3dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcwNTMxMQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3176#discussion_r488705311", "bodyText": "See above #UnknownSymbolsMatter comment.", "author": "alban-auzeill", "createdAt": "2020-09-15T14:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA2MjAxOA==", "url": "https://github.com/SonarSource/sonar-java/pull/3176#discussion_r488062018", "bodyText": "I understand that you wanted to follow the same pattern as raiseIssueOnNotCompliantModifiers, but this code can report an issue only in one of the children, does it make sense to keep it in the common part?", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-14T16:22:57Z", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/AbstractJUnit5NotCompliantModifierChecker.java", "diffHunk": "@@ -24,45 +24,56 @@\n import java.util.stream.Collectors;\n import org.sonar.java.checks.helpers.UnitTestUtils;\n import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.Symbol.MethodSymbol;\n import org.sonar.plugins.java.api.tree.ClassTree;\n import org.sonar.plugins.java.api.tree.MethodTree;\n import org.sonar.plugins.java.api.tree.Modifier;\n import org.sonar.plugins.java.api.tree.ModifiersTree;\n import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TypeTree;\n \n public abstract class AbstractJUnit5NotCompliantModifierChecker extends IssuableSubscriptionVisitor {\n \n-  protected abstract boolean isNotCompliant(Modifier modifier);\n+  protected abstract boolean isNotCompliantModifier(Modifier modifier, boolean isMethod);\n+\n+  protected abstract boolean isNotCompliantReturnType(TypeTree returnType, MethodSymbol symbol);\n \n   public List<Tree.Kind> nodesToVisit() {\n     return Collections.singletonList(Tree.Kind.CLASS);\n   }\n \n   @Override\n   public void visitNode(Tree tree) {\n-    if (!hasSemantic()) {\n-      return;\n-    }\n-\n     ClassTree classTree = (ClassTree) tree;\n     List<MethodTree> testMethods = classTree.members().stream()\n       .filter(member -> member.is(Tree.Kind.METHOD))\n       .map(MethodTree.class::cast)\n       .filter(UnitTestUtils::hasJUnit5TestAnnotation)\n       .collect(Collectors.toList());\n \n-    testMethods.stream().map(MethodTree::modifiers).forEach(this::raiseIssueOnNotCompliantModifiers);\n+    for (MethodTree testMethod : testMethods) {\n+      raiseIssueOnNotCompliantModifiers(testMethod.modifiers(), true);\n+      raiseIssueOnNotCompliantReturnType(testMethod);\n+    }\n \n     if (!testMethods.isEmpty()) {\n-      raiseIssueOnNotCompliantModifiers(classTree.modifiers());\n+      raiseIssueOnNotCompliantModifiers(classTree.modifiers(), false);\n     }\n   }\n \n-  private void raiseIssueOnNotCompliantModifiers(ModifiersTree modifierTree) {\n+  private void raiseIssueOnNotCompliantModifiers(ModifiersTree modifierTree, boolean isMethod) {\n     modifierTree.modifiers().stream()\n-      .filter(modifier -> isNotCompliant(modifier.modifier()))\n+      .filter(modifier -> isNotCompliantModifier(modifier.modifier(), isMethod))\n       .findFirst()\n       .ifPresent(modifier -> reportIssue(modifier, \"Remove this '\" + modifier.keyword().text() + \"' modifier.\"));\n   }\n \n+  private void raiseIssueOnNotCompliantReturnType(MethodTree methodTree) {\n+    // Return type of METHOD is never null (unlike CONSTRUCTOR)\n+    TypeTree returnType = methodTree.returnType();\n+    if (isNotCompliantReturnType(returnType, methodTree.symbol())) {", "originalCommit": "7bae5061155923a469545c46d1bafccf36fbc3dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "872799ca5ca218c01fec7834ade907b27ac20f73", "url": "https://github.com/SonarSource/sonar-java/commit/872799ca5ca218c01fec7834ade907b27ac20f73", "message": "Inline raiseIssueOnNotCompliantReturnType", "committedDate": "2020-09-15T12:43:29Z", "type": "forcePushed"}, {"oid": "548449bba2977c3c1b47206e45098ae3b45c34a4", "url": "https://github.com/SonarSource/sonar-java/commit/548449bba2977c3c1b47206e45098ae3b45c34a4", "message": "SONARJAVA-3513 Improve S5810 to support static and test methods with return values", "committedDate": "2020-09-15T14:21:35Z", "type": "commit"}, {"oid": "dbccdb04e8b29f9013c7c7af4be7d9c657474a29", "url": "https://github.com/SonarSource/sonar-java/commit/dbccdb04e8b29f9013c7c7af4be7d9c657474a29", "message": "Replace isNotCompliantReturnType by raiseIssueOnNotCompliantReturnType", "committedDate": "2020-09-15T14:21:35Z", "type": "commit"}, {"oid": "dbccdb04e8b29f9013c7c7af4be7d9c657474a29", "url": "https://github.com/SonarSource/sonar-java/commit/dbccdb04e8b29f9013c7c7af4be7d9c657474a29", "message": "Replace isNotCompliantReturnType by raiseIssueOnNotCompliantReturnType", "committedDate": "2020-09-15T14:21:35Z", "type": "forcePushed"}]}