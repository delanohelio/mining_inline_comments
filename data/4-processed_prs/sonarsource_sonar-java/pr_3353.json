{"pr_number": 3353, "pr_title": "SONARJAVA-3467 FP on S1948 when using both field and setter/constructor injection", "pr_createdAt": "2020-12-15T14:59:06Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3353", "timeline": [{"oid": "af30b8f864f046ed68d6d1c4d52281c25148e531", "url": "https://github.com/SonarSource/sonar-java/commit/af30b8f864f046ed68d6d1c4d52281c25148e531", "message": "WIP", "committedDate": "2020-12-15T15:04:09Z", "type": "forcePushed"}, {"oid": "9eb9b81a65992db634a2a2ffb0620d72c79e8120", "url": "https://github.com/SonarSource/sonar-java/commit/9eb9b81a65992db634a2a2ffb0620d72c79e8120", "message": "SONARJAVA-3467 FP on S1948 when using both field and setter/constructor injection", "committedDate": "2020-12-15T15:24:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ0NDcyMg==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r543444722", "bodyText": "Without semantic this annotation won't be found. So this line protects of FPs in case of incomplete semantic., the same check is done in line 179", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-12-15T15:28:10Z", "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,14 +60,46 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+      \n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+      \n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)\n+        .filter(variableTree -> \n+          !(constructorInjectedParams.contains(variableTree.simpleName().name()) ||\n+            setterInjectedParams.contains(variableTree.simpleName().name())))\n+        .forEach(this::checkVariableMember);\n     }\n   }\n \n+  private static Set<String> getSetterInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .map(methodTree -> methodTree.simpleName().name())\n+      .filter(name -> name.startsWith(\"set\"))\n+      .map(name -> name.substring(3).toLowerCase(Locale.ROOT))\n+      .collect(Collectors.toSet());\n+  }\n+\n+  private static Set<String> getConstructorInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .flatMap(methodTree -> methodTree.parameters().stream())\n+      .map(variableTree -> variableTree.simpleName().name())\n+      .collect(Collectors.toSet());\n+  }\n+\n+  private static boolean isAnnotatedWithInject(MethodTree methodTree) {\n+    return methodTree.symbol().metadata().isAnnotatedWith(JAVAX_INJECT)\n+      || methodTree.symbol().metadata().annotations().stream().anyMatch(annotation -> annotation.symbol().isUnknown());", "originalCommit": "9eb9b81a65992db634a2a2ffb0620d72c79e8120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "url": "https://github.com/SonarSource/sonar-java/commit/4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "message": "SONARJAVA-3467 FP on S1948 when using both field and setter/constructor injection", "committedDate": "2020-12-15T15:30:14Z", "type": "commit"}, {"oid": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "url": "https://github.com/SonarSource/sonar-java/commit/4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "message": "SONARJAVA-3467 FP on S1948 when using both field and setter/constructor injection", "committedDate": "2020-12-15T15:30:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzNjQzNQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544136435", "bodyText": "We are doing a first filtering here, and then a second in checkVariableMember thanks to isExcluded. We could move the second filtering here.\nIt will avoid having the differents kind of injections being filtered at two different places.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-12-16T09:19:37Z", "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,14 +60,46 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+      \n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+      \n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)\n+        .filter(variableTree -> ", "originalCommit": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE0NTk5Mg==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544145992", "bodyText": "isAnnotatedWith will go through all annotations, so with this code, you end up going through the list 4 times when the field is not annotated by any of the annotations (which I expect to be the most frequent case). We could do everything in one shot, without using isAnnotatedWith.\nThe same happens in isAnnotatedWithInject.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-12-16T09:33:10Z", "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -135,10 +173,14 @@ private static boolean isTransientSerializableOrInjected(VariableTree member) {\n       return true;\n     }\n     SymbolMetadata metadata = member.symbol().metadata();\n-    return metadata.isAnnotatedWith(\"javax.inject.Inject\")\n+    return metadata.isAnnotatedWith(JAVAX_INJECT)\n       || metadata.isAnnotatedWith(\"javax.ejb.EJB\")\n       || metadata.isAnnotatedWith(\"org.apache.wicket.spring.injection.annot.SpringBean\")\n-      || metadata.annotations().stream().anyMatch(annotation -> annotation.symbol().isUnknown());\n+      || hasAnnotationsWithIncompleteSemantic(metadata);", "originalCommit": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1Njk5Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544156996", "bodyText": "I'm wondering if we can really rely on the naming of parameters here. As an example, we will not support the example described in the ticket.\nWhat is your opinion on it?", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-12-16T09:48:29Z", "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,14 +60,46 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+      \n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+      \n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)\n+        .filter(variableTree -> \n+          !(constructorInjectedParams.contains(variableTree.simpleName().name()) ||\n+            setterInjectedParams.contains(variableTree.simpleName().name())))\n+        .forEach(this::checkVariableMember);\n     }\n   }\n \n+  private static Set<String> getSetterInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .map(methodTree -> methodTree.simpleName().name())\n+      .filter(name -> name.startsWith(\"set\"))\n+      .map(name -> name.substring(3).toLowerCase(Locale.ROOT))\n+      .collect(Collectors.toSet());\n+  }\n+\n+  private static Set<String> getConstructorInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))\n+      .map(MethodTree.class::cast)\n+      .filter(SerializableFieldInSerializableClassCheck::isAnnotatedWithInject)\n+      .flatMap(methodTree -> methodTree.parameters().stream())\n+      .map(variableTree -> variableTree.simpleName().name())", "originalCommit": "4fbae0ad6ef92e06955524ea78ec9adb055eddd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI4MTI4OQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544281289", "bodyText": "Yes, that's true. I was just thinking what would be a better option.\nSo I changed the logic here to check assignments inside the constructor, and exclude fields that are assigned values inside constructor annotated with @Inject.\nWdyt about this solution?", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-12-16T13:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyODkzMA==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544328930", "bodyText": "Nice one, this solution looks better to me! What about using it for the setter as well? Doing both in this method?", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-12-16T14:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1Njk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5NTAzMg==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544395032", "bodyText": "I thought about it. \"Setters\" are actually a very common practice and initially I thought it will be much faster to just rely on naming convention, but you're right @Inject can be used on any method and it will be nice to reduce noise for them as well", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-12-16T15:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE1Njk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMxOTMwNg==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544319306", "bodyText": "What do you think about this solution instead?\n  private static boolean isAnnotatedWith(SymbolMetadata metadata, String... fullyQualifiedNames) {\n    Set<String> fullyQualifiedNamesSet = new HashSet<>(Arrays.asList(fullyQualifiedNames));\n    return metadata.annotations().stream()\n      .map(a -> a.symbol().type())\n      .anyMatch(t -> t.isUnknown() || fullyQualifiedNamesSet.contains(t.fullyQualifiedName()));\n  }\nTo sum up, I'm using a stream instead of the loop, and a HashSet instead of isOneOf.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-12-16T13:59:21Z", "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -135,10 +179,23 @@ private static boolean isTransientSerializableOrInjected(VariableTree member) {\n       return true;\n     }\n     SymbolMetadata metadata = member.symbol().metadata();\n-    return metadata.isAnnotatedWith(\"javax.inject.Inject\")\n-      || metadata.isAnnotatedWith(\"javax.ejb.EJB\")\n-      || metadata.isAnnotatedWith(\"org.apache.wicket.spring.injection.annot.SpringBean\")\n-      || metadata.annotations().stream().anyMatch(annotation -> annotation.symbol().isUnknown());\n+    return isAnnotatedWith(metadata, JAVAX_INJECT, \"javax.ejb.EJB\", \"org.apache.wicket.spring.injection.annot.SpringBean\");\n+  }\n+\n+  private static boolean isAnnotatedWith(SymbolMetadata metadata, String... fullyQualifiedNames) {\n+    for (SymbolMetadata.AnnotationInstance annotation : metadata.annotations()) {\n+      Type type = annotation.symbol().type();\n+      if (type.isUnknown() || isOneOf(type, fullyQualifiedNames)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean isOneOf(Type type, String[] fullyQualifiedNames) {\n+    return Arrays.stream(fullyQualifiedNames)\n+      .map(type::is)\n+      .reduce(false, Boolean::logicalOr);", "originalCommit": "0786f30246e6d3567e6435352b0937a37e9c9ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM4ODgxNg==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544388816", "bodyText": "Looks nice!", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-12-16T15:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMxOTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyNjUyMQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544326521", "bodyText": "You compute this two times (the first one in getConstructorInjectedFields), what about storing it in an intermediate variable instead?", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-12-16T14:09:00Z", "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,32 +65,65 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+\n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+\n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)", "originalCommit": "0786f30246e6d3567e6435352b0937a37e9c9ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM4ODYzMg==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544388632", "bodyText": "If we remove the check in AssignmentVisitor, there is no need to have all fields before iterating", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-12-16T15:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyNjUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMzEyMA==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544333120", "bodyText": "This should work fine, I would just add a test when you have multiple constructors reaching the forEach, to make sure we are not losing anything across different visits.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-12-16T14:17:36Z", "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -54,32 +65,65 @@ public void visitNode(Tree tree) {\n     if (isSerializable(classTree)\n       && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)\n       && !classTree.symbol().type().isSubtypeOf(\"javax.servlet.http.HttpServlet\")) {\n-      for (Tree member : classTree.members()) {\n-        if (member.is(Tree.Kind.VARIABLE)) {\n-          checkVariableMember((VariableTree) member);\n-        }\n-      }\n+\n+      Set<String> constructorInjectedParams = getConstructorInjectedFields(classTree);\n+      Set<String> setterInjectedParams = getSetterInjectedFields(classTree);\n+\n+      classTree.members().stream()\n+        .filter(member -> member.is(Tree.Kind.VARIABLE))\n+        .map(VariableTree.class::cast)\n+        .filter(variableTree -> !(isExcluded(variableTree) ||\n+          constructorInjectedParams.contains(variableTree.simpleName().name()) ||\n+          setterInjectedParams.contains(variableTree.simpleName().name())))\n+        .forEach(this::checkVariableMember);\n     }\n   }\n \n+  private static Set<String> getSetterInjectedFields(ClassTree classTree) {\n+    return classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .filter(methodTree -> isAnnotatedWith(methodTree.symbol().metadata(), JAVAX_INJECT))\n+      .map(methodTree -> methodTree.simpleName().name())\n+      .filter(name -> name.startsWith(\"set\"))\n+      .map(name -> name.substring(3).toLowerCase(Locale.ROOT))\n+      .collect(Collectors.toSet());\n+  }\n+\n+  private static Set<String> getConstructorInjectedFields(ClassTree classTree) {\n+    Set<String> fields = classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.VARIABLE))\n+      .map(VariableTree.class::cast)\n+      .map(variableTree -> variableTree.simpleName().name())\n+      .collect(Collectors.toSet());\n+\n+    AssignmentsVisitor assignmentsVisitor = new AssignmentsVisitor(fields);\n+    \n+    classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))\n+      .map(MethodTree.class::cast)\n+      .filter(methodTree -> isAnnotatedWith(methodTree.symbol().metadata(), JAVAX_INJECT))\n+      .forEach(methodTree -> methodTree.accept(assignmentsVisitor));\n+    \n+    return assignmentsVisitor.getUsedFields();", "originalCommit": "0786f30246e6d3567e6435352b0937a37e9c9ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5MTAyOQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544391029", "bodyText": "Actually this is impossible situation for compiling example, cause only one constructor can be annotated with @Inject But I added it in non-compiling example", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-12-16T15:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMzEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0NDkyOA==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544344928", "bodyText": "Do we really need this check? If we collect any variable assigned, it should work fine, the set returned will just contain unrelated names.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-12-16T14:32:36Z", "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -168,4 +225,30 @@ private static boolean implementsSerializable(@Nullable Type type) {\n     return false;\n   }\n \n+  private static final class AssignmentsVisitor extends BaseTreeVisitor {\n+    private final Set<String> fields;\n+    private final Set<String> usedFields = new HashSet<>();\n+\n+    public AssignmentsVisitor(Set<String> fields) {\n+      this.fields = fields;\n+    }\n+\n+    @Override\n+    public void visitAssignmentExpression(AssignmentExpressionTree tree) {\n+      if (ExpressionUtils.isSelectOnThisOrSuper(tree)) {\n+        MemberSelectExpressionTree select = ((MemberSelectExpressionTree) tree.variable());\n+        usedFields.add(select.identifier().name());\n+      } else if (tree.variable().is(Tree.Kind.IDENTIFIER)) {\n+        IdentifierTree identifier = ((IdentifierTree) tree.variable());\n+        if (fields.contains(identifier.name())) {", "originalCommit": "0786f30246e6d3567e6435352b0937a37e9c9ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5MTk3NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3353#discussion_r544391975", "bodyText": "It was a small space opitimization. As far as we return Set, should not be a big deal regarding performance, can drop it", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-12-16T15:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0NDkyOA=="}], "type": "inlineReview"}, {"oid": "120d464fc62f118b1dcaeaaf70ce96eb832cd9d3", "url": "https://github.com/SonarSource/sonar-java/commit/120d464fc62f118b1dcaeaaf70ce96eb832cd9d3", "message": "SONARJAVA-3467 Adjust review comments", "committedDate": "2020-12-16T15:38:48Z", "type": "commit"}, {"oid": "120d464fc62f118b1dcaeaaf70ce96eb832cd9d3", "url": "https://github.com/SonarSource/sonar-java/commit/120d464fc62f118b1dcaeaaf70ce96eb832cd9d3", "message": "SONARJAVA-3467 Adjust review comments", "committedDate": "2020-12-16T15:38:48Z", "type": "forcePushed"}]}