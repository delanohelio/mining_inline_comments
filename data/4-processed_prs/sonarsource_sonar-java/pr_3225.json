{"pr_number": 3225, "pr_title": "SONARJAVA-3468 FP on S1905 when casted argument is an ambiguous method reference", "pr_createdAt": "2020-09-30T12:34:06Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3225", "timeline": [{"oid": "4d96ecc46ed91e38a1b516c61df049d2938a4b04", "url": "https://github.com/SonarSource/sonar-java/commit/4d96ecc46ed91e38a1b516c61df049d2938a4b04", "message": "Add FP to test checks", "committedDate": "2020-09-30T12:39:10Z", "type": "forcePushed"}, {"oid": "65cc6aba36fb3faba4a919d848aa4158982e443a", "url": "https://github.com/SonarSource/sonar-java/commit/65cc6aba36fb3faba4a919d848aa4158982e443a", "message": "Add FP to test checks", "committedDate": "2020-09-30T12:44:55Z", "type": "forcePushed"}, {"oid": "90e699c3d6296014f13dbaf4d84510205156f0be", "url": "https://github.com/SonarSource/sonar-java/commit/90e699c3d6296014f13dbaf4d84510205156f0be", "message": "Remove odd checks from non compiling file, add false negative in tests", "committedDate": "2020-09-30T14:41:34Z", "type": "forcePushed"}, {"oid": "a37cb61ff1ea9bad184e55c1ebe36b33bca5b82d", "url": "https://github.com/SonarSource/sonar-java/commit/a37cb61ff1ea9bad184e55c1ebe36b33bca5b82d", "message": "Remove odd checks from non compiling file, add false negative in tests", "committedDate": "2020-09-30T14:44:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5NTczMw==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r497595733", "bodyText": "I agree that I can not think of a situation where it will be false, but I think we can let it for defensive programming.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-30T15:19:32Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -73,7 +71,7 @@ private static boolean requiredForMemberAccess(TypeCastTree typeCastTree) {\n     ExpressionTree expression = typeCastTree.expression();\n     if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {\n       Tree parent = typeCastTree.parent();\n-      return expression.is(Tree.Kind.METHOD_REFERENCE) && parent != null && skipParentheses(parent).is(Tree.Kind.MEMBER_SELECT);", "originalCommit": "a37cb61ff1ea9bad184e55c1ebe36b33bca5b82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYwMDQwOA==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r497600408", "bodyText": "This cast is not safe if we call this method with any TypeCastTree or if twoexpression() calls return different values. (it is not the case, but I still think it's good practice to not rely on it).", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-30T15:25:46Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -172,6 +175,24 @@ private static boolean isUnnecessarySubtypeCast(Type childType, TypeCastTree typ\n         || isUnnecessaryLambdaCast(childType, parentType));\n   }\n \n+  private static boolean isAmbiguousMethodReference(TypeCastTree typeCastTree) {\n+    MethodReferenceTree methodReferenceTree = (MethodReferenceTree) typeCastTree.expression();", "originalCommit": "a37cb61ff1ea9bad184e55c1ebe36b33bca5b82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYwNjMwMQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r497606301", "bodyText": "I would rather put this code in the non-compiling part.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-30T15:33:57Z", "path": "java-checks-test-sources/src/main/java/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -391,16 +400,62 @@ void foo() {\n \n class CastRawType {\n   public static void paramsErrorMessage(Class clazz) {\n-    Outer.A r = (Outer.A) clazz.getAnnotation(Outer.A.class); // Handle cast of raw types\n+    Outer.Nested r = (Outer.Nested) clazz.getAnnotation(Outer.Nested.class); // Handle cast of raw types\n   }\n }\n \n @lombok.AllArgsConstructor\n-enum MyEnum {\n+enum MyPrivateEnum {\n \n   A((byte) 1), // constructor can not be resolved by ECJ, as it is generated by lombok\n   B((byte) 2);\n \n   @lombok.Getter\n   private byte value;\n+\n+}", "originalCommit": "a37cb61ff1ea9bad184e55c1ebe36b33bca5b82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxNDkzOA==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r497614938", "bodyText": "This code:\nbar(((Supplier<String>) Overloaded::fff));\n\nwill throw a ClassCastException here.\nUsing parent() is always annoying, there are many ways to write code to trick the rule. In doubt, I use defensive programming and accept if the coverage is not 100%.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-30T15:45:44Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -172,6 +175,24 @@ private static boolean isUnnecessarySubtypeCast(Type childType, TypeCastTree typ\n         || isUnnecessaryLambdaCast(childType, parentType));\n   }\n \n+  private static boolean isAmbiguousMethodReference(TypeCastTree typeCastTree) {\n+    MethodReferenceTree methodReferenceTree = (MethodReferenceTree) typeCastTree.expression();\n+    Symbol.TypeSymbol methodRefOwner = (Symbol.TypeSymbol) methodReferenceTree.method().symbol().owner();\n+    long numberMethodRefsOverloads = getOverloadsCount(methodRefOwner,methodReferenceTree.method().symbol().name());\n+\n+    MethodInvocationTree methodInvocationTree = (MethodInvocationTree) typeCastTree.parent().parent();", "originalCommit": "a37cb61ff1ea9bad184e55c1ebe36b33bca5b82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxNzYyNg==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r497617626", "bodyText": "Any reason why you used an early return here, instead of including this logic into the returned boolean expression?", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-30T15:49:35Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -164,6 +164,9 @@ private static Tree skipParentheses(Tree parent) {\n \n   private static boolean isUnnecessarySubtypeCast(Type childType, TypeCastTree typeCastTree, Type parentType) {\n     boolean isArgument = skipParentheses(typeCastTree.parent()).is(Tree.Kind.ARGUMENTS);\n+    if (isArgument && typeCastTree.expression().is(Tree.Kind.METHOD_REFERENCE) && isAmbiguousMethodReference(typeCastTree)) {\n+      return false;\n+    }", "originalCommit": "a37cb61ff1ea9bad184e55c1ebe36b33bca5b82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyNTA2MA==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r497625060", "bodyText": "foo((Supplier<String>) Overloaded::unknown); \n\nWhen the method reference is unknown, this code will throw a ClassCastException.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-30T15:59:59Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -172,6 +175,24 @@ private static boolean isUnnecessarySubtypeCast(Type childType, TypeCastTree typ\n         || isUnnecessaryLambdaCast(childType, parentType));\n   }\n \n+  private static boolean isAmbiguousMethodReference(TypeCastTree typeCastTree) {\n+    MethodReferenceTree methodReferenceTree = (MethodReferenceTree) typeCastTree.expression();\n+    Symbol.TypeSymbol methodRefOwner = (Symbol.TypeSymbol) methodReferenceTree.method().symbol().owner();", "originalCommit": "a37cb61ff1ea9bad184e55c1ebe36b33bca5b82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYzMTcyMg==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r497631722", "bodyText": "unknown((Supplier<String>) Overloaded::fff);\n\nThis code... does not raise a ClassCastException. :)\nBut an issue is still reported and I think it makes sense to not report an issue if we don't know the type expected. If the fix is easy, and it makes sense to include it with this PR, we could do it now.\nOtherwise, we can simply create a new ticket to track this minor issue.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-30T16:09:56Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -172,6 +175,24 @@ private static boolean isUnnecessarySubtypeCast(Type childType, TypeCastTree typ\n         || isUnnecessaryLambdaCast(childType, parentType));\n   }\n \n+  private static boolean isAmbiguousMethodReference(TypeCastTree typeCastTree) {\n+    MethodReferenceTree methodReferenceTree = (MethodReferenceTree) typeCastTree.expression();\n+    Symbol.TypeSymbol methodRefOwner = (Symbol.TypeSymbol) methodReferenceTree.method().symbol().owner();\n+    long numberMethodRefsOverloads = getOverloadsCount(methodRefOwner,methodReferenceTree.method().symbol().name());\n+\n+    MethodInvocationTree methodInvocationTree = (MethodInvocationTree) typeCastTree.parent().parent();\n+    Symbol.TypeSymbol owner = (Symbol.TypeSymbol) methodInvocationTree.symbol().owner();", "originalCommit": "a37cb61ff1ea9bad184e55c1ebe36b33bca5b82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1222712358fd347253aff41e75653c7cb697d3c3", "url": "https://github.com/SonarSource/sonar-java/commit/1222712358fd347253aff41e75653c7cb697d3c3", "message": "Refactoring", "committedDate": "2020-10-01T09:31:55Z", "type": "forcePushed"}, {"oid": "6876ce896c729ba9bd501ab4d143b950f01d76ad", "url": "https://github.com/SonarSource/sonar-java/commit/6876ce896c729ba9bd501ab4d143b950f01d76ad", "message": "Move test files to the proper test sources directory", "committedDate": "2020-10-01T10:25:18Z", "type": "commit"}, {"oid": "fe4187599d0eec623562f4c199069b4817c0d36e", "url": "https://github.com/SonarSource/sonar-java/commit/fe4187599d0eec623562f4c199069b4817c0d36e", "message": "Add FP to test checks", "committedDate": "2020-10-01T10:25:18Z", "type": "commit"}, {"oid": "8d018558740698e776da0ddbcd8e0986e120cd68", "url": "https://github.com/SonarSource/sonar-java/commit/8d018558740698e776da0ddbcd8e0986e120cd68", "message": "Add FP to test checks", "committedDate": "2020-10-01T10:25:18Z", "type": "commit"}, {"oid": "359670e828cf7211f84c32e004ff0145431e7ddb", "url": "https://github.com/SonarSource/sonar-java/commit/359670e828cf7211f84c32e004ff0145431e7ddb", "message": "Remove odd checks from non compiling file, add false negative in tests", "committedDate": "2020-10-01T10:25:18Z", "type": "commit"}, {"oid": "413c5f60f120e691410040cdcd5d9d8b12cebd9a", "url": "https://github.com/SonarSource/sonar-java/commit/413c5f60f120e691410040cdcd5d9d8b12cebd9a", "message": "Refactoring", "committedDate": "2020-10-01T11:54:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyOTM0NA==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r498229344", "bodyText": "All this code is compiling and is duplicated in the compiling file. I think we should keep only what is not compiling in this file, to avoid duplication.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-10-01T13:07:27Z", "path": "java-checks-test-sources/src/main/files/non-compiling/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package checks;\n+\n+import java.util.function.Predicate;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Comparator;\n+import java.util.Set;\n+\n+class Outer {\n+  class A {\n+  }\n+  class B extends A { }\n+  List list;\n+  List<String> foo() {\n+    Object obj = null;\n+    Object o1 = (List<String>) foo(); // Noncompliant [[sc=18;ec=30]] {{Remove this unnecessary cast to \"List\".}}\n+    Object o2 = (List<? extends String>) foo(); // Noncompliant {{Remove this unnecessary cast to \"List\".}}\n+    Object o3 = (List<? super String>) foo(); // Noncompliant {{Remove this unnecessary cast to \"List\".}}\n+    String s1 = (String) obj; // Compliant\n+    String s2 = (String) s1; // Noncompliant {{Remove this unnecessary cast to \"String\".}}\n+    A a = (A) new B(); // Noncompliant {{Remove this unnecessary cast to \"A\".}}\n+    A[][] as = (A[][]) new B[1][1]; // Noncompliant {{Remove this unnecessary cast to \"A[][]\".}}\n+    B b = null;\n+    fun(b);\n+    fun((B) b); // Noncompliant\n+    fun((A) b); // Compliant - exception to distinguish the method to call\n+    funBParameter((A) b); // Noncompliant\n+    List<B> bees = new java.util.ArrayList<B>();\n+    List<A> aaas = (List) bees;", "originalCommit": "413c5f60f120e691410040cdcd5d9d8b12cebd9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MTk1Mw==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r498261953", "bodyText": "I tried to remove as many duplications as possible but it's kinda hard to make difference between what you need in non-compiling code. I've already removed much from non-compiling file.", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-10-01T13:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIyOTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MDM4MQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r498240381", "bodyText": "As a general observation, I tend to prefer to create an intermediate variable to store typeCastTree.expression().\nIn my opinion, it increases the clarity of the code and avoids problems in case it returns differents values between two calls, or if the computation is expensive.\nSame for parentTree.parent(), to avoid having to call skipParentheses() twice.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-10-01T13:23:37Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -163,13 +163,33 @@ private static Tree skipParentheses(Tree parent) {\n   }\n \n   private static boolean isUnnecessarySubtypeCast(Type childType, TypeCastTree typeCastTree, Type parentType) {\n-    boolean isArgument = skipParentheses(typeCastTree.parent()).is(Tree.Kind.ARGUMENTS);\n+    Tree parentTree = skipParentheses(typeCastTree.parent());\n+    boolean isArgument = parentTree.is(Tree.Kind.ARGUMENTS);\n+\n     return !childType.isPrimitive()\n       // Exception: subtype cast are tolerated in method or constructor call arguments\n       && (typeCastTree.type().symbolType().equals(childType)\n         || (isArgument && childType.equals(parentType)) || (!isArgument && childType.isSubtypeOf(parentType)))\n       && (!ExpressionUtils.skipParentheses(typeCastTree.expression()).is(Tree.Kind.LAMBDA_EXPRESSION)\n-        || isUnnecessaryLambdaCast(childType, parentType));\n+        || isUnnecessaryLambdaCast(childType, parentType))\n+      && !(isArgument && isMandatoryMethodReferenceCast(typeCastTree, parentTree));\n+  }\n+\n+  private static boolean isMandatoryMethodReferenceCast(TypeCastTree typeCastTree, Tree parentTree) {\n+    if (typeCastTree.expression().is(Tree.Kind.METHOD_REFERENCE) && skipParentheses(parentTree.parent()).is(Tree.Kind.METHOD_INVOCATION)) {", "originalCommit": "413c5f60f120e691410040cdcd5d9d8b12cebd9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0MTMwNw==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r498241307", "bodyText": "Same here, let's create a variable to store symbol.owner().", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-10-01T13:24:54Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -163,13 +163,33 @@ private static Tree skipParentheses(Tree parent) {\n   }\n \n   private static boolean isUnnecessarySubtypeCast(Type childType, TypeCastTree typeCastTree, Type parentType) {\n-    boolean isArgument = skipParentheses(typeCastTree.parent()).is(Tree.Kind.ARGUMENTS);\n+    Tree parentTree = skipParentheses(typeCastTree.parent());\n+    boolean isArgument = parentTree.is(Tree.Kind.ARGUMENTS);\n+\n     return !childType.isPrimitive()\n       // Exception: subtype cast are tolerated in method or constructor call arguments\n       && (typeCastTree.type().symbolType().equals(childType)\n         || (isArgument && childType.equals(parentType)) || (!isArgument && childType.isSubtypeOf(parentType)))\n       && (!ExpressionUtils.skipParentheses(typeCastTree.expression()).is(Tree.Kind.LAMBDA_EXPRESSION)\n-        || isUnnecessaryLambdaCast(childType, parentType));\n+        || isUnnecessaryLambdaCast(childType, parentType))\n+      && !(isArgument && isMandatoryMethodReferenceCast(typeCastTree, parentTree));\n+  }\n+\n+  private static boolean isMandatoryMethodReferenceCast(TypeCastTree typeCastTree, Tree parentTree) {\n+    if (typeCastTree.expression().is(Tree.Kind.METHOD_REFERENCE) && skipParentheses(parentTree.parent()).is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodReferenceTree expression = (MethodReferenceTree) typeCastTree.expression();\n+      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) skipParentheses(parentTree.parent());\n+      Symbol methodAsArg = expression.method().symbol();\n+      Symbol methodCaller = methodInvocationTree.symbol();\n+      return hasOverloads(methodAsArg) && hasOverloads(methodCaller);\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasOverloads(Symbol symbol) {\n+    return symbol.owner().isTypeSymbol() && ((Symbol.TypeSymbol) symbol.owner()).memberSymbols().stream()", "originalCommit": "413c5f60f120e691410040cdcd5d9d8b12cebd9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0NjQ1Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/3225#discussion_r498246456", "bodyText": "I would also put this test in the compiling part, to be sure that unknown method does not prevent the Exception to happen.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-10-01T13:31:52Z", "path": "java-checks-test-sources/src/main/files/non-compiling/checks/RedundantTypeCastCheck.java", "diffHunk": "@@ -116,24 +116,49 @@ String qix2() {\n   private byte value;\n \n \n-  class FP_S1905 {\n-    static class Overloaded {\n-      static String f() {\n-        return \"\";\n-      }\n-\n-      static String f(String a) {\n-        return \"\";\n-      }\n-    }\n+}\n \n-    void main() {\n-      foo(Overloaded::f); // Does not compile without cast\n-      foo(String::new); // Does not compile without cast\n+class FP_S1905 {\n+  static class Overloaded {\n+    static String f() {\n+      return \"\";\n     }\n \n-    void foo(Supplier<String> supplier) {\n-    }\n-    void foo(Function<String, String> function) {\n+    static String f(String a) {\n+      return \"\";\n     }\n-  }}\n+  }\n+\n+  void main() {\n+    foo(Overloaded::f); // Does not compile without cast\n+    foo(String::new); // Does not compile without cast\n+\n+    bar(((Supplier<String>) Overloaded::fff));", "originalCommit": "413c5f60f120e691410040cdcd5d9d8b12cebd9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "53e423370925f83b1c98b82a29652f58d4d7861d", "url": "https://github.com/SonarSource/sonar-java/commit/53e423370925f83b1c98b82a29652f58d4d7861d", "message": "Refactoring", "committedDate": "2020-10-01T14:22:23Z", "type": "commit"}, {"oid": "53e423370925f83b1c98b82a29652f58d4d7861d", "url": "https://github.com/SonarSource/sonar-java/commit/53e423370925f83b1c98b82a29652f58d4d7861d", "message": "Refactoring", "committedDate": "2020-10-01T14:22:23Z", "type": "forcePushed"}]}