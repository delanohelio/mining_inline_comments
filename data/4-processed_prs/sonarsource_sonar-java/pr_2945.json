{"pr_number": 2945, "pr_title": "SONARJAVA-2944 Rule S4970: Derived exceptions should not hide their parents catch block", "pr_createdAt": "2020-05-06T13:18:25Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/2945", "timeline": [{"oid": "a67aef7d53ac253d237df146e3ed4c36eb559741", "url": "https://github.com/SonarSource/sonar-java/commit/a67aef7d53ac253d237df146e3ed4c36eb559741", "message": "SONARJAVA-2944 Rule S4970: Derived exceptions should not hide their parents catch block", "committedDate": "2020-05-06T13:19:07Z", "type": "forcePushed"}, {"oid": "34239000069a04b2a2065af41c0b528fcf3f2687", "url": "https://github.com/SonarSource/sonar-java/commit/34239000069a04b2a2065af41c0b528fcf3f2687", "message": "SONARJAVA-2944 Rule S4970: Derived exceptions should not hide their parents catch block", "committedDate": "2020-05-06T15:30:11Z", "type": "commit"}, {"oid": "34239000069a04b2a2065af41c0b528fcf3f2687", "url": "https://github.com/SonarSource/sonar-java/commit/34239000069a04b2a2065af41c0b528fcf3f2687", "message": "SONARJAVA-2944 Rule S4970: Derived exceptions should not hide their parents catch block", "committedDate": "2020-05-06T15:30:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTEyOA==", "url": "https://github.com/SonarSource/sonar-java/pull/2945#discussion_r421325128", "bodyText": "I don't see test cases where lambdas or anonymous classes are used, therefore these lines are not covered. Can you add some?", "author": "m-g-sonar", "createdAt": "2020-05-07T08:20:58Z", "path": "java-checks/src/main/java/org/sonar/java/checks/UnreachableCatchCheck.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.CatchTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.LambdaExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.NewClassTree;\n+import org.sonar.plugins.java.api.tree.SyntaxToken;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TryStatementTree;\n+import org.sonar.plugins.java.api.tree.TypeTree;\n+import org.sonar.plugins.java.api.tree.UnionTypeTree;\n+\n+@Rule(key = \"S4970\")\n+public class UnreachableCatchCheck extends IssuableSubscriptionVisitor {\n+\n+  private Map<Type, SyntaxToken> typeToCatchToken = new HashMap<>();\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    TryStatementTree tryStatementTree = (TryStatementTree) tree;\n+    typeToCatchToken.clear();\n+    Multimap<Type, Type> derivedToBase = getDerivedTypesCaughtBeforeBaseType(tryStatementTree.catches());\n+\n+    if (derivedToBase.isEmpty()) {\n+      return;\n+    }\n+\n+    MethodThrownTypeCollector collector = new MethodThrownTypeCollector();\n+    tryStatementTree.block().accept(collector);\n+    List<Type> thrownTypes = collector.thrownTypes;\n+\n+    derivedToBase.entries().forEach(entry -> {\n+      Type derivedType = entry.getKey();\n+      Type baseType = entry.getValue();\n+\n+      // Catching a derived type before the base type is fine if the body of the try throws an exception which is a subtype of the base type,\n+      // but not of the derived type. We have to make sure that we are not in this situation before reporting an issue.\n+      if (isHidden(baseType, derivedType, thrownTypes)) {\n+        reportIssue(typeToCatchToken.get(baseType),\n+          \"Remove this catch block because it is unreachable as hidden by previous catch blocks.\",\n+          Collections.singletonList(new JavaFileScannerContext.Location(\"Already catch the exception\", typeToCatchToken.get(derivedType))),\n+          null);\n+      }\n+    });\n+  }\n+\n+  private Multimap<Type, Type> getDerivedTypesCaughtBeforeBaseType(List<CatchTree> catches) {\n+    Multimap<Type, Type> derivedBeforeBase = HashMultimap.create();\n+\n+    List<Type> catchTypes = catches.stream()\n+      .flatMap(c -> {\n+        List<Type> types = new ArrayList<>();\n+        collectTypesFromTypeTree(c.parameter().type(), types, c.catchKeyword());\n+        return types.stream();\n+      })\n+      .filter(UnreachableCatchCheck::isChecked)\n+      .collect(Collectors.toList());\n+\n+    for (int i = 0; i < catchTypes.size() - 1; i++) {\n+      Type topType = catchTypes.get(0);\n+      for (int j = i + 1; j < catchTypes.size(); j++) {\n+        Type bottomType = catchTypes.get(j);\n+        if (topType.isSubtypeOf(bottomType)) {\n+          derivedBeforeBase.put(topType, bottomType);\n+        }\n+      }\n+    }\n+    return derivedBeforeBase;\n+  }\n+\n+  private void collectTypesFromTypeTree(TypeTree typeTree, List<Type> types, SyntaxToken correspondingCatch) {\n+    if (typeTree.is(Tree.Kind.UNION_TYPE)) {\n+      ((UnionTypeTree) typeTree).typeAlternatives().forEach(t -> collectTypesFromTypeTree(t, types, correspondingCatch));\n+    } else {\n+      Type type = typeTree.symbolType();\n+      typeToCatchToken.put(type, correspondingCatch);\n+      types.add(type);\n+    }\n+  }\n+\n+  private static boolean isChecked(Type type) {\n+    return !type.isSubtypeOf(\"java.lang.RuntimeException\")\n+      && !type.isSubtypeOf(\"java.lang.Error\")\n+      && !type.is(\"java.lang.Throwable\");\n+  }\n+\n+  private static boolean isHidden(Type baseType, Type derivedType, List<Type> thrownTypes) {\n+    return thrownTypes.stream().noneMatch(thrownType ->\n+      thrownType.isSubtypeOf(baseType) && !thrownType.isSubtypeOf(derivedType)\n+    );\n+  }\n+\n+  private static class MethodThrownTypeCollector extends BaseTreeVisitor {\n+    List<Type> thrownTypes = new ArrayList<>();\n+\n+    @Override\n+    public void visitMethodInvocation(MethodInvocationTree mit) {\n+      addAllThrownTypes(mit.symbol());\n+      super.visitMethodInvocation(mit);\n+    }\n+\n+    @Override\n+    public void visitNewClass(NewClassTree tree) {\n+      addAllThrownTypes(tree.constructorSymbol());\n+      super.visitNewClass(tree);\n+    }\n+\n+    private void addAllThrownTypes(Symbol symbol) {\n+      if (symbol.isMethodSymbol()) {\n+        thrownTypes.addAll(((Symbol.MethodSymbol) symbol).thrownTypes());\n+      }\n+    }\n+\n+    @Override\n+    public void visitClass(ClassTree tree) {\n+      // Skip class\n+    }\n+\n+    @Override\n+    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {\n+      // Skip lambdas\n+    }", "originalCommit": "34239000069a04b2a2065af41c0b528fcf3f2687", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTkwNA==", "url": "https://github.com/SonarSource/sonar-java/pull/2945#discussion_r421329904", "bodyText": "I think we should also visit the thrown statements, to collect which exceptions are manually thrown within the block (even if it's an ugly practice).\nI also feel that the visitor class should be renamed. What about simply ThrownExceptionCollector?", "author": "m-g-sonar", "createdAt": "2020-05-07T08:28:42Z", "path": "java-checks/src/main/java/org/sonar/java/checks/UnreachableCatchCheck.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.CatchTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.LambdaExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.NewClassTree;\n+import org.sonar.plugins.java.api.tree.SyntaxToken;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TryStatementTree;\n+import org.sonar.plugins.java.api.tree.TypeTree;\n+import org.sonar.plugins.java.api.tree.UnionTypeTree;\n+\n+@Rule(key = \"S4970\")\n+public class UnreachableCatchCheck extends IssuableSubscriptionVisitor {\n+\n+  private Map<Type, SyntaxToken> typeToCatchToken = new HashMap<>();\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    TryStatementTree tryStatementTree = (TryStatementTree) tree;\n+    typeToCatchToken.clear();\n+    Multimap<Type, Type> derivedToBase = getDerivedTypesCaughtBeforeBaseType(tryStatementTree.catches());\n+\n+    if (derivedToBase.isEmpty()) {\n+      return;\n+    }\n+\n+    MethodThrownTypeCollector collector = new MethodThrownTypeCollector();\n+    tryStatementTree.block().accept(collector);\n+    List<Type> thrownTypes = collector.thrownTypes;\n+\n+    derivedToBase.entries().forEach(entry -> {\n+      Type derivedType = entry.getKey();\n+      Type baseType = entry.getValue();\n+\n+      // Catching a derived type before the base type is fine if the body of the try throws an exception which is a subtype of the base type,\n+      // but not of the derived type. We have to make sure that we are not in this situation before reporting an issue.\n+      if (isHidden(baseType, derivedType, thrownTypes)) {\n+        reportIssue(typeToCatchToken.get(baseType),\n+          \"Remove this catch block because it is unreachable as hidden by previous catch blocks.\",\n+          Collections.singletonList(new JavaFileScannerContext.Location(\"Already catch the exception\", typeToCatchToken.get(derivedType))),\n+          null);\n+      }\n+    });\n+  }\n+\n+  private Multimap<Type, Type> getDerivedTypesCaughtBeforeBaseType(List<CatchTree> catches) {\n+    Multimap<Type, Type> derivedBeforeBase = HashMultimap.create();\n+\n+    List<Type> catchTypes = catches.stream()\n+      .flatMap(c -> {\n+        List<Type> types = new ArrayList<>();\n+        collectTypesFromTypeTree(c.parameter().type(), types, c.catchKeyword());\n+        return types.stream();\n+      })\n+      .filter(UnreachableCatchCheck::isChecked)\n+      .collect(Collectors.toList());\n+\n+    for (int i = 0; i < catchTypes.size() - 1; i++) {\n+      Type topType = catchTypes.get(0);\n+      for (int j = i + 1; j < catchTypes.size(); j++) {\n+        Type bottomType = catchTypes.get(j);\n+        if (topType.isSubtypeOf(bottomType)) {\n+          derivedBeforeBase.put(topType, bottomType);\n+        }\n+      }\n+    }\n+    return derivedBeforeBase;\n+  }\n+\n+  private void collectTypesFromTypeTree(TypeTree typeTree, List<Type> types, SyntaxToken correspondingCatch) {\n+    if (typeTree.is(Tree.Kind.UNION_TYPE)) {\n+      ((UnionTypeTree) typeTree).typeAlternatives().forEach(t -> collectTypesFromTypeTree(t, types, correspondingCatch));\n+    } else {\n+      Type type = typeTree.symbolType();\n+      typeToCatchToken.put(type, correspondingCatch);\n+      types.add(type);\n+    }\n+  }\n+\n+  private static boolean isChecked(Type type) {\n+    return !type.isSubtypeOf(\"java.lang.RuntimeException\")\n+      && !type.isSubtypeOf(\"java.lang.Error\")\n+      && !type.is(\"java.lang.Throwable\");\n+  }\n+\n+  private static boolean isHidden(Type baseType, Type derivedType, List<Type> thrownTypes) {\n+    return thrownTypes.stream().noneMatch(thrownType ->\n+      thrownType.isSubtypeOf(baseType) && !thrownType.isSubtypeOf(derivedType)\n+    );\n+  }\n+\n+  private static class MethodThrownTypeCollector extends BaseTreeVisitor {", "originalCommit": "34239000069a04b2a2065af41c0b528fcf3f2687", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzNzk2OQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2945#discussion_r421337969", "bodyText": "what a mega map at the end. Don't you fear to have duplicates?\nif we have the following relationships (<- is subtype of):\nA <- B <- C <- D\n\nYou will end up having in the map:\nA: B,C,D // not even necessarily ordered, and could be C,D,B\nB: C,D\nC: D\n\nwhich is redundant.", "author": "m-g-sonar", "createdAt": "2020-05-07T08:41:42Z", "path": "java-checks/src/main/java/org/sonar/java/checks/UnreachableCatchCheck.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.CatchTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.LambdaExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.NewClassTree;\n+import org.sonar.plugins.java.api.tree.SyntaxToken;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TryStatementTree;\n+import org.sonar.plugins.java.api.tree.TypeTree;\n+import org.sonar.plugins.java.api.tree.UnionTypeTree;\n+\n+@Rule(key = \"S4970\")\n+public class UnreachableCatchCheck extends IssuableSubscriptionVisitor {\n+\n+  private Map<Type, SyntaxToken> typeToCatchToken = new HashMap<>();\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    TryStatementTree tryStatementTree = (TryStatementTree) tree;\n+    typeToCatchToken.clear();\n+    Multimap<Type, Type> derivedToBase = getDerivedTypesCaughtBeforeBaseType(tryStatementTree.catches());\n+\n+    if (derivedToBase.isEmpty()) {\n+      return;\n+    }\n+\n+    MethodThrownTypeCollector collector = new MethodThrownTypeCollector();\n+    tryStatementTree.block().accept(collector);\n+    List<Type> thrownTypes = collector.thrownTypes;\n+\n+    derivedToBase.entries().forEach(entry -> {\n+      Type derivedType = entry.getKey();\n+      Type baseType = entry.getValue();\n+\n+      // Catching a derived type before the base type is fine if the body of the try throws an exception which is a subtype of the base type,\n+      // but not of the derived type. We have to make sure that we are not in this situation before reporting an issue.\n+      if (isHidden(baseType, derivedType, thrownTypes)) {\n+        reportIssue(typeToCatchToken.get(baseType),\n+          \"Remove this catch block because it is unreachable as hidden by previous catch blocks.\",\n+          Collections.singletonList(new JavaFileScannerContext.Location(\"Already catch the exception\", typeToCatchToken.get(derivedType))),\n+          null);\n+      }\n+    });\n+  }\n+\n+  private Multimap<Type, Type> getDerivedTypesCaughtBeforeBaseType(List<CatchTree> catches) {\n+    Multimap<Type, Type> derivedBeforeBase = HashMultimap.create();\n+\n+    List<Type> catchTypes = catches.stream()\n+      .flatMap(c -> {\n+        List<Type> types = new ArrayList<>();\n+        collectTypesFromTypeTree(c.parameter().type(), types, c.catchKeyword());\n+        return types.stream();\n+      })\n+      .filter(UnreachableCatchCheck::isChecked)\n+      .collect(Collectors.toList());\n+\n+    for (int i = 0; i < catchTypes.size() - 1; i++) {", "originalCommit": "34239000069a04b2a2065af41c0b528fcf3f2687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ1NjYxOA==", "url": "https://github.com/SonarSource/sonar-java/pull/2945#discussion_r421456618", "bodyText": "In fact, the current implementation reports duplicates! I thought I had a test for it, but the next line is Type topType = catchTypes.get(0); instead of catchTypes.get(i); \ud83d\ude15\nI changed the implementation to inverse the key and the value, the map will now look like:\nD: A,B,C\nC: B,A\nB: A\n\nWe still have the map though, we could slightly change the logic to avoid it, but we will have to add extra logic for the same result.\nAfter discussion, we concluded that this status is good enough since the most critical concern is resolved (no duplication).", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-05-07T12:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzNzk2OQ=="}], "type": "inlineReview"}, {"oid": "957fc31b7205908769a38a8bcab2368e1af7db4e", "url": "https://github.com/SonarSource/sonar-java/commit/957fc31b7205908769a38a8bcab2368e1af7db4e", "message": "Improve coverage", "committedDate": "2020-05-07T11:11:00Z", "type": "commit"}, {"oid": "ccc1c1a0343ac74d664bc1a7449cba576e3d5765", "url": "https://github.com/SonarSource/sonar-java/commit/ccc1c1a0343ac74d664bc1a7449cba576e3d5765", "message": "Support exception thrown directly", "committedDate": "2020-05-07T11:15:23Z", "type": "commit"}, {"oid": "23d68359fa9ca58d007faf7a3cc967c48375317c", "url": "https://github.com/SonarSource/sonar-java/commit/23d68359fa9ca58d007faf7a3cc967c48375317c", "message": "Avoid issue duplication", "committedDate": "2020-05-07T12:26:33Z", "type": "commit"}]}