{"pr_number": 9235, "pr_title": "Add join-related DataSource types, and analysis functionality.", "pr_createdAt": "2020-01-21T18:59:29Z", "pr_url": "https://github.com/apache/druid/pull/9235", "timeline": [{"oid": "2cda5c6e1fb381e03c7e8a27475cc07d2448ecf8", "url": "https://github.com/apache/druid/commit/2cda5c6e1fb381e03c7e8a27475cc07d2448ecf8", "message": "Add join-related DataSource types, and analysis functionality.\n\nBuilds on #9111 and implements the datasource analysis mentioned in #8728. Still can't\nhandle join datasources, but we're a step closer.\n\nJoin-related DataSource types:\n\n1) Add \"join\", \"lookup\", and \"inline\" datasources.\n2) Add \"getChildren\" and \"withChildren\" methods to DataSource, which will be used\n   in the future for query rewriting (e.g. inlining of subqueries).\n\nDataSource analysis functionality:\n\n1) Add DataSourceAnalysis class, which breaks down datasources into three components:\n   outer queries, a base datasource (left-most of the highest level left-leaning join\n   tree), and other joined-in leaf datasources (the right-hand branches of the\n   left-leaning join tree).\n2) Add \"isConcrete\", \"isGlobal\", and \"isCacheable\" methods to DataSource in order to\n   support analysis.\n\nOther notes:\n\n1) Renamed DataSource#getNames to DataSource#getTableNames, which I think is clearer.\n   Also, made it a Set, so implementations don't need to worry about duplicates.\n2) The addition of \"isCacheable\" should work around #8713, since UnionDataSource now\n   returns false for cacheability.", "committedDate": "2020-01-21T18:58:07Z", "type": "commit"}, {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "url": "https://github.com/apache/druid/commit/0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "message": "Remove javadoc comment.", "committedDate": "2020-01-21T21:09:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI4OTQxMQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369289411", "bodyText": "Similar comment to the one I left in CacheUtil.", "author": "ccaominh", "createdAt": "2020-01-21T22:58:55Z", "path": "server/src/main/java/org/apache/druid/client/ResultLevelCacheUtil.java", "diffHunk": "@@ -73,7 +73,8 @@ public static void populate(\n     return QueryContexts.isUseResultLevelCache(query)\n            && strategy != null\n            && cacheConfig.isUseResultLevelCache()\n-           && cacheConfig.isQueryCacheable(query);\n+           && cacheConfig.isQueryCacheable(query)\n+           && query.getDataSource().isCacheable();", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5MDY5OA==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369290698", "bodyText": "Perhaps extract these four lines should be a helper method since it's duplicated in populateResultLevelCache().\nIs there a test that is affected by the addition of isCacheable() or should one be added?", "author": "ccaominh", "createdAt": "2020-01-21T23:02:27Z", "path": "server/src/main/java/org/apache/druid/client/CacheUtil.java", "diffHunk": "@@ -99,7 +99,8 @@\n     return QueryContexts.isUseCache(query)\n            && strategy != null\n            && cacheConfig.isUseCache()\n-           && cacheConfig.isQueryCacheable(query);\n+           && cacheConfig.isQueryCacheable(query)\n+           && query.getDataSource().isCacheable();", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM0NzU1OQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369347559", "bodyText": "Hmm, after thinking about this a bit IMO it is best to combine ResultLevelCacheUtil and CacheUtil, then make the change you suggested (although I think we can only extract three lines), and then add tests for CacheUtil. I'll add that to this patch in a bit.", "author": "gianm", "createdAt": "2020-01-22T02:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5MDY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM1MDY3Ng==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369350676", "bodyText": "Or maybe not combining them in this patch, but at least doing the extraction.", "author": "gianm", "createdAt": "2020-01-22T03:03:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5MDY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTE1NA==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369699154", "bodyText": "@ccaominh I decided to combine them after all, and add a CacheUtil test that tests the newly extracted isQueryCacheable method.", "author": "gianm", "createdAt": "2020-01-22T17:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5MDY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5MzE0Ng==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369293146", "bodyText": "Should this be private to match the javadoc?", "author": "ccaominh", "createdAt": "2020-01-21T23:09:53Z", "path": "processing/src/main/java/org/apache/druid/query/InlineDataSource.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.RowAdapter;\n+import org.apache.druid.segment.column.ColumnHolder;\n+import org.apache.druid.segment.column.ValueType;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.ToLongFunction;\n+\n+/**\n+ * Represents an inline datasource, where the rows are embedded within the DataSource object itself.\n+ *\n+ * The rows are backed by an Iterable, which can be lazy or not. Lazy datasources will only be iterated if someone calls\n+ * {@link #getRows()} and iterates the result, or until someone calls {@link #getRowsAsList()}.\n+ */\n+public class InlineDataSource implements DataSource\n+{\n+  private final List<String> columnNames;\n+  private final List<ValueType> columnTypes;\n+  private final Iterable<Object[]> rows;\n+\n+  private InlineDataSource(\n+      final List<String> columnNames,\n+      final List<ValueType> columnTypes,\n+      final Iterable<Object[]> rows\n+  )\n+  {\n+    this.columnNames = Preconditions.checkNotNull(columnNames, \"'columnNames' must be nonnull\");\n+    this.columnTypes = Preconditions.checkNotNull(columnTypes, \"'columnTypes' must be nonnull\");\n+    this.rows = Preconditions.checkNotNull(rows, \"'rows' must be nonnull\");\n+\n+    if (columnNames.size() != columnTypes.size()) {\n+      throw new IAE(\"columnNames and columnTypes must be the same length\");\n+    }\n+  }\n+\n+  /**\n+   * Factory method for Jackson. Used for inline datasources that were originally encoded as JSON. Private because\n+   * non-Jackson callers should use {@link #fromIterable}.\n+   */\n+  @JsonCreator\n+  public static InlineDataSource fromJson(", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMzNjc5OA==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369336798", "bodyText": "Oops, yes, it should. I'll fix it.", "author": "gianm", "createdAt": "2020-01-22T01:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5MzE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMDEyNQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369300125", "bodyText": "Typo: stringificatione -> stringification\nIs it worth adding a test to enforce this?", "author": "ccaominh", "createdAt": "2020-01-21T23:31:41Z", "path": "processing/src/main/java/org/apache/druid/query/InlineDataSource.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.RowAdapter;\n+import org.apache.druid.segment.column.ColumnHolder;\n+import org.apache.druid.segment.column.ValueType;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.ToLongFunction;\n+\n+/**\n+ * Represents an inline datasource, where the rows are embedded within the DataSource object itself.\n+ *\n+ * The rows are backed by an Iterable, which can be lazy or not. Lazy datasources will only be iterated if someone calls\n+ * {@link #getRows()} and iterates the result, or until someone calls {@link #getRowsAsList()}.\n+ */\n+public class InlineDataSource implements DataSource\n+{\n+  private final List<String> columnNames;\n+  private final List<ValueType> columnTypes;\n+  private final Iterable<Object[]> rows;\n+\n+  private InlineDataSource(\n+      final List<String> columnNames,\n+      final List<ValueType> columnTypes,\n+      final Iterable<Object[]> rows\n+  )\n+  {\n+    this.columnNames = Preconditions.checkNotNull(columnNames, \"'columnNames' must be nonnull\");\n+    this.columnTypes = Preconditions.checkNotNull(columnTypes, \"'columnTypes' must be nonnull\");\n+    this.rows = Preconditions.checkNotNull(rows, \"'rows' must be nonnull\");\n+\n+    if (columnNames.size() != columnTypes.size()) {\n+      throw new IAE(\"columnNames and columnTypes must be the same length\");\n+    }\n+  }\n+\n+  /**\n+   * Factory method for Jackson. Used for inline datasources that were originally encoded as JSON. Private because\n+   * non-Jackson callers should use {@link #fromIterable}.\n+   */\n+  @JsonCreator\n+  public static InlineDataSource fromJson(\n+      @JsonProperty(\"columnNames\") List<String> columnNames,\n+      @JsonProperty(\"columnTypes\") List<ValueType> columnTypes,\n+      @JsonProperty(\"rows\") List<Object[]> rows\n+  )\n+  {\n+    return new InlineDataSource(columnNames, columnTypes, rows);\n+  }\n+\n+  /**\n+   * Creates an inline datasource from an Iterable. The Iterable will not be iterated until someone calls\n+   * {@link #getRows()} and iterates the result, or until someone calls {@link #getRowsAsList()}.\n+   *\n+   * @param columnNames names of each column in the rows\n+   * @param columnTypes types of each column in the rows\n+   * @param rows        rows, each of the same length as columnNames and columnTypes\n+   */\n+  public static InlineDataSource fromIterable(\n+      final List<String> columnNames,\n+      final List<ValueType> columnTypes,\n+      final Iterable<Object[]> rows\n+  )\n+  {\n+    return new InlineDataSource(columnNames, columnTypes, rows);\n+  }\n+\n+  @Override\n+  public Set<String> getTableNames()\n+  {\n+    return Collections.emptySet();\n+  }\n+\n+  @JsonProperty\n+  public List<String> getColumnNames()\n+  {\n+    return columnNames;\n+  }\n+\n+  @JsonProperty\n+  public List<ValueType> getColumnTypes()\n+  {\n+    return columnTypes;\n+  }\n+\n+  /**\n+   * Returns rows as a list. If the original Iterable behind this datasource was a List, this method will return it\n+   * as-is, without copying it. Otherwise, this method will walk the iterable and copy it into a List before returning.\n+   */\n+  @JsonProperty(\"rows\")\n+  public List<Object[]> getRowsAsList()\n+  {\n+    return rows instanceof List ? ((List<Object[]>) rows) : Lists.newArrayList(rows);\n+  }\n+\n+  /**\n+   * Returns rows as an Iterable.\n+   */\n+  @JsonIgnore\n+  public Iterable<Object[]> getRows()\n+  {\n+    return rows;\n+  }\n+\n+  @Override\n+  public List<DataSource> getChildren()\n+  {\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public DataSource withChildren(List<DataSource> children)\n+  {\n+    if (!children.isEmpty()) {\n+      throw new IAE(\"Cannot accept children\");\n+    }\n+\n+    return this;\n+  }\n+\n+  @Override\n+  public boolean isCacheable()\n+  {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean isGlobal()\n+  {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean isConcrete()\n+  {\n+    return false;\n+  }\n+\n+  public Map<String, ValueType> getRowSignature()\n+  {\n+    final ImmutableMap.Builder<String, ValueType> retVal = ImmutableMap.builder();\n+\n+    for (int i = 0; i < columnNames.size(); i++) {\n+      retVal.put(columnNames.get(i), columnTypes.get(i));\n+    }\n+\n+    return retVal.build();\n+  }\n+\n+  public RowAdapter<Object[]> rowAdapter()\n+  {\n+    return new RowAdapter<Object[]>()\n+    {\n+      @Override\n+      public ToLongFunction<Object[]> timestampFunction()\n+      {\n+        final int columnNumber = columnNames.indexOf(ColumnHolder.TIME_COLUMN_NAME);\n+\n+        if (columnNumber >= 0) {\n+          return row -> (long) row[columnNumber];\n+        } else {\n+          return row -> 0L;\n+        }\n+      }\n+\n+      @Override\n+      public Function<Object[], Object> columnFunction(String columnName)\n+      {\n+        final int columnNumber = columnNames.indexOf(columnName);\n+\n+        if (columnNumber >= 0) {\n+          return row -> row[columnNumber];\n+        } else {\n+          return row -> null;\n+        }\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    InlineDataSource that = (InlineDataSource) o;\n+    return Objects.equals(columnNames, that.columnNames) &&\n+           Objects.equals(columnTypes, that.columnTypes) &&\n+           Objects.equals(rows, that.rows);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(columnNames, columnTypes, rows);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    // Don't include 'rows' in stringificatione, because it might be long and/or lazy.", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMzNzM0NQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369337345", "bodyText": "Good idea, I'll add one (and fix the typo).", "author": "gianm", "createdAt": "2020-01-22T01:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMDEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMzk2Mw==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369313963", "bodyText": "Do you want to add unit tests for these methods?", "author": "ccaominh", "createdAt": "2020-01-22T00:20:25Z", "path": "processing/src/main/java/org/apache/druid/segment/join/Joinables.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.join;\n+\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Utility methods for working with {@link Joinable} related classes.\n+ */\n+public class Joinables", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMzOTIyOA==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369339228", "bodyText": "Good idea, I'll add some.", "author": "gianm", "createdAt": "2020-01-22T02:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMzk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxNzI4Ng==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369317286", "bodyText": "Nice javadoc!", "author": "ccaominh", "createdAt": "2020-01-22T00:33:16Z", "path": "processing/src/main/java/org/apache/druid/query/planning/DataSourceAnalysis.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.planning;\n+\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.Pair;\n+import org.apache.druid.query.BaseQuery;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.query.spec.QuerySegmentSpec;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * Analysis of a datasource for purposes of deciding how to execute a particular query.\n+ *\n+ * The analysis breaks a datasource down in the following way:\n+ *\n+ * <pre>\n+ *\n+ *                             Q  <-- Possible outer query datasource(s) [may be multiple stacked]\n+ *                             |\n+ *                             J  <-- Possible join tree, expected to be left-leaning\n+ *                            / \\\n+ *                           J  Dj <--  Other leaf datasources\n+ *   Base datasource        / \\         which will be joined\n+ *  (bottom-leftmost) -->  Db Dj  <---- into the base datasource\n+ *\n+ * </pre>\n+ *\n+ * The base datasource (Db) is returned by {@link #getBaseDataSource()}. The other leaf datasources are returned by\n+ * {@link #getPreJoinableClauses()}. The outer query datasources are available as part of {@link #getDataSource()},\n+ * which just returns the original datasource that was provided for analysis.\n+ *\n+ * The base datasource (Db) will never be a join, but it can be any other type of datasource (table, query, etc).\n+ * Note that join trees are only flattened if they occur at the top of the overall tree (or underneath an outer query),\n+ * and that join trees are only flattened to the degree that they are left-leaning. Due to these facts, it is possible\n+ * for the base or leaf datasources to include additional joins.\n+ *\n+ * The base datasource is the one that will be considered by the core Druid query stack for scanning via\n+ * {@link org.apache.druid.segment.Segment} and {@link org.apache.druid.segment.StorageAdapter}. The other leaf\n+ * datasources must be joinable onto the base data.\n+ *\n+ * The idea here is to keep things simple and dumb. So we focus only on identifying left-leaning join trees, which map\n+ * neatly onto a series of hash table lookups at query time. The user/system generating the queries, e.g. the druid-sql\n+ * layer (or the end user in the case of native queries), is responsible for containing the smarts to structure the\n+ * tree in a way that will lead to optimal execution.\n+ */", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM0NTk5Ng==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369345996", "bodyText": "ASCII art is what it's all about.", "author": "gianm", "createdAt": "2020-01-22T02:40:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxNzI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMjAxNQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369322015", "bodyText": "Do you want to add an EqualsVerifier test?", "author": "ccaominh", "createdAt": "2020-01-22T00:51:46Z", "path": "processing/src/test/java/org/apache/druid/query/planning/DataSourceAnalysisTest.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.planning;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.InlineDataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.LookupDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.query.groupby.GroupByQuery;\n+import org.apache.druid.query.spec.MultipleIntervalSegmentSpec;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.join.JoinConditionAnalysis;\n+import org.apache.druid.segment.join.JoinType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+public class DataSourceAnalysisTest\n+{\n+  private static final TableDataSource TABLE_FOO = new TableDataSource(\"foo\");\n+  private static final TableDataSource TABLE_BAR = new TableDataSource(\"bar\");\n+  private static final LookupDataSource LOOKUP_LOOKYLOO = new LookupDataSource(\"lookyloo\");\n+  private static final InlineDataSource INLINE = InlineDataSource.fromIterable(\n+      ImmutableList.of(\"column\"),\n+      ImmutableList.of(ValueType.STRING),\n+      ImmutableList.of(new Object[0])\n+  );\n+\n+  @Test\n+  public void testTable()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(TABLE_FOO);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(TABLE_FOO, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(unionDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(unionDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnTable()\n+  {\n+    final QueryDataSource queryDataSource = subquery(TABLE_FOO);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final QueryDataSource queryDataSource = subquery(unionDataSource);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testLookup()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(LOOKUP_LOOKYLOO);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnLookup()\n+  {\n+    final QueryDataSource queryDataSource = new QueryDataSource(\n+        GroupByQuery.builder()\n+                    .setDataSource(LOOKUP_LOOKYLOO)\n+                    .setInterval(new MultipleIntervalSegmentSpec(Collections.singletonList(Intervals.of(\"2000/3000\"))))\n+                    .setGranularity(Granularities.ALL)\n+                    .build()\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testInline()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(INLINE);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(INLINE, analysis.getDataSource());\n+    Assert.assertEquals(INLINE, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testJoinSimpleLeftLeaning()\n+  {\n+    // Join of a table onto a variety of simple joinable objects (lookup, inline, subquery) with a left-leaning\n+    // structure (no right children are joins themselves).\n+\n+    final JoinDataSource joinDataSource =\n+        join(\n+            join(\n+                join(\n+                    TABLE_FOO,\n+                    LOOKUP_LOOKYLOO,\n+                    \"1.\",\n+                    JoinType.INNER\n+                ),\n+                INLINE,\n+                \"2.\",\n+                JoinType.LEFT\n+            ),\n+            subquery(LOOKUP_LOOKYLOO),\n+            \"3.\",\n+            JoinType.FULL\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\")),\n+            new PreJoinableClause(\"2.\", INLINE, JoinType.LEFT, joinClause(\"2.\")),\n+            new PreJoinableClause(\"3.\", subquery(LOOKUP_LOOKYLOO), JoinType.FULL, joinClause(\"3.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinSimpleRightLeaning()\n+  {\n+    // Join of a table onto a variety of simple joinable objects (lookup, inline, subquery) with a right-leaning\n+    // structure (no left children are joins themselves).\n+    //\n+    // Note that unlike the left-leaning stack, which is fully flattened, this one will not get flattened at all.\n+\n+    final JoinDataSource rightLeaningJoinStack =\n+        join(\n+            LOOKUP_LOOKYLOO,\n+            join(\n+                INLINE,\n+                subquery(LOOKUP_LOOKYLOO),\n+                \"1.\",\n+                JoinType.LEFT\n+            ),\n+            \"2.\",\n+            JoinType.FULL\n+        );\n+\n+    final JoinDataSource joinDataSource =\n+        join(\n+            TABLE_FOO,\n+            rightLeaningJoinStack,\n+            \"3.\",\n+            JoinType.RIGHT\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"3.\", rightLeaningJoinStack, JoinType.RIGHT, joinClause(\"3.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinOverTableSubquery()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        TABLE_FOO,\n+        subquery(TABLE_FOO),\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", subquery(TABLE_FOO), JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinTableUnionToLookup()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final JoinDataSource joinDataSource = join(\n+        unionDataSource,\n+        LOOKUP_LOOKYLOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinUnderTopLevelSubqueries()\n+  {\n+    final QueryDataSource queryDataSource =\n+        subquery(\n+            subquery(\n+                join(\n+                    TABLE_FOO,\n+                    LOOKUP_LOOKYLOO,\n+                    \"1.\",\n+                    JoinType.INNER\n+                )\n+            )\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinLookupToLookup()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        LOOKUP_LOOKYLOO,\n+        LOOKUP_LOOKYLOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinLookupToTable()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        LOOKUP_LOOKYLOO,\n+        TABLE_FOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", TABLE_FOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMzOTk2Nw==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369339967", "bodyText": "Yeah, I'll add one.", "author": "gianm", "createdAt": "2020-01-22T02:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMjAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMzI1MQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369323251", "bodyText": "Looks like you can use subquery(LOOKUP_LOOKYLOO) here instead?", "author": "ccaominh", "createdAt": "2020-01-22T00:56:58Z", "path": "processing/src/test/java/org/apache/druid/query/planning/DataSourceAnalysisTest.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.planning;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.InlineDataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.LookupDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.query.groupby.GroupByQuery;\n+import org.apache.druid.query.spec.MultipleIntervalSegmentSpec;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.join.JoinConditionAnalysis;\n+import org.apache.druid.segment.join.JoinType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+public class DataSourceAnalysisTest\n+{\n+  private static final TableDataSource TABLE_FOO = new TableDataSource(\"foo\");\n+  private static final TableDataSource TABLE_BAR = new TableDataSource(\"bar\");\n+  private static final LookupDataSource LOOKUP_LOOKYLOO = new LookupDataSource(\"lookyloo\");\n+  private static final InlineDataSource INLINE = InlineDataSource.fromIterable(\n+      ImmutableList.of(\"column\"),\n+      ImmutableList.of(ValueType.STRING),\n+      ImmutableList.of(new Object[0])\n+  );\n+\n+  @Test\n+  public void testTable()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(TABLE_FOO);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(TABLE_FOO, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(unionDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(unionDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnTable()\n+  {\n+    final QueryDataSource queryDataSource = subquery(TABLE_FOO);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final QueryDataSource queryDataSource = subquery(unionDataSource);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testLookup()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(LOOKUP_LOOKYLOO);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnLookup()\n+  {\n+    final QueryDataSource queryDataSource = new QueryDataSource(\n+        GroupByQuery.builder()\n+                    .setDataSource(LOOKUP_LOOKYLOO)\n+                    .setInterval(new MultipleIntervalSegmentSpec(Collections.singletonList(Intervals.of(\"2000/3000\"))))\n+                    .setGranularity(Granularities.ALL)\n+                    .build()\n+    );", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM0NTUwOQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369345509", "bodyText": "You're right, I'll change it.", "author": "gianm", "createdAt": "2020-01-22T02:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMzI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyNTE0OQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369325149", "bodyText": "Perhaps create a named constant for the interval since it's in the asserts for several of the new tests", "author": "ccaominh", "createdAt": "2020-01-22T01:05:08Z", "path": "processing/src/test/java/org/apache/druid/query/planning/DataSourceAnalysisTest.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.planning;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.InlineDataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.LookupDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.query.groupby.GroupByQuery;\n+import org.apache.druid.query.spec.MultipleIntervalSegmentSpec;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.join.JoinConditionAnalysis;\n+import org.apache.druid.segment.join.JoinType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+public class DataSourceAnalysisTest\n+{\n+  private static final TableDataSource TABLE_FOO = new TableDataSource(\"foo\");\n+  private static final TableDataSource TABLE_BAR = new TableDataSource(\"bar\");\n+  private static final LookupDataSource LOOKUP_LOOKYLOO = new LookupDataSource(\"lookyloo\");\n+  private static final InlineDataSource INLINE = InlineDataSource.fromIterable(\n+      ImmutableList.of(\"column\"),\n+      ImmutableList.of(ValueType.STRING),\n+      ImmutableList.of(new Object[0])\n+  );\n+\n+  @Test\n+  public void testTable()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(TABLE_FOO);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(TABLE_FOO, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(unionDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(unionDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnTable()\n+  {\n+    final QueryDataSource queryDataSource = subquery(TABLE_FOO);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final QueryDataSource queryDataSource = subquery(unionDataSource);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testLookup()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(LOOKUP_LOOKYLOO);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnLookup()\n+  {\n+    final QueryDataSource queryDataSource = new QueryDataSource(\n+        GroupByQuery.builder()\n+                    .setDataSource(LOOKUP_LOOKYLOO)\n+                    .setInterval(new MultipleIntervalSegmentSpec(Collections.singletonList(Intervals.of(\"2000/3000\"))))\n+                    .setGranularity(Granularities.ALL)\n+                    .build()\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testInline()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(INLINE);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(INLINE, analysis.getDataSource());\n+    Assert.assertEquals(INLINE, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testJoinSimpleLeftLeaning()\n+  {\n+    // Join of a table onto a variety of simple joinable objects (lookup, inline, subquery) with a left-leaning\n+    // structure (no right children are joins themselves).\n+\n+    final JoinDataSource joinDataSource =\n+        join(\n+            join(\n+                join(\n+                    TABLE_FOO,\n+                    LOOKUP_LOOKYLOO,\n+                    \"1.\",\n+                    JoinType.INNER\n+                ),\n+                INLINE,\n+                \"2.\",\n+                JoinType.LEFT\n+            ),\n+            subquery(LOOKUP_LOOKYLOO),\n+            \"3.\",\n+            JoinType.FULL\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\")),\n+            new PreJoinableClause(\"2.\", INLINE, JoinType.LEFT, joinClause(\"2.\")),\n+            new PreJoinableClause(\"3.\", subquery(LOOKUP_LOOKYLOO), JoinType.FULL, joinClause(\"3.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinSimpleRightLeaning()\n+  {\n+    // Join of a table onto a variety of simple joinable objects (lookup, inline, subquery) with a right-leaning\n+    // structure (no left children are joins themselves).\n+    //\n+    // Note that unlike the left-leaning stack, which is fully flattened, this one will not get flattened at all.\n+\n+    final JoinDataSource rightLeaningJoinStack =\n+        join(\n+            LOOKUP_LOOKYLOO,\n+            join(\n+                INLINE,\n+                subquery(LOOKUP_LOOKYLOO),\n+                \"1.\",\n+                JoinType.LEFT\n+            ),\n+            \"2.\",\n+            JoinType.FULL\n+        );\n+\n+    final JoinDataSource joinDataSource =\n+        join(\n+            TABLE_FOO,\n+            rightLeaningJoinStack,\n+            \"3.\",\n+            JoinType.RIGHT\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"3.\", rightLeaningJoinStack, JoinType.RIGHT, joinClause(\"3.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinOverTableSubquery()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        TABLE_FOO,\n+        subquery(TABLE_FOO),\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", subquery(TABLE_FOO), JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinTableUnionToLookup()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final JoinDataSource joinDataSource = join(\n+        unionDataSource,\n+        LOOKUP_LOOKYLOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinUnderTopLevelSubqueries()\n+  {\n+    final QueryDataSource queryDataSource =\n+        subquery(\n+            subquery(\n+                join(\n+                    TABLE_FOO,\n+                    LOOKUP_LOOKYLOO,\n+                    \"1.\",\n+                    JoinType.INNER\n+                )\n+            )\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinLookupToLookup()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        LOOKUP_LOOKYLOO,\n+        LOOKUP_LOOKYLOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinLookupToTable()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        LOOKUP_LOOKYLOO,\n+        TABLE_FOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", TABLE_FOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  /**\n+   * Generate a datasource that joins on a column named \"x\" on both sides.\n+   */\n+  private static JoinDataSource join(\n+      final DataSource left,\n+      final DataSource right,\n+      final String rightPrefix,\n+      final JoinType joinType\n+  )\n+  {\n+    return JoinDataSource.create(\n+        left,\n+        right,\n+        rightPrefix,\n+        joinClause(rightPrefix).getOriginalExpression(),\n+        joinType,\n+        ExprMacroTable.nil()\n+    );\n+  }\n+\n+  /**\n+   * Generate a join clause that joins on a column named \"x\" on both sides.\n+   */\n+  private static JoinConditionAnalysis joinClause(\n+      final String rightPrefix\n+  )\n+  {\n+    return JoinConditionAnalysis.forExpression(\n+        StringUtils.format(\"x == \\\"%sx\\\"\", rightPrefix),\n+        rightPrefix,\n+        ExprMacroTable.nil()\n+    );\n+  }\n+\n+  /**\n+   * Generate a datasource that does a subquery on another datasource. The specific kind of query doesn't matter\n+   * much for the purpose of this test class, so it's always the same.\n+   */\n+  private static QueryDataSource subquery(final DataSource dataSource)\n+  {\n+    return new QueryDataSource(\n+        GroupByQuery.builder()\n+                    .setDataSource(dataSource)\n+                    .setInterval(new MultipleIntervalSegmentSpec(Collections.singletonList(Intervals.of(\"2000/3000\"))))", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM0NTg1Nw==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369345857", "bodyText": "Sure, sounds reasonable.", "author": "gianm", "createdAt": "2020-01-22T02:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyNTE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1NDkzNQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369254935", "bodyText": "\ud83d\udc4d this seems like a good intermediary solution until we fix the issue for real", "author": "clintropolis", "createdAt": "2020-01-21T21:34:29Z", "path": "processing/src/main/java/org/apache/druid/query/UnionDataSource.java", "diffHunk": "@@ -52,6 +57,51 @@ public UnionDataSource(@JsonProperty(\"dataSources\") List<TableDataSource> dataSo\n     return dataSources;\n   }\n \n+  @Override\n+  public List<DataSource> getChildren()\n+  {\n+    return ImmutableList.copyOf(dataSources);\n+  }\n+\n+  @Override\n+  public DataSource withChildren(List<DataSource> children)\n+  {\n+    if (children.size() != dataSources.size()) {\n+      throw new IAE(\"Expected [%d] children, got [%d]\", dataSources.size(), children.size());\n+    }\n+\n+    if (!children.stream().allMatch(dataSource -> dataSource instanceof TableDataSource)) {\n+      throw new IAE(\"All children must be tables\");\n+    }\n+\n+    return new UnionDataSource(\n+        children.stream().map(dataSource -> (TableDataSource) dataSource).collect(Collectors.toList())\n+    );\n+  }\n+\n+  @Override\n+  public boolean isCacheable()\n+  {\n+    // Disables result-level caching for 'union' datasources, which doesn't work currently.\n+    // See https://github.com/apache/druid/issues/8713 for reference.", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1OTkwMw==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369259903", "bodyText": "\ud83e\udd18", "author": "clintropolis", "createdAt": "2020-01-21T21:46:04Z", "path": "processing/src/main/java/org/apache/druid/query/InlineDataSource.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.RowAdapter;\n+import org.apache.druid.segment.column.ColumnHolder;\n+import org.apache.druid.segment.column.ValueType;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.ToLongFunction;\n+\n+/**\n+ * Represents an inline datasource, where the rows are embedded within the DataSource object itself.\n+ *\n+ * The rows are backed by an Iterable, which can be lazy or not. Lazy datasources will only be iterated if someone calls\n+ * {@link #getRows()} and iterates the result, or until someone calls {@link #getRowsAsList()}.\n+ */\n+public class InlineDataSource implements DataSource", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxMDgzMg==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369410832", "bodyText": "curious about why this change. I know this isn't really part of your change, but I've also noticed equals and hashcode for a lot of classes that extend BaseQuery have their own implementation of equals and hashCode and do not check the base class. Sounds like we should add some equalsVerifier tests for them, maybe in another patch.", "author": "suneet-s", "createdAt": "2020-01-22T07:54:26Z", "path": "processing/src/main/java/org/apache/druid/query/BaseQuery.java", "diffHunk": "@@ -270,14 +270,13 @@ public boolean equals(Object o)\n            Objects.equals(dataSource, baseQuery.dataSource) &&\n            Objects.equals(context, baseQuery.context) &&\n            Objects.equals(querySegmentSpec, baseQuery.querySegmentSpec) &&\n-           Objects.equals(duration, baseQuery.duration) &&\n+           Objects.equals(getDuration(), baseQuery.getDuration()) &&\n            Objects.equals(granularity, baseQuery.granularity);\n   }\n \n   @Override\n   public int hashCode()\n   {\n-\n-    return Objects.hash(dataSource, descending, context, querySegmentSpec, duration, granularity);", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcwMTE5NQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369701195", "bodyText": "It's because duration is lazily computed, so it might be null. Calling getDuration() forces it to be computed. I'll add a comment.\nBtw, a lot of the subclasses of BaseQuery do call super.equals at some point (but they do other stuff too).", "author": "gianm", "createdAt": "2020-01-22T17:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxMDgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcxNTg3OQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369715879", "bodyText": "Weird  - I see the calls to super.equals() now, maybe I just shouldn't read code in the night \ud83d\ude1d\nEqualsVerifier is still complaining about some other stuff. But cleaning that up can be another issue.", "author": "suneet-s", "createdAt": "2020-01-22T18:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxMDgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQyMzc0OA==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369423748", "bodyText": "why must these sizes match?", "author": "suneet-s", "createdAt": "2020-01-22T08:30:42Z", "path": "processing/src/main/java/org/apache/druid/query/UnionDataSource.java", "diffHunk": "@@ -52,6 +57,51 @@ public UnionDataSource(@JsonProperty(\"dataSources\") List<TableDataSource> dataSo\n     return dataSources;\n   }\n \n+  @Override\n+  public List<DataSource> getChildren()\n+  {\n+    return ImmutableList.copyOf(dataSources);\n+  }\n+\n+  @Override\n+  public DataSource withChildren(List<DataSource> children)\n+  {\n+    if (children.size() != dataSources.size()) {", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcwMDI3NQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369700275", "bodyText": "It's a precondition for the method, since its intent is for replacing inputs with inlined/etc versions, so the number of children shouldn't change. I'll add a comment in the interface.", "author": "gianm", "createdAt": "2020-01-22T17:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQyMzc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQyODExNA==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369428114", "bodyText": "@NonNull annotations for the parameters?", "author": "suneet-s", "createdAt": "2020-01-22T08:41:22Z", "path": "processing/src/main/java/org/apache/druid/segment/join/Joinables.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.join;\n+\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Utility methods for working with {@link Joinable} related classes.\n+ */\n+public class Joinables\n+{\n+  /**\n+   * Checks that \"prefix\" is a valid prefix for a join clause (see {@link JoinableClause#getPrefix()}) and, if so,\n+   * returns it. Otherwise, throws an exception.\n+   */\n+  public static String validatePrefix(@Nullable final String prefix)\n+  {\n+    if (prefix == null) {\n+      throw new IAE(\"Join clause cannot have null prefix\");\n+    } else if (isPrefixedBy(ColumnHolder.TIME_COLUMN_NAME, prefix) || ColumnHolder.TIME_COLUMN_NAME.equals(prefix)) {\n+      throw new IAE(\n+          \"Join clause cannot have prefix[%s], since it would shadow %s\",\n+          prefix,\n+          ColumnHolder.TIME_COLUMN_NAME\n+      );\n+    } else {\n+      return prefix;\n+    }\n+  }\n+\n+  public static boolean isPrefixedBy(final String columnName, final String prefix)", "originalCommit": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcwMDY0Nw==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369700647", "bodyText": "I think I'd prefer @EverythingIsNonnullByDefault (which is how I prefer to write/read code usually anyway). We use it in a few other packages in Druid. Maybe we can add that here in a future patch?", "author": "gianm", "createdAt": "2020-01-22T17:31:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQyODExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcwOTIwMw==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369709203", "bodyText": "Works for me! I haven't gotten in the habit of looking out for those annotations yet, but I love the idea of NonnullBy default!", "author": "suneet-s", "createdAt": "2020-01-22T17:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQyODExNA=="}], "type": "inlineReview"}, {"oid": "385bd754bf973a5ca4d432e093f40227c8259ecf", "url": "https://github.com/apache/druid/commit/385bd754bf973a5ca4d432e093f40227c8259ecf", "message": "Updates reflecting code review.", "committedDate": "2020-01-22T17:27:19Z", "type": "commit"}, {"oid": "2b81140fc9ab9894c78273dfaa5684da529aa583", "url": "https://github.com/apache/druid/commit/2b81140fc9ab9894c78273dfaa5684da529aa583", "message": "Add comments.", "committedDate": "2020-01-22T17:29:48Z", "type": "commit"}, {"oid": "2f21089a95906b80017426b98bc59e9b72f1c278", "url": "https://github.com/apache/druid/commit/2f21089a95906b80017426b98bc59e9b72f1c278", "message": "Add more comments.", "committedDate": "2020-01-22T17:31:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgxNzUwMQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369817501", "bodyText": "I tried adding rows to toString and it doesn't iterate over rowsIterable (it prints an identifier for the lambda).", "author": "ccaominh", "createdAt": "2020-01-22T21:38:13Z", "path": "processing/src/test/java/org/apache/druid/query/InlineDataSourceTest.java", "diffHunk": "@@ -225,6 +225,14 @@ public void test_equals()\n                   .verify();\n   }\n \n+  @Test\n+  public void test_toString_iterable()\n+  {\n+    // Verify that toString does not iterate the rows.\n+    final String ignored = iterableDataSource.toString();\n+    Assert.assertEquals(0, iterationCounter.get());", "originalCommit": "2f21089a95906b80017426b98bc59e9b72f1c278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgzMjk0Mg==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369832942", "bodyText": "Yeah, that makes sense. I guess the behavior would depend on whatever the particular Iterable\u2019s toString method does. Do you think it makes sense to leave the test like this it change it somehow?", "author": "gianm", "createdAt": "2020-01-22T22:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgxNzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0OTU5NQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369849595", "bodyText": "I'm ok with leaving the test as it is for now.", "author": "ccaominh", "createdAt": "2020-01-22T22:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgxNzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg1MDM0OQ==", "url": "https://github.com/apache/druid/pull/9235#discussion_r369850349", "bodyText": "Any suggestions for how to improve it in a follow-up?", "author": "gianm", "createdAt": "2020-01-22T22:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgxNzUwMQ=="}], "type": "inlineReview"}]}