{"pr_number": 9734, "pr_title": "Initialize SettableByteEntityReader only when inputFormat is not null", "pr_createdAt": "2020-04-21T17:40:31Z", "pr_url": "https://github.com/apache/druid/pull/9734", "timeline": [{"oid": "1fcfd6d26bb59f2779f39dc9345d29f0eea63c56", "url": "https://github.com/apache/druid/commit/1fcfd6d26bb59f2779f39dc9345d29f0eea63c56", "message": "Lazy initialization of SettableByteEntityReader to avoid NPE", "committedDate": "2020-04-21T17:35:54Z", "type": "commit"}, {"oid": "d452d1c018d435968b189c6274b79442a08f863d", "url": "https://github.com/apache/druid/commit/d452d1c018d435968b189c6274b79442a08f863d", "message": "toInputFormat for tsv", "committedDate": "2020-04-21T17:55:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MjYzNw==", "url": "https://github.com/apache/druid/pull/9734#discussion_r412472637", "bodyText": "nit: this error message should be \"Either parser or inputFormat should be set\" maybe since this is checking if both are null?", "author": "clintropolis", "createdAt": "2020-04-21T20:34:44Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/StreamChunkParser.java", "diffHunk": "@@ -38,20 +45,38 @@\n {\n   @Nullable\n   private final InputRowParser<ByteBuffer> parser;\n-  private final SettableByteEntityReader byteEntityReader;\n+  private final Supplier<SettableByteEntityReader> lazyByteEntityReaderSupplier; // lazy initializer\n \n-  StreamChunkParser(@Nullable InputRowParser<ByteBuffer> parser, SettableByteEntityReader byteEntityReader)\n+  /**\n+   * Either parser or inputFormat shouldn't be null.\n+   */\n+  StreamChunkParser(\n+      @Nullable InputRowParser<ByteBuffer> parser,\n+      @Nullable InputFormat inputFormat,\n+      InputRowSchema inputRowSchema,\n+      TransformSpec transformSpec,\n+      File indexingTmpDir\n+  )\n   {\n+    if (parser == null && inputFormat == null) {\n+      throw new IAE(\"Either parser or inputFormat shouldn't be set\");", "originalCommit": "d452d1c018d435968b189c6274b79442a08f863d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4NzYxNQ==", "url": "https://github.com/apache/druid/pull/9734#discussion_r412487615", "bodyText": "Oops, thanks.", "author": "jihoonson", "createdAt": "2020-04-21T21:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MjYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MzU4Mw==", "url": "https://github.com/apache/druid/pull/9734#discussion_r412473583", "bodyText": "Would it be better to prefer the inputFormat if it exists?", "author": "clintropolis", "createdAt": "2020-04-21T20:36:15Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/StreamChunkParser.java", "diffHunk": "@@ -38,20 +45,38 @@\n {\n   @Nullable\n   private final InputRowParser<ByteBuffer> parser;\n-  private final SettableByteEntityReader byteEntityReader;\n+  private final Supplier<SettableByteEntityReader> lazyByteEntityReaderSupplier; // lazy initializer\n \n-  StreamChunkParser(@Nullable InputRowParser<ByteBuffer> parser, SettableByteEntityReader byteEntityReader)\n+  /**\n+   * Either parser or inputFormat shouldn't be null.\n+   */\n+  StreamChunkParser(\n+      @Nullable InputRowParser<ByteBuffer> parser,\n+      @Nullable InputFormat inputFormat,\n+      InputRowSchema inputRowSchema,\n+      TransformSpec transformSpec,\n+      File indexingTmpDir\n+  )\n   {\n+    if (parser == null && inputFormat == null) {\n+      throw new IAE(\"Either parser or inputFormat shouldn't be set\");\n+    }\n     this.parser = parser;\n-    this.byteEntityReader = byteEntityReader;\n+    // Create a lazy initializer since it will fail to create a SettableByteEntityReader if inputFormat is null\n+    this.lazyByteEntityReaderSupplier = Suppliers.memoize(() -> new SettableByteEntityReader(\n+        inputFormat,\n+        inputRowSchema,\n+        transformSpec,\n+        indexingTmpDir\n+    ));\n   }\n \n   List<InputRow> parse(List<byte[]> streamChunk) throws IOException\n   {\n     if (parser != null) {\n       return parseWithParser(parser, streamChunk);\n     } else {\n-      return parseWithInputFormat(byteEntityReader, streamChunk);\n+      return parseWithInputFormat(lazyByteEntityReaderSupplier.get(), streamChunk);", "originalCommit": "d452d1c018d435968b189c6274b79442a08f863d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4ODA1Nw==", "url": "https://github.com/apache/druid/pull/9734#discussion_r412488057", "bodyText": "Changed to prefer inputFormat.", "author": "jihoonson", "createdAt": "2020-04-21T21:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3MzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NTEwOQ==", "url": "https://github.com/apache/druid/pull/9734#discussion_r412475109", "bodyText": "nit: Why a supplier instead of just making byteEntityReader @Nullable? it seems like it would not be used if parser is not null.", "author": "clintropolis", "createdAt": "2020-04-21T20:38:45Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/StreamChunkParser.java", "diffHunk": "@@ -38,20 +45,38 @@\n {\n   @Nullable\n   private final InputRowParser<ByteBuffer> parser;\n-  private final SettableByteEntityReader byteEntityReader;\n+  private final Supplier<SettableByteEntityReader> lazyByteEntityReaderSupplier; // lazy initializer\n \n-  StreamChunkParser(@Nullable InputRowParser<ByteBuffer> parser, SettableByteEntityReader byteEntityReader)\n+  /**\n+   * Either parser or inputFormat shouldn't be null.\n+   */\n+  StreamChunkParser(\n+      @Nullable InputRowParser<ByteBuffer> parser,\n+      @Nullable InputFormat inputFormat,\n+      InputRowSchema inputRowSchema,\n+      TransformSpec transformSpec,\n+      File indexingTmpDir\n+  )\n   {\n+    if (parser == null && inputFormat == null) {\n+      throw new IAE(\"Either parser or inputFormat shouldn't be set\");\n+    }\n     this.parser = parser;\n-    this.byteEntityReader = byteEntityReader;\n+    // Create a lazy initializer since it will fail to create a SettableByteEntityReader if inputFormat is null\n+    this.lazyByteEntityReaderSupplier = Suppliers.memoize(() -> new SettableByteEntityReader(", "originalCommit": "d452d1c018d435968b189c6274b79442a08f863d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4NzgxOA==", "url": "https://github.com/apache/druid/pull/9734#discussion_r412487818", "bodyText": "Changed to nullable.", "author": "jihoonson", "createdAt": "2020-04-21T21:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NTEwOQ=="}], "type": "inlineReview"}, {"oid": "a1acd298348fdf2eacf91b40dad5936dd96d57b4", "url": "https://github.com/apache/druid/commit/a1acd298348fdf2eacf91b40dad5936dd96d57b4", "message": "address comments", "committedDate": "2020-04-21T20:59:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjIxMw==", "url": "https://github.com/apache/druid/pull/9734#discussion_r412496213", "bodyText": "Where is the test that makes sure TSV is handled properly now? Also do we already have a similar test for CSV?", "author": "ccaominh", "createdAt": "2020-04-21T21:14:13Z", "path": "core/src/main/java/org/apache/druid/data/input/impl/DelimitedParseSpec.java", "diffHunk": "@@ -123,6 +124,12 @@ public int getSkipHeaderRows()\n     );\n   }\n \n+  @Override\n+  public InputFormat toInputFormat()", "originalCommit": "a1acd298348fdf2eacf91b40dad5936dd96d57b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxNDIyNQ==", "url": "https://github.com/apache/druid/pull/9734#discussion_r414214225", "bodyText": "What do you mean by \"handling TSV properly\"? This method does nothing useful for now. I think we should remove this method.", "author": "jihoonson", "createdAt": "2020-04-24T00:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIzNDE5NA==", "url": "https://github.com/apache/druid/pull/9734#discussion_r414234194", "bodyText": "Sorry, my comment was more about adding integration tests for streaming ingestion with the various formats, which I believe we're missing. This can be addressed in a follow up PR that tackles the issue comprehensively.", "author": "ccaominh", "createdAt": "2020-04-24T01:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MTIyNQ==", "url": "https://github.com/apache/druid/pull/9734#discussion_r414261225", "bodyText": "Sounds good. I will add some tests with TSV in a follow-up PR.", "author": "jihoonson", "createdAt": "2020-04-24T03:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTYyNQ==", "url": "https://github.com/apache/druid/pull/9734#discussion_r412505625", "bodyText": "I think it would be good to add some tests for this class since it looks like the existing unit tests don't cover this class at all. For example, there's nothing ensuring that parser and inputFormat are both not null when they're passed to the StreamChunkParser constructor.\nAlso, it looks like we only have tests that ensure that real time ingestion works with JSON. We should add a tests to make sure real time ingestion never breaks in the future for Avro, TSV, etc.", "author": "ccaominh", "createdAt": "2020-04-21T21:30:45Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskRunner.java", "diffHunk": "@@ -372,12 +373,10 @@ private TaskStatus runInternal(TaskToolbox toolbox) throws Exception\n     // Now we can initialize StreamChunkReader with the given toolbox.\n     final StreamChunkParser parser = new StreamChunkParser(\n         this.parser,\n-        new SettableByteEntityReader(\n-            inputFormat,\n-            inputRowSchema,\n-            task.getDataSchema().getTransformSpec(),\n-            toolbox.getIndexingTmpDir()\n-        )\n+        inputFormat,", "originalCommit": "a1acd298348fdf2eacf91b40dad5936dd96d57b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxNDI2Ng==", "url": "https://github.com/apache/druid/pull/9734#discussion_r414214266", "bodyText": "I think it would be good to add some tests for this class since it looks like the existing unit tests don't cover this class at all. For example, there's nothing ensuring that parser and inputFormat are both not null when they're passed to the StreamChunkParser constructor.\n\nHmm, I'm not sure I understood your comment. I believe this class is being tested in both KafkaIndexTaskTest and KinesisIndexTaskTest. Either parser or inputFormat can be set for kafka indexing service to work. If both are set, it prefers inputFormat over `parser.\n\nAlso, it looks like we only have tests that ensure that real time ingestion works with JSON. We should add a tests to make sure real time ingestion never breaks in the future for Avro, TSV, etc.\n\nThose tests seem useful, but I don't think adding them should be done in this PR since it's a sort of out of scope; the issue is creating a SettableByteEntityReader can fail with any parser in which toInputFormat is missing. Also, it could be a big change even bigger than this PR. I will add them in a follow-up PR.", "author": "jihoonson", "createdAt": "2020-04-24T00:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIzMzcyNA==", "url": "https://github.com/apache/druid/pull/9734#discussion_r414233724", "bodyText": "Cool, I didn't look at the coverage from KafkaIndexTaskTest and KinesisIndexTaskTest, so my comment can be disregarded.\nAdding the integration tests in a follow up PR sounds good to me since you manually verified your fix for the scenario that uncovered this bug.", "author": "ccaominh", "createdAt": "2020-04-24T01:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTA1MQ==", "url": "https://github.com/apache/druid/pull/9734#discussion_r412509051", "bodyText": "This is repeated for two of the tests below, so may be worth factoring out.", "author": "ccaominh", "createdAt": "2020-04-21T21:37:10Z", "path": "indexing-service/src/test/java/org/apache/druid/indexing/seekablestream/StreamChunkParserTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.seekablestream;\n+\n+import com.google.common.collect.Iterables;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputEntityReader;\n+import org.apache.druid.data.input.InputFormat;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.impl.DimensionsSpec;\n+import org.apache.druid.data.input.impl.InputRowParser;\n+import org.apache.druid.data.input.impl.JSONParseSpec;\n+import org.apache.druid.data.input.impl.JsonInputFormat;\n+import org.apache.druid.data.input.impl.StringInputRowParser;\n+import org.apache.druid.data.input.impl.TimestampSpec;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.segment.transform.TransformSpec;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.TemporaryFolder;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class StreamChunkParserTest\n+{\n+  private static final TimestampSpec TIMESTAMP_SPEC = new TimestampSpec(null, null, null);\n+\n+  @Rule\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  @Test\n+  public void testWithParserAndNullInputformatParseProperly() throws IOException\n+  {\n+    final InputRowParser<ByteBuffer> parser = new StringInputRowParser(\n+        new NotConvertibleToInputFormatParseSpec(),\n+        StringUtils.UTF8_STRING\n+    );\n+    final StreamChunkParser chunkParser = new StreamChunkParser(\n+        parser,\n+        // Set nulls for all parameters below since inputFormat will be never used.\n+        null,\n+        null,\n+        null,\n+        null\n+    );\n+    final String json = \"{\\\"timestamp\\\": \\\"2020-01-01\\\", \\\"dim\\\": \\\"val\\\", \\\"met\\\": \\\"val2\\\"}\";\n+    List<InputRow> parsedRows = chunkParser.parse(Collections.singletonList(json.getBytes(StringUtils.UTF8_STRING)));\n+    Assert.assertEquals(1, parsedRows.size());\n+    InputRow row = parsedRows.get(0);\n+    Assert.assertEquals(DateTimes.of(\"2020-01-01\"), row.getTimestamp());\n+    Assert.assertEquals(\"val\", Iterables.getOnlyElement(row.getDimension(\"dim\")));\n+    Assert.assertEquals(\"val2\", Iterables.getOnlyElement(row.getDimension(\"met\")));", "originalCommit": "a1acd298348fdf2eacf91b40dad5936dd96d57b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDIxNDI0MA==", "url": "https://github.com/apache/druid/pull/9734#discussion_r414214240", "bodyText": "Done.", "author": "jihoonson", "createdAt": "2020-04-24T00:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTA1MQ=="}], "type": "inlineReview"}, {"oid": "1d3f79602e0ecc40bdc695592e20167cc10682ee", "url": "https://github.com/apache/druid/commit/1d3f79602e0ecc40bdc695592e20167cc10682ee", "message": "common code", "committedDate": "2020-04-24T00:08:02Z", "type": "commit"}]}