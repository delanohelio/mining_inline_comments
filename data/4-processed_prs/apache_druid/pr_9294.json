{"pr_number": 9294, "pr_title": "SQL join support for lookups.", "pr_createdAt": "2020-01-30T22:49:08Z", "pr_url": "https://github.com/apache/druid/pull/9294", "timeline": [{"oid": "bb714014f7ac3bb9947850375e51f002c81010c7", "url": "https://github.com/apache/druid/commit/bb714014f7ac3bb9947850375e51f002c81010c7", "message": "SQL join support for lookups.\n\n1) Add LookupSchema to SQL, so lookups show up in the catalog.\n2) Add join-related rels and rules to SQL, allowing joins to be planned into\n   native Druid queries.", "committedDate": "2020-01-30T23:02:29Z", "type": "commit"}, {"oid": "bb714014f7ac3bb9947850375e51f002c81010c7", "url": "https://github.com/apache/druid/commit/bb714014f7ac3bb9947850375e51f002c81010c7", "message": "SQL join support for lookups.\n\n1) Add LookupSchema to SQL, so lookups show up in the catalog.\n2) Add join-related rels and rules to SQL, allowing joins to be planned into\n   native Druid queries.", "committedDate": "2020-01-30T23:02:29Z", "type": "forcePushed"}, {"oid": "18cc3767d57ca36d54f50ae55254121993f67c1e", "url": "https://github.com/apache/druid/commit/18cc3767d57ca36d54f50ae55254121993f67c1e", "message": "Add two missing LookupSchema calls in tests.", "committedDate": "2020-01-30T23:42:48Z", "type": "commit"}, {"oid": "9150ac699ecd56021efca4828b6b07a6b8d56c4c", "url": "https://github.com/apache/druid/commit/9150ac699ecd56021efca4828b6b07a6b8d56c4c", "message": "Fix tests.", "committedDate": "2020-01-31T01:12:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0MzUxMA==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373243510", "bodyText": "excluduing -> excluding", "author": "jon-wei", "createdAt": "2020-01-30T23:10:44Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.Pair;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.join.JoinType;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.planner.Calcites;\n+import org.apache.druid.sql.calcite.table.RowSignature;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * DruidRel that uses a {@link JoinDataSource}.\n+ */\n+public class DruidJoinQueryRel extends DruidRel<DruidJoinQueryRel>\n+{\n+  private static final TableDataSource DUMMY_DATA_SOURCE = new TableDataSource(\"__join__\");\n+  private static final double COST_FACTOR = 100.0;\n+\n+  private final PartialDruidQuery partialQuery;\n+  private final Join joinRel;\n+  private RelNode left;\n+  private RelNode right;\n+\n+  private DruidJoinQueryRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      Join joinRel,\n+      PartialDruidQuery partialQuery,\n+      QueryMaker queryMaker\n+  )\n+  {\n+    super(cluster, traitSet, queryMaker);\n+    this.joinRel = joinRel;\n+    this.left = joinRel.getLeft();\n+    this.right = joinRel.getRight();\n+    this.partialQuery = partialQuery;\n+  }\n+\n+  public static DruidJoinQueryRel create(final Join joinRel, final QueryMaker queryMaker)\n+  {\n+    return new DruidJoinQueryRel(\n+        joinRel.getCluster(),\n+        joinRel.getTraitSet(),\n+        joinRel,\n+        PartialDruidQuery.create(joinRel),\n+        queryMaker\n+    );\n+  }\n+\n+  @Override\n+  public PartialDruidQuery getPartialDruidQuery()\n+  {\n+    return partialQuery;\n+  }\n+\n+  @Override\n+  public Sequence<Object[]> runQuery()\n+  {\n+    // runQuery doesn't need to finalize aggregations, because the fact that runQuery is happening suggests this\n+    // is the outermost query and it will actually get run as a native query. Druid's native query layer will\n+    // finalize aggregations for the outermost query even if we don't explicitly ask it to.\n+\n+    final DruidQuery query = toDruidQuery(false);\n+    return getQueryMaker().runQuery(query);\n+  }\n+\n+  @Override\n+  public DruidJoinQueryRel withPartialQuery(final PartialDruidQuery newQueryBuilder)\n+  {\n+    return new DruidJoinQueryRel(\n+        getCluster(),\n+        getTraitSet().plusAll(newQueryBuilder.getRelTraits()),\n+        joinRel,\n+        newQueryBuilder,\n+        getQueryMaker()\n+    );\n+  }\n+\n+  @Override\n+  public int getQueryCount()\n+  {\n+    return ((DruidRel<?>) left).getQueryCount() + ((DruidRel<?>) right).getQueryCount();\n+  }\n+\n+  @Override\n+  public DruidQuery toDruidQuery(final boolean finalizeAggregations)\n+  {\n+    final DruidRel<?> leftDruidRel = (DruidRel<?>) left;\n+    final DruidQuery leftQuery = Preconditions.checkNotNull((leftDruidRel).toDruidQuery(false), \"leftQuery\");\n+    final RowSignature leftSignature = leftQuery.getOutputRowSignature();\n+    final DataSource leftDataSource;\n+\n+    final DruidRel<?> rightDruidRel = (DruidRel<?>) right;\n+    final DruidQuery rightQuery = Preconditions.checkNotNull(rightDruidRel.toDruidQuery(false), \"rightQuery\");\n+    final RowSignature rightSignature = rightQuery.getOutputRowSignature();\n+    final DataSource rightDataSource;\n+\n+    // Left rel: allow direct embedding of scans/mappings including those of joins.\n+    if (DruidRels.isScanOrMapping(leftDruidRel, true)) {\n+      leftDataSource = leftQuery.getDataSource();\n+    } else {\n+      leftDataSource = new QueryDataSource(leftQuery.getQuery());\n+    }\n+\n+    // Right rel: allow direct embedding of scans/mappings, excluduing joins (those must be done as subqueries).", "originalCommit": "bb714014f7ac3bb9947850375e51f002c81010c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4NTQ2OA==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373285468", "bodyText": "Oops, I'll fix it.", "author": "gianm", "createdAt": "2020-01-31T01:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0MzUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3MTUzMw==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373271533", "bodyText": "What's the effect of replacing INSTANCE with SWAP_OUTER here?", "author": "jon-wei", "createdAt": "2020-01-31T00:55:37Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/Rules.java", "diffHunk": "@@ -101,7 +101,7 @@\n           JoinPushExpressionsRule.INSTANCE,\n           FilterAggregateTransposeRule.INSTANCE,\n           ProjectWindowTransposeRule.INSTANCE,\n-          JoinCommuteRule.INSTANCE,\n+          JoinCommuteRule.SWAP_OUTER,", "originalCommit": "18cc3767d57ca36d54f50ae55254121993f67c1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4NTQ1MQ==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373285451", "bodyText": "It is needed for the behavior tested by CalciteQueryTest's testFilterAndGroupByLookupUsingJoinOperatorBackwards.", "author": "gianm", "createdAt": "2020-01-31T01:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3MTUzMw=="}], "type": "inlineReview"}, {"oid": "9939fd0705ffd9c0e51603014d073712fafa7936", "url": "https://github.com/apache/druid/commit/9939fd0705ffd9c0e51603014d073712fafa7936", "message": "Fix typo.", "committedDate": "2020-01-31T01:57:54Z", "type": "commit"}, {"oid": "0783ad9038d9c5f1a382b1306bea8a0ad226139a", "url": "https://github.com/apache/druid/commit/0783ad9038d9c5f1a382b1306bea8a0ad226139a", "message": "Merge branch 'master' into joins-sql", "committedDate": "2020-01-31T17:28:21Z", "type": "commit"}, {"oid": "86e16c2da1d99705e32abe726382753bee3cf7a3", "url": "https://github.com/apache/druid/commit/86e16c2da1d99705e32abe726382753bee3cf7a3", "message": "Merge branch 'master' into joins-sql", "committedDate": "2020-01-31T22:53:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjY5Nw==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373822697", "bodyText": "does this need to be public?", "author": "suneet-s", "createdAt": "2020-02-02T06:26:31Z", "path": "processing/src/main/java/org/apache/druid/segment/join/MapJoinableFactory.java", "diffHunk": "@@ -36,7 +36,7 @@\n   private final Map<Class<? extends DataSource>, JoinableFactory> joinableFactories;\n \n   @Inject\n-  MapJoinableFactory(Map<Class<? extends DataSource>, JoinableFactory> joinableFactories)\n+  public MapJoinableFactory(Map<Class<? extends DataSource>, JoinableFactory> joinableFactories)", "originalCommit": "86e16c2da1d99705e32abe726382753bee3cf7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjc1OQ==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373822759", "bodyText": "two constructors that are very similar are confusing. Can we combine?", "author": "suneet-s", "createdAt": "2020-02-02T06:27:51Z", "path": "server/src/main/java/org/apache/druid/server/ClientQuerySegmentWalker.java", "diffHunk": "@@ -48,18 +48,17 @@\n public class ClientQuerySegmentWalker implements QuerySegmentWalker\n {\n   private final ServiceEmitter emitter;\n-  private final CachingClusteredClient baseClient;\n+  private final QuerySegmentWalker baseClient;\n   private final QueryToolChestWarehouse warehouse;\n   private final RetryQueryRunnerConfig retryConfig;\n   private final ObjectMapper objectMapper;\n   private final ServerConfig serverConfig;\n   private final Cache cache;\n   private final CacheConfig cacheConfig;\n \n-  @Inject\n   public ClientQuerySegmentWalker(\n       ServiceEmitter emitter,\n-      CachingClusteredClient baseClient,\n+      QuerySegmentWalker baseClient,", "originalCommit": "86e16c2da1d99705e32abe726382753bee3cf7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjg4Nw==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373822887", "bodyText": "todo: need a test for this", "author": "suneet-s", "createdAt": "2020-02-02T06:30:33Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/Rules.java", "diffHunk": "@@ -130,13 +130,13 @@\n           AggregateValuesRule.INSTANCE\n       );\n \n-  // Rules from VolcanoPlanner's registerAbstractRelationalRules.\n+  // Rules from VolcanoPlanner's registerAbstractRelationalRules, minus JoinCommuteRule since it's already\n+  // in DEFAULT_RULES.", "originalCommit": "86e16c2da1d99705e32abe726382753bee3cf7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMzAzMw==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373823033", "bodyText": "can left and right be defined as DruidRel<?>", "author": "suneet-s", "createdAt": "2020-02-02T06:33:38Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.Pair;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.join.JoinType;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.planner.Calcites;\n+import org.apache.druid.sql.calcite.table.RowSignature;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * DruidRel that uses a {@link JoinDataSource}.\n+ */\n+public class DruidJoinQueryRel extends DruidRel<DruidJoinQueryRel>\n+{\n+  private static final TableDataSource DUMMY_DATA_SOURCE = new TableDataSource(\"__join__\");\n+  private static final double COST_FACTOR = 100.0;\n+\n+  private final PartialDruidQuery partialQuery;\n+  private final Join joinRel;\n+  private RelNode left;\n+  private RelNode right;\n+\n+  private DruidJoinQueryRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      Join joinRel,\n+      PartialDruidQuery partialQuery,\n+      QueryMaker queryMaker\n+  )\n+  {\n+    super(cluster, traitSet, queryMaker);\n+    this.joinRel = joinRel;\n+    this.left = joinRel.getLeft();\n+    this.right = joinRel.getRight();\n+    this.partialQuery = partialQuery;\n+  }\n+\n+  public static DruidJoinQueryRel create(final Join joinRel, final QueryMaker queryMaker)\n+  {\n+    return new DruidJoinQueryRel(\n+        joinRel.getCluster(),\n+        joinRel.getTraitSet(),\n+        joinRel,\n+        PartialDruidQuery.create(joinRel),\n+        queryMaker\n+    );\n+  }\n+\n+  @Override\n+  public PartialDruidQuery getPartialDruidQuery()\n+  {\n+    return partialQuery;\n+  }\n+\n+  @Override\n+  public Sequence<Object[]> runQuery()\n+  {\n+    // runQuery doesn't need to finalize aggregations, because the fact that runQuery is happening suggests this\n+    // is the outermost query and it will actually get run as a native query. Druid's native query layer will\n+    // finalize aggregations for the outermost query even if we don't explicitly ask it to.\n+\n+    final DruidQuery query = toDruidQuery(false);\n+    return getQueryMaker().runQuery(query);\n+  }\n+\n+  @Override\n+  public DruidJoinQueryRel withPartialQuery(final PartialDruidQuery newQueryBuilder)\n+  {\n+    return new DruidJoinQueryRel(\n+        getCluster(),\n+        getTraitSet().plusAll(newQueryBuilder.getRelTraits()),\n+        joinRel,\n+        newQueryBuilder,\n+        getQueryMaker()\n+    );\n+  }\n+\n+  @Override\n+  public int getQueryCount()\n+  {\n+    return ((DruidRel<?>) left).getQueryCount() + ((DruidRel<?>) right).getQueryCount();", "originalCommit": "86e16c2da1d99705e32abe726382753bee3cf7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg2NTc2NA==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373865764", "bodyText": "Maybe add a description here since the pre-condition is on a computed value.\nSimilar comments in the rest of this file", "author": "suneet-s", "createdAt": "2020-02-02T18:35:08Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "diffHunk": "@@ -126,15 +151,17 @@ public DruidQuery(\n       final boolean finalizeAggregations\n   )\n   {\n-    this.dataSource = dataSource;\n-    this.outputRowType = partialQuery.leafRel().getRowType();\n-    this.sourceRowSignature = sourceRowSignature;\n-    this.virtualColumnRegistry = VirtualColumnRegistry.create(sourceRowSignature);\n-    this.plannerContext = plannerContext;\n+    final RelDataType outputRowType = partialQuery.leafRel().getRowType();\n+    final VirtualColumnRegistry virtualColumnRegistry = VirtualColumnRegistry.create(sourceRowSignature);\n \n     // Now the fun begins.\n+    final DimFilter filter;\n+    final Projection selectProjection;\n+    final Grouping grouping;\n+    final Sorting sorting;\n+\n     if (partialQuery.getWhereFilter() != null) {\n-      this.filter = Preconditions.checkNotNull(\n+      filter = Preconditions.checkNotNull(", "originalCommit": "86e16c2da1d99705e32abe726382753bee3cf7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg2NTgzNw==", "url": "https://github.com/apache/druid/pull/9294#discussion_r373865837", "bodyText": "Why not checkNotNull", "author": "suneet-s", "createdAt": "2020-02-02T18:36:06Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "diffHunk": "@@ -525,6 +561,29 @@ private static Sorting computeSorting(\n     return Sorting.create(orderBys, limit, projection);\n   }\n \n+  /**\n+   * Return the {@link RowSignature} corresponding to the output of a query with the given parameters.\n+   */\n+  private static RowSignature computeOutputRowSignature(\n+      final RowSignature sourceRowSignature,\n+      @Nullable final Projection selectProjection,\n+      @Nullable final Grouping grouping,\n+      @Nullable final Sorting sorting\n+  )\n+  {\n+    if (sorting != null && sorting.getProjection() != null) {\n+      return sorting.getProjection().getOutputRowSignature();\n+    } else if (grouping != null) {\n+      // Sanity check: cannot have both \"grouping\" and \"selectProjection\".\n+      Preconditions.checkState(selectProjection == null, \"Cannot have both 'grouping' and 'selectProjection'\");", "originalCommit": "86e16c2da1d99705e32abe726382753bee3cf7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}