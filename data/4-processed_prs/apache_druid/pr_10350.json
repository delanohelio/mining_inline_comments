{"pr_number": 10350, "pr_title": "Support SearchQueryDimFilter in sql via new methods", "pr_createdAt": "2020-09-03T20:07:11Z", "pr_url": "https://github.com/apache/druid/pull/10350", "timeline": [{"oid": "6648e67d8c9568d5936f82b495cc24dea5510762", "url": "https://github.com/apache/druid/commit/6648e67d8c9568d5936f82b495cc24dea5510762", "message": "Support SearchQueryDimFilter in sql via new methods", "committedDate": "2020-09-03T19:59:59Z", "type": "commit"}, {"oid": "6e86280ad4b9e006fb58bc54e818cd89f4fe1bae", "url": "https://github.com/apache/druid/commit/6e86280ad4b9e006fb58bc54e818cd89f4fe1bae", "message": "Contains is a reserved word", "committedDate": "2020-09-04T12:49:45Z", "type": "commit"}, {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "url": "https://github.com/apache/druid/commit/176d71272f6629fed5b0924b54c4f78ecef94e3f", "message": "revert unnecessary change", "committedDate": "2020-09-04T12:51:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2Njk3Mw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486066973", "bodyText": "The PR description says the functions are called contains and icontains, but it looks like this patch uses the names with _str appended. Was there any reason you chose these names instead of others?\nI couldn't find an equivalent query in postgresql, and when I googled for a contains operator: Oracle and SQL server appear to have one - https://docs.oracle.com/cd/B28359_01/text.111/b28303/query.htm#g1016054 and https://docs.microsoft.com/en-us/sql/t-sql/queries/contains-transact-sql?view=sql-server-2017.\nAlso, was there any reasoning behind having 2 functions instead of 1 with a parameter to ignore the case? I don't think I have a strong preference either way yet, just curious", "author": "suneet-s", "createdAt": "2020-09-10T05:07:25Z", "path": "docs/querying/sql.md", "diffHunk": "@@ -561,6 +561,8 @@ The [DataSketches extension](../development/extensions-core/datasketches-extensi\n |`COALESCE(value1, value2, ...)`|Returns the first value that is neither NULL nor empty string.|\n |`NVL(expr,expr-for-null)`|Returns 'expr-for-null' if 'expr' is null (or empty string for string type).|\n |`BLOOM_FILTER_TEST(<expr>, <serialized-filter>)`|Returns true if the value is contained in a Base64-serialized bloom filter. See the [Bloom filter extension](../development/extensions-core/bloom-filter.html) documentation for additional details.|\n+|`CONTAINS_STR(<expr>, str)`|Returns true if the `str` is a substring of `expr`.|\n+|`ICONTAINS_STR(<expr>, str)`|Returns true if the `str` is a substring of `expr`. The match is case-insensitive.|", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3NDY5OA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486074698", "bodyText": "These should be in the \"String functions\" section.\nI don't have an opinion on the names right now, but to form an opinion I like to do the following.\n\nCheck Calcite's SqlStdOperatorTable, which contains standard operators. If there's something matching there, we should use that.\nIf there isn't a standard operator, survey some other databases. I like to check the golden oldies: MySQL, PostgreSQL, Oracle, SQL Server, as well as some of the newer ones like Presto, Snowflake, BigQuery. If a few of them seem to agree on a name and behavior it's good to go with that.\nIf there doesn't seem to be any agreement, or if you don't want to implement what they seem to agree on for some reason, then make up a new operator.", "author": "gianm", "createdAt": "2020-09-10T05:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2Njk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3NDcwMA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486074700", "bodyText": "OK thinking about this some more, I think I like the idea of one function name more since it maps to the SearchQuerySpec. Then, over time, this function can become smarter and support the different types of search query specs, so if a user passes in a list of values, it knows to use the FragmentSearchQuerySpec and if they pass in some other flag, it knows to use the RegexSearchQuerySpec", "author": "suneet-s", "createdAt": "2020-09-10T05:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2Njk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEwMzk1MQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486103951", "bodyText": "These are really good points and it's my bad to not put my reasonings in the description earlier.  The description has more details but in short,\n\ncontains is a standard operator in calcite, built with non-string input types.\nThe function names are different for case insensitive flavour, to not overload the function signature and follow standard MySQL convention (like/ilike)", "author": "abhishekagarwal87", "createdAt": "2020-09-10T06:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2Njk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5OTk1OQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486199959", "bodyText": "Did some collection of those other databases I mentioned seem to agree on a way to do this?\nIf not, I think your reasoning makes sense. The only thing I'd consider changing, in that case, is spelling out STRING rather than STR. We have a few other functions that have STRING in the name and none that have STR: https://druid.apache.org/docs/latest/querying/sql\nOn the two-functions vs extra-parameter thing: IMO it feels more SQL-ish to have two functions. It doesn't map as directly onto the native construct, but I think that's okay. The native constructs were designed for a JSON API, where it's easy and natural to add a bunch of named parameters. That isn't the case with SQL, where parameters are positional, and so adding a lot of them doesn't work as well.", "author": "gianm", "createdAt": "2020-09-10T09:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2Njk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI0OTkxNg==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486249916", "bodyText": "mysql and postgres - They have substring functions that return the starting index of a search string. I did not find any function similar to contains. Oracle has a similar function which is called instr\nSnowflake has a contains function similar to ours though there is no case insensitive flavor.\nPresto does not seem to have a contains method but does have the methods to find the starting index of another string.\nBigQuery has REGEXP_CONTAINS which takes a regular expression as an input.\n\nCONTAINS would have been an ideal choice for the name but alas, that conflicts with the existing calcite operator.  I can certainly rename them to CONTAINS_STRING", "author": "abhishekagarwal87", "createdAt": "2020-09-10T11:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2Njk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NzUzMA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486067530", "bodyText": "nit: javadocs please", "author": "suneet-s", "createdAt": "2020-09-10T05:08:18Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ContainsOperatorConversion.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.filter.DimFilter;\n+import org.apache.druid.query.filter.SearchQueryDimFilter;\n+import org.apache.druid.query.search.ContainsSearchQuerySpec;\n+import org.apache.druid.query.search.SearchQuerySpec;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DirectOperatorConversion;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+import org.apache.druid.sql.calcite.rel.VirtualColumnRegistry;\n+\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+public class ContainsOperatorConversion extends DirectOperatorConversion", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMDcwMA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486510700", "bodyText": "Added.", "author": "abhishekagarwal87", "createdAt": "2020-09-10T17:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NzUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3MDg4OA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486070888", "bodyText": "Can you also add some tests similar to the ones in FunctionTest to test that we can correctly parse the expression similar to testLpad", "author": "suneet-s", "createdAt": "2020-09-10T05:17:46Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/expression/ExpressionsTest.java", "diffHunk": "@@ -1072,6 +1075,108 @@ public void testPad()\n     );\n   }\n \n+  @Test\n+  public void testContains()\n+  {\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        Collections.emptyList(),\n+        new SearchQueryDimFilter(\"spacey\", new ContainsSearchQuerySpec(\"there\", true), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        Collections.emptyList(),\n+        new SearchQueryDimFilter(\"spacey\", new ContainsSearchQuerySpec(\"There\", true), null),\n+        false\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(false).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        Collections.emptyList(),\n+        new SearchQueryDimFilter(\"spacey\", new ContainsSearchQuerySpec(\"There\", false), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"what\")\n+        ),\n+        ImmutableList.of(\n+            new ExpressionVirtualColumn(\n+                \"v0\",\n+                \"concat('what is',\\\"spacey\\\")\",\n+                ValueType.STRING,\n+                TestExprMacroTable.INSTANCE\n+            )\n+        ),\n+        new SearchQueryDimFilter(\"v0\", new ContainsSearchQuerySpec(\"what\", true), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        ImmutableList.of(\n+            new ExpressionVirtualColumn(\n+                \"v0\",\n+                \"concat('what is',\\\"spacey\\\")\",\n+                ValueType.STRING,\n+                TestExprMacroTable.INSTANCE\n+            )\n+        ),\n+        new SearchQueryDimFilter(\"v0\", new ContainsSearchQuerySpec(\"there\", true), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(false).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"What\")\n+        ),\n+        ImmutableList.of(\n+            new ExpressionVirtualColumn(\n+                \"v0\",\n+                \"concat('what is',\\\"spacey\\\")\",\n+                ValueType.STRING,\n+                TestExprMacroTable.INSTANCE\n+            )\n+        ),\n+        new SearchQueryDimFilter(\"v0\", new ContainsSearchQuerySpec(\"What\", false), null),\n+        true\n+    );\n+  }", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5Nzg5Nw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486197897", "bodyText": "I have not added native functions for these methods. Yet. similar discussion - https://github.com/apache/druid/pull/10350/files#r486068975", "author": "abhishekagarwal87", "createdAt": "2020-09-10T09:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3MDg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486068975", "bodyText": "I don't see native functions named \"contains_str\" and \"icontains_str\", do they exist? (DirectOperatorConversion assumes there is a native function with the functionName you pass in here.)", "author": "gianm", "createdAt": "2020-09-10T05:10:48Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ContainsOperatorConversion.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.filter.DimFilter;\n+import org.apache.druid.query.filter.SearchQueryDimFilter;\n+import org.apache.druid.query.search.ContainsSearchQuerySpec;\n+import org.apache.druid.query.search.SearchQuerySpec;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DirectOperatorConversion;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+import org.apache.druid.sql.calcite.rel.VirtualColumnRegistry;\n+\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+public class ContainsOperatorConversion extends DirectOperatorConversion\n+{\n+  private static final String CASE_SENSITIVE_FN_NAME = \"contains_str\";\n+  private static final String CASE_INSENSITIVE_FN_NAME = \"icontains_str\";\n+  private final boolean caseSensitive;\n+\n+  public ContainsOperatorConversion(\n+      final SqlFunction sqlFunction,\n+      final String functionName,\n+      final boolean caseSensitive\n+  )\n+  {\n+    super(sqlFunction, functionName);", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExNzQ1Nw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486117457", "bodyText": "They don't exist. I am going to fix this by returning null in toDruidExpression method. do you think it will be useful to add corresponding native functions as well that can be used outside leaf filters?", "author": "abhishekagarwal87", "createdAt": "2020-09-10T07:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MzE2NA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486193164", "bodyText": "Yes, because we should let people use this function in any context, not just as a leaf filter, and we'll need a native expression in order to do that. Imagine a query like:\nSELECT CASE WHEN CONTAINS_STR(domain, '.com') THEN 'dot-com' ELSE 'other' END\nFROM tbl\n\nThat would need to get translated using a virtual column + a native expression.", "author": "gianm", "createdAt": "2020-09-10T09:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI1MTUzNw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486251537", "bodyText": "makes sense.", "author": "abhishekagarwal87", "createdAt": "2020-09-10T11:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzODAzNw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486438037", "bodyText": "This would be a nice comment to add on DirectOperatorConversion. I always get confused about which one to add to.", "author": "suneet-s", "createdAt": "2020-09-10T15:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTE3NQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486069175", "bodyText": "Might be more readable to give these methods nice names, like caseInsensitive() and caseSensitive(). Small nit though.", "author": "gianm", "createdAt": "2020-09-10T05:11:32Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/DruidOperatorTable.java", "diffHunk": "@@ -181,6 +182,8 @@\n           .add(new AliasedOperatorConversion(new TruncateOperatorConversion(), \"TRUNC\"))\n           .add(new LPadOperatorConversion())\n           .add(new RPadOperatorConversion())\n+          .add(ContainsOperatorConversion.createOperatorConversion(true))\n+          .add(ContainsOperatorConversion.createOperatorConversion(false))", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExNTU0MA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486115540", "bodyText": "Ack. Those indeed sound better.", "author": "abhishekagarwal87", "createdAt": "2020-09-10T07:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTYwNw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486069607", "bodyText": "You should include tests here using testHelper.testExpression too. It'll test that toDruidExpression works properly, which will be used if someone uses this operator outside of a leaf filter.", "author": "gianm", "createdAt": "2020-09-10T05:13:10Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/expression/ExpressionsTest.java", "diffHunk": "@@ -1072,6 +1075,108 @@ public void testPad()\n     );\n   }\n \n+  @Test\n+  public void testContains()\n+  {", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI1MTc3OQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486251779", "bodyText": "will add those as I add corresponding native functions.", "author": "abhishekagarwal87", "createdAt": "2020-09-10T11:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTYwNw=="}], "type": "inlineReview"}, {"oid": "d5a841a4a04a301daf8a839b15a03926e570d5da", "url": "https://github.com/apache/druid/commit/d5a841a4a04a301daf8a839b15a03926e570d5da", "message": "Fix toDruidExpression method", "committedDate": "2020-09-10T09:30:16Z", "type": "commit"}, {"oid": "b7d3cef69b128a5dde2b83cbfe502c671ddda06f", "url": "https://github.com/apache/druid/commit/b7d3cef69b128a5dde2b83cbfe502c671ddda06f", "message": "rename methods", "committedDate": "2020-09-10T11:04:32Z", "type": "commit"}, {"oid": "bbfe4cbfb39747c0c60960fae452c4cd6be354a6", "url": "https://github.com/apache/druid/commit/bbfe4cbfb39747c0c60960fae452c4cd6be354a6", "message": "java docs", "committedDate": "2020-09-10T11:20:33Z", "type": "commit"}, {"oid": "7e7125d36acde6c70ef1e7b4a86b805e5199d7e3", "url": "https://github.com/apache/druid/commit/7e7125d36acde6c70ef1e7b4a86b805e5199d7e3", "message": "Add native functions", "committedDate": "2020-09-10T17:08:38Z", "type": "commit"}, {"oid": "38306ecc759b2c35cb1aa515f787ac14ce738613", "url": "https://github.com/apache/druid/commit/38306ecc759b2c35cb1aa515f787ac14ce738613", "message": "revert change in dockerfile", "committedDate": "2020-09-10T17:16:36Z", "type": "commit"}, {"oid": "549971029d0f2659b9a4734711ea8147ede726c5", "url": "https://github.com/apache/druid/commit/549971029d0f2659b9a4734711ea8147ede726c5", "message": "remove changes from dockerfile", "committedDate": "2020-09-10T17:19:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTI2Mw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486709263", "bodyText": "Since ContainsExpr always expects this to be a literal value, should this class just accept a String instead?", "author": "suneet-s", "createdAt": "2020-09-11T00:45:05Z", "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExpr.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.function.Function;\n+\n+/**\n+ * {@link Expr} class returned by {@link ContainsExprMacro} and {@link CaseInsensitiveContainsExprMacro} for\n+ * evaluating the expression.\n+ */\n+class ContainsExpr extends ExprMacroTable.BaseScalarUnivariateMacroFunctionExpr\n+{\n+  private final Function<String, Boolean> searchFunction;\n+  private final Expr searchStrExpr;", "originalCommit": "549971029d0f2659b9a4734711ea8147ede726c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkyOTg3Mw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486929873", "bodyText": "searchStrExpr is required in stringify method.", "author": "abhishekagarwal87", "createdAt": "2020-09-11T09:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxOTQ2Ng==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487319466", "bodyText": "I think that makes sense. I tried to walk through the possible values of expr.stringify() given the fact that it is guaranteed to be a string literal, but it was a little tricky for me to reason about, so keeping it an Expr is cool", "author": "suneet-s", "createdAt": "2020-09-11T22:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTc2OA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486709768", "bodyText": "Thanks for the awesome javadocs \ud83e\udd18", "author": "suneet-s", "createdAt": "2020-09-11T00:47:11Z", "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExprMacro.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+\n+import java.util.List;\n+\n+/**\n+ * This class implements a function that checks if one string contains another string. It is required that second\n+ * string be a literal. This expression is case-sensitive.\n+ * signature:\n+ * long contains_string(string, string)\n+ * <p>\n+ * Examples:\n+ * - {@code contains_string(\"foobar\", \"bar\") - 1 }\n+ * - {@code contains_string(\"foobar\", \"car\") - 0 }\n+ * - {@code contains_string(\"foobar\", \"Bar\") - 0 }\n+ * <p>\n+ * See {@link CaseInsensitiveContainsExprMacro} for the case-insensitive version.\n+ */", "originalCommit": "549971029d0f2659b9a4734711ea8147ede726c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMDMyNg==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486710326", "bodyText": "super nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public ContainsOperatorConversion(\n          \n          \n            \n              private ContainsOperatorConversion(", "author": "suneet-s", "createdAt": "2020-09-11T00:49:15Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ContainsOperatorConversion.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.expression.CaseInsensitiveContainsExprMacro;\n+import org.apache.druid.query.expression.ContainsExprMacro;\n+import org.apache.druid.query.filter.DimFilter;\n+import org.apache.druid.query.filter.SearchQueryDimFilter;\n+import org.apache.druid.query.search.ContainsSearchQuerySpec;\n+import org.apache.druid.query.search.SearchQuerySpec;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+import org.apache.druid.sql.calcite.rel.VirtualColumnRegistry;\n+\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+/**\n+ * Register {@code contains_string} and {@code icontains_string} functions with calcite that internally\n+ * translate these functions into {@link SearchQueryDimFilter} with {@link ContainsSearchQuerySpec} as\n+ * search query spec.\n+ */\n+public class ContainsOperatorConversion implements SqlOperatorConversion\n+{\n+  private final SqlOperator operator;\n+  private final boolean caseSensitive;\n+\n+  public ContainsOperatorConversion(", "originalCommit": "549971029d0f2659b9a4734711ea8147ede726c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486712620", "bodyText": "Can you add some tests for how the function deals with nulls and empty strings - these tend to surface some issues because we need to support 2 modes - default mode and sql compatible mode, and sometimes the behavior of these functions may be slightly different than we expect. I remember finding issues when I changed the behavior of lpad / rpad functions - https://github.com/apache/druid/pull/10006/files#diff-fd48c48432e4977332aa9806d2d308faR150-R151", "author": "suneet-s", "createdAt": "2020-09-11T00:57:40Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/expression/ExpressionsTest.java", "diffHunk": "@@ -1072,6 +1075,221 @@ public void testPad()\n     );\n   }\n \n+  @Test\n+  public void testContains()\n+  {\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(\\\"spacey\\\",'there')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(\\\"spacey\\\",'There')\"),\n+        0L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseInsensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        DruidExpression.fromExpression(\"icontains_string(\\\"spacey\\\",'There')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"what\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(concat('what is',\\\"spacey\\\"),'what')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(concat('what is',\\\"spacey\\\"),'there')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseInsensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        DruidExpression.fromExpression(\"icontains_string(concat('what is',\\\"spacey\\\"),'There')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        SqlStdOperatorTable.AND,\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+                testHelper.makeInputRef(\"spacey\"),\n+                testHelper.makeLiteral(\"there\")\n+            ),\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.EQUALS,\n+                testHelper.makeLiteral(\"yes\"),\n+                testHelper.makeLiteral(\"yes\")\n+            )\n+        ),\n+        DruidExpression.fromExpression(\"(contains_string(\\\"spacey\\\",'there') && ('yes' == 'yes'))\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        SqlStdOperatorTable.AND,\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                ContainsOperatorConversion.caseInsensitive().calciteOperator(),\n+                testHelper.makeInputRef(\"spacey\"),\n+                testHelper.makeLiteral(\"There\")\n+            ),\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.EQUALS,\n+                testHelper.makeLiteral(\"yes\"),\n+                testHelper.makeLiteral(\"yes\")\n+            )\n+        ),\n+        DruidExpression.fromExpression(\"(icontains_string(\\\"spacey\\\",'There') && ('yes' == 'yes'))\"),", "originalCommit": "549971029d0f2659b9a4734711ea8147ede726c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2NTIwMg==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487065202", "bodyText": "Added two tests for the same. Learnt a few things along the way. I was not at all expecting an empty string to be turned to null. Do you know why that is done?", "author": "abhishekagarwal87", "createdAt": "2020-09-11T14:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MzQxMg==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487073412", "bodyText": "https://druid.apache.org/docs/latest/querying/sql.html#null-values\nThis is because initially there was no null and druid was not sql compatible so nulls were treated as empty strings or 0s. This was done at ingestion time as well, so once the data was ingested, we can't distinguish between a null and a 0.", "author": "suneet-s", "createdAt": "2020-09-11T14:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3Nzg5Ng==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487077896", "bodyText": "hmm. what do you think should be the output of following in the default mode assuming myColumn has empty value?\nCONTAINS(\"myColumn\", '')", "author": "abhishekagarwal87", "createdAt": "2020-09-11T14:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyOTg4Ng==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487129886", "bodyText": "I was not handling the null values similar to other expressions. It should work now. code coverage bot was complaining as tests were added in sql module and these Expr* classes are in the processing module. After I added the tests in the processing module, I realized what the problem was.  When an empty string is passed, the functions get a null value that they again convert to an empty value.", "author": "abhishekagarwal87", "createdAt": "2020-09-11T15:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA=="}], "type": "inlineReview"}, {"oid": "1f408a72d73e5dd8fd60e03269eecae0e68f2c71", "url": "https://github.com/apache/druid/commit/1f408a72d73e5dd8fd60e03269eecae0e68f2c71", "message": "More tests", "committedDate": "2020-09-11T11:34:58Z", "type": "commit"}, {"oid": "cfd26bdaaf9e9768e734d1e460b38e57bd44921d", "url": "https://github.com/apache/druid/commit/cfd26bdaaf9e9768e734d1e460b38e57bd44921d", "message": "travis fix", "committedDate": "2020-09-11T13:50:35Z", "type": "commit"}, {"oid": "a8ae16920d494aaafc1d6f454a644fbd096fc044", "url": "https://github.com/apache/druid/commit/a8ae16920d494aaafc1d6f454a644fbd096fc044", "message": "Handle null values better", "committedDate": "2020-09-11T15:31:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyMjY4OA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487322688", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // same behavior as regexp_like.\n          \n          \n            \n                  // same behavior as ContainsSearchQuerySpec#accept\n          \n      \n    \n    \n  \n\nLuckily the behavior is the same as regexp_like\n    if (dimVal == null || value == null) {\n      return false;\n    }", "author": "suneet-s", "createdAt": "2020-09-11T22:48:10Z", "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExpr.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.function.Function;\n+\n+/**\n+ * {@link Expr} class returned by {@link ContainsExprMacro} and {@link CaseInsensitiveContainsExprMacro} for\n+ * evaluating the expression.\n+ */\n+class ContainsExpr extends ExprMacroTable.BaseScalarUnivariateMacroFunctionExpr\n+{\n+  private final Function<String, Boolean> searchFunction;\n+  private final Expr searchStrExpr;\n+\n+  ContainsExpr(String functioName, Expr arg, Expr searchStrExpr, boolean caseSensitive)\n+  {\n+    super(functioName, arg);\n+    this.searchStrExpr = validateSearchExpr(searchStrExpr, functioName);\n+    // Creates the function eagerly to avoid branching in eval.\n+    this.searchFunction = createFunction(searchStrExpr, caseSensitive);\n+  }\n+\n+  private ContainsExpr(String functioName, Expr arg, Expr searchStrExpr, Function<String, Boolean> searchFunction)\n+  {\n+    super(functioName, arg);\n+    this.searchFunction = searchFunction;\n+    this.searchStrExpr = validateSearchExpr(searchStrExpr, functioName);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public ExprEval eval(final Expr.ObjectBinding bindings)\n+  {\n+    final String s = NullHandling.nullToEmptyIfNeeded(arg.eval(bindings).asString());\n+\n+    if (s == null) {\n+      // same behavior as regexp_like.", "originalCommit": "a8ae16920d494aaafc1d6f454a644fbd096fc044", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyMzYzMA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487323630", "bodyText": "nit: It would be good to link to the DimFilter whose behavior we are trying to mimic here ContainsSearchQuerySpec\nsince we want the logic between these 2 classes to stay the same. I wonder if we can future proof this so they stay in sync if someone makes an update to ContainsSearchQuerySpec", "author": "suneet-s", "createdAt": "2020-09-11T22:52:01Z", "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExpr.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.function.Function;\n+\n+/**\n+ * {@link Expr} class returned by {@link ContainsExprMacro} and {@link CaseInsensitiveContainsExprMacro} for\n+ * evaluating the expression.\n+ */", "originalCommit": "a8ae16920d494aaafc1d6f454a644fbd096fc044", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyOTUzMQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487329531", "bodyText": "According to ContainsSearchQuerySpec#accept searching for anything on null should be false\n    if (dimVal == null || value == null) {\n      return false;\n    }", "author": "suneet-s", "createdAt": "2020-09-11T23:18:14Z", "path": "processing/src/test/java/org/apache/druid/query/expression/ContainsExprMacroTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprType;\n+import org.apache.druid.math.expr.Parser;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ContainsExprMacroTest extends MacroTestBase\n+{\n+  public ContainsExprMacroTest()\n+  {\n+    super(new ContainsExprMacro());\n+  }\n+\n+  @Test\n+  public void testErrorZeroArguments()\n+  {\n+    expectException(IllegalArgumentException.class, \"Function[contains_string] must have 2 arguments\");\n+    eval(\"contains_string()\", Parser.withMap(ImmutableMap.of()));\n+  }\n+\n+  @Test\n+  public void testErrorThreeArguments()\n+  {\n+    expectException(IllegalArgumentException.class, \"Function[contains_string] must have 2 arguments\");\n+    eval(\"contains_string('a', 'b', 'c')\", Parser.withMap(ImmutableMap.of()));\n+  }\n+\n+  @Test\n+  public void testMatch()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, 'oba')\", Parser.withMap(ImmutableMap.of(\"a\", \"foobar\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNoMatch()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, 'bar')\", Parser.withMap(ImmutableMap.of(\"a\", \"foo\")));\n+    Assert.assertEquals(\n+        ExprEval.of(false, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNullSearch()\n+  {\n+    if (NullHandling.sqlCompatible()) {\n+      expectException(IllegalArgumentException.class, \"Function[contains_string] substring must be a string literal\");\n+    }\n+\n+    final ExprEval<?> result = eval(\"contains_string(a, null)\", Parser.withMap(ImmutableMap.of(\"a\", \"foo\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testEmptyStringSearch()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, '')\", Parser.withMap(ImmutableMap.of(\"a\", \"foo\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNullSearchOnEmptyString()\n+  {\n+    if (NullHandling.sqlCompatible()) {\n+      expectException(IllegalArgumentException.class, \"Function[contains_string] substring must be a string literal\");\n+    }\n+\n+    final ExprEval<?> result = eval(\"contains_string(a, null)\", Parser.withMap(ImmutableMap.of(\"a\", \"\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testEmptyStringSearchOnEmptyString()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, '')\", Parser.withMap(ImmutableMap.of(\"a\", \"\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNullSearchOnNull()\n+  {\n+    if (NullHandling.sqlCompatible()) {\n+      expectException(IllegalArgumentException.class, \"Function[contains_string] substring must be a string literal\");\n+    }\n+\n+    final ExprEval<?> result = eval(\"contains_string(a, null)\", Parser.withSuppliers(ImmutableMap.of(\"a\", () -> null)));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),", "originalCommit": "a8ae16920d494aaafc1d6f454a644fbd096fc044", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3MTI3Mw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487371273", "bodyText": "In non-sql compatible mode, both of these will be empty instead of null and hence the function would return true.\nIn SQL compatible mode, we would see an exception since null is not a valid literal.", "author": "abhishekagarwal87", "createdAt": "2020-09-12T05:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyOTUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3MTY2OA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487371668", "bodyText": "though I am still evaluating if the SQL operator behaves differently in non-sql compatible mode. That is, If null is not translated into empty string in the SQL operator, we may see a behaviour mismatch.", "author": "abhishekagarwal87", "createdAt": "2020-09-12T05:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyOTUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA4NTYyNQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r488085625", "bodyText": "In non-sql compatible mode, both of these will be empty instead of null and hence the function would return true.\nIn SQL compatible mode, we would see an exception since null is not a valid literal.\n\nThanks for the explanation", "author": "suneet-s", "createdAt": "2020-09-14T16:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyOTUzMQ=="}], "type": "inlineReview"}]}