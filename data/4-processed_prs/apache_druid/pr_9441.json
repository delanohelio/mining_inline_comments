{"pr_number": 9441, "pr_title": "Improve OvershadowableManager performance", "pr_createdAt": "2020-02-29T05:21:17Z", "pr_url": "https://github.com/apache/druid/pull/9441", "timeline": [{"oid": "26edbff1a331956ff087924810568b32b46eaa27", "url": "https://github.com/apache/druid/commit/26edbff1a331956ff087924810568b32b46eaa27", "message": "Use the iterator instead of higherKey(); use the iterator API instead of stream", "committedDate": "2020-02-29T04:57:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwODAwNw==", "url": "https://github.com/apache/druid/pull/9441#discussion_r387208007", "bodyText": "missing unit tests for this function?", "author": "suneet-s", "createdAt": "2020-03-03T18:24:02Z", "path": "core/src/main/java/org/apache/druid/timeline/VersionedIntervalTimeline.java", "diffHunk": "@@ -161,11 +162,11 @@ public int getNumObjects()\n    */\n   public Set<ObjectType> findNonOvershadowedObjectsInInterval(Interval interval, Partitions completeness)", "originalCommit": "26edbff1a331956ff087924810568b32b46eaa27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg1NTIwNw==", "url": "https://github.com/apache/druid/pull/9441#discussion_r389855207", "bodyText": "Added some.", "author": "jihoonson", "createdAt": "2020-03-09T17:44:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIwODAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0NjI5Mw==", "url": "https://github.com/apache/druid/pull/9441#discussion_r387246293", "bodyText": "Are we guaranteed that chunk.getObject will never be null?", "author": "suneet-s", "createdAt": "2020-03-03T19:33:44Z", "path": "core/src/main/java/org/apache/druid/timeline/VersionedIntervalTimeline.java", "diffHunk": "@@ -482,7 +483,12 @@ public boolean isOvershadowed(Interval interval, VersionType version, ObjectType\n         if (versionCompare > 0) {\n           return false;\n         } else if (versionCompare == 0) {\n-          if (timelineEntry.partitionHolder.stream().noneMatch(chunk -> chunk.getObject().overshadows(object))) {\n+          // Intentionally use the Iterators API instead of the stream API for performance.\n+          //noinspection ConstantConditions\n+          final boolean nonOvershadowedObject = Iterators.all(\n+              timelineEntry.partitionHolder.iterator(), chunk -> !chunk.getObject().overshadows(object)", "originalCommit": "26edbff1a331956ff087924810568b32b46eaa27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg1NjI0Ng==", "url": "https://github.com/apache/druid/pull/9441#discussion_r389856246", "bodyText": "If you are asking whether we guarantee that programmatically, then I don't think so. But the object in the chunk should never be null.", "author": "jihoonson", "createdAt": "2020-03-09T17:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0NjI5Mw=="}], "type": "inlineReview"}, {"oid": "5504debc61a685b6aaa546bf41a0566da25ecbf8", "url": "https://github.com/apache/druid/commit/5504debc61a685b6aaa546bf41a0566da25ecbf8", "message": "Fix tests; fix a concurrency bug in timeline", "committedDate": "2020-03-04T02:31:56Z", "type": "commit"}, {"oid": "e18dea1adf770b829d56113a5ddc785255bfceab", "url": "https://github.com/apache/druid/commit/e18dea1adf770b829d56113a5ddc785255bfceab", "message": "fix test", "committedDate": "2020-03-09T17:15:55Z", "type": "commit"}, {"oid": "42fd983d88c4d99f78074b86abcd3ab2873dfe3d", "url": "https://github.com/apache/druid/commit/42fd983d88c4d99f78074b86abcd3ab2873dfe3d", "message": "add tests for findNonOvershadowedObjectsInInterval", "committedDate": "2020-03-09T17:33:36Z", "type": "commit"}, {"oid": "114bf34c62cac009270a81c1ddd580c65172fa93", "url": "https://github.com/apache/druid/commit/114bf34c62cac009270a81c1ddd580c65172fa93", "message": "fix test", "committedDate": "2020-03-09T17:44:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NDg3NA==", "url": "https://github.com/apache/druid/pull/9441#discussion_r389944874", "bodyText": "should this override public OvershadowableManager<T> clone() instead?", "author": "suneet-s", "createdAt": "2020-03-09T20:32:52Z", "path": "core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java", "diffHunk": "@@ -105,12 +105,46 @@\n     this.overshadowedGroups = new TreeMap<>();\n   }\n \n-  OvershadowableManager(OvershadowableManager<T> other)\n+  public OvershadowableManager<T> copyVisible()\n   {\n-    this.knownPartitionChunks = new HashMap<>(other.knownPartitionChunks);\n-    this.standbyGroups = new TreeMap<>(other.standbyGroups);\n-    this.visibleGroupPerRange = new TreeMap<>(other.visibleGroupPerRange);\n-    this.overshadowedGroups = new TreeMap<>(other.overshadowedGroups);\n+    final OvershadowableManager<T> copy = new OvershadowableManager<>();\n+    visibleGroupPerRange.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.visibleGroupPerRange.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    return copy;\n+  }\n+\n+  public OvershadowableManager<T> deepCopy()", "originalCommit": "114bf34c62cac009270a81c1ddd580c65172fa93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4Nzg3NQ==", "url": "https://github.com/apache/druid/pull/9441#discussion_r389987875", "bodyText": "From the Item 13 (Override clone judiciously) of the book \"Effective Java\",\n\nIs all this complexity really necessary? Rarely. If you extend a class that already implements Cloneable, you have little choice but to implement a well-behaved clone method. Otherwise, you are usually better off providing an alternative means of object copying. A better approach to object copying is to provide a copy constructor or copy factory.\n\nI changed this method to a static factory based on this.", "author": "jihoonson", "createdAt": "2020-03-09T22:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NDg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NTQ3Mw==", "url": "https://github.com/apache/druid/pull/9441#discussion_r389945473", "bodyText": "missing tests to verify that the returned copy is a deepCopy() - what if new fields are added to the overshadowable manager? Similar comments for copyVisible()", "author": "suneet-s", "createdAt": "2020-03-09T20:34:03Z", "path": "core/src/main/java/org/apache/druid/timeline/partition/OvershadowableManager.java", "diffHunk": "@@ -105,12 +105,46 @@\n     this.overshadowedGroups = new TreeMap<>();\n   }\n \n-  OvershadowableManager(OvershadowableManager<T> other)\n+  public OvershadowableManager<T> copyVisible()\n   {\n-    this.knownPartitionChunks = new HashMap<>(other.knownPartitionChunks);\n-    this.standbyGroups = new TreeMap<>(other.standbyGroups);\n-    this.visibleGroupPerRange = new TreeMap<>(other.visibleGroupPerRange);\n-    this.overshadowedGroups = new TreeMap<>(other.overshadowedGroups);\n+    final OvershadowableManager<T> copy = new OvershadowableManager<>();\n+    visibleGroupPerRange.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.visibleGroupPerRange.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    return copy;\n+  }\n+\n+  public OvershadowableManager<T> deepCopy()\n+  {\n+    final OvershadowableManager<T> copy = copyVisible();\n+    overshadowedGroups.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.overshadowedGroups.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    standbyGroups.forEach((partitionRange, versionToGroups) -> {\n+      // There should be only one group per partition range\n+      final AtomicUpdateGroup<T> group = versionToGroups.values().iterator().next();\n+      group.getChunks().forEach(chunk -> copy.knownPartitionChunks.put(chunk.getChunkNumber(), chunk));\n+\n+      copy.standbyGroups.put(\n+          partitionRange,\n+          new SingleEntryShort2ObjectSortedMap<>(group.getMinorVersion(), AtomicUpdateGroup.copy(group))\n+      );\n+    });\n+    return copy;", "originalCommit": "114bf34c62cac009270a81c1ddd580c65172fa93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NzkxMw==", "url": "https://github.com/apache/druid/pull/9441#discussion_r389987913", "bodyText": "Added tests.", "author": "jihoonson", "createdAt": "2020-03-09T22:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NTQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0Nzk4MA==", "url": "https://github.com/apache/druid/pull/9441#discussion_r389947980", "bodyText": "Does the order of the segments matter?\nWhy not just calculate the min start and max end with O(n) implementation by looping over segments", "author": "suneet-s", "createdAt": "2020-03-09T20:39:04Z", "path": "server/src/main/java/org/apache/druid/server/coordinator/duty/NewestSegmentFirstIterator.java", "diffHunk": "@@ -509,12 +509,13 @@ private SegmentsToCompact findSegmentsToCompact(\n     private QueueEntry(List<DataSegment> segments)\n     {\n       Preconditions.checkArgument(segments != null && !segments.isEmpty());\n-      Collections.sort(segments);\n+      final List<DataSegment> segmentsToSort = new ArrayList<>(segments);\n+      Collections.sort(segmentsToSort);\n       this.interval = new Interval(\n-          segments.get(0).getInterval().getStart(),\n-          segments.get(segments.size() - 1).getInterval().getEnd()\n+          segmentsToSort.get(0).getInterval().getStart(),\n+          segmentsToSort.get(segmentsToSort.size() - 1).getInterval().getEnd()\n       );\n-      this.segments = segments;\n+      this.segments = segmentsToSort;", "originalCommit": "114bf34c62cac009270a81c1ddd580c65172fa93", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NzkzNg==", "url": "https://github.com/apache/druid/pull/9441#discussion_r389987936", "bodyText": "\ud83d\udc4d fixed.", "author": "jihoonson", "createdAt": "2020-03-09T22:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0Nzk4MA=="}], "type": "inlineReview"}, {"oid": "b49262fa6df2b22d97c6605fb9bdcb3e58a0e8c0", "url": "https://github.com/apache/druid/commit/b49262fa6df2b22d97c6605fb9bdcb3e58a0e8c0", "message": "add missing tests; fix a bug in QueueEntry", "committedDate": "2020-03-09T22:02:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTEyOA==", "url": "https://github.com/apache/druid/pull/9441#discussion_r390011128", "bodyText": "Thanks for the tests! One last ask, since this depends on equals to be implemented correctly, I think we need another test for equals\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n              @Test\n          \n          \n            \n              public void testEqualAndHashCodeContract()\n          \n          \n            \n              {\n          \n          \n            \n                EqualsVerifier.forClass(OvershadowableManager.class).usingGetClass().verify();\n          \n          \n            \n              }", "author": "suneet-s", "createdAt": "2020-03-09T23:12:47Z", "path": "core/src/test/java/org/apache/druid/timeline/partition/OvershadowableManagerTest.java", "diffHunk": "@@ -63,6 +64,57 @@ public void setup()\n     expectedStandbyChunks = new ArrayList<>();\n   }\n \n+  @Test\n+  public void testCopyVisible()\n+  {\n+    // chunks of partition id 0 and 1\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // chunks to overshadow the partition id range [0, 2)\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+\n+    // chunks of partition id 3 and 4\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // standby chunk\n+    manager.addChunk(newNonRootChunk(2, 4, 1, 3));\n+\n+    OvershadowableManager<OvershadowableInteger> copy = OvershadowableManager.copyVisible(manager);\n+    Assert.assertTrue(copy.getOvershadowedChunks().isEmpty());\n+    Assert.assertTrue(copy.getStandbyChunks().isEmpty());\n+    Assert.assertEquals(\n+        Lists.newArrayList(manager.visibleChunksIterator()),\n+        Lists.newArrayList(copy.visibleChunksIterator())\n+    );\n+  }\n+\n+  @Test\n+  public void testDeepCopy()\n+  {\n+    // chunks of partition id 0 and 1\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // chunks to overshadow the partition id range [0, 2)\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+    manager.addChunk(newNonRootChunk(0, 2, 1, 3));\n+\n+    // chunks of partition id 3 and 4\n+    manager.addChunk(newRootChunk());\n+    manager.addChunk(newRootChunk());\n+\n+    // standby chunk\n+    manager.addChunk(newNonRootChunk(2, 4, 1, 3));\n+\n+    OvershadowableManager<OvershadowableInteger> copy = OvershadowableManager.deepCopy(manager);\n+    Assert.assertEquals(manager, copy);\n+  }\n+", "originalCommit": "b49262fa6df2b22d97c6605fb9bdcb3e58a0e8c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzU2Mg==", "url": "https://github.com/apache/druid/pull/9441#discussion_r390013562", "bodyText": "Oops, added tests for OvershadowableManager and AtomicUpdateGroup.", "author": "jihoonson", "createdAt": "2020-03-09T23:20:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTEyOA=="}], "type": "inlineReview"}, {"oid": "0b4974e4eeb47c056bc7ac3ad45309e57dcba97d", "url": "https://github.com/apache/druid/commit/0b4974e4eeb47c056bc7ac3ad45309e57dcba97d", "message": "equals tests", "committedDate": "2020-03-09T23:19:59Z", "type": "commit"}, {"oid": "4476989fe54dcdf67f38d9c85e4a44c99d1666bc", "url": "https://github.com/apache/druid/commit/4476989fe54dcdf67f38d9c85e4a44c99d1666bc", "message": "fix test", "committedDate": "2020-03-10T05:41:38Z", "type": "commit"}]}