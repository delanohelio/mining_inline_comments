{"pr_number": 9488, "pr_title": "Match GREATEST/LEAST function behavior to other DBs", "pr_createdAt": "2020-03-09T22:27:27Z", "pr_url": "https://github.com/apache/druid/pull/9488", "timeline": [{"oid": "44c4b5e40ec1cabde5ba5f76707f4eb535222989", "url": "https://github.com/apache/druid/commit/44c4b5e40ec1cabde5ba5f76707f4eb535222989", "message": "Match GREATEST/LEAST function behavior\n\nChange the behavior of the GREATEST / LEAST functions to be similar to\nhow it is implemented in other databases (as functions instead of\naggregators). The GREATEST/LEAST functions are not in the SQL standard,\nbut users will expect behavior similar to what other databases provide.", "committedDate": "2020-03-09T22:20:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTgzMg==", "url": "https://github.com/apache/druid/pull/9488#discussion_r390009832", "bodyText": "is this implicit cast something that other databases do as well ? how about enforce an explicit cast ?", "author": "b-slim", "createdAt": "2020-03-09T23:08:42Z", "path": "docs/querying/sql.md", "diffHunk": "@@ -334,6 +332,22 @@ simplest way to write literal timestamps in other time zones is to use TIME_PARS\n |<code>timestamp_expr { + &#124; - } <interval_expr><code>|Add or subtract an amount of time from a timestamp. interval_expr can include interval literals like `INTERVAL '2' HOUR`, and may include interval arithmetic as well. This operator treats days as uniformly 86400 seconds long, and does not take into account daylight savings time. To account for daylight savings time, use TIME_SHIFT instead.|\n \n \n+### Reduction functions\n+\n+Reduction functions operate on zero or more expressions and return a single expression. If no expressions are passed\n+as arguments, then the result is `NULL`. The expressions must all be convertible to a\n+common data type, which will be the type of the result:\n+*  If any argument is `NULL`, the result is `NULL`.\n+*  If the arguments comprise a mix of numbers and strings, the arguments are interpreted as strings.", "originalCommit": "44c4b5e40ec1cabde5ba5f76707f4eb535222989", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTMwOQ==", "url": "https://github.com/apache/druid/pull/9488#discussion_r390011309", "bodyText": "The references that I looked at (added to the description) do implicit casting. The docs I added here are inspired by the ones for MySQL: https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least", "author": "ccaominh", "createdAt": "2020-03-09T23:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzYyMA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r390013620", "bodyText": "Thanks for pointer, do you see this applying to every reduce function ?", "author": "b-slim", "createdAt": "2020-03-09T23:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNTUxOA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r390015518", "bodyText": "I'm not sure what other reduction functions we'll want to add in the future, but ideally the behavior is consistent. That being said, I wouldn't be surprised if the docs need to be reorganized to accommodate future reduction functions.", "author": "ccaominh", "createdAt": "2020-03-09T23:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNzY5Mg==", "url": "https://github.com/apache/druid/pull/9488#discussion_r390017692", "bodyText": "If am reading the code correctly this is applying to every reduce function as per getComparisionType function impl.", "author": "b-slim", "createdAt": "2020-03-09T23:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxOTc4NA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r390019784", "bodyText": "Yeah, I meant to say the docs and implementation may need to change later depending on whether/what other reduction functions are added in the future.", "author": "ccaominh", "createdAt": "2020-03-09T23:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTMzMA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r390011330", "bodyText": "Old text, but maximum/minimum seem like not quite the right word.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | greatest([expr1, ...]) | Returns the maximum expression across zero or more expressions. |\n          \n          \n            \n            | greatest([expr1, ...]) | Returns the largest value among zero or more expressions. |", "author": "sthetland", "createdAt": "2020-03-09T23:13:27Z", "path": "docs/misc/math-expr.md", "diffHunk": "@@ -181,6 +181,22 @@ See javadoc of java.lang.Math for detailed explanation for each function.\n | all(lambda,arr) | returns 1 if all elements in the array matches the lambda expression, else 0 |\n \n \n+### Reduction functions\n+\n+Reduction functions operate on zero or more expressions and return a single expression. If no expressions are passed\n+as arguments, then the result is `NULL`. The expressions must all be convertible to a\n+common data type, which will be the type of the result:\n+*  If any argument is `NULL`, the result is `NULL`.\n+*  If the arguments comprise a mix of numbers and strings, the arguments are interpreted as strings.\n+*  If all arguments are integer numbers, the arguments are interpreted as longs.\n+*  If all arguments are numbers and at least one argument is a double, the arguments are interpreted as doubles. \n+\n+| function | description |\n+| --- | --- |\n+| greatest([expr1, ...]) | Returns the maximum expression across zero or more expressions. |", "originalCommit": "44c4b5e40ec1cabde5ba5f76707f4eb535222989", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNjEyOA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r390016128", "bodyText": "Thinking about it more, I'm not sure what the best wording would be since the expressions could all be strings (in which case, greatest returns the last value if they're all sorted alphabetically). \"Largest\" may be confused with \"longest\". Any suggestions?", "author": "ccaominh", "createdAt": "2020-03-09T23:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5OTkxNg==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391099916", "bodyText": "How about:\n\nEvaluates zero or more expressions and returns the maximum value based on comparisons as described above.\n\nI do think \"maximum\" is better than \"largest\" due to the ambiguity with strings.", "author": "gianm", "createdAt": "2020-03-11T16:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTQ3Mg==", "url": "https://github.com/apache/druid/pull/9488#discussion_r390011472", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | least([expr1, ...]) | Returns the minimum expression across zero or more expressions. |\n          \n          \n            \n            | least([expr1, ...]) | Returns the smallest value among zero or more expressions. |", "author": "sthetland", "createdAt": "2020-03-09T23:13:55Z", "path": "docs/misc/math-expr.md", "diffHunk": "@@ -181,6 +181,22 @@ See javadoc of java.lang.Math for detailed explanation for each function.\n | all(lambda,arr) | returns 1 if all elements in the array matches the lambda expression, else 0 |\n \n \n+### Reduction functions\n+\n+Reduction functions operate on zero or more expressions and return a single expression. If no expressions are passed\n+as arguments, then the result is `NULL`. The expressions must all be convertible to a\n+common data type, which will be the type of the result:\n+*  If any argument is `NULL`, the result is `NULL`.\n+*  If the arguments comprise a mix of numbers and strings, the arguments are interpreted as strings.\n+*  If all arguments are integer numbers, the arguments are interpreted as longs.\n+*  If all arguments are numbers and at least one argument is a double, the arguments are interpreted as doubles. \n+\n+| function | description |\n+| --- | --- |\n+| greatest([expr1, ...]) | Returns the maximum expression across zero or more expressions. |\n+| least([expr1, ...]) | Returns the minimum expression across zero or more expressions. |", "originalCommit": "44c4b5e40ec1cabde5ba5f76707f4eb535222989", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "url": "https://github.com/apache/druid/commit/ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "message": "Merge remote-tracking branch 'upstream/master' into fix-greatest-least", "committedDate": "2020-03-10T18:07:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5MjY3Mw==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391092673", "bodyText": "Given it's not standard and we can do what we want, I would suggest going with the Postgres behavior for these reasons:\n\nIMO the Postgres behavior is more likely to be useful: if I do GREATEST(x, y, z) and y is null, I probably want that to be equivalent to GREATEST(x, z).\nPostgres behavior is used as a base for a wide variety of other databases beyond the ones we're looking at here, so its behavior is influential.", "author": "gianm", "createdAt": "2020-03-11T16:17:13Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NDg1Mg==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391094852", "bodyText": "Even though this method is private, javadocs would be nice, especially for explaining when null would be returned. The method is long enough that it is not obvious what it does without studying it.", "author": "gianm", "createdAt": "2020-03-11T16:20:20Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.\n+        return ExprEval.of(null);\n+      }\n+\n+      Stream<ExprEval<?>> exprEvalStream = exprAnalysis.exprEvals.stream();\n+      switch (exprAnalysis.comparisonType) {\n+        case DOUBLE:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToDouble(ExprEval::asDouble).reduce(doubleReducer).getAsDouble());\n+        case LONG:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToLong(ExprEval::asLong).reduce(longReducer).getAsLong());\n+        default:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.map(ExprEval::asString).reduce(stringReducer).get());\n+      }\n+    }\n+\n+    @Nullable\n+    private ExprAnalysis analyzeExprs(List<Expr> exprs, Expr.ObjectBinding bindings)", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NzU2NQ==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391097565", "bodyText": "I believe exprEval.value() == null is equivalent and may avoid computing the stringValue in some cases.", "author": "gianm", "createdAt": "2020-03-11T16:24:16Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.\n+        return ExprEval.of(null);\n+      }\n+\n+      Stream<ExprEval<?>> exprEvalStream = exprAnalysis.exprEvals.stream();\n+      switch (exprAnalysis.comparisonType) {\n+        case DOUBLE:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToDouble(ExprEval::asDouble).reduce(doubleReducer).getAsDouble());\n+        case LONG:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToLong(ExprEval::asLong).reduce(longReducer).getAsLong());\n+        default:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.map(ExprEval::asString).reduce(stringReducer).get());\n+      }\n+    }\n+\n+    @Nullable\n+    private ExprAnalysis analyzeExprs(List<Expr> exprs, Expr.ObjectBinding bindings)\n+    {\n+      Set<ExprType> presentTypes = EnumSet.noneOf(ExprType.class);\n+      List<ExprEval<?>> exprEvals = new ArrayList<>();\n+\n+      for (Expr expr : exprs) {\n+        ExprEval<?> exprEval = expr.eval(bindings);\n+        ExprType exprType = exprEval.type();\n+\n+        if (isValidType(exprType)) {\n+          presentTypes.add(exprType);\n+        }\n+\n+        if (exprEval.asString() == null) {", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjczMQ==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391106731", "bodyText": "There are more SQL types than Druid types so we need to account for all the 'extras' too. (They can show up from literals, etc.) For example a DECIMAL or FLOAT could show up and we want to treat those as doubles for purposes of this logic.\nMostly we do this mapping by using Calcites.getValueTypeForSqlTypeName \u2014\u00a0try checking that out.", "author": "gianm", "createdAt": "2020-03-11T16:37:44Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ReductionOperatorConversionHelper.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+\n+class ReductionOperatorConversionHelper\n+{\n+  private ReductionOperatorConversionHelper()\n+  {\n+  }\n+\n+  /**\n+   * Implements rules similar to: https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least\n+   *\n+   * @see org.apache.druid.math.expr.Function.ReduceFunc#apply\n+   * @see org.apache.druid.math.expr.Function.ReduceFunc#getComparisionType\n+   */\n+  static final SqlReturnTypeInference TYPE_INFERENCE =\n+      opBinding -> {\n+        final RelDataTypeFactory typeFactory = opBinding.getTypeFactory();\n+\n+        final int n = opBinding.getOperandCount();\n+        if (n == 0) {\n+          return typeFactory.createSqlType(SqlTypeName.NULL);\n+        }\n+\n+        boolean hasDouble = false;\n+        for (int i = 0; i < n; i++) {\n+          RelDataType type = opBinding.getOperandType(i);\n+          if (SqlTypeUtil.isString(type) || SqlTypeUtil.isCharacter(type)) {\n+            return type;\n+          } else if (SqlTypeUtil.isDouble(type)) {", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwOTQ5MA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391109490", "bodyText": "You could probably come up with some tests for these cases too.", "author": "gianm", "createdAt": "2020-03-11T16:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMjY5Mw==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391112693", "bodyText": "Sorry if I'm mis-reading this.\nIt looks like this patch introduces expressions to calculate the greatest / least across multiple expressions. Native druid queries have a post aggregator that should do this. When I was thinking of implementing this I thought there would be a translation from sql to the native druid query with the correct post aggregator (maybe somewhere in here - OperatorConversions#toPostAggregator)\nOtherwise we'd want to make sure this behavior stays in sync with the Double/LongPostAggregators", "author": "suneet-s", "createdAt": "2020-03-11T16:46:21Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.\n+        return ExprEval.of(null);", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE4NTQ5NQ==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391185495", "bodyText": "Some relevant facts:\n\nIn SQL, these functions can be used in contexts that are not post-aggregation, so that means a native Druid post-aggregator is insufficient to cover all SQL use cases\nIn native Druid queries, there is an ExpressionPostAggregator, so an expression can cover the post-aggregation use case as well as all others.\n\nTogether these mean the expression does everything we want, and the greatest/least-specific post-aggregators aren't that useful. To keep things simple, the Druid SQL layer shouldn't use the post-aggregators, it should just use the expressions via an ExpressionPostAggregator (@ccaominh's patch does achieve this).\nI agree it would be good for them to be consistent, though.", "author": "gianm", "createdAt": "2020-03-11T18:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMjY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE4ODE3MA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391188170", "bodyText": "Ah makes sense. Thanks for the explanation! :)", "author": "suneet-s", "createdAt": "2020-03-11T18:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMjY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwOTgzOA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391809838", "bodyText": "Looks like the greatest/least post aggregator behavior is like postgres (ignore nulls, unless all are nulls), so another reason to switch the behavior of the expressions from mysql-like to postgres-like.", "author": "ccaominh", "createdAt": "2020-03-12T18:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMjY5Mw=="}], "type": "inlineReview"}, {"oid": "1a5a9610e9c6e10910059bc383238b5b88c5cbd6", "url": "https://github.com/apache/druid/commit/1a5a9610e9c6e10910059bc383238b5b88c5cbd6", "message": "Match postgres behavior & handle more SQL types", "committedDate": "2020-03-12T19:06:03Z", "type": "commit"}, {"oid": "5f0fcc03ac04411af6f50607db22a67e2ca3ddf8", "url": "https://github.com/apache/druid/commit/5f0fcc03ac04411af6f50607db22a67e2ca3ddf8", "message": "Merge remote-tracking branch 'upstream/master' into fix-greatest-least", "committedDate": "2020-03-12T19:07:00Z", "type": "commit"}, {"oid": "643a3fc6fa82df975f72148971a64179958c25b7", "url": "https://github.com/apache/druid/commit/643a3fc6fa82df975f72148971a64179958c25b7", "message": "Fix imports", "committedDate": "2020-03-12T19:10:25Z", "type": "commit"}]}