{"pr_number": 9407, "pr_title": "query laning and load shedding", "pr_createdAt": "2020-02-26T12:21:22Z", "pr_url": "https://github.com/apache/druid/pull/9407", "timeline": [{"oid": "6220985559b4fa941e25e61caa5846c7ce8e368a", "url": "https://github.com/apache/druid/commit/6220985559b4fa941e25e61caa5846c7ce8e368a", "message": "prototype", "committedDate": "2020-02-25T10:48:47Z", "type": "commit"}, {"oid": "3f410014da090c7df66df293a1894da3486cabaa", "url": "https://github.com/apache/druid/commit/3f410014da090c7df66df293a1894da3486cabaa", "message": "merge QueryScheduler and QueryManager", "committedDate": "2020-02-25T10:48:47Z", "type": "commit"}, {"oid": "feae8b193d73354366ce683c0ef405e366c8e31b", "url": "https://github.com/apache/druid/commit/feae8b193d73354366ce683c0ef405e366c8e31b", "message": "everything in its right place", "committedDate": "2020-02-25T10:48:47Z", "type": "commit"}, {"oid": "554b8b514a6c92d04f806960eaf33ebb366ab21a", "url": "https://github.com/apache/druid/commit/554b8b514a6c92d04f806960eaf33ebb366ab21a", "message": "adjustments", "committedDate": "2020-02-25T18:41:00Z", "type": "commit"}, {"oid": "0597c3f87117a8f35785a3cea7ba8f9b4e7e8511", "url": "https://github.com/apache/druid/commit/0597c3f87117a8f35785a3cea7ba8f9b4e7e8511", "message": "docs", "committedDate": "2020-02-26T12:15:34Z", "type": "commit"}, {"oid": "405c94e52988ebb1381b3e9337e1d6ff11331ada", "url": "https://github.com/apache/druid/commit/405c94e52988ebb1381b3e9337e1d6ff11331ada", "message": "fixes", "committedDate": "2020-02-27T11:38:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIwNDgyNw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r385204827", "bodyText": "a variety of mechanisms examine\nI believe a \"to\" is missing here ?", "author": "sascha-coenen", "createdAt": "2020-02-27T16:03:02Z", "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,31 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+Druid provides facilities to aid in query capacity reservation for heterogenous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms examine and classify a query at the broker, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane). ", "originalCommit": "405c94e52988ebb1381b3e9337e1d6ff11331ada", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e22ece12861765ec3eeccc6531c283e717785969", "url": "https://github.com/apache/druid/commit/e22ece12861765ec3eeccc6531c283e717785969", "message": "doc fixes", "committedDate": "2020-02-28T00:11:50Z", "type": "commit"}, {"oid": "e98cad76992ced1659ab75834bab7a8967eaa33e", "url": "https://github.com/apache/druid/commit/e98cad76992ced1659ab75834bab7a8967eaa33e", "message": "use resilience4j instead of semaphore", "committedDate": "2020-02-28T05:48:15Z", "type": "commit"}, {"oid": "2069437298c6b111804d0fd18034514c47ae8f1b", "url": "https://github.com/apache/druid/commit/2069437298c6b111804d0fd18034514c47ae8f1b", "message": "more tests", "committedDate": "2020-02-28T06:59:43Z", "type": "commit"}, {"oid": "eaf1449a360506a85257f16abe25201875af8387", "url": "https://github.com/apache/druid/commit/eaf1449a360506a85257f16abe25201875af8387", "message": "simplify", "committedDate": "2020-02-28T08:42:09Z", "type": "commit"}, {"oid": "688ca43af1f246dd6578e2ace96778cdb3571cff", "url": "https://github.com/apache/druid/commit/688ca43af1f246dd6578e2ace96778cdb3571cff", "message": "checkstyle", "committedDate": "2020-02-28T11:09:06Z", "type": "commit"}, {"oid": "f0b3f9f02be406e42e8fa523716c630d2b21aa36", "url": "https://github.com/apache/druid/commit/f0b3f9f02be406e42e8fa523716c630d2b21aa36", "message": "spelling", "committedDate": "2020-02-28T19:11:38Z", "type": "commit"}, {"oid": "87c6cbd1660d4981fc3618feed9210f91a218ca5", "url": "https://github.com/apache/druid/commit/87c6cbd1660d4981fc3618feed9210f91a218ca5", "message": "oops heh", "committedDate": "2020-02-28T22:15:22Z", "type": "commit"}, {"oid": "5e91bcba6661334d8b6d6dc745ce2cd68037ca0e", "url": "https://github.com/apache/druid/commit/5e91bcba6661334d8b6d6dc745ce2cd68037ca0e", "message": "remove unused", "committedDate": "2020-02-28T22:17:34Z", "type": "commit"}, {"oid": "912b7bc43d5406114f85e85918e04b8c01a9bf7f", "url": "https://github.com/apache/druid/commit/912b7bc43d5406114f85e85918e04b8c01a9bf7f", "message": "simplify", "committedDate": "2020-02-29T03:07:33Z", "type": "commit"}, {"oid": "1e384bf9e4d8c2cae1cf12e894aa2afa00e9a9c1", "url": "https://github.com/apache/druid/commit/1e384bf9e4d8c2cae1cf12e894aa2afa00e9a9c1", "message": "concurrency tests", "committedDate": "2020-03-02T11:48:27Z", "type": "commit"}, {"oid": "60861a43fd25bca15aa3215988252bc392b3ad3f", "url": "https://github.com/apache/druid/commit/60861a43fd25bca15aa3215988252bc392b3ad3f", "message": "add SqlResource tests, refactor error response", "committedDate": "2020-03-03T06:02:13Z", "type": "commit"}, {"oid": "9aed16e6ca23d413d30554ebfd8157210849e67b", "url": "https://github.com/apache/druid/commit/9aed16e6ca23d413d30554ebfd8157210849e67b", "message": "add json config tests", "committedDate": "2020-03-04T01:13:23Z", "type": "commit"}, {"oid": "419ab98ef48eb0a7590bb064393c424a553d3544", "url": "https://github.com/apache/druid/commit/419ab98ef48eb0a7590bb064393c424a553d3544", "message": "use LongAdder instead of AtomicLong", "committedDate": "2020-03-04T01:19:13Z", "type": "commit"}, {"oid": "f0d39e1dd4108c9ee803fd6335c515813a892d14", "url": "https://github.com/apache/druid/commit/f0d39e1dd4108c9ee803fd6335c515813a892d14", "message": "remove test only stuffs from scheduler", "committedDate": "2020-03-04T02:04:05Z", "type": "commit"}, {"oid": "2afaaf1150b7808e8543e87eecf45ecd9bf8b9fe", "url": "https://github.com/apache/druid/commit/2afaaf1150b7808e8543e87eecf45ecd9bf8b9fe", "message": "javadocs, etc", "committedDate": "2020-03-04T11:45:53Z", "type": "commit"}, {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "url": "https://github.com/apache/druid/commit/ef029c4a894aafd4b17ca903e77ae497e41034ba", "message": "style", "committedDate": "2020-03-04T12:13:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MjcxNQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r387962715", "bodyText": "Perhaps the setting name (\"type\") and the name in the docs (\"strategy\") should be made consistent.\nIn terms of documentation flow, it may be helpful to add a section below (e.g. \"Laning strategy\") and reference it here. \"No laning strategy\", etc. would be children on this new section.", "author": "ccaominh", "createdAt": "2020-03-04T22:05:13Z", "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,31 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|\n+|`druid.query.scheduler.laning.type`|Query laning strategy to use to assign queries to a lane in order to control capacities for certain classes of queries.|`none`|", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1NDk5NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388754995", "bodyText": "druid.query.scheduler.laning.strategy seems reasonable, will switch", "author": "clintropolis", "createdAt": "2020-03-06T07:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MjcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2NjExMg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389166112", "bodyText": "With regards to documentation flow, I had made the suggested change in a branch I intend to follow-up with: clintropolis/druid@query-laning-and-load-shedding...clintropolis:query-auto-prioritization\nI wasn't sure if it made sense to break down yet in this branch because only the laning strategy exists, where as in that branch the scheduler also now has a prioritization strategy. I can go ahead and pull that part back of the doc change back into this PR though.", "author": "clintropolis", "createdAt": "2020-03-06T22:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MjcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2NDUwNQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r387964505", "bodyText": "Consider adding:\nThis strategy can be enabled by setting druid.query.scheduler.laning.type to none.", "author": "ccaominh", "createdAt": "2020-03-04T22:09:05Z", "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,31 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|\n+|`druid.query.scheduler.laning.type`|Query laning strategy to use to assign queries to a lane in order to control capacities for certain classes of queries.|`none`|\n+\n+###### No laning strategy\n+\n+In this mode, queries are never assigned a lane and only limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode.\n+", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTc4NA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r387991784", "bodyText": "Was this added to the docs?", "author": "ccaominh", "createdAt": "2020-03-04T23:16:48Z", "path": "processing/src/main/java/org/apache/druid/query/QueryContexts.java", "diffHunk": "@@ -35,6 +35,7 @@\n public class QueryContexts\n {\n   public static final String PRIORITY_KEY = \"priority\";\n+  public static final String LANE_KEY = \"lane\";", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1NTUzNA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388755534", "bodyText": "No, I hadn't documented since I hadn't decided the behavior of whether or not a lane specified in the query context by the user should override the laning strategy, or if it should be laning strategy specific, see other comment about this", "author": "clintropolis", "createdAt": "2020-03-06T07:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5OTE0OA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r387999148", "bodyText": "There's some similarity between this and QueryInterruptedException and ResourceLimitExceededException and at first glance it may be unclear when to use which (perhaps mitigated by adding javadocs to this class). Is there a way to incorporate this into the same pattern in the QueryInterruptedException implementation?", "author": "ccaominh", "createdAt": "2020-03-04T23:38:35Z", "path": "server/src/main/java/org/apache/druid/server/QueryCapacityExceededException.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.QueryException;\n+\n+public class QueryCapacityExceededException extends QueryException", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1MjQzMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388752431", "bodyText": "I think I would agree that this area probably needs a refactor, maybe more suitable to be done in a follow-up PR, but will try to at least add some javadocs to clarify that the QueryExceptions are intended to be the main exceptions we surface from the API provided by QueryResource and SqlResource. Currently QueryInterruptedException is specifically caught and tied to HTTP 500 errors in these classes, so I split out QueryCapacityExceededException so that I could catch it separately and respond with the 429 status code (or 503, whatever we end up going with).", "author": "clintropolis", "createdAt": "2020-03-06T07:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5OTE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMjk5OQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388012999", "bodyText": "Is it useful to test when QueryContexts.LANE_KEY is set?", "author": "ccaominh", "createdAt": "2020-03-05T00:23:34Z", "path": "server/src/test/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategyTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.query.Druids;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.timeseries.TimeseriesQuery;\n+import org.apache.druid.server.QueryLaningStrategy;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+public class HiLoQueryLaningStrategyTest\n+{\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  private Druids.TimeseriesQueryBuilder queryBuilder;\n+  private HiLoQueryLaningStrategy strategy;\n+\n+  @Before\n+  public void setup()\n+  {\n+    this.queryBuilder = Druids.newTimeseriesQueryBuilder()\n+                              .dataSource(\"test\")\n+                              .intervals(ImmutableList.of(Intervals.ETERNITY))\n+                              .granularity(Granularities.DAY)\n+                              .aggregators(new CountAggregatorFactory(\"count\"));\n+\n+    this.strategy = new HiLoQueryLaningStrategy(10);\n+  }\n+\n+  @Test\n+  public void testMaxLowThreadsRequired()\n+  {\n+    expectedException.expect(NullPointerException.class);\n+    expectedException.expectMessage(\"maxLowThreads must be set\");\n+    QueryLaningStrategy strategy = new HiLoQueryLaningStrategy(null);\n+  }\n+\n+  @Test\n+  public void testLaneLimits()\n+  {\n+    Object2IntMap<String> laneConfig = strategy.getLaneLimits();\n+    Assert.assertEquals(1, laneConfig.size());\n+    Assert.assertTrue(laneConfig.containsKey(HiLoQueryLaningStrategy.LOW));\n+    Assert.assertEquals(10, laneConfig.getInt(HiLoQueryLaningStrategy.LOW));\n+  }\n+\n+  @Test\n+  public void testLaningNoPriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.build();\n+    Assert.assertFalse(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+  }\n+\n+  @Test\n+  public void testLaningZeroPriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.context(ImmutableMap.of(QueryContexts.PRIORITY_KEY, 0)).build();\n+    Assert.assertFalse(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+  }\n+\n+  @Test\n+  public void testLaningInteractivePriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.context(ImmutableMap.of(QueryContexts.PRIORITY_KEY, 100)).build();\n+    Assert.assertFalse(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+  }\n+\n+  @Test\n+  public void testLaningLowPriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.context(ImmutableMap.of(QueryContexts.PRIORITY_KEY, -1)).build();\n+    Assert.assertTrue(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+    Assert.assertEquals(\n+        HiLoQueryLaningStrategy.LOW,\n+        strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).get()\n+    );\n+  }\n+}", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1NDE4Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388754187", "bodyText": "Hmm, I'm not yet quite sure if not allowing a laning strategy to override the manually set context value is the correct behavior yet, so I didn't add a test.\nDo you have any thoughts on whether or not to replace an explicit, user specified lane be delegated to the laning strategy? The more I think about it the more I think the laning strategy should get to choose, so I think I'm going to change the behavior. If we still think that hilo should honor the user specified lane, then I can add a test for that (or add a test that it is overridden if we decide to go in the other direction).", "author": "clintropolis", "createdAt": "2020-03-06T07:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMjk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3Mjg0OQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389072849", "bodyText": "Since the user can select a lane by setting the priority in the query context, I'm not sure of the benefit of also having a lane in the query context. Later, when there's automatic setting of the lane/priority, I think it should first respect the value in the query context if there's one before applying the automatic behavior.", "author": "ccaominh", "createdAt": "2020-03-06T18:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMjk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MTA5Mw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389161093", "bodyText": "I think there are a few reasons to put it on the query context. For one to propagate the value downstream to historical and realtime tasks so they can utilize that information in the future to also make load management decisions.\nBut also, I'm not sure that lane necessarily has to be related to priority just because the current implementation I have provided is. It is really just a label used to enforce limits.\nIn my list of potential follow-up work, I wanted to support a manual laning strategy that only supports explicit use defined lanes on the context both to make integration tests easier but also just to account for scenarios where an external application drives these decisions and still wishes to enforce limits on classes of queries. I also suggested a tier based laning strategy, which would not be related to priority, but rather the set of servers it is going to be querying.", "author": "clintropolis", "createdAt": "2020-03-06T21:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMjk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjI3OQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388016279", "bodyText": "Perhaps rename to maxLowHttpThreads so that it's not confused with the number of processing threads", "author": "ccaominh", "createdAt": "2020-03-05T00:35:09Z", "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,31 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|\n+|`druid.query.scheduler.laning.type`|Query laning strategy to use to assign queries to a lane in order to control capacities for certain classes of queries.|`none`|\n+\n+###### No laning strategy\n+\n+In this mode, queries are never assigned a lane and only limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode.\n+\n+###### 'High/Low' laning strategy\n+This laning strategy splits queries with a `priority` below zero into a `low` query lane, automatically. The limit on `low` queries can be set to some desired fraction of the total capacity (or HTTP thread pool size), reserving capacity for interactive queries. Queries in the `low` lane are _not_ guaranteed their capacity, which may be consumed by interactive queries, but may use up to this limit if total capacity is available. \n+\n+This strategy can be enabled by setting `druid.query.scheduler.laning.type` to `hilo`.\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.laning.maxLowThreads`|Maximum number of HTTP threads that can be used by queries with a priority lower than 0.|No default, must be set if using this mode|", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1MTcwMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388751700", "bodyText": "I'm not sure I agree that it is particularly confusing, since the HTTP setting is druid.server.http.numThreads and the new scheduler 'total' lane is druid.query.scheduler.numThreads. Are you considering the hypothetical of if we ever decided to extend the concept of laning to the processing pool I guess?\nWould this setting be better as a percentage, so one property could be applicable to either usage? It doesn't seem like it would be hard to switch, would just need to adjust QueryLaningStrategy.getLaneLimits to take the 'total' limit, and make ServerConfig available to the QueryScheduler so it could fall back to druid.server.http.numThreads if druid.query.scheduler.numThreads isn't set. ServerConfig should probably already be provided to QueryScheduler so it can treat the case where druid.query.scheduler.numThreads is higher than druid.server.http.numThreads the same as not setting the scheduler numThreads at all and ignoring total limiter.", "author": "clintropolis", "createdAt": "2020-03-06T07:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MjY0OA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389162648", "bodyText": "reworked/renamed to maxLowPercent to be more flexible", "author": "clintropolis", "createdAt": "2020-03-06T21:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjU0Ng==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388016546", "bodyText": "Left a comment in the docs about the property name", "author": "ccaominh", "createdAt": "2020-03-05T00:35:56Z", "path": "server/src/main/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Query laning strategy which associates all {@link Query} with priority lower than 0 into a 'low' lane\n+ */\n+public class HiLoQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  public static final String LOW = \"low\";\n+\n+  @JsonProperty\n+  private final int maxLowThreads;\n+\n+  @JsonCreator\n+  public HiLoQueryLaningStrategy(\n+      @JsonProperty(\"maxLowThreads\") Integer maxLowThreads", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMTg1MQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388631851", "bodyText": "Thanks for adding all the javadocs that were missing before!", "author": "ccaominh", "createdAt": "2020-03-05T23:51:24Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjI1Ng==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388632256", "bodyText": "Consider adding a named constant for the -1 (similar for getLaneAvailableCapacity)", "author": "ccaominh", "createdAt": "2020-03-05T23:52:49Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1OTcyMw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388659723", "bodyText": "May be better to do this in a exception handler in case there's an unexpected error between the two acquisitions. I don't think there's a test for this scenario?", "author": "ccaominh", "createdAt": "2020-03-06T01:05:11Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  public int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want\n+    // to check for total capacity exceeded and release the lane (if present) before throwing capacity exceeded\n+    totalConfig.ifPresent(config -> {\n+      Bulkhead totalLimiter = laneRegistry.bulkhead(TOTAL, config);\n+      if (!totalLimiter.tryAcquirePermission()) {\n+        releaseLanes(hallPasses);", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1OTIyMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388759220", "bodyText": "Hmm, I couldn't find an exception that would be thrown in this block, tryAcquirePermission eats InterruptedException and also the timeout is configured to 0 so the underlying semaphore call takes a code path that shouldn't explode, so I imagined any exception that happens where would be indicative of a catastrophic failure or the jetty server shutting down.\nThat said, I guess it doesn't harm much to wrap in a try catch and rethrow after releasing.\nThis isn't explicitly tested for, but a shadow of it being tested is visible in the concurrency tests which flex the case where a lane was acquired but the total could not be in this assert that the 'lane released' count is equal to the 'lane acquired' + 'lane not acquired' count which fails if we don't consider the 'lane not acquired' count.", "author": "clintropolis", "createdAt": "2020-03-06T08:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1OTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MjA1MQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388662051", "bodyText": "Maybe rename to \"bulkhead\"", "author": "ccaominh", "createdAt": "2020-03-06T01:08:33Z", "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.inject.Injector;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import org.apache.druid.guice.GuiceInjectors;\n+import org.apache.druid.guice.JsonConfigProvider;\n+import org.apache.druid.guice.JsonConfigurator;\n+import org.apache.druid.guice.annotations.Global;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.BaseSequence;\n+import org.apache.druid.java.util.common.guava.LazySequence;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.java.util.common.guava.SequenceWrapper;\n+import org.apache.druid.java.util.common.guava.Sequences;\n+import org.apache.druid.java.util.common.guava.Yielder;\n+import org.apache.druid.java.util.common.guava.Yielders;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.topn.TopNQuery;\n+import org.apache.druid.query.topn.TopNQueryBuilder;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class QuerySchedulerTest\n+{\n+  private static final int NUM_CONCURRENT_QUERIES = 10000;\n+  private static final int NUM_ROWS = 10000;\n+\n+  @Rule\n+  public ExpectedException expected = ExpectedException.none();\n+\n+  private ListeningExecutorService executorService;\n+  private QueryScheduler scheduler;\n+\n+  private AtomicLong totalAcquired;\n+  private AtomicLong totalReleased;\n+  private AtomicLong laneAcquired;\n+  private AtomicLong laneNotAcquired;\n+  private AtomicLong laneReleased;\n+\n+  @Before\n+  public void setup()\n+  {\n+    executorService = MoreExecutors.listeningDecorator(\n+        Execs.multiThreaded(8, \"test_query_scheduler_%s\")\n+    );\n+    totalAcquired = new AtomicLong();\n+    totalReleased = new AtomicLong();\n+    laneAcquired = new AtomicLong();\n+    laneNotAcquired = new AtomicLong();\n+    laneReleased = new AtomicLong();\n+    scheduler = new QueryScheduler(5, new HiLoQueryLaningStrategy(2)) {\n+      @Override\n+      List<Bulkhead> acquireLanes(Query<?> query)\n+      {\n+        List<Bulkhead> bulkheads = super.acquireLanes(query);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalAcquired.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneAcquired.incrementAndGet();\n+        }\n+\n+        return bulkheads;\n+      }\n+\n+      @Override\n+      void releaseLanes(List<Bulkhead> bulkheads)\n+      {\n+        super.releaseLanes(bulkheads);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalReleased.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneReleased.incrementAndGet();\n+          if (bulkheads.size() == 1) {\n+            laneNotAcquired.incrementAndGet();\n+          }\n+        }\n+      }\n+    };\n+  }\n+\n+  @After\n+  public void teardown()\n+  {\n+    executorService.shutdownNow();\n+  }\n+\n+  @Test\n+  public void testHiLoHi() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery interactive = makeInteractiveQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduled = scheduler.laneQuery(QueryPlus.wrap(interactive), ImmutableSet.of());\n+\n+        Assert.assertNotNull(scheduled);\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduled, underlyingSequence);\n+        int rowCount = consumeAndCloseSequence(results);\n+\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+  }\n+\n+  @Test\n+  public void testHiLoLo() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery report = makeReportQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduledReport = scheduler.laneQuery(QueryPlus.wrap(report), ImmutableSet.of());\n+        Assert.assertNotNull(scheduledReport);\n+        Assert.assertEquals(HiLoQueryLaningStrategy.LOW, QueryContexts.getLane(scheduledReport));\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduledReport, underlyingSequence);\n+\n+        int rowCount = consumeAndCloseSequence(results);\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+  }\n+\n+  @Test\n+  public void testHiLoReleaseSemaphoreWhenSequenceExplodes() throws Exception", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MzE4Ng==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388663186", "bodyText": "This assert is not executed. Maybe use an exception handler instead of expected?", "author": "ccaominh", "createdAt": "2020-03-06T01:11:05Z", "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.inject.Injector;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import org.apache.druid.guice.GuiceInjectors;\n+import org.apache.druid.guice.JsonConfigProvider;\n+import org.apache.druid.guice.JsonConfigurator;\n+import org.apache.druid.guice.annotations.Global;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.BaseSequence;\n+import org.apache.druid.java.util.common.guava.LazySequence;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.java.util.common.guava.SequenceWrapper;\n+import org.apache.druid.java.util.common.guava.Sequences;\n+import org.apache.druid.java.util.common.guava.Yielder;\n+import org.apache.druid.java.util.common.guava.Yielders;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.topn.TopNQuery;\n+import org.apache.druid.query.topn.TopNQueryBuilder;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class QuerySchedulerTest\n+{\n+  private static final int NUM_CONCURRENT_QUERIES = 10000;\n+  private static final int NUM_ROWS = 10000;\n+\n+  @Rule\n+  public ExpectedException expected = ExpectedException.none();\n+\n+  private ListeningExecutorService executorService;\n+  private QueryScheduler scheduler;\n+\n+  private AtomicLong totalAcquired;\n+  private AtomicLong totalReleased;\n+  private AtomicLong laneAcquired;\n+  private AtomicLong laneNotAcquired;\n+  private AtomicLong laneReleased;\n+\n+  @Before\n+  public void setup()\n+  {\n+    executorService = MoreExecutors.listeningDecorator(\n+        Execs.multiThreaded(8, \"test_query_scheduler_%s\")\n+    );\n+    totalAcquired = new AtomicLong();\n+    totalReleased = new AtomicLong();\n+    laneAcquired = new AtomicLong();\n+    laneNotAcquired = new AtomicLong();\n+    laneReleased = new AtomicLong();\n+    scheduler = new QueryScheduler(5, new HiLoQueryLaningStrategy(2)) {\n+      @Override\n+      List<Bulkhead> acquireLanes(Query<?> query)\n+      {\n+        List<Bulkhead> bulkheads = super.acquireLanes(query);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalAcquired.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneAcquired.incrementAndGet();\n+        }\n+\n+        return bulkheads;\n+      }\n+\n+      @Override\n+      void releaseLanes(List<Bulkhead> bulkheads)\n+      {\n+        super.releaseLanes(bulkheads);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalReleased.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneReleased.incrementAndGet();\n+          if (bulkheads.size() == 1) {\n+            laneNotAcquired.incrementAndGet();\n+          }\n+        }\n+      }\n+    };\n+  }\n+\n+  @After\n+  public void teardown()\n+  {\n+    executorService.shutdownNow();\n+  }\n+\n+  @Test\n+  public void testHiLoHi() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery interactive = makeInteractiveQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduled = scheduler.laneQuery(QueryPlus.wrap(interactive), ImmutableSet.of());\n+\n+        Assert.assertNotNull(scheduled);\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduled, underlyingSequence);\n+        int rowCount = consumeAndCloseSequence(results);\n+\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+  }\n+\n+  @Test\n+  public void testHiLoLo() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery report = makeReportQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduledReport = scheduler.laneQuery(QueryPlus.wrap(report), ImmutableSet.of());\n+        Assert.assertNotNull(scheduledReport);\n+        Assert.assertEquals(HiLoQueryLaningStrategy.LOW, QueryContexts.getLane(scheduledReport));\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduledReport, underlyingSequence);\n+\n+        int rowCount = consumeAndCloseSequence(results);\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+  }\n+\n+  @Test\n+  public void testHiLoReleaseSemaphoreWhenSequenceExplodes() throws Exception\n+  {\n+    expected.expectMessage(\"exploded\");\n+    expected.expect(ExecutionException.class);\n+    TopNQuery interactive = makeInteractiveQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduled = scheduler.laneQuery(QueryPlus.wrap(interactive), ImmutableSet.of());\n+\n+        Assert.assertNotNull(scheduled);\n+\n+        Sequence<Integer> underlyingSequence = makeExplodingSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduled, underlyingSequence);\n+\n+        consumeAndCloseSequence(results);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MTkxNA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388761914", "bodyText": "Ah, i think that was a leftover from copying another test to make this one, but I think it does seem useful to assert that the token was released after the exception so will change", "author": "clintropolis", "createdAt": "2020-03-06T08:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MzE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NTY1NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388665655", "bodyText": "This and the method below are public but they appear to just be used in the unit test.", "author": "ccaominh", "createdAt": "2020-03-06T01:20:30Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjM1OA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388666358", "bodyText": "What's the purpose of the TOTAL bulkhead if each lane has a bulkhead?", "author": "ccaominh", "createdAt": "2020-03-06T01:23:02Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  public int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1NDU2OQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388754569", "bodyText": "the total is to control overall query throughput, and is tied to druid.query.scheduler.numThreads. Even queries without a lane are subject to this limit, if configured. I'll try to make this more clear in the javadocs or comments.", "author": "clintropolis", "createdAt": "2020-03-06T07:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3Mzc4Mg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389073782", "bodyText": "I was thinking that if there are only counters per lane, then the code would be simpler as the lane and total counter would not have to be kept consistent.", "author": "ccaominh", "createdAt": "2020-03-06T18:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1OTIzMw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389159233", "bodyText": "that is true, but I wanted to dual purpose this to also be able to set total limits to protect the rest of the service from the query processing system, and save room for health checks and the like.\nAs I discussed in the description, I considered that the total counter specifically might be suitable as a jetty QoSFilter, which also is using a semaphore, however we would need to ensure that we set the request timeout high enough to give the laned queries time to fail and release the semaphore since the total would now be getting acquired before the lane. It seemed easier to me to track here than to precisely determine that interval, however the discussion is worth having I think.", "author": "clintropolis", "createdAt": "2020-03-06T21:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjU4Mg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388666582", "bodyText": "Missing blank line", "author": "ccaominh", "createdAt": "2020-03-06T01:23:44Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/CalciteTests.java", "diffHunk": "@@ -700,6 +701,14 @@ public static SpecificSegmentsQuerySegmentWalker createMockWalker(\n       final QueryRunnerFactoryConglomerate conglomerate,\n       final File tmpDir\n   )\n+  {\n+    return createMockWalker(conglomerate, tmpDir, null);\n+  }\n+  public static SpecificSegmentsQuerySegmentWalker createMockWalker(", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NzA4Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388667087", "bodyText": "Which tests cover this block?", "author": "ccaominh", "createdAt": "2020-03-06T01:25:28Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/SpecificSegmentsQuerySegmentWalker.java", "diffHunk": "@@ -388,13 +410,33 @@ public SegmentDescriptor getDescriptor()\n           toolChest\n       );\n \n+\n       // Wrap baseRunner in a runner that rewrites the QuerySegmentSpec to mention the specific segments.\n       // This mimics what CachingClusteredClient on the Broker does, and is required for certain queries (like Scan)\n       // to function properly.\n-      return (theQuery, responseContext) -> baseRunner.run(\n-          theQuery.withQuery(Queries.withSpecificSegments(theQuery.getQuery(), ImmutableList.copyOf(specs))),\n-          responseContext\n-      );\n+      return (theQuery, responseContext) -> {\n+        if (scheduler != null) {\n+          Set<SegmentServerSelector> segments = new HashSet<>();\n+          specs.forEach(spec -> segments.add(new SegmentServerSelector(null, spec)));\n+          return scheduler.run(\n+              scheduler.laneQuery(theQuery, segments),\n+              new LazySequence<>(\n+                  () -> baseRunner.run(\n+                      theQuery.withQuery(Queries.withSpecificSegments(\n+                          theQuery.getQuery(),\n+                          ImmutableList.copyOf(specs)\n+                      )),\n+                      responseContext\n+                  )\n+              )\n+          );", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MTIyOA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388761228", "bodyText": "If you mean which tests use this block, then it is the SqlResourceTest which create this thing with a scheduler.\nNo laning strategy is currently using the set of SegmentServerSelector to make decisions at this time, I just went ahead and wired it up because we do have the set of SegmentDescriptors available here, in anticipation of some future usage. With the ServerSelector part of that set to null though, we would probably want to either have a mock or artifical set of servers to pretend to serve the test segments, so it might still need some future work?", "author": "clintropolis", "createdAt": "2020-03-06T08:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NzA4Nw=="}], "type": "inlineReview"}, {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "url": "https://github.com/apache/druid/commit/059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "message": "partial review stuffs", "committedDate": "2020-03-06T12:59:58Z", "type": "commit"}, {"oid": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "url": "https://github.com/apache/druid/commit/0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "message": "adjust", "committedDate": "2020-03-06T21:04:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1MDMyOQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389050329", "bodyText": "Provide a map?", "author": "jihoonson", "createdAt": "2020-03-06T17:47:52Z", "path": "server/src/main/java/org/apache/druid/server/QueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"strategy\", defaultImpl = NoQueryLaningStrategy.class)\n+@JsonSubTypes(value = {\n+    @JsonSubTypes.Type(name = \"none\", value = NoQueryLaningStrategy.class),\n+    @JsonSubTypes.Type(name = \"hilo\", value = HiLoQueryLaningStrategy.class)\n+})\n+public interface QueryLaningStrategy\n+{\n+  /**\n+   * Provide map of lane names to the limit on the number of concurrent queries for that lane", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NDkwMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389064900", "bodyText": "Probably the javadoc of this method (or this class) should say that this class is used in QueryScheduler and should be thread-safe.", "author": "jihoonson", "createdAt": "2020-03-06T18:19:33Z", "path": "server/src/main/java/org/apache/druid/server/QueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"strategy\", defaultImpl = NoQueryLaningStrategy.class)\n+@JsonSubTypes(value = {\n+    @JsonSubTypes.Type(name = \"none\", value = NoQueryLaningStrategy.class),\n+    @JsonSubTypes.Type(name = \"hilo\", value = HiLoQueryLaningStrategy.class)\n+})\n+public interface QueryLaningStrategy\n+{\n+  /**\n+   * Provide map of lane names to the limit on the number of concurrent queries for that lane\n+   * @param totalLimit\n+   */\n+  Object2IntMap<String> getLaneLimits(int totalLimit);\n+\n+  /**\n+   * For a given {@link QueryPlus} and set of {@link SegmentServerSelector}, compute if a query belongs to a lane\n+   */\n+  <T> Optional<String> computeLane(QueryPlus<T> query, Set<SegmentServerSelector> segments);", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTIzMg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219232", "bodyText": "added", "author": "clintropolis", "createdAt": "2020-03-07T02:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NjE4NA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389066184", "bodyText": "Please add a comment what the key and the value are.", "author": "jihoonson", "createdAt": "2020-03-06T18:22:16Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTIxNQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219215", "bodyText": "added javadoc", "author": "clintropolis", "createdAt": "2020-03-07T02:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NjE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NzgyMg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389077822", "bodyText": "I find this comment confusing. There will be multiple futures of the same ID in historicals most of the time unless the query reads only one segment in a historical. Probably better to comment about what could happen in brokers and historicals.", "author": "jihoonson", "createdAt": "2020-03-06T18:46:07Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NzUwNw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389157507", "bodyText": "Oh nvm, I thought that the historical can register multiple futures per segment for the same query which is not true. They always register only one future for one query.", "author": "jihoonson", "createdAt": "2020-03-06T21:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MjI1MA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389162250", "bodyText": "Ah, the comment was referring to the fact that query id can be manually set, like if you and I both send queries with the same id, one of us cancelling would cancel both I think.", "author": "clintropolis", "createdAt": "2020-03-06T21:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTIxMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219211", "bodyText": "I adjusted the comment to try and clear up what i was talking about", "author": "clintropolis", "createdAt": "2020-03-07T02:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NzgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4ODYwMw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389088603", "bodyText": "Please comment that this class is used in everywhere including historicals and tasks.", "author": "jihoonson", "createdAt": "2020-03-06T19:09:14Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389121756", "bodyText": "It seems racy that two queries can compete on a particular lane and the total lane separately. I guess it would be a better behavior if it guarantees the first-come, first-served basis.", "author": "jihoonson", "createdAt": "2020-03-06T20:13:54Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  @VisibleForTesting\n+  int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  @VisibleForTesting\n+  int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1MzMxMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389153310", "bodyText": "yeah, it is definitely racy, but didn't seem especially harmful, is it worth the extra lock (not sure what would be most appropriate, striped on lane i guess?) we would have to hold to grab both and have truly fair behavior?", "author": "clintropolis", "createdAt": "2020-03-06T21:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3Nzk3NA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389177974", "bodyText": "Hmm I can imagine that a user issues a high-priority query immediately followed by a low-priority query. Due to the nature of concurrent execution, even if the high-priority query reached to here first, the low-priority query could execute the code before the high-priority one does. Then the high-priority query could be rejected if the low-priority query took the last available slot in the total lane.\nI guess the upside is the more deterministic and thus predictable behavior while the downside is the overhead of the extra lock. How bad is the extra lock? It seems ok?", "author": "jihoonson", "createdAt": "2020-03-06T22:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNDIwMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389214201", "bodyText": "The lock overhead doesn't seem like it would be too much, but it also doesn't seem like it would change much, especially when queries are not in the same lane. I added some comments that discuss how the lane acquiring is not fair", "author": "clintropolis", "createdAt": "2020-03-07T01:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNTQxNw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389215417", "bodyText": "The comment sounds good to me. Thanks.", "author": "jihoonson", "createdAt": "2020-03-07T01:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNDg5Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389124897", "bodyText": "nit: the javadoc of releasePermission says:\n    /**\n     * Releases a permission and increases the number of available permits by one.\n     * <p>\n     * Should only be used when a permission was acquired but not used. Otherwise use {@link\n     * Bulkhead#onComplete()} to signal a completed call and release a permission.\n     */\n    void releasePermission();\nreleasePermission() and onComplete() of SemaphoreBulkhead are:\n    @Override\n    public void releasePermission() {\n        semaphore.release();\n    }\n\n    @Override\n    public void onComplete() {\n        semaphore.release();\n        publishBulkheadEvent(() -> new BulkheadOnCallFinishedEvent(name));\n    }\nI think it's safe to call releasePermission() for now since we don't use the EventPublisher, but it still wouldn't harm to use onComplete(). It would also probably be better to avoid potential bugs if we want to use EventPublisher in the future.", "author": "jihoonson", "createdAt": "2020-03-06T20:21:23Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  @VisibleForTesting\n+  int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  @VisibleForTesting\n+  int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want\n+    // to check for total capacity exceeded and release the lane (if present) before throwing capacity exceeded\n+    totalConfig.ifPresent(config -> {\n+      Bulkhead totalLimiter = laneRegistry.bulkhead(TOTAL, config);\n+      if (!totalLimiter.tryAcquirePermission()) {\n+        releaseLanes(hallPasses);\n+        throw new QueryCapacityExceededException();\n+      }\n+      hallPasses.add(totalLimiter);\n+    });\n+    return hallPasses;\n+  }\n+\n+  /**\n+   * Release all {@link Bulkhead} semaphores in the list\n+   */\n+  @VisibleForTesting\n+  void releaseLanes(List<Bulkhead> bulkheads)\n+  {\n+    bulkheads.forEach(Bulkhead::releasePermission);", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MTg3MA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389161870", "bodyText": "good catch", "author": "clintropolis", "createdAt": "2020-03-06T21:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNTQzNg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389125436", "bodyText": "hastotalLimit -> hasTotalLimit", "author": "jihoonson", "createdAt": "2020-03-06T20:22:36Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  @VisibleForTesting\n+  int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  @VisibleForTesting\n+  int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want\n+    // to check for total capacity exceeded and release the lane (if present) before throwing capacity exceeded\n+    totalConfig.ifPresent(config -> {\n+      Bulkhead totalLimiter = laneRegistry.bulkhead(TOTAL, config);\n+      if (!totalLimiter.tryAcquirePermission()) {\n+        releaseLanes(hallPasses);\n+        throw new QueryCapacityExceededException();\n+      }\n+      hallPasses.add(totalLimiter);\n+    });\n+    return hallPasses;\n+  }\n+\n+  /**\n+   * Release all {@link Bulkhead} semaphores in the list\n+   */\n+  @VisibleForTesting\n+  void releaseLanes(List<Bulkhead> bulkheads)\n+  {\n+    bulkheads.forEach(Bulkhead::releasePermission);\n+  }\n+\n+  /**\n+   * With a total thread count and {@link QueryLaningStrategy#getLaneLimits}, create a map of lane name to\n+   * {@link BulkheadConfig} to be used to create the {@link #laneRegistry}. This accepts the configured value of\n+   * numThreads rather than using {@link #totalCapacity} so that we only have a total {@link Bulkhead} if\n+   * {@link QuerySchedulerConfig#getNumThreads()} is set\n+   */\n+  private Map<String, BulkheadConfig> getLaneConfigs(boolean hastotalLimit)", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389160387", "bodyText": "Does it make sense to add maxCapacity as well?", "author": "jihoonson", "createdAt": "2020-03-06T21:47:35Z", "path": "server/src/main/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Query laning strategy which associates all {@link Query} with priority lower than 0 into a 'low' lane\n+ */\n+public class HiLoQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  public static final String LOW = \"low\";\n+\n+  @JsonProperty\n+  private final int maxLowPercent;", "originalCommit": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MTcxOQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389161719", "bodyText": "hmm, this is the maximum number of concurrent queries for this lane.\ndruid.query.scheduler.numThreads or druid.server.http.numThreads define the maximum number of concurrent running queries, but it's not lane specific.", "author": "clintropolis", "createdAt": "2020-03-06T21:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3MzQyNQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389173425", "bodyText": "I mean, sometimes you may want to increase the total capacity, but keep it as it is for the low lane. In that case, maxCapacity would be more convenient because you don't have to change the configuration.", "author": "jihoonson", "createdAt": "2020-03-06T22:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NTM5NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389175395", "bodyText": "Ah, so do you mean the lane limit should be the min or (or max?) of maxCapacity and maxLowPercent of totalLimit when computing the lane limits?", "author": "clintropolis", "createdAt": "2020-03-06T22:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3Njg1Mg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389176852", "bodyText": "We could do that. Or we can allow either maxLowPercent or maxCapacity to be set.", "author": "jihoonson", "createdAt": "2020-03-06T22:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTE1Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219157", "bodyText": "Would it be ok to do this addition in a follow-up PR? Originally this setting was maxLowThreads, but i switched to being percent based to be more versatile. However, it does seem maybe useful to allow one or the other to be set.", "author": "clintropolis", "createdAt": "2020-03-07T02:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTc2NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219765", "bodyText": "Sounds good to me.", "author": "jihoonson", "createdAt": "2020-03-07T02:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjIyNQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389176225", "bodyText": "Maybe worth to say what configuration is related to this error. See https://github.com/apache/druid/blob/master/processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/Groupers.java#L39 as an example.", "author": "jihoonson", "createdAt": "2020-03-06T22:32:59Z", "path": "server/src/main/java/org/apache/druid/server/QueryCapacityExceededException.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.QueryException;\n+\n+public class QueryCapacityExceededException extends QueryException\n+{\n+  private static final String ERROR_CLASS = QueryCapacityExceededException.class.getName();\n+  public static final String ERROR_CODE = \"Query capacity exceeded\";\n+  public static final String ERROR_MESSAGE = \"Total query capacity exceeded\";\n+  public static final String ERROR_MESSAGE_TEMPLATE = \"Query capacity exceeded for lane %s\";", "originalCommit": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNDA4Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389214087", "bodyText": "This seems like maybe a good idea, but I am also afraid it might be a little chatty. I think people would expect to see these error messages if they configure limits, especially since there are no default limits. I think is maybe a bit different than the message you referenced, which I think is more likely something that would be bumped into by accident while trying to query something too big. Maybe if i document the error responses to expect in the configuration documentation that would be useful enough?", "author": "clintropolis", "createdAt": "2020-03-07T01:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNTI3OA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389215278", "bodyText": "That sounds good to me.", "author": "jihoonson", "createdAt": "2020-03-07T01:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxODg1MA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389218850", "bodyText": "Added docs to querying.md with the other error response documentation", "author": "clintropolis", "createdAt": "2020-03-07T02:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjIyNQ=="}], "type": "inlineReview"}, {"oid": "5711fce706bbd23a5f7b559ff91e4288ea8ad96d", "url": "https://github.com/apache/druid/commit/5711fce706bbd23a5f7b559ff91e4288ea8ad96d", "message": "review stuffs", "committedDate": "2020-03-07T01:14:28Z", "type": "commit"}, {"oid": "aa73a14a056e61f14a0927e8a029da999f95fc1c", "url": "https://github.com/apache/druid/commit/aa73a14a056e61f14a0927e8a029da999f95fc1c", "message": "more javadoc", "committedDate": "2020-03-07T01:22:25Z", "type": "commit"}, {"oid": "50847af1a17bb2fa2a8bff12ee32e4476fe67a86", "url": "https://github.com/apache/druid/commit/50847af1a17bb2fa2a8bff12ee32e4476fe67a86", "message": "error response documentation", "committedDate": "2020-03-07T02:20:05Z", "type": "commit"}, {"oid": "abe3631be329e40c5a3fbdbd904f4867a00ec6ee", "url": "https://github.com/apache/druid/commit/abe3631be329e40c5a3fbdbd904f4867a00ec6ee", "message": "spelling", "committedDate": "2020-03-07T03:00:40Z", "type": "commit"}, {"oid": "86501ef4bbe2f1d2b425b75e697b55e32571b2b1", "url": "https://github.com/apache/druid/commit/86501ef4bbe2f1d2b425b75e697b55e32571b2b1", "message": "preserve user specified lane for NoSchedulingStrategy", "committedDate": "2020-03-07T03:12:01Z", "type": "commit"}, {"oid": "8b7b70d16c6da7347d12718f4db3720114c17fec", "url": "https://github.com/apache/druid/commit/8b7b70d16c6da7347d12718f4db3720114c17fec", "message": "more test, why not", "committedDate": "2020-03-07T03:14:09Z", "type": "commit"}, {"oid": "91ad9d97fc3d416801204bd3d19f10205d3b6283", "url": "https://github.com/apache/druid/commit/91ad9d97fc3d416801204bd3d19f10205d3b6283", "message": "doc adjustment", "committedDate": "2020-03-07T03:17:21Z", "type": "commit"}, {"oid": "373fd1158f13c9f7a77ac6ba1748aa2b2cbb8b99", "url": "https://github.com/apache/druid/commit/373fd1158f13c9f7a77ac6ba1748aa2b2cbb8b99", "message": "style", "committedDate": "2020-03-07T05:08:54Z", "type": "commit"}, {"oid": "274150174fabd07646fe87a01dea67dc714172c7", "url": "https://github.com/apache/druid/commit/274150174fabd07646fe87a01dea67dc714172c7", "message": "missed review for make a thing a constant", "committedDate": "2020-03-09T17:12:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NjA0NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389956045", "bodyText": "Behavior here is a bit different from the docs, which say the value is rounded up.\nSince this allows a lane limit of zero or the total limit, it is a bit inconsistent with disallowing maxLowPercent from being 0 or 100 percent.", "author": "ccaominh", "createdAt": "2020-03-09T20:55:02Z", "path": "server/src/main/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Query laning strategy which associates all {@link Query} with priority lower than 0 into a 'low' lane\n+ */\n+public class HiLoQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  public static final String LOW = \"low\";\n+\n+  @JsonProperty\n+  private final int maxLowPercent;\n+\n+  @JsonCreator\n+  public HiLoQueryLaningStrategy(\n+      @JsonProperty(\"maxLowPercent\") Integer maxLowPercent\n+  )\n+  {\n+    this.maxLowPercent = Preconditions.checkNotNull(maxLowPercent, \"maxLowPercent must be set\");\n+    Preconditions.checkArgument(\n+        0 < maxLowPercent && maxLowPercent < 100,\n+        \"maxLowPercent must be between 0 and 100\"\n+    );\n+  }\n+\n+  @Override\n+  public Object2IntMap<String> getLaneLimits(int totalLimit)\n+  {\n+    Object2IntMap<String> onlyLow = new Object2IntArrayMap<>(1);\n+    onlyLow.put(LOW, Ints.checkedCast(Math.round(totalLimit * ((double) maxLowPercent / 100))));", "originalCommit": "274150174fabd07646fe87a01dea67dc714172c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2MTEzMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389961130", "bodyText": "Oops, I meant to round up, will adjust", "author": "clintropolis", "createdAt": "2020-03-09T21:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NjA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2NjA3NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389966075", "bodyText": "thanks, good catch. fixed, clarified error and docs, and added some tests", "author": "clintropolis", "createdAt": "2020-03-09T21:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NjA0NQ=="}], "type": "inlineReview"}, {"oid": "8575cf8dc1a3e4fbedb46b1f7d36985e984b991c", "url": "https://github.com/apache/druid/commit/8575cf8dc1a3e4fbedb46b1f7d36985e984b991c", "message": "fixes and tests", "committedDate": "2020-03-09T21:14:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4ODE5NA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389988194", "bodyText": "Not bad as is, but if i were to try to boil it down just a little, it might be something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n          \n          \n            \n            *Laning strategies* allow you to control capacity utilization for heterogeneous query workloads. With laning, the broker examines and classifies a query for the purpose of assigning it to a 'lane'. Lanes have capacity limits, enforced by the broker, that ensure sufficient resources are available for other lanes or for interactive queries (with no lane). Requests in excess of the capacity are discarded with an HTTP 429 status code.", "author": "sthetland", "createdAt": "2020-03-09T22:06:07Z", "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,35 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).", "originalCommit": "8575cf8dc1a3e4fbedb46b1f7d36985e984b991c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNzMxOA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390037318", "bodyText": "thanks, applied with some minor adjustment", "author": "clintropolis", "createdAt": "2020-03-10T00:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4ODE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4ODk1Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389988957", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In this mode, queries are never assigned lane, and concurrent query count will only limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode. This strategy can also be explicitly enabled by setting `druid.query.scheduler.laning.strategy` to `none`.\n          \n          \n            \n            In this mode, queries are never assigned a lane, and the concurrent query count will only be limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode. Enable this strategy explicitly by setting `druid.query.scheduler.laning.strategy` to `none`.", "author": "sthetland", "createdAt": "2020-03-09T22:08:18Z", "path": "docs/configuration/index.md", "diffHunk": "@@ -1476,9 +1476,35 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+The Broker provides facilities to aid in query capacity reservation for heterogeneous query workloads in the form of 'laning' strategies, which provide a variety of mechanisms to examine and classify a query, assigning it to a 'lane'. Lanes are defined with capacity limits which the broker will enforce, causing requests in excess of the capacity to be discarded with an HTTP 429 status code, reserving resources for other lanes or for interactive queries (with no lane).\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|\n+|`druid.query.scheduler.laning.strategy`|Query laning strategy to use to assign queries to a lane in order to control capacities for certain classes of queries.|`none`|\n+\n+##### Laning strategies\n+\n+###### No laning strategy\n+\n+In this mode, queries are never assigned lane, and concurrent query count will only limited by `druid.server.http.numThreads` or `druid.query.scheduler.numThreads`, if set. This is the default Druid query scheduler operating mode. This strategy can also be explicitly enabled by setting `druid.query.scheduler.laning.strategy` to `none`.", "originalCommit": "8575cf8dc1a3e4fbedb46b1f7d36985e984b991c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "25a8bda9fa2dd456b23598390c94c1a39e1a70a3", "url": "https://github.com/apache/druid/commit/25a8bda9fa2dd456b23598390c94c1a39e1a70a3", "message": "fix test", "committedDate": "2020-03-10T00:37:20Z", "type": "commit"}, {"oid": "32965a4fa92d60c46f4296a5f387b9b29484712b", "url": "https://github.com/apache/druid/commit/32965a4fa92d60c46f4296a5f387b9b29484712b", "message": "Update docs/configuration/index.md\n\nCo-Authored-By: sthetland <steve.hetland@imply.io>", "committedDate": "2020-03-10T00:43:25Z", "type": "commit"}, {"oid": "361e06e80186835be87e69b0001ddc84d5838e16", "url": "https://github.com/apache/druid/commit/361e06e80186835be87e69b0001ddc84d5838e16", "message": "Merge remote-tracking branch 'upstream/master' into query-laning-and-load-shedding", "committedDate": "2020-03-10T00:44:16Z", "type": "commit"}, {"oid": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "url": "https://github.com/apache/druid/commit/3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "message": "doc update", "committedDate": "2020-03-10T00:46:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5ODAxMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390098011", "bodyText": "why is this  Integer and not int considering it has a default non-null value?", "author": "himanshug", "createdAt": "2020-03-10T05:10:42Z", "path": "server/src/main/java/org/apache/druid/server/QuerySchedulerConfig.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+public class QuerySchedulerConfig\n+{\n+  @JsonProperty\n+  private Integer numThreads = 0;", "originalCommit": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5NDIxNg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390194216", "bodyText": "Hmm, that is a good point, will change in one of the follow-up PRs.", "author": "clintropolis", "createdAt": "2020-03-10T09:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5ODAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyNDA0NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390124045", "bodyText": "in what use case would I ever want to set it something other  than druid.server.http.numThreads ? If the recommendation is to set it lower than druid.server.http.numThreads then why the default value is not set to druid.server.http.numThreads - 1 ?\nI guess, as a user I don't quite understand the importance of setting this higher/same/lower compared to druid.server.http.numThreads and when I should choose one vs the other.", "author": "himanshug", "createdAt": "2020-03-10T07:01:40Z", "path": "docs/configuration/index.md", "diffHunk": "@@ -1481,9 +1481,35 @@ These Broker configurations can be defined in the `broker/runtime.properties` fi\n |`druid.broker.select.tier`|`highestPriority`, `lowestPriority`, `custom`|If segments are cross-replicated across tiers in a cluster, you can tell the broker to prefer to select segments in a tier with a certain priority.|`highestPriority`|\n |`druid.broker.select.tier.custom.priorities`|`An array of integer priorities.`|Select servers in tiers with a custom priority list.|None|\n \n+##### Query laning\n+\n+*Laning strategies* allow you to control capacity utilization for heterogeneous query workloads. With laning, the broker examines and classifies a query for the purpose of assigning it to a 'lane'. Lanes have capacity limits, enforced by the broker, that can be used to ensure sufficient resources are available for other lanes or for interactive queries (with no lane), or to limit overall throughput for queries within the lane. Requests in excess of the capacity are discarded with an HTTP 429 status code.\n+\n+|Property|Description|Default|\n+|--------|-----------|-------|\n+|`druid.query.scheduler.numThreads`|Maximum number of HTTP threads to dedicate to query processing. To save HTTP thread capacity, this should be lower than `druid.server.http.numThreads`.|Unbounded|", "originalCommit": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5ODU3Mw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390198573", "bodyText": "in what use case would I ever want to set it something other than druid.server.http.numThreads ?\n\nI actually think we might always want to set it lower than druid.server.http.numThreads, but I was too nervous to make this the default and made it opt in behavior instead (since it grabs and releases locks for each query if there is some bug in releasing locks a broker would eventually stop accepting queries entirely). The primary reason I think we want it lower than druid.server.http.numThreads is to save some 'slack' space for non-query http connections, like accepting health checks, lookup management, and other such things that can be starved when long running queries start to pile up.\n\nIf the recommendation is to set it lower than druid.server.http.numThreads then why the default value is not set to druid.server.http.numThreads - 1 ?\n\nSee my above nervousness, but I think druid.server.http.numThreads - 1 would probably be a good default. This might want to be adjusted to be even lower depending on how much other non query http traffic the server is receiving (e.g. frequently polled/updated lookups, etc).\n\nI guess, as a user I don't quite understand the importance of setting this higher/same/lower compared to druid.server.http.numThreads and when I should choose one vs the other.\n\nI would agree the current documentation doesn't quite adequately describe how this stuff might be utilized, in a future PR i want to add a section to cluster tuning docs to more properly advise on when and how to set this stuff up.", "author": "clintropolis", "createdAt": "2020-03-10T09:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyNDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0OTg5Mg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390549892", "bodyText": "thanks, I understand the  reasoning now.\nlookup end points already have a QoS filter to never consume more than two threads from jetty, I wonder if in this world it makes sense to setup QoS filter for non-query endpoints(say hardcoded to 2) so that we can ensure that  they don't end up consuming more jetty threads than intended.\nthen default  druid.query.scheduler.numThreads = druid.server.http.numThreads - numReservedForOthers=4 and users would likely never be expected to touch druid.query.scheduler.numThreads .\nMajor behavior change with lane usage is really losing the queuing  of requests to handle spikes and instead sending 429s immediately.  In future, we  could introduce mechanism to maintain statically/dynamically sized [per lane] waiting  queue ourselves as well along with concurrency limits in lane strategy.", "author": "himanshug", "createdAt": "2020-03-10T19:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyNDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODE0NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r391338145", "bodyText": "I wonder if it would make sense to instead move towards automatically computing druid.server.http.numThreads, since maybe it is easier for operators to only have to think about the number of concurrent queries to serve and just set druid.query.scheduler.numThreads? Druid could probably automatically figure out how many more http threads it needs based on configuration.\n\nMajor behavior change with lane usage is really losing the queuing of requests to handle spikes and instead sending 429s immediately. In future, we could introduce mechanism to maintain statically/dynamically sized [per lane] waiting queue ourselves as well along with concurrency limits in lane strategy.\n\nYeah the current behavior is definitely a hard stop if you are over the line. I agree it would make sense to allow some sort of timed out queuing behavior, which is what jetty QoS filter can sort of provide, which is a large part of why I am still wondering if druid.query.scheduler.numThreads should be a QoS filter instead of enforced as an actual lane like it is currently.", "author": "clintropolis", "createdAt": "2020-03-12T00:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyNDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MzQwMw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r391343403", "bodyText": "It is fine to let user provide druid.query.scheduler.numThreads and compute druid.server.http.numThreads , just that one of those should not be touched by user in most cases.\nThere are few advantages in maintaining the queues ourselves and not letting jetty do it.\n\nwe have no control over jetty queue, if a request is dropped then end  user sees that as a TCP connection close and not a HTTP 429. So, to client, it is not clear whether to retry or backoff.\nwe don't know how much time request waited  in jetty queue, consequently request time metrics don't account for that.\njetty queue is [probably] static in size, if we managed it ourselves then we have the option of keeping dynamically sized queues and do potentially other cool things.", "author": "himanshug", "createdAt": "2020-03-12T00:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyNDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMjIwMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390132201", "bodyText": "is it expected that sum(returned_map.values) < totalLimit ?\nnit:  Also wonder why limits returned here  were not percentages but absolute counts given that each implementation would probably end up doing that calculation.", "author": "himanshug", "createdAt": "2020-03-10T07:29:51Z", "path": "server/src/main/java/org/apache/druid/server/QueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"strategy\", defaultImpl = NoQueryLaningStrategy.class)\n+@JsonSubTypes(value = {\n+    @JsonSubTypes.Type(name = \"none\", value = NoQueryLaningStrategy.class),\n+    @JsonSubTypes.Type(name = \"hilo\", value = HiLoQueryLaningStrategy.class)\n+})\n+public interface QueryLaningStrategy\n+{\n+  /**\n+   * Provide a map of lane names to the limit on the number of concurrent queries for that lane\n+   * @param totalLimit\n+   */\n+  Object2IntMap<String> getLaneLimits(int totalLimit);", "originalCommit": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMTE3MQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390201171", "bodyText": "is it expected that sum(returned_map.values) < totalLimit ?\n\nRight now I am not requiring this needs to be true since the limits are not guaranteed capacity, but rather maximums. It seemed more flexible to leave it to individual QueryLaningStrategy implementations to enforce that if they wish.\n\nnit: Also wonder why limits returned here were not percentages but absolute counts given that each implementation would probably end up doing that calculation.\n\nHmm, I think that is definitely worth considering, though @jihoonson was asking for absolute limits in this comment #9407 (comment), so in the very least I will add a utility method to the QueryLaningStrategy interface for doing this conversion.", "author": "clintropolis", "createdAt": "2020-03-10T09:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMjIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2OTEwMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390469100", "bodyText": "Hehe, that happens with multiple reviewers. Yeah, having a utility method is equally good.", "author": "himanshug", "createdAt": "2020-03-10T17:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMjIwMQ=="}], "type": "inlineReview"}]}