{"pr_number": 10593, "pr_title": "IncrementalIndex Tests and Benchmarks Parametrization", "pr_createdAt": "2020-11-18T13:56:44Z", "pr_url": "https://github.com/apache/druid/pull/10593", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNDU3MQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532214571", "bodyText": "shouldn't this method take a parameter to decide which type of index to return?\nor is this the default builder?\nthen maybe buildDefaultIncIndex and the default should be some hard coded value that can be changed over time", "author": "Eshcar", "createdAt": "2020-11-29T14:06:33Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilterPartitionBenchmark.java", "diffHunk": "@@ -227,10 +228,10 @@ public void tearDown() throws IOException\n \n   private IncrementalIndex makeIncIndex()\n   {\n-    return new IncrementalIndex.Builder()\n+    return new OnheapIncrementalIndex.Builder()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyMDg2NQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533120865", "bodyText": "I agree. But for the sake of reducing the diff size, I'd prefer to avoid this refactor.", "author": "liran-funaro", "createdAt": "2020-12-01T07:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNDU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNTQ0NA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532215444", "bodyText": "the diff here is very misleading - this line is part of a one line method tearDown that was deleted", "author": "Eshcar", "createdAt": "2020-11-29T14:13:42Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilteredAggregatorBenchmark.java", "diffHunk": "@@ -205,30 +184,106 @@ public void setup() throws IOException\n \n     GeneratorSchemaInfo basicSchema = GeneratorBasicSchemas.SCHEMA_MAP.get(\"basic\");\n     QuerySegmentSpec intervalSpec = new MultipleIntervalSegmentSpec(Collections.singletonList(basicSchema.getDataInterval()));\n-    List<AggregatorFactory> queryAggs = new ArrayList<>();\n-    queryAggs.add(filteredMetrics[0]);\n+    List<AggregatorFactory> queryAggs = Collections.singletonList(filteredMetric);\n \n     query = Druids.newTimeseriesQueryBuilder()\n                   .dataSource(\"blah\")\n                   .granularity(Granularities.ALL)\n                   .intervals(intervalSpec)\n                   .aggregators(queryAggs)\n-                  .descending(false)\n+                  .descending(descending)\n                   .build();\n   }\n \n-  @TearDown\n-  public void tearDown() throws IOException\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexState\n+  {\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;\n+\n+    IncrementalIndex<?> incIndex;\n+\n+    @Setup\n+    public void setup(FilteredAggregatorBenchmark global) throws JsonProcessingException\n+    {\n+      global.appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);\n+      incIndex = global.makeIncIndex(global.schemaInfo.getAggsArray());\n+      global.generator.addToIndex(incIndex, global.rowsPerSegment);\n+    }\n+\n+    @TearDown\n+    public void tearDown()\n+    {\n+      incIndex.close();\n+    }\n+  }\n+\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexIngestState\n   {\n-    FileUtils.deleteDirectory(tmpDir);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNjE3OQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533126179", "bodyText": "Note that it was not deleted. It just moved below to the teardown of the QueryableIndexState: qIndexesDir.delete();", "author": "liran-funaro", "createdAt": "2020-12-01T07:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNTkwMw==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532215903", "bodyText": "since now there is a new extension point for incremental index, shouldn't the type be extendable as well?\nuse enum instead of string and names like defaultOnHeap and OakOffHeap so additional on/off-heap implementations can be added in the future", "author": "Eshcar", "createdAt": "2020-11-29T14:17:21Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilteredAggregatorBenchmark.java", "diffHunk": "@@ -205,30 +184,106 @@ public void setup() throws IOException\n \n     GeneratorSchemaInfo basicSchema = GeneratorBasicSchemas.SCHEMA_MAP.get(\"basic\");\n     QuerySegmentSpec intervalSpec = new MultipleIntervalSegmentSpec(Collections.singletonList(basicSchema.getDataInterval()));\n-    List<AggregatorFactory> queryAggs = new ArrayList<>();\n-    queryAggs.add(filteredMetrics[0]);\n+    List<AggregatorFactory> queryAggs = Collections.singletonList(filteredMetric);\n \n     query = Druids.newTimeseriesQueryBuilder()\n                   .dataSource(\"blah\")\n                   .granularity(Granularities.ALL)\n                   .intervals(intervalSpec)\n                   .aggregators(queryAggs)\n-                  .descending(false)\n+                  .descending(descending)\n                   .build();\n   }\n \n-  @TearDown\n-  public void tearDown() throws IOException\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexState\n+  {\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyMjg2OQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533122869", "bodyText": "The idea here is indeed to allow a future index to be tested with the same code.\nUsing Enum will force this enumeration to list all existing index types in the core Druid package, albeit the index may only exist as an extension.\nThis way (using string), the user can choose any indexType name in the command line without it having to be pre-defined in the code.", "author": "liran-funaro", "createdAt": "2020-12-01T07:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNjU1Nw==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532216557", "bodyText": "no option for qIndex to be null? e.g., if indexFile is empty?", "author": "Eshcar", "createdAt": "2020-11-29T14:21:50Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilteredAggregatorBenchmark.java", "diffHunk": "@@ -205,30 +184,106 @@ public void setup() throws IOException\n \n     GeneratorSchemaInfo basicSchema = GeneratorBasicSchemas.SCHEMA_MAP.get(\"basic\");\n     QuerySegmentSpec intervalSpec = new MultipleIntervalSegmentSpec(Collections.singletonList(basicSchema.getDataInterval()));\n-    List<AggregatorFactory> queryAggs = new ArrayList<>();\n-    queryAggs.add(filteredMetrics[0]);\n+    List<AggregatorFactory> queryAggs = Collections.singletonList(filteredMetric);\n \n     query = Druids.newTimeseriesQueryBuilder()\n                   .dataSource(\"blah\")\n                   .granularity(Granularities.ALL)\n                   .intervals(intervalSpec)\n                   .aggregators(queryAggs)\n-                  .descending(false)\n+                  .descending(descending)\n                   .build();\n   }\n \n-  @TearDown\n-  public void tearDown() throws IOException\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexState\n+  {\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;\n+\n+    IncrementalIndex<?> incIndex;\n+\n+    @Setup\n+    public void setup(FilteredAggregatorBenchmark global) throws JsonProcessingException\n+    {\n+      global.appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);\n+      incIndex = global.makeIncIndex(global.schemaInfo.getAggsArray());\n+      global.generator.addToIndex(incIndex, global.rowsPerSegment);\n+    }\n+\n+    @TearDown\n+    public void tearDown()\n+    {\n+      incIndex.close();\n+    }\n+  }\n+\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexIngestState\n   {\n-    FileUtils.deleteDirectory(tmpDir);\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;\n+\n+    IncrementalIndex<?> incIndex;\n+    List<InputRow> inputRows;\n+\n+    @Setup(Level.Invocation)\n+    public void setup(FilteredAggregatorBenchmark global) throws JsonProcessingException\n+    {\n+      global.appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);\n+      inputRows = global.generator.toList(global.rowsPerSegment);\n+      incIndex = global.makeIncIndex(new AggregatorFactory[]{global.filteredMetric});\n+    }\n+\n+    @TearDown(Level.Invocation)\n+    public void tearDown()\n+    {\n+      incIndex.close();\n+    }\n+  }\n+\n+  @State(Scope.Benchmark)\n+  public static class QueryableIndexState\n+  {\n+    private File qIndexesDir;\n+    private QueryableIndex qIndex;\n+\n+    @Setup\n+    public void setup(FilteredAggregatorBenchmark global) throws IOException\n+    {\n+      global.appendableIndexSpec = new OnheapIncrementalIndex.Spec();\n+\n+      IncrementalIndex<?> incIndex = global.makeIncIndex(global.schemaInfo.getAggsArray());\n+      global.generator.addToIndex(incIndex, global.rowsPerSegment);\n+\n+      qIndexesDir = FileUtils.createTempDir();\n+      log.info(\"Using temp dir: \" + qIndexesDir.getAbsolutePath());\n+\n+      File indexFile = INDEX_MERGER_V9.persist(\n+          incIndex,\n+          qIndexesDir,\n+          new IndexSpec(),\n+          null\n+      );\n+      incIndex.close();\n+\n+      qIndex = INDEX_IO.loadIndex(indexFile);\n+    }\n+\n+    @TearDown\n+    public void tearDown()\n+    {\n+      qIndex.close();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE1NTY2Mg==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533155662", "bodyText": "I'm not sure. But if setup fails, this might be an issue. Added a null check just to be safe.", "author": "liran-funaro", "createdAt": "2020-12-01T08:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNjU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMDM5MA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532220390", "bodyText": "Does adding all rows into one index equivalent to having 3 indices?", "author": "Eshcar", "createdAt": "2020-11-29T14:52:36Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/IncrementalIndexRowTypeBenchmark.java", "diffHunk": "@@ -124,46 +131,51 @@ private MapBasedInputRow getStringRow(long timestamp, int dimensionCount)\n     return new MapBasedInputRow(timestamp, dimensionList, builder.build());\n   }\n \n-  private IncrementalIndex makeIncIndex()\n+  private IncrementalIndex<?> makeIncIndex()\n   {\n-    return new IncrementalIndex.Builder()\n+    return appendableIndexSpec.builder()\n         .setSimpleTestingIndexSchema(aggs)\n         .setDeserializeComplexMetrics(false)\n-        .setMaxRowCount(MAX_ROWS)\n-        .buildOnheap();\n+        .setMaxRowCount(rowsPerSegment)\n+        .build();\n   }\n \n   @Setup\n-  public void setup()\n+  public void setup() throws JsonProcessingException\n   {\n-    for (int i = 0; i < MAX_ROWS; i++) {\n+    appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);\n+\n+    for (int i = 0; i < rowsPerSegment; i++) {\n       longRows.add(getLongRow(0, DIMENSION_COUNT));\n     }\n \n-    for (int i = 0; i < MAX_ROWS; i++) {\n+    for (int i = 0; i < rowsPerSegment; i++) {\n       floatRows.add(getFloatRow(0, DIMENSION_COUNT));\n     }\n \n-    for (int i = 0; i < MAX_ROWS; i++) {\n+    for (int i = 0; i < rowsPerSegment; i++) {\n       stringRows.add(getStringRow(0, DIMENSION_COUNT));\n     }\n   }\n \n-  @Setup(Level.Iteration)\n+  @Setup(Level.Invocation)\n   public void setup2()\n   {\n     incIndex = makeIncIndex();\n-    incFloatIndex = makeIncIndex();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyMDEyNQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533120125", "bodyText": "Notice that the setup level was changed to per invocation, so for each benchmark, a new index is created.\nThere wasn't really a need for three different indices in the first place.", "author": "liran-funaro", "createdAt": "2020-12-01T07:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMDM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMTM5Mg==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532221392", "bodyText": "worth mentioning that this is where the type of the index is set in the spec, and later used by the factory", "author": "Eshcar", "createdAt": "2020-11-29T15:00:23Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilteredAggregatorBenchmark.java", "diffHunk": "@@ -205,30 +184,106 @@ public void setup() throws IOException\n \n     GeneratorSchemaInfo basicSchema = GeneratorBasicSchemas.SCHEMA_MAP.get(\"basic\");\n     QuerySegmentSpec intervalSpec = new MultipleIntervalSegmentSpec(Collections.singletonList(basicSchema.getDataInterval()));\n-    List<AggregatorFactory> queryAggs = new ArrayList<>();\n-    queryAggs.add(filteredMetrics[0]);\n+    List<AggregatorFactory> queryAggs = Collections.singletonList(filteredMetric);\n \n     query = Druids.newTimeseriesQueryBuilder()\n                   .dataSource(\"blah\")\n                   .granularity(Granularities.ALL)\n                   .intervals(intervalSpec)\n                   .aggregators(queryAggs)\n-                  .descending(false)\n+                  .descending(descending)\n                   .build();\n   }\n \n-  @TearDown\n-  public void tearDown() throws IOException\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexState\n+  {\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;\n+\n+    IncrementalIndex<?> incIndex;\n+\n+    @Setup\n+    public void setup(FilteredAggregatorBenchmark global) throws JsonProcessingException\n+    {\n+      global.appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE1NDQ2NA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533154464", "bodyText": "Added.", "author": "liran-funaro", "createdAt": "2020-12-01T08:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMTM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMjM1MA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532222350", "bodyText": "nice handling of the file", "author": "Eshcar", "createdAt": "2020-11-29T15:07:08Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/indexing/IndexPersistBenchmark.java", "diffHunk": "@@ -149,39 +138,44 @@ public void teardown()\n     incIndex = null;\n   }\n \n-  private IncrementalIndex makeIncIndex()\n+  @Setup(Level.Invocation)\n+  public void setupTemp()\n+  {\n+    tmpDir = FileUtils.createTempDir();\n+    log.info(\"Using temp dir: \" + tmpDir.getAbsolutePath());\n+  }\n+\n+  @TearDown(Level.Invocation)\n+  public void teardownTemp() throws IOException\n   {\n-    return new IncrementalIndex.Builder()\n+    FileUtils.deleteDirectory(tmpDir);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIxMTU3Nw==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533211577", "bodyText": "Thanks!", "author": "liran-funaro", "createdAt": "2020-12-01T09:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMjM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMjk2Nw==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532222967", "bodyText": "from this point onward a bit hard to follow the reasoning for the changes? what part of the PR description does this relate to?", "author": "Eshcar", "createdAt": "2020-11-29T15:11:50Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/query/GroupByBenchmark.java", "diffHunk": "@@ -428,14 +424,12 @@ private void setupQueries()\n   }\n \n   @Setup(Level.Trial)\n-  public void setup() throws IOException\n+  public void setup()\n   {\n     log.info(\"SETUP CALLED AT \" + +System.currentTimeMillis());\n \n     ComplexMetrics.registerSerde(\"hyperUnique\", new HyperUniquesSerde());\n \n-    executorService = Execs.multiThreaded(numProcessingThreads, \"GroupByThreadPool[%d]\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE1ODEwMA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533158100", "bodyText": "These changes are due to the scoping of the benchmark. This setup method now only in charge of initializing everything common for benchmarking both the incremental-index and the queriable-index.\nAnything specific to the incremental or queriable index was moved to its designated scope below.", "author": "liran-funaro", "createdAt": "2020-12-01T08:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMjk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMzc1NA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532223754", "bodyText": "what's the reasoning for these changes? add documentation to explain", "author": "Eshcar", "createdAt": "2020-11-29T15:17:29Z", "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -150,18 +150,13 @@ protected AddToFactsResult addToFacts(\n       boolean skipMaxRowsInMemoryCheck // ignored, we always want to check this for offheap\n   ) throws IndexSizeExceededException\n   {\n-    ByteBuffer aggBuffer;\n-    int bufferIndex;\n-    int bufferOffset;\n-\n     synchronized (this) {\n       final AggregatorFactory[] metrics = getMetrics();\n       final int priorIndex = facts.getPriorIndex(key);\n       if (IncrementalIndexRow.EMPTY_ROW_INDEX != priorIndex) {\n         final int[] indexAndOffset = indexAndOffsets.get(priorIndex);\n-        bufferIndex = indexAndOffset[0];\n-        bufferOffset = indexAndOffset[1];\n-        aggBuffer = aggBuffers.get(bufferIndex).get();\n+        ByteBuffer aggBuffer = aggBuffers.get(indexAndOffset[0]).get();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3NDYxNA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533174614", "bodyText": "Before this change, the code that responsible for the aggregation ran after a new row was inserted to indexAndOffsets (see line 209 below). This means that the new row was visible before any data was aggregated to it.\nThis does not correspond with the on-heap index behavior, which first aggregates the data, then inserts the row to the index.\nAccording to IncrementalIndexIngestionTest.testMultithreadAddFacts(), the on-heap behavior is the correct one, so I changed it accordingly so the test will pass for this index as well.", "author": "liran-funaro", "createdAt": "2020-12-01T08:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMzc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNDAwOA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r539704008", "bodyText": "Hmm I feel that this fix to OffheapIncrementalIndex can be independent in its own separate issue and PR since it is a bug and would make it easier for tracking in the future.", "author": "a2l007", "createdAt": "2020-12-09T22:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMzc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMDg0Mw==", "url": "https://github.com/apache/druid/pull/10593#discussion_r541910843", "bodyText": "If this bug fix will be in a separate PR, then this PR will have a failing test.", "author": "liran-funaro", "createdAt": "2020-12-13T12:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMzc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNDA5OQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532224099", "bodyText": "from here on forward same 5 lines changes repeat for different tests", "author": "Eshcar", "createdAt": "2020-11-29T15:20:03Z", "path": "processing/src/test/java/org/apache/druid/query/DoubleStorageTest.java", "diffHunk": "@@ -321,10 +322,10 @@ private static QueryableIndex buildIndex(String storeDoubleAsFloat) throws IOExc\n         )\n         .build();\n \n-    final IncrementalIndex index = new IncrementalIndex.Builder()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIxNjk5NQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533216995", "bodyText": "This is true for tests that do not test the incremental-index implementation. For such tests, we use the on-heap implementation because it is the most stable.\nTests that test the index itself, are now parametrized so they have more modifications other than these 5 lines.", "author": "liran-funaro", "createdAt": "2020-12-01T09:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNDA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNDgzNA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532224834", "bodyText": "all changes from here are due to the generic type?", "author": "Eshcar", "createdAt": "2020-11-29T15:25:05Z", "path": "processing/src/test/java/org/apache/druid/segment/data/IncrementalIndexTest.java", "diffHunk": "@@ -268,7 +217,7 @@ private static MapBasedInputRow getLongRow(long timestamp, int dimensionCount)\n   public void testCaseSensitivity() throws Exception\n   {\n     long timestamp = System.currentTimeMillis();\n-    IncrementalIndex index = closerRule.closeLater(indexCreator.createIndex(DEFAULT_AGGREGATOR_FACTORIES));\n+    IncrementalIndex<?> index = indexCreator.createIndex((Object) DEFAULT_AGGREGATOR_FACTORIES);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE3NjY1MA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533176650", "bodyText": "Yes. To allow testing any new incremental index.", "author": "liran-funaro", "createdAt": "2020-12-01T08:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNDgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk4NTMyMQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r536985321", "bodyText": "Thanks for addressing the questions and issues\nLGTM", "author": "Eshcar", "createdAt": "2020-12-06T08:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNDgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNTMxNA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r532225314", "bodyText": "add  a more general documentation of the role of this class for the time it is supported", "author": "Eshcar", "createdAt": "2020-11-29T15:28:46Z", "path": "processing/src/test/java/org/apache/druid/segment/incremental/OffheapIncrementalIndexTestSpec.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Supplier;\n+import org.apache.druid.collections.CloseableStupidPool;\n+import org.apache.druid.utils.JvmUtils;\n+\n+import javax.annotation.Nullable;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Since the off-heap incremental index is not yet supported in production ingestion, we define its spec here only", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIxNzM5Mw==", "url": "https://github.com/apache/druid/pull/10593#discussion_r533217393", "bodyText": "Added.", "author": "liran-funaro", "createdAt": "2020-12-01T09:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNTMxNA=="}], "type": "inlineReview"}, {"oid": "559a9e8afcb3bf1ac42533c9c57b12d99f913eec", "url": "https://github.com/apache/druid/commit/559a9e8afcb3bf1ac42533c9c57b12d99f913eec", "message": "Fix forbiddenapis error: Forbidden method invocation: java.lang.String#format(java.lang.String,java.lang.Object[]) [Uses default locale]", "committedDate": "2020-11-30T10:46:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzQ0Mg==", "url": "https://github.com/apache/druid/pull/10593#discussion_r539593442", "bodyText": "Typo: form -> from", "author": "a2l007", "createdAt": "2020-12-09T19:40:55Z", "path": "processing/src/main/java/org/apache/druid/segment/generator/DataGenerator.java", "diffHunk": "@@ -143,4 +151,54 @@ private long nextTimestamp()\n     }\n   }\n \n+  /**\n+   * Initialize a Java Stream generator for InputRow from this DataGenerator.\n+   *\n+   * @param numOfRows the number of rows to generate\n+   * @return a generator\n+   */\n+  private Stream<InputRow> generator(int numOfRows)\n+  {\n+    return Stream.generate(this::nextRow).limit(numOfRows);\n+  }\n+\n+  /**\n+   * Add rows form any generator to an index.", "originalCommit": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMTIwMg==", "url": "https://github.com/apache/druid/pull/10593#discussion_r541911202", "bodyText": "Fixed", "author": "liran-funaro", "createdAt": "2020-12-13T12:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYyMTc5MA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r539621790", "bodyText": "Can we use StringUtils.format here instead?", "author": "a2l007", "createdAt": "2020-12-09T20:26:14Z", "path": "processing/src/test/java/org/apache/druid/segment/incremental/IncrementalIndexCreator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClassResolver;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import org.apache.druid.jackson.DefaultObjectMapper;\n+import org.apache.druid.java.util.common.io.Closer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An incremental-index creator for parameterized incremental-index tests.\n+ * It lists all the available incremental-index implementations, and responsible to create and close incremental-index\n+ * instances during the tests.\n+ */\n+public class IncrementalIndexCreator implements Closeable\n+{\n+  public static final ObjectMapper JSON_MAPPER = new DefaultObjectMapper();\n+\n+  /**\n+   * Allows adding support for testing unregistered indexes.\n+   * It is used by Druid's extensions for the incremental-index.\n+   *\n+   * @param c    an index spec class\n+   * @param name an index spec name\n+   */\n+  public static void addIndexSpec(Class<?> c, String name)\n+  {\n+    JSON_MAPPER.registerSubtypes(new NamedType(c, name));\n+  }\n+\n+  static {\n+    // The off-heap incremental-index is not registered for production, but we want to include it in the tests.\n+    IncrementalIndexCreator.addIndexSpec(OffheapIncrementalIndexTestSpec.class, OffheapIncrementalIndexTestSpec.TYPE);\n+  }\n+\n+  /**\n+   * Fetch all the available incremental-index implementations.\n+   * It can be used to parametrize the test. If more parameters are needed, use indexTypeCartesianProduct().\n+   * @see #indexTypeCartesianProduct(Collection[]).\n+   *\n+   * @return a list of all the incremental-index implementations types (String)\n+   */\n+  public static List<String> getAppendableIndexTypes()\n+  {\n+    SubtypeResolver resolver = JSON_MAPPER.getSubtypeResolver();\n+    MapperConfig<?> config = JSON_MAPPER.getDeserializationConfig();\n+    AnnotatedClass cls = AnnotatedClassResolver.resolveWithoutSuperTypes(config, AppendableIndexSpec.class);\n+    Collection<NamedType> types = resolver.collectAndResolveSubtypesByClass(config, cls);\n+    return types.stream().map(NamedType::getName).filter(Objects::nonNull).distinct().collect(Collectors.toList());\n+  }\n+\n+  public interface IndexCreator\n+  {\n+    /**\n+     * Build an index given a builder and args.\n+     *\n+     * @param builder an incremental index builder supplied by the framework\n+     * @param args a list of arguments that are used to configure the builder\n+     * @return a new instance of an incremental-index\n+     */\n+    IncrementalIndex<?> createIndex(AppendableIndexBuilder builder, Object... args);\n+  }\n+\n+  private final Closer closer = Closer.create();\n+\n+  private final AppendableIndexSpec appendableIndexSpec;\n+\n+  private final IndexCreator indexCreator;\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param spec a spec that can generate a incremental-index builder\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(AppendableIndexSpec spec, IndexCreator indexCreator)\n+  {\n+    this.appendableIndexSpec = spec;\n+    this.indexCreator = indexCreator;\n+  }\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param indexType an index type (name)\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(String indexType, IndexCreator indexCreator) throws JsonProcessingException\n+  {\n+    this(parseIndexType(indexType), indexCreator);\n+  }\n+\n+  /**\n+   * Generate an AppendableIndexSpec from index type.\n+   *\n+   * @param indexType an index type\n+   * @return AppendableIndexSpec instance of this type\n+   * @throws JsonProcessingException if failed to to parse the index\n+   */\n+  public static AppendableIndexSpec parseIndexType(String indexType) throws JsonProcessingException\n+  {\n+    return JSON_MAPPER.readValue(\n+        String.format(Locale.ENGLISH, \"{\\\"type\\\": \\\"%s\\\"}\", indexType),", "originalCommit": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMTIxMA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r541911210", "bodyText": "Fixed.", "author": "liran-funaro", "createdAt": "2020-12-13T12:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYyMTc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MDM3Ng==", "url": "https://github.com/apache/druid/pull/10593#discussion_r539660376", "bodyText": "This method is convenient but it would be useful to add more detail on how it can be used.", "author": "a2l007", "createdAt": "2020-12-09T21:27:14Z", "path": "processing/src/test/java/org/apache/druid/segment/incremental/IncrementalIndexCreator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClassResolver;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import org.apache.druid.jackson.DefaultObjectMapper;\n+import org.apache.druid.java.util.common.io.Closer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An incremental-index creator for parameterized incremental-index tests.\n+ * It lists all the available incremental-index implementations, and responsible to create and close incremental-index\n+ * instances during the tests.\n+ */\n+public class IncrementalIndexCreator implements Closeable\n+{\n+  public static final ObjectMapper JSON_MAPPER = new DefaultObjectMapper();\n+\n+  /**\n+   * Allows adding support for testing unregistered indexes.\n+   * It is used by Druid's extensions for the incremental-index.\n+   *\n+   * @param c    an index spec class\n+   * @param name an index spec name\n+   */\n+  public static void addIndexSpec(Class<?> c, String name)\n+  {\n+    JSON_MAPPER.registerSubtypes(new NamedType(c, name));\n+  }\n+\n+  static {\n+    // The off-heap incremental-index is not registered for production, but we want to include it in the tests.\n+    IncrementalIndexCreator.addIndexSpec(OffheapIncrementalIndexTestSpec.class, OffheapIncrementalIndexTestSpec.TYPE);\n+  }\n+\n+  /**\n+   * Fetch all the available incremental-index implementations.\n+   * It can be used to parametrize the test. If more parameters are needed, use indexTypeCartesianProduct().\n+   * @see #indexTypeCartesianProduct(Collection[]).\n+   *\n+   * @return a list of all the incremental-index implementations types (String)\n+   */\n+  public static List<String> getAppendableIndexTypes()\n+  {\n+    SubtypeResolver resolver = JSON_MAPPER.getSubtypeResolver();\n+    MapperConfig<?> config = JSON_MAPPER.getDeserializationConfig();\n+    AnnotatedClass cls = AnnotatedClassResolver.resolveWithoutSuperTypes(config, AppendableIndexSpec.class);\n+    Collection<NamedType> types = resolver.collectAndResolveSubtypesByClass(config, cls);\n+    return types.stream().map(NamedType::getName).filter(Objects::nonNull).distinct().collect(Collectors.toList());\n+  }\n+\n+  public interface IndexCreator\n+  {\n+    /**\n+     * Build an index given a builder and args.\n+     *\n+     * @param builder an incremental index builder supplied by the framework\n+     * @param args a list of arguments that are used to configure the builder\n+     * @return a new instance of an incremental-index\n+     */\n+    IncrementalIndex<?> createIndex(AppendableIndexBuilder builder, Object... args);\n+  }\n+\n+  private final Closer closer = Closer.create();\n+\n+  private final AppendableIndexSpec appendableIndexSpec;\n+\n+  private final IndexCreator indexCreator;\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param spec a spec that can generate a incremental-index builder\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(AppendableIndexSpec spec, IndexCreator indexCreator)\n+  {\n+    this.appendableIndexSpec = spec;\n+    this.indexCreator = indexCreator;\n+  }\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param indexType an index type (name)\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(String indexType, IndexCreator indexCreator) throws JsonProcessingException\n+  {\n+    this(parseIndexType(indexType), indexCreator);\n+  }\n+\n+  /**\n+   * Generate an AppendableIndexSpec from index type.\n+   *\n+   * @param indexType an index type\n+   * @return AppendableIndexSpec instance of this type\n+   * @throws JsonProcessingException if failed to to parse the index\n+   */\n+  public static AppendableIndexSpec parseIndexType(String indexType) throws JsonProcessingException\n+  {\n+    return JSON_MAPPER.readValue(\n+        String.format(Locale.ENGLISH, \"{\\\"type\\\": \\\"%s\\\"}\", indexType),\n+        AppendableIndexSpec.class\n+    );\n+  }\n+\n+  /**\n+   * Create an index given the input args.\n+   *\n+   * @param args The arguments for the index-generator\n+   * @return An incremental-index instance\n+   */\n+  public final IncrementalIndex<?> createIndex(Object... args)\n+  {\n+    return createIndex(indexCreator, args);\n+  }\n+\n+  /**\n+   * Create an index given the input args with a specialized index-creator.\n+   *\n+   * @param args The arguments for the index-generator\n+   * @return An incremental-index instance\n+   */\n+  public final IncrementalIndex<?> createIndex(IndexCreator indexCreator, Object... args)\n+  {\n+    return closer.register(indexCreator.createIndex(appendableIndexSpec.builder(), args));\n+  }\n+\n+  @Override\n+  public void close() throws IOException\n+  {\n+    closer.close();\n+\n+    if (appendableIndexSpec instanceof Closeable) {\n+      ((Closeable) appendableIndexSpec).close();\n+    }\n+  }\n+\n+  /**\n+   * Used to parameterize the tests with all the permutations of the parameters\n+   * together with all the incremental index implementations.\n+   *\n+   * @param c a list of collections of parameters\n+   * @return the cartesian product of all parameters\n+   */\n+  public static List<Object[]> indexTypeCartesianProduct(Collection<?>... c)", "originalCommit": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMTY4Mw==", "url": "https://github.com/apache/druid/pull/10593#discussion_r541911683", "bodyText": "Added", "author": "liran-funaro", "createdAt": "2020-12-13T12:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MDM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MzE0OA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r539663148", "bodyText": "In addition to saying parameterized incremental-index tests, could you please add more info in the javadoc specifying what are the configurable parameters?", "author": "a2l007", "createdAt": "2020-12-09T21:31:47Z", "path": "processing/src/test/java/org/apache/druid/segment/incremental/IncrementalIndexCreator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClassResolver;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import org.apache.druid.jackson.DefaultObjectMapper;\n+import org.apache.druid.java.util.common.io.Closer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An incremental-index creator for parameterized incremental-index tests.\n+ * It lists all the available incremental-index implementations, and responsible to create and close incremental-index\n+ * instances during the tests.\n+ */\n+public class IncrementalIndexCreator implements Closeable", "originalCommit": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MzQ4NQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r541973485", "bodyText": "I added more detailed documentation for this class.", "author": "liran-funaro", "createdAt": "2020-12-13T18:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MzE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2NDg2NA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r539664864", "bodyText": "Does this method need public visibility?", "author": "a2l007", "createdAt": "2020-12-09T21:34:34Z", "path": "processing/src/test/java/org/apache/druid/segment/incremental/IncrementalIndexCreator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClassResolver;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import org.apache.druid.jackson.DefaultObjectMapper;\n+import org.apache.druid.java.util.common.io.Closer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An incremental-index creator for parameterized incremental-index tests.\n+ * It lists all the available incremental-index implementations, and responsible to create and close incremental-index\n+ * instances during the tests.\n+ */\n+public class IncrementalIndexCreator implements Closeable\n+{\n+  public static final ObjectMapper JSON_MAPPER = new DefaultObjectMapper();\n+\n+  /**\n+   * Allows adding support for testing unregistered indexes.\n+   * It is used by Druid's extensions for the incremental-index.\n+   *\n+   * @param c    an index spec class\n+   * @param name an index spec name\n+   */\n+  public static void addIndexSpec(Class<?> c, String name)\n+  {\n+    JSON_MAPPER.registerSubtypes(new NamedType(c, name));\n+  }\n+\n+  static {\n+    // The off-heap incremental-index is not registered for production, but we want to include it in the tests.\n+    IncrementalIndexCreator.addIndexSpec(OffheapIncrementalIndexTestSpec.class, OffheapIncrementalIndexTestSpec.TYPE);\n+  }\n+\n+  /**\n+   * Fetch all the available incremental-index implementations.\n+   * It can be used to parametrize the test. If more parameters are needed, use indexTypeCartesianProduct().\n+   * @see #indexTypeCartesianProduct(Collection[]).\n+   *\n+   * @return a list of all the incremental-index implementations types (String)\n+   */\n+  public static List<String> getAppendableIndexTypes()\n+  {\n+    SubtypeResolver resolver = JSON_MAPPER.getSubtypeResolver();\n+    MapperConfig<?> config = JSON_MAPPER.getDeserializationConfig();\n+    AnnotatedClass cls = AnnotatedClassResolver.resolveWithoutSuperTypes(config, AppendableIndexSpec.class);\n+    Collection<NamedType> types = resolver.collectAndResolveSubtypesByClass(config, cls);\n+    return types.stream().map(NamedType::getName).filter(Objects::nonNull).distinct().collect(Collectors.toList());\n+  }\n+\n+  public interface IndexCreator\n+  {\n+    /**\n+     * Build an index given a builder and args.\n+     *\n+     * @param builder an incremental index builder supplied by the framework\n+     * @param args a list of arguments that are used to configure the builder\n+     * @return a new instance of an incremental-index\n+     */\n+    IncrementalIndex<?> createIndex(AppendableIndexBuilder builder, Object... args);\n+  }\n+\n+  private final Closer closer = Closer.create();\n+\n+  private final AppendableIndexSpec appendableIndexSpec;\n+\n+  private final IndexCreator indexCreator;\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param spec a spec that can generate a incremental-index builder\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(AppendableIndexSpec spec, IndexCreator indexCreator)\n+  {\n+    this.appendableIndexSpec = spec;\n+    this.indexCreator = indexCreator;\n+  }\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param indexType an index type (name)\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(String indexType, IndexCreator indexCreator) throws JsonProcessingException\n+  {\n+    this(parseIndexType(indexType), indexCreator);\n+  }\n+\n+  /**\n+   * Generate an AppendableIndexSpec from index type.\n+   *\n+   * @param indexType an index type\n+   * @return AppendableIndexSpec instance of this type\n+   * @throws JsonProcessingException if failed to to parse the index\n+   */\n+  public static AppendableIndexSpec parseIndexType(String indexType) throws JsonProcessingException\n+  {\n+    return JSON_MAPPER.readValue(\n+        String.format(Locale.ENGLISH, \"{\\\"type\\\": \\\"%s\\\"}\", indexType),\n+        AppendableIndexSpec.class\n+    );\n+  }\n+\n+  /**\n+   * Create an index given the input args.\n+   *\n+   * @param args The arguments for the index-generator\n+   * @return An incremental-index instance\n+   */\n+  public final IncrementalIndex<?> createIndex(Object... args)\n+  {\n+    return createIndex(indexCreator, args);\n+  }\n+\n+  /**\n+   * Create an index given the input args with a specialized index-creator.\n+   *\n+   * @param args The arguments for the index-generator\n+   * @return An incremental-index instance\n+   */\n+  public final IncrementalIndex<?> createIndex(IndexCreator indexCreator, Object... args)\n+  {\n+    return closer.register(indexCreator.createIndex(appendableIndexSpec.builder(), args));\n+  }\n+\n+  @Override\n+  public void close() throws IOException\n+  {\n+    closer.close();\n+\n+    if (appendableIndexSpec instanceof Closeable) {\n+      ((Closeable) appendableIndexSpec).close();\n+    }\n+  }\n+\n+  /**\n+   * Used to parameterize the tests with all the permutations of the parameters\n+   * together with all the incremental index implementations.\n+   *\n+   * @param c a list of collections of parameters\n+   * @return the cartesian product of all parameters\n+   */\n+  public static List<Object[]> indexTypeCartesianProduct(Collection<?>... c)\n+  {\n+    Collection<?>[] args = new Collection<?>[c.length + 1];\n+    args[0] = getAppendableIndexTypes();\n+    System.arraycopy(c, 0, args, 1, c.length);\n+    return cartesianProduct(args);\n+  }\n+\n+  /**\n+   * Generates all the permutations of the parameters.\n+   *\n+   * @param c a list of collections of parameters\n+   * @return the cartesian product of all parameters\n+   */\n+  public static List<Object[]> cartesianProduct(Collection<?>... c)", "originalCommit": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMTgyOA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r541911828", "bodyText": "No. Changed to private.", "author": "liran-funaro", "createdAt": "2020-12-13T12:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2NDg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMDMzNw==", "url": "https://github.com/apache/druid/pull/10593#discussion_r539720337", "bodyText": "I see there are other usages of gen.nextRow() that haven't been replaced. Is the plan to replace them in an follow up PR?", "author": "a2l007", "createdAt": "2020-12-09T23:17:24Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/indexing/IncrementalIndexReadBenchmark.java", "diffHunk": "@@ -110,28 +119,28 @@ public void setup() throws IOException\n     );\n \n     incIndex = makeIncIndex();\n+    gen.addToIndex(incIndex, rowsPerSegment);", "originalCommit": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkwMzM2MQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r541903361", "bodyText": "It wasn't planned, but I don't mind creating a follow-up PR for that or replacing everything in this PR.\nWhat do you think is better?", "author": "liran-funaro", "createdAt": "2020-12-13T11:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMDMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0MjUyNA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r543642524", "bodyText": "Changing it in a follow-up PR sounds good to me.", "author": "a2l007", "createdAt": "2020-12-15T19:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMDMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExODk4Mw==", "url": "https://github.com/apache/druid/pull/10593#discussion_r544118983", "bodyText": "OK. I'll publish a new PR for this once this PR is merged.", "author": "liran-funaro", "createdAt": "2020-12-16T08:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMDMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMTczNQ==", "url": "https://github.com/apache/druid/pull/10593#discussion_r539721735", "bodyText": "This logging is generally useful as it helps track the status of the benchmark run. Could this be incorporated as part of addToIndex?\nThis comment applies to the same change for the remaining places as well.", "author": "a2l007", "createdAt": "2020-12-09T23:20:33Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/indexing/IncrementalIndexReadBenchmark.java", "diffHunk": "@@ -110,28 +119,28 @@ public void setup() throws IOException\n     );\n \n     incIndex = makeIncIndex();\n+    gen.addToIndex(incIndex, rowsPerSegment);\n+  }\n \n-    for (int j = 0; j < rowsPerSegment; j++) {\n-      InputRow row = gen.nextRow();\n-      if (j % 10000 == 0) {\n-        log.info(j + \" rows generated.\");", "originalCommit": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk2NzM5Mg==", "url": "https://github.com/apache/druid/pull/10593#discussion_r541967392", "bodyText": "I modified the DataGenerator to produce log events every 10,000 rows.", "author": "liran-funaro", "createdAt": "2020-12-13T17:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMTczNQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3MDg1NA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r543670854", "bodyText": "Sorry I missed this earlier, but I feel that we should retain the textual values for rollupOpportunity as that is more user-friendly when reading the benchmark results.", "author": "a2l007", "createdAt": "2020-12-15T20:40:24Z", "path": "benchmarks/src/test/java/org/apache/druid/benchmark/indexing/IndexPersistBenchmark.java", "diffHunk": "@@ -87,101 +90,95 @@\n   @Param({\"true\", \"false\"})\n   private boolean rollup;\n \n-  @Param({\"none\", \"moderate\", \"high\"})\n-  private String rollupOpportunity;\n+  @Param({\"0\", \"1000\", \"10000\"})\n+  private int rollupOpportunity;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExODU0MA==", "url": "https://github.com/apache/druid/pull/10593#discussion_r544118540", "bodyText": "OK. I rolled back this change.", "author": "liran-funaro", "createdAt": "2020-12-16T08:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3MDg1NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "1df4fecc62eb104bd19f1e21fbc970a6604ec63c", "url": "https://github.com/apache/druid/commit/1df4fecc62eb104bd19f1e21fbc970a6604ec63c", "message": "Remove redundant IncrementalIndex.Builder", "committedDate": "2020-12-22T10:37:20Z", "type": "commit"}, {"oid": "f4e0be979d48c14c51a952f3237e5daab8d98212", "url": "https://github.com/apache/druid/commit/f4e0be979d48c14c51a952f3237e5daab8d98212", "message": "Parametrize incremental index tests and benchmarks\n\n- Reveal and fix a bug in OffheapIncrementalIndex", "committedDate": "2020-12-22T10:37:21Z", "type": "commit"}, {"oid": "33a613f71befc23770d212b47a532c472c5055a2", "url": "https://github.com/apache/druid/commit/33a613f71befc23770d212b47a532c472c5055a2", "message": "Fix forbiddenapis error: Forbidden method invocation: java.lang.String#format(java.lang.String,java.lang.Object[]) [Uses default locale]", "committedDate": "2020-12-22T10:37:21Z", "type": "commit"}, {"oid": "0d9369442d2310b4640ff5ff226e5608b1bc62d2", "url": "https://github.com/apache/druid/commit/0d9369442d2310b4640ff5ff226e5608b1bc62d2", "message": "Fix Intellij errors: declared exception is never thrown", "committedDate": "2020-12-22T10:37:22Z", "type": "commit"}, {"oid": "07a64123dc722e4e5b3050a02d2776266ec75c5f", "url": "https://github.com/apache/druid/commit/07a64123dc722e4e5b3050a02d2776266ec75c5f", "message": "Add documentation and validate before closing objects on tearDown.", "committedDate": "2020-12-22T10:37:22Z", "type": "commit"}, {"oid": "1ead19a14af7835b0a9a3153134afe27a75cd7fa", "url": "https://github.com/apache/druid/commit/1ead19a14af7835b0a9a3153134afe27a75cd7fa", "message": "Add documentation to OffheapIncrementalIndexTestSpec", "committedDate": "2020-12-22T10:37:22Z", "type": "commit"}, {"oid": "1ffdf56a680f8a6a805b440fd75b9cb97d05b9d6", "url": "https://github.com/apache/druid/commit/1ffdf56a680f8a6a805b440fd75b9cb97d05b9d6", "message": "Doc corrections and minor changes.", "committedDate": "2020-12-22T10:37:23Z", "type": "commit"}, {"oid": "a4ebea5236b9ca700eae84086b776af32bbeeafa", "url": "https://github.com/apache/druid/commit/a4ebea5236b9ca700eae84086b776af32bbeeafa", "message": "Add logging for generated rows.", "committedDate": "2020-12-22T10:37:23Z", "type": "commit"}, {"oid": "43461f9a876880325220d1f39ebfedbc6bef9960", "url": "https://github.com/apache/druid/commit/43461f9a876880325220d1f39ebfedbc6bef9960", "message": "Refactor new tests/benchmarks.", "committedDate": "2020-12-22T10:37:23Z", "type": "commit"}, {"oid": "fc9037972b37621b3788e174b12fd55fe47b492c", "url": "https://github.com/apache/druid/commit/fc9037972b37621b3788e174b12fd55fe47b492c", "message": "Improve IncrementalIndexCreator documentation", "committedDate": "2020-12-22T10:37:24Z", "type": "commit"}, {"oid": "781871798bed88416d20d8897d635c48deb6136b", "url": "https://github.com/apache/druid/commit/781871798bed88416d20d8897d635c48deb6136b", "message": "Add required tests for DataGenerator", "committedDate": "2020-12-22T10:37:24Z", "type": "commit"}, {"oid": "7527dde6471aab28b1a5ffd187b747db898b1d18", "url": "https://github.com/apache/druid/commit/7527dde6471aab28b1a5ffd187b747db898b1d18", "message": "Revert \"rollupOpportunity\" to be a string", "committedDate": "2020-12-22T10:37:24Z", "type": "commit"}, {"oid": "7527dde6471aab28b1a5ffd187b747db898b1d18", "url": "https://github.com/apache/druid/commit/7527dde6471aab28b1a5ffd187b747db898b1d18", "message": "Revert \"rollupOpportunity\" to be a string", "committedDate": "2020-12-22T10:37:24Z", "type": "forcePushed"}]}