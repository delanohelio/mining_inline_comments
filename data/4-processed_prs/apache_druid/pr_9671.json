{"pr_number": 9671, "pr_title": "Add support for Avro OCF using InputFormat", "pr_createdAt": "2020-04-10T17:53:32Z", "pr_url": "https://github.com/apache/druid/pull/9671", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "8e8952ee76461ecf460f685ee8d453ce2e1366c3", "url": "https://github.com/apache/druid/commit/8e8952ee76461ecf460f685ee8d453ce2e1366c3", "message": "Add AvroOCFInputFormat", "committedDate": "2020-04-12T08:15:04Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "d1936052af8005e291352671ed3706541c1aa31b", "url": "https://github.com/apache/druid/commit/d1936052af8005e291352671ed3706541c1aa31b", "message": "Support supplying a reader schema in AvroOCFInputFormat", "committedDate": "2020-04-13T17:00:28Z", "type": "commit"}, {"oid": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "url": "https://github.com/apache/druid/commit/2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "message": "Add docs for Avro OCF input format", "committedDate": "2020-04-13T17:00:28Z", "type": "commit"}, {"oid": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "url": "https://github.com/apache/druid/commit/2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "message": "Add docs for Avro OCF input format", "committedDate": "2020-04-13T17:00:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0MTA4OA==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421841088", "bodyText": "Can you add a valid example for schema as well? It will help readers getting some idea about what it would be for them.", "author": "jihoonson", "createdAt": "2020-05-07T22:58:12Z", "path": "docs/ingestion/data-formats.md", "diffHunk": "@@ -223,6 +223,41 @@ The Parquet `inputFormat` has the following components:\n |flattenSpec| JSON Object |Define a [`flattenSpec`](#flattenspec) to extract nested values from a Parquet file. Note that only 'path' expression are supported ('jq' is unavailable).| no (default will auto-discover 'root' level properties) |\n | binaryAsString | Boolean | Specifies if the bytes parquet column which is not logically marked as a string or enum type should be treated as a UTF-8 encoded string. | no (default = false) |\n \n+### Avro OCF\n+\n+> You need to include the [`druid-avro-extensions`](../development/extensions-core/avro.md) as an extension to use the Avro OCF input format.\n+\n+The `inputFormat` to load data of Avro OCF format. An example is:\n+```json\n+\"ioConfig\": {\n+  \"inputFormat\": {\n+    \"type\": \"avro_ocf\",\n+    \"flattenSpec\": {\n+      \"useFieldDiscovery\": true,\n+      \"fields\": [\n+        {\n+          \"type\": \"path\",\n+          \"name\": \"nested\",\n+          \"expr\": \"$.path.to.nested\"\n+        }\n+      ]\n+    },\n+    \"schema\": {\n+      ...", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0Mzg4MQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421843881", "bodyText": "The created reader should be closed.", "author": "jihoonson", "createdAt": "2020-05-07T23:06:56Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      Schema readerSchema,\n+      JSONPathSpec flattenSpec,\n+      boolean binaryAsString\n+  )\n+  {\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n+    this.temporaryDirectory = temporaryDirectory;\n+    this.readerSchema = readerSchema;\n+    this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n+  }\n+\n+  private static Schema dataFileSchema(File file) throws IOException\n+  {\n+    return new DataFileReader<GenericRecord>(file, new GenericDatumReader<>()).getSchema();", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0NDMxMw==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421844313", "bodyText": "Please add @Nullable.", "author": "jihoonson", "createdAt": "2020-05-07T23:08:30Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.avro.Schema;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputEntityReader;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.impl.NestedInputFormat;\n+import org.apache.druid.guice.annotations.Json;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class AvroOCFInputFormat extends NestedInputFormat\n+{\n+  private static final Logger LOGGER = new Logger(AvroOCFInputFormat.class);\n+\n+  private final boolean binaryAsString;\n+  private final Schema readerSchema;", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0NDM2NQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421844365", "bodyText": "Please add @Nullable.", "author": "jihoonson", "createdAt": "2020-05-07T23:08:40Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.avro.Schema;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputEntityReader;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.impl.NestedInputFormat;\n+import org.apache.druid.guice.annotations.Json;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class AvroOCFInputFormat extends NestedInputFormat\n+{\n+  private static final Logger LOGGER = new Logger(AvroOCFInputFormat.class);\n+\n+  private final boolean binaryAsString;\n+  private final Schema readerSchema;\n+\n+  @JsonCreator\n+  public AvroOCFInputFormat(\n+      @JacksonInject @Json ObjectMapper mapper,\n+      @JsonProperty(\"flattenSpec\") @Nullable JSONPathSpec flattenSpec,\n+      @JsonProperty(\"schema\") Map<String, Object> schema,", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0NDc3MA==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421844770", "bodyText": "Please add @Nullable.", "author": "jihoonson", "createdAt": "2020-05-07T23:09:39Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      Schema readerSchema,", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0NjMwNA==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421846304", "bodyText": "dataFileReader should be registered on closer.", "author": "jihoonson", "createdAt": "2020-05-07T23:14:02Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      Schema readerSchema,\n+      JSONPathSpec flattenSpec,\n+      boolean binaryAsString\n+  )\n+  {\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n+    this.temporaryDirectory = temporaryDirectory;\n+    this.readerSchema = readerSchema;\n+    this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n+  }\n+\n+  private static Schema dataFileSchema(File file) throws IOException\n+  {\n+    return new DataFileReader<GenericRecord>(file, new GenericDatumReader<>()).getSchema();\n+  }\n+\n+  @Override\n+  protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n+  {\n+    final Closer closer = Closer.create();\n+\n+    final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n+    final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n+    final Schema writerSchema = dataFileSchema(file.file());\n+    if (readerSchema == null) {\n+      readerSchema = writerSchema;\n+    }\n+    final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>(writerSchema, readerSchema);\n+    final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0OTQ4NQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421849485", "bodyText": "This seems fine for now, but we would probably want to make it splittable in the future. Would you please add a comment about it with this link?", "author": "jihoonson", "createdAt": "2020-05-07T23:24:05Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFInputFormat.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.avro.Schema;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputEntityReader;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.impl.NestedInputFormat;\n+import org.apache.druid.guice.annotations.Json;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class AvroOCFInputFormat extends NestedInputFormat\n+{\n+  private static final Logger LOGGER = new Logger(AvroOCFInputFormat.class);\n+\n+  private final boolean binaryAsString;\n+  private final Schema readerSchema;\n+\n+  @JsonCreator\n+  public AvroOCFInputFormat(\n+      @JacksonInject @Json ObjectMapper mapper,\n+      @JsonProperty(\"flattenSpec\") @Nullable JSONPathSpec flattenSpec,\n+      @JsonProperty(\"schema\") Map<String, Object> schema,\n+      @JsonProperty(\"binaryAsString\") @Nullable Boolean binaryAsString\n+  ) throws Exception\n+  {\n+    super(flattenSpec);\n+    // If a reader schema is supplied create the datum reader with said schema, otherwise use the writer schema\n+    if (schema != null) {\n+      String schemaStr = mapper.writeValueAsString(schema);\n+      LOGGER.debug(\"Initialising with reader schema: [%s]\", schemaStr);\n+      this.readerSchema = new Schema.Parser().parse(schemaStr);\n+    } else {\n+      this.readerSchema = null;\n+    }\n+    this.binaryAsString = binaryAsString == null ? false : binaryAsString;\n+  }\n+\n+  @Override\n+  public boolean isSplittable()\n+  {\n+    return false;", "originalCommit": "2c5fa5551658bbbb6c5b08e6616b6708d3c56ff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk3OTA0NQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r421979045", "bodyText": "Yeah I think the best way to do splitting would be block-wise. I will add a comment about it and link to the spec as you suggested.", "author": "josephglanville", "createdAt": "2020-05-08T07:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg0OTQ4NQ=="}], "type": "inlineReview"}, {"oid": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "url": "https://github.com/apache/druid/commit/80f7d561b6604aa921937ab7f26bbcb7d12307df", "message": "Address review comments", "committedDate": "2020-05-13T17:36:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMTQzMQ==", "url": "https://github.com/apache/druid/pull/9671#discussion_r424801431", "bodyText": "I'm wondering if we can reuse the created dataFileReader rather than creating two instances even though creating an instance would be probably cheap (it only reads the header). It seems possible if you update reader and writher schemas as below:\n      final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n      final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>();\n      final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);\n      final Schema writerSchema = dataFileReader.getSchema();\n      if (readerSchema == null) {\n        readerSchema = writerSchema;\n      }\n      datumReader.setSchema(writerSchema);\n      datumReader.setExpected(readerSchema);", "author": "jihoonson", "createdAt": "2020-05-14T00:14:38Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      @Nullable Schema readerSchema,\n+      JSONPathSpec flattenSpec,\n+      boolean binaryAsString\n+  )\n+  {\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n+    this.temporaryDirectory = temporaryDirectory;\n+    this.readerSchema = readerSchema;\n+    this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n+  }\n+\n+  private static Schema dataFileSchema(File file) throws IOException\n+  {\n+    final DataFileReader<GenericRecord> reader = new DataFileReader<>(file, new GenericDatumReader<>());\n+    final Schema schema = reader.getSchema();\n+    reader.close();\n+    return schema;\n+  }\n+\n+  @Override\n+  protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n+  {\n+    final Closer closer = Closer.create();\n+\n+    final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n+    final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n+    final Schema writerSchema = dataFileSchema(file.file());\n+    if (readerSchema == null) {\n+      readerSchema = writerSchema;\n+    }\n+    final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>(writerSchema, readerSchema);", "originalCommit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3Njc0Mw==", "url": "https://github.com/apache/druid/pull/9671#discussion_r424876743", "bodyText": "Yes this is possible, I didn't do it originally because I made the same observation that it's likely cheap. However may as well avoid it.", "author": "josephglanville", "createdAt": "2020-05-14T05:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMTQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMTg5Nw==", "url": "https://github.com/apache/druid/pull/9671#discussion_r424801897", "bodyText": "I noticed #9867 while reviewing this.. Any exceptions should be caught before returning the iterator. So, the code should probably be\n  protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n  {\n    final Closer closer = Closer.create();\n    final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n\n    try {\n      final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n      final GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>();\n      final DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(file.file(), datumReader);\n      final Schema writerSchema = dataFileReader.getSchema();\n      if (readerSchema == null) {\n        readerSchema = writerSchema;\n      }\n      datumReader.setSchema(writerSchema);\n      datumReader.setExpected(readerSchema);\n      closer.register(dataFileReader);\n    }\n    catch (Exception e) {\n      closer.close();\n      throw new RuntimeException(e);\n    }\n\n    return new CloseableIterator<GenericRecord>()\n    ...", "author": "jihoonson", "createdAt": "2020-05-14T00:16:29Z", "path": "extensions-core/avro-extensions/src/main/java/org/apache/druid/data/input/avro/AvroOCFReader.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.data.input.avro;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.file.DataFileReader;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.druid.data.input.InputEntity;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowSchema;\n+import org.apache.druid.data.input.IntermediateRowParsingReader;\n+import org.apache.druid.data.input.impl.MapInputRowParser;\n+import org.apache.druid.java.util.common.io.Closer;\n+import org.apache.druid.java.util.common.parsers.CloseableIterator;\n+import org.apache.druid.java.util.common.parsers.JSONPathSpec;\n+import org.apache.druid.java.util.common.parsers.ObjectFlattener;\n+import org.apache.druid.java.util.common.parsers.ObjectFlatteners;\n+import org.apache.druid.java.util.common.parsers.ParseException;\n+\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class AvroOCFReader extends IntermediateRowParsingReader<GenericRecord>\n+{\n+  private final InputRowSchema inputRowSchema;\n+  private final InputEntity source;\n+  private final File temporaryDirectory;\n+  private final ObjectFlattener<GenericRecord> recordFlattener;\n+  private Schema readerSchema;\n+\n+  AvroOCFReader(\n+      InputRowSchema inputRowSchema,\n+      InputEntity source,\n+      File temporaryDirectory,\n+      @Nullable Schema readerSchema,\n+      JSONPathSpec flattenSpec,\n+      boolean binaryAsString\n+  )\n+  {\n+    this.inputRowSchema = inputRowSchema;\n+    this.source = source;\n+    this.temporaryDirectory = temporaryDirectory;\n+    this.readerSchema = readerSchema;\n+    this.recordFlattener = ObjectFlatteners.create(flattenSpec, new AvroFlattenerMaker(false, binaryAsString));\n+  }\n+\n+  private static Schema dataFileSchema(File file) throws IOException\n+  {\n+    final DataFileReader<GenericRecord> reader = new DataFileReader<>(file, new GenericDatumReader<>());\n+    final Schema schema = reader.getSchema();\n+    reader.close();\n+    return schema;\n+  }\n+\n+  @Override\n+  protected CloseableIterator<GenericRecord> intermediateRowIterator() throws IOException\n+  {\n+    final Closer closer = Closer.create();\n+\n+    final byte[] buffer = new byte[InputEntity.DEFAULT_FETCH_BUFFER_SIZE];\n+    final InputEntity.CleanableFile file = closer.register(source.fetch(temporaryDirectory, buffer));\n+    final Schema writerSchema = dataFileSchema(file.file());", "originalCommit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3Njc5Ng==", "url": "https://github.com/apache/druid/pull/9671#discussion_r424876796", "bodyText": "I see, yes will fix.", "author": "josephglanville", "createdAt": "2020-05-14T05:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMTg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMTk5Mg==", "url": "https://github.com/apache/druid/pull/9671#discussion_r424801992", "bodyText": "\ud83d\udc4d", "author": "jihoonson", "createdAt": "2020-05-14T00:16:53Z", "path": "docs/ingestion/data-formats.md", "diffHunk": "@@ -223,6 +223,53 @@ The Parquet `inputFormat` has the following components:\n |flattenSpec| JSON Object |Define a [`flattenSpec`](#flattenspec) to extract nested values from a Parquet file. Note that only 'path' expression are supported ('jq' is unavailable).| no (default will auto-discover 'root' level properties) |\n | binaryAsString | Boolean | Specifies if the bytes parquet column which is not logically marked as a string or enum type should be treated as a UTF-8 encoded string. | no (default = false) |\n \n+### Avro OCF\n+\n+> You need to include the [`druid-avro-extensions`](../development/extensions-core/avro.md) as an extension to use the Avro OCF input format.\n+\n+The `inputFormat` to load data of Avro OCF format. An example is:\n+```json\n+\"ioConfig\": {\n+  \"inputFormat\": {\n+    \"type\": \"avro_ocf\",\n+    \"flattenSpec\": {\n+      \"useFieldDiscovery\": true,\n+      \"fields\": [\n+        {\n+          \"type\": \"path\",\n+          \"name\": \"someRecord_subInt\",\n+          \"expr\": \"$.someRecord.subInt\"\n+        }\n+      ]\n+    },\n+    \"schema\": {\n+      \"namespace\": \"org.apache.druid.data.input\",\n+      \"name\": \"SomeDatum\",\n+      \"type\": \"record\",\n+      \"fields\" : [\n+        { \"name\": \"timestamp\", \"type\": \"long\" },\n+        { \"name\": \"eventType\", \"type\": \"string\" },\n+        { \"name\": \"id\", \"type\": \"long\" },\n+        { \"name\": \"someRecord\", \"type\": {\n+          \"type\": \"record\", \"name\": \"MySubRecord\", \"fields\": [\n+            { \"name\": \"subInt\", \"type\": \"int\"},\n+            { \"name\": \"subLong\", \"type\": \"long\"}\n+          ]\n+        }}]\n+    },\n+    \"binaryAsString\": false", "originalCommit": "80f7d561b6604aa921937ab7f26bbcb7d12307df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b08f4c1469d905c9c2d1042c496a4090edbce2ca", "url": "https://github.com/apache/druid/commit/b08f4c1469d905c9c2d1042c496a4090edbce2ca", "message": "Address second round of review", "committedDate": "2020-05-15T01:12:06Z", "type": "commit"}]}