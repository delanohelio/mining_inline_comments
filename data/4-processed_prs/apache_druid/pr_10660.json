{"pr_number": 10660, "pr_title": "fix DruidSchema incorrectly listing tables with no segments", "pr_createdAt": "2020-12-09T03:08:59Z", "pr_url": "https://github.com/apache/druid/pull/10660", "timeline": [{"oid": "65b1a579a69afcfd2c71b70c430a1365ad3c4b43", "url": "https://github.com/apache/druid/commit/65b1a579a69afcfd2c71b70c430a1365ad3c4b43", "message": "fix race condition with DruidSchema tables and dataSourcesNeedingRebuild", "committedDate": "2020-12-09T03:00:38Z", "type": "commit"}, {"oid": "557e40ab79d23ce0e1316ee2dfe8625070f8c0f5", "url": "https://github.com/apache/druid/commit/557e40ab79d23ce0e1316ee2dfe8625070f8c0f5", "message": "rework to see if it passes analysis", "committedDate": "2020-12-09T18:54:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NzMxNA==", "url": "https://github.com/apache/druid/pull/10660#discussion_r539587314", "bodyText": "This looks like it's undoing a mistake in removeSegment \u2014\u00a0the datasource should never have been added to dataSourcesNeedingRebuild in the first place. IMO it'd be better to make the change there. Doing it here works, though, so I'm OK with it if you don't want to move the logic around.", "author": "gianm", "createdAt": "2020-12-09T19:31:37Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -270,8 +270,15 @@ public void start() throws InterruptedException\n                   // Add missing segments back to the refresh list.\n                   segmentsNeedingRefresh.addAll(Sets.difference(segmentsToRefresh, refreshed));\n \n+                  // remove any tables which have been completely dropped before refresh", "originalCommit": "557e40ab79d23ce0e1316ee2dfe8625070f8c0f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5ODE2OQ==", "url": "https://github.com/apache/druid/pull/10660#discussion_r539598169", "bodyText": "Ah, the removal of segments from the broker could also mean that a datasource is no longer global/joinable and so also could require a rebuild, so i'm not sure we can remove it anymore without rethinking/reworking some other stuff. Since there were multiple places that we add to dataSourcesNeedingRebuild, but only one place we add to tables, it seemed less room for error to do the filtering here in the only place we populate it.", "author": "clintropolis", "createdAt": "2020-12-09T19:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NzMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYyMTg3MA==", "url": "https://github.com/apache/druid/pull/10660#discussion_r539621870", "bodyText": "removeSegment is only called when the last replica of a segment is gone, though.", "author": "gianm", "createdAt": "2020-12-09T20:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NzMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYyOTk2Mg==", "url": "https://github.com/apache/druid/pull/10660#discussion_r539629962", "bodyText": "Oh good point, the broker thing happens in removeServerSegment, not removeSegment. Ok, i'll remove the dataSourcesNeedingRebuild.add from removeSegment \ud83d\udc4d", "author": "clintropolis", "createdAt": "2020-12-09T20:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NzMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMjgwNA==", "url": "https://github.com/apache/druid/pull/10660#discussion_r539632804", "bodyText": "I think it should be there, but only called if there's some other segments still remaining.", "author": "gianm", "createdAt": "2020-12-09T20:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NzMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4NzMyNg==", "url": "https://github.com/apache/druid/pull/10660#discussion_r539987326", "bodyText": "Looks like one of the integration tests failed after the latest modifications, so more than just moving dataSourcesNeedingRebuild.add to the else is needed. I suspect it is the removeServerSegment which should also probably check if there are any segments before adding to the list in case it is triggered by the broker (broker segments are not currently tracked in segmentMetadataInfo since they will always currently be duplicated on a historical)", "author": "clintropolis", "createdAt": "2020-12-10T08:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU4NzMxNA=="}], "type": "inlineReview"}, {"oid": "1a04f1c94aa774b29b5e31ce94899f06b3c7057a", "url": "https://github.com/apache/druid/commit/1a04f1c94aa774b29b5e31ce94899f06b3c7057a", "message": "more better", "committedDate": "2020-12-09T22:54:12Z", "type": "commit"}, {"oid": "6cc63e1f3afe5762fe64643f2dfc867aa0a9c32c", "url": "https://github.com/apache/druid/commit/6cc63e1f3afe5762fe64643f2dfc867aa0a9c32c", "message": "maybe this", "committedDate": "2020-12-10T09:01:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNDkzMA==", "url": "https://github.com/apache/druid/pull/10660#discussion_r540414930", "bodyText": "How could knownSegments be null or empty here? If removeServerSegment is being called, doesn't that suggest we should have previously had an addSegment call, and therefore the segment should be known?", "author": "gianm", "createdAt": "2020-12-10T18:51:33Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/schema/DruidSchema.java", "diffHunk": "@@ -448,25 +449,27 @@ void removeServerSegment(final DruidServerMetadata server, final DataSegment seg\n   {\n     synchronized (lock) {\n       log.debug(\"Segment[%s] is gone from server[%s]\", segment.getId(), server.getName());\n-      if (server.getType().equals(ServerType.BROKER)) {\n-        // a segment on a broker means a broadcast datasource, skip metadata because we'll also see this segment on the\n-        // historical, however mark the datasource for refresh because it might no longer be broadcast or something\n-        dataSourcesNeedingRebuild.add(segment.getDataSource());\n-      } else {\n-        final Map<SegmentId, AvailableSegmentMetadata> knownSegments = segmentMetadataInfo.get(segment.getDataSource());\n-        final AvailableSegmentMetadata segmentMetadata = knownSegments.get(segment.getId());\n-        final Set<DruidServerMetadata> segmentServers = segmentMetadata.getReplicas();\n-        final ImmutableSet<DruidServerMetadata> servers = FluentIterable\n-            .from(segmentServers)\n-            .filter(Predicates.not(Predicates.equalTo(server)))\n-            .toSet();\n-\n-        final AvailableSegmentMetadata metadataWithNumReplicas = AvailableSegmentMetadata\n-            .from(segmentMetadata)\n-            .withReplicas(servers)\n-            .withRealtime(recomputeIsRealtime(servers))\n-            .build();\n-        knownSegments.put(segment.getId(), metadataWithNumReplicas);\n+      final Map<SegmentId, AvailableSegmentMetadata> knownSegments = segmentMetadataInfo.get(segment.getDataSource());\n+      if (knownSegments != null && !knownSegments.isEmpty()) {", "originalCommit": "6cc63e1f3afe5762fe64643f2dfc867aa0a9c32c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4MTcwMA==", "url": "https://github.com/apache/druid/pull/10660#discussion_r540481700", "bodyText": "Hmm, I couldn't work out in my mind that it definitively would be there so added this check as a precaution. Note that segments on brokers are not added to segmentMetadataInfo (or currently stored in the broker server view timeline), so my fear was cases where the segment is dropped from all historicals before the broker.\nThat said, I don't really like this if statement either, let me see if i can determine for sure if this can happen.", "author": "clintropolis", "createdAt": "2020-12-10T20:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNDkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ5NjE0Nw==", "url": "https://github.com/apache/druid/pull/10660#discussion_r540496147", "bodyText": "Oh, I see. I was assuming that segments get added to segmentMetadataInfo no matter where they're served from.\nDo you know why that's not the case? I mean, why not add segments served by Brokers to segmentMetadataInfo?\nAt any rate, if it's not the case, then I think knownSegments could be null here if it's dropped from historicals before the broker, so it makes sense to check for it. There should be a comment about why this can happen.", "author": "gianm", "createdAt": "2020-12-10T21:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNDkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwOTcxNw==", "url": "https://github.com/apache/druid/pull/10660#discussion_r540509717", "bodyText": "Do you know why that's not the case? I mean, why not add segments served by Brokers to segmentMetadataInfo?\n\nHmm, trying to remember exactly. I know BrokerServerView doesn't track broker served segments on the timeline because it would require changes to query server selection logic to either filter out brokers, or, make it smart enough to query locally through the brokers segment manager directly whenever it picked itself (so that it doesn't make an infinite query loop by submitting another query to itself and so on). Side note, fixing this would be a cool improvement because it would allow for brokers to query other brokers, which with some other work could potentially allow for cool broker trees where not every broker has to track segments of every historical, but could still query every segment.\nI think that DruidSchema actually could probably track them though, since it doesn't use the broker server views timelines, just the events fired from the timeline (which still do happen for segments served by brokers to allow things like DruidSchema to act on them). I suspect that I skipped broker segment tracking simply because it wasn't really necessary to compute the schema itself, only whether the datasource is globally available, but it doesn't seem like it would be harmful to add them. I'll look into making the change, because that would be less magical behavior.\n\nAt any rate, if it's not the case, then I think knownSegments could be null here if it's dropped from historicals before the broker, so it makes sense to check for it. There should be a comment about why this can happen.\n\nI guess the null check really only belongs inside of if (server.getType().equals(ServerType.BROKER)) clause since that is the only case it can be null. If changing to just track broker segments is problematic for some reason, I'll make this change and add a comment.", "author": "clintropolis", "createdAt": "2020-12-10T21:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNDkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxMjA3MQ==", "url": "https://github.com/apache/druid/pull/10660#discussion_r540512071", "bodyText": "Oh, segmentRemoved does not get triggered from broker segments by BrokerServerView since it is ignoring the broker segments (segmentRemoved is fired only when segment is completely removed from timeline which doesn't contain broker segments).\nI'll just keep it this way for now I think, and add some comments about why the null check and how someday DruidSchema could consider tracking the broker segments when BrokerServerView is modified to track broker served segments.", "author": "clintropolis", "createdAt": "2020-12-10T21:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNDkzMA=="}], "type": "inlineReview"}, {"oid": "32ecbf710e2e0f3c5ab42b301ce110cfe340b43c", "url": "https://github.com/apache/druid/commit/32ecbf710e2e0f3c5ab42b301ce110cfe340b43c", "message": "re-arrange and comments", "committedDate": "2020-12-10T21:40:56Z", "type": "commit"}]}