{"pr_number": 9965, "pr_title": "API to verify a datasource has the latest ingested data", "pr_createdAt": "2020-06-02T04:13:00Z", "pr_url": "https://github.com/apache/druid/pull/9965", "timeline": [{"oid": "bd95578e6a4875aa106b1710b3c1b78f46bbc12f", "url": "https://github.com/apache/druid/commit/bd95578e6a4875aa106b1710b3c1b78f46bbc12f", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T03:57:56Z", "type": "commit"}, {"oid": "8d2749e34f0d74ccfc480da14c0b2826ef354116", "url": "https://github.com/apache/druid/commit/8d2749e34f0d74ccfc480da14c0b2826ef354116", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T09:13:38Z", "type": "commit"}, {"oid": "aca82f3eafa1c9ca9b4cb6dde48b55442b86c0bd", "url": "https://github.com/apache/druid/commit/aca82f3eafa1c9ca9b4cb6dde48b55442b86c0bd", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T10:13:01Z", "type": "commit"}, {"oid": "1a1a0cdb13bc473b81e4ecf7a9e76afb035a72e5", "url": "https://github.com/apache/druid/commit/1a1a0cdb13bc473b81e4ecf7a9e76afb035a72e5", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T10:21:08Z", "type": "commit"}, {"oid": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "url": "https://github.com/apache/druid/commit/6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T10:48:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NTM4OQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r434945389", "bodyText": "I think this parameter should be something like forceMetadataPoll or forceMetadataRefresh something", "author": "clintropolis", "createdAt": "2020-06-04T01:41:52Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +393,43 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"firstCheck\") @Nullable final Boolean firstCheck", "originalCommit": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxNzA5OQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437817099", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-10T01:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjMxNA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r434946314", "bodyText": "It seems a little off that not having serverInventoryView or it not being initialized would return a {\"loaded\":false} but a datasource not existing would be an empty response. I think this response is fine, but maybe the serverInventoryView == null case should be an error response indicating that information in unavailable", "author": "clintropolis", "createdAt": "2020-06-04T01:45:10Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +393,43 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"firstCheck\") @Nullable final Boolean firstCheck\n+  )\n+  {\n+    if (serverInventoryView == null || serverInventoryView.getSegmentLoadInfos() == null) {\n+      return Response.ok(ImmutableMap.of(\"loaded\", false)).build();\n+    }\n+    // Force poll\n+    Interval theInterval = interval == null ? Intervals.ETERNITY : Intervals.of(interval);\n+    boolean requiresMetadataStorePoll = firstCheck == null ? true :firstCheck;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);", "originalCommit": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxNzUwNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437817506", "bodyText": "serverInventoryView and segmentLoadInfos are never null", "author": "maytasm", "createdAt": "2020-06-10T01:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjY1NQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r434946655", "bodyText": "nit: i think the old name was better, and still works with the new method being named forceOrWaitOngoingDatabasePoll", "author": "clintropolis", "createdAt": "2020-06-04T01:46:43Z", "path": "server/src/main/java/org/apache/druid/metadata/SqlSegmentsMetadataManager.java", "diffHunk": "@@ -403,11 +425,16 @@ private void awaitOrPerformDatabasePoll()\n   }\n \n   /**\n-   * If the latest {@link DatabasePoll} is a {@link PeriodicDatabasePoll}, or an {@link OnDemandDatabasePoll} that is\n-   * made not longer than {@link #periodicPollDelay} from now, awaits for it and returns true; returns false otherwise,\n-   * meaning that a new on-demand database poll should be initiated.\n+   * This method returns true without waiting for database poll if the latest {@link DatabasePoll} is a\n+   * {@link PeriodicDatabasePoll} that has completed it's first poll, or an {@link OnDemandDatabasePoll} that is\n+   * made not longer than {@link #periodicPollDelay} from current time.\n+   * This method does wait untill completion for if the latest {@link DatabasePoll} is a\n+   * {@link PeriodicDatabasePoll} that has not completed it's first poll, or an {@link OnDemandDatabasePoll} that is\n+   * alrady in the process of polling the database.\n+   * This means that any method using this check can read from snapshot that is\n+   * up to {@link SqlSegmentsMetadataManager#periodicPollDelay} old.\n    */\n-  private boolean awaitLatestDatabasePoll()\n+  private boolean useLatestSnapshotIfWithinDelay()", "originalCommit": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxODUxOQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437818519", "bodyText": "I really dont like the old name. This method most of the time does not wait (even though the method is called await). For example, if the latest poll is PeriodicDatabasePoll, it will never wait and just return the last poll. Even if there is a on-going PeriodicDatabasePoll, it does not wait and return the last poll. If the latest poll is OnDemandDatabasePoll, it will only wait if the latest is older than pollPeriod. This means that most of the time this method does not await and return last poll.", "author": "maytasm", "createdAt": "2020-06-10T02:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxODcxNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437818716", "bodyText": "Just saying awaitLatestDatabasePoll is misleading as it does not always guarantee wait on latest database poll.", "author": "maytasm", "createdAt": "2020-06-10T02:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1MjA3Nw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r434952077", "bodyText": "nit: formatting seems strange here, i suggest:\n  Optional<Iterable<DataSegment>> iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n      String datasource,\n      Interval interval,\n      boolean requiresLatest\n  );", "author": "clintropolis", "createdAt": "2020-06-04T02:08:40Z", "path": "server/src/main/java/org/apache/druid/metadata/SegmentsMetadataManager.java", "diffHunk": "@@ -113,6 +114,18 @@ int markAsUsedNonOvershadowedSegments(String dataSource, Set<String> segmentIds)\n    */\n   Iterable<DataSegment> iterateAllUsedSegments();\n \n+  /**\n+   * Returns an iterable to go over all used and non-overshadowed segments of given data sources over given interval.\n+   * The order in which segments are iterated is unspecified.\n+   * If {@param requiresLatest} is true then a force metadatastore poll will be triggered. This can cause a longer\n+   * response time but will ensure that the latest segment information (at the time this method is called) is returned.\n+   * If {@param requiresLatest} is false then segment information from stale snapshot of up to the last periodic poll\n+   * period {@link SqlSegmentsMetadataManager#periodicPollDelay} will be used.\n+   */\n+  Optional<Iterable<DataSegment>> iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(String datasource,", "originalCommit": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxODg0Nw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437818847", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-10T02:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1MjA3Nw=="}], "type": "inlineReview"}, {"oid": "0a7dc4e2a357a9094e08fcd8f4684abe1ff0ceae", "url": "https://github.com/apache/druid/commit/0a7dc4e2a357a9094e08fcd8f4684abe1ff0ceae", "message": "fix checksyle", "committedDate": "2020-06-06T03:43:41Z", "type": "commit"}, {"oid": "0a019d1b2adbcfb7a92ffc496d3c21edb510ef86", "url": "https://github.com/apache/druid/commit/0a019d1b2adbcfb7a92ffc496d3c21edb510ef86", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-10T01:58:08Z", "type": "commit"}, {"oid": "49dc85b69325ccfe7515ad5a4870aa40567c292d", "url": "https://github.com/apache/druid/commit/49dc85b69325ccfe7515ad5a4870aa40567c292d", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-10T02:05:33Z", "type": "commit"}, {"oid": "46e5019df2fdf9dda0e5a3475fd6e877d5c23cf9", "url": "https://github.com/apache/druid/commit/46e5019df2fdf9dda0e5a3475fd6e877d5c23cf9", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-10T08:07:46Z", "type": "commit"}, {"oid": "2270a5bec6985111be1d464b96bf23f7962a0d58", "url": "https://github.com/apache/druid/commit/2270a5bec6985111be1d464b96bf23f7962a0d58", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-10T08:43:15Z", "type": "commit"}, {"oid": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "url": "https://github.com/apache/druid/commit/172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "message": "fix spelling", "committedDate": "2020-06-10T12:19:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MjYzMA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r438362630", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #### Segment Loading for Datasource\n          \n          \n            \n            #### Segment Loading by Datasource", "author": "sthetland", "createdAt": "2020-06-10T19:36:15Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,41 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading for Datasource", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDA4NA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439700084", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T02:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MjYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MzEzOQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r438363139", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            These APIs can be used to verify if segments created by recent ingestion task are loaded onto historicals and available for query.\n          \n          \n            \n            You can verify if segments created by a recent ingestion task are loaded onto historicals and available for querying using the following APIs.", "author": "sthetland", "createdAt": "2020-06-10T19:37:16Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,41 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading for Datasource\n+\n+These APIs can be used to verify if segments created by recent ingestion task are loaded onto historicals and available for query.", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDEyNQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439700125", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T02:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MzEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MzQ0NQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r438363445", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            1. Submit your ingestion task\n          \n          \n            \n            1. Submit your ingestion task.", "author": "sthetland", "createdAt": "2020-06-10T19:37:51Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,41 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading for Datasource\n+\n+These APIs can be used to verify if segments created by recent ingestion task are loaded onto historicals and available for query.\n+An example workflow for this is:\n+1. Submit your ingestion task", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDE0NQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439700145", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T02:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2MzQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2Mzk1OA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r438363958", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Repeatedly poll Overlord's task API ( `/druid/indexer/v1/task/{taskId}/status`) until task is completed and succeeded.\n          \n          \n            \n            2. Repeatedly poll the Overlord's task API ( `/druid/indexer/v1/task/{taskId}/status`) until your task is shown to be successfully completed.", "author": "sthetland", "createdAt": "2020-06-10T19:38:49Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,41 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading for Datasource\n+\n+These APIs can be used to verify if segments created by recent ingestion task are loaded onto historicals and available for query.\n+An example workflow for this is:\n+1. Submit your ingestion task\n+2. Repeatedly poll Overlord's task API ( `/druid/indexer/v1/task/{taskId}/status`) until task is completed and succeeded.", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDE2MQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439700161", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T02:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2Mzk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NTEyNA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r438365124", "bodyText": "maybe call it loadstatus?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            3. Poll Segment Loading for Datasource API (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with `forceMetadataRefresh=true` once. \n          \n          \n            \n            3. Poll the datasource loadstatus API (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with `forceMetadataRefresh=true` once.", "author": "sthetland", "createdAt": "2020-06-10T19:41:00Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,41 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading for Datasource\n+\n+These APIs can be used to verify if segments created by recent ingestion task are loaded onto historicals and available for query.\n+An example workflow for this is:\n+1. Submit your ingestion task\n+2. Repeatedly poll Overlord's task API ( `/druid/indexer/v1/task/{taskId}/status`) until task is completed and succeeded.\n+3. Poll Segment Loading for Datasource API (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with `forceMetadataRefresh=true` once. ", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDIzMQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439700231", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T02:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NTEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NjQ5OA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r438366498", "bodyText": "Maybe indicate that true is the default here? and remove the sentence that comes later (\"forceMetadataRefresh will be set to true if not given.\")\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            over the given interval (or last 2 weeks if interval is not given). Setting `forceMetadataRefresh=true`\n          \n          \n            \n            over the given interval (or last 2 weeks if interval is not given). Setting `forceMetadataRefresh` to true (the default)", "author": "sthetland", "createdAt": "2020-06-10T19:43:36Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,41 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading for Datasource\n+\n+These APIs can be used to verify if segments created by recent ingestion task are loaded onto historicals and available for query.\n+An example workflow for this is:\n+1. Submit your ingestion task\n+2. Repeatedly poll Overlord's task API ( `/druid/indexer/v1/task/{taskId}/status`) until task is completed and succeeded.\n+3. Poll Segment Loading for Datasource API (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with `forceMetadataRefresh=true` once. \n+If there are segments not yet loaded, continue to step 4, otherwise you can now query the data.\n+4. Repeatedly poll Segment Loading for Datasource API (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with `forceMetadataRefresh=false`. \n+Continue polling until all segments are loaded. Once all segments are loaded you can now query the data.\n+\n+##### GET\n+\n+* `/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus?forceMetadataRefresh={boolean}&interval={myInterval}`\n+\n+Returns the percentage of segments actually loaded in the cluster versus segments that should be loaded in the cluster for the given datasource \n+over the given interval (or last 2 weeks if interval is not given). Setting `forceMetadataRefresh=true`", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDY1MQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439700651", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T02:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NjQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2ODE2Ng==", "url": "https://github.com/apache/druid/pull/9965#discussion_r438368166", "bodyText": "Maybe add the positive case as well, if this is the case?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If no used segments found for the given inputs, this API returns 100% as the value.\n          \n          \n            \n            If all segments have been loaded or no used segments are found for the given inputs, this API returns 100% as the value.", "author": "sthetland", "createdAt": "2020-06-10T19:46:43Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,41 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading for Datasource\n+\n+These APIs can be used to verify if segments created by recent ingestion task are loaded onto historicals and available for query.\n+An example workflow for this is:\n+1. Submit your ingestion task\n+2. Repeatedly poll Overlord's task API ( `/druid/indexer/v1/task/{taskId}/status`) until task is completed and succeeded.\n+3. Poll Segment Loading for Datasource API (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with `forceMetadataRefresh=true` once. \n+If there are segments not yet loaded, continue to step 4, otherwise you can now query the data.\n+4. Repeatedly poll Segment Loading for Datasource API (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with `forceMetadataRefresh=false`. \n+Continue polling until all segments are loaded. Once all segments are loaded you can now query the data.\n+\n+##### GET\n+\n+* `/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus?forceMetadataRefresh={boolean}&interval={myInterval}`\n+\n+Returns the percentage of segments actually loaded in the cluster versus segments that should be loaded in the cluster for the given datasource \n+over the given interval (or last 2 weeks if interval is not given). Setting `forceMetadataRefresh=true`\n+will force the coordinator to poll latest segment metadata from the metadata store. `forceMetadataRefresh` will be set to true if not given.\n+If no used segments found for the given inputs, this API returns 100% as the value.", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDcxNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439700716", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T02:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2ODE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MTE4Ng==", "url": "https://github.com/apache/druid/pull/9965#discussion_r438381186", "bodyText": "\"This does not include replication\" Meaning, replicated segments?", "author": "sthetland", "createdAt": "2020-06-10T20:12:08Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,41 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading for Datasource\n+\n+These APIs can be used to verify if segments created by recent ingestion task are loaded onto historicals and available for query.\n+An example workflow for this is:\n+1. Submit your ingestion task\n+2. Repeatedly poll Overlord's task API ( `/druid/indexer/v1/task/{taskId}/status`) until task is completed and succeeded.\n+3. Poll Segment Loading for Datasource API (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with `forceMetadataRefresh=true` once. \n+If there are segments not yet loaded, continue to step 4, otherwise you can now query the data.\n+4. Repeatedly poll Segment Loading for Datasource API (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with `forceMetadataRefresh=false`. \n+Continue polling until all segments are loaded. Once all segments are loaded you can now query the data.\n+\n+##### GET\n+\n+* `/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus?forceMetadataRefresh={boolean}&interval={myInterval}`\n+\n+Returns the percentage of segments actually loaded in the cluster versus segments that should be loaded in the cluster for the given datasource \n+over the given interval (or last 2 weeks if interval is not given). Setting `forceMetadataRefresh=true`\n+will force the coordinator to poll latest segment metadata from the metadata store. `forceMetadataRefresh` will be set to true if not given.\n+If no used segments found for the given inputs, this API returns 100% as the value.\n+\n+ * `/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus?simple&forceMetadataRefresh={boolean}&interval={myInterval}`\n+\n+Returns the number of segments left to load until segments that should be loaded in the cluster are available for the given datasource \n+over the given interval (or last 2 weeks if interval is not given). This does not include replication. Setting `forceMetadataRefresh=true` ", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMDg5NA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439700894", "bodyText": "Yes.\nMaybe \"This does not include replica of segments\"?", "author": "maytasm", "createdAt": "2020-06-13T02:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MTE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3OTExMA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439179110", "bodyText": "I really don't think this should default to true since it is a heavy operation, but also, since the docs recommend polling the API with the not default option to determine when your segments are all available and only calling with the default option once.", "author": "clintropolis", "createdAt": "2020-06-12T02:51:13Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMTU4Ng==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439701586", "bodyText": "The reason I have the default as true is to prevent operator mistake by forgetting to set to true on the first call. Basically, you will get the correct result if you make every call with true. However, you will not get the correct result (and can be making query when segments are not yet loaded!) if you make every call with false. Hence, having default to true to a safer option imo.", "author": "maytasm", "createdAt": "2020-06-13T02:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3OTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMTYyNQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439701625", "bodyText": "Setting to false is an optional optimization that can be done on the calls after the first call.", "author": "maytasm", "createdAt": "2020-06-13T02:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3OTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzE5Mw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707193", "bodyText": "Making this field mandatory instead. 400 bad request will be returned if forceMetadataRefresh is not given. This will make sure user read and understand the doc when using this API. To use this API properly, you will have to change the flag in the flow between first call and subsequent call. Hence, there is no \u201cdefault\u201d as the flag are for different cases. Basically both flags are as default as the other flag and are needed for different step in the flow.", "author": "maytasm", "createdAt": "2020-06-13T04:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3OTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MDgyNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439180826", "bodyText": "It seems like there is quite a lot of logic in this API entry point method, it would be worth breaking each of these blocks out into methods dedicated for each response so it's a bit easier to follow", "author": "clintropolis", "createdAt": "2020-06-12T02:58:53Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzE5Ng==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707196", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MTI2Mg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439181262", "bodyText": "resposne -> response", "author": "clintropolis", "createdAt": "2020-06-12T03:00:42Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzIxMw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707213", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MjY0MA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439182640", "bodyText": "Hmm, is there a way to re-arrange this without iterating the entire set of segments twice? If not it would maybe be worth pushing this into DruidCoordinator, at least if force refresh is true, since it potentially has segmentReplicantLookup already built, or exposing it to this resource in some manner.", "author": "clintropolis", "createdAt": "2020-06-12T03:06:54Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode\n+      final Map<String, Object2LongMap<String>> underReplicationCountsPerDataSourcePerTier = new HashMap<>();\n+      final List<Rule> rules = metadataRuleManager.getRulesWithDefault(dataSourceName);\n+      final Table<SegmentId, String, Integer> segmentsInCluster = HashBasedTable.create();\n+      final DateTime now = DateTimes.nowUtc();\n+\n+      for (DataSegment segment : segments.get()) {\n+        for (DruidServer druidServer : serverInventoryView.getInventory()) {\n+          String tier = druidServer.getTier();\n+          SegmentId segmentId = segment.getId();\n+          DruidDataSource druidDataSource = druidServer.getDataSource(dataSourceName);\n+          if (druidDataSource != null && druidDataSource.getSegment(segmentId) != null) {\n+            Integer numReplicants = segmentsInCluster.get(segmentId, tier);\n+            if (numReplicants == null) {\n+              numReplicants = 0;\n+            }\n+            segmentsInCluster.put(segmentId, tier, numReplicants + 1);\n+          }\n+        }\n+      }\n+      for (DataSegment segment : segments.get()) {", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzM5MQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707391", "bodyText": "Removed this code in DataSourcesResource. Reuse the code for calculating the underReplicationCountsPerDataSourcePerTier in DruidCoordinator by making the call to DruidCoordinator. This basically reuse segmentReplicantLookup in DruidCoordinator. This can make sure that the behavior is consistent between the full format of the new API and the existing coordinator loadstatus API. For example, if there is a bug in the full format coordinator loadstatus API where it is ignoring broadcast rule, then we just have to remember to fix it in one place ;)", "author": "maytasm", "createdAt": "2020-06-13T04:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MjY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MzYwMQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439183601", "bodyText": "resposne -> response", "author": "clintropolis", "createdAt": "2020-06-12T03:11:19Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode\n+      final Map<String, Object2LongMap<String>> underReplicationCountsPerDataSourcePerTier = new HashMap<>();\n+      final List<Rule> rules = metadataRuleManager.getRulesWithDefault(dataSourceName);\n+      final Table<SegmentId, String, Integer> segmentsInCluster = HashBasedTable.create();\n+      final DateTime now = DateTimes.nowUtc();\n+\n+      for (DataSegment segment : segments.get()) {\n+        for (DruidServer druidServer : serverInventoryView.getInventory()) {\n+          String tier = druidServer.getTier();\n+          SegmentId segmentId = segment.getId();\n+          DruidDataSource druidDataSource = druidServer.getDataSource(dataSourceName);\n+          if (druidDataSource != null && druidDataSource.getSegment(segmentId) != null) {\n+            Integer numReplicants = segmentsInCluster.get(segmentId, tier);\n+            if (numReplicants == null) {\n+              numReplicants = 0;\n+            }\n+            segmentsInCluster.put(segmentId, tier, numReplicants + 1);\n+          }\n+        }\n+      }\n+      for (DataSegment segment : segments.get()) {\n+        for (final Rule rule : rules) {\n+          if (!(rule instanceof LoadRule && rule.appliesTo(segment, now))) {\n+            continue;\n+          }\n+          ((LoadRule) rule)\n+              .getTieredReplicants()\n+              .forEach((final String tier, final Integer ruleReplicants) -> {\n+                Integer currentReplicantsRetVal = segmentsInCluster.get(segment.getId(), tier);\n+                int currentReplicants = currentReplicantsRetVal == null ? 0 : currentReplicantsRetVal;\n+                Object2LongMap<String> underReplicationPerDataSource = underReplicationCountsPerDataSourcePerTier\n+                    .computeIfAbsent(tier, ignored -> new Object2LongOpenHashMap<>());\n+                ((Object2LongOpenHashMap<String>) underReplicationPerDataSource)\n+                    .addTo(dataSourceName, Math.max(ruleReplicants - currentReplicants, 0));\n+              });\n+          break; // only the first matching rule applies\n+        }\n+      }\n+      return Response.ok(underReplicationCountsPerDataSourcePerTier).build();\n+    } else {\n+      // Calculate resposne for default mode", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzQxMA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707410", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MzYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NDExNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439184116", "bodyText": "Yeah, I think you need to handle BroadcastDistributionRule here too if you want to be totally complete, however CoordinatorResource loadstatus api call has this problem too, so it would probably be ok to fix both in a follow-up PR.", "author": "clintropolis", "createdAt": "2020-06-12T03:13:50Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode\n+      final Map<String, Object2LongMap<String>> underReplicationCountsPerDataSourcePerTier = new HashMap<>();\n+      final List<Rule> rules = metadataRuleManager.getRulesWithDefault(dataSourceName);\n+      final Table<SegmentId, String, Integer> segmentsInCluster = HashBasedTable.create();\n+      final DateTime now = DateTimes.nowUtc();\n+\n+      for (DataSegment segment : segments.get()) {\n+        for (DruidServer druidServer : serverInventoryView.getInventory()) {\n+          String tier = druidServer.getTier();\n+          SegmentId segmentId = segment.getId();\n+          DruidDataSource druidDataSource = druidServer.getDataSource(dataSourceName);\n+          if (druidDataSource != null && druidDataSource.getSegment(segmentId) != null) {\n+            Integer numReplicants = segmentsInCluster.get(segmentId, tier);\n+            if (numReplicants == null) {\n+              numReplicants = 0;\n+            }\n+            segmentsInCluster.put(segmentId, tier, numReplicants + 1);\n+          }\n+        }\n+      }\n+      for (DataSegment segment : segments.get()) {\n+        for (final Rule rule : rules) {\n+          if (!(rule instanceof LoadRule && rule.appliesTo(segment, now))) {", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzQzMQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707431", "bodyText": "Since this is a bug in the original Coordinator loadstatus API. I'll fix this in a follow-up PR", "author": "maytasm", "createdAt": "2020-06-13T04:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NDExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NDc5MQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439184791", "bodyText": "super nit: it would probably be consistent to try to match the terminology that appears in the system segments table, which uses 'published' and 'available' for used and loaded\n\nnumUsedSegments -> numPublishedSegments\nnumUnloadedSegments -> numUnavailableSegments", "author": "clintropolis", "createdAt": "2020-06-12T03:16:50Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode\n+      final Map<String, Object2LongMap<String>> underReplicationCountsPerDataSourcePerTier = new HashMap<>();\n+      final List<Rule> rules = metadataRuleManager.getRulesWithDefault(dataSourceName);\n+      final Table<SegmentId, String, Integer> segmentsInCluster = HashBasedTable.create();\n+      final DateTime now = DateTimes.nowUtc();\n+\n+      for (DataSegment segment : segments.get()) {\n+        for (DruidServer druidServer : serverInventoryView.getInventory()) {\n+          String tier = druidServer.getTier();\n+          SegmentId segmentId = segment.getId();\n+          DruidDataSource druidDataSource = druidServer.getDataSource(dataSourceName);\n+          if (druidDataSource != null && druidDataSource.getSegment(segmentId) != null) {\n+            Integer numReplicants = segmentsInCluster.get(segmentId, tier);\n+            if (numReplicants == null) {\n+              numReplicants = 0;\n+            }\n+            segmentsInCluster.put(segmentId, tier, numReplicants + 1);\n+          }\n+        }\n+      }\n+      for (DataSegment segment : segments.get()) {\n+        for (final Rule rule : rules) {\n+          if (!(rule instanceof LoadRule && rule.appliesTo(segment, now))) {\n+            continue;\n+          }\n+          ((LoadRule) rule)\n+              .getTieredReplicants()\n+              .forEach((final String tier, final Integer ruleReplicants) -> {\n+                Integer currentReplicantsRetVal = segmentsInCluster.get(segment.getId(), tier);\n+                int currentReplicants = currentReplicantsRetVal == null ? 0 : currentReplicantsRetVal;\n+                Object2LongMap<String> underReplicationPerDataSource = underReplicationCountsPerDataSourcePerTier\n+                    .computeIfAbsent(tier, ignored -> new Object2LongOpenHashMap<>());\n+                ((Object2LongOpenHashMap<String>) underReplicationPerDataSource)\n+                    .addTo(dataSourceName, Math.max(ruleReplicants - currentReplicants, 0));\n+              });\n+          break; // only the first matching rule applies\n+        }\n+      }\n+      return Response.ok(underReplicationCountsPerDataSourcePerTier).build();\n+    } else {\n+      // Calculate resposne for default mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUsedSegments = 0;", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzUyMA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707520", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NDc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NTM3NA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439185374", "bodyText": "resposne -> response", "author": "clintropolis", "createdAt": "2020-06-12T03:19:37Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzUyNQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707525", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NTM3NA=="}], "type": "inlineReview"}, {"oid": "6d4db3164bbf3aa06f511426b6208f8273901e0f", "url": "https://github.com/apache/druid/commit/6d4db3164bbf3aa06f511426b6208f8273901e0f", "message": "address comments", "committedDate": "2020-06-13T04:21:49Z", "type": "commit"}, {"oid": "cb39dd2e4e5f3aa5589e67ff84edf10d0afda109", "url": "https://github.com/apache/druid/commit/cb39dd2e4e5f3aa5589e67ff84edf10d0afda109", "message": "fix checkstyle", "committedDate": "2020-06-13T04:28:53Z", "type": "commit"}, {"oid": "409a3926a21c8cbe8deb7a5c8b620d99d93cdfd1", "url": "https://github.com/apache/druid/commit/409a3926a21c8cbe8deb7a5c8b620d99d93cdfd1", "message": "update docs", "committedDate": "2020-06-13T05:01:16Z", "type": "commit"}, {"oid": "bb803cd946dc94d0a8a362c84bf42ce66f3ba9b9", "url": "https://github.com/apache/druid/commit/bb803cd946dc94d0a8a362c84bf42ce66f3ba9b9", "message": "fix tests", "committedDate": "2020-06-13T05:48:30Z", "type": "commit"}, {"oid": "2470e8fa81e483839e8903a6f982c6108c230c8a", "url": "https://github.com/apache/druid/commit/2470e8fa81e483839e8903a6f982c6108c230c8a", "message": "fix doc", "committedDate": "2020-06-15T20:22:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5NTkzMA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440495930", "bodyText": "\"This include replica of segments.\" doesn't quite seem right, maybe \"This includes segment replication counts.\"", "author": "clintropolis", "createdAt": "2020-06-15T23:11:58Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -96,11 +96,11 @@ Returns the percentage of segments actually loaded in the cluster versus segment\n \n  * `/druid/coordinator/v1/loadstatus?simple`\n \n-Returns the number of segments left to load until segments that should be loaded in the cluster are available for queries. This does not include replication.\n+Returns the number of segments left to load until segments that should be loaded in the cluster are available for queries. This does not include replica of segments.\n \n * `/druid/coordinator/v1/loadstatus?full`\n \n-Returns the number of segments left to load in each tier until segments that should be loaded in the cluster are all available. This includes replication.\n+Returns the number of segments left to load in each tier until segments that should be loaded in the cluster are all available. This include replica of segments.", "originalCommit": "2470e8fa81e483839e8903a6f982c6108c230c8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzNjk5MQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440536991", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-16T01:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5NTkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5NjEwMw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440496103", "bodyText": "\"This does not include replica of segments.\" -> \"This does not include segment replication counts.\"", "author": "clintropolis", "createdAt": "2020-06-15T23:12:30Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -96,11 +96,11 @@ Returns the percentage of segments actually loaded in the cluster versus segment\n \n  * `/druid/coordinator/v1/loadstatus?simple`\n \n-Returns the number of segments left to load until segments that should be loaded in the cluster are available for queries. This does not include replication.\n+Returns the number of segments left to load until segments that should be loaded in the cluster are available for queries. This does not include replica of segments.", "originalCommit": "2470e8fa81e483839e8903a6f982c6108c230c8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzNzIwNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440537206", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-16T01:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5NjEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5NzUyMQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440497521", "bodyText": "This example workflow seems useful, but also out of place given the rest of this document, which strictly documents API requests and responses instead of illustrating an example application of how to use the API. I'm not sure where else it should live, or if it should just be removed, or if maybe it is fine, but I think it is worth discussing.", "author": "clintropolis", "createdAt": "2020-06-15T23:16:56Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,44 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading by Datasource\n+\n+You can verify if segments created by a recent ingestion task are loaded onto historicals and available for querying using the following APIs.\n+An example workflow for this is:", "originalCommit": "2470e8fa81e483839e8903a6f982c6108c230c8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzODIyNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440538226", "bodyText": "I think this example is useful. Especially when user is trying to verify if segments are loaded and available right after ingestion task is done. The workflow also point out the difference with the coordinator loadstatus API (and how they have different use case). I think the https://druid.apache.org/docs/latest/ingestion/faq.html might be a better place for this.", "author": "maytasm", "createdAt": "2020-06-16T01:41:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5NzUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMzA2Mw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440503063", "bodyText": "I think it's ok that segmentReplicantLookup could potentially be stale since it is only updated on coordinator runs, since the refreshed segment metadata would at least ensure that the stale data would be under counting replication levels, rather than potentially falsely reporting that everything is available (when forcing refresh).", "author": "clintropolis", "createdAt": "2020-06-15T23:35:02Z", "path": "server/src/main/java/org/apache/druid/server/coordinator/DruidCoordinator.java", "diffHunk": "@@ -256,15 +256,24 @@ public boolean isLeader()\n    * @return tier -> { dataSource -> underReplicationCount } map\n    */\n   public Map<String, Object2LongMap<String>> computeUnderReplicationCountsPerDataSourcePerTier()\n+  {\n+    final Iterable<DataSegment> dataSegments = segmentsMetadataManager.iterateAllUsedSegments();\n+    return computeUnderReplicationCountsPerDataSourcePerTierForSegments(dataSegments);\n+  }\n+\n+  /**\n+   * @return tier -> { dataSource -> underReplicationCount } map\n+   */\n+  public Map<String, Object2LongMap<String>> computeUnderReplicationCountsPerDataSourcePerTierForSegments(", "originalCommit": "2470e8fa81e483839e8903a6f982c6108c230c8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU0MTk0OQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440541949", "bodyText": "Keeping the segmentReplicantLookup as possibly stale for now. This still ensures that we will never return true (available) when it\u2019s false (not available) since we force refresh metadata. Although we can return false (not available) when it\u2019s true (available) for up to a period of coordinator run longer for the full format response. This problem will only affects the full format. We can loop back to this if we find that having the option to force refresh the  segmentReplicantLookup is useful. If that is the case then we can use the existing query param, forceMetadataRefresh, to force refresh segmentReplicantLookup too.", "author": "maytasm", "createdAt": "2020-06-16T01:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMzA2Mw=="}], "type": "inlineReview"}, {"oid": "cb9f160d0331574fe112ca2467a9518cff5302b5", "url": "https://github.com/apache/druid/commit/cb9f160d0331574fe112ca2467a9518cff5302b5", "message": "address comments", "committedDate": "2020-06-16T01:52:26Z", "type": "commit"}, {"oid": "79acb14fe87c15c3cb795b83476a8f497917ddb0", "url": "https://github.com/apache/druid/commit/79acb14fe87c15c3cb795b83476a8f497917ddb0", "message": "fix typo", "committedDate": "2020-06-16T02:04:02Z", "type": "commit"}, {"oid": "afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "url": "https://github.com/apache/druid/commit/afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "message": "fix spelling", "committedDate": "2020-06-16T03:46:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMDMwNw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441100307", "bodyText": "I think this applies to only batch ingestion. In streaming ingestion, each row becomes queryable once it's consumed by a realtime task.", "author": "jihoonson", "createdAt": "2020-06-16T19:45:39Z", "path": "docs/ingestion/faq.md", "diffHunk": "@@ -66,6 +66,18 @@ Other common reasons that hand-off fails are as follows:\n \n Make sure to include the `druid-hdfs-storage` and all the hadoop configuration, dependencies (that can be obtained by running command `hadoop classpath` on a machine where hadoop has been setup) in the classpath. And, provide necessary HDFS settings as described in [deep storage](../dependencies/deep-storage.md) .\n \n+## How do I know when I can make query to Druid after submitting ingestion task?", "originalCommit": "afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNDM2Nw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441224367", "bodyText": "Yes. Updated.", "author": "maytasm", "createdAt": "2020-06-17T01:09:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNTcyNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441125726", "bodyText": "I think it would be nice to warn one more time here what will happen with forceMetadataRefresh=true. It could also be mentioned that this API will refresh not only the specified datasource, but all datasources.", "author": "jihoonson", "createdAt": "2020-06-16T20:34:51Z", "path": "docs/ingestion/faq.md", "diffHunk": "@@ -66,6 +66,18 @@ Other common reasons that hand-off fails are as follows:\n \n Make sure to include the `druid-hdfs-storage` and all the hadoop configuration, dependencies (that can be obtained by running command `hadoop classpath` on a machine where hadoop has been setup) in the classpath. And, provide necessary HDFS settings as described in [deep storage](../dependencies/deep-storage.md) .\n \n+## How do I know when I can make query to Druid after submitting ingestion task?\n+\n+You can verify if segments created by a recent ingestion task are loaded onto historicals and available for querying using the following workflow.\n+1. Submit your ingestion task.\n+2. Repeatedly poll the [Overlord's tasks API](../operations/api-reference.md#tasks) ( `/druid/indexer/v1/task/{taskId}/status`) until your task is shown to be successfully completed.\n+3. Poll the [Segment Loading by Datasource API](../operations/api-reference.md#segment-loading-by-datasource) (`/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus`) with \n+`forceMetadataRefresh=true` and `interval=<INTERVAL_OF_INGESTED_DATA>` once.", "originalCommit": "afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNjIzMw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441226233", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-17T01:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNTcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzMjM4Ng==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441132386", "bodyText": "It would be nice to mention that it will refresh all datasources here too.", "author": "jihoonson", "createdAt": "2020-06-16T20:47:31Z", "path": "docs/operations/api-reference.md", "diffHunk": "@@ -114,6 +114,35 @@ Returns the number of segments to load and drop, as well as the total segment lo\n \n Returns the serialized JSON of segments to load and drop for each Historical process.\n \n+\n+#### Segment Loading by Datasource\n+\n+##### GET\n+\n+* `/druid/coordinator/v1/datasources/{dataSourceName}/loadstatus?forceMetadataRefresh={boolean}&interval={myInterval}`\n+\n+Returns the percentage of segments actually loaded in the cluster versus segments that should be loaded in the cluster for the given \n+datasource over the given interval (or last 2 weeks if interval is not given). `forceMetadataRefresh` is required to be set. \n+Setting `forceMetadataRefresh` to true will force the coordinator to poll latest segment metadata from the metadata store. ", "originalCommit": "afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzMjYxNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441132616", "bodyText": "Same for other APIs.", "author": "jihoonson", "createdAt": "2020-06-16T20:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzMjM4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNjczNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441226736", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-17T01:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzMjM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0NTI0MQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441145241", "bodyText": "typo: alrady -> already", "author": "jihoonson", "createdAt": "2020-06-16T21:12:43Z", "path": "server/src/main/java/org/apache/druid/metadata/SqlSegmentsMetadataManager.java", "diffHunk": "@@ -403,11 +427,17 @@ private void awaitOrPerformDatabasePoll()\n   }\n \n   /**\n-   * If the latest {@link DatabasePoll} is a {@link PeriodicDatabasePoll}, or an {@link OnDemandDatabasePoll} that is\n-   * made not longer than {@link #periodicPollDelay} from now, awaits for it and returns true; returns false otherwise,\n-   * meaning that a new on-demand database poll should be initiated.\n+   * This method returns true without waiting for database poll if the latest {@link DatabasePoll} is a\n+   * {@link PeriodicDatabasePoll} that has completed it's first poll, or an {@link OnDemandDatabasePoll} that is\n+   * made not longer than {@link #periodicPollDelay} from current time.\n+   * This method does wait untill completion for if the latest {@link DatabasePoll} is a\n+   * {@link PeriodicDatabasePoll} that has not completed it's first poll, or an {@link OnDemandDatabasePoll} that is\n+   * alrady in the process of polling the database.", "originalCommit": "afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNjgxMQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441226811", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-17T01:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0NTI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1Nzk4Mw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441157983", "bodyText": "Could be defined as a static final.", "author": "jihoonson", "createdAt": "2020-06-16T21:40:19Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +397,131 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"forceMetadataRefresh\") final Boolean forceMetadataRefresh,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    if (forceMetadataRefresh == null) {\n+      return Response\n+          .status(Response.Status.BAD_REQUEST)\n+          .entity(\"Invalid request. forceMetadataRefresh must be specified\")\n+          .build();\n+    }\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;", "originalCommit": "afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNzA4Mg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441227082", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-17T01:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1Nzk4Mw=="}], "type": "inlineReview"}, {"oid": "fc77cc07dc22ec86e73961b582893750ca4bb8da", "url": "https://github.com/apache/druid/commit/fc77cc07dc22ec86e73961b582893750ca4bb8da", "message": "address comments", "committedDate": "2020-06-17T01:39:32Z", "type": "commit"}, {"oid": "7b64a1aeda61c183baa42bbd9961b51511e63064", "url": "https://github.com/apache/druid/commit/7b64a1aeda61c183baa42bbd9961b51511e63064", "message": "address comments", "committedDate": "2020-06-17T01:46:18Z", "type": "commit"}, {"oid": "65b60febe9e02f7ca44991aadf2fcf9fb2ab6094", "url": "https://github.com/apache/druid/commit/65b60febe9e02f7ca44991aadf2fcf9fb2ab6094", "message": "fix typo in docs", "committedDate": "2020-06-17T04:52:11Z", "type": "commit"}]}