{"pr_number": 9905, "pr_title": "Fix compact partially overlapping segments", "pr_createdAt": "2020-05-21T02:27:55Z", "pr_url": "https://github.com/apache/druid/pull/9905", "timeline": [{"oid": "052e579e75df78a65c5eb39412f65f18102895a9", "url": "https://github.com/apache/druid/commit/052e579e75df78a65c5eb39412f65f18102895a9", "message": "fix compact overlapping segments", "committedDate": "2020-05-21T01:27:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MTU4Ng==", "url": "https://github.com/apache/druid/pull/9905#discussion_r435641586", "bodyText": "Would you explain why you changed this? The intention here was to make some unit tests failed when the timeline somehow returns unsorted intervals which is supposed to be a bug.", "author": "jihoonson", "createdAt": "2020-06-05T01:26:36Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/CompactionTask.java", "diffHunk": "@@ -710,20 +728,8 @@ private static DimensionsSpec createDimensionsSpec(List<Pair<QueryableIndex, Dat\n     // Dimensions are extracted from the recent segments to olders because recent segments are likely to be queried more\n     // frequently, and thus the performance should be optimized for recent ones rather than old ones.\n \n-    // timelineSegments are sorted in order of interval, but we do a sanity check here.\n-    final Comparator<Interval> intervalComparator = Comparators.intervalsByStartThenEnd();\n-    for (int i = 0; i < queryableIndices.size() - 1; i++) {\n-      final Interval shouldBeSmaller = queryableIndices.get(i).lhs.getDataInterval();\n-      final Interval shouldBeLarger = queryableIndices.get(i + 1).lhs.getDataInterval();\n-      Preconditions.checkState(\n-          intervalComparator.compare(shouldBeSmaller, shouldBeLarger) <= 0,\n-          \"QueryableIndexes are not sorted! Interval[%s] of segment[%s] is laster than interval[%s] of segment[%s]\",\n-          shouldBeSmaller,\n-          queryableIndices.get(i).rhs.getId(),\n-          shouldBeLarger,\n-          queryableIndices.get(i + 1).rhs.getId()\n-      );\n-    }\n+    // sort timelineSegments in order of interval.\n+    queryableIndices.sort((o1, o2) -> Comparators.intervalsByStartThenEnd().compare(o1.rhs.getInterval(), o2.rhs.getInterval()));", "originalCommit": "052e579e75df78a65c5eb39412f65f18102895a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTY1MQ==", "url": "https://github.com/apache/druid/pull/9905#discussion_r435735651", "bodyText": "Hi @jihoonson\nHere I intended to fix the error in step 5 as described here.\nWhen compacting the two segments\n\ninline_data_2020-05-18T00:00:00.000Z_2020-05-19T00:00:00.000Z_version_1\ninline_data_2020-05-18T20:00:00.000Z_2020-05-18T21:00:00.000Z_version_2\n\nthere will be three timelineObjectHolders\n\n2020-05-18T00:00:00.000Z/2020-05-18T20:00:00.000Z backed by segment inline_data_2020-05-18T00:00:00.000Z_2020-05-19T00:00:00.000Z_version_1\n2020-05-18T20:00:00.000Z/2020-05-18T21:00:00.000Z backed by segment inline_data_2020-05-18T20:00:00.000Z_2020-05-18T21:00:00.000Z_version_2\n2020-05-18T21:00:00.000Z/2020-05-19T00:00:00.000Z backed by segment inline_data_2020-05-18T00:00:00.000Z_2020-05-19T00:00:00.000Z_version_1\n\nAnd the last two pairs of queryableIndices will fail to pass the previous sanity check. Also I found that now timeline already has unit tests about sorting timelineObjectHolders and the sanity check will pass in most case. So I decided to fix the error by re-sorting them anyway. And I added a link in the comment. Do it make sense?", "author": "yuanlihan", "createdAt": "2020-06-05T07:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTc5Nw==", "url": "https://github.com/apache/druid/pull/9905#discussion_r436075797", "bodyText": "@yuanlihan thanks for the explanation! What this method does is finding the most reasonable order of dimensions when input segments have mixed orders. The current algorithm is assuming that more recent segments will likely have the order what you want more (there would be some reason if you have changed the dimension order at some point). Maybe a potential improvement can be considering the segment version as well if some segment intervals are overlapped, but I think this could be done in a separate PR.\n\nAlso I found that now timeline already has unit tests about sorting timelineObjectHolders and the sanity check will pass in most case.\n\nBTW, out of curiosity, can you point me out where this test is?", "author": "jihoonson", "createdAt": "2020-06-05T17:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0OTE3NQ==", "url": "https://github.com/apache/druid/pull/9905#discussion_r436249175", "bodyText": "Hi @jihoonson\n\nBTW, out of curiosity, can you point me out where this test is?\n\nI found that the expected timelines in test cases of VersionedIntervalTimelineTest are all intentionally provided in well-ordered. Maybe I should said that there are implicit tests that cover sorting timelineObjectHolders.", "author": "yuanlihan", "createdAt": "2020-06-06T08:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MTU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MjU3MQ==", "url": "https://github.com/apache/druid/pull/9905#discussion_r435642571", "bodyText": "Could you use a more intuitive name such as numUmbrellaIntervals?", "author": "jihoonson", "createdAt": "2020-06-05T01:30:34Z", "path": "indexing-service/src/test/java/org/apache/druid/indexing/common/task/CompactionTaskTest.java", "diffHunk": "@@ -191,28 +194,33 @@ public static void setupClass()\n     MIXED_TYPE_COLUMN_MAP.put(Intervals.of(\"2017-05-01/2017-06-01\"), new DoubleDimensionSchema(MIXED_TYPE_COLUMN));\n     MIXED_TYPE_COLUMN_MAP.put(Intervals.of(\"2017-06-01/2017-07-01\"), new DoubleDimensionSchema(MIXED_TYPE_COLUMN));\n \n+    MIXED_TYPE_COLUMN_MAP.put(Intervals.of(\"2017-06-01/2017-06-02\"), new DoubleDimensionSchema(MIXED_TYPE_COLUMN));\n+    MIXED_TYPE_COLUMN_MAP.put(Intervals.of(\"2017-06-15/2017-06-16\"), new DoubleDimensionSchema(MIXED_TYPE_COLUMN));\n+    MIXED_TYPE_COLUMN_MAP.put(Intervals.of(\"2017-06-30/2017-07-01\"), new DoubleDimensionSchema(MIXED_TYPE_COLUMN));\n+\n     DIMENSIONS = new HashMap<>();\n     AGGREGATORS = new ArrayList<>();\n \n     DIMENSIONS.put(ColumnHolder.TIME_COLUMN_NAME, new LongDimensionSchema(ColumnHolder.TIME_COLUMN_NAME));\n     DIMENSIONS.put(TIMESTAMP_COLUMN, new LongDimensionSchema(TIMESTAMP_COLUMN));\n-    for (int i = 0; i < SEGMENT_INTERVALS.size(); i++) {\n+    int num = 6;", "originalCommit": "052e579e75df78a65c5eb39412f65f18102895a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNDE5Mg==", "url": "https://github.com/apache/druid/pull/9905#discussion_r435734192", "bodyText": "Naming updated", "author": "yuanlihan", "createdAt": "2020-06-05T07:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MjU3MQ=="}], "type": "inlineReview"}, {"oid": "ce51e7d25119f2f8fcbc1ea5936ff410c4e5e8d0", "url": "https://github.com/apache/druid/commit/ce51e7d25119f2f8fcbc1ea5936ff410c4e5e8d0", "message": "fix comment", "committedDate": "2020-06-05T07:10:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzQ5OA==", "url": "https://github.com/apache/druid/pull/9905#discussion_r436077498", "bodyText": "Oops, sorry I missed the CI failure.\n[ERROR] org.apache.druid.indexing.common.task.CompactionTask.createIngestionSchema(TaskToolbox, CompactionTask$SegmentProvider, CompactionTask$PartitionConfigurationManager, DimensionsSpec, AggregatorFactory[], Granularity, ObjectMapper, CoordinatorClient, SegmentLoaderFactory, RetryPolicyFactory) makes inefficient use of keySet iterator instead of entrySet iterator [org.apache.druid.indexing.common.task.CompactionTask] At CompactionTask.java:[line 531] WMI_WRONG_MAP_ITERATOR\n\nThis means you are calling HashMap.get() even though you can iterate the Entry set. Would you fix this please?", "author": "jihoonson", "createdAt": "2020-06-05T17:58:57Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/CompactionTask.java", "diffHunk": "@@ -524,10 +524,28 @@ private String createIndexTaskSpecId(int i)\n                                  .add(p)\n       );\n \n-      final List<ParallelIndexIngestionSpec> specs = new ArrayList<>(intervalToSegments.size());\n-      for (Entry<Interval, List<Pair<QueryableIndex, DataSegment>>> entry : intervalToSegments.entrySet()) {\n-        final Interval interval = entry.getKey();\n-        final List<Pair<QueryableIndex, DataSegment>> segmentsToCompact = entry.getValue();\n+      // unify overlapping intervals to ensure overlapping segments compacting in the same indexSpec\n+      List<Pair<Interval, List<Pair<QueryableIndex, DataSegment>>>> intervalToSegmentsUnified = new ArrayList<>();\n+      Iterator<Interval> iterator = intervalToSegments.keySet().iterator();\n+      Interval union = iterator.next();\n+      List<Pair<QueryableIndex, DataSegment>> segments = new ArrayList<>(intervalToSegments.get(union));", "originalCommit": "ce51e7d25119f2f8fcbc1ea5936ff410c4e5e8d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0OTQ1MQ==", "url": "https://github.com/apache/druid/pull/9905#discussion_r436249451", "bodyText": "fixed CI failure.", "author": "yuanlihan", "createdAt": "2020-06-06T08:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzQ5OA=="}], "type": "inlineReview"}, {"oid": "0b1aa6444b1920ca3995b1bc019326b695562ed4", "url": "https://github.com/apache/druid/commit/0b1aa6444b1920ca3995b1bc019326b695562ed4", "message": "fix CI failure", "committedDate": "2020-06-06T08:05:15Z", "type": "commit"}]}