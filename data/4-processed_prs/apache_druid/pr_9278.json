{"pr_number": 9278, "pr_title": "Speed up joins on indexed tables with string keys", "pr_createdAt": "2020-01-29T00:23:29Z", "pr_url": "https://github.com/apache/druid/pull/9278", "timeline": [{"oid": "2287bed236973da368c636e8b54c349b3eb89aba", "url": "https://github.com/apache/druid/commit/2287bed236973da368c636e8b54c349b3eb89aba", "message": "Speed up joins on indexed tables with string keys\n\nWhen joining on index tables with string keys, caching the computation\nof row id to row numbers improves performance on the\nJoinAndLookupBenchmark.joinIndexTableStringKey* benchmarks by about 10%\nif the column cache is enabled an by about 100% if the column cache is\ndisabled.", "committedDate": "2020-01-29T00:13:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE3OTk1Mg==", "url": "https://github.com/apache/druid/pull/9278#discussion_r372179952", "bodyText": "This is only safe when the selector has a 'real' dictionary, i.e. when selector.getValueCardinality() does not return DimensionSelector.CARDINALITY_UNKNOWN. If it is unknown then the ids are not valid outside the context of a specific row. So, in that case you'll need to fall back to the slower code.", "author": "gianm", "createdAt": "2020-01-29T04:08:03Z", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -262,8 +288,9 @@ public ValueType defaultType()\n         final IndexedInts row = selector.getRow();\n \n         if (row.size() == 1) {\n-          final String key = selector.lookupName(row.get(0));\n-          return index.find(key).iterator();\n+          int dimensionId = row.get(0);\n+          //noinspection ConstantConditions (cache cannot return nulls since nulls are never stored in cache)\n+          return dimensionCaches.get(selector).get(dimensionId).iterator();", "originalCommit": "2287bed236973da368c636e8b54c349b3eb89aba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDIwNg==", "url": "https://github.com/apache/druid/pull/9278#discussion_r372180206", "bodyText": "For each selector, dimensionIds are contiguous and go from 0 (inclusive) to selector.getValueCardinality() (exclusive). If the cardinality is less than CACHE_MAX_SIZE then you could use an IntList[] as a cache. It should be faster.", "author": "gianm", "createdAt": "2020-01-29T04:09:39Z", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -240,13 +243,36 @@ private void advanceCurrentRow()\n    */\n   private static class ConditionMatcherFactory implements ColumnProcessorFactory<Supplier<IntIterator>>\n   {\n+    private static final int MAX_NUM_CACHE = 10;\n+    private static final int CACHE_MAX_SIZE = 1000;\n+\n     private final ValueType keyType;\n     private final IndexedTable.Index index;\n \n+    // DimensionSelector -> (int) dimension id -> (IntList) row numbers\n+    private final LoadingCache<DimensionSelector, LoadingCache<Integer, IntList>> dimensionCaches;\n+\n     ConditionMatcherFactory(ValueType keyType, IndexedTable.Index index)\n     {\n       this.keyType = keyType;\n       this.index = index;\n+\n+      this.dimensionCaches =\n+          Caffeine.newBuilder()\n+                  .maximumSize(MAX_NUM_CACHE)\n+                  .build(\n+                      selector ->\n+                          Caffeine.newBuilder()\n+                                  .maximumSize(CACHE_MAX_SIZE)\n+                                  .build(dimensionId -> getRowNumbers(selector, dimensionId))\n+                  );\n+\n+    }\n+\n+    private IntList getRowNumbers(DimensionSelector selector, int dimensionId)\n+    {\n+      final String key = selector.lookupName(dimensionId);", "originalCommit": "2287bed236973da368c636e8b54c349b3eb89aba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwMTAyMw==", "url": "https://github.com/apache/druid/pull/9278#discussion_r372601023", "bodyText": "(Assuming the dictionary is real, i.e., selector.getValueCardinality() != DimensionSelector.CARDINALITY_UNKNOWN)", "author": "gianm", "createdAt": "2020-01-29T20:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDQxNw==", "url": "https://github.com/apache/druid/pull/9278#discussion_r372180417", "bodyText": "How does this compare to the LruEvalCache in SingleStringInputCachingExpressionColumnValueSelector? I think they're trying to solve the same problem, so whichever approach works better, both that class and this one should use the best approach.", "author": "gianm", "createdAt": "2020-01-29T04:11:03Z", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -240,13 +243,36 @@ private void advanceCurrentRow()\n    */\n   private static class ConditionMatcherFactory implements ColumnProcessorFactory<Supplier<IntIterator>>\n   {\n+    private static final int MAX_NUM_CACHE = 10;\n+    private static final int CACHE_MAX_SIZE = 1000;\n+\n     private final ValueType keyType;\n     private final IndexedTable.Index index;\n \n+    // DimensionSelector -> (int) dimension id -> (IntList) row numbers\n+    private final LoadingCache<DimensionSelector, LoadingCache<Integer, IntList>> dimensionCaches;\n+\n     ConditionMatcherFactory(ValueType keyType, IndexedTable.Index index)\n     {\n       this.keyType = keyType;\n       this.index = index;\n+\n+      this.dimensionCaches =\n+          Caffeine.newBuilder()\n+                  .maximumSize(MAX_NUM_CACHE)\n+                  .build(\n+                      selector ->\n+                          Caffeine.newBuilder()", "originalCommit": "2287bed236973da368c636e8b54c349b3eb89aba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc1MTEzNg==", "url": "https://github.com/apache/druid/pull/9278#discussion_r373751136", "bodyText": "On JoinAndLookupBenchmark.joinIndexedTableStringKey, using the LruEvalCache approach is about 10% faster than using Caffeine.", "author": "ccaominh", "createdAt": "2020-02-01T02:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDQxNw=="}], "type": "inlineReview"}, {"oid": "fc460d3ac96fbc858c5c29e82c5c08f5c4a4ccfa", "url": "https://github.com/apache/druid/commit/fc460d3ac96fbc858c5c29e82c5c08f5c4a4ccfa", "message": "Merge remote-tracking branch 'upstream/master' into joins-index-table-join-matcher-cache", "committedDate": "2020-01-30T01:07:20Z", "type": "commit"}, {"oid": "6fd4707397dd92dc5d4161dc462e14f6b5d9230f", "url": "https://github.com/apache/druid/commit/6fd4707397dd92dc5d4161dc462e14f6b5d9230f", "message": "Faster cache impl and handle unknown cardinality", "committedDate": "2020-02-01T02:14:41Z", "type": "commit"}, {"oid": "2a4bc32e2c460693410f53326c5f6e410302ff0b", "url": "https://github.com/apache/druid/commit/2a4bc32e2c460693410f53326c5f6e410302ff0b", "message": "Merge remote-tracking branch 'upstream/master' into joins-index-table-join-matcher-cache", "committedDate": "2020-02-01T02:24:39Z", "type": "commit"}, {"oid": "6d5b18aa52cbd8437c267800eb2901aa5ac6530e", "url": "https://github.com/apache/druid/commit/6d5b18aa52cbd8437c267800eb2901aa5ac6530e", "message": "Remove unused dependency", "committedDate": "2020-02-01T17:53:15Z", "type": "commit"}, {"oid": "bb951d204fb01fa416f0644f696463f32cc8263e", "url": "https://github.com/apache/druid/commit/bb951d204fb01fa416f0644f696463f32cc8263e", "message": "Merge remote-tracking branch 'upstream/master' into joins-index-table-join-matcher-cache", "committedDate": "2020-02-01T17:53:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwOTgyNg==", "url": "https://github.com/apache/druid/pull/9278#discussion_r374409826", "bodyText": "This won't change from row to row, so it's likely going to be better to check it outside hot code (i.e. return a different Supplier<IntIterator> based on the result of calling selector.getValueCardinality()).", "author": "gianm", "createdAt": "2020-02-04T00:01:34Z", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -263,8 +299,17 @@ public ValueType defaultType()\n         final IndexedInts row = selector.getRow();\n \n         if (row.size() == 1) {\n-          final String key = selector.lookupName(row.get(0));\n-          return index.find(key).iterator();\n+          int dimensionId = row.get(0);\n+          final IntList rowNumbers;\n+          if (selector.getValueCardinality() == DimensionDictionarySelector.CARDINALITY_UNKNOWN) {", "originalCommit": "bb951d204fb01fa416f0644f696463f32cc8263e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMTAxMw==", "url": "https://github.com/apache/druid/pull/9278#discussion_r374411013", "bodyText": "I thought Java guaranteed that object arrays will start with all nulls.", "author": "gianm", "createdAt": "2020-02-04T00:05:42Z", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -308,4 +353,112 @@ public ValueType defaultType()\n       return () -> IntIterators.EMPTY_ITERATOR;\n     }\n   }\n+\n+  @VisibleForTesting\n+  static class LruLoadingHashMap<K, V> extends LinkedHashMap<K, V>\n+  {\n+    private final int maxSize;\n+    private final Function<K, V> loader;\n+\n+    LruLoadingHashMap(int maxSize, Function<K, V> loader)\n+    {\n+      super(capacity(maxSize));\n+      this.maxSize = maxSize;\n+      this.loader = loader;\n+    }\n+\n+    V getAndLoadIfAbsent(K key)\n+    {\n+      return computeIfAbsent(key, loader);\n+    }\n+\n+    @Override\n+    protected boolean removeEldestEntry(Map.Entry eldest)\n+    {\n+      return size() > maxSize;\n+    }\n+\n+    private static int capacity(int expectedSize)\n+    {\n+      // This is the calculation used in JDK8 to resize when a putAll happens; it seems to be the most conservative\n+      // calculation we can make. 0.75 is the default load factor.\n+      return (int) ((float) expectedSize / 0.75F + 1.0F);\n+    }\n+  }\n+\n+  private interface Int2IntListMap\n+  {\n+    IntList getAndLoadIfAbsent(int key);\n+  }\n+\n+  /**\n+   * Lookup table for keys in the range from 0 to maxSize - 1\n+   */\n+  @VisibleForTesting\n+  static class Int2IntListLookupTable implements Int2IntListMap\n+  {\n+    private final IntList[] lookup;\n+    private final IntFunction<IntList> loader;\n+\n+    Int2IntListLookupTable(int maxSize, IntFunction<IntList> loader)\n+    {\n+      this.loader = loader;\n+      this.lookup = new IntList[maxSize];\n+      Arrays.fill(lookup, null);", "originalCommit": "bb951d204fb01fa416f0644f696463f32cc8263e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5b8955eb00d1feda09432156c7bd3b7271c904a3", "url": "https://github.com/apache/druid/commit/5b8955eb00d1feda09432156c7bd3b7271c904a3", "message": "Hoist cardinality check outside of hot loop", "committedDate": "2020-02-04T21:45:40Z", "type": "commit"}, {"oid": "71eab4d59c89a3d5c1af16dd58da3b5887caefca", "url": "https://github.com/apache/druid/commit/71eab4d59c89a3d5c1af16dd58da3b5887caefca", "message": "Merge remote-tracking branch 'upstream/master' into joins-index-table-join-matcher-cache", "committedDate": "2020-02-04T21:46:26Z", "type": "commit"}, {"oid": "18e9bf5d14fbacebc6d5d4e12c6667a02fb1162b", "url": "https://github.com/apache/druid/commit/18e9bf5d14fbacebc6d5d4e12c6667a02fb1162b", "message": "Fix dummy DimensionSelector for tests", "committedDate": "2020-02-04T23:28:59Z", "type": "commit"}]}