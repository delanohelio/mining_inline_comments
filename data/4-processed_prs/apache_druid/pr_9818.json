{"pr_number": 9818, "pr_title": "Directly rewrite filters on RHS join columns into LHS equivalents", "pr_createdAt": "2020-05-04T04:36:03Z", "pr_url": "https://github.com/apache/druid/pull/9818", "timeline": [{"oid": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "url": "https://github.com/apache/druid/commit/937f268f4d64aa561caab00fbe7aca1eac0bcecc", "message": "Directly rewrite filters on RHS join columns into LHS equivalents", "committedDate": "2020-05-04T04:30:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MjIxNw==", "url": "https://github.com/apache/druid/pull/9818#discussion_r419752217", "bodyText": "Missing in equals()\nCan you add an EqualsVerifierTest for this please", "author": "suneet-s", "createdAt": "2020-05-04T21:54:25Z", "path": "processing/src/main/java/org/apache/druid/query/filter/ExpressionDimFilter.java", "diffHunk": "@@ -44,6 +45,9 @@\n   @Nullable\n   private final FilterTuning filterTuning;\n \n+  @JsonIgnore\n+  private final ExprMacroTable macroTable;", "originalCommit": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2MDgwOA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r420460808", "bodyText": "The ExprMacroTable is not really a property of the filter itself, it's an injected reference to a global scoped macro definition table.\nIt's similarly excluded in aggregator spec equals() (e.g. DoubleSumAggregatorFactory)", "author": "jon-wei", "createdAt": "2020-05-05T23:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MjIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5OTkwNg==", "url": "https://github.com/apache/druid/pull/9818#discussion_r420499906", "bodyText": "Actually this change is unnecessary (I made it while trying out ExpressionFilter rewrites which i later decided wouldn't be supported initially), I reverted this area", "author": "jon-wei", "createdAt": "2020-05-06T01:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MjIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MjU1OA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r419752558", "bodyText": "Missing EqualsVerifierTest for this LikeDimFilter.\nThanks for this adding an equals test for LikeMatcher \ud83d\udc4d", "author": "suneet-s", "createdAt": "2020-05-04T21:55:08Z", "path": "processing/src/main/java/org/apache/druid/query/filter/LikeDimFilter.java", "diffHunk": "@@ -363,5 +363,26 @@ public SuffixMatch getSuffixMatch()\n     {\n       return suffixMatch;\n     }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      LikeMatcher that = (LikeMatcher) o;\n+      return getSuffixMatch() == that.getSuffixMatch() &&\n+             Objects.equals(getPrefix(), that.getPrefix()) &&\n+             Objects.equals(pattern.toString(), that.pattern.toString());\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+      return Objects.hash(getSuffixMatch(), getPrefix(), pattern.toString());\n+    }", "originalCommit": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NTIxOA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r420465218", "bodyText": "Hm, it doesn't look like we have EqualsVerifierTest for any of the DimFilter implementations; since this patch is only adding equals implementations for Filter classes, I think that should be done in a separate PR", "author": "jon-wei", "createdAt": "2020-05-05T23:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MjU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MzUzMw==", "url": "https://github.com/apache/druid/pull/9818#discussion_r419753533", "bodyText": "Why can't a like dim filter be re-written?", "author": "suneet-s", "createdAt": "2020-05-04T21:57:18Z", "path": "processing/src/main/java/org/apache/druid/query/filter/LikeDimFilter.java", "diffHunk": "@@ -363,5 +363,26 @@ public SuffixMatch getSuffixMatch()\n     {\n       return suffixMatch;\n     }\n+", "originalCommit": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2MjU5Ng==", "url": "https://github.com/apache/druid/pull/9818#discussion_r420462596", "bodyText": "Like filters can, the new interface is on Filter, not DimFilter", "author": "jon-wei", "createdAt": "2020-05-05T23:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1MzUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NDcxNA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r419754714", "bodyText": "I think we should add a test that looks for all implementations of Filter and then validate whatsupportsRequiredColumnRewrite() returns.\nSince the default is false, we should be explicit in the list of filters that we say do not support re-writes. This way, if someone adds a filter in the future, this test will fail and force the dev to think about what the correct implementation should be.", "author": "suneet-s", "createdAt": "2020-05-04T21:59:48Z", "path": "processing/src/main/java/org/apache/druid/query/filter/Filter.java", "diffHunk": "@@ -162,4 +163,29 @@ default boolean canVectorizeMatcher()\n    * can be expected to have a bitmap index retrievable via {@link BitmapIndexSelector#getBitmapIndex(String)}\n    */\n   Set<String> getRequiredColumns();\n+\n+  /**\n+   * Returns true is this filter is able to return a copy of this filter that is identical to this filter except that it\n+   * operates on different columns, based on a renaming map.\n+   */\n+  default boolean supportsRequiredColumnRewrite()", "originalCommit": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODcyMg==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422428722", "bodyText": "Would you elaborate more details of the test you think? I'm not sure how it could help. Since the default returns false, the new filter overrode this method to return true if it had to be. The author should be able to think what it means when it is overridden. If you mean new filters need a design review, that should be done during the design phase rather than testing phase.", "author": "jihoonson", "createdAt": "2020-05-09T00:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MjA5Mg==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422442092", "bodyText": "I think that can be difficult for the author and the reviewer. There are many functions in an interface, and most editors will pull in methods that don't have a definition unless you explicitly tell them to. As a reviewer, nothing is warning me that the implementation/ design did not consider implementing this function.\nI have a WIP change that does something similar to validate that the equals and hashCode implementations are not using the implementation provided by Object I suspect we'd want something very similar, except with the ability to provide exceptions. https://github.com/suneet-s/druid/blob/b8bc17551361b20458b073c62b5fe8f5d6a85183/processing/src/test/java/org/apache/druid/query/filter/FilterTest.java#L33\nThis way, the dev has to add the exception as part of the PR for the tests to pass, and the reviewer can see that an exception was added and ask themselves if that exception makes sense.", "author": "suneet-s", "createdAt": "2020-05-09T02:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjMyOQ==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422452329", "bodyText": "Oh thanks, I see what you are saying. But do we need that kind of tests? If I understand correctly, this interface is for temporarily marking what filters support the rewrite for now since some of filters don't implement it. This interface will be eventually removed in the future. I don't see any reason to not support the rewrite for some particular filter types.", "author": "jihoonson", "createdAt": "2020-05-09T04:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NDcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NjEzOQ==", "url": "https://github.com/apache/druid/pull/9818#discussion_r419756139", "bodyText": "note to self: re-think the interface here. Does this need to be de-coupled from the function above? Does this introduce more chances of developer error that's only detected at runtime? Is there a pattern that guarantees that this is only called if supportsRequiredColumnRewrite is  true?", "author": "suneet-s", "createdAt": "2020-05-04T22:03:17Z", "path": "processing/src/main/java/org/apache/druid/query/filter/Filter.java", "diffHunk": "@@ -162,4 +163,29 @@ default boolean canVectorizeMatcher()\n    * can be expected to have a bitmap index retrievable via {@link BitmapIndexSelector#getBitmapIndex(String)}\n    */\n   Set<String> getRequiredColumns();\n+\n+  /**\n+   * Returns true is this filter is able to return a copy of this filter that is identical to this filter except that it\n+   * operates on different columns, based on a renaming map.\n+   */\n+  default boolean supportsRequiredColumnRewrite()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Return a copy of this filter that is identical to the this filter except that it operates on different columns,\n+   * based on a renaming map where the key is the column to be renamed in the filter, and the value is the new\n+   * column name.\n+   *\n+   * For example, if I have a filter (A = hello), and I have a renaming map (A -> B),\n+   * this should return the filter (B = hello)\n+   *\n+   * @param columnRewrites Column rewrite map\n+   * @return Copy of this filter that operates on new columns based on the rewrite map\n+   */\n+  default Filter rewriteRequiredColumns(Map<String, String> columnRewrites)\n+  {\n+    throw new UnsupportedOperationException(\"Required column rewrite is not supported by this filter.\");", "originalCommit": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyODczMg==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422428732", "bodyText": "Good question. A potential alternative could be having just this interface and its default implementation returns this. I haven't thought enough to say what is better yet.", "author": "jihoonson", "createdAt": "2020-05-09T00:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NjEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NzIxNA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r419757214", "bodyText": "note to self: What is the overhead of creating a new object for the filter?", "author": "suneet-s", "createdAt": "2020-05-04T22:05:47Z", "path": "processing/src/main/java/org/apache/druid/segment/filter/BoundFilter.java", "diffHunk": "@@ -172,6 +174,37 @@ public boolean supportsSelectivityEstimation(ColumnSelector columnSelector, Bitm\n     return boundDimFilter.getRequiredColumns();\n   }\n \n+  @Override\n+  public boolean supportsRequiredColumnRewrite()\n+  {\n+    return true;\n+  }\n+\n+  @Override\n+  public Filter rewriteRequiredColumns(Map<String, String> columnRewrites)\n+  {\n+    if (columnRewrites.get(boundDimFilter.getDimension()) == null) {\n+      throw new IAE(\n+          \"Received a non-applicable rewrite: %s, filter's dimension: %s\",\n+          columnRewrites,\n+          boundDimFilter.getDimension()\n+      );\n+    }\n+    BoundDimFilter newDimFilter = new BoundDimFilter(\n+        columnRewrites.get(boundDimFilter.getDimension()),\n+        boundDimFilter.getLower(),\n+        boundDimFilter.getUpper(),\n+        boundDimFilter.isLowerStrict(),\n+        boundDimFilter.isUpperStrict(),\n+        null,\n+        boundDimFilter.getExtractionFn(),\n+        boundDimFilter.getOrdering()\n+    );\n+    return new BoundFilter(", "originalCommit": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg3MjM4Mg==", "url": "https://github.com/apache/druid/pull/9818#discussion_r419872382", "bodyText": "Dead code", "author": "suneet-s", "createdAt": "2020-05-05T05:33:55Z", "path": "processing/src/main/java/org/apache/druid/segment/join/filter/JoinFilterAnalyzer.java", "diffHunk": "@@ -387,87 +428,197 @@ private static JoinFilterAnalysis analyzeJoinFilterClause(\n       return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n     }\n \n+    if (filterClause instanceof OrFilter) {\n+      return rewriteOrFilter(\n+          (OrFilter) filterClause,\n+          joinFilterPreAnalysis,\n+          pushDownVirtualColumnsForLhsExprs\n+      );\n+    }\n+\n+    if (doesRequiredColumnSetSupportDirectJoinFilterRewrite(\n+        filterClause.getRequiredColumns(),\n+        joinFilterPreAnalysis.getEquiconditions()\n+    )) {\n+      return rewriteFilterDirect(\n+          filterClause,\n+          joinFilterPreAnalysis,\n+          pushDownVirtualColumnsForLhsExprs\n+      );\n+    }\n+\n     // Currently we only support rewrites of selector filters and selector filters within OR filters.\n     if (filterClause instanceof SelectorFilter) {\n       return rewriteSelectorFilter(\n           (SelectorFilter) filterClause,\n-          joinFilterPreAnalysis\n+          joinFilterPreAnalysis,\n+          pushDownVirtualColumnsForLhsExprs\n       );\n     }\n \n-    if (filterClause instanceof OrFilter) {\n-      return rewriteOrFilter(\n-          (OrFilter) filterClause,\n-          joinFilterPreAnalysis\n+    return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n+  }\n+\n+  private static JoinFilterAnalysis rewriteFilterDirect(\n+      Filter filterClause,\n+      JoinFilterPreAnalysis joinFilterPreAnalysis,\n+      Map<Expr, VirtualColumn> pushDownVirtualColumnsForLhsExprs\n+  )\n+  {\n+    if (!filterClause.supportsRequiredColumnRewrite()) {\n+      return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n+    }\n+\n+    List<Filter> newFilters = new ArrayList<>();\n+    /*\n+    if (areSomeColumnsFromPostJoinVirtualColumns(\n+        joinFilterPreAnalysis.getPostJoinVirtualColumns(),\n+        filterClause.getRequiredColumns()\n+    )) {\n+      return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n+    }\n+    */\n+\n+    /*\n+    if (!areSomeColumnsFromJoin(joinFilterPreAnalysis.getJoinableClauses(), filterClause.getRequiredColumns())) {\n+      return new JoinFilterAnalysis(\n+          false,\n+          filterClause,\n+          filterClause,\n+          pushdownVirtualColumns\n       );\n     }\n+    */", "originalCommit": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxNDkzOA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r420214938", "bodyText": "get() without isPresent() check", "author": "suneet-s", "createdAt": "2020-05-05T15:50:05Z", "path": "processing/src/main/java/org/apache/druid/segment/join/filter/JoinFilterAnalyzer.java", "diffHunk": "@@ -265,6 +286,10 @@ public static JoinFilterPreAnalysis computeJoinFilterPreAnalysis(\n                   (rhsCol) -> Optional.of(new ArrayList<>())\n               );\n           perColumnCorrelations.get().add(correlationForPrefix.getValue());", "originalCommit": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMTcyOQ==", "url": "https://github.com/apache/druid/pull/9818#discussion_r420501729", "bodyText": "I added an assert for perColumnCorrelations.isPresent() here, it should never be empty in that block (for it to have been empty, if (correlationsForPrefix.isPresent()) { must have been false, and this block ensures it's not empty in the computeIfAbsent call)\nI think this area of the code is hard to follow right now, it would be an area to be refactored.", "author": "jon-wei", "createdAt": "2020-05-06T01:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxNDkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzNDg3NQ==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422434875", "bodyText": "I'm curious why the value type is Optional vs just treating nulls as missing keys. Are Optional.absent() and null values (missing keys) treated in different ways?", "author": "jihoonson", "createdAt": "2020-05-09T01:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxNDkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxODQyOA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r420218428", "bodyText": "Shouldn't we need to do this?\nWhat if the filter could not be re-written directly (eg. an expression filter, or there were multiple columns in a filter)", "author": "suneet-s", "createdAt": "2020-05-05T15:54:51Z", "path": "processing/src/main/java/org/apache/druid/segment/join/filter/JoinFilterAnalyzer.java", "diffHunk": "@@ -265,6 +286,10 @@ public static JoinFilterPreAnalysis computeJoinFilterPreAnalysis(\n                   (rhsCol) -> Optional.of(new ArrayList<>())\n               );\n           perColumnCorrelations.get().add(correlationForPrefix.getValue());\n+          if (rhsRewriteCandidate.isJoinColumn()) {\n+            // we don't need to determine correlated values if the filter is on the join column", "originalCommit": "937f268f4d64aa561caab00fbe7aca1eac0bcecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUwMzE4OA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r420503188", "bodyText": "Hm, I think that isJoinColumn  property is more correctly called isDirectRewrite, I renamed that.\nIt's not necessary since if the direct rewrite couldn't happen, then it should fall through to the blocks in computeJoinFilterPreAnalysis and  analyzeJoinFilterClause which handle indirect rewrites, and it would be handled in that way.\nThere was a bug that would cause this to not fall through because of missing supportsRequiredColumnRewrite checks, I've fixed that and added a filter to JoinFilterAnalyzerTest.test_filterPushDown_factToRegionToCountryLeftFilterOnRHSJoinConditionColumnsHelper which overrides supportsRequiredColumnRewrite on a SelectorFilter to demonstrate this.", "author": "jon-wei", "createdAt": "2020-05-06T01:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxODQyOA=="}], "type": "inlineReview"}, {"oid": "c24e612bf7591230508fce8e224657b012dc0613", "url": "https://github.com/apache/druid/commit/c24e612bf7591230508fce8e224657b012dc0613", "message": "PR comments", "committedDate": "2020-05-06T01:23:00Z", "type": "commit"}, {"oid": "64bfecb00bd472e2269042fe8976ddcde7a40eae", "url": "https://github.com/apache/druid/commit/64bfecb00bd472e2269042fe8976ddcde7a40eae", "message": "Fix inspection", "committedDate": "2020-05-06T01:26:19Z", "type": "commit"}, {"oid": "d82c4f93e7a7adf918c9ac31c9e5d3f1284eeaf8", "url": "https://github.com/apache/druid/commit/d82c4f93e7a7adf918c9ac31c9e5d3f1284eeaf8", "message": "Revert unnecessary ExprMacroTable change", "committedDate": "2020-05-06T01:27:55Z", "type": "commit"}, {"oid": "c312e05c05238ab9c84b80713f8006ffd71050a4", "url": "https://github.com/apache/druid/commit/c312e05c05238ab9c84b80713f8006ffd71050a4", "message": "Merge remote-tracking branch 'upstream/master' into optimize_join_filter", "committedDate": "2020-05-09T01:37:53Z", "type": "commit"}, {"oid": "cce3497a9785bd4e65f926d03941f85a0a44124b", "url": "https://github.com/apache/druid/commit/cce3497a9785bd4e65f926d03941f85a0a44124b", "message": "Fix build after merge", "committedDate": "2020-05-09T01:52:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTU3Mg==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422429572", "bodyText": "Does this interface take a map for future expansion even though all callers pass a map containing only one pair of key and value?", "author": "jihoonson", "createdAt": "2020-05-09T00:26:55Z", "path": "processing/src/main/java/org/apache/druid/query/filter/Filter.java", "diffHunk": "@@ -162,4 +163,29 @@ default boolean canVectorizeMatcher()\n    * can be expected to have a bitmap index retrievable via {@link BitmapIndexSelector#getBitmapIndex(String)}\n    */\n   Set<String> getRequiredColumns();\n+\n+  /**\n+   * Returns true is this filter is able to return a copy of this filter that is identical to this filter except that it\n+   * operates on different columns, based on a renaming map.\n+   */\n+  default boolean supportsRequiredColumnRewrite()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Return a copy of this filter that is identical to the this filter except that it operates on different columns,\n+   * based on a renaming map where the key is the column to be renamed in the filter, and the value is the new\n+   * column name.\n+   *\n+   * For example, if I have a filter (A = hello), and I have a renaming map (A -> B),\n+   * this should return the filter (B = hello)\n+   *\n+   * @param columnRewrites Column rewrite map\n+   * @return Copy of this filter that operates on new columns based on the rewrite map\n+   */\n+  default Filter rewriteRequiredColumns(Map<String, String> columnRewrites)", "originalCommit": "d82c4f93e7a7adf918c9ac31c9e5d3f1284eeaf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTg3NA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422451874", "bodyText": "Yes, that was the intent", "author": "jon-wei", "createdAt": "2020-05-09T04:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyOTU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDgxOA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422430818", "bodyText": "nit: columnRewrites.get(dimension) can be cached as a local variable above. Same for other filters.", "author": "jihoonson", "createdAt": "2020-05-09T00:33:43Z", "path": "processing/src/main/java/org/apache/druid/segment/filter/InFilter.java", "diffHunk": "@@ -179,6 +181,30 @@ public boolean canVectorizeMatcher()\n     return ImmutableSet.of(dimension);\n   }\n \n+  @Override\n+  public boolean supportsRequiredColumnRewrite()\n+  {\n+    return true;\n+  }\n+\n+  @Override\n+  public Filter rewriteRequiredColumns(Map<String, String> columnRewrites)\n+  {\n+    if (columnRewrites.get(dimension) == null) {\n+      throw new IAE(\"Received a non-applicable rewrite: %s, filter's dimension: %s\", columnRewrites, dimension);\n+    }\n+\n+    return new InFilter(\n+        columnRewrites.get(dimension),", "originalCommit": "d82c4f93e7a7adf918c9ac31c9e5d3f1284eeaf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzY2MQ==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422453661", "bodyText": "Cached the local variables in these areas", "author": "jon-wei", "createdAt": "2020-05-09T05:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMDgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMjM5Ng==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422432396", "bodyText": "Can use Collections.emptyMap().", "author": "jihoonson", "createdAt": "2020-05-09T00:42:59Z", "path": "processing/src/main/java/org/apache/druid/segment/join/filter/JoinFilterAnalyzer.java", "diffHunk": "@@ -125,7 +126,8 @@ public static JoinFilterPreAnalysis computeJoinFilterPreAnalysis(\n           null,\n           null,\n           enableFilterPushDown,\n-          enableFilterRewrite\n+          enableFilterRewrite,\n+          new HashMap<>()", "originalCommit": "d82c4f93e7a7adf918c9ac31c9e5d3f1284eeaf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzY2OQ==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422453669", "bodyText": "Updated to suggested", "author": "jon-wei", "createdAt": "2020-05-09T05:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMjQwMg==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422432402", "bodyText": "Can use Collections.emptyMap().", "author": "jihoonson", "createdAt": "2020-05-09T00:43:03Z", "path": "processing/src/main/java/org/apache/druid/segment/join/filter/JoinFilterAnalyzer.java", "diffHunk": "@@ -166,7 +168,8 @@ public static JoinFilterPreAnalysis computeJoinFilterPreAnalysis(\n           normalizedJoinTableClauses,\n           null,\n           enableFilterPushDown,\n-          enableFilterRewrite\n+          enableFilterRewrite,\n+          new HashMap<>()", "originalCommit": "d82c4f93e7a7adf918c9ac31c9e5d3f1284eeaf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzY3Mw==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422453673", "bodyText": "Updated to suggested", "author": "jon-wei", "createdAt": "2020-05-09T05:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMjQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMzI0NA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422433244", "bodyText": "Would add some description about what \"direct rewrite\" means?", "author": "jihoonson", "createdAt": "2020-05-09T00:49:13Z", "path": "processing/src/main/java/org/apache/druid/segment/join/filter/JoinFilterAnalyzer.java", "diffHunk": "@@ -862,5 +1006,10 @@ public String getValueForRewrite()\n     {\n       return valueForRewrite;\n     }\n+\n+    public boolean isDirectRewrite()", "originalCommit": "d82c4f93e7a7adf918c9ac31c9e5d3f1284eeaf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzY4MQ==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422453681", "bodyText": "Added a javadoc", "author": "jon-wei", "createdAt": "2020-05-09T05:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMzMyNQ==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422433325", "bodyText": "The new parameter is missing in the Javadoc.", "author": "jihoonson", "createdAt": "2020-05-09T00:49:46Z", "path": "processing/src/main/java/org/apache/druid/segment/join/filter/JoinFilterAnalyzer.java", "diffHunk": "@@ -370,14 +412,15 @@ public static JoinFilterSplit splitFilter(\n    * Analyze a filter clause from a filter that is in conjunctive normal form (AND of ORs).\n    * The clause is expected to be an OR filter or a leaf filter.\n    *\n-   * @param filterClause     Individual filter clause (an OR filter or a leaf filter) from a filter that is in CNF\n+   * @param filterClause          Individual filter clause (an OR filter or a leaf filter) from a filter that is in CNF\n    * @param joinFilterPreAnalysis The pre-analysis computed by {@link #computeJoinFilterPreAnalysis)}\n    *\n    * @return a JoinFilterAnalysis that contains a possible filter rewrite and information on how to handle the filter.\n    */\n   private static JoinFilterAnalysis analyzeJoinFilterClause(\n       Filter filterClause,\n-      JoinFilterPreAnalysis joinFilterPreAnalysis\n+      JoinFilterPreAnalysis joinFilterPreAnalysis,\n+      Map<Expr, VirtualColumn> pushDownVirtualColumnsForLhsExprs", "originalCommit": "d82c4f93e7a7adf918c9ac31c9e5d3f1284eeaf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzY4Nw==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422453687", "bodyText": "Added new parameter to javadoc", "author": "jon-wei", "createdAt": "2020-05-09T05:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NTAxOQ==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422455019", "bodyText": "Thanks. This javadoc is really helpful.", "author": "jihoonson", "createdAt": "2020-05-09T05:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MzA3Ng==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422443076", "bodyText": "Hmm, I'm not sure exactly what is wrong, but it seems there is something missing. When I modified the join condition in this test to \"\\\"%sregionIsoCode\\\" == regionIsoCode && \\\"%scountryIsoCode\\\" == regionIsoCode && \\\"%sregionName\\\" == user\", this block did strange rewrites such as r1.regionIsoCode = AAAA -> user = AAAA or r1.regionName = Fourems Province -> regionIsoCode = Fourems Province.", "author": "jihoonson", "createdAt": "2020-05-09T02:28:18Z", "path": "processing/src/main/java/org/apache/druid/segment/join/filter/JoinFilterAnalyzer.java", "diffHunk": "@@ -387,87 +430,178 @@ private static JoinFilterAnalysis analyzeJoinFilterClause(\n       return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n     }\n \n+    if (filterClause instanceof OrFilter) {\n+      return rewriteOrFilter(\n+          (OrFilter) filterClause,\n+          joinFilterPreAnalysis,\n+          pushDownVirtualColumnsForLhsExprs\n+      );\n+    }\n+\n+    if (filterClause.supportsRequiredColumnRewrite() && doesRequiredColumnSetSupportDirectJoinFilterRewrite(\n+        filterClause.getRequiredColumns(),\n+        joinFilterPreAnalysis.getEquiconditions()\n+    )) {\n+      return rewriteFilterDirect(\n+          filterClause,\n+          joinFilterPreAnalysis,\n+          pushDownVirtualColumnsForLhsExprs\n+      );\n+    }\n+\n     // Currently we only support rewrites of selector filters and selector filters within OR filters.\n     if (filterClause instanceof SelectorFilter) {\n       return rewriteSelectorFilter(\n           (SelectorFilter) filterClause,\n-          joinFilterPreAnalysis\n+          joinFilterPreAnalysis,\n+          pushDownVirtualColumnsForLhsExprs\n       );\n     }\n \n-    if (filterClause instanceof OrFilter) {\n-      return rewriteOrFilter(\n-          (OrFilter) filterClause,\n-          joinFilterPreAnalysis\n-      );\n+    return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n+  }\n+\n+  private static JoinFilterAnalysis rewriteFilterDirect(\n+      Filter filterClause,\n+      JoinFilterPreAnalysis joinFilterPreAnalysis,\n+      Map<Expr, VirtualColumn> pushDownVirtualColumnsForLhsExprs\n+  )\n+  {\n+    if (!filterClause.supportsRequiredColumnRewrite()) {\n+      return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n     }\n \n-    return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n+    List<Filter> newFilters = new ArrayList<>();\n+\n+    // we only support direct rewrites of filters that reference a single column\n+    String reqColumn = filterClause.getRequiredColumns().iterator().next();\n+\n+    Optional<List<JoinFilterColumnCorrelationAnalysis>> correlationAnalyses = joinFilterPreAnalysis.getCorrelationsByFilteringColumn()\n+                                                                                                   .get(reqColumn);\n+\n+    if (!correlationAnalyses.isPresent()) {\n+      return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n+    }\n+\n+    for (JoinFilterColumnCorrelationAnalysis correlationAnalysis : correlationAnalyses.get()) {\n+      if (correlationAnalysis.supportsPushDown()) {\n+        for (String correlatedBaseColumn : correlationAnalysis.getBaseColumns()) {\n+          Filter rewrittenFilter = filterClause.rewriteRequiredColumns(ImmutableMap.of(\n+              reqColumn,\n+              correlatedBaseColumn\n+          ));\n+          newFilters.add(rewrittenFilter);\n+        }\n+\n+        for (Expr correlatedBaseExpr : correlationAnalysis.getBaseExpressions()) {\n+          // We need to create a virtual column for the expressions when pushing down\n+          VirtualColumn pushDownVirtualColumn = pushDownVirtualColumnsForLhsExprs.computeIfAbsent(\n+              correlatedBaseExpr,\n+              (expr) -> {\n+                String vcName = getCorrelatedBaseExprVirtualColumnName(pushDownVirtualColumnsForLhsExprs.size());\n+                return new ExpressionVirtualColumn(\n+                    vcName,\n+                    correlatedBaseExpr,\n+                    ValueType.STRING\n+                );\n+              }\n+          );\n+\n+          Filter rewrittenFilter = filterClause.rewriteRequiredColumns(ImmutableMap.of(\n+              reqColumn,\n+              pushDownVirtualColumn.getOutputName()\n+          ));\n+          newFilters.add(rewrittenFilter);\n+        }\n+      }\n+    }\n+\n+    if (newFilters.isEmpty()) {\n+      return JoinFilterAnalysis.createNoPushdownFilterAnalysis(filterClause);\n+    }", "originalCommit": "cce3497a9785bd4e65f926d03941f85a0a44124b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzU5MA==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422453590", "bodyText": "I've added that test and fixed the issue, the problem was I forgot to implement a block here for handling direct rewrites: 87ad569#diff-24d942179715e417814286d06dc4f668R203\nThe \"determine RHS candidate for leaf filter\" code has been moved into a separate method, called by the change above: 87ad569#diff-24d942179715e417814286d06dc4f668R367\nAs part of that I adjusted this area and related 87ad569#diff-24d942179715e417814286d06dc4f668R229 so that the direct rewrite information is kept separately from the non-direct rewrites, storing them in the same structures was causing problems.", "author": "jon-wei", "createdAt": "2020-05-09T05:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MzA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NjUyMw==", "url": "https://github.com/apache/druid/pull/9818#discussion_r422456523", "bodyText": "Thanks for the quick fix!", "author": "jihoonson", "createdAt": "2020-05-09T05:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MzA3Ng=="}], "type": "inlineReview"}, {"oid": "87ad5690240553200597f66185310169ad4e2b02", "url": "https://github.com/apache/druid/commit/87ad5690240553200597f66185310169ad4e2b02", "message": "Address PR comments", "committedDate": "2020-05-09T04:57:30Z", "type": "commit"}]}