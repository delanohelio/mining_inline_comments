{"pr_number": 10635, "pr_title": "Add SQL functions to format numbers into human readable format", "pr_createdAt": "2020-12-04T09:13:37Z", "pr_url": "https://github.com/apache/druid/pull/10635", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NDIyMg==", "url": "https://github.com/apache/druid/pull/10635#discussion_r535974222", "bodyText": "shouldn't there be a check on precision as well?", "author": "abhishekagarwal87", "createdAt": "2020-12-04T09:53:27Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/SizeFormatOperatorConversion.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+\n+public class SizeFormatOperatorConversion implements SqlOperatorConversion\n+{\n+  public static final SqlOperatorConversion BINARY_BYTE_FORMAT = new SizeFormatOperatorConversion(\"binary_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_BYTE_FORMAT = new SizeFormatOperatorConversion(\"decimal_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_FORMAT = new SizeFormatOperatorConversion(\"decimal_format\");\n+\n+  private final String name;\n+  private final SqlFunction sqlFunction;\n+\n+  private SizeFormatOperatorConversion(String name)\n+  {\n+    this.sqlFunction = OperatorConversions\n+        .operatorBuilder(StringUtils.toUpperCase(name))\n+        .operandTypeChecker(new StringFormatOperandTypeChecker())\n+        .functionCategory(SqlFunctionCategory.STRING)\n+        .returnTypeNonNull(SqlTypeName.VARCHAR)\n+        .build();\n+\n+    this.name = name;\n+  }\n+\n+  @Override\n+  public SqlOperator calciteOperator()\n+  {\n+    return sqlFunction;\n+  }\n+\n+  @Override\n+  public DruidExpression toDruidExpression(\n+      final PlannerContext plannerContext,\n+      final RowSignature rowSignature,\n+      final RexNode rexNode\n+  )\n+  {\n+    return OperatorConversions.convertCall(plannerContext, rowSignature, rexNode, name);\n+  }\n+\n+  private static class StringFormatOperandTypeChecker implements SqlOperandTypeChecker\n+  {\n+    @Override\n+    public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure)\n+    {\n+      final RelDataType firstArgType = callBinding.getOperandType(0);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0Mzc3OA==", "url": "https://github.com/apache/druid/pull/10635#discussion_r537243778", "bodyText": "Fixed", "author": "FrankChen021", "createdAt": "2020-12-07T05:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NDIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NjY1NQ==", "url": "https://github.com/apache/druid/pull/10635#discussion_r535976655", "bodyText": "should this be?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .virtualColumns(expressionVirtualColumn(\"v0\", \"'44.61KiB'\", ValueType.STRING),\n          \n          \n            \n                            .virtualColumns(expressionVirtualColumn(\"v0\", \"binary_date_format(45678)\", ValueType.STRING),", "author": "abhishekagarwal87", "createdAt": "2020-12-04T09:57:11Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -16153,6 +16161,44 @@ public void testTimeStampAddConversion() throws Exception\n     );\n   }\n \n+  public void testSizeFormatFunction() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT m1, \"\n+        + \"BINARY_BYTE_FORMAT(45678),\"\n+        + \"BINARY_BYTE_FORMAT(m1*12345),\"\n+        + \"BINARY_BYTE_FORMAT(m1*12345, 0), \"\n+        + \"DECIMAL_BYTE_FORMAT(m1*12345), \"\n+        + \"DECIMAL_FORMAT(m1*12345) \"\n+        + \"FROM numfoo WHERE f1 = 0.1 LIMIT 1\",\n+        ImmutableList.of(\n+            newScanQueryBuilder()\n+                .dataSource(CalciteTests.DATASOURCE3)\n+                .intervals(querySegmentSpec(Filtration.eternity()))\n+                .virtualColumns(expressionVirtualColumn(\"v0\", \"'44.61KiB'\", ValueType.STRING),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0MzY1MA==", "url": "https://github.com/apache/druid/pull/10635#discussion_r537243650", "bodyText": "This is a special case. I also thought it should a function call expression here. But because the given argument is a constant, this function call has been calculated during SQL parsing phase before converting to native sql. I've added some comments in the latest commit here.", "author": "FrankChen021", "createdAt": "2020-12-07T05:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NjY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI4MTM5NA==", "url": "https://github.com/apache/druid/pull/10635#discussion_r537281394", "bodyText": "\ud83d\udc4d  Thanks for clarifying", "author": "abhishekagarwal87", "createdAt": "2020-12-07T07:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NTYzNQ==", "url": "https://github.com/apache/druid/pull/10635#discussion_r535985635", "bodyText": "in this particular scenario, should space be appended?", "author": "abhishekagarwal87", "createdAt": "2020-12-04T10:11:18Z", "path": "core/src/test/java/org/apache/druid/java/util/common/HumanReadableBytesTest.java", "diffHunk": "@@ -395,6 +395,107 @@ public void testBytesRange()\n     Assert.assertEquals(\"value must be in the range of [0, 5]\", message);\n   }\n \n+  @Test\n+  public void testFormatInBinaryByte()\n+  {\n+    Assert.assertEquals(\"-8.00 EiB\", HumanReadableBytes.format(Long.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-8.000 EiB\", HumanReadableBytes.format(Long.MIN_VALUE, 3, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+\n+    Assert.assertEquals(\"-2.00 GiB\", HumanReadableBytes.format(Integer.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-32.00 KiB\", HumanReadableBytes.format(Short.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-128.00 B\", HumanReadableBytes.format(Byte.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-1.00 B\", HumanReadableBytes.format(-1, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"0.00 B\", HumanReadableBytes.format(0, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 B\", HumanReadableBytes.format(1, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 KiB\", HumanReadableBytes.format(1024L, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 MiB\", HumanReadableBytes.format(1024L * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 GiB\", HumanReadableBytes.format(1024L * 1024 * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 TiB\", HumanReadableBytes.format(1024L * 1024 * 1024 * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 PiB\", HumanReadableBytes.format(1024L * 1024 * 1024 * 1024 * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"8.00 EiB\", HumanReadableBytes.format(Long.MAX_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testPrecisionInBinaryFormat()\n+  {\n+    Assert.assertEquals(\"1 KiB\", HumanReadableBytes.format(1500, 0, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.5 KiB\", HumanReadableBytes.format(1500, 1, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.46 KiB\", HumanReadableBytes.format(1500, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.465 KiB\", HumanReadableBytes.format(1500, 3, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testPrecisionInDecimalFormat()\n+  {\n+    Assert.assertEquals(\"1 KB\", HumanReadableBytes.format(1456, 0, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.5 KB\", HumanReadableBytes.format(1456, 1, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.46 KB\", HumanReadableBytes.format(1456, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.456 KB\", HumanReadableBytes.format(1456, 3, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testFormatInDecimalByte()\n+  {\n+    Assert.assertEquals(\"1.00 B\", HumanReadableBytes.format(1, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 KB\", HumanReadableBytes.format(1000L, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 MB\", HumanReadableBytes.format(1000L * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 GB\", HumanReadableBytes.format(1000L * 1000 * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 TB\", HumanReadableBytes.format(1000L * 1000 * 1000 * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 PB\", HumanReadableBytes.format(1000L * 1000 * 1000 * 1000 * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"9.22 EB\", HumanReadableBytes.format(Long.MAX_VALUE, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+\n+    Assert.assertEquals(\"100.00 KB\", HumanReadableBytes.format(99999, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"99.999 KB\", HumanReadableBytes.format(99999, 3, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+\n+    Assert.assertEquals(\"999.9 PB\", HumanReadableBytes.format(999_949_999_999_999_999L, 1, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"999.95 PB\", HumanReadableBytes.format(999_949_999_999_999_999L, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"999.949 PB\", HumanReadableBytes.format(999_949_999_999_999_999L, 3, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testFormatInDecimal()\n+  {\n+    Assert.assertEquals(\"1.00 \", HumanReadableBytes.format(1, 2, HumanReadableBytes.UnitSystem.DECIMAL, true));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0NDE2NQ==", "url": "https://github.com/apache/druid/pull/10635#discussion_r537244165", "bodyText": "This special case has been handled in the latest commit.", "author": "FrankChen021", "createdAt": "2020-12-07T05:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NTYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjYyMg==", "url": "https://github.com/apache/druid/pull/10635#discussion_r535986622", "bodyText": "is the hasSpace customizable from outside? May be it can be just hard-coded to true.", "author": "abhishekagarwal87", "createdAt": "2020-12-04T10:12:44Z", "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -208,4 +208,108 @@ private static long parseInner(String rawNumber)\n       throw new IAE(\"Invalid format or out of range of long: %s\", rawNumber);\n     }\n   }\n+\n+  public enum UnitSystem\n+  {\n+    /**\n+     * also known as IEC format\n+     * eg: B, KiB, MiB, GiB ...\n+     */\n+    BINARY_BYTE,\n+\n+    /**\n+     * also known as SI format\n+     * eg: B, KB, MB ...\n+     */\n+    DECIMAL_BYTE,\n+\n+    /**\n+     * simplified SI format without 'B' indicator\n+     * eg: K, M, G ...\n+     */\n+    DECIMAL\n+  }\n+\n+  /**\n+   * Returns a human-readable string version of input value\n+   *\n+   * @param bytes      input value. Negative value is also allowed\n+   * @param precision  [0,3]\n+   * @param unitSystem which unit system is adopted to format the input value, see {@link UnitSystem}\n+   * @param hasSpace   if it's true, there's an extra space between the number and the unit suffix\n+   */\n+  public static String format(long bytes, int precision, UnitSystem unitSystem, boolean hasSpace)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0NDk3Mw==", "url": "https://github.com/apache/druid/pull/10635#discussion_r537244973", "bodyText": "We intended to expose this parameter at the SQL/native query level at first, but found that this parameter is not so vital. So we still keep it in the underlying implementation but hide it from the SQL level.", "author": "FrankChen021", "createdAt": "2020-12-07T05:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI4MDc0Mg==", "url": "https://github.com/apache/druid/pull/10635#discussion_r537280742", "bodyText": "IMO it's more of a dead param then and should be removed. It can be added back if druid ever exposes hasSpace to user in future.", "author": "abhishekagarwal87", "createdAt": "2020-12-07T07:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM2NTU1NQ==", "url": "https://github.com/apache/druid/pull/10635#discussion_r537365555", "bodyText": "OK. It's been deleted.", "author": "FrankChen021", "createdAt": "2020-12-07T09:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1ODM0Mg==", "url": "https://github.com/apache/druid/pull/10635#discussion_r538058342", "bodyText": "Since we are calling asLong without checking isNumericNull of the ExprEval, we are ignoring the value of druid.generic.useDefaultValueForNull here, which I think is incorrect and this should return null instead.\nThinking out loud, how should this function behave with non-long inputs?\nThe way this is currently implement:\n\nInputs of ExprType.DOUBLE will be cast to a ExprType.LONG before conversion.\nFor ExprType.STRING inputs, if they are number-ish strings, they will be parsed into long values, but if not asLong will always be 0.\n\nI don't know that this behavior is incorrect, I just wanted to call it out to think about it.\nI do think we want to check for isNumericNull and return ExprEval.of(null) if NullHandling.sqlCompatible() is set, for any input types.\nI see in the SQL operator it looks like it strictly validates that the inputs are numeric, while Druid native expressions have traditionally been a bit fast and loose about the inputs they accept and tend to be rather forgiving, so perhaps this is ok that the behavior here doesn't quite match.", "author": "clintropolis", "createdAt": "2020-12-08T06:02:53Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -3275,4 +3276,86 @@ public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n       return l.stream();\n     }\n   }\n+\n+  abstract class SizeFormatFunc implements Function\n+  {\n+    protected abstract HumanReadableBytes.UnitSystem getUnitSystem();\n+\n+    /**\n+     * Evaluate given expression\n+     * By default, 'precision' is 2 and 'hasSpace' is false\n+     */\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      final long bytes = args.get(0).eval(bindings).asLong();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1MDUxMg==", "url": "https://github.com/apache/druid/pull/10635#discussion_r538150512", "bodyText": "good point. I'll make some improvement here.", "author": "FrankChen021", "createdAt": "2020-12-08T08:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1ODM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIwNjkzMQ==", "url": "https://github.com/apache/druid/pull/10635#discussion_r539206931", "bodyText": "Hi @clintropolis , null and type handling has been improved in the latest commit. Please check it at your convenience.", "author": "FrankChen021", "createdAt": "2020-12-09T10:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1ODM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1OTY5MQ==", "url": "https://github.com/apache/druid/pull/10635#discussion_r538059691", "bodyText": "Should these docs live with the 'numeric' functions? I suppose here is ok too...", "author": "clintropolis", "createdAt": "2020-12-08T06:06:57Z", "path": "docs/querying/sql.md", "diffHunk": "@@ -563,6 +563,9 @@ The [DataSketches extension](../development/extensions-core/datasketches-extensi\n |`COALESCE(value1, value2, ...)`|Returns the first value that is neither NULL nor empty string.|\n |`NVL(expr,expr-for-null)`|Returns 'expr-for-null' if 'expr' is null (or empty string for string type).|\n |`BLOOM_FILTER_TEST(<expr>, <serialized-filter>)`|Returns true if the value is contained in a Base64-serialized bloom filter. See the [Bloom filter extension](../development/extensions-core/bloom-filter.html) documentation for additional details.|\n+|`BINARY_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KiB`, `MiB`, `GiB`, `TiB`, `PiB`, `EiB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [SI](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KB`, `MB`, `GB`, `TB`, `PB`, `EB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_FORMAT(value, [precision])`|Returns the value in human-readable SI format. Supported unit suffix: `K`, `M`, `G`, `T`, `P`, `E`. `precision` must be in the range of [0,3] (default: 2).|", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE0ODc0MA==", "url": "https://github.com/apache/druid/pull/10635#discussion_r538148740", "bodyText": "I see all existing numeric functions are all about mathematical computation, the input parameter and output result are all type of integer or float.  The new functions in this PR are a little bit different from those, I don't whether it's suitable to put them in 'numeric function' section, so I put them in a separated section.", "author": "FrankChen021", "createdAt": "2020-12-08T08:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1OTY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1NTEyMg==", "url": "https://github.com/apache/druid/pull/10635#discussion_r538155122", "bodyText": "yeah, i guess in the native expression version of this document the section is called math functions or something like that", "author": "clintropolis", "createdAt": "2020-12-08T09:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1OTY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIyODE3OA==", "url": "https://github.com/apache/druid/pull/10635#discussion_r554228178", "bodyText": "I think they make sense in the numeric section, because they accept numbers. It's OK that they don't return numbers. It's analogous to TIME_FORMAT, which still belongs in the time section.", "author": "gianm", "createdAt": "2021-01-08T22:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1OTY5MQ=="}], "type": "inlineReview"}, {"oid": "6dd891ef72cd782f22e02ccb9899f633f461b77d", "url": "https://github.com/apache/druid/commit/6dd891ef72cd782f22e02ccb9899f633f461b77d", "message": "add binary_byte_format/decimal_byte_format/decimal_format", "committedDate": "2020-12-22T01:21:31Z", "type": "commit"}, {"oid": "1ecbbfc65776d02e32a868300b07741bd95ef4d0", "url": "https://github.com/apache/druid/commit/1ecbbfc65776d02e32a868300b07741bd95ef4d0", "message": "clean code", "committedDate": "2020-12-22T01:21:31Z", "type": "commit"}, {"oid": "a6afe8521c2c49b2187a802fc4f9675a6d88455f", "url": "https://github.com/apache/druid/commit/a6afe8521c2c49b2187a802fc4f9675a6d88455f", "message": "fix doc", "committedDate": "2020-12-22T01:21:31Z", "type": "commit"}, {"oid": "f5fab7159fff0d21186524d74d32a61689cbef26", "url": "https://github.com/apache/druid/commit/f5fab7159fff0d21186524d74d32a61689cbef26", "message": "fix review comments", "committedDate": "2020-12-22T01:21:31Z", "type": "commit"}, {"oid": "be3c333612e7aad74f4b2e90b0bc25b0b33da6af", "url": "https://github.com/apache/druid/commit/be3c333612e7aad74f4b2e90b0bc25b0b33da6af", "message": "add spelling check rules", "committedDate": "2020-12-22T01:21:32Z", "type": "commit"}, {"oid": "e02809a2a976c32328f2be86bd42533cc0c1469f", "url": "https://github.com/apache/druid/commit/e02809a2a976c32328f2be86bd42533cc0c1469f", "message": "remove extra param", "committedDate": "2020-12-22T01:21:32Z", "type": "commit"}, {"oid": "b5a3756633260a0ec55721f47f518abcaaf727f5", "url": "https://github.com/apache/druid/commit/b5a3756633260a0ec55721f47f518abcaaf727f5", "message": "improve type handling and null handling", "committedDate": "2020-12-22T01:21:32Z", "type": "commit"}, {"oid": "e279c18a05c6b93246ab00a46f2d743225cad3ca", "url": "https://github.com/apache/druid/commit/e279c18a05c6b93246ab00a46f2d743225cad3ca", "message": "remove extra zeros", "committedDate": "2020-12-22T01:21:32Z", "type": "commit"}, {"oid": "91e6a550ff8dbacae2d6da91262784df0a52d6c5", "url": "https://github.com/apache/druid/commit/91e6a550ff8dbacae2d6da91262784df0a52d6c5", "message": "fix tests and add space between unit suffix and number as most size-format functions do", "committedDate": "2020-12-22T01:39:23Z", "type": "commit"}, {"oid": "91e6a550ff8dbacae2d6da91262784df0a52d6c5", "url": "https://github.com/apache/druid/commit/91e6a550ff8dbacae2d6da91262784df0a52d6c5", "message": "fix tests and add space between unit suffix and number as most size-format functions do", "committedDate": "2020-12-22T01:39:23Z", "type": "forcePushed"}, {"oid": "5d0fe124f5438e608d3d3eda1f80f39fa17a56ff", "url": "https://github.com/apache/druid/commit/5d0fe124f5438e608d3d3eda1f80f39fa17a56ff", "message": "fix tests", "committedDate": "2020-12-23T01:12:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxNTc4Mg==", "url": "https://github.com/apache/druid/pull/10635#discussion_r547515782", "bodyText": "All unit tests are run with both values of druid.generic.useDefaultValueForNull, so it isn't necessary to explicitly configure it. What we typically do is try to just write the test to check for the mode and adjust the expectation accordingly, e.g. to use another example from this file\nassertExpr(\"lpad(x, 2, '')\", NullHandling.replaceWithDefault() ? null : \"fo\");", "author": "clintropolis", "createdAt": "2020-12-22T21:28:56Z", "path": "core/src/test/java/org/apache/druid/math/expr/FunctionTest.java", "diffHunk": "@@ -519,6 +525,203 @@ public void testLeast()\n     assertExpr(\"least(1, null, 'A')\", \"1\");\n   }\n \n+  @Test\n+  public void testSizeFormat()\n+  {\n+    assertExpr(\"binary_byte_format(-1024)\", \"-1.00 KiB\");\n+    assertExpr(\"binary_byte_format(1024)\", \"1.00 KiB\");\n+    assertExpr(\"binary_byte_format(1024*1024)\", \"1.00 MiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024)\", \"1.00 GiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024*1024)\", \"1.00 TiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024*1024*1024)\", \"1.00 PiB\");\n+\n+    assertExpr(\"decimal_byte_format(-1000)\", \"-1.00 KB\");\n+    assertExpr(\"decimal_byte_format(1000)\", \"1.00 KB\");\n+    assertExpr(\"decimal_byte_format(1000*1000)\", \"1.00 MB\");\n+    assertExpr(\"decimal_byte_format(1000*1000*1000)\", \"1.00 GB\");\n+    assertExpr(\"decimal_byte_format(1000*1000*1000*1000)\", \"1.00 TB\");\n+\n+    assertExpr(\"decimal_format(-1000)\", \"-1.00 K\");\n+    assertExpr(\"decimal_format(1000)\", \"1.00 K\");\n+    assertExpr(\"decimal_format(1000*1000)\", \"1.00 M\");\n+    assertExpr(\"decimal_format(1000*1000*1000)\", \"1.00 G\");\n+    assertExpr(\"decimal_format(1000*1000*1000*1000)\", \"1.00 T\");\n+  }\n+\n+  @Test\n+  public void testSizeFormatWithDifferentPrecision()\n+  {\n+    assertExpr(\"binary_byte_format(1024, 0)\", \"1 KiB\");\n+    assertExpr(\"binary_byte_format(1024*1024, 1)\", \"1.0 MiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024, 2)\", \"1.00 GiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024*1024, 3)\", \"1.000 TiB\");\n+\n+    assertExpr(\"decimal_byte_format(1234, 0)\", \"1 KB\");\n+    assertExpr(\"decimal_byte_format(1234*1000, 1)\", \"1.2 MB\");\n+    assertExpr(\"decimal_byte_format(1234*1000*1000, 2)\", \"1.23 GB\");\n+    assertExpr(\"decimal_byte_format(1234*1000*1000*1000, 3)\", \"1.234 TB\");\n+\n+    assertExpr(\"decimal_format(1234, 0)\", \"1 K\");\n+    assertExpr(\"decimal_format(1234*1000,1)\", \"1.2 M\");\n+    assertExpr(\"decimal_format(1234*1000*1000,2)\", \"1.23 G\");\n+    assertExpr(\"decimal_format(1234*1000*1000*1000,3)\", \"1.234 T\");\n+  }\n+\n+  @Test\n+  public void testSizeFormatWithEdgeCases()\n+  {\n+    //a nonexist value is null which is treated as 0\n+    assertExpr(\"binary_byte_format(nonexist)\", \"0 B\");\n+\n+    //f = 12.34\n+    assertExpr(\"binary_byte_format(f)\", \"12 B\");\n+\n+    //nan is Double.NaN\n+    assertExpr(\"binary_byte_format(nan)\", \"0 B\");\n+\n+    //inf = Double.POSITIVE_INFINITY\n+    assertExpr(\"binary_byte_format(inf)\", \"8.00 EiB\");\n+\n+    //inf = Double.NEGATIVE_INFINITY\n+    assertExpr(\"binary_byte_format(-inf)\", \"-8.00 EiB\");\n+\n+    // o = 0\n+    assertExpr(\"binary_byte_format(o)\", \"0 B\");\n+\n+    // od = 0D\n+    assertExpr(\"binary_byte_format(od)\", \"0 B\");\n+\n+    // of = 0F\n+    assertExpr(\"binary_byte_format(of)\", \"0 B\");\n+  }\n+\n+  @Test\n+  public void testSizeForatInvalidArgumentType()\n+  {\n+    try {\n+      //x = \"foo\"\n+      Parser.parse(\"binary_byte_format(x)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs a number as its first argument\", e.getMessage());\n+    }\n+\n+    try {\n+      //x = \"foo\"\n+      Parser.parse(\"binary_byte_format(1024, x)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs an integer as its second argument\", e.getMessage());\n+    }\n+\n+    try {\n+      //of = 0F\n+      Parser.parse(\"binary_byte_format(1024, of)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs an integer as its second argument\", e.getMessage());\n+    }\n+\n+    try {\n+      //of = 0F\n+      Parser.parse(\"binary_byte_format(1024, nonexist)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs an integer as its second argument\", e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testSizeFormatInvalidPrecision()\n+  {\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, maxLong)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[9223372036854775807] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, minLong)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[-9223372036854775808] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, -1)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[-1] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, 4)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[4] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testSizeFormatInvalidArgumentSize()\n+  {\n+    expectedException.expect(IAE.class);\n+    expectedException.expectMessage(\"Function[binary_byte_format] needs 1 or 2 arguments\");\n+    Parser.parse(\"binary_byte_format(1024, 2, 3)\", ExprMacroTable.nil())\n+          .eval(bindings);\n+  }\n+\n+  @Test\n+  public void testSizeFormatWithNoDefaultValueForNull()\n+  {\n+    NullHandling.updateForTests(false);", "originalCommit": "91e6a550ff8dbacae2d6da91262784df0a52d6c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTcyNzIxMw==", "url": "https://github.com/apache/druid/pull/10635#discussion_r551727213", "bodyText": "MySQL ships a similar function format_bytes\nI struggled the two different approaches at first. And at last I chose to do it by 3 different functions. The reasons are,\n\n\ndifferent function names are more meaningful than different arguments for one function. Since there're 3 different unit systems in this PR, how to name them in a short enough way and without ambiguity is a big challenge. For example,  FORMAT(number, 'si'), FORMAT(number, 'dec'), si and dec are standard abbreviation and short enough but they're hard to understand; FORMAT(number, 'binary_byte'), it's clear enough, but it's not so simple compared to binary_byte_format(number)\n\n\nat the underlying layer, there are always different format functions, and if we provide one function at the user side, we have to do some checks on the format specifier and dispatch calls to those different functions. It's a little bit simple if different functions are provided.\n\n\nBut as you mentioned, there are also some drawbacks in this way. If the standard is to keep consistent with other databases or keep less numbers of functions exposed to users, maybe we need to combine these functions together.", "author": "FrankChen021", "createdAt": "2021-01-05T05:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxNTc4Mg=="}], "type": "inlineReview"}, {"oid": "8e4eede275f1116ba8f2766fb014e0d6ecda600a", "url": "https://github.com/apache/druid/commit/8e4eede275f1116ba8f2766fb014e0d6ecda600a", "message": "merge master to resolve conflicts\n\nSigned-off-by: frank chen <frank.chen021@outlook.com>", "committedDate": "2021-02-22T07:24:56Z", "type": "commit"}, {"oid": "94206b693ce67cf66741f340360e95268aeb3246", "url": "https://github.com/apache/druid/commit/94206b693ce67cf66741f340360e95268aeb3246", "message": "add examples", "committedDate": "2021-02-22T07:39:33Z", "type": "commit"}, {"oid": "f19e6a59ef82e4d056e05a6954b3a9203a040eec", "url": "https://github.com/apache/druid/commit/f19e6a59ef82e4d056e05a6954b3a9203a040eec", "message": "change function names according to review comments", "committedDate": "2021-02-22T09:09:28Z", "type": "commit"}, {"oid": "5dca644d6877d69dbc06d150f330f8fd0dcbaafa", "url": "https://github.com/apache/druid/commit/5dca644d6877d69dbc06d150f330f8fd0dcbaafa", "message": "merge master to resolve conflicts\n\nSigned-off-by: frank chen <frank.chen021@outlook.com>", "committedDate": "2021-03-05T08:38:23Z", "type": "commit"}, {"oid": "47d22f9b0f479fa920a2315e1429c890859391c7", "url": "https://github.com/apache/druid/commit/47d22f9b0f479fa920a2315e1429c890859391c7", "message": "fix merge\n\nSigned-off-by: frank chen <frank.chen021@outlook.com>", "committedDate": "2021-03-05T10:24:17Z", "type": "commit"}, {"oid": "ad7d8312c46c22db73dada4f5e14caf894e976c0", "url": "https://github.com/apache/druid/commit/ad7d8312c46c22db73dada4f5e14caf894e976c0", "message": "no need to configure NullHandling explicitly for tests\n\nSigned-off-by: frank chen <frank.chen021@outlook.com>", "committedDate": "2021-03-05T10:29:28Z", "type": "commit"}, {"oid": "c3dbb1e5e0d5fabfdb116de89f0657a772605d3d", "url": "https://github.com/apache/druid/commit/c3dbb1e5e0d5fabfdb116de89f0657a772605d3d", "message": "fix tests in SQL-Compatible mode\n\nSigned-off-by: frank chen <frank.chen021@outlook.com>", "committedDate": "2021-03-08T09:32:25Z", "type": "commit"}, {"oid": "f21bc878228dd68f11d2ff06afb5d543c68ad24e", "url": "https://github.com/apache/druid/commit/f21bc878228dd68f11d2ff06afb5d543c68ad24e", "message": "Merge master to resolve conflicts\n\nSigned-off-by: frank chen <frank.chen021@outlook.com>", "committedDate": "2021-05-13T02:01:15Z", "type": "commit"}, {"oid": "f21bc878228dd68f11d2ff06afb5d543c68ad24e", "url": "https://github.com/apache/druid/commit/f21bc878228dd68f11d2ff06afb5d543c68ad24e", "message": "Merge master to resolve conflicts\n\nSigned-off-by: frank chen <frank.chen021@outlook.com>", "committedDate": "2021-05-13T02:01:15Z", "type": "forcePushed"}, {"oid": "81195458fda6bb3f1ff2f1d918d5bf87568e2699", "url": "https://github.com/apache/druid/commit/81195458fda6bb3f1ff2f1d918d5bf87568e2699", "message": "Merge branch 'master' into size-format to resolve conflicts", "committedDate": "2021-06-18T08:22:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NjA5OTg1Mg==", "url": "https://github.com/apache/druid/pull/10635#discussion_r656099852", "bodyText": "this should use the recently added returnTypeCascadeNullable since it returns null if the input is null (see #11327)", "author": "clintropolis", "createdAt": "2021-06-22T10:45:19Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/HumanReadableFormatOperatorConversion.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+\n+public class HumanReadableFormatOperatorConversion implements SqlOperatorConversion\n+{\n+  public static final SqlOperatorConversion BINARY_BYTE_FORMAT = new HumanReadableFormatOperatorConversion(\"human_readable_binary_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_BYTE_FORMAT = new HumanReadableFormatOperatorConversion(\"human_readable_decimal_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_FORMAT = new HumanReadableFormatOperatorConversion(\"human_readable_decimal_format\");\n+\n+  private final String name;\n+  private final SqlFunction sqlFunction;\n+\n+  private HumanReadableFormatOperatorConversion(String name)\n+  {\n+    this.sqlFunction = OperatorConversions\n+        .operatorBuilder(StringUtils.toUpperCase(name))\n+        .operandTypeChecker(new HumanReadableFormatOperandTypeChecker())\n+        .functionCategory(SqlFunctionCategory.STRING)\n+        .returnTypeNonNull(SqlTypeName.VARCHAR)", "originalCommit": "81195458fda6bb3f1ff2f1d918d5bf87568e2699", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1Njg5MzkwMg==", "url": "https://github.com/apache/druid/pull/10635#discussion_r656893902", "bodyText": "Fixed", "author": "FrankChen021", "createdAt": "2021-06-23T08:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NjA5OTg1Mg=="}], "type": "inlineReview"}, {"oid": "fc7cc9bd95aeaab565ce1ad9b05b41c34935e7de", "url": "https://github.com/apache/druid/commit/fc7cc9bd95aeaab565ce1ad9b05b41c34935e7de", "message": "Resolve review comments", "committedDate": "2021-06-23T08:47:05Z", "type": "commit"}, {"oid": "fa1f05795e2f829f977ed89cf10627f2727552d7", "url": "https://github.com/apache/druid/commit/fa1f05795e2f829f977ed89cf10627f2727552d7", "message": "Update SQL test case to check null handling", "committedDate": "2021-06-23T08:49:46Z", "type": "commit"}, {"oid": "12edaabc96f385a2cd400f00ca71af74d0c7e160", "url": "https://github.com/apache/druid/commit/12edaabc96f385a2cd400f00ca71af74d0c7e160", "message": "Fix intellij inspections", "committedDate": "2021-06-24T01:54:35Z", "type": "commit"}, {"oid": "27d9a41ade079ea807650adebf3fa5b6dbe806ba", "url": "https://github.com/apache/druid/commit/27d9a41ade079ea807650adebf3fa5b6dbe806ba", "message": "Merge branch 'master' to resolve conflicts", "committedDate": "2021-06-26T16:02:05Z", "type": "commit"}, {"oid": "27d9a41ade079ea807650adebf3fa5b6dbe806ba", "url": "https://github.com/apache/druid/commit/27d9a41ade079ea807650adebf3fa5b6dbe806ba", "message": "Merge branch 'master' to resolve conflicts", "committedDate": "2021-06-26T16:02:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDM1NjcxNA==", "url": "https://github.com/apache/druid/pull/10635#discussion_r660356714", "bodyText": "@FrankChen021  can you add one example with a custom precision value? Maybe, one of these examples can be modified itself.", "author": "abhishekagarwal87", "createdAt": "2021-06-29T07:35:49Z", "path": "docs/misc/math-expr.md", "diffHunk": "@@ -258,3 +258,12 @@ supported features:\n * math functions: `abs`, `acos`, `asin`, `atan`, `cbrt`, `ceil`, `cos`, `cosh`, `cot`, `exp`, `expm1`, `floor`, `getExponent`, `log`, `log10`, `log1p`, `nextUp`, `rint`, `signum`, `sin`, `sinh`, `sqrt`, `tan`, `tanh`, `toDegrees`, `toRadians`, `ulp`, `atan2`, `copySign`, `div`, `hypot`, `max`, `min`, `nextAfter`,  `pow`, `remainder`, `scalb` are supported for numeric types\n * time functions: `timestamp_floor` (with constant granularity argument) is supported for numeric types\n * other: `parse_long` is supported for numeric and string types\n+\n+\n+## Other functions\n+\n+| function | description |\n+| --- | --- |\n+| human_readable_binary_byte_format(value[, precision]) | Format a number in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. For example, human_readable_binary_byte_format(1048576) returns `1.00 MiB`. `precision` must be in the range of [0,3] (default: 2). |", "originalCommit": "27d9a41ade079ea807650adebf3fa5b6dbe806ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "30eb6eda3c521dc65bc36ef5f607332cee074bd2", "url": "https://github.com/apache/druid/commit/30eb6eda3c521dc65bc36ef5f607332cee074bd2", "message": "Add more examples", "committedDate": "2021-06-29T09:12:31Z", "type": "commit"}, {"oid": "e773dac201b3c56834ae31b88cc336b3cbf500a0", "url": "https://github.com/apache/druid/commit/e773dac201b3c56834ae31b88cc336b3cbf500a0", "message": "Fix example", "committedDate": "2021-06-29T09:15:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDQzMzU4NA==", "url": "https://github.com/apache/druid/pull/10635#discussion_r660433584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | human_readable_binary_byte_format(value[, precision]) | Format a number in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. `precision` must be in the range of [0,3] (default: 2). For example:<li> human_readable_binary_byte_format(1048576) returns `1.00 MiB`</li><li>human_readable_binary_byte_format(1048576, 1) returns `1.000 MiB`</li> |\n          \n          \n            \n            | human_readable_binary_byte_format(value[, precision]) | Format a number in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. `precision` must be in the range of [0,3] (default: 2). For example:<li> human_readable_binary_byte_format(1048576) returns `1.00 MiB`</li><li>human_readable_binary_byte_format(1048576, 1) returns `1.0 MiB`</li> |", "author": "abhishekagarwal87", "createdAt": "2021-06-29T09:16:26Z", "path": "docs/misc/math-expr.md", "diffHunk": "@@ -258,3 +258,12 @@ supported features:\n * math functions: `abs`, `acos`, `asin`, `atan`, `cbrt`, `ceil`, `cos`, `cosh`, `cot`, `exp`, `expm1`, `floor`, `getExponent`, `log`, `log10`, `log1p`, `nextUp`, `rint`, `signum`, `sin`, `sinh`, `sqrt`, `tan`, `tanh`, `toDegrees`, `toRadians`, `ulp`, `atan2`, `copySign`, `div`, `hypot`, `max`, `min`, `nextAfter`,  `pow`, `remainder`, `scalb` are supported for numeric types\n * time functions: `timestamp_floor` (with constant granularity argument) is supported for numeric types\n * other: `parse_long` is supported for numeric and string types\n+\n+\n+## Other functions\n+\n+| function | description |\n+| --- | --- |\n+| human_readable_binary_byte_format(value[, precision]) | Format a number in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. `precision` must be in the range of [0,3] (default: 2). For example:<li> human_readable_binary_byte_format(1048576) returns `1.00 MiB`</li><li>human_readable_binary_byte_format(1048576, 1) returns `1.000 MiB`</li> |", "originalCommit": "30eb6eda3c521dc65bc36ef5f607332cee074bd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDQzNDUwOQ==", "url": "https://github.com/apache/druid/pull/10635#discussion_r660434509", "bodyText": "Thanks for your quick review. I found this bug and fixed it.", "author": "FrankChen021", "createdAt": "2021-06-29T09:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDQzMzU4NA=="}], "type": "inlineReview"}, {"oid": "f3c62a3ac69a38a8b8372fa5ea62914dc5debc51", "url": "https://github.com/apache/druid/commit/f3c62a3ac69a38a8b8372fa5ea62914dc5debc51", "message": "Merge branch 'master' into size-format\n\nSigned-off-by: frank chen <frank.chen021@outlook.com>", "committedDate": "2021-08-13T06:57:35Z", "type": "commit"}]}