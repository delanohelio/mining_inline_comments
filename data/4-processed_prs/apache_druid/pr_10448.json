{"pr_number": 10448, "pr_title": "Added CronScheduler support as a proof to clock drift while emitting metrics", "pr_createdAt": "2020-09-29T11:00:32Z", "pr_url": "https://github.com/apache/druid/pull/10448", "timeline": [{"oid": "525c6bd53e95e008cbd1fa8427c867e7a3aa9af3", "url": "https://github.com/apache/druid/commit/525c6bd53e95e008cbd1fa8427c867e7a3aa9af3", "message": "Added cronScheduler support for MonitorScheduler", "committedDate": "2020-07-31T08:37:43Z", "type": "commit"}, {"oid": "4c041bd364def78cf2ea1903c9733e4df4f6aed4", "url": "https://github.com/apache/druid/commit/4c041bd364def78cf2ea1903c9733e4df4f6aed4", "message": "added javadoc and license", "committedDate": "2020-08-03T06:34:36Z", "type": "commit"}, {"oid": "24b686da7eef2a262732c96e632a803ca6bd186f", "url": "https://github.com/apache/druid/commit/24b686da7eef2a262732c96e632a803ca6bd186f", "message": "Fixed formatting", "committedDate": "2020-08-03T12:18:43Z", "type": "commit"}, {"oid": "8aec96cf4fc3dd08ab02df3b8c8902d375f9dc4c", "url": "https://github.com/apache/druid/commit/8aec96cf4fc3dd08ab02df3b8c8902d375f9dc4c", "message": "Merge pull request #472 from ayushkul2910/cronScheduling\n\nUsing CronScheduler instead of ScheduledExecutorService in MonitorScheduler", "committedDate": "2020-09-28T07:22:49Z", "type": "commit"}, {"oid": "653be2f6a663d1b4c5be29f7836e88cee64b57c5", "url": "https://github.com/apache/druid/commit/653be2f6a663d1b4c5be29f7836e88cee64b57c5", "message": "Added tests for ScheduledExecutors and MonitorScheduler (#574)", "committedDate": "2020-10-12T10:42:52Z", "type": "commit"}, {"oid": "67438be5f03813dda5e7da18d22ffcb33af1f601", "url": "https://github.com/apache/druid/commit/67438be5f03813dda5e7da18d22ffcb33af1f601", "message": "Fixed conflicts in MonitorSchedulerTest", "committedDate": "2020-10-12T11:39:54Z", "type": "commit"}, {"oid": "35071c2b904f483fbe6fd6c1d6594d489ca022d2", "url": "https://github.com/apache/druid/commit/35071c2b904f483fbe6fd6c1d6594d489ca022d2", "message": "added branch coverage for ScheduledExecutors", "committedDate": "2020-10-14T07:41:07Z", "type": "commit"}, {"oid": "35071c2b904f483fbe6fd6c1d6594d489ca022d2", "url": "https://github.com/apache/druid/commit/35071c2b904f483fbe6fd6c1d6594d489ca022d2", "message": "added branch coverage for ScheduledExecutors", "committedDate": "2020-10-14T07:41:07Z", "type": "forcePushed"}, {"oid": "20f7fe61551d1f3afeaeb06c245089aa4569f568", "url": "https://github.com/apache/druid/commit/20f7fe61551d1f3afeaeb06c245089aa4569f568", "message": "dummy commit for rerunning build", "committedDate": "2020-10-18T13:21:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg==", "url": "https://github.com/apache/druid/pull/10448#discussion_r507181662", "bodyText": "I think this logic: scheduling one-shot task which reschedules itself, is problematic. I think we should remove these methods (together with the Signal enum) because they have negative utility.\nIn particular, for CronScheduler, constant rescheduling is probably prone to some drift. Instead, CronScheduler's methods like scheduleAtFixedRate() should be used directly from MonitorScheduler. The periodic task can be cancelled using the returned Future.", "author": "leventov", "createdAt": "2020-10-18T16:13:34Z", "path": "core/src/main/java/org/apache/druid/java/util/common/concurrent/ScheduledExecutors.java", "diffHunk": "@@ -167,6 +169,50 @@ public void run()\n     );\n   }\n \n+  public static void scheduleAtFixedRate(CronScheduler exec, Duration rate, Callable<Signal> callable)\n+  {\n+    scheduleAtFixedRate(exec, rate, rate, callable);\n+  }\n+\n+  /**\n+   * Run callable once every period, after the given initial delay. Uses\n+   * {@link CronScheduler} for task scheduling. Exceptions are caught and logged\n+   * as errors.\n+   */\n+  public static void scheduleAtFixedRate(\n+      final CronScheduler exec,\n+      final Duration initialDelay,\n+      final Duration rate,\n+      final Callable<Signal> callable\n+  )\n+  {\n+    log.debug(\"Scheduling periodically: %s with period %s\", callable, rate);\n+    Instant delayInstance = Instant.now().plusMillis(initialDelay.getMillis());\n+    exec.scheduleAt(delayInstance,", "originalCommit": "20f7fe61551d1f3afeaeb06c245089aa4569f568", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4NjkyNg==", "url": "https://github.com/apache/druid/pull/10448#discussion_r507186926", "bodyText": "That makes sense. I'll change this.", "author": "ayushkul2910", "createdAt": "2020-10-18T17:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0MTcwMg==", "url": "https://github.com/apache/druid/pull/10448#discussion_r511941702", "bodyText": "Hey @leventov, do you think the below implementation for startMonitor(final Monitor monitor) method in MonitorScheduler class will suffice? Also, can this cause any inconsistency  since scheduledFuture is volatile and is shared amongst all the monitors?\nsynchronized (lock) {\n  monitor.start();\n  Long rate = config.getEmitterPeriod().getMillis();\n  scheduledFuture = scheduler.scheduleAtFixedRate(\n      rate,\n      rate,\n      TimeUnit.MILLISECONDS,\n      new CronTask()\n      {\n        @Override\n        public void run(long scheduledRunTimeMillis)\n        {\n          try {\n            if (monitor.monitor(emitter) && hasMonitor(monitor)) {\n              log.trace(\"Running %s (period %s)\", this, rate);\n            } else {\n              log.debug(\"Stopping rescheduling %s (delay %s)\", this, rate);\n              removeMonitor(monitor);\n              while (scheduledFuture == null) {\n                Thread.sleep(1);\n              }\n              scheduledFuture.cancel(false);\n            }\n          } catch (Throwable e) {\n            log.error(e, \"Uncaught exception.\");\n          }\n        }\n      });\n}", "author": "ayushkul2910", "createdAt": "2020-10-26T13:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMzE5Mw==", "url": "https://github.com/apache/druid/pull/10448#discussion_r512203193", "bodyText": "There should be a separate future for every monitor. I also think there should be a separate executorService for running monitor.monitor(emitter), and cancelling the future from the first monitor, for two reasons:\n\nMonitor code is not guaranteed to be non-blocking and \"cheap\", which is the requirement of CronScheduler;\nYou can avoid having a race condition of cancelling a future on the first iteration when it's not yet created.", "author": "leventov", "createdAt": "2020-10-26T19:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYwODUyNw==", "url": "https://github.com/apache/druid/pull/10448#discussion_r512608527", "bodyText": "Keeping the above points in mind, I think this implementation will do.\nsynchronized (lock) {\n  monitor.start();\n  Long rate = config.getEmitterPeriod().getMillis();\n  Future<?> scheduledFuture = scheduler.scheduleAtFixedRate(\n      rate,\n      rate,\n      TimeUnit.MILLISECONDS,\n      new CronTask()\n      {\n        private volatile Future<Boolean> monitorFuture = null;\n        @Override\n        public void run(long scheduledRunTimeMillis)\n        {\n          try {\n            if (monitorFuture != null && monitorFuture.isDone()\n                && !(monitorFuture.get() && hasMonitor(monitor))) {\n              removeMonitor(monitor);\n              monitor.getScheduledFuture().cancel(false);\n              log.debug(\"Stopped rescheduling %s (delay %s)\", this, rate);\n              return;\n            }\n            \n            log.trace(\"Running %s (period %s)\", this, rate);\n            monitorFuture = executor.submit(new Callable<Boolean>()\n            {\n              public Boolean call()\n              {\n                try {\n                  return monitor.monitor(emitter);\n                } catch (Throwable e) {\n                  log.error(e, \"Uncaught exception.\");\n                  return false;\n                }\n              }\n            });\n          } \n          catch (Throwable e) {\n            log.error(e, \"Uncaught exception.\");\n          }\n        }\n      });\n  monitor.setScheduledFuture(scheduledFuture);\n}\n\nIn this:\n\nEach monitor has a separate future.\nCron task is cheap, it checks a boolean condition. If condition is true it cancels the scheduling process for the particular monitor, else submits a callable for monitoring to executor service\nNo race condition for cancelling scheduledFuture on first iteration.\n\nPlease let me know your thoughts on this.", "author": "ayushkul2910", "createdAt": "2020-10-27T11:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg=="}], "type": "inlineReview"}, {"oid": "0de642c6f75cd378915d19ff6cf5514769e9fb0f", "url": "https://github.com/apache/druid/commit/0de642c6f75cd378915d19ff6cf5514769e9fb0f", "message": "added cronScheduler for fixed rate monitoring in MonitorScheduler", "committedDate": "2020-10-30T14:02:25Z", "type": "commit"}, {"oid": "a24eacb46a324946adce12edb437fec6ef40a986", "url": "https://github.com/apache/druid/commit/a24eacb46a324946adce12edb437fec6ef40a986", "message": "added override annotation", "committedDate": "2020-11-01T11:14:50Z", "type": "commit"}, {"oid": "10ba516b47068b83b1021142fc940c1b788ffce8", "url": "https://github.com/apache/druid/commit/10ba516b47068b83b1021142fc940c1b788ffce8", "message": "fixed checkstyle", "committedDate": "2020-11-01T12:10:51Z", "type": "commit"}, {"oid": "3af13a0e8cc43571969bead1ab787f5b5e2f8a6d", "url": "https://github.com/apache/druid/commit/3af13a0e8cc43571969bead1ab787f5b5e2f8a6d", "message": "changed executor to use cachedThreadPool", "committedDate": "2020-11-01T12:13:40Z", "type": "commit"}, {"oid": "62b3f303826064406db2517adfcef8758202e185", "url": "https://github.com/apache/druid/commit/62b3f303826064406db2517adfcef8758202e185", "message": "Merge branch 'master' of https://github.com/miqdigital/druid into cronScheduling", "committedDate": "2020-11-02T10:00:18Z", "type": "commit"}, {"oid": "d8628ad13629a4a8bbca52e3f6561276be7b5893", "url": "https://github.com/apache/druid/commit/d8628ad13629a4a8bbca52e3f6561276be7b5893", "message": "changed number of threads to 64", "committedDate": "2020-11-07T12:58:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjEwOQ==", "url": "https://github.com/apache/druid/pull/10448#discussion_r552386109", "bodyText": "This looks like an overkill. What was the rationale for using this many threads?", "author": "jihoonson", "createdAt": "2021-01-06T06:02:06Z", "path": "server/src/main/java/org/apache/druid/server/metrics/MetricsModule.java", "diffHunk": "@@ -108,10 +108,10 @@ public MonitorScheduler getMonitorScheduler(\n \n     return new MonitorScheduler(\n         config.get(),\n-        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorScheduler-%s\").build(),\n+        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorSchedulerThread\").build(),\n         emitter,\n         monitors,\n-        Executors.newCachedThreadPool()\n+        Execs.multiThreaded(64, \"MonitorThread-%d\")", "originalCommit": "d8628ad13629a4a8bbca52e3f6561276be7b5893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2MjM0OQ==", "url": "https://github.com/apache/druid/pull/10448#discussion_r553162349", "bodyText": "Hi @jihoonson , sorry for delay in response.\nI think currently there are ~20 monitors, which can run concurrently with the MonitorScheduler class. Suppose a case in which frequency of scheduling < time taken by the executor thread to do monitor.monitor(...)(Although I am not sure if this case is possible in practical, kind of edge case). This can result in queuing of the tasks if threads are very less. I think we should atleast have no. of threads equal to max number of monitors supported. I may be missing something here. What do you think?", "author": "ayushkul2910", "createdAt": "2021-01-07T07:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwNzg1NQ==", "url": "https://github.com/apache/druid/pull/10448#discussion_r553607855", "bodyText": "The monitor usually takes less than 1 sec (probably less than 100 ms) while the emission period is large enough to run all monitors (1 min by default). So, I think the scenario you described can happen when there are some failures such as retrying metrics emission due to some network issue. However, I don't think we should handle these failures by employing multiple threads because there is nothing we can do better with more threads. I would rather not schedule a new monitor task if the previous one is still running. I implemented this in #10732.", "author": "jihoonson", "createdAt": "2021-01-07T21:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg5MzM2OQ==", "url": "https://github.com/apache/druid/pull/10448#discussion_r553893369", "bodyText": "This makes sense, we should reduce the number of monitor threads.", "author": "ayushkul2910", "createdAt": "2021-01-08T11:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjEwOQ=="}], "type": "inlineReview"}]}