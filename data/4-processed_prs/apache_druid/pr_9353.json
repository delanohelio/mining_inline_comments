{"pr_number": 9353, "pr_title": "Inject things instead of subclassing everything for parallel task testing", "pr_createdAt": "2020-02-11T20:03:20Z", "pr_url": "https://github.com/apache/druid/pull/9353", "timeline": [{"oid": "71c613f8b4eba8a5a66a204283d75ca6b2778685", "url": "https://github.com/apache/druid/commit/71c613f8b4eba8a5a66a204283d75ca6b2778685", "message": "Inject things instead of subclassing everything for parallel task\ntesting", "committedDate": "2020-02-11T19:47:07Z", "type": "commit"}, {"oid": "215f2abb94eb7cc3362d201c8111e225e3a4e5c4", "url": "https://github.com/apache/druid/commit/215f2abb94eb7cc3362d201c8111e225e3a4e5c4", "message": "javadoc", "committedDate": "2020-02-11T20:02:40Z", "type": "commit"}, {"oid": "42438653704ae525289fcb765676e80807b52918", "url": "https://github.com/apache/druid/commit/42438653704ae525289fcb765676e80807b52918", "message": "fix compilation", "committedDate": "2020-02-11T20:45:11Z", "type": "commit"}, {"oid": "c69dd925ab3b23fd54cac1a5d001d4523725bde9", "url": "https://github.com/apache/druid/commit/c69dd925ab3b23fd54cac1a5d001d4523725bde9", "message": "fix wrong merge", "committedDate": "2020-02-12T01:22:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY5NTgxNw==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379695817", "bodyText": "This was previously a class member variable, so it was only allocated once. Is there a reason that's changed here?", "author": "ccaominh", "createdAt": "2020-02-15T00:02:48Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/batch/parallel/HttpShuffleClient.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.common.task.batch.parallel;\n+\n+import com.google.inject.Inject;\n+import org.apache.druid.guice.annotations.EscalatedClient;\n+import org.apache.druid.java.util.common.FileUtils;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.http.client.HttpClient;\n+import org.apache.druid.java.util.http.client.Request;\n+import org.apache.druid.java.util.http.client.response.InputStreamResponseHandler;\n+import org.jboss.netty.handler.codec.http.HttpMethod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.concurrent.ExecutionException;\n+\n+public class HttpShuffleClient implements ShuffleClient\n+{\n+  private static final int BUFFER_SIZE = 1024 * 4;\n+  private static final int NUM_FETCH_RETRIES = 3;\n+\n+  private final HttpClient httpClient;\n+\n+  @Inject\n+  public HttpShuffleClient(@EscalatedClient HttpClient httpClient)\n+  {\n+    this.httpClient = httpClient;\n+  }\n+\n+  @Override\n+  public <T, P extends PartitionLocation<T>> File fetchSegmentFile(\n+      File partitionDir,\n+      String supervisorTaskId,\n+      P location\n+  ) throws IOException\n+  {\n+    final byte[] buffer = new byte[BUFFER_SIZE];", "originalCommit": "c69dd925ab3b23fd54cac1a5d001d4523725bde9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg4Mjk3OA==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379882978", "bodyText": "This method can be called by multiple threads at the same time with the Indexer. Added comments.", "author": "jihoonson", "createdAt": "2020-02-16T07:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY5NTgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY5NTkzMA==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379695930", "bodyText": "Is it worth adding unit tests for this method?", "author": "ccaominh", "createdAt": "2020-02-15T00:03:31Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/batch/parallel/HttpShuffleClient.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.indexing.common.task.batch.parallel;\n+\n+import com.google.inject.Inject;\n+import org.apache.druid.guice.annotations.EscalatedClient;\n+import org.apache.druid.java.util.common.FileUtils;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.http.client.HttpClient;\n+import org.apache.druid.java.util.http.client.Request;\n+import org.apache.druid.java.util.http.client.response.InputStreamResponseHandler;\n+import org.jboss.netty.handler.codec.http.HttpMethod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.concurrent.ExecutionException;\n+\n+public class HttpShuffleClient implements ShuffleClient\n+{\n+  private static final int BUFFER_SIZE = 1024 * 4;\n+  private static final int NUM_FETCH_RETRIES = 3;\n+\n+  private final HttpClient httpClient;\n+\n+  @Inject\n+  public HttpShuffleClient(@EscalatedClient HttpClient httpClient)\n+  {\n+    this.httpClient = httpClient;\n+  }\n+\n+  @Override\n+  public <T, P extends PartitionLocation<T>> File fetchSegmentFile(", "originalCommit": "c69dd925ab3b23fd54cac1a5d001d4523725bde9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg4Mjk4Nw==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379882987", "bodyText": "Added some.", "author": "jihoonson", "createdAt": "2020-02-16T07:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY5NTkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwMjI3Nw==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379702277", "bodyText": "Suggestion: Rename to something like DISABLE_TASK_INJECT_CONTEXT_KEY.", "author": "ccaominh", "createdAt": "2020-02-15T00:45:09Z", "path": "indexing-service/src/test/java/org/apache/druid/indexing/common/task/batch/parallel/AbstractParallelIndexSupervisorTaskTest.java", "diffHunk": "@@ -35,53 +43,80 @@\n import org.apache.druid.data.input.impl.TimestampSpec;\n import org.apache.druid.indexer.RunnerTaskState;\n import org.apache.druid.indexer.TaskLocation;\n-import org.apache.druid.indexer.TaskState;\n import org.apache.druid.indexer.TaskStatus;\n import org.apache.druid.indexer.TaskStatusPlus;\n+import org.apache.druid.indexing.common.RetryPolicyConfig;\n+import org.apache.druid.indexing.common.RetryPolicyFactory;\n+import org.apache.druid.indexing.common.SegmentLoaderFactory;\n import org.apache.druid.indexing.common.TaskInfoProvider;\n import org.apache.druid.indexing.common.TaskToolbox;\n+import org.apache.druid.indexing.common.TestUtils;\n+import org.apache.druid.indexing.common.actions.TaskActionClient;\n import org.apache.druid.indexing.common.config.TaskConfig;\n import org.apache.druid.indexing.common.stats.DropwizardRowIngestionMetersFactory;\n+import org.apache.druid.indexing.common.stats.RowIngestionMetersFactory;\n+import org.apache.druid.indexing.common.task.CompactionTask;\n import org.apache.druid.indexing.common.task.IndexTaskClientFactory;\n import org.apache.druid.indexing.common.task.IngestionTestBase;\n import org.apache.druid.indexing.common.task.NoopTestTaskReportFileWriter;\n import org.apache.druid.indexing.common.task.Task;\n import org.apache.druid.indexing.common.task.TaskResource;\n import org.apache.druid.indexing.common.task.TestAppenderatorsManager;\n+import org.apache.druid.indexing.overlord.Segments;\n import org.apache.druid.indexing.worker.IntermediaryDataManager;\n import org.apache.druid.indexing.worker.config.WorkerConfig;\n import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.IAE;\n import org.apache.druid.java.util.common.ISE;\n import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.math.expr.ExprMacroTable;\n import org.apache.druid.metadata.EntryExistsException;\n+import org.apache.druid.query.expression.LookupEnabledTestExprMacroTable;\n+import org.apache.druid.segment.IndexIO;\n import org.apache.druid.segment.join.NoopJoinableFactory;\n+import org.apache.druid.segment.loading.LocalDataSegmentPuller;\n import org.apache.druid.segment.loading.LocalDataSegmentPusher;\n import org.apache.druid.segment.loading.LocalDataSegmentPusherConfig;\n import org.apache.druid.segment.loading.NoopDataSegmentKiller;\n import org.apache.druid.segment.loading.StorageLocationConfig;\n+import org.apache.druid.segment.realtime.appenderator.AppenderatorsManager;\n import org.apache.druid.segment.realtime.appenderator.SegmentIdWithShardSpec;\n+import org.apache.druid.segment.realtime.firehose.ChatHandlerProvider;\n import org.apache.druid.segment.realtime.firehose.NoopChatHandlerProvider;\n import org.apache.druid.server.DruidNode;\n import org.apache.druid.server.security.AllowAllAuthorizer;\n+import org.apache.druid.server.security.AuthConfig;\n import org.apache.druid.server.security.Authorizer;\n import org.apache.druid.server.security.AuthorizerMapper;\n+import org.apache.druid.timeline.DataSegment;\n+import org.apache.druid.timeline.SegmentId;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n import org.joda.time.DateTime;\n import org.joda.time.Duration;\n+import org.joda.time.Interval;\n+import org.junit.After;\n+import org.junit.Before;\n import org.junit.Rule;\n import org.junit.rules.TemporaryFolder;\n \n import javax.annotation.Nullable;\n import java.io.File;\n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Future;\n \n public class AbstractParallelIndexSupervisorTaskTest extends IngestionTestBase\n {\n+  static final String DISABLE_INJECT_CONTEXT_KEY = \"disableInject\";", "originalCommit": "c69dd925ab3b23fd54cac1a5d001d4523725bde9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg4Mjk4OQ==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379882989", "bodyText": "Done.", "author": "jihoonson", "createdAt": "2020-02-16T07:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwMjI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwMjk2OQ==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379702969", "bodyText": "Previously, tests would be able to specify a timeout, which is useful for failing tests sooner than the travis timeout.", "author": "ccaominh", "createdAt": "2020-02-15T00:50:34Z", "path": "indexing-service/src/test/java/org/apache/druid/indexing/common/task/batch/parallel/AbstractParallelIndexSupervisorTaskTest.java", "diffHunk": "@@ -151,127 +195,196 @@ protected void initializeIntermediaryDataManager() throws IOException\n         ),\n         null\n     );\n+    LocalShuffleClient shuffleClient = new LocalShuffleClient(intermediaryDataManager);\n+    coordinatorClient = new LocalCoordinatorClient();\n+    prepareObjectMapper(\n+        objectMapper,\n+        getIndexIO(),\n+        indexingServiceClient,\n+        indexTaskClientFactory,\n+        shuffleClient,\n+        coordinatorClient\n+    );\n   }\n \n-  public class LocalIndexingServiceClient extends NoopIndexingServiceClient\n+  @After\n+  public void tearDownAbstractParallelIndexSupervisorTaskTest()\n+  {\n+    taskRunner.shutdown();\n+    temporaryFolder.delete();\n+  }\n+\n+  protected LocalIndexingServiceClient getIndexingServiceClient()\n+  {\n+    return indexingServiceClient;\n+  }\n+\n+  protected IndexTaskClientFactory<ParallelIndexSupervisorTaskClient> getParallelIndexTaskClientFactory()\n+  {\n+    return indexTaskClientFactory;\n+  }\n+\n+  protected CoordinatorClient getCoordinatorClient()\n   {\n-    private final ConcurrentMap<String, Future<TaskStatus>> tasks = new ConcurrentHashMap<>();\n+    return coordinatorClient;\n+  }\n+\n+  private static class TaskContainer\n+  {\n+    private final Task task;\n+    @MonotonicNonNull\n+    private volatile Future<TaskStatus> statusFuture;\n+    @MonotonicNonNull\n+    private volatile TestLocalTaskActionClient actionClient;\n+\n+    private TaskContainer(Task task)\n+    {\n+      this.task = task;\n+    }\n+\n+    private void setStatusFuture(Future<TaskStatus> statusFuture)\n+    {\n+      this.statusFuture = statusFuture;\n+    }\n+\n+    private void setActionClient(TestLocalTaskActionClient actionClient)\n+    {\n+      this.actionClient = actionClient;\n+    }\n+  }\n+\n+  public class SimpleThreadingTaskRunner\n+  {\n+    private final ConcurrentMap<String, TaskContainer> tasks = new ConcurrentHashMap<>();\n     private final ListeningExecutorService service = MoreExecutors.listeningDecorator(\n-        Execs.multiThreaded(5, \"parallel-index-supervisor-task-test-%d\")\n+        Execs.multiThreaded(5, \"simple-threading-task-runner-%d\")\n     );\n \n-    @Override\n-    public String runTask(Object taskObject)\n+    public String run(Task task)\n+    {\n+      runTask(task);\n+      return task.getId();\n+    }\n+\n+    private TaskStatus runAndWait(Task task)\n     {\n-      final Task subTask = (Task) taskObject;\n       try {\n-        getTaskStorage().insert(subTask, TaskStatus.running(subTask.getId()));\n+        return runTask(task).get();\n       }\n-      catch (EntryExistsException e) {\n+      catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        throw new RuntimeException(e);\n+      }\n+      catch (ExecutionException e) {\n         throw new RuntimeException(e);\n       }\n+    }\n \n-      // WARNING: In production, subtasks are created via HTTP calls and instantiated by Jackson, which means they\n-      // cannot share objects like they can here. For example, if the indexing task uses JsonParseSpec, the same\n-      // JSONFlattenerMaker instance is shared among subtasks, which is bad since JSONFlattenerMaker is not thread-safe.\n-      tasks.put(subTask.getId(), service.submit(() -> {\n-        try {\n-          final TaskToolbox toolbox = createTaskToolbox(subTask);\n-          if (subTask.isReady(toolbox.getTaskActionClient())) {\n-            return subTask.run(toolbox);\n-          } else {\n-            getTaskStorage().setStatus(TaskStatus.failure(subTask.getId()));\n-            throw new ISE(\"task[%s] is not ready\", subTask.getId());\n-          }\n-        }\n-        catch (Exception e) {\n-          getTaskStorage().setStatus(TaskStatus.failure(subTask.getId(), e.getMessage()));\n-          throw new RuntimeException(e);\n+    private TaskStatus waitToFinish(Task task)\n+    {\n+      final TaskContainer taskContainer = tasks.get(task.getId());\n+      if (taskContainer == null) {\n+        throw new IAE(\"Unknown task[%s]\", task.getId());\n+      }\n+      try {\n+        while (taskContainer.statusFuture == null && !Thread.currentThread().isInterrupted()) {\n+          Thread.sleep(10);\n         }\n-      }));\n-      return subTask.getId();\n+        return taskContainer.statusFuture.get();", "originalCommit": "c69dd925ab3b23fd54cac1a5d001d4523725bde9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg4MzAwMA==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379883000", "bodyText": "Added the timeout back.", "author": "jihoonson", "createdAt": "2020-02-16T07:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwMjk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwMzI5Mw==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379703293", "bodyText": "If the interval had been a named constant for the class, then updating it for all of the tests would have been easier. Perhaps it's worth creating the named constant now.", "author": "ccaominh", "createdAt": "2020-02-15T00:53:07Z", "path": "indexing-service/src/test/java/org/apache/druid/indexing/common/task/batch/parallel/SinglePhaseParallelIndexingTest.java", "diffHunk": "@@ -197,62 +182,52 @@ private void testRunAndOverwrite(@Nullable Interval inputInterval, Granularity s\n   }\n \n   @Test\n-  public void testWithoutInterval() throws Exception\n+  public void testWithoutInterval()\n   {\n     testRunAndOverwrite(null, Granularities.DAY);\n   }\n \n   @Test()\n-  public void testRunInParallel() throws Exception\n+  public void testRunInParallel()\n   {\n     // Ingest all data.\n-    testRunAndOverwrite(Intervals.of(\"2017/2018\"), Granularities.DAY);\n+    testRunAndOverwrite(Intervals.of(\"2017-12/P1M\"), Granularities.DAY);", "originalCommit": "c69dd925ab3b23fd54cac1a5d001d4523725bde9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg4MzAwOA==", "url": "https://github.com/apache/druid/pull/9353#discussion_r379883008", "bodyText": "Hmm, since the test data is generated in each class, I think it's better to have the constant separately in each class as well. Added constants.", "author": "jihoonson", "createdAt": "2020-02-16T07:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwMzI5Mw=="}], "type": "inlineReview"}, {"oid": "663edd1c9652c88c67175e1e100d99df99e360f8", "url": "https://github.com/apache/druid/commit/663edd1c9652c88c67175e1e100d99df99e360f8", "message": "Address comments", "committedDate": "2020-02-16T07:55:13Z", "type": "commit"}]}