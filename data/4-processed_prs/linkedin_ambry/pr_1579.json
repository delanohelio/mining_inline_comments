{"pr_number": 1579, "pr_title": "Change java ByteBuffer to netty ByteBuf in request and response.", "pr_createdAt": "2020-06-25T18:13:00Z", "pr_url": "https://github.com/linkedin/ambry/pull/1579", "timeline": [{"oid": "c1977ce64ce06498055506203e48143021b2bbe8", "url": "https://github.com/linkedin/ambry/commit/c1977ce64ce06498055506203e48143021b2bbe8", "message": "Protocol works", "committedDate": "2020-06-26T06:03:15Z", "type": "forcePushed"}, {"oid": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "url": "https://github.com/linkedin/ambry/commit/9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "message": "Update the AmbrySendToHttp2Adapter", "committedDate": "2020-06-26T18:23:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxNTA5Mw==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446415093", "bodyText": "Http2NetworkClient throws an exception\nrelease\n[2020-06-26 14:16:03,876] WARN An exception was thrown by com.github.ambry.network.http2.Http2NetworkClient$1.operationComplete() (io.netty.util.concurrent.DefaultPromise)\nio.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1\n\tat io.netty.util.internal.ReferenceCountUpdater.toLiveRealRefCnt(ReferenceCountUpdater.java:74)\n\tat io.netty.util.internal.ReferenceCountUpdater.release(ReferenceCountUpdater.java:138)\n\tat io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:100)\n\tat com.github.ambry.protocol.PutRequest.release(PutRequest.java:269)\n\nNetty write decrease the ref cnt, but it doesn't set the variable to null. So we hit above exception.", "author": "zzmao", "createdAt": "2020-06-26T21:20:05Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/PutRequest.java", "diffHunk": "@@ -175,93 +179,95 @@ private int sizeExcludingBlobAndCrcSize() {\n    * Construct the bufferToSend to serialize request metadata and other blob related information. The newly constructed\n    * bufferToSend will not include the blob content as it's carried by the {@code blob} field in this class.\n    */\n-  private void prepareBuffer() {\n-    bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+  @Override\n+  protected void prepareBuffer() {\n+    bufferToSend = PooledByteBufAllocator.DEFAULT.heapBuffer(sizeExcludingBlobAndCrcSize());\n     writeHeader();\n-    int crcStart = bufferToSend.position();\n-    bufferToSend.put(blobId.toBytes());\n+    int crcStart = bufferToSend.writerIndex();\n+    bufferToSend.writeBytes(blobId.toBytes());\n     BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-    bufferToSend.putInt(usermetadata.capacity());\n-    bufferToSend.put(usermetadata);\n-    bufferToSend.putShort((short) blobType.ordinal());\n+    bufferToSend.writeInt(usermetadata.capacity());\n+    bufferToSend.writeBytes(usermetadata);\n+    bufferToSend.writeShort((short) blobType.ordinal());\n     short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-    bufferToSend.putShort(keyLength);\n+    bufferToSend.writeShort(keyLength);\n     if (keyLength > 0) {\n-      bufferToSend.put(blobEncryptionKey);\n+      bufferToSend.writeBytes(blobEncryptionKey);\n     }\n-    bufferToSend.putLong(blobSize);\n-    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n-    nioBuffersFromBlob = blob.nioBuffers();\n-    for (ByteBuffer bb : nioBuffersFromBlob) {\n+    bufferToSend.writeLong(blobSize);\n+    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.writerIndex() - crcStart);\n+    for (ByteBuffer bb : blob.nioBuffers()) {\n       crc.update(bb);\n       // change it back to 0 since we are going to write it to the channel later.\n       bb.position(0);\n     }\n-    crcBuf.putLong(crc.getValue());\n-    crcBuf.flip();\n-    bufferToSend.flip();\n+    crcByteBuf.writeLong(crc.getValue());\n+\n+    CompositeByteBuf compositeByteBuf = bufferToSend.alloc().compositeHeapBuffer(2 + blob.nioBufferCount());\n+    compositeByteBuf.addComponent(true, bufferToSend);\n+    if (blob instanceof CompositeByteBuf) {\n+      Iterator<ByteBuf> iter = ((CompositeByteBuf) blob).iterator();\n+      while (iter.hasNext()) {\n+        compositeByteBuf.addComponent(true, iter.next());\n+      }\n+    } else {\n+      compositeByteBuf.addComponent(true, blob);\n+    }\n+    compositeByteBuf.addComponent(true, crcByteBuf);\n+    blob = null;\n+    crcByteBuf = null;\n+    bufferToSend = compositeByteBuf;\n   }\n \n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n+    if (bufferToSend == null) {\n+      prepareBuffer();\n+    }\n+    if (nioBuffers == null) {\n+      nioBuffers = bufferToSend.nioBuffers();\n+    }\n     long written = 0;\n-    try {\n-      if (sentBytes < sizeInBytes()) {\n-        if (bufferToSend == null) {\n-          // this is the first time this method was called, prepare the buffer to send the header and other metadata\n-          // (everything except the blob content).\n-          prepareBuffer();\n-        }\n-        // If the header and metadata are not yet written out completely, try and write out as much of it now.\n-        if (bufferToSend.hasRemaining()) {\n-          written = channel.write(bufferToSend);\n-        }\n-\n-        // If the header and metadata were written out completely (in this call or a previous call),\n-        // try and write out as much of the blob now.\n-        if (!bufferToSend.hasRemaining() && blob != null) {\n-          int totalWrittenBytesForBlob = 0, currentWritten = -1;\n-          while (bufferIndex < nioBuffersFromBlob.length && currentWritten != 0) {\n-            currentWritten = -1;\n-            ByteBuffer byteBuffer = nioBuffersFromBlob[bufferIndex];\n-            if (!byteBuffer.hasRemaining()) {\n-              // some bytebuffers are zero length, ignore those bytebuffers.\n-              bufferIndex ++;\n-            } else {\n-              currentWritten = channel.write(byteBuffer);\n-              totalWrittenBytesForBlob += currentWritten;\n-            }\n-          }\n-          blob.skipBytes(totalWrittenBytesForBlob);\n-          written += totalWrittenBytesForBlob;\n-          okayToWriteCrc = !blob.isReadable();\n-        }\n-\n-        if (okayToWriteCrc && crcBuf.hasRemaining()) {\n-          if (blob != null) {\n-            blob.release();\n-            blob = null;\n-          }\n-          written += channel.write(crcBuf);\n+    if (sentBytes < sizeInBytes()) {\n+      int totalWrittenBytes = 0, currentWritten = -1;\n+      while (bufferIndex < nioBuffers.length && currentWritten != 0) {\n+        currentWritten = -1;\n+        ByteBuffer byteBuffer = nioBuffers[bufferIndex];\n+        if (!byteBuffer.hasRemaining()) {\n+          // some bytebuffers are zero length, ignore those bytebuffers.\n+          bufferIndex++;\n+        } else {\n+          currentWritten = channel.write(byteBuffer);\n+          totalWrittenBytes += currentWritten;\n         }\n-\n-        sentBytes += written;\n-      }\n-    } catch (Exception e) {\n-      if (blob != null) {\n-        blob.release();\n-        blob = null;\n       }\n+      bufferToSend.skipBytes(totalWrittenBytes);\n+      written += totalWrittenBytes;\n     }\n+    sentBytes += written;\n     return written;\n   }\n \n+  /**\n+   * Override release even if the {@link #content()}'s result is not null. When the {@link #prepareBuffer()} is\n+   * not invoked, there will be {@link #blob} and {@link #crcByteBuf} created but not returned by {@link #content()},\n+   * and we have to release them.\n+   * @return\n+   */\n   @Override\n-  public void release() {\n+  public boolean release() {\n     if (blob != null) {\n       blob.release();", "originalCommit": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxOTYxNw==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446419617", "bodyText": "I purposely didn't set the content to null so we don't release it multiple times. Where does it get released before? Can we figure that out?", "author": "justinlin-linkedin", "createdAt": "2020-06-26T21:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxNTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyOTc1Mg==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447129752", "bodyText": "In Http2NetworkClient::sendAndPoll()\n                  // release related bytebuf\n                  requestInfo.getRequest().release();\n\nThis is called in the success case, but with your PR, this no longer needed.", "author": "zzmao", "createdAt": "2020-06-29T17:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxNTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NTE2OQ==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446445169", "bodyText": "One alternative to having Send always extend ByteBufHolder would be to have users do an instanceof check to see if it implements ByteBufHolder. However, if we intend to have almost all impls eventually support this, the way you have it is probably preferable. But there seem to be a ton of implementations of send where content just returns null.", "author": "cgtz", "createdAt": "2020-06-26T23:01:51Z", "path": "ambry-api/src/main/java/com/github/ambry/network/Send.java", "diffHunk": "@@ -52,7 +54,9 @@ default void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n   long sizeInBytes();\n \n   /**\n-   * Release all the resource this object holds. Make this a default method so subclasses don't have to override it.\n+   * Return the data which is held by this {@link ByteBufHolder}. The result could be null, if it's null,", "originalCommit": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3NzAwNQ==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446477005", "bodyText": "Eventually we will support it. All the MessageFormatSend's bytes are ready in memory, I don't see a reason why not to support it in the future.", "author": "justinlin-linkedin", "createdAt": "2020-06-27T03:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NTE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NjIyNA==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446446224", "bodyText": "can this import be removed?", "author": "cgtz", "createdAt": "2020-06-26T23:06:48Z", "path": "ambry-api/src/main/java/com/github/ambry/store/MessageReadSet.java", "diffHunk": "@@ -15,6 +15,7 @@\n \n import com.github.ambry.router.AsyncWritableChannel;\n import com.github.ambry.router.Callback;\n+import io.netty.buffer.ByteBuf;", "originalCommit": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0OTg1Ng==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446449856", "bodyText": "My understanding of this code was that an entry was only added to this map if the request is given a valid connection (line 215-225 would take out of pendingConnectionsToAssociatedRequests and add to correlationIdInFlightToConnectionId and connectionIdToRequestInFlight). Adding to the map would mean that this block of code handling connection checkout timeouts would never be executed for that connection. Am I missing an edge case here?", "author": "cgtz", "createdAt": "2020-06-26T23:23:46Z", "path": "ambry-network/src/main/java/com/github/ambry/network/SocketNetworkClient.java", "diffHunk": "@@ -158,14 +156,19 @@ public SocketNetworkClient(Selector selector, NetworkConfig networkConfig, Netwo\n       if (time.milliseconds() - requestMetadata.requestQueuedAtMs > checkoutTimeoutMs) {\n         responseInfoList.add(\n             new ResponseInfo(requestMetadata.requestInfo, NetworkClientErrorCode.ConnectionUnavailable, null));\n+        requestMetadata.requestInfo.getRequest().release();\n         logger.trace(\"Failing request to host {} port {} due to connection unavailability\",\n             requestMetadata.requestInfo.getHost(), requestMetadata.requestInfo.getPort());\n         iter.remove();\n-        requestMetadata.requestInfo.getRequest().release();\n         if (requestMetadata.pendingConnectionId != null) {\n           pendingConnectionsToAssociatedRequests.remove(requestMetadata.pendingConnectionId);\n           requestMetadata.pendingConnectionId = null;\n         }\n+        String connId =\n+            correlationIdInFlightToConnectionId.get(requestMetadata.requestInfo.getRequest().getCorrelationId());\n+        if (connId != null) {\n+          connectionIdToRequestInFlight.remove(connId);", "originalCommit": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3NjgxNw==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446476817", "bodyText": "I suppose we should checkin the connection here. There is a chance that when a request is associated with a connection and somehow it takes so long to send it out that this request just times out. In this case, we are releasing the request's bytebuf here in this line 159, so we have to make sure the request is removed from all bookkeeping maps and sets.", "author": "justinlin-linkedin", "createdAt": "2020-06-27T03:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0OTg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ4MTM1Nw==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r448481357", "bodyText": "I guess this piece of code doesn't hurt. But I still don't see how correlationIdInFlightToConnectionId.get will ever return non-null at this point. This part of the code handles requests that do not yet have a connection to make the request over, and that map is only added to after a connection is checked out.\nOne confusing part of SocketNetworkClient is how the pending connection ID works. The pending connection ID is not actually checked out yet but is an indicator to show that a new connection is in the process of being established and will eventually be added to the pool but weirdly it doesn't guarantee that that specific connection is actually used for the request it was associated with.", "author": "cgtz", "createdAt": "2020-07-01T16:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0OTg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYzMzg5Mg==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r448633892", "bodyText": "I think we have a disagreement on whether a request can timeout after it gets associated with a connection id. I certainly think it's possible that even after a request has checked out a connection, it can still time out, due to slow outbound link, gc or some other reasons.\nIn MockSelector of unit tests, we do have a case where the MockSelector would throw IOException when sending out a request without disconnecting the connection. SocketNetworkClient won't remove this request from pending requests when seeing an IOException. So I take that we will retry this request, on the same connection, until it times out.", "author": "justinlin-linkedin", "createdAt": "2020-07-01T21:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0OTg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MDkyMg==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446450922", "bodyText": "nit: can just use requestMetadataToRelease.forEach", "author": "cgtz", "createdAt": "2020-06-26T23:29:33Z", "path": "ambry-network/src/main/java/com/github/ambry/network/SocketNetworkClient.java", "diffHunk": "@@ -377,19 +388,17 @@ private void handleSelectorEvents(List<ResponseInfo> responseInfoList) {\n    */\n   @Override\n   public void close() {\n+    Set<RequestMetadata> requestMetadataToRelease = new HashSet<>();\n     if (pendingRequests != null) {\n-      pendingRequests.forEach(requestMetadata -> {\n-        requestMetadata.requestInfo.getRequest().release();\n-      });\n-    } if (connectionIdToRequestInFlight != null) {\n-      connectionIdToRequestInFlight.values().forEach(requestMetadata -> {\n-        requestMetadata.requestInfo.getRequest().release();\n-      });\n-    } if (pendingConnectionsToAssociatedRequests != null) {\n-      pendingConnectionsToAssociatedRequests.values().forEach(requestMetadata -> {\n-        requestMetadata.requestInfo.getRequest().release();\n-      });\n+      requestMetadataToRelease.addAll(pendingRequests);\n+    }\n+    if (connectionIdToRequestInFlight != null) {\n+      requestMetadataToRelease.addAll(connectionIdToRequestInFlight.values());\n+    }\n+    if (pendingConnectionsToAssociatedRequests != null) {\n+      requestMetadataToRelease.addAll(pendingConnectionsToAssociatedRequests.values());\n     }\n+    requestMetadataToRelease.stream().forEach(requestMetadata -> requestMetadata.requestInfo.getRequest().release());", "originalCommit": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MTEyMw==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446451123", "bodyText": "extra println", "author": "cgtz", "createdAt": "2020-06-26T23:30:39Z", "path": "ambry-network/src/main/java/com/github/ambry/network/SocketNetworkClient.java", "diffHunk": "@@ -358,6 +360,15 @@ private void handleSelectorEvents(List<ResponseInfo> responseInfoList) {\n       networkMetrics.connectionDisconnected.inc();\n     }\n \n+    // Release all completed sends\n+    List<NetworkSend> completedSends = selector.completedSends();\n+    if (completedSends != null) {\n+      if (completedSends.size() > 0) {\n+        System.out.println(\"Release completed sends: \" + completedSends.size());", "originalCommit": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDg0Nw==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r446460847", "bodyText": "Remove this import?", "author": "cgtz", "createdAt": "2020-06-27T00:30:46Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/DeleteResponse.java", "diffHunk": "@@ -15,6 +15,7 @@\n \n import com.github.ambry.server.ServerErrorCode;\n import com.github.ambry.utils.Utils;\n+import io.netty.buffer.ByteBuf;", "originalCommit": "9d8875b70ae718f6c3605addb04fc9eee0e7efb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTg4NA==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447111884", "bodyText": "any reason not to use directBuffer?", "author": "zzmao", "createdAt": "2020-06-29T16:48:43Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/GetResponse.java", "diffHunk": "@@ -114,46 +122,111 @@ public static GetResponse readFrom(DataInputStream stream, ClusterMap map) throw\n    * {@link GetResponse#writeTo(AsyncWritableChannel, Callback)}.\n    * This method allocate bufferToSend and write metadata to it if bufferToSend is null.\n    */\n-  private void prepareBufferToSend() {\n-    if (bufferToSend == null) {\n-      bufferToSend = ByteBuffer.allocate(\n+  @Override\n+  protected void prepareBuffer() {\n+    if (toSend != null && toSend.content() != null) {\n+      bufferToSend = PooledByteBufAllocator.DEFAULT.heapBuffer((int) sizeInBytes());", "originalCommit": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwMTM5MQ==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447301391", "bodyText": "My thought on the heap buffer is that we started to manage the memory and it shouldn't be too bad to use heap memory for everything. I suppose we can start using direct memory for it.", "author": "justinlin-linkedin", "createdAt": "2020-06-29T22:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwNTcyMg==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447305722", "bodyText": "I remember direct memory is friendly for network data.", "author": "zzmao", "createdAt": "2020-06-29T22:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMzY0Nw==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447113647", "bodyText": "Not used.", "author": "zzmao", "createdAt": "2020-06-29T16:51:31Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/PutRequest.java", "diffHunk": "@@ -23,11 +23,15 @@\n import com.github.ambry.utils.CrcInputStream;\n import com.github.ambry.utils.Utils;\n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n import java.io.DataInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.ByteBuffer;\n import java.nio.channels.WritableByteChannel;\n+import java.util.ArrayList;", "originalCommit": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMTkzNA==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447121934", "bodyText": "Why explicitly use compositeHeapBuffer? I thought blob are direct buffers, no?", "author": "zzmao", "createdAt": "2020-06-29T17:05:10Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/PutRequest.java", "diffHunk": "@@ -175,93 +179,95 @@ private int sizeExcludingBlobAndCrcSize() {\n    * Construct the bufferToSend to serialize request metadata and other blob related information. The newly constructed\n    * bufferToSend will not include the blob content as it's carried by the {@code blob} field in this class.\n    */\n-  private void prepareBuffer() {\n-    bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+  @Override\n+  protected void prepareBuffer() {\n+    bufferToSend = PooledByteBufAllocator.DEFAULT.heapBuffer(sizeExcludingBlobAndCrcSize());\n     writeHeader();\n-    int crcStart = bufferToSend.position();\n-    bufferToSend.put(blobId.toBytes());\n+    int crcStart = bufferToSend.writerIndex();\n+    bufferToSend.writeBytes(blobId.toBytes());\n     BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-    bufferToSend.putInt(usermetadata.capacity());\n-    bufferToSend.put(usermetadata);\n-    bufferToSend.putShort((short) blobType.ordinal());\n+    bufferToSend.writeInt(usermetadata.capacity());\n+    bufferToSend.writeBytes(usermetadata);\n+    bufferToSend.writeShort((short) blobType.ordinal());\n     short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-    bufferToSend.putShort(keyLength);\n+    bufferToSend.writeShort(keyLength);\n     if (keyLength > 0) {\n-      bufferToSend.put(blobEncryptionKey);\n+      bufferToSend.writeBytes(blobEncryptionKey);\n     }\n-    bufferToSend.putLong(blobSize);\n-    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n-    nioBuffersFromBlob = blob.nioBuffers();\n-    for (ByteBuffer bb : nioBuffersFromBlob) {\n+    bufferToSend.writeLong(blobSize);\n+    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.writerIndex() - crcStart);\n+    for (ByteBuffer bb : blob.nioBuffers()) {\n       crc.update(bb);\n       // change it back to 0 since we are going to write it to the channel later.\n       bb.position(0);\n     }\n-    crcBuf.putLong(crc.getValue());\n-    crcBuf.flip();\n-    bufferToSend.flip();\n+    crcByteBuf.writeLong(crc.getValue());\n+\n+    CompositeByteBuf compositeByteBuf = bufferToSend.alloc().compositeHeapBuffer(2 + blob.nioBufferCount());", "originalCommit": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMjk3Mg==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447122972", "bodyText": "bufferToSend.alloc() -> PooledByteBufAllocator.DEFAULT?\nFeel we can use PooledByteBufAllocator.DEFAULT almost everywhere in the first few versions.", "author": "zzmao", "createdAt": "2020-06-29T17:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMTkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwNjI4Mg==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447306282", "bodyText": "here we at least have three separate bytebuf, first one is header bytebuf, second is blob content bytebuf, the third is the crc bytebuf. We don't want to create a new bytebuf and copy all three bytebufs to the newly created one. So here we create a compositebytebuf and just add the existing bytebufs to the the compositebytebuf to avoid extra copying.", "author": "justinlin-linkedin", "createdAt": "2020-06-29T22:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMTkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyNzk1Mw==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447127953", "bodyText": "The implementation overuses bufferToSend and caused some confusion when I looked at the code.\nHow about just set\nbufferToSend = PooledByteBufAllocator.DEFAULT.compositBuffer() in the beginning,\nthen allocate temp buffer for headers and write blob to bufferToSend,\nfinally return bufferToSend?", "author": "zzmao", "createdAt": "2020-06-29T17:16:02Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/PutRequest.java", "diffHunk": "@@ -175,93 +179,95 @@ private int sizeExcludingBlobAndCrcSize() {\n    * Construct the bufferToSend to serialize request metadata and other blob related information. The newly constructed\n    * bufferToSend will not include the blob content as it's carried by the {@code blob} field in this class.\n    */\n-  private void prepareBuffer() {\n-    bufferToSend = ByteBuffer.allocate(sizeExcludingBlobAndCrcSize());\n+  @Override\n+  protected void prepareBuffer() {\n+    bufferToSend = PooledByteBufAllocator.DEFAULT.heapBuffer(sizeExcludingBlobAndCrcSize());\n     writeHeader();\n-    int crcStart = bufferToSend.position();\n-    bufferToSend.put(blobId.toBytes());\n+    int crcStart = bufferToSend.writerIndex();\n+    bufferToSend.writeBytes(blobId.toBytes());\n     BlobPropertiesSerDe.serializeBlobProperties(bufferToSend, properties);\n-    bufferToSend.putInt(usermetadata.capacity());\n-    bufferToSend.put(usermetadata);\n-    bufferToSend.putShort((short) blobType.ordinal());\n+    bufferToSend.writeInt(usermetadata.capacity());\n+    bufferToSend.writeBytes(usermetadata);\n+    bufferToSend.writeShort((short) blobType.ordinal());\n     short keyLength = blobEncryptionKey == null ? 0 : (short) blobEncryptionKey.remaining();\n-    bufferToSend.putShort(keyLength);\n+    bufferToSend.writeShort(keyLength);\n     if (keyLength > 0) {\n-      bufferToSend.put(blobEncryptionKey);\n+      bufferToSend.writeBytes(blobEncryptionKey);\n     }\n-    bufferToSend.putLong(blobSize);\n-    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.position() - crcStart);\n-    nioBuffersFromBlob = blob.nioBuffers();\n-    for (ByteBuffer bb : nioBuffersFromBlob) {\n+    bufferToSend.writeLong(blobSize);\n+    crc.update(bufferToSend.array(), bufferToSend.arrayOffset() + crcStart, bufferToSend.writerIndex() - crcStart);\n+    for (ByteBuffer bb : blob.nioBuffers()) {\n       crc.update(bb);\n       // change it back to 0 since we are going to write it to the channel later.\n       bb.position(0);\n     }\n-    crcBuf.putLong(crc.getValue());\n-    crcBuf.flip();\n-    bufferToSend.flip();\n+    crcByteBuf.writeLong(crc.getValue());\n+\n+    CompositeByteBuf compositeByteBuf = bufferToSend.alloc().compositeHeapBuffer(2 + blob.nioBufferCount());\n+    compositeByteBuf.addComponent(true, bufferToSend);\n+    if (blob instanceof CompositeByteBuf) {\n+      Iterator<ByteBuf> iter = ((CompositeByteBuf) blob).iterator();\n+      while (iter.hasNext()) {\n+        compositeByteBuf.addComponent(true, iter.next());\n+      }\n+    } else {\n+      compositeByteBuf.addComponent(true, blob);\n+    }\n+    compositeByteBuf.addComponent(true, crcByteBuf);\n+    blob = null;\n+    crcByteBuf = null;\n+    bufferToSend = compositeByteBuf;", "originalCommit": "856ae8dfb2e885ffdd84d135fa5d6144ef531dab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwMTc4Ng==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447301786", "bodyText": "it's because writeHeader method after allocate the memory. writeHeader method always serialize the header into bufferToSend ByteBuf. So I have to create allocate bufferToSend as the header ByteBuf before calling writeHeader method.\nI will add more comments to clarify.", "author": "justinlin-linkedin", "createdAt": "2020-06-29T22:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyNzk1Mw=="}], "type": "inlineReview"}, {"oid": "489035ac900b2ff9960f0b83712c6a4c9a57cba8", "url": "https://github.com/linkedin/ambry/commit/489035ac900b2ff9960f0b83712c6a4c9a57cba8", "message": "More release", "committedDate": "2020-06-29T22:39:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNDY3OA==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447324678", "bodyText": "who releases the request if an IOException is thrown?", "author": "cgtz", "createdAt": "2020-06-29T23:54:57Z", "path": "ambry-network/src/main/java/com/github/ambry/network/BlockingChannel.java", "diffHunk": "@@ -171,6 +171,7 @@ public void send(Send request) throws IOException {\n     while (!request.isSendComplete()) {\n       request.writeTo(writeChannel);\n     }\n+    request.release();", "originalCommit": "8a5b8ade85ea6bf42370817328940c219613c5db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2Mjg3MQ==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447362871", "bodyText": "you are right, request should be released in all cases.", "author": "justinlin-linkedin", "createdAt": "2020-06-30T02:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNDY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzNjUyNA==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447336524", "bodyText": "any reason to not call sizeInBytes() here?", "author": "cgtz", "createdAt": "2020-06-30T00:29:48Z", "path": "ambry-protocol/src/main/java/com/github/ambry/protocol/GetResponse.java", "diffHunk": "@@ -114,46 +122,111 @@ public static GetResponse readFrom(DataInputStream stream, ClusterMap map) throw\n    * {@link GetResponse#writeTo(AsyncWritableChannel, Callback)}.\n    * This method allocate bufferToSend and write metadata to it if bufferToSend is null.\n    */\n-  private void prepareBufferToSend() {\n-    if (bufferToSend == null) {\n-      bufferToSend = ByteBuffer.allocate(\n+  @Override\n+  protected void prepareBuffer() {\n+    if (toSend != null && toSend.content() != null) {\n+      bufferToSend = PooledByteBufAllocator.DEFAULT.ioBuffer((int) sizeInBytes());\n+    } else {\n+      bufferToSend = PooledByteBufAllocator.DEFAULT.ioBuffer(\n           (int) super.sizeInBytes() + (Partition_Response_Info_List_Size + partitionResponseInfoSize));", "originalCommit": "8a5b8ade85ea6bf42370817328940c219613c5db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2NDMzOA==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447364338", "bodyText": "I made a mistake, bufferToSend should never allocate sizeInBytes() bytes.\nGetResponse is made of two parts, the metadata part and the data part.\nbufferToSend should only has metadata part, since the data is carried by toSend.\nif toSend doesn't support ByteBufHolder, then when writing GetResponse to network, we write bufferToSend first, and then toSend later.\nif toSend supports ByteBufHolder, then bufferToSend will be CompositeByteBuf later. This CompositeByteBuf contains metadata and data.", "author": "justinlin-linkedin", "createdAt": "2020-06-30T02:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzNjUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0MTQzMQ==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447841431", "bodyText": "Please help add a counter metric(channelNotWriteableCounter) before streamChannel.writeAndFlush()  .\nif (!streamChannel.isWriteable() || !streamChannel.parentChannel().isWriteable() ) {\nchannelNotWriteableCounter.inc()\n}", "author": "zzmao", "createdAt": "2020-06-30T17:02:52Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -107,6 +107,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                     http2ClientMetrics.http2StreamWriteAndFlushTime.update(\n                         System.currentTimeMillis() - streamAcquiredTime);\n                     requestInfo.setStreamSendTime(System.currentTimeMillis());\n+                    // When success, handler would release the request.", "originalCommit": "ee9bd56b6920be39cffd5c97fa1f902e716bf04c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0MzQ3Mw==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447843473", "bodyText": "also a warn message.", "author": "zzmao", "createdAt": "2020-06-30T17:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0MTQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg1MjA1OA==", "url": "https://github.com/linkedin/ambry/pull/1579#discussion_r447852058", "bodyText": "logger.warn(\"Stream {} {} not writable. BytesBeforeWritable {} {}\", streamChannel.hashCode(), streamChannel, streamChannel().bytesBeforeWritable(), streamChannel.parent().bytesBeforeWritable());", "author": "zzmao", "createdAt": "2020-06-30T17:19:38Z", "path": "ambry-network/src/main/java/com/github/ambry/network/http2/Http2NetworkClient.java", "diffHunk": "@@ -98,6 +98,10 @@ public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConf\n               long streamAcquiredTime = System.currentTimeMillis();\n               Channel streamChannel = future.getNow();\n               streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              if (!streamChannel.isWritable() || !streamChannel.parent().isWritable()) {\n+                http2ClientMetrics.http2StreamNotWritableCount.inc();\n+                logger.warn(\"Stream {} {} not writable\", streamChannel.hashCode(), streamChannel);", "originalCommit": "c092dba5e0d5bbe127b9f95c913e4dc2749ad28e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3", "url": "https://github.com/linkedin/ambry/commit/24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3", "message": "Change java ByteBuffer to netty ByteBuf in request and response.", "committedDate": "2020-07-13T17:35:03Z", "type": "commit"}, {"oid": "24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3", "url": "https://github.com/linkedin/ambry/commit/24761536a5bbb0ea2a8cfb5718e6ae959d76f4c3", "message": "Change java ByteBuffer to netty ByteBuf in request and response.", "committedDate": "2020-07-13T17:35:03Z", "type": "forcePushed"}]}