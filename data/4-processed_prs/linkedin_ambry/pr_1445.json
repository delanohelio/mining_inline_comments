{"pr_number": 1445, "pr_title": "Add support for cloud replicas to OperationTracker", "pr_createdAt": "2020-03-28T19:36:46Z", "pr_url": "https://github.com/linkedin/ambry/pull/1445", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1NzE5Nw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400557197", "bodyText": "Do we need to keep different inflightCount for diskReplica and cloudReplica separately? If inflightCount already contains request cloudReplica and we compare this number to parallelism of diskReplica might be wrong. Let's say diskReplica's parallelism is 3 and now there are 2 inflight diskReplica and 1 inflight cloudReplica, then hasNext may return false. However, the actual number of inflight diskReplica is less than parallelism of disk replica.", "author": "jsjtzyy", "createdAt": "2020-03-30T23:36:09Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -323,12 +352,13 @@ public void onResponse(ReplicaId replicaId, TrackedRequestFinalState trackedRequ\n   private class OpTrackerIterator implements Iterator<ReplicaId> {\n     @Override\n     public boolean hasNext() {\n-      return inflightCount < parallelism && replicaIterator.hasNext();\n+      return inflightCount < getCurrentParallelism() && replicaIterator.hasNext();", "originalCommit": "a695a482cbfe2d653b3050f28d450d280d3a2aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTczMjYyOA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401732628", "bodyText": "This is an interesting case. There is a question here about whether the cloud and disk parallelism can be summed or not. In your case the effective parallelism could be 4 since you are allowing both disk and cloud requests to reach full parallelism.\nHowever, I feel that although this increases the chance of success for the disk replicas, it is not completely necessary as a single acknowledgement from a cloud replica could satisfy the operation. The reason I decided to shrink the parallelism instead of summing it was to not waste a single cloud request by also sending requests to disk replicas at the same time. I notice that I also made an assumption that the requests are ordered by datacenter, which sometimes isn't true for the backup and down nodes.", "author": "cgtz", "createdAt": "2020-04-01T16:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1NzE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3NzUzOA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401777538", "bodyText": "I feel ok with current logic. Perhaps we can add debug log to help determine if the request being sent is cloudReplica request or disk one.", "author": "jsjtzyy", "createdAt": "2020-04-01T17:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU1NzE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MjIzNw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400562237", "bodyText": "Sorry, I am not sure if I wrote the comments, but this can be applied to GET as well", "author": "jsjtzyy", "createdAt": "2020-03-30T23:52:18Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -66,27 +69,32 @@\n class SimpleOperationTracker implements OperationTracker {\n   protected final String datacenterName;\n   protected final String originatingDcName;\n-  protected final int successTarget;\n-  protected final int parallelism;\n+  protected final int diskSuccessTarget;\n+  protected final int diskParallelism;\n+  protected final int cloudSuccessTarget;\n+  protected final int cloudParallelism;\n+  protected final boolean cloudReplicasPresent;\n+  // How many NotFound responses from originating dc will terminate the operation.\n+  // It's decided by the success target of each mutation operations, including put, delete, update ttl etc.\n+  protected final int originatingDcNotFoundFailureThreshold;", "originalCommit": "a695a482cbfe2d653b3050f28d450d280d3a2aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTczNDk3NA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401734974", "bodyText": "Changed the comment. The success target no longer has a part in this calculation after the dynamic target changes", "author": "cgtz", "createdAt": "2020-04-01T16:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MjIzNw=="}], "type": "inlineReview"}, {"oid": "161788d6547b3f3965ea99cce073786bffee2fc0", "url": "https://github.com/linkedin/ambry/commit/161788d6547b3f3965ea99cce073786bffee2fc0", "message": "Some unit test cases", "committedDate": "2020-03-31T00:19:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxOTA1NA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400619054", "bodyText": "Curious why this is max and not sum.  Is it not possible to have inflight disk and cloud requests at the same time?\nIf the logic is correct, then suggest breaking this into two checks so the error message can specify which one is out of bounds.", "author": "lightningrob", "createdAt": "2020-03-31T03:18:42Z", "path": "ambry-router/src/main/java/com.github.ambry.router/AdaptiveOperationTracker.java", "diffHunk": "@@ -83,7 +81,7 @@\n       localDcResourceToHistogram = getResourceToLatencyMap(routerOperation, true);\n       crossDcResourceToHistogram = getResourceToLatencyMap(routerOperation, false);\n     }\n-    if (parallelism > routerConfig.routerOperationTrackerMaxInflightRequests) {\n+    if (Math.max(diskParallelism, cloudParallelism) > routerConfig.routerOperationTrackerMaxInflightRequests) {", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2MTExOA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401961118", "bodyText": "I guess the reason we introduced routerOperationTrackerMaxInflightRequests is to throttle total # of request in regular data centers. So, although current number of disk requests equals MaxInflightRequests, router is still able to route request to cloud which is not restricted by MaxInflightRequests of regular dc(s).\nI agree with one point that we'd better break it into different checks and probably use separate MaxInflightRequests for cloud dc and regular dc.", "author": "jsjtzyy", "createdAt": "2020-04-01T23:06:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxOTA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3MTc0NA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401971744", "bodyText": "Yep, to expand on this, the adaptive operation tracker has the ability to go beyond the parallelism setting if requests are past due. This limit makes sure that it does not snowball and keep sending out parallel requests.", "author": "cgtz", "createdAt": "2020-04-01T23:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxOTA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMjAwMA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r402112000", "bodyText": "I added a second if for the constructor validations but kept the logic as is. Since max in flight requests is used when the number of requests made needs to go beyond the initial parallelism for performance reasons but isn't related to the quorum, I kept the config as is so that all in flight requests count towards the same limit.", "author": "cgtz", "createdAt": "2020-04-02T07:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxOTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYyNTUzMw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400625533", "bodyText": "Minor: can collapse to single line.", "author": "lightningrob", "createdAt": "2020-03-31T03:44:28Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -357,20 +388,40 @@ public ReplicaId next() {\n \n   private boolean hasFailed() {\n     boolean hasFailed;\n-    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget) {\n+    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget\n+        && inFlightReplicaType == ReplicaType.DISK_BACKED) {\n       hasFailed = totalReplicaCount - failedCount < Math.max(totalReplicaCount - 1,\n           routerConfig.routerPutSuccessTarget + disabledCount);\n     } else {\n-      hasFailed = (totalReplicaCount - failedCount) < successTarget || hasFailedOnNotFound();\n+      // if one type of replica has a lower success target, we can only call it a complete failure when there are fewer\n+      // than that target left to check. This could be optimized by saving the replica type of the remaining replicas\n+      // to try and choosing the success target based on their type.\n+      int minSuccessTarget = cloudReplicasPresent ? Math.min(diskSuccessTarget, cloudSuccessTarget) : diskSuccessTarget;\n+      hasFailed = (totalReplicaCount - failedCount) < minSuccessTarget || hasFailedOnNotFound();\n     }\n     return hasFailed;\n   }\n \n   /**\n-   * @return the success target number of this operation tracker.\n+   * @param replicaType the {@link ReplicaType}\n+   * @return the success target number of this operation tracker for the provided replica type.\n+   */\n+  int getSuccessTarget(ReplicaType replicaType) {\n+    if (replicaType == ReplicaType.CLOUD_BACKED) {\n+      return cloudSuccessTarget;\n+    } else {\n+      return diskSuccessTarget;\n+    }", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzMjAxNg==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400632016", "bodyText": "I'm having trouble following this logic.  Assuming there is a cloud replica present, totalReplicaCount = 13, minSuccessTarget will be 1, in which case failedCount has to equal totalReplicaCount to declare failure.  But if the cloud replica has failed, we will still require diskSuccessTarget successes among disk replicas - assume that is 2.  Then the most failures we can tolerate is 11 (10 disk + 1 cloud).  With failedCount = 12, hasFailed = (13-12 < 1) will be false but should be true, no?", "author": "lightningrob", "createdAt": "2020-03-31T04:10:44Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -357,20 +388,40 @@ public ReplicaId next() {\n \n   private boolean hasFailed() {\n     boolean hasFailed;\n-    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget) {\n+    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget\n+        && inFlightReplicaType == ReplicaType.DISK_BACKED) {\n       hasFailed = totalReplicaCount - failedCount < Math.max(totalReplicaCount - 1,\n           routerConfig.routerPutSuccessTarget + disabledCount);\n     } else {\n-      hasFailed = (totalReplicaCount - failedCount) < successTarget || hasFailedOnNotFound();\n+      // if one type of replica has a lower success target, we can only call it a complete failure when there are fewer\n+      // than that target left to check. This could be optimized by saving the replica type of the remaining replicas\n+      // to try and choosing the success target based on their type.\n+      int minSuccessTarget = cloudReplicasPresent ? Math.min(diskSuccessTarget, cloudSuccessTarget) : diskSuccessTarget;\n+      hasFailed = (totalReplicaCount - failedCount) < minSuccessTarget || hasFailedOnNotFound();", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0NzM4OQ==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401747389", "bodyText": "I guess this is a little rough to use the min. The reason I did that was to account for the case where the 13th replica was a cloud replica that could still satisfy the request with a success target of 1. However, this has the downside of wasting a request if that last replica was a disk replica.\nTo address this, I could do what the comment suggests and figure out the replica types of the remaining replicas. To avoid iterating through the entire list every time hasFailed is called, I could record the index of the last cloud replica and the last disk replica in the pool. If we are past the last replica of a certain type, switch to the other success target. Or, in this method, compare against the max success target and then if that returns true, make a second comparison by inspecting the remaining replicas in the pool (this should be a relatively smaller # of items to iterate through assuming success targets are small).\nDo either of these approaches sound better?", "author": "cgtz", "createdAt": "2020-04-01T16:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzMjAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5MjQyNg==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401792426", "bodyText": "Sounds like 1st approach is more efficient.", "author": "jsjtzyy", "createdAt": "2020-04-01T17:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzMjAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5NjkwNw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401796907", "bodyText": "In addition, let's also account for PUT operation when this is an Azure frontend. I feel like we need an extra else if for this case because the first if only applies to DiskReplica in regular dc(s).", "author": "jsjtzyy", "createdAt": "2020-04-01T17:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzMjAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NTcxMw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401975713", "bodyText": "Hi @jsjtzyy, for the put operation in azure, what condition were you thinking of where the logic will be different from the fallback policy? I feel like there is no concept of disabled for cloud replicas.", "author": "cgtz", "createdAt": "2020-04-01T23:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzMjAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExMDQzNA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r402110434", "bodyText": "For this condition I added a check in hasFailedOnNotFound to always return false on put operations. The condition would have returned false anyways given how we instantiate the operationtracker in PutOperation, but this makes it clearer.\nFor the failure threshold I changed the logic around a bit by counting how many replicas of each type are left. Using the success count for each type and this number, we can tell if a success is still possible or not for each type without requiring the hacky min logic", "author": "cgtz", "createdAt": "2020-04-02T07:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzMjAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzMjkzMQ==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400632931", "bodyText": "This logic looks correct.  I'm not convinced about the hasFailed logic, seems like that needs to use a similar OR condition.", "author": "lightningrob", "createdAt": "2020-03-31T04:14:42Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -261,11 +284,13 @@\n   @Override\n   public boolean hasSucceeded() {\n     boolean hasSucceeded;\n-    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget) {\n-      hasSucceeded =\n-          succeededCount >= Math.max(totalReplicaCount - disabledCount - 1, routerConfig.routerPutSuccessTarget);\n+    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget\n+        && inFlightReplicaType == ReplicaType.DISK_BACKED) {\n+      // this logic only applies to disk replicas where the quorum can change during replica movement\n+      int dynamicSuccessTarget = Math.max(totalReplicaCount - disabledCount - 1, routerConfig.routerPutSuccessTarget);\n+      hasSucceeded = diskSucceededCount >= dynamicSuccessTarget;\n     } else {\n-      hasSucceeded = succeededCount >= successTarget;\n+      hasSucceeded = diskSucceededCount >= diskSuccessTarget || cloudSucceededCount >= cloudSuccessTarget;", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzNDg0Mw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400634843", "bodyText": "Since both of these test cases succeed, shouldn't we also have one that fails?", "author": "lightningrob", "createdAt": "2020-03-31T04:22:59Z", "path": "ambry-router/src/test/java/com.github.ambry.router/OperationTrackerTest.java", "diffHunk": "@@ -923,11 +925,59 @@ public void operationClassTest() {\n       // ensure the success target matches the number specified for each type of operaiton\n       if (operationTracker != null) {\n         assertEquals(\"The suggest target doesn't match\", (long) entry.getValue(),\n-            (operationTracker).getSuccessTarget());\n+            operationTracker.getSuccessTarget(ReplicaType.DISK_BACKED));\n       }\n     }\n   }\n \n+  /**\n+   * Test cases with cloud replicas in the local datacenter.\n+   */\n+  @Test\n+  public void cloudReplicaInLocalDcTest() {\n+    // test success in cloud dc\n+    initializeWithCloudDcs(true);\n+    originatingDcName = getDatacenters(ReplicaType.DISK_BACKED).iterator().next();\n+    OperationTracker ot =\n+        getOperationTracker(true, 2, 3, false, Integer.MAX_VALUE, RouterOperation.GetBlobOperation, false);\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    // parallelism of 1 for cloud replicas, so only one request should be sent\n+    sendRequests(ot, 1, false);\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    ot.onResponse(inflightReplicas.poll(), TrackedRequestFinalState.SUCCESS);\n+    // success target of 1 with cloud replicas.\n+    assertTrue(\"Operation should have succeeded\", ot.hasSucceeded());\n+    assertTrue(\"Operation should be done\", ot.isDone());\n+  }\n+\n+  /**\n+   * Test cases with cloud replicas in the remote datacenter.\n+   */\n+  @Test\n+  public void cloudReplicaInRemoteDcTest() {\n+    // test failure in disk dc with fallback to cloud DC\n+    initializeWithCloudDcs(false);\n+    originatingDcName = getDatacenters(ReplicaType.CLOUD_BACKED).iterator().next();\n+    OperationTracker ot =\n+        getOperationTracker(true, 2, 3, false, Integer.MAX_VALUE, RouterOperation.GetBlobOperation, false);\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    // parallelism of 3 for disk replicas (local dc).\n+    sendRequests(ot, 3, false);\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    ot.onResponse(inflightReplicas.poll(), TrackedRequestFinalState.FAILURE);\n+    // one response frees up a spot to send a cloud request\n+    sendRequests(ot, 1, false);\n+    for (int i = 0; i < 2; i++) {\n+      ot.onResponse(inflightReplicas.poll(), TrackedRequestFinalState.FAILURE);\n+      // parallelism should have changed to 1 after cloud request was sent\n+      sendRequests(ot, 0, false);\n+    }\n+    assertFalse(\"Operation should not have been done.\", ot.isDone());\n+    ot.onResponse(inflightReplicas.poll(), TrackedRequestFinalState.SUCCESS);\n+    assertTrue(\"Operation should have succeeded\", ot.hasSucceeded());\n+    assertTrue(\"Operation should be done\", ot.isDone());\n+  }\n+", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0Nzg5OQ==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401747899", "bodyText": "Added some more test cases", "author": "cgtz", "createdAt": "2020-04-01T16:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzNDg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzNTc3Mg==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r400635772", "bodyText": "Should compare to replicaType, no?", "author": "lightningrob", "createdAt": "2020-03-31T04:26:56Z", "path": "ambry-router/src/test/java/com.github.ambry.router/OperationTrackerTest.java", "diffHunk": "@@ -944,19 +994,64 @@ private void initialize() {\n     mockClusterMap = new MockClusterMap(false, datanodes, 1, Collections.singletonList(mockPartition), localDcName);\n   }\n \n+  /**\n+   * Initialize 4 DCs, 2 disk datacenters, 2 cloud datacenters. Each disk datacenter has 3 replicas, and each cloud\n+   * datacenter has 1 replica.\n+   * @param makeCloudDcLocal {@code true} to make the local datacenter one of the cloud datacenters.\n+   */\n+  private void initializeWithCloudDcs(boolean makeCloudDcLocal) {\n+    List<Port> portList = Collections.singletonList(new Port(PORT, PortType.PLAINTEXT));\n+    List<String> mountPaths = Collections.singletonList(\"mockMountPath\");\n+    mockPartition = new MockPartitionId();\n+    List<MockDataNodeId> diskNodes = Arrays.asList(new MockDataNodeId(portList, mountPaths, \"dc-0\"),\n+        new MockDataNodeId(portList, mountPaths, \"dc-1\"));\n+    populateReplicaList(3 * diskNodes.size(), ReplicaState.STANDBY, diskNodes);\n+    List<MockDataNodeId> cloudNodes = Arrays.asList(new MockDataNodeId(portList, Collections.emptyList(), \"cloud-dc-0\"),\n+        new MockDataNodeId(portList, Collections.emptyList(), \"cloud-dc-1\"));\n+    // only one cloud replica per cloud dc.\n+    populateReplicaList(cloudNodes.size(), ReplicaState.STANDBY, cloudNodes);\n+    datanodes = new ArrayList<>();\n+    datanodes.addAll(diskNodes);\n+    datanodes.addAll(cloudNodes);\n+    localDcName = (makeCloudDcLocal ? cloudNodes : diskNodes).get(0).getDatacenterName();\n+    mockClusterMap = new MockClusterMap(false, datanodes, 1, Collections.singletonList(mockPartition), localDcName);\n+  }\n+\n   /**\n    * Populate replicas for a partition.\n    * @param replicaCount The number of replicas to populate.\n    * @param replicaState The {@link ReplicaState} associated with these replicas.\n    */\n   private void populateReplicaList(int replicaCount, ReplicaState replicaState) {\n+    populateReplicaList(replicaCount, replicaState, datanodes);\n+  }\n+\n+  /**\n+   * Populate replicas for a partition.\n+   * @param replicaCount The number of replicas to populate.\n+   * @param replicaState The {@link ReplicaState} associated with these replicas.\n+   * @param datanodes the datanodes to populate with replicas\n+   */\n+  private void populateReplicaList(int replicaCount, ReplicaState replicaState, List<MockDataNodeId> datanodes) {\n     for (int i = 0; i < replicaCount; i++) {\n       ReplicaId replicaId = new MockReplicaId(PORT, mockPartition, datanodes.get(i % datanodes.size()), 0);\n       mockPartition.replicaIds.add(replicaId);\n       mockPartition.replicaAndState.put(replicaId, replicaState);\n     }\n   }\n \n+  /**\n+   * @param replicaType the type of replica to filter by.\n+   * @return the datacenter names with replicas of type {@code replicaType}.\n+   */\n+  private Set<String> getDatacenters(ReplicaType replicaType) {\n+    return mockPartition.getReplicaIds()\n+        .stream()\n+        .filter(r -> r.getReplicaType() == ReplicaType.CLOUD_BACKED)", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2MjgxNQ==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401262815", "bodyText": "Yes, will fix this in my commit to add more tests and address comments.", "author": "cgtz", "createdAt": "2020-03-31T22:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYzNTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwMjg3OQ==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401202879", "bodyText": "To make it compatible, let's add similar check in StaticClusterManager.", "author": "jsjtzyy", "createdAt": "2020-03-31T20:43:16Z", "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/HelixClusterManager.java", "diffHunk": "@@ -316,10 +316,14 @@ public void onReplicaEvent(ReplicaId replicaId, ReplicaEventType event) {\n         replica.getDataNodeId().onNodeTimeout();\n         break;\n       case Disk_Error:\n-        replica.getDiskId().onDiskError();\n+        if (replica.getReplicaType() == ReplicaType.DISK_BACKED) {\n+          replica.getDiskId().onDiskError();\n+        }", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg0NTg4MA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401845880", "bodyText": "Right now, I only implemented CloudServiceReplicas for HelixClusterManager, but I will add this in in case we have to add this later on.", "author": "cgtz", "createdAt": "2020-04-01T19:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwMjg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwNjIwNA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401206204", "bodyText": "nit: can import ClusterMapSnapshotConstants in a static way.", "author": "jsjtzyy", "createdAt": "2020-03-31T20:49:27Z", "path": "ambry-replication/src/test/java/com.github.ambry.replication/CloudToStoreReplicationManagerTest.java", "diffHunk": "@@ -62,7 +63,7 @@\n public class CloudToStoreReplicationManagerTest {\n   private static final String NEW_PARTITION_NAME = \"12\";\n   private static final String CLOUD_DC_NAME = \"CloudDc\";\n-  private static final String VCR_MOUNT_PATH = \"/vcr/1\";\n+  private static final String VCR_MOUNT_PATH = ClusterMapSnapshotConstants.CLOUD_REPLICA_MOUNT + \"/1\";", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwOTA1OA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401209058", "bodyText": "nit: rename these two variables to isLocalDcReplica, isOriginatingDcReplica", "author": "jsjtzyy", "createdAt": "2020-03-31T20:54:32Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -191,19 +202,21 @@\n     for (ReplicaId replicaId : replicas) {\n       examinedReplicas.add(replicaId);\n       String replicaDcName = replicaId.getDataNodeId().getDatacenterName();\n-      if (replicaDcName.equals(originatingDcName)) {\n+      boolean localDcReplica = replicaDcName.equals(datacenterName);\n+      boolean originatingDcReplica = replicaDcName.equals(originatingDcName);", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMjA2OQ==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401212069", "bodyText": "I think this check also applies to cloudParallelism.\nAlso, could you add additional info in the exception message to record operation type? (so far, only PUT operation has dynamic parallelism but it's still good to add type into error message)", "author": "jsjtzyy", "createdAt": "2020-03-31T21:00:00Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -143,32 +154,32 @@\n       case PutOperation:\n         eligibleReplicas =\n             getEligibleReplicas(partitionId, datacenterName, EnumSet.of(ReplicaState.STANDBY, ReplicaState.LEADER));\n-        successTarget = routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n+        diskSuccessTarget = routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n             routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n-        parallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n+        diskParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n             : routerConfig.routerPutRequestParallelism;\n+        crossColoEnabled = false;\n         break;\n       case DeleteOperation:\n-        successTarget = routerConfig.routerDeleteSuccessTarget;\n-        parallelism = routerConfig.routerDeleteRequestParallelism;\n+        diskSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n+        diskParallelism = routerConfig.routerDeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case TtlUpdateOperation:\n-        successTarget = routerConfig.routerTtlUpdateSuccessTarget;\n-        parallelism = routerConfig.routerTtlUpdateRequestParallelism;\n+        diskSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n+        diskParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       default:\n         throw new IllegalArgumentException(\"Unsupported operation: \" + routerOperation);\n     }\n-    if (parallelism < 1) {\n-      throw new IllegalArgumentException(\"Parallelism has to be > 0. Configured to be \" + parallelism);\n+    if (diskParallelism < 1) {", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMTEzMw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401221133", "bodyText": "If I remember correctly, we are supposed to try replicas in local dc first, then replica in linkedin dcs, and then cloud replica. So this logic has changed?", "author": "jsjtzyy", "createdAt": "2020-03-31T21:18:02Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -227,22 +240,32 @@\n         replicaPool.add(downReplicas.pollFirst());\n       }\n     }\n+    cloudReplicasPresent =\n+        replicaPool.stream().map(ReplicaId::getReplicaType).anyMatch(Predicate.isEqual(ReplicaType.CLOUD_BACKED));\n     totalReplicaCount = replicaPool.size();\n-    if (totalReplicaCount < successTarget) {\n-      // {@link MockPartitionId#getReplicaIds} is returning a shared reference which may cause race condition.\n-      // Please report the test failure if you run into this exception.\n-      throw new IllegalArgumentException(\n-          generateErrorMessage(partitionId, examinedReplicas, replicaPool, backupReplicasToCheck, downReplicasToCheck));\n+\n+    // MockPartitionId.getReplicaIds() is returning a shared reference which may cause race condition.\n+    // Please report the test failure if you run into this exception.\n+    Supplier<IllegalArgumentException> notEnoughReplicasException = () -> new IllegalArgumentException(\n+        generateErrorMessage(partitionId, examinedReplicas, replicaPool, backupReplicasToCheck, downReplicasToCheck));\n+    // initialize this to the replica type of the first request to send so that parallelism is set correctly for the\n+    // first request\n+    inFlightReplicaType =\n+        replicaPool.stream().findFirst().map(ReplicaId::getReplicaType).orElseThrow(notEnoughReplicasException);", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1NzgwNw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401257807", "bodyText": "This logic has not changed. The order of the items in replica pool is still the same. This line just gets the replica type of the first item in the linked list, which should be a replica in the local dc.", "author": "cgtz", "createdAt": "2020-03-31T22:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMTEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1OTY1OQ==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401259659", "bodyText": "ah, I get your point. The frontend that uses operation tracker might be Azure frontend. In that case, first replica type is cloud replica, right? Did we ensure cloud replica will be picked in first place when populating the replica pool?", "author": "jsjtzyy", "createdAt": "2020-03-31T22:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMTEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2MzQ3OA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401763478", "bodyText": "The cloud replica will be returned in the list of replica IDs if it exists. Since each cloud replica has a virtual \"datanode\" it will follow the same datacenter ordering logic that other replicas do. For azure fabrics, it will come first.", "author": "cgtz", "createdAt": "2020-04-01T16:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMTEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2NDk4NQ==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401764985", "bodyText": "Make sense. Thanks for the explanation.", "author": "jsjtzyy", "createdAt": "2020-04-01T16:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMTEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMjgxNA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401222814", "bodyText": "If routerGetEligibleReplicasByStateEnabled is true, the replicaPool won't include cloudReplica. Do we need to explicitly add it into pool?", "author": "jsjtzyy", "createdAt": "2020-03-31T21:21:26Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -227,22 +240,32 @@\n         replicaPool.add(downReplicas.pollFirst());\n       }\n     }\n+    cloudReplicasPresent =\n+        replicaPool.stream().map(ReplicaId::getReplicaType).anyMatch(Predicate.isEqual(ReplicaType.CLOUD_BACKED));", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1ODk2Mw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401258963", "bodyText": "I was under the impression that it would be returned since CloudServiceClusterChangeHandler has the following implementation (return the replica unconditionally if it exists):\n  @Override\n  public Stream<AmbryReplica> getReplicaIdsByState(AmbryPartition partition, ReplicaState state) {\n    AmbryReplica replica = partitionToReplica.get(partition.toPathString());\n    return replica == null ? Stream.empty() : Stream.of(replica);\n  }", "author": "cgtz", "createdAt": "2020-03-31T22:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMjgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MDM3Ng==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401770376", "bodyText": "Right, I forgot cloud dc is added to dcToDcInfo", "author": "jsjtzyy", "createdAt": "2020-04-01T17:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyMjgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNDc3NA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r401224774", "bodyText": "I would suggest renaming these variables to something like  diskReplicaSuccessCount to distinguish it from diskDownCount more easily.", "author": "jsjtzyy", "createdAt": "2020-03-31T21:25:30Z", "path": "ambry-router/src/main/java/com.github.ambry.router/SimpleOperationTracker.java", "diffHunk": "@@ -66,27 +69,32 @@\n class SimpleOperationTracker implements OperationTracker {\n   protected final String datacenterName;\n   protected final String originatingDcName;\n-  protected final int successTarget;\n-  protected final int parallelism;\n+  protected final int diskSuccessTarget;\n+  protected final int diskParallelism;\n+  protected final int cloudSuccessTarget;\n+  protected final int cloudParallelism;\n+  protected final boolean cloudReplicasPresent;\n+  // How many NotFound responses from originating dc will terminate the operation.\n+  // It's decided by the success target of each mutation operations, including put, delete, update ttl etc.\n+  protected final int originatingDcNotFoundFailureThreshold;\n+  protected final int totalReplicaCount;\n   protected final LinkedList<ReplicaId> replicaPool = new LinkedList<>();\n \n-  protected int totalReplicaCount = 0;\n   protected int inflightCount = 0;\n-  protected int succeededCount = 0;\n+  protected int diskSucceededCount = 0;\n+  protected int cloudSucceededCount = 0;", "originalCommit": "161788d6547b3f3965ea99cce073786bffee2fc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f79b617a171fd76922ac7b1e6ca9b0fe8b0806b9", "url": "https://github.com/linkedin/ambry/commit/f79b617a171fd76922ac7b1e6ca9b0fe8b0806b9", "message": "Address some comments", "committedDate": "2020-04-01T16:11:30Z", "type": "forcePushed"}, {"oid": "3bf658eeeda5b5c41df2f2e72c710e2bbb8eb3f9", "url": "https://github.com/linkedin/ambry/commit/3bf658eeeda5b5c41df2f2e72c710e2bbb8eb3f9", "message": "Add support for cloud replicas to OperationTracker\n\nCLOUD_BACKED replicas differ from DISK_BACKED replicas in that they\nonly require one succesful response to deem the operation a success.\nThe changes in this commit tune the success target and parallelism based\non the type of replica requests are sent to. For DISK_BACKED replicas,\nthe policies remain the same, but for CLOUD_BACKED replicas, one\nsuccessful response will complete the operation. Additionally, only one\nrequest will be sent by SimpleOperationTracker at a time when a cloud\nrequest is in flight (since this one request would be able to\nsuccessfully complete the operation).", "committedDate": "2020-04-02T07:34:51Z", "type": "commit"}, {"oid": "61c9f4410636b305b58f4f3c8bb27af372514b49", "url": "https://github.com/linkedin/ambry/commit/61c9f4410636b305b58f4f3c8bb27af372514b49", "message": "Some unit test cases", "committedDate": "2020-04-02T07:34:51Z", "type": "commit"}, {"oid": "a113b8c025785616baf8ffc32d08956996e2125d", "url": "https://github.com/linkedin/ambry/commit/a113b8c025785616baf8ffc32d08956996e2125d", "message": "Address some comments", "committedDate": "2020-04-02T07:34:51Z", "type": "commit"}, {"oid": "89ea14d558698c35445c4496b977fa4a6d45e572", "url": "https://github.com/linkedin/ambry/commit/89ea14d558698c35445c4496b977fa4a6d45e572", "message": "Fix test case issue with spaces in MockReplicaId.toString()", "committedDate": "2020-04-02T07:34:51Z", "type": "commit"}, {"oid": "9ba5b1e1e1ec42a201323d5e29f0ebc4b491b400", "url": "https://github.com/linkedin/ambry/commit/9ba5b1e1e1ec42a201323d5e29f0ebc4b491b400", "message": "Revert MockReplicaId.toString() changes", "committedDate": "2020-04-02T07:34:51Z", "type": "commit"}, {"oid": "7c03a10039455e8d4b8b030c5dcf6bff60eac50f", "url": "https://github.com/linkedin/ambry/commit/7c03a10039455e8d4b8b030c5dcf6bff60eac50f", "message": "Address remaining comments", "committedDate": "2020-04-02T07:34:51Z", "type": "commit"}, {"oid": "7c03a10039455e8d4b8b030c5dcf6bff60eac50f", "url": "https://github.com/linkedin/ambry/commit/7c03a10039455e8d4b8b030c5dcf6bff60eac50f", "message": "Address remaining comments", "committedDate": "2020-04-02T07:34:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MTYzMw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r402481633", "bodyText": "minor: numReplicasInLocalDc is updated but never accessed. Consider removing it?", "author": "jsjtzyy", "createdAt": "2020-04-02T17:22:39Z", "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -191,19 +207,24 @@\n     for (ReplicaId replicaId : replicas) {\n       examinedReplicas.add(replicaId);\n       String replicaDcName = replicaId.getDataNodeId().getDatacenterName();\n-      if (replicaDcName.equals(originatingDcName)) {\n+      boolean isLocalDcReplica = replicaDcName.equals(datacenterName);\n+      boolean isOriginatingDcReplica = replicaDcName.equals(originatingDcName);\n+      if (isLocalDcReplica) {\n+        numReplicasInLocalDc++;", "originalCommit": "7c03a10039455e8d4b8b030c5dcf6bff60eac50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4NDgzNw==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r402484837", "bodyText": "Sorry left that in there since I was thinking about adding in some changes to the logic for adding backup replicas when includeOriginating is false to just use the total number of replicas in the local and remote dcs instead of hardcoding it to 6. I ultimately decided not to couple these changes though since it affects our current production cluster the most.", "author": "cgtz", "createdAt": "2020-04-02T17:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MTYzMw=="}], "type": "inlineReview"}, {"oid": "2ecfbbe57b93bdcedc3be05ee65cc495425b9a4e", "url": "https://github.com/linkedin/ambry/commit/2ecfbbe57b93bdcedc3be05ee65cc495425b9a4e", "message": "Remove unused variable", "committedDate": "2020-04-02T17:29:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwMDk1OA==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r402600958", "bodyText": "Is there still a TODO here?", "author": "lightningrob", "createdAt": "2020-04-02T21:16:40Z", "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -261,21 +288,32 @@\n   @Override\n   public boolean hasSucceeded() {\n     boolean hasSucceeded;\n-    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget) {\n-      hasSucceeded =\n-          succeededCount >= Math.max(totalReplicaCount - disabledCount - 1, routerConfig.routerPutSuccessTarget);\n+    if (routerOperation == RouterOperation.PutOperation && routerConfig.routerPutUseDynamicSuccessTarget\n+        && inFlightReplicaType == ReplicaType.DISK_BACKED) {\n+      // this logic only applies to disk replicas where the quorum can change during replica movement\n+      int dynamicSuccessTarget = Math.max(totalReplicaCount - disabledCount - 1, routerConfig.routerPutSuccessTarget);\n+      hasSucceeded = diskReplicaSuccessCount >= dynamicSuccessTarget;\n     } else {\n-      hasSucceeded = succeededCount >= successTarget;\n+      hasSucceeded = diskReplicaSuccessCount >= diskSuccessTarget || cloudReplicaSuccessCount >= cloudSuccessTarget;\n     }\n     return hasSucceeded;\n   }\n \n   @Override\n   public boolean hasFailedOnNotFound() {\n-    return (originatingDcNotFoundFailureThreshold > 0\n-        && originatingDcNotFoundCount >= originatingDcNotFoundFailureThreshold) || (crossColoEnabled\n-        && diskDownCount + totalNotFoundCount > totalReplicaCount - successTarget);\n+    if (routerOperation == RouterOperation.PutOperation) {\n+      return false;\n+    }\n+    if (originatingDcNotFoundFailureThreshold > 0\n+        && originatingDcNotFoundCount >= originatingDcNotFoundFailureThreshold) {\n+      return true;\n+    }\n     // To account for GET operation, the threshold should be  >= totalReplicaCount - (success target - 1)\n+    // Right now, this only applies for disk replica only partitions and may not be completely accurate if there are\n+    // failures responses other than not found.\n+    // TODO support cloud replicas in this condition, also account for failures other than not found", "originalCommit": "2ecfbbe57b93bdcedc3be05ee65cc495425b9a4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNzYxMQ==", "url": "https://github.com/linkedin/ambry/pull/1445#discussion_r402607611", "bodyText": "Yes that is still a todo. I will make github issues for the todos that I added to this file", "author": "cgtz", "createdAt": "2020-04-02T21:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwMDk1OA=="}], "type": "inlineReview"}]}