{"pr_number": 1352, "pr_title": "Add Netty Based HTTP2 implementation for storage server.", "pr_createdAt": "2020-01-06T21:12:50Z", "pr_url": "https://github.com/linkedin/ambry/pull/1352", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NTg4Nw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r363485887", "bodyText": "The test is temporarily disabled, will fix it soon in this PR.", "author": "zzmao", "createdAt": "2020-01-06T21:14:12Z", "path": "ambry-rest/src/test/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactoryTest.java", "diffHunk": "@@ -71,7 +71,6 @@ public void getAsyncRequestResponseHandlerTest() throws InstantiationException,\n   /**\n    * Tests instantiation of {@link AsyncRequestResponseHandlerFactory} with bad input.\n    */\n-  @Test", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2Mjc1Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369162752", "bodyText": "fixed.", "author": "zzmao", "createdAt": "2020-01-21T18:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NTg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NjE1MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r363486150", "bodyText": "Temporarily commented. Will fix it soon in this PR.", "author": "zzmao", "createdAt": "2020-01-06T21:14:52Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/AsyncRequestResponseHandlerFactory.java", "diffHunk": "@@ -109,10 +109,10 @@ private static void buildInstance(MetricRegistry metricRegistry) {\n         instance = new AsyncRequestResponseHandler(requestResponseHandlerMetrics);\n       }\n       // check if same instance of MetricRegistry - otherwise it is a problem.\n-      if (AsyncRequestResponseHandlerFactory.requestResponseHandlerMetrics.metricRegistry != metricRegistry) {", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2MjgwNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369162804", "bodyText": "fixed.", "author": "zzmao", "createdAt": "2020-01-21T18:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NjE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjU4Ng==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r364042586", "bodyText": "we should only call callback method once for the entire list since the callback passed to writeTo should be invoked only when the write is completed or failed.", "author": "justinlin-linkedin", "createdAt": "2020-01-08T02:38:35Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -48,6 +50,13 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    for (Send send : compositSendList) {\n+      send.writeTo(channel, callback);\n+    }\n+  }\n+", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MzkyMA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365483920", "bodyText": "Yes, perhaps each child send should have its own callback and then when either all of those callbacks succeed or an error has occured, the passed-in callback is notified, like in the default impl of AsyncWritableChannel.write(ByteBuf src, Callback<Long> callback)", "author": "cgtz", "createdAt": "2020-01-11T00:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE3MDIwMw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369170203", "bodyText": "Yes, this should be changed.\nI will make another PR to address this issue. For this PR, I will set callback to null in child send.", "author": "zzmao", "createdAt": "2020-01-21T18:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjgwNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r364042804", "bodyText": "same here, callback should only be invoked once.", "author": "justinlin-linkedin", "createdAt": "2020-01-08T02:39:53Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java", "diffHunk": "@@ -131,6 +133,26 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    if (bufferToSend == null) {\n+      bufferToSend = ByteBuffer.allocate(\n+          (int) super.sizeInBytes() + (Partition_Response_Info_List_Size + partitionResponseInfoSize));\n+      writeHeader();\n+      if (partitionResponseInfoList != null) {\n+        bufferToSend.putInt(partitionResponseInfoList.size());\n+        for (PartitionResponseInfo partitionResponseInfo : partitionResponseInfoList) {\n+          partitionResponseInfo.writeTo(bufferToSend);\n+        }\n+      }\n+      bufferToSend.flip();\n+    }\n+    channel.write(bufferToSend, callback);\n+    if (toSend != null) {\n+      toSend.writeTo(channel, callback);\n+    }", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE3MDMzNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369170334", "bodyText": "Will make another PR to address this issue. For this PR, I will set callback to null in child send.", "author": "zzmao", "createdAt": "2020-01-21T18:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA0MjgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MTgxNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365481814", "bodyText": "Add asynchronously to the docs to indicate that this method returns immediately after the write is initiated?", "author": "cgtz", "createdAt": "2020-01-11T00:37:48Z", "path": "ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java", "diffHunk": "@@ -36,7 +38,14 @@\n   long writeTo(int index, WritableByteChannel channel, long relativeOffset, long maxSize) throws IOException;\n \n   /**\n-   * Returns the total number of messages in this set\n+   * Write all messages in this set to the give {@link AsyncWritableChannel}", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU1NjYwOQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365556609", "bodyText": "Oh nvm, upon reading the other code I see that this is at least calls write() for all data available. Could you explain how this method is intended to behave. For example, is the supplied callback to be called when the entire batch of writes succeeds or fails? Also, are implementations of this method allowed to block waiting for i.o. (e.g. disk access), or are they supposed to have their messages ready and materialized in memory?", "author": "cgtz", "createdAt": "2020-01-12T04:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MTgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE3Njc0Ng==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r369176746", "bodyText": "Added in comment:\n   * This method is intend to write prefetched data from {@link MessageReadSet} to {@link AsyncWritableChannel}. Data\n   * should be ready in memory(no blocking call) before write to {@link AsyncWritableChannel} asynchronously. Callback is\n   * called when the entire batch of writes succeeds or fails.", "author": "zzmao", "createdAt": "2020-01-21T18:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MTkwMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365481901", "bodyText": "Callback<Void>?", "author": "cgtz", "createdAt": "2020-01-11T00:38:40Z", "path": "ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java", "diffHunk": "@@ -36,7 +38,14 @@\n   long writeTo(int index, WritableByteChannel channel, long relativeOffset, long maxSize) throws IOException;\n \n   /**\n-   * Returns the total number of messages in this set\n+   * Write all messages in this set to the give {@link AsyncWritableChannel}\n+   * @param channel the channel into which the data needs to be written to\n+   * @param callback The callback when data is fully wrote to the channel.\n+   * @throws IOException\n+   */\n+  void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException;", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MzU4OA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365483588", "bodyText": "composit -> composite", "author": "cgtz", "createdAt": "2020-01-11T00:50:24Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -48,6 +50,13 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    for (Send send : compositSendList) {", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NDE4NA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365484184", "bodyText": "This is done inside of the selector, reading the size of the payload is implemented in BoundedReceive", "author": "cgtz", "createdAt": "2020-01-11T00:54:38Z", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java", "diffHunk": "@@ -32,6 +33,13 @@ public NettyServerRequestResponseChannel(int queueSize) {\n   /** Send a request to be handled, potentially blocking until there is room in the queue for the request */\n   @Override\n   public void sendRequest(NetworkRequest request) throws InterruptedException {\n+    DataInputStream stream = new DataInputStream(request.getInputStream());\n+    try {\n+      // TODO: Where is this done in socket channel?", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUzOTU5MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365539590", "bodyText": "if the first port is not optional, make it an int instead of a wrapper object.", "author": "cgtz", "createdAt": "2020-01-11T20:07:45Z", "path": "ambry-clustermap/src/test/java/com.github.ambry.clustermap/MockClusterMap.java", "diffHunk": "@@ -234,16 +238,15 @@ public static MockClusterMap createOneNodeRecoveryClusterMap(MockDataNodeId reco\n     return new MockClusterMap(recoveryNode, vcrNode, dcName);\n   }\n \n-  protected ArrayList<Port> getListOfPorts(int port) {\n-    ArrayList<Port> ports = new ArrayList<>();\n-    ports.add(new Port(port, PortType.PLAINTEXT));\n-    return ports;\n-  }\n-\n-  protected ArrayList<Port> getListOfPorts(int port, int sslPort) {\n+  protected ArrayList<Port> getListOfPorts(Integer port, Integer sslPort, Integer http2Port) {", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU1NjYzNg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365556636", "bodyText": "Can you make this shared code block into a helper function?", "author": "cgtz", "createdAt": "2020-01-12T04:13:15Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/GetResponse.java", "diffHunk": "@@ -131,6 +133,26 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    if (bufferToSend == null) {\n+      bufferToSend = ByteBuffer.allocate(\n+          (int) super.sizeInBytes() + (Partition_Response_Info_List_Size + partitionResponseInfoSize));\n+      writeHeader();\n+      if (partitionResponseInfoList != null) {\n+        bufferToSend.putInt(partitionResponseInfoList.size());\n+        for (PartitionResponseInfo partitionResponseInfo : partitionResponseInfoList) {\n+          partitionResponseInfo.writeTo(bufferToSend);\n+        }\n+      }\n+      bufferToSend.flip();\n+    }", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3OTU3Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368179573", "bodyText": "yes, I should do this.", "author": "zzmao", "createdAt": "2020-01-17T23:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU1NjYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MTc0MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365971740", "bodyText": "I thought this was combined into RestRequestResponseHandlerFactory", "author": "cgtz", "createdAt": "2020-01-13T18:58:56Z", "path": "ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java", "diffHunk": "@@ -201,6 +215,37 @@ public void startup() throws InstantiationException {\n           networkServer.getRequestResponseChannel(), requests);\n       networkServer.start();\n \n+      // start netty http2 server\n+      if (nodeId.hasHttp2Port()) {\n+        RestServerConfig restServerConfig = new RestServerConfig(properties);\n+        SSLFactory sslFactory = new NettySslHttp2Factory(sslConfig);\n+        RestServerState restServerState = new RestServerState(restServerConfig.restServerHealthCheckUri);\n+        NettyServerRequestResponseChannel requestResponseChannel = new NettyServerRequestResponseChannel(1);\n+        RestRequestService restRequestService = new StorageRestRequestService(requestResponseChannel);\n+\n+        AmbryServerRequests ambryServerRequestsForHttp2 =\n+            new AmbryServerRequests(storageManager, requestResponseChannel, clusterMap, nodeId, registry, serverMetrics,\n+                findTokenHelper, notificationSystem, replicationManager, storeKeyFactory, serverConfig,\n+                storeKeyConverterFactory, statsManager);\n+        RequestHandlerPool requestHandlerPoolForHttp2 =\n+            new RequestHandlerPool(serverConfig.serverRequestHandlerNumOfThreads, requestResponseChannel,\n+                ambryServerRequestsForHttp2);\n+\n+        RestRequestHandlerFactory restRequestHandlerFactory =", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MjkyMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365972921", "bodyText": "It does not look like this factory has the override behavior, so you can modify this javadoc and change the arg name to just sslFactory", "author": "cgtz", "createdAt": "2020-01-13T19:01:45Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Netty specific implementation of {@link NioServerFactory}.\n+ * <p/>\n+ * Sets up all the supporting cast required for the operation of {@link NettyServer} and returns a new instance on\n+ * {@link #getNioServer()}.\n+ */\n+public class StorageServerNettyFactory implements NioServerFactory {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StorageServerNettyFactory.class);\n+\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  final Map<Integer, ChannelInitializer<SocketChannel>> channelInitializers;\n+\n+  /**\n+   * Creates a new instance of NettyFrontendServerFactory.\n+   * @param http2Port the port for HTTP2 request.\n+   * @param verifiableProperties the in-memory {@link VerifiableProperties} to use.\n+   * @param metricRegistry the {@link MetricRegistry} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to hand off the requests to.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} that can be used for public access logging\n+   * @param restServerState the {@link RestServerState} that can be used to check the health of the system\n+   *                              to respond to health check requests\n+   * @param defaultSslFactory the {@link SSLFactory} used to construct the {@link javax.net.ssl.SSLEngine} used for", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MzAxMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365973011", "bodyText": "sslfactory is required", "author": "cgtz", "createdAt": "2020-01-13T19:01:56Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Netty specific implementation of {@link NioServerFactory}.\n+ * <p/>\n+ * Sets up all the supporting cast required for the operation of {@link NettyServer} and returns a new instance on\n+ * {@link #getNioServer()}.\n+ */\n+public class StorageServerNettyFactory implements NioServerFactory {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StorageServerNettyFactory.class);\n+\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  final Map<Integer, ChannelInitializer<SocketChannel>> channelInitializers;\n+\n+  /**\n+   * Creates a new instance of NettyFrontendServerFactory.\n+   * @param http2Port the port for HTTP2 request.\n+   * @param verifiableProperties the in-memory {@link VerifiableProperties} to use.\n+   * @param metricRegistry the {@link MetricRegistry} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to hand off the requests to.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} that can be used for public access logging\n+   * @param restServerState the {@link RestServerState} that can be used to check the health of the system\n+   *                              to respond to health check requests\n+   * @param defaultSslFactory the {@link SSLFactory} used to construct the {@link javax.net.ssl.SSLEngine} used for\n+   *                          handling SSL requests (unless {@link NettyConfig#SSL_FACTORY_KEY} is set, in which case\n+   *                          it will be overridden).\n+   * @throws IllegalArgumentException if any of the arguments are null.\n+   * @throws ReflectiveOperationException if a netty-specific {@link SSLFactory} cannot be instantiated via reflection.\n+   */\n+  public StorageServerNettyFactory(int http2Port, VerifiableProperties verifiableProperties,\n+      MetricRegistry metricRegistry, final RestRequestHandler requestHandler,\n+      final PublicAccessLogger publicAccessLogger, final RestServerState restServerState, SSLFactory defaultSslFactory)\n+      throws ReflectiveOperationException {\n+    if (verifiableProperties == null || metricRegistry == null || requestHandler == null || publicAccessLogger == null\n+        || restServerState == null) {", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTI4OA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365975288", "bodyText": "It may be worth looking into what to do about public access logging on storage servers. They already have public access logging facilities inside of AmbryRequests. We would either want to disable these logs or make sure that they are redirected to the right log files.", "author": "cgtz", "createdAt": "2020-01-13T19:06:55Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Netty specific implementation of {@link NioServerFactory}.\n+ * <p/>\n+ * Sets up all the supporting cast required for the operation of {@link NettyServer} and returns a new instance on\n+ * {@link #getNioServer()}.\n+ */\n+public class StorageServerNettyFactory implements NioServerFactory {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StorageServerNettyFactory.class);\n+\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  final Map<Integer, ChannelInitializer<SocketChannel>> channelInitializers;\n+\n+  /**\n+   * Creates a new instance of NettyFrontendServerFactory.\n+   * @param http2Port the port for HTTP2 request.\n+   * @param verifiableProperties the in-memory {@link VerifiableProperties} to use.\n+   * @param metricRegistry the {@link MetricRegistry} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to hand off the requests to.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} that can be used for public access logging\n+   * @param restServerState the {@link RestServerState} that can be used to check the health of the system\n+   *                              to respond to health check requests\n+   * @param defaultSslFactory the {@link SSLFactory} used to construct the {@link javax.net.ssl.SSLEngine} used for\n+   *                          handling SSL requests (unless {@link NettyConfig#SSL_FACTORY_KEY} is set, in which case\n+   *                          it will be overridden).\n+   * @throws IllegalArgumentException if any of the arguments are null.\n+   * @throws ReflectiveOperationException if a netty-specific {@link SSLFactory} cannot be instantiated via reflection.\n+   */\n+  public StorageServerNettyFactory(int http2Port, VerifiableProperties verifiableProperties,\n+      MetricRegistry metricRegistry, final RestRequestHandler requestHandler,\n+      final PublicAccessLogger publicAccessLogger, final RestServerState restServerState, SSLFactory defaultSslFactory)\n+      throws ReflectiveOperationException {\n+    if (verifiableProperties == null || metricRegistry == null || requestHandler == null || publicAccessLogger == null\n+        || restServerState == null) {\n+      throw new IllegalArgumentException(\"Null arg(s) received during instantiation of StorageServerNettyFactory\");\n+    }\n+    nettyConfig = new NettyConfig(verifiableProperties);\n+    performanceConfig = new PerformanceConfig(verifiableProperties);\n+    nettyMetrics = new NettyMetrics(metricRegistry);\n+    ConnectionStatsHandler connectionStatsHandler = new ConnectionStatsHandler(nettyMetrics);\n+\n+    Map<Integer, ChannelInitializer<SocketChannel>> initializers = new HashMap<>();\n+\n+    initializers.put(http2Port,\n+        new StorageServerNettyChannelInitializer(nettyConfig, performanceConfig, nettyMetrics, connectionStatsHandler,\n+            requestHandler, publicAccessLogger, restServerState, defaultSslFactory, metricRegistry));", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3NzU3Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368177572", "bodyText": "removed.", "author": "zzmao", "createdAt": "2020-01-17T23:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTY2NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365975665", "bodyText": "you can just use Collections.singletonMap here.", "author": "cgtz", "createdAt": "2020-01-13T19:07:38Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.socket.SocketChannel;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Netty specific implementation of {@link NioServerFactory}.\n+ * <p/>\n+ * Sets up all the supporting cast required for the operation of {@link NettyServer} and returns a new instance on\n+ * {@link #getNioServer()}.\n+ */\n+public class StorageServerNettyFactory implements NioServerFactory {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(StorageServerNettyFactory.class);\n+\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  final Map<Integer, ChannelInitializer<SocketChannel>> channelInitializers;\n+\n+  /**\n+   * Creates a new instance of NettyFrontendServerFactory.\n+   * @param http2Port the port for HTTP2 request.\n+   * @param verifiableProperties the in-memory {@link VerifiableProperties} to use.\n+   * @param metricRegistry the {@link MetricRegistry} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to hand off the requests to.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} that can be used for public access logging\n+   * @param restServerState the {@link RestServerState} that can be used to check the health of the system\n+   *                              to respond to health check requests\n+   * @param defaultSslFactory the {@link SSLFactory} used to construct the {@link javax.net.ssl.SSLEngine} used for\n+   *                          handling SSL requests (unless {@link NettyConfig#SSL_FACTORY_KEY} is set, in which case\n+   *                          it will be overridden).\n+   * @throws IllegalArgumentException if any of the arguments are null.\n+   * @throws ReflectiveOperationException if a netty-specific {@link SSLFactory} cannot be instantiated via reflection.\n+   */\n+  public StorageServerNettyFactory(int http2Port, VerifiableProperties verifiableProperties,\n+      MetricRegistry metricRegistry, final RestRequestHandler requestHandler,\n+      final PublicAccessLogger publicAccessLogger, final RestServerState restServerState, SSLFactory defaultSslFactory)\n+      throws ReflectiveOperationException {\n+    if (verifiableProperties == null || metricRegistry == null || requestHandler == null || publicAccessLogger == null\n+        || restServerState == null) {\n+      throw new IllegalArgumentException(\"Null arg(s) received during instantiation of StorageServerNettyFactory\");\n+    }\n+    nettyConfig = new NettyConfig(verifiableProperties);\n+    performanceConfig = new PerformanceConfig(verifiableProperties);\n+    nettyMetrics = new NettyMetrics(metricRegistry);\n+    ConnectionStatsHandler connectionStatsHandler = new ConnectionStatsHandler(nettyMetrics);\n+\n+    Map<Integer, ChannelInitializer<SocketChannel>> initializers = new HashMap<>();", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3OTUwNQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368179505", "bodyText": "cool.", "author": "zzmao", "createdAt": "2020-01-17T23:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTkyNw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365975927", "bodyText": "commented out ^", "author": "cgtz", "createdAt": "2020-01-13T19:08:14Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import java.net.InetSocketAddress;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link StorageServerNettyFactory}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class StorageServerNettyChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  private final ConnectionStatsHandler connectionStatsHandler;\n+  private final RestRequestHandler requestHandler;\n+  private final PublicAccessLogger publicAccessLogger;\n+  private final RestServerState restServerState;\n+  private final SSLFactory sslFactory;\n+\n+  /**\n+   * Construct a {@link StorageServerNettyChannelInitializer}.\n+   * @param nettyConfig the config to use when instantiating certain handlers on this pipeline.\n+   * @param performanceConfig the config to use when evaluating ambry service level objectives that include latency.\n+   * @param nettyMetrics the {@link NettyMetrics} object to use.\n+   * @param connectionStatsHandler the {@link ConnectionStatsHandler} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to handle requests on this pipeline.\n+   * @param publicAccessLogger the {@link PublicAccessLogger} to use.\n+   * @param restServerState the {@link RestServerState} object to use.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public StorageServerNettyChannelInitializer(NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      NettyMetrics nettyMetrics, ConnectionStatsHandler connectionStatsHandler, RestRequestHandler requestHandler,\n+      PublicAccessLogger publicAccessLogger, RestServerState restServerState, SSLFactory sslFactory,\n+      MetricRegistry metricRegistry) {\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.nettyMetrics = nettyMetrics;\n+    this.connectionStatsHandler = connectionStatsHandler;\n+    this.publicAccessLogger = publicAccessLogger;\n+    this.restServerState = restServerState;\n+    this.sslFactory = sslFactory;\n+    RestRequestMetricsTracker.setDefaults(metricRegistry);\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    // If channel handler implementations are not annotated with @Sharable, Netty creates a new instance of every class\n+    // in the pipeline for every connection.\n+    // i.e. if there are a 1000 active connections there will be a 1000 NettyMessageProcessor instances.\n+    ChannelPipeline pipeline = ch.pipeline();\n+    // connection stats handler to track connection related metrics\n+    // if SSL is enabled, add an SslHandler before the HTTP codec\n+    if (sslFactory != null) {\n+      InetSocketAddress peerAddress = ch.remoteAddress();\n+      String peerHost = peerAddress.getHostName();\n+      int peerPort = peerAddress.getPort();\n+      SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(peerHost, peerPort, SSLFactory.Mode.SERVER));\n+      pipeline.addLast(\"SslHandler\", sslHandler);\n+    }\n+    // TODO: add PublicAccessLogger and ConnectionStatsHandler\n+    pipeline.addLast(Http2FrameCodecBuilder.forServer().build())\n+        // .addLast(\"healthCheckHandler\", new HealthCheckHandler(restServerState, nettyMetrics))", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3ODQyMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368178421", "bodyText": "removed.", "author": "zzmao", "createdAt": "2020-01-17T23:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NzE3Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r365977172", "bodyText": "Do the utility handlers like HealthCheckHandler, and PublicAccessLogHandler belong here?", "author": "cgtz", "createdAt": "2020-01-13T19:11:05Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2StreamHandler.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.http2.Http2StreamFrameToHttpObjectCodec;\n+import io.netty.handler.stream.ChunkedWriteHandler;\n+\n+\n+/*\n+ * HTTP2 stream handler for each stream.\n+ */\n+@ChannelHandler.Sharable\n+public class Http2StreamHandler extends ChannelInboundHandlerAdapter {\n+\n+  private NettyMetrics nettyMetrics;\n+  private NettyConfig nettyConfig;\n+  private PerformanceConfig performanceConfig;\n+  private RestRequestHandler requestHandler;\n+\n+  public Http2StreamHandler(NettyMetrics nettyMetrics, NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      RestRequestHandler requestHandler) {\n+    this.nettyMetrics = nettyMetrics;\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+    ctx.pipeline().addLast(new Http2StreamFrameToHttpObjectCodec(true));\n+    // NettyMessageProcessor depends on ChunkedWriteHandler.", "originalCommit": "744f1e6576eaf037c51443dccded11a33473271e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3ODkxOA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r368178918", "bodyText": "Existing server logging is good. We don't need PublicAccessLogHandler.\nHealthCheckHandler  is needed. Let me if I can add it in this PR.", "author": "zzmao", "createdAt": "2020-01-17T23:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NzE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MjI3MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371562270", "bodyText": "who is sending this health check request? is the send compatible with http2?", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3NzE3Mg=="}], "type": "inlineReview"}, {"oid": "e0c86d8b6d6198be231e8d2133942c659d780a24", "url": "https://github.com/linkedin/ambry/commit/e0c86d8b6d6198be231e8d2133942c659d780a24", "message": "http2 stroage", "committedDate": "2020-01-21T18:47:31Z", "type": "forcePushed"}, {"oid": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "url": "https://github.com/linkedin/ambry/commit/dd6d62a2823ece52260f0ca64e8fc77cb108f555", "message": "simplify http2 blocking channel", "committedDate": "2020-01-22T22:48:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0MzIwNQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371543205", "bodyText": "should increment i after each write.", "author": "justinlin-linkedin", "createdAt": "2020-01-27T23:38:35Z", "path": "ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java", "diffHunk": "@@ -208,6 +210,25 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    int lastIndex = readOptions.size() - 1;\n+    int i = 0;\n+    for (BlobReadOptions options : readOptions) {\n+      ByteBuffer buf = options.getPrefetchedData();\n+      if (buf == null) {\n+        throw new IOException(\"Data should be prefetched.\");\n+      }\n+      buf.position(0);\n+      if (i == lastIndex) {", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODE1Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372008152", "bodyText": "good catch.", "author": "zzmao", "createdAt": "2020-01-28T19:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0MzIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0NDkzNw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371544937", "bodyText": "We can stop writing to the channel whenever there is an exception here and stop the for loop. This would require changing the callback implementation.", "author": "justinlin-linkedin", "createdAt": "2020-01-27T23:44:48Z", "path": "ambry-store/src/main/java/com.github.ambry.store/StoreMessageReadSet.java", "diffHunk": "@@ -208,6 +210,25 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    int lastIndex = readOptions.size() - 1;\n+    int i = 0;\n+    for (BlobReadOptions options : readOptions) {\n+      ByteBuffer buf = options.getPrefetchedData();\n+      if (buf == null) {\n+        throw new IOException(\"Data should be prefetched.\");\n+      }\n+      buf.position(0);\n+      if (i == lastIndex) {\n+        // only the last one needs callback.\n+        channel.write(buf, callback);\n+      } else {\n+        channel.write(buf, null);\n+      }", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODc1OQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372008759", "bodyText": "Yes. A good callback implementation is needed. Will add todo here and implement in follow up PR.", "author": "zzmao", "createdAt": "2020-01-28T19:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0NDkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU0ODQ3Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371548473", "bodyText": "nit: private volatile", "author": "justinlin-linkedin", "createdAt": "2020-01-27T23:57:08Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -55,14 +56,14 @@\n  */\n public class Http2BlockingChannel implements ConnectedChannel {\n   private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n-  private final Http2ResponseHandler http2ResponseHandler;\n   private final String hostName;\n   private final int port;\n   private EventLoopGroup workerGroup;\n   private Channel channel;\n+  private ChannelPromise channelPromise;\n+  private ByteBuf responseByteBuf;", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MDgyMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371550821", "bodyText": "this is going to run out of sync with the callback in the send method. If the awaitUninterruptedly returns false, dataInputStream would reuse the responseByteBuf set by last send.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:05:25Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -103,24 +104,31 @@ public void send(Send request) throws IOException {\n     byteBufferChannel.getBuffer().position(0);\n     ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n \n-    Http2ClientStreamInitializer initializer = new Http2ClientStreamInitializer(http2ResponseHandler);\n+    Http2ClientStreamInitializer initializer = new Http2ClientStreamInitializer(new Http2ResponseHandler());\n     Http2StreamChannel childChannel =\n         new Http2StreamChannelBootstrap(channel).handler(initializer).open().syncUninterruptibly().getNow();\n     Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+    http2Headers.set(RestUtils.Headers.HTTP2_FRONTEND_REQUEST, \"true\");\n+    channelPromise = childChannel.newPromise();\n+    childChannel.attr(Http2ResponseHandler.RESPONSE_CALLBACK).set(new Callback<ByteBuf>() {\n+      @Override\n+      public void onCompletion(ByteBuf result, Exception exception) {\n+        responseByteBuf = result;\n+        channelPromise.setSuccess();\n+      }\n+    });\n \n     DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n     DefaultHttp2DataFrame dataFrame = new DefaultHttp2DataFrame(byteBuf, true);\n-    ChannelPromise childChannelPromise = childChannel.newPromise();\n     childChannel.write(headersFrame);\n-    ChannelFuture channelFuture = childChannel.write(dataFrame);\n+    childChannel.write(dataFrame);\n     childChannel.flush();\n-    http2ResponseHandler.put(channelFuture, childChannelPromise);\n   }\n \n   @Override\n   public ChannelOutput receive() throws IOException {\n-    Http2ResponseHandler.StreamResult streamResult = http2ResponseHandler.awaitResponses(5, TimeUnit.SECONDS);\n-    DataInputStream dataInputStream = new NettyByteBufDataInputStream(streamResult.getByteBuf());\n+    channelPromise.awaitUninterruptibly(3, TimeUnit.SECONDS);\n+    DataInputStream dataInputStream = new NettyByteBufDataInputStream(responseByteBuf);", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxMjE2MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372012160", "bodyText": "Adding a check if return value T or F.", "author": "zzmao", "createdAt": "2020-01-28T19:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MDgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MzYwNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371553604", "bodyText": "we should create a variable in the object to reference requestHandlePoolForHttp2 so we can stop it in the shutdown method.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:16:15Z", "path": "ambry-server/src/main/java/com.github.ambry.server/AmbryServer.java", "diffHunk": "@@ -201,6 +214,36 @@ public void startup() throws InstantiationException {\n           networkServer.getRequestResponseChannel(), requests);\n       networkServer.start();\n \n+      // Start netty http2 server\n+      if (nodeId.hasHttp2Port()) {\n+        RestServerConfig restServerConfig = new RestServerConfig(properties);\n+        SSLFactory sslFactory = new NettySslHttp2Factory(sslConfig);\n+        RestServerState restServerState = new RestServerState(restServerConfig.restServerHealthCheckUri);\n+        NettyServerRequestResponseChannel requestResponseChannel = new NettyServerRequestResponseChannel(1);\n+        RestRequestService restRequestService = new StorageRestRequestService(requestResponseChannel);\n+\n+        AmbryServerRequests ambryServerRequestsForHttp2 =\n+            new AmbryServerRequests(storageManager, requestResponseChannel, clusterMap, nodeId, registry, serverMetrics,\n+                findTokenHelper, notificationSystem, replicationManager, storeKeyFactory, serverConfig,\n+                storeKeyConverterFactory, statsManager);\n+        RequestHandlerPool requestHandlerPoolForHttp2 =", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNTA1Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372015052", "bodyText": "fixed. Also renamed some variables name with http2 keyword.", "author": "zzmao", "createdAt": "2020-01-28T19:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MzYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NTk4MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371555980", "bodyText": "I don't get this one.\nThis method will be called in the StorageRestRequestService, which is a service to handle http2 request. That means the NetworkRequest would only contains the bytes from http2 client, why the BoundedReceive is involved here? I don't see a reason to read 8 bytes from enqueuing this request.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:25:13Z", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java", "diffHunk": "@@ -32,6 +33,14 @@ public NettyServerRequestResponseChannel(int queueSize) {\n   /** Send a request to be handled, potentially blocking until there is room in the queue for the request */\n   @Override\n   public void sendRequest(NetworkRequest request) throws InterruptedException {\n+    DataInputStream stream = new DataInputStream(request.getInputStream());\n+    try {\n+      // The first 8 bytes is size of the request. TCP implementation uses this size to allocate buffer. See {@link BoundedReceive}\n+      // Here we just need to consume it.\n+      stream.readLong();", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAzMTMxNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372031314", "bodyText": "Talk offline.", "author": "zzmao", "createdAt": "2020-01-28T20:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NTk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNTU1Ng==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373925556", "bodyText": "To make this more symmetrical with SocketServer, which handles the size header before adding the request to the queue, it may be better to read the size header in StorageRestRequestService.", "author": "cgtz", "createdAt": "2020-02-03T05:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NTk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NjYzMA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371556630", "bodyText": "nit: please add javadoc.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:27:39Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AdminResponse.java", "diffHunk": "@@ -59,15 +61,25 @@ public static AdminResponse readFrom(DataInputStream stream) throws IOException\n     return new AdminResponse(correlationId, clientId, error);\n   }\n \n-  @Override\n-  public long writeTo(WritableByteChannel channel) throws IOException {\n+  private void prepareBufferToSend() {", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxOTA4Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372019082", "bodyText": "added. Also changed in GetResponse.", "author": "zzmao", "createdAt": "2020-01-28T19:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1NjYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MTAxMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371561011", "bodyText": "We can stop the for loop whenever there is a failure in the writeTo method.\nThe benefit of doing so is that every Send is a StoreMessageReadSet here and calling writeTo on StoreMessageReadSet would trigger one disk io operation. Stoping for loop whenever there is a failure would save some disk io.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T00:44:36Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -24,33 +26,48 @@\n  */\n public class CompositeSend implements Send {\n \n-  private final List<Send> compositSendList;\n+  private final List<Send> compositeSendList;\n   private long totalSizeToWrite;\n   private int currentIndexInProgress;\n \n-  public CompositeSend(List<Send> compositSendList) {\n-    this.compositSendList = compositSendList;\n+  public CompositeSend(List<Send> compositeSendList) {\n+    this.compositeSendList = compositeSendList;\n     this.currentIndexInProgress = 0;\n-    for (Send messageFormatSend : compositSendList) {\n+    for (Send messageFormatSend : compositeSendList) {\n       totalSizeToWrite += messageFormatSend.sizeInBytes();\n     }\n   }\n \n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (currentIndexInProgress < compositSendList.size()) {\n-      written = compositSendList.get(currentIndexInProgress).writeTo(channel);\n-      if (compositSendList.get(currentIndexInProgress).isSendComplete()) {\n+    if (currentIndexInProgress < compositeSendList.size()) {\n+      written = compositeSendList.get(currentIndexInProgress).writeTo(channel);\n+      if (compositeSendList.get(currentIndexInProgress).isSendComplete()) {\n         currentIndexInProgress++;\n       }\n     }\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    int lastIndex = compositeSendList.size() - 1;\n+    int i = 0;\n+    for (Send send : compositeSendList) {\n+      if (i == lastIndex) {\n+        // only the last one pass in callback\n+        send.writeTo(channel, callback);\n+      } else {\n+        send.writeTo(channel, null);\n+      }\n+      i++;\n+    }", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxOTQ2Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372019462", "bodyText": "What's your suggestion on how to stop it?", "author": "zzmao", "createdAt": "2020-01-28T19:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MTAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0MTg5MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373641890", "bodyText": "Had offline chat. Looks like there is no immediate way to stop the loop, because exception happens in callback.  But will enhance callback logic in next PR.", "author": "zzmao", "createdAt": "2020-01-31T19:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NjI5Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r371566293", "bodyText": "I think we should probably add another handler between IdleStateHandler and Http2MultiplexHandler to deal with IdleStateEvent.\nHttp2MulitiplexHandler doesn't seem like it will handle IdleStateEvent, so we would probably see all the children channels would be triggered by this event.", "author": "justinlin-linkedin", "createdAt": "2020-01-28T01:05:56Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import java.net.InetSocketAddress;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link StorageServerNettyFactory}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class StorageServerNettyChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  private final ConnectionStatsHandler connectionStatsHandler;\n+  private final RestRequestHandler requestHandler;\n+  private final RestServerState restServerState;\n+  private final SSLFactory sslFactory;\n+\n+  /**\n+   * Construct a {@link StorageServerNettyChannelInitializer}.\n+   * @param nettyConfig the config to use when instantiating certain handlers on this pipeline.\n+   * @param performanceConfig the config to use when evaluating ambry service level objectives that include latency.\n+   * @param nettyMetrics the {@link NettyMetrics} object to use.\n+   * @param connectionStatsHandler the {@link ConnectionStatsHandler} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to handle requests on this pipeline.\n+   * @param restServerState the {@link RestServerState} object to use.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public StorageServerNettyChannelInitializer(NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      NettyMetrics nettyMetrics, ConnectionStatsHandler connectionStatsHandler, RestRequestHandler requestHandler,\n+      RestServerState restServerState, SSLFactory sslFactory, MetricRegistry metricRegistry) {\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.nettyMetrics = nettyMetrics;\n+    this.connectionStatsHandler = connectionStatsHandler;\n+    this.restServerState = restServerState;\n+    this.sslFactory = sslFactory;\n+    RestRequestMetricsTracker.setDefaults(metricRegistry);\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    // If channel handler implementations are not annotated with @Sharable, Netty creates a new instance of every class\n+    // in the pipeline for every connection.\n+    // i.e. if there are a 1000 active connections there will be a 1000 NettyMessageProcessor instances.\n+    ChannelPipeline pipeline = ch.pipeline();\n+    // connection stats handler to track connection related metrics\n+    // if SSL is enabled, add an SslHandler before the HTTP codec\n+    if (sslFactory != null) {\n+      InetSocketAddress peerAddress = ch.remoteAddress();\n+      String peerHost = peerAddress.getHostName();\n+      int peerPort = peerAddress.getPort();\n+      SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(peerHost, peerPort, SSLFactory.Mode.SERVER));\n+      pipeline.addLast(\"SslHandler\", sslHandler);\n+    }\n+    pipeline.addLast(Http2FrameCodecBuilder.forServer().build())\n+        .addLast(\"IdleStateHandler\", new IdleStateHandler(0, 0, nettyConfig.nettyServerIdleTimeSeconds))\n+        .addLast(\"Http2MultiplexHandler\", new Http2MultiplexHandler(\n+            new Http2StreamHandler(nettyMetrics, nettyConfig, performanceConfig, requestHandler)));", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyOTEyMA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372029120", "bodyText": "Got you. Let me think about this.", "author": "zzmao", "createdAt": "2020-01-28T20:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NjI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NDkyNQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373644925", "bodyText": "OK to remove IdleStateHandler as discussed offline.", "author": "zzmao", "createdAt": "2020-01-31T19:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2NjI5Mw=="}], "type": "inlineReview"}, {"oid": "ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "url": "https://github.com/linkedin/ambry/commit/ee8045e621b9579d6fedd4ccb4ee975ce5791fdf", "message": "address comments and fix conflict", "committedDate": "2020-01-31T19:36:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMDE0NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372020145", "bodyText": "waif -> wait", "author": "cgtz", "createdAt": "2020-01-28T19:49:17Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java", "diffHunk": "@@ -308,14 +308,16 @@ private boolean handleRequest(HttpRequest httpRequest) throws RestServiceExcepti\n           }\n           responseChannel.setRequest(request);\n           logger.trace(\"Channel {} now handling request {}\", ctx.channel(), request.getUri());\n-          // We send POST that is not multipart for handling immediately since we expect valid content with it that will\n-          // be streamed in. In the case of POST that is multipart, all the content has to be received for Netty's\n+          // We send POST that is not multipart or not http2 for handling immediately since we expect valid content with it that will\n+          // be streamed in.\n+          // In the case of POST that is multipart, all the content has to be received for Netty's\n           // decoder and NettyMultipartRequest to work. So it is scheduled for handling when LastHttpContent is received.\n           // With any other method that we support, we do not expect any valid content. LastHttpContent is a Netty thing.\n           // So we wait for LastHttpContent (throw an error if we don't receive it or receive something else) and then\n           // schedule the other methods for handling in handleContent().\n+          // For HTTP2 from frontend, waif for all contents to be received.", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMjYwMw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r372022603", "bodyText": "Should this header be set for server -> server replication requests made for replication? If so, could we rename it to \"x-ambry-internal-protocol-request\" or similar?", "author": "cgtz", "createdAt": "2020-01-28T19:54:11Z", "path": "ambry-api/src/main/java/com.github.ambry/rest/RestUtils.java", "diffHunk": "@@ -216,6 +216,11 @@\n      * Response header indicating the reason a request is non compliant.\n      */\n     public final static String NON_COMPLIANCE_WARNING = \"x-ambry-non-compliance-warning\";\n+    \n+    /**\n+     * Request header indicating a HTTP2 request from frontend to server.\n+     */\n+    public final static String HTTP2_FRONTEND_REQUEST = \"x-ambry-http2-frontend-request\";", "originalCommit": "dd6d62a2823ece52260f0ca64e8fc77cb108f555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMjQ4NA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374412484", "bodyText": "how about x-ambry-internal-http2-request?", "author": "zzmao", "createdAt": "2020-02-04T00:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMjYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTQ2NA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373889464", "bodyText": "can you leave a todo here since we will probably have to go back and implement this. Also, this should take Callback<Void>", "author": "cgtz", "createdAt": "2020-02-03T00:38:03Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java", "diffHunk": "@@ -66,6 +68,11 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTQ5NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373889495", "bodyText": "Callback<Long>", "author": "cgtz", "createdAt": "2020-02-03T00:38:18Z", "path": "ambry-messageformat/src/main/java/com.github.ambry.messageformat/MessageFormatSend.java", "diffHunk": "@@ -266,6 +268,11 @@ public long writeTo(WritableByteChannel channel) throws IOException {\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTUzMw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373889533", "bodyText": "Callback<Void>", "author": "cgtz", "createdAt": "2020-02-03T00:38:55Z", "path": "ambry-messageformat/src/test/java/com.github.ambry.messageformat/MessageFormatSendTest.java", "diffHunk": "@@ -86,6 +88,11 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n       return written;\n     }\n \n+    @Override\n+    public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTcxNw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373889717", "bodyText": "nit: this isn't exactly a result of an interrupt, so I think throwing a RuntimeException like IllegalStateException would be a better fit here.", "author": "cgtz", "createdAt": "2020-02-03T00:41:26Z", "path": "ambry-network/src/main/java/com.github.ambry.network/NettyServerRequestResponseChannel.java", "diffHunk": "@@ -32,6 +33,14 @@ public NettyServerRequestResponseChannel(int queueSize) {\n   /** Send a request to be handled, potentially blocking until there is room in the queue for the request */\n   @Override\n   public void sendRequest(NetworkRequest request) throws InterruptedException {\n+    DataInputStream stream = new DataInputStream(request.getInputStream());\n+    try {\n+      // The first 8 bytes is size of the request. TCP implementation uses this size to allocate buffer. See {@link BoundedReceive}\n+      // Here we just need to consume it.\n+      stream.readLong();\n+    } catch (IOException e) {\n+      throw new InterruptedException(\"stream read error.\" + e);", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzODU5NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r375438595", "bodyText": "fixed.", "author": "zzmao", "createdAt": "2020-02-05T18:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg4OTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDU0OA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373890548", "bodyText": "Callback<Long> here and in any similar places. Generally try to specify the type parameter in the implementation when the interface explicitly specifies one. This will compile but it limits the compiler's ability to type check, e.g. on line 60.", "author": "cgtz", "createdAt": "2020-02-03T00:51:34Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -24,33 +26,49 @@\n  */\n public class CompositeSend implements Send {\n \n-  private final List<Send> compositSendList;\n+  private final List<Send> compositeSendList;\n   private long totalSizeToWrite;\n   private int currentIndexInProgress;\n \n-  public CompositeSend(List<Send> compositSendList) {\n-    this.compositSendList = compositSendList;\n+  public CompositeSend(List<Send> compositeSendList) {\n+    this.compositeSendList = compositeSendList;\n     this.currentIndexInProgress = 0;\n-    for (Send messageFormatSend : compositSendList) {\n+    for (Send messageFormatSend : compositeSendList) {\n       totalSizeToWrite += messageFormatSend.sizeInBytes();\n     }\n   }\n \n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (currentIndexInProgress < compositSendList.size()) {\n-      written = compositSendList.get(currentIndexInProgress).writeTo(channel);\n-      if (compositSendList.get(currentIndexInProgress).isSendComplete()) {\n+    if (currentIndexInProgress < compositeSendList.size()) {\n+      written = compositeSendList.get(currentIndexInProgress).writeTo(channel);\n+      if (compositeSendList.get(currentIndexInProgress).isSendComplete()) {\n         currentIndexInProgress++;\n       }\n     }\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxNDUyOA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374414528", "bodyText": "addressing all callback issue.", "author": "zzmao", "createdAt": "2020-02-04T00:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNjY3Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373926673", "bodyText": "Callback<Void>", "author": "cgtz", "createdAt": "2020-02-03T05:26:14Z", "path": "ambry-messageformat/src/test/java/com.github.ambry.messageformat/BlobStoreHardDeleteTest.java", "diffHunk": "@@ -286,6 +288,11 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n         return channel.write(ByteBuffer.wrap(toReturn));\n       }\n \n+      @Override\n+      public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNzIzNQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373927235", "bodyText": "Sorry, I think I suggested Callback<Void> in a previous comment. To align with Send and AsyncWritableChannel it may be better to have a Callback<Long> where the result is the total number of bytes written.", "author": "cgtz", "createdAt": "2020-02-03T05:29:47Z", "path": "ambry-api/src/main/java/com.github.ambry/store/MessageReadSet.java", "diffHunk": "@@ -36,7 +38,16 @@\n   long writeTo(int index, WritableByteChannel channel, long relativeOffset, long maxSize) throws IOException;\n \n   /**\n-   * Returns the total number of messages in this set\n+   * This method is intend to write prefetched data from {@link MessageReadSet} to {@link AsyncWritableChannel}. Data\n+   * should be ready in memory(no blocking call) before write to {@link AsyncWritableChannel} asynchronously. Callback is\n+   * called when the entire batch of writes succeeds or fails.\n+   * @param channel the channel into which the data needs to be written to\n+   * @param callback The callback when data is fully wrote to the channel.\n+   * @throws IOException If prefetch is not used.\n+   */\n+  void writeTo(AsyncWritableChannel channel, Callback<Void> callback) throws IOException;", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNzU4NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373927585", "bodyText": "This callback technically won't be set to the correct value since it will only reflect the size of the last send, not all sends in the batch. This may not currently be a problem but is something to look out for.", "author": "cgtz", "createdAt": "2020-02-03T05:31:41Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/CompositeSend.java", "diffHunk": "@@ -24,33 +26,49 @@\n  */\n public class CompositeSend implements Send {\n \n-  private final List<Send> compositSendList;\n+  private final List<Send> compositeSendList;\n   private long totalSizeToWrite;\n   private int currentIndexInProgress;\n \n-  public CompositeSend(List<Send> compositSendList) {\n-    this.compositSendList = compositSendList;\n+  public CompositeSend(List<Send> compositeSendList) {\n+    this.compositeSendList = compositeSendList;\n     this.currentIndexInProgress = 0;\n-    for (Send messageFormatSend : compositSendList) {\n+    for (Send messageFormatSend : compositeSendList) {\n       totalSizeToWrite += messageFormatSend.sizeInBytes();\n     }\n   }\n \n   @Override\n   public long writeTo(WritableByteChannel channel) throws IOException {\n     long written = 0;\n-    if (currentIndexInProgress < compositSendList.size()) {\n-      written = compositSendList.get(currentIndexInProgress).writeTo(channel);\n-      if (compositSendList.get(currentIndexInProgress).isSendComplete()) {\n+    if (currentIndexInProgress < compositeSendList.size()) {\n+      written = compositeSendList.get(currentIndexInProgress).writeTo(channel);\n+      if (compositeSendList.get(currentIndexInProgress).isSendComplete()) {\n         currentIndexInProgress++;\n       }\n     }\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback callback) throws IOException {\n+    int lastIndex = compositeSendList.size() - 1;\n+    int i = 0;\n+    for (Send send : compositeSendList) {\n+      if (i == lastIndex) {\n+        // only the last one pass in callback\n+        send.writeTo(channel, callback);", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzOTUxNg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r375439516", "bodyText": "added a comment", "author": "zzmao", "createdAt": "2020-02-05T18:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyNzU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyODQ0MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373928440", "bodyText": "I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.", "author": "cgtz", "createdAt": "2020-02-03T05:36:58Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/Response.java", "diffHunk": "@@ -42,16 +44,26 @@ protected void writeHeader() {\n     bufferToSend.putShort((short) error.ordinal());\n   }\n \n-  @Override\n-  public long writeTo(WritableByteChannel channel) throws IOException {\n+  private void prepareBuffer() {\n     if (bufferToSend == null) {\n       bufferToSend = ByteBuffer.allocate((int) sizeInBytes());\n       writeHeader();\n       bufferToSend.flip();\n     }\n+  }\n+\n+  @Override\n+  public long writeTo(WritableByteChannel channel) throws IOException {\n+    prepareBuffer();\n     return bufferToSend.remaining() > 0 ? channel.write(bufferToSend) : 0;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) throws IOException {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNDUyNA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374424524", "bodyText": "This is a good suggestion. IOException is not needed.", "author": "zzmao", "createdAt": "2020-02-04T00:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyODQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyOTEyMQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373929121", "bodyText": "final", "author": "cgtz", "createdAt": "2020-02-03T05:40:47Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.router.Callback;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http2.HttpConversionUtil;\n+import io.netty.util.AttributeKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n+ */\n+@ChannelHandler.Sharable\n+public class Http2ResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n+  public static AttributeKey<Callback<ByteBuf>> RESPONSE_CALLBACK = AttributeKey.newInstance(\"responseCallback\");", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkyOTI4NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373929285", "bodyText": "why is this protected? couldn't it be static and private?", "author": "cgtz", "createdAt": "2020-02-03T05:41:52Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ResponseHandler.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.router.Callback;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http2.HttpConversionUtil;\n+import io.netty.util.AttributeKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n+ */\n+@ChannelHandler.Sharable\n+public class Http2ResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n+  public static AttributeKey<Callback<ByteBuf>> RESPONSE_CALLBACK = AttributeKey.newInstance(\"responseCallback\");\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMDc5Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373930792", "bodyText": "why does all content need to be received before calling handleRequest for HTTP2? Are there cases that CopyingAsyncWritableChannel will not handle correctly?", "author": "cgtz", "createdAt": "2020-02-03T05:50:39Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettyMessageProcessor.java", "diffHunk": "@@ -308,14 +308,16 @@ private boolean handleRequest(HttpRequest httpRequest) throws RestServiceExcepti\n           }\n           responseChannel.setRequest(request);\n           logger.trace(\"Channel {} now handling request {}\", ctx.channel(), request.getUri());\n-          // We send POST that is not multipart for handling immediately since we expect valid content with it that will\n-          // be streamed in. In the case of POST that is multipart, all the content has to be received for Netty's\n+          // We send POST that is not multipart or not http2 for handling immediately since we expect valid content with it that will\n+          // be streamed in.\n+          // In the case of POST that is multipart, all the content has to be received for Netty's\n           // decoder and NettyMultipartRequest to work. So it is scheduled for handling when LastHttpContent is received.\n           // With any other method that we support, we do not expect any valid content. LastHttpContent is a Netty thing.\n           // So we wait for LastHttpContent (throw an error if we don't receive it or receive something else) and then\n           // schedule the other methods for handling in handleContent().\n+          // For HTTP2 from frontend, waif for all contents to be received.\n           if ((request.getRestMethod().equals(RestMethod.POST) || request.getRestMethod().equals(RestMethod.PUT))\n-              && !HttpPostRequestDecoder.isMultipart(httpRequest)) {\n+              && !HttpPostRequestDecoder.isMultipart(httpRequest) && !request.isHttp2RequestFromFrontend()) {\n             requestHandler.handleRequest(request, responseChannel);", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTA0NA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373931044", "bodyText": "why remove this comment?", "author": "cgtz", "createdAt": "2020-02-03T05:51:58Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettySslHttp2Factory.java", "diffHunk": "@@ -39,7 +39,6 @@\n \n /**\n  * An HTTP/2 specific implementation of {@link SSLFactory} that uses Netty's SSL libraries for HTTP2.", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjA4OA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374426088", "bodyText": "added back.", "author": "zzmao", "createdAt": "2020-02-04T01:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTQ2MA==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373931460", "bodyText": "For http2 is it even an option to not set up SSL? You could use Objects.requireNonNull in the constructor", "author": "cgtz", "createdAt": "2020-02-03T05:54:18Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import java.net.InetSocketAddress;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link StorageServerNettyFactory}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class StorageServerNettyChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  private final ConnectionStatsHandler connectionStatsHandler;\n+  private final RestRequestHandler requestHandler;\n+  private final RestServerState restServerState;\n+  private final SSLFactory sslFactory;\n+\n+  /**\n+   * Construct a {@link StorageServerNettyChannelInitializer}.\n+   * @param nettyConfig the config to use when instantiating certain handlers on this pipeline.\n+   * @param performanceConfig the config to use when evaluating ambry service level objectives that include latency.\n+   * @param nettyMetrics the {@link NettyMetrics} object to use.\n+   * @param connectionStatsHandler the {@link ConnectionStatsHandler} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to handle requests on this pipeline.\n+   * @param restServerState the {@link RestServerState} object to use.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public StorageServerNettyChannelInitializer(NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      NettyMetrics nettyMetrics, ConnectionStatsHandler connectionStatsHandler, RestRequestHandler requestHandler,\n+      RestServerState restServerState, SSLFactory sslFactory, MetricRegistry metricRegistry) {\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.nettyMetrics = nettyMetrics;\n+    this.connectionStatsHandler = connectionStatsHandler;\n+    this.restServerState = restServerState;\n+    this.sslFactory = sslFactory;\n+    RestRequestMetricsTracker.setDefaults(metricRegistry);\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    // If channel handler implementations are not annotated with @Sharable, Netty creates a new instance of every class\n+    // in the pipeline for every connection.\n+    // i.e. if there are a 1000 active connections there will be a 1000 NettyMessageProcessor instances.\n+    ChannelPipeline pipeline = ch.pipeline();\n+    // connection stats handler to track connection related metrics\n+    // if SSL is enabled, add an SslHandler before the HTTP codec\n+    if (sslFactory != null) {", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjgxOQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374426819", "bodyText": "added.", "author": "zzmao", "createdAt": "2020-02-04T01:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTgyNg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373931826", "bodyText": "Was there an issue with adding ConnectionStatsHandler?", "author": "cgtz", "createdAt": "2020-02-03T05:56:18Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/StorageServerNettyChannelInitializer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.NettyConfig;\n+import com.github.ambry.config.PerformanceConfig;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import java.net.InetSocketAddress;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link StorageServerNettyFactory}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class StorageServerNettyChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final NettyConfig nettyConfig;\n+  private final PerformanceConfig performanceConfig;\n+  private final NettyMetrics nettyMetrics;\n+  private final ConnectionStatsHandler connectionStatsHandler;\n+  private final RestRequestHandler requestHandler;\n+  private final RestServerState restServerState;\n+  private final SSLFactory sslFactory;\n+\n+  /**\n+   * Construct a {@link StorageServerNettyChannelInitializer}.\n+   * @param nettyConfig the config to use when instantiating certain handlers on this pipeline.\n+   * @param performanceConfig the config to use when evaluating ambry service level objectives that include latency.\n+   * @param nettyMetrics the {@link NettyMetrics} object to use.\n+   * @param connectionStatsHandler the {@link ConnectionStatsHandler} to use.\n+   * @param requestHandler the {@link RestRequestHandler} to handle requests on this pipeline.\n+   * @param restServerState the {@link RestServerState} object to use.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public StorageServerNettyChannelInitializer(NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n+      NettyMetrics nettyMetrics, ConnectionStatsHandler connectionStatsHandler, RestRequestHandler requestHandler,\n+      RestServerState restServerState, SSLFactory sslFactory, MetricRegistry metricRegistry) {\n+    this.nettyConfig = nettyConfig;\n+    this.performanceConfig = performanceConfig;\n+    this.nettyMetrics = nettyMetrics;\n+    this.connectionStatsHandler = connectionStatsHandler;\n+    this.restServerState = restServerState;\n+    this.sslFactory = sslFactory;\n+    RestRequestMetricsTracker.setDefaults(metricRegistry);\n+    this.requestHandler = requestHandler;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    // If channel handler implementations are not annotated with @Sharable, Netty creates a new instance of every class\n+    // in the pipeline for every connection.\n+    // i.e. if there are a 1000 active connections there will be a 1000 NettyMessageProcessor instances.\n+    ChannelPipeline pipeline = ch.pipeline();\n+    // connection stats handler to track connection related metrics", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNzQ2NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374427465", "bodyText": "added.", "author": "zzmao", "createdAt": "2020-02-04T01:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMjY2Mg==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373932662", "bodyText": "call TestSSLUtils.addHttp2Properties here?", "author": "cgtz", "createdAt": "2020-02-03T06:00:39Z", "path": "ambry-server/src/integration-test/java/com.github.ambry.server/RouterServerPlaintextTest.java", "diffHunk": "@@ -74,7 +74,13 @@ public RouterServerPlaintextTest(boolean testEncryption) {\n   @BeforeClass\n   public static void initializeTests() throws Exception {\n     Properties properties = getRouterProperties(\"DC1\");\n-    plaintextCluster = new MockCluster(new Properties(), false, SystemTime.getInstance());\n+\n+    Properties serverProperties = new Properties();\n+    serverProperties.setProperty(\"rest.server.rest.request.service.factory\",", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNzY4Mw==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r374427683", "bodyText": "fixed.", "author": "zzmao", "createdAt": "2020-02-04T01:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMjY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzMzQ3OQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373933479", "bodyText": "remove println", "author": "cgtz", "createdAt": "2020-02-03T06:05:10Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -96,31 +103,39 @@ public void disconnect() throws IOException {\n \n   @Override\n   public void send(Send request) throws IOException {\n+    System.out.println(\"send\");", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzNDY4NQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r373934685", "bodyText": "Instead of combining ambry callbacks and netty promises here, how about setting the attribute to a CompletableFuture or ambry's FutureResult? Then you can wait on the future without requiring lines 135-137", "author": "cgtz", "createdAt": "2020-02-03T06:10:45Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -96,31 +103,39 @@ public void disconnect() throws IOException {\n \n   @Override\n   public void send(Send request) throws IOException {\n+    System.out.println(\"send\");\n     ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n     while (!request.isSendComplete()) {\n       request.writeTo(byteBufferChannel);\n     }\n     byteBufferChannel.getBuffer().position(0);\n     ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n \n-    Http2ClientStreamInitializer initializer = new Http2ClientStreamInitializer(http2ResponseHandler);\n-    Http2StreamChannel childChannel =\n-        new Http2StreamChannelBootstrap(channel).handler(initializer).open().syncUninterruptibly().getNow();\n+    Http2StreamChannel childChannel = http2StreamChannelBootstrap.open().syncUninterruptibly().getNow();\n     Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+    http2Headers.set(RestUtils.Headers.HTTP2_FRONTEND_REQUEST, \"true\");\n+    channelPromise = childChannel.newPromise();", "originalCommit": "61c22b5638f24e54441b5cf53e37974b5d038aca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5ODg1OQ==", "url": "https://github.com/linkedin/ambry/pull/1352#discussion_r376098859", "bodyText": "nit: UnsupportedOperationException, since NotImplementedException is reflection-specific", "author": "cgtz", "createdAt": "2020-02-06T21:44:08Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudMessageReadSet.java", "diffHunk": "@@ -66,6 +69,12 @@ public long writeTo(int index, WritableByteChannel channel, long relativeOffset,\n     return written;\n   }\n \n+  @Override\n+  public void writeTo(AsyncWritableChannel channel, Callback<Long> callback) {\n+    // TODO: read from cloud based store and write to AsyncWritableChannel is needed in the future.\n+    throw new NotImplementedException();", "originalCommit": "db91456b30ce68b73eb96880e81b057e5992ff65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "url": "https://github.com/linkedin/ambry/commit/c4cb90700b994d8b20a0e5f3a4305fafc96ffe8b", "message": "http2 stroage", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "d19013abc408f99434c8f4589406ff04ea42e778", "url": "https://github.com/linkedin/ambry/commit/d19013abc408f99434c8f4589406ff04ea42e778", "message": "fix properties issue", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "8835a8f73640ba4ade7103d2339d40d5231e8795", "url": "https://github.com/linkedin/ambry/commit/8835a8f73640ba4ade7103d2339d40d5231e8795", "message": "properties issue", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "6c05ac67c6ba99b10981cd9acaf44c35abea1d7d", "url": "https://github.com/linkedin/ambry/commit/6c05ac67c6ba99b10981cd9acaf44c35abea1d7d", "message": "simplify http2 blocking channel", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "fc99a58e1210f3125fcf9149b770813f56d9148f", "url": "https://github.com/linkedin/ambry/commit/fc99a58e1210f3125fcf9149b770813f56d9148f", "message": "working", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "68a59ed4c2f47bccb249c1b0f38efdce623c9a49", "url": "https://github.com/linkedin/ambry/commit/68a59ed4c2f47bccb249c1b0f38efdce623c9a49", "message": "address comments and fix conflict", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "a702ee8b657c198e181bee7fbd0728a41a5d5940", "url": "https://github.com/linkedin/ambry/commit/a702ee8b657c198e181bee7fbd0728a41a5d5940", "message": "remove ambry-router/src/main/java/com.github.ambry.router/Http2NetworkClient.java", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "0a217d67d244b88d6b1075951d723aa540213094", "url": "https://github.com/linkedin/ambry/commit/0a217d67d244b88d6b1075951d723aa540213094", "message": "address cgetz comments", "committedDate": "2020-02-10T21:41:54Z", "type": "commit"}, {"oid": "bf97c505ab7ddf7d1199ad97183eb1696fbcce26", "url": "https://github.com/linkedin/ambry/commit/bf97c505ab7ddf7d1199ad97183eb1696fbcce26", "message": "address last comments.", "committedDate": "2020-02-10T21:47:38Z", "type": "commit"}, {"oid": "bf97c505ab7ddf7d1199ad97183eb1696fbcce26", "url": "https://github.com/linkedin/ambry/commit/bf97c505ab7ddf7d1199ad97183eb1696fbcce26", "message": "address last comments.", "committedDate": "2020-02-10T21:47:38Z", "type": "forcePushed"}, {"oid": "e61ab80edfe913c143ad8045f86c3de829dfc322", "url": "https://github.com/linkedin/ambry/commit/e61ab80edfe913c143ad8045f86c3de829dfc322", "message": "getListOfPorts() fix", "committedDate": "2020-02-10T22:13:46Z", "type": "commit"}, {"oid": "e61ab80edfe913c143ad8045f86c3de829dfc322", "url": "https://github.com/linkedin/ambry/commit/e61ab80edfe913c143ad8045f86c3de829dfc322", "message": "getListOfPorts() fix", "committedDate": "2020-02-10T22:13:46Z", "type": "forcePushed"}]}