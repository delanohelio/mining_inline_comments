{"pr_number": 1667, "pr_title": "Implementation of CompositeAccountService that combines two account service sources", "pr_createdAt": "2020-10-20T20:00:49Z", "pr_url": "https://github.com/linkedin/ambry/pull/1667", "timeline": [{"oid": "e10d5fa51302b9cc4a279a1d32dcd99e9188f197", "url": "https://github.com/linkedin/ambry/commit/e10d5fa51302b9cc4a279a1d32dcd99e9188f197", "message": "Implementation of CompositeAccountService that combines two account service sources. This class can be used for safe migrations between different backing stores.", "committedDate": "2020-10-20T05:42:15Z", "type": "commit"}, {"oid": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "url": "https://github.com/linkedin/ambry/commit/e2af7f0b591cef46b5aff32ea6b98a882770133a", "message": "Add changes to sample get requests for comparision in CompositeAccountService", "committedDate": "2020-10-21T00:09:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4MTgyMw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510581823", "bodyText": "The initial delay is the interval (5 mins by default), is this intended?", "author": "jsjtzyy", "createdAt": "2020-10-23T04:06:33Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4MzczMw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510583733", "bodyText": "It seems compareAccountMetadata method does an exhaustive check periodically. Any specific reason to do a sampling check?", "author": "jsjtzyy", "createdAt": "2020-10-23T04:15:36Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)\n+        && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountId ={}\", accountId);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    Account primaryResult = primaryAccountService.getAccountByName(accountName);\n+    Account secondaryResult = secondaryAccountService.getAccountByName(accountName);\n+    if (++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck && primaryResult != null\n+        && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}\", accountName);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY1MTYxNA==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510651614", "bodyText": "That was my idea, and now I'm having second thoughts about it too.", "author": "lightningrob", "createdAt": "2020-10-23T06:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4MzczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NDg1MA==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510584850", "bodyText": "Make these AtomicLong", "author": "jsjtzyy", "createdAt": "2020-10-23T04:21:00Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxNTM2MQ==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510615361", "bodyText": "That could make the variable a hot spot with many threads updating it.\nWe could dispense with the variables and just use a Random to get next value in [0,100].", "author": "lightningrob", "createdAt": "2020-10-23T05:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NDg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NTA5Mg==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510585092", "bodyText": "getAccountRequestCount.addAndGet(1)", "author": "jsjtzyy", "createdAt": "2020-10-23T04:22:03Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxNzg4OQ==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510617889", "bodyText": "Can call a local method like shouldCompare() which can do the modulo.\nAlso, if it's not time to compare, should skip calling secondaryService.", "author": "lightningrob", "createdAt": "2020-10-23T05:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NjM0NQ==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510586345", "bodyText": "Single container comparison is lightweight, it probably doesn't need sampling.", "author": "jsjtzyy", "createdAt": "2020-10-23T04:27:14Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)\n+        && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountId ={}\", accountId);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    Account primaryResult = primaryAccountService.getAccountByName(accountName);\n+    Account secondaryResult = secondaryAccountService.getAccountByName(accountName);\n+    if (++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck && primaryResult != null\n+        && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}\", accountName);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void updateAccounts(Collection<Account> accounts) throws AccountServiceException {\n+    primaryAccountService.updateAccounts(accounts);\n+    try {\n+      secondaryAccountService.updateAccounts(accounts);\n+      // Not comparing updated accounts list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update accounts failed for secondary source\", e);\n+      accountServiceMetrics.updateAccountInconsistencyCount.inc();\n+    }\n+  }\n+\n+  @Override\n+  public Collection<Account> getAllAccounts() {\n+    return primaryAccountService.getAllAccounts();\n+  }\n+\n+  @Override\n+  public boolean addAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.addAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.removeAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public Collection<Container> updateContainers(String accountName, Collection<Container> containers)\n+      throws AccountServiceException {\n+    Collection<Container> primaryResult = primaryAccountService.updateContainers(accountName, containers);\n+    try {\n+      secondaryAccountService.updateContainers(accountName, containers);\n+      // Not comparing updated containers list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update containers failed for secondary source\", e);\n+      accountServiceMetrics.updateContainerInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Container getContainer(String accountName, String containerName) throws AccountServiceException {\n+    Container primaryResult = primaryAccountService.getContainer(accountName, containerName);\n+    try {\n+      Container secondaryResult = secondaryAccountService.getContainer(accountName, containerName);\n+      if (++getContainerRequestCount % 100 < config.samplingPercentageForGetContainerConsistencyCheck", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NzIzNA==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510587234", "bodyText": "We probably need to rename this method to fit in MySqlAccountService (or probably remove this method as we use a different way to mark inactive container)", "author": "jsjtzyy", "createdAt": "2020-10-23T04:31:06Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)\n+        && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountId ={}\", accountId);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    Account primaryResult = primaryAccountService.getAccountByName(accountName);\n+    Account secondaryResult = secondaryAccountService.getAccountByName(accountName);\n+    if (++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck && primaryResult != null\n+        && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}\", accountName);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void updateAccounts(Collection<Account> accounts) throws AccountServiceException {\n+    primaryAccountService.updateAccounts(accounts);\n+    try {\n+      secondaryAccountService.updateAccounts(accounts);\n+      // Not comparing updated accounts list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update accounts failed for secondary source\", e);\n+      accountServiceMetrics.updateAccountInconsistencyCount.inc();\n+    }\n+  }\n+\n+  @Override\n+  public Collection<Account> getAllAccounts() {\n+    return primaryAccountService.getAllAccounts();\n+  }\n+\n+  @Override\n+  public boolean addAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.addAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.removeAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public Collection<Container> updateContainers(String accountName, Collection<Container> containers)\n+      throws AccountServiceException {\n+    Collection<Container> primaryResult = primaryAccountService.updateContainers(accountName, containers);\n+    try {\n+      secondaryAccountService.updateContainers(accountName, containers);\n+      // Not comparing updated containers list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update containers failed for secondary source\", e);\n+      accountServiceMetrics.updateContainerInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Container getContainer(String accountName, String containerName) throws AccountServiceException {\n+    Container primaryResult = primaryAccountService.getContainer(accountName, containerName);\n+    try {\n+      Container secondaryResult = secondaryAccountService.getContainer(accountName, containerName);\n+      if (++getContainerRequestCount % 100 < config.samplingPercentageForGetContainerConsistencyCheck\n+          && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+        logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}, containerName = {}\",\n+            accountName, containerName);\n+        accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+      }\n+    } catch (Exception e) {\n+      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+      logger.error(\"get container failed for secondary for accountName={}, containerName={}\", accountName,\n+          containerName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Set<Container> getContainersByStatus(Container.ContainerStatus containerStatus) {\n+    Set<Container> primaryResult = primaryAccountService.getContainersByStatus(containerStatus);\n+    Set<Container> secondaryResult = secondaryAccountService.getContainersByStatus(containerStatus);\n+    if (!primaryResult.equals(secondaryResult)) {\n+      logger.warn(\n+          \"Inconsistency detected between primary and secondary for containers with status ={}, primary ={}, secondary = {}\",\n+          containerStatus, primaryResult, secondaryResult);\n+      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void selectInactiveContainersAndMarkInZK(StatsSnapshot statsSnapshot) {", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYyODI2OA==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510628268", "bodyText": "Already planned.", "author": "lightningrob", "createdAt": "2020-10-23T05:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4NzQzMw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510587433", "bodyText": "selectInactiveContainersAndMarkInZK is not implemented in MysqlAccountService.", "author": "jsjtzyy", "createdAt": "2020-10-23T04:31:52Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)\n+        && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountId ={}\", accountId);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    Account primaryResult = primaryAccountService.getAccountByName(accountName);\n+    Account secondaryResult = secondaryAccountService.getAccountByName(accountName);\n+    if (++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck && primaryResult != null\n+        && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}\", accountName);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void updateAccounts(Collection<Account> accounts) throws AccountServiceException {\n+    primaryAccountService.updateAccounts(accounts);\n+    try {\n+      secondaryAccountService.updateAccounts(accounts);\n+      // Not comparing updated accounts list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update accounts failed for secondary source\", e);\n+      accountServiceMetrics.updateAccountInconsistencyCount.inc();\n+    }\n+  }\n+\n+  @Override\n+  public Collection<Account> getAllAccounts() {\n+    return primaryAccountService.getAllAccounts();\n+  }\n+\n+  @Override\n+  public boolean addAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.addAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.removeAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public Collection<Container> updateContainers(String accountName, Collection<Container> containers)\n+      throws AccountServiceException {\n+    Collection<Container> primaryResult = primaryAccountService.updateContainers(accountName, containers);\n+    try {\n+      secondaryAccountService.updateContainers(accountName, containers);\n+      // Not comparing updated containers list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update containers failed for secondary source\", e);\n+      accountServiceMetrics.updateContainerInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Container getContainer(String accountName, String containerName) throws AccountServiceException {\n+    Container primaryResult = primaryAccountService.getContainer(accountName, containerName);\n+    try {\n+      Container secondaryResult = secondaryAccountService.getContainer(accountName, containerName);\n+      if (++getContainerRequestCount % 100 < config.samplingPercentageForGetContainerConsistencyCheck\n+          && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+        logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}, containerName = {}\",\n+            accountName, containerName);\n+        accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+      }\n+    } catch (Exception e) {\n+      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+      logger.error(\"get container failed for secondary for accountName={}, containerName={}\", accountName,\n+          containerName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Set<Container> getContainersByStatus(Container.ContainerStatus containerStatus) {\n+    Set<Container> primaryResult = primaryAccountService.getContainersByStatus(containerStatus);\n+    Set<Container> secondaryResult = secondaryAccountService.getContainersByStatus(containerStatus);\n+    if (!primaryResult.equals(secondaryResult)) {\n+      logger.warn(\n+          \"Inconsistency detected between primary and secondary for containers with status ={}, primary ={}, secondary = {}\",\n+          containerStatus, primaryResult, secondaryResult);\n+      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void selectInactiveContainersAndMarkInZK(StatsSnapshot statsSnapshot) {\n+    primaryAccountService.selectInactiveContainersAndMarkInZK(statsSnapshot);\n+    try {\n+      secondaryAccountService.selectInactiveContainersAndMarkInZK(statsSnapshot);\n+    } catch (Exception e) {", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4ODA0MA==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510588040", "bodyText": "Note that primaryAccounts.removeAll() returns a boolean value rather than inconsistent accounts set.", "author": "jsjtzyy", "createdAt": "2020-10-23T04:34:48Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)\n+        && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountId ={}\", accountId);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    Account primaryResult = primaryAccountService.getAccountByName(accountName);\n+    Account secondaryResult = secondaryAccountService.getAccountByName(accountName);\n+    if (++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck && primaryResult != null\n+        && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}\", accountName);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void updateAccounts(Collection<Account> accounts) throws AccountServiceException {\n+    primaryAccountService.updateAccounts(accounts);\n+    try {\n+      secondaryAccountService.updateAccounts(accounts);\n+      // Not comparing updated accounts list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update accounts failed for secondary source\", e);\n+      accountServiceMetrics.updateAccountInconsistencyCount.inc();\n+    }\n+  }\n+\n+  @Override\n+  public Collection<Account> getAllAccounts() {\n+    return primaryAccountService.getAllAccounts();\n+  }\n+\n+  @Override\n+  public boolean addAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.addAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.removeAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public Collection<Container> updateContainers(String accountName, Collection<Container> containers)\n+      throws AccountServiceException {\n+    Collection<Container> primaryResult = primaryAccountService.updateContainers(accountName, containers);\n+    try {\n+      secondaryAccountService.updateContainers(accountName, containers);\n+      // Not comparing updated containers list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update containers failed for secondary source\", e);\n+      accountServiceMetrics.updateContainerInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Container getContainer(String accountName, String containerName) throws AccountServiceException {\n+    Container primaryResult = primaryAccountService.getContainer(accountName, containerName);\n+    try {\n+      Container secondaryResult = secondaryAccountService.getContainer(accountName, containerName);\n+      if (++getContainerRequestCount % 100 < config.samplingPercentageForGetContainerConsistencyCheck\n+          && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+        logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}, containerName = {}\",\n+            accountName, containerName);\n+        accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+      }\n+    } catch (Exception e) {\n+      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+      logger.error(\"get container failed for secondary for accountName={}, containerName={}\", accountName,\n+          containerName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Set<Container> getContainersByStatus(Container.ContainerStatus containerStatus) {\n+    Set<Container> primaryResult = primaryAccountService.getContainersByStatus(containerStatus);\n+    Set<Container> secondaryResult = secondaryAccountService.getContainersByStatus(containerStatus);\n+    if (!primaryResult.equals(secondaryResult)) {\n+      logger.warn(\n+          \"Inconsistency detected between primary and secondary for containers with status ={}, primary ={}, secondary = {}\",\n+          containerStatus, primaryResult, secondaryResult);\n+      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void selectInactiveContainersAndMarkInZK(StatsSnapshot statsSnapshot) {\n+    primaryAccountService.selectInactiveContainersAndMarkInZK(statsSnapshot);\n+    try {\n+      secondaryAccountService.selectInactiveContainersAndMarkInZK(statsSnapshot);\n+    } catch (Exception e) {\n+      logger.warn(\"Marking containers as inactive failed for secondary\", e);\n+      accountServiceMetrics.updateContainerInconsistencyCount.inc();\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      primaryAccountService.close();\n+    } finally {\n+      secondaryAccountService.close();\n+    }\n+    shutDownExecutorService(scheduler, config.consistencyCheckerShutdownTimeoutMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  /**\n+   * Compares and logs differences (if any) in Account metadata stored in primary and secondary sources\n+   */\n+  private void compareAccountMetadata() {\n+    Set<Account> primaryAccounts = new HashSet<>(primaryAccountService.getAllAccounts());\n+    Set<Account> secondaryAccounts = new HashSet<>(secondaryAccountService.getAllAccounts());\n+    if (!primaryAccounts.equals(secondaryAccounts)) {\n+      accountServiceMetrics.accountMetadataInconsistencyCount.inc();\n+      logger.debug(\"Inconsistency detected between primary and secondary at {} for accounts ={}\",\n+          SystemTime.getInstance().milliseconds(), primaryAccounts.removeAll(secondaryAccounts));", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYzODkyMw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510638923", "bodyText": "This will be unreadable (and we won't see it anyway without debug turned on).\nI would make it a more detailed comparison, where we report each account and container that is not in both services or not equal.  Example output:\nAccount found in primary, absent in secondary: {\"name\": \"samza test\", \"id\": 101, ...}\nContainer mismatch: primary has {\"name\": \"uploads\", \"id\":5, \"encrypted\":\"true\",...}, secondary has {\"name\": \"uploads\", \"id\":5, \"encrypted\":\"false\",...}\nAnd log the result at warn level.", "author": "lightningrob", "createdAt": "2020-10-23T05:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4ODA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4OTY1NA==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510589654", "bodyText": "getTestAccount() is called in several places and the method instantiates same account/container several times. Why not have a global testAccount?", "author": "jsjtzyy", "createdAt": "2020-10-23T04:42:33Z", "path": "ambry-account/src/test/java/com/github/ambry/account/CompositeAccountServiceTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.TestUtils;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+public class CompositeAccountServiceTest {\n+\n+  AccountService primaryAccountService = mock(HelixAccountService.class);\n+  AccountService secondaryAccountService = mock(MySqlAccountService.class);\n+  AccountServiceMetrics metrics = new AccountServiceMetrics(new MetricRegistry());\n+  Properties props = new Properties();\n+  AccountService compositeAccountService;\n+\n+  public CompositeAccountServiceTest() {\n+    compositeAccountService = new CompositeAccountService(primaryAccountService, secondaryAccountService, metrics,\n+        new CompositeAccountServiceConfig(new VerifiableProperties(props)));\n+  }\n+\n+  /**\n+   * Test composite getAccountById() with both sources returning the same result.\n+   */\n+  @Test\n+  public void testGetAccountByIdBothSuccess() {\n+    Account testAccount = getTestAccount();", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU5MDY1Mw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510590653", "bodyText": "typo: comparison", "author": "jsjtzyy", "createdAt": "2020-10-23T04:46:50Z", "path": "ambry-api/src/main/java/com/github/ambry/config/CompositeAccountServiceConfig.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Configs for CompositeAccountService\n+ */\n+public class CompositeAccountServiceConfig {\n+  public static final String COMPOSITE_ACCOUNT_SERVICE_PREFIX = \"composite.account.service.\";\n+  public static final String CONSISTENCY_CHECKER_INTERVAL_MINUTES =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"consistency.checker.interval.minutes\";\n+  public static final String CONSISTENCY_CHECKER_SHUTDOWN_TIMEOUT_MINUTES =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"consistency.checker.shutdown.timeout.minutes\";\n+  public static final String SAMPLING_PERCENTAGE_FOR_GET_ACCOUNT_CONSISTENCY_CHECK =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"sampling.percentage.for.get.account.consistency.check\";\n+  public static final String SAMPLING_PERCENTAGE_FOR_GET_CONTAINER_CONSISTENCY_CHECK =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"sampling.percentage.for.get.container.consistency.check\";\n+\n+  /**\n+   * The time interval in minutes for checking consistency in account data between primary and secondary sources.\n+   * Setting to 0 will disable it. Default value is 5 minutes.\n+   */\n+  @Config(CONSISTENCY_CHECKER_INTERVAL_MINUTES)\n+  @Default(\"5\")\n+  public final int consistencyCheckerIntervalMinutes;\n+\n+  /**\n+   * The timeout in minutes to shut down the consistency checker of {@code CompositeAccountService}. Default value is 1 minutes.\n+   */\n+  @Config(CONSISTENCY_CHECKER_SHUTDOWN_TIMEOUT_MINUTES)\n+  @Default(\"1\")\n+  public final int consistencyCheckerShutdownTimeoutMinutes;\n+\n+  /**\n+   * Percentage of {@link com.github.ambry.account.AccountService#getAccountByName(String)} and\n+   * {@link com.github.ambry.account.AccountService#getAccountById(short)} requests for which we want to compare\n+   * results between primary and secondary sources. Default value is 50%. If we want to avoid latency due to comparision,", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU5MDc0Nw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510590747", "bodyText": "typo: comparison", "author": "jsjtzyy", "createdAt": "2020-10-23T04:47:08Z", "path": "ambry-api/src/main/java/com/github/ambry/config/CompositeAccountServiceConfig.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Configs for CompositeAccountService\n+ */\n+public class CompositeAccountServiceConfig {\n+  public static final String COMPOSITE_ACCOUNT_SERVICE_PREFIX = \"composite.account.service.\";\n+  public static final String CONSISTENCY_CHECKER_INTERVAL_MINUTES =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"consistency.checker.interval.minutes\";\n+  public static final String CONSISTENCY_CHECKER_SHUTDOWN_TIMEOUT_MINUTES =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"consistency.checker.shutdown.timeout.minutes\";\n+  public static final String SAMPLING_PERCENTAGE_FOR_GET_ACCOUNT_CONSISTENCY_CHECK =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"sampling.percentage.for.get.account.consistency.check\";\n+  public static final String SAMPLING_PERCENTAGE_FOR_GET_CONTAINER_CONSISTENCY_CHECK =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"sampling.percentage.for.get.container.consistency.check\";\n+\n+  /**\n+   * The time interval in minutes for checking consistency in account data between primary and secondary sources.\n+   * Setting to 0 will disable it. Default value is 5 minutes.\n+   */\n+  @Config(CONSISTENCY_CHECKER_INTERVAL_MINUTES)\n+  @Default(\"5\")\n+  public final int consistencyCheckerIntervalMinutes;\n+\n+  /**\n+   * The timeout in minutes to shut down the consistency checker of {@code CompositeAccountService}. Default value is 1 minutes.\n+   */\n+  @Config(CONSISTENCY_CHECKER_SHUTDOWN_TIMEOUT_MINUTES)\n+  @Default(\"1\")\n+  public final int consistencyCheckerShutdownTimeoutMinutes;\n+\n+  /**\n+   * Percentage of {@link com.github.ambry.account.AccountService#getAccountByName(String)} and\n+   * {@link com.github.ambry.account.AccountService#getAccountById(short)} requests for which we want to compare\n+   * results between primary and secondary sources. Default value is 50%. If we want to avoid latency due to comparision,\n+   * this value can be set to 0.\n+   */\n+  @Config(SAMPLING_PERCENTAGE_FOR_GET_ACCOUNT_CONSISTENCY_CHECK)\n+  @Default(\"50\")\n+  public final int samplingPercentageForGetAccountConsistencyCheck;\n+\n+  /**\n+   * Percentage of {@link com.github.ambry.account.AccountService#getContainer(String, String)} requests for which we\n+   * want to compare results between primary and secondary sources. Default value is 50%. If we want to avoid\n+   * latency due to comparision, this value can be set to 0.", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYwNjMzOQ==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510606339", "bodyText": "I think we just need one error counter.", "author": "lightningrob", "createdAt": "2020-10-23T05:22:43Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AccountServiceMetrics.java", "diffHunk": "@@ -48,48 +48,62 @@\n   public final Counter accountDeletesToAmbryServerErrorCount;\n   public final Counter accountFetchFromAmbryServerErrorCount;\n   public final Counter accountUpdatesToZkErrorCount;\n+  public final Counter accountMetadataInconsistencyCount;", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYyMDE4NQ==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510620185", "bodyText": "This can be expensive if it compares all the containers.  I wonder if comparing in the scheduled thread might be enough.", "author": "lightningrob", "createdAt": "2020-10-23T05:37:55Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)\n+        && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountId ={}\", accountId);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    Account primaryResult = primaryAccountService.getAccountByName(accountName);\n+    Account secondaryResult = secondaryAccountService.getAccountByName(accountName);\n+    if (++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck && primaryResult != null\n+        && !primaryResult.equals(secondaryResult)) {", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYyNTMzNQ==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510625335", "bodyText": "I would throw the exception to fail the update.  The secondary service (mysql) should have its own error counter to track its failure, and the inconsistency can be reported by the background thread that does the comparison.  (And the inconsistency should disappear if the client retries the failed operation.)", "author": "lightningrob", "createdAt": "2020-10-23T05:43:45Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)\n+        && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountId ={}\", accountId);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    Account primaryResult = primaryAccountService.getAccountByName(accountName);\n+    Account secondaryResult = secondaryAccountService.getAccountByName(accountName);\n+    if (++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck && primaryResult != null\n+        && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}\", accountName);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void updateAccounts(Collection<Account> accounts) throws AccountServiceException {\n+    primaryAccountService.updateAccounts(accounts);\n+    try {\n+      secondaryAccountService.updateAccounts(accounts);\n+      // Not comparing updated accounts list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update accounts failed for secondary source\", e);", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYyNTcyMw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510625723", "bodyText": "Same as above.", "author": "lightningrob", "createdAt": "2020-10-23T05:44:12Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)\n+        && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountId ={}\", accountId);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    Account primaryResult = primaryAccountService.getAccountByName(accountName);\n+    Account secondaryResult = secondaryAccountService.getAccountByName(accountName);\n+    if (++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck && primaryResult != null\n+        && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}\", accountName);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void updateAccounts(Collection<Account> accounts) throws AccountServiceException {\n+    primaryAccountService.updateAccounts(accounts);\n+    try {\n+      secondaryAccountService.updateAccounts(accounts);\n+      // Not comparing updated accounts list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update accounts failed for secondary source\", e);\n+      accountServiceMetrics.updateAccountInconsistencyCount.inc();\n+    }\n+  }\n+\n+  @Override\n+  public Collection<Account> getAllAccounts() {\n+    return primaryAccountService.getAllAccounts();\n+  }\n+\n+  @Override\n+  public boolean addAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.addAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.removeAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public Collection<Container> updateContainers(String accountName, Collection<Container> containers)\n+      throws AccountServiceException {\n+    Collection<Container> primaryResult = primaryAccountService.updateContainers(accountName, containers);\n+    try {\n+      secondaryAccountService.updateContainers(accountName, containers);\n+      // Not comparing updated containers list as it could increase latency of update operation.\n+    } catch (Exception e) {", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYyOTk3NQ==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510629975", "bodyText": "I would wrap each close in a separate ry-catch to make sure that they and the executor shutdown all get attempted.", "author": "lightningrob", "createdAt": "2020-10-23T05:48:44Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.server.StatsSnapshot;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.utils.Utils.*;\n+\n+\n+/**\n+ * An implementation of {@link AccountService} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between account service implementations using different backing stores.\n+ */\n+public class CompositeAccountService implements AccountService {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CompositeAccountService.class);\n+  private static final String ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX = \"account-data-consistency-checker\";\n+  private final AccountService primaryAccountService;\n+  private final AccountService secondaryAccountService;\n+  private final AccountServiceMetrics accountServiceMetrics;\n+  private final CompositeAccountServiceConfig config;\n+  private final ScheduledExecutorService scheduler;\n+  private static long getAccountRequestCount = 0;\n+  private static long getContainerRequestCount = 0;\n+\n+  public CompositeAccountService(AccountService primaryAccountService, AccountService secondaryAccountService,\n+      AccountServiceMetrics accountServiceMetrics, CompositeAccountServiceConfig config) {\n+    this.primaryAccountService = primaryAccountService;\n+    this.secondaryAccountService = secondaryAccountService;\n+    this.accountServiceMetrics = accountServiceMetrics;\n+    this.config = config;\n+    scheduler = Utils.newScheduler(1, ACCOUNT_DATA_CONSISTENCY_CHECKER_PREFIX, false);\n+    scheduler.scheduleAtFixedRate(this::compareAccountMetadata, config.consistencyCheckerIntervalMinutes,\n+        config.consistencyCheckerIntervalMinutes, TimeUnit.MINUTES);\n+  }\n+\n+  @Override\n+  public Account getAccountById(short accountId) {\n+    Account primaryResult = primaryAccountService.getAccountById(accountId);\n+    Account secondaryResult = secondaryAccountService.getAccountById(accountId);\n+    if ((++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck)\n+        && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountId ={}\", accountId);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Account getAccountByName(String accountName) {\n+    Account primaryResult = primaryAccountService.getAccountByName(accountName);\n+    Account secondaryResult = secondaryAccountService.getAccountByName(accountName);\n+    if (++getAccountRequestCount % 100 < config.samplingPercentageForGetAccountConsistencyCheck && primaryResult != null\n+        && !primaryResult.equals(secondaryResult)) {\n+      logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}\", accountName);\n+      accountServiceMetrics.getAccountDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void updateAccounts(Collection<Account> accounts) throws AccountServiceException {\n+    primaryAccountService.updateAccounts(accounts);\n+    try {\n+      secondaryAccountService.updateAccounts(accounts);\n+      // Not comparing updated accounts list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update accounts failed for secondary source\", e);\n+      accountServiceMetrics.updateAccountInconsistencyCount.inc();\n+    }\n+  }\n+\n+  @Override\n+  public Collection<Account> getAllAccounts() {\n+    return primaryAccountService.getAllAccounts();\n+  }\n+\n+  @Override\n+  public boolean addAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.addAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer) {\n+    return primaryAccountService.removeAccountUpdateConsumer(accountUpdateConsumer);\n+  }\n+\n+  @Override\n+  public Collection<Container> updateContainers(String accountName, Collection<Container> containers)\n+      throws AccountServiceException {\n+    Collection<Container> primaryResult = primaryAccountService.updateContainers(accountName, containers);\n+    try {\n+      secondaryAccountService.updateContainers(accountName, containers);\n+      // Not comparing updated containers list as it could increase latency of update operation.\n+    } catch (Exception e) {\n+      logger.error(\"Update containers failed for secondary source\", e);\n+      accountServiceMetrics.updateContainerInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Container getContainer(String accountName, String containerName) throws AccountServiceException {\n+    Container primaryResult = primaryAccountService.getContainer(accountName, containerName);\n+    try {\n+      Container secondaryResult = secondaryAccountService.getContainer(accountName, containerName);\n+      if (++getContainerRequestCount % 100 < config.samplingPercentageForGetContainerConsistencyCheck\n+          && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+        logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}, containerName = {}\",\n+            accountName, containerName);\n+        accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+      }\n+    } catch (Exception e) {\n+      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+      logger.error(\"get container failed for secondary for accountName={}, containerName={}\", accountName,\n+          containerName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public Set<Container> getContainersByStatus(Container.ContainerStatus containerStatus) {\n+    Set<Container> primaryResult = primaryAccountService.getContainersByStatus(containerStatus);\n+    Set<Container> secondaryResult = secondaryAccountService.getContainersByStatus(containerStatus);\n+    if (!primaryResult.equals(secondaryResult)) {\n+      logger.warn(\n+          \"Inconsistency detected between primary and secondary for containers with status ={}, primary ={}, secondary = {}\",\n+          containerStatus, primaryResult, secondaryResult);\n+      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public void selectInactiveContainersAndMarkInZK(StatsSnapshot statsSnapshot) {\n+    primaryAccountService.selectInactiveContainersAndMarkInZK(statsSnapshot);\n+    try {\n+      secondaryAccountService.selectInactiveContainersAndMarkInZK(statsSnapshot);\n+    } catch (Exception e) {\n+      logger.warn(\"Marking containers as inactive failed for secondary\", e);\n+      accountServiceMetrics.updateContainerInconsistencyCount.inc();\n+    }\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    try {\n+      primaryAccountService.close();\n+    } finally {\n+      secondaryAccountService.close();", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY0NDcyNw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510644727", "bodyText": "Let's combine these into a single sampling rate.", "author": "lightningrob", "createdAt": "2020-10-23T06:03:46Z", "path": "ambry-api/src/main/java/com/github/ambry/config/CompositeAccountServiceConfig.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.config;\n+\n+/**\n+ * Configs for CompositeAccountService\n+ */\n+public class CompositeAccountServiceConfig {\n+  public static final String COMPOSITE_ACCOUNT_SERVICE_PREFIX = \"composite.account.service.\";\n+  public static final String CONSISTENCY_CHECKER_INTERVAL_MINUTES =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"consistency.checker.interval.minutes\";\n+  public static final String CONSISTENCY_CHECKER_SHUTDOWN_TIMEOUT_MINUTES =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"consistency.checker.shutdown.timeout.minutes\";\n+  public static final String SAMPLING_PERCENTAGE_FOR_GET_ACCOUNT_CONSISTENCY_CHECK =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"sampling.percentage.for.get.account.consistency.check\";\n+  public static final String SAMPLING_PERCENTAGE_FOR_GET_CONTAINER_CONSISTENCY_CHECK =\n+      COMPOSITE_ACCOUNT_SERVICE_PREFIX + \"sampling.percentage.for.get.container.consistency.check\";\n+\n+  /**\n+   * The time interval in minutes for checking consistency in account data between primary and secondary sources.\n+   * Setting to 0 will disable it. Default value is 5 minutes.\n+   */\n+  @Config(CONSISTENCY_CHECKER_INTERVAL_MINUTES)\n+  @Default(\"5\")\n+  public final int consistencyCheckerIntervalMinutes;\n+\n+  /**\n+   * The timeout in minutes to shut down the consistency checker of {@code CompositeAccountService}. Default value is 1 minutes.\n+   */\n+  @Config(CONSISTENCY_CHECKER_SHUTDOWN_TIMEOUT_MINUTES)\n+  @Default(\"1\")\n+  public final int consistencyCheckerShutdownTimeoutMinutes;\n+\n+  /**\n+   * Percentage of {@link com.github.ambry.account.AccountService#getAccountByName(String)} and\n+   * {@link com.github.ambry.account.AccountService#getAccountById(short)} requests for which we want to compare\n+   * results between primary and secondary sources. Default value is 50%. If we want to avoid latency due to comparision,\n+   * this value can be set to 0.\n+   */\n+  @Config(SAMPLING_PERCENTAGE_FOR_GET_ACCOUNT_CONSISTENCY_CHECK)\n+  @Default(\"50\")\n+  public final int samplingPercentageForGetAccountConsistencyCheck;\n+\n+  /**\n+   * Percentage of {@link com.github.ambry.account.AccountService#getContainer(String, String)} requests for which we\n+   * want to compare results between primary and secondary sources. Default value is 50%. If we want to avoid\n+   * latency due to comparision, this value can be set to 0.\n+   */\n+  @Config(SAMPLING_PERCENTAGE_FOR_GET_CONTAINER_CONSISTENCY_CHECK)", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY0NTA2Nw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r510645067", "bodyText": "javadoc", "author": "lightningrob", "createdAt": "2020-10-23T06:04:05Z", "path": "ambry-account/src/test/java/com/github/ambry/account/CompositeAccountServiceTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.config.CompositeAccountServiceConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.TestUtils;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+public class CompositeAccountServiceTest {", "originalCommit": "e2af7f0b591cef46b5aff32ea6b98a882770133a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bf379a3e50daf00d682d05ba2dedeae1c8c08062", "url": "https://github.com/linkedin/ambry/commit/bf379a3e50daf00d682d05ba2dedeae1c8c08062", "message": "Address comments from Yingyi and Rob", "committedDate": "2020-10-26T05:07:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1ODkyNA==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r512258924", "bodyText": "Is this to clear the StringBuilder?", "author": "jsjtzyy", "createdAt": "2020-10-26T20:49:23Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java", "diffHunk": "@@ -70,4 +73,95 @@ static boolean hasDuplicateAccountIdOrName(Collection<Account> accounts) {\n     deprecatedContainers.addAll(accountService.getContainersByStatus(Container.ContainerStatus.INACTIVE));\n     return deprecatedContainers;\n   }\n+\n+  /**\n+   * Compares and logs differences (if any) in Accounts.\n+   * @param accountsInPrimary accounts in primary collection.\n+   * @param accountsInSecondary accounts in secondary collection.\n+   * @return true if accounts and their containers are same in both collections.\n+   */\n+  public static boolean compareAccounts(Collection<Account> accountsInPrimary,\n+      Collection<Account> accountsInSecondary) {\n+    boolean isSame = true;\n+    Map<Short, Account> secondaryAccountMap = new HashMap<>();\n+    accountsInSecondary.forEach(account -> secondaryAccountMap.put(account.getId(), account));\n+\n+    Set<Account> accountsMissingInSecondary = accountsInPrimary.stream()\n+        .filter(account -> secondaryAccountMap.get(account.getId()) == null)\n+        .collect(Collectors.toSet());\n+\n+    Set<Account> accountsDifferentInSecondary = new HashSet<>(accountsInPrimary);\n+    accountsDifferentInSecondary.removeAll(accountsInSecondary);\n+    accountsDifferentInSecondary.removeAll(accountsMissingInSecondary);\n+\n+    if (!accountsMissingInSecondary.isEmpty() || !accountsDifferentInSecondary.isEmpty()) {\n+      isSame = false;\n+\n+      StringBuilder accountsInfo = new StringBuilder();\n+\n+      if (!accountsMissingInSecondary.isEmpty()) {\n+        accountsInfo.append(\"[\");\n+        for (Account account : accountsMissingInSecondary) {\n+          accountsInfo.append(AccountCollectionSerde.accountToJsonNoContainers(account).toString()).append(\",\");\n+        }\n+        accountsInfo.append(\"]\");\n+        logger.warn(\"Accounts found in primary and absent in secondary = {}\", accountsInfo.toString());\n+      }\n+\n+      if (!accountsDifferentInSecondary.isEmpty()) {\n+        accountsInfo.setLength(0);", "originalCommit": "bf379a3e50daf00d682d05ba2dedeae1c8c08062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NDMxMw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r512264313", "bodyText": "container.toString() doesn't have container name, is this ok? (I guess probably ok because I see you have container.toJson().toString() in following lines)", "author": "jsjtzyy", "createdAt": "2020-10-26T20:59:12Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java", "diffHunk": "@@ -70,4 +73,95 @@ static boolean hasDuplicateAccountIdOrName(Collection<Account> accounts) {\n     deprecatedContainers.addAll(accountService.getContainersByStatus(Container.ContainerStatus.INACTIVE));\n     return deprecatedContainers;\n   }\n+\n+  /**\n+   * Compares and logs differences (if any) in Accounts.\n+   * @param accountsInPrimary accounts in primary collection.\n+   * @param accountsInSecondary accounts in secondary collection.\n+   * @return true if accounts and their containers are same in both collections.\n+   */\n+  public static boolean compareAccounts(Collection<Account> accountsInPrimary,\n+      Collection<Account> accountsInSecondary) {\n+    boolean isSame = true;\n+    Map<Short, Account> secondaryAccountMap = new HashMap<>();\n+    accountsInSecondary.forEach(account -> secondaryAccountMap.put(account.getId(), account));\n+\n+    Set<Account> accountsMissingInSecondary = accountsInPrimary.stream()\n+        .filter(account -> secondaryAccountMap.get(account.getId()) == null)\n+        .collect(Collectors.toSet());\n+\n+    Set<Account> accountsDifferentInSecondary = new HashSet<>(accountsInPrimary);\n+    accountsDifferentInSecondary.removeAll(accountsInSecondary);\n+    accountsDifferentInSecondary.removeAll(accountsMissingInSecondary);\n+\n+    if (!accountsMissingInSecondary.isEmpty() || !accountsDifferentInSecondary.isEmpty()) {\n+      isSame = false;\n+\n+      StringBuilder accountsInfo = new StringBuilder();\n+\n+      if (!accountsMissingInSecondary.isEmpty()) {\n+        accountsInfo.append(\"[\");\n+        for (Account account : accountsMissingInSecondary) {\n+          accountsInfo.append(AccountCollectionSerde.accountToJsonNoContainers(account).toString()).append(\",\");\n+        }\n+        accountsInfo.append(\"]\");\n+        logger.warn(\"Accounts found in primary and absent in secondary = {}\", accountsInfo.toString());\n+      }\n+\n+      if (!accountsDifferentInSecondary.isEmpty()) {\n+        accountsInfo.setLength(0);\n+        accountsInfo.append(\"[\");\n+        for (Account account : accountsDifferentInSecondary) {\n+          accountsInfo.append(\"{Account = \")\n+              .append(account.toString())\n+              .append(\", primary = \")\n+              .append(AccountCollectionSerde.accountToJsonNoContainers(account).toString())\n+              .append(\", secondary = \")\n+              .append(AccountCollectionSerde.accountToJsonNoContainers(secondaryAccountMap.get(account.getId()))\n+                  .toString());\n+\n+          Set<Container> containersMissingInSecondary = account.getAllContainers()\n+              .stream()\n+              .filter(\n+                  container -> secondaryAccountMap.get(account.getId()).getContainerByName(container.getName()) == null)\n+              .collect(Collectors.toSet());\n+\n+          Set<Container> containersDifferentInSecondary = new HashSet<>(account.getAllContainers());\n+          containersDifferentInSecondary.removeAll(secondaryAccountMap.get(account.getId()).getAllContainers());\n+          containersDifferentInSecondary.removeAll(containersMissingInSecondary);\n+\n+          if (!containersMissingInSecondary.isEmpty()) {\n+            accountsInfo.append(\", Containers missing in secondary: [\");\n+            for (Container container : containersMissingInSecondary) {\n+              accountsInfo.append(container.toJson().toString()).append(\",\");\n+            }\n+            accountsInfo.append(\"]\");\n+          }\n+\n+          if (!containersDifferentInSecondary.isEmpty()) {\n+            accountsInfo.append(\", Containers different in secondary: [\");\n+            for (Container container : containersDifferentInSecondary) {\n+              accountsInfo.append(\"{container = \")\n+                  .append(container.toString())", "originalCommit": "bf379a3e50daf00d682d05ba2dedeae1c8c08062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzOTY1NA==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r512339654", "bodyText": "Minor: can use !secondaryAccountMap.containsKey(account.getId())", "author": "lightningrob", "createdAt": "2020-10-27T00:03:32Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java", "diffHunk": "@@ -70,4 +73,95 @@ static boolean hasDuplicateAccountIdOrName(Collection<Account> accounts) {\n     deprecatedContainers.addAll(accountService.getContainersByStatus(Container.ContainerStatus.INACTIVE));\n     return deprecatedContainers;\n   }\n+\n+  /**\n+   * Compares and logs differences (if any) in Accounts.\n+   * @param accountsInPrimary accounts in primary collection.\n+   * @param accountsInSecondary accounts in secondary collection.\n+   * @return true if accounts and their containers are same in both collections.\n+   */\n+  public static boolean compareAccounts(Collection<Account> accountsInPrimary,\n+      Collection<Account> accountsInSecondary) {\n+    boolean isSame = true;\n+    Map<Short, Account> secondaryAccountMap = new HashMap<>();\n+    accountsInSecondary.forEach(account -> secondaryAccountMap.put(account.getId(), account));\n+\n+    Set<Account> accountsMissingInSecondary = accountsInPrimary.stream()\n+        .filter(account -> secondaryAccountMap.get(account.getId()) == null)", "originalCommit": "bf379a3e50daf00d682d05ba2dedeae1c8c08062", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM1MDA3Ng==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r512350076", "bodyText": "Also, we are filtering on accountId here but on containerName below.  Maybe name makes more sense?", "author": "lightningrob", "createdAt": "2020-10-27T00:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzOTY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0MzQ1MQ==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r512343451", "bodyText": "That's right, you already had a diff method for this tool that you could reuse.", "author": "lightningrob", "createdAt": "2020-10-27T00:16:51Z", "path": "ambry-tools/src/main/java/com/github/ambry/account/MySqlAccountsDBTool.java", "diffHunk": "@@ -262,59 +261,8 @@ public void compare() throws SQLException {\n       accountSetFromDB.add(accountBuilder.build());\n     }\n \n-    //Accounts missing (or different) in DB = accounts in ZK - accounts in DB\n-    accountSetFromZK.removeAll(accountSetFromDB);\n-\n-    if (accountSetFromZK.size() > 0) {\n-\n-      Map<Short, Account> accountMapFromDB = new HashMap<>();\n-      accountSetFromDB.forEach(account -> {\n-        accountMapFromDB.put(account.getId(), account);\n-      });\n-\n-      Set<Account> accountsMissingInDB = accountSetFromZK.stream()\n-          .filter(account -> !accountMapFromDB.containsKey(account.getId()))\n-          .collect(Collectors.toSet());\n-      logger.info(\"======================= Accounts missing in DB =======================\");\n-      logger.info(\"{}\", accountsMissingInDB);\n-\n-      logger.info(\"\\r\\n\");\n-\n-      accountSetFromZK.removeAll(accountsMissingInDB);\n-      logger.info(\"=======================  Accounts different in DB =======================\");\n-      logger.info(\"{}\", accountSetFromZK);\n-\n-      logger.info(\"\\r\\n\");\n-\n-      logger.info(\n-          \"======================= Detailed Information for accounts that are different =======================\");\n-\n-      for (Account accountFromZK : accountSetFromZK) {\n-        Account accountFromDB = accountMapFromDB.get(accountFromZK.getId());\n-        Set<Container> containersDiffInZK = new HashSet<>(accountFromZK.getAllContainers());\n-        containersDiffInZK.removeAll(accountFromDB.getAllContainers());\n-\n-        logger.info(\"\\r\\n\");\n-        logger.info(\"----------------------- Account ID: {}, Account Name: {} -----------------------\",\n-            accountFromZK.getId(), accountFromZK.getName());\n-        logger.info(\"........................ Containers missing or different in DB ........................\");\n-        logger.info(\"{}\", containersDiffInZK);\n-\n-        logger.info(\"\\r\\n\");\n-        for (Container containerInZK : containersDiffInZK) {\n-          Container containerInDB = accountFromDB.getContainerById(containerInZK.getId());\n-          if (containerInDB != null) {\n-            logger.info(\"........................ Container ID: {}, Container Name: {} ........................\",\n-                containerInZK.getId(), containerInZK.getName());\n-            logger.info(\"Container info in zk: {}\", containerInZK.toJson().toString());\n-            logger.info(\"Container info in DB: {}\", containerInDB.toJson().toString());\n-            logger.info(\"\\r\\n\");\n-          }\n-        }\n-      }\n-    } else {\n-      logger.info(\"Accounts/Containers are in sync at ZK and DB\");\n-    }\n+    // Compare accounts in ZK and DB\n+    AccountUtils.compareAccounts(accountSetFromZK, accountSetFromDB);", "originalCommit": "bf379a3e50daf00d682d05ba2dedeae1c8c08062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM0NDY4OA==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r512344688", "bodyText": "It could be useful to maintain a Guage metric of the running total of inconsistencies, so we can alert when it stays above 0 for some time threshold.  We can add this in a follow up PR.", "author": "lightningrob", "createdAt": "2020-10-27T00:21:22Z", "path": "ambry-account/src/main/java/com/github/ambry/account/CompositeAccountService.java", "diffHunk": "@@ -113,79 +107,81 @@ public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> account\n   public Collection<Container> updateContainers(String accountName, Collection<Container> containers)\n       throws AccountServiceException {\n     Collection<Container> primaryResult = primaryAccountService.updateContainers(accountName, containers);\n-    try {\n-      secondaryAccountService.updateContainers(accountName, containers);\n-      // Not comparing updated containers list as it could increase latency of update operation.\n-    } catch (Exception e) {\n-      logger.error(\"Update containers failed for secondary source\", e);\n-      accountServiceMetrics.updateContainerInconsistencyCount.inc();\n-    }\n+    secondaryAccountService.updateContainers(accountName, containers);\n     return primaryResult;\n   }\n \n   @Override\n   public Container getContainer(String accountName, String containerName) throws AccountServiceException {\n     Container primaryResult = primaryAccountService.getContainer(accountName, containerName);\n-    try {\n-      Container secondaryResult = secondaryAccountService.getContainer(accountName, containerName);\n-      if (++getContainerRequestCount % 100 < config.samplingPercentageForGetContainerConsistencyCheck\n-          && primaryResult != null && !primaryResult.equals(secondaryResult)) {\n-        logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}, containerName = {}\",\n-            accountName, containerName);\n-        accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+    if (shouldCompare()) {\n+      try {\n+        Container secondaryResult = secondaryAccountService.getContainer(accountName, containerName);\n+        if (primaryResult != null && !primaryResult.equals(secondaryResult)) {\n+          logger.warn(\"Inconsistency detected between primary and secondary for accountName ={}, containerName = {}\",\n+              accountName, containerName);\n+          accountServiceMetrics.accountDataInconsistencyCount.inc();\n+        }\n+      } catch (Exception e) {\n+        accountServiceMetrics.accountDataInconsistencyCount.inc();\n+        logger.error(\"get container failed for secondary for accountName={}, containerName={}\", accountName,\n+            containerName, e);\n       }\n-    } catch (Exception e) {\n-      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n-      logger.error(\"get container failed for secondary for accountName={}, containerName={}\", accountName,\n-          containerName, e);\n     }\n     return primaryResult;\n   }\n \n   @Override\n   public Set<Container> getContainersByStatus(Container.ContainerStatus containerStatus) {\n     Set<Container> primaryResult = primaryAccountService.getContainersByStatus(containerStatus);\n-    Set<Container> secondaryResult = secondaryAccountService.getContainersByStatus(containerStatus);\n-    if (!primaryResult.equals(secondaryResult)) {\n-      logger.warn(\n-          \"Inconsistency detected between primary and secondary for containers with status ={}, primary ={}, secondary = {}\",\n-          containerStatus, primaryResult, secondaryResult);\n-      accountServiceMetrics.getContainerDataInconsistencyCount.inc();\n+    if (shouldCompare()) {\n+      Set<Container> secondaryResult = secondaryAccountService.getContainersByStatus(containerStatus);\n+      if (!primaryResult.equals(secondaryResult)) {\n+        logger.warn(\n+            \"Inconsistency detected between primary and secondary for containers with status ={}, primary ={}, secondary = {}\",\n+            containerStatus, primaryResult, secondaryResult);\n+        accountServiceMetrics.accountDataInconsistencyCount.inc();\n+      }\n     }\n     return primaryResult;\n   }\n \n   @Override\n   public void selectInactiveContainersAndMarkInZK(StatsSnapshot statsSnapshot) {\n     primaryAccountService.selectInactiveContainersAndMarkInZK(statsSnapshot);\n-    try {\n-      secondaryAccountService.selectInactiveContainersAndMarkInZK(statsSnapshot);\n-    } catch (Exception e) {\n-      logger.warn(\"Marking containers as inactive failed for secondary\", e);\n-      accountServiceMetrics.updateContainerInconsistencyCount.inc();\n-    }\n+    secondaryAccountService.selectInactiveContainersAndMarkInZK(statsSnapshot);\n   }\n \n   @Override\n   public void close() throws IOException {\n+    shutDownExecutorService(scheduler, config.consistencyCheckerShutdownTimeoutMinutes, TimeUnit.MINUTES);\n     try {\n       primaryAccountService.close();\n-    } finally {\n+    } catch (Exception e) {\n+      logger.error(\"Close failed for primary source\", e);\n+    }\n+    try {\n       secondaryAccountService.close();\n+    } catch (Exception e) {\n+      logger.error(\"Close failed for secondary source\", e);\n     }\n-    shutDownExecutorService(scheduler, config.consistencyCheckerShutdownTimeoutMinutes, TimeUnit.MINUTES);\n   }\n \n   /**\n    * Compares and logs differences (if any) in Account metadata stored in primary and secondary sources\n    */\n-  private void compareAccountMetadata() {\n-    Set<Account> primaryAccounts = new HashSet<>(primaryAccountService.getAllAccounts());\n-    Set<Account> secondaryAccounts = new HashSet<>(secondaryAccountService.getAllAccounts());\n-    if (!primaryAccounts.equals(secondaryAccounts)) {\n-      accountServiceMetrics.accountMetadataInconsistencyCount.inc();\n-      logger.debug(\"Inconsistency detected between primary and secondary at {} for accounts ={}\",\n-          SystemTime.getInstance().milliseconds(), primaryAccounts.removeAll(secondaryAccounts));\n+  void compareAccountMetadata() {\n+    if (!AccountUtils.compareAccounts(primaryAccountService.getAllAccounts(),\n+        secondaryAccountService.getAllAccounts())) {\n+      accountServiceMetrics.accountDataInconsistencyCount.inc();", "originalCommit": "bf379a3e50daf00d682d05ba2dedeae1c8c08062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM1MDk2Nw==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r512350967", "bodyText": "The method doesn't log if accounts/containers exist in secondary but not primary.  I suppose the assumption is that primary is updated first so this case is unlikely to happen?  That might be acceptable.", "author": "lightningrob", "createdAt": "2020-10-27T00:45:10Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java", "diffHunk": "@@ -70,4 +73,95 @@ static boolean hasDuplicateAccountIdOrName(Collection<Account> accounts) {\n     deprecatedContainers.addAll(accountService.getContainersByStatus(Container.ContainerStatus.INACTIVE));\n     return deprecatedContainers;\n   }\n+\n+  /**\n+   * Compares and logs differences (if any) in Accounts.\n+   * @param accountsInPrimary accounts in primary collection.\n+   * @param accountsInSecondary accounts in secondary collection.\n+   * @return true if accounts and their containers are same in both collections.\n+   */\n+  public static boolean compareAccounts(Collection<Account> accountsInPrimary,\n+      Collection<Account> accountsInSecondary) {\n+    boolean isSame = true;\n+    Map<Short, Account> secondaryAccountMap = new HashMap<>();\n+    accountsInSecondary.forEach(account -> secondaryAccountMap.put(account.getId(), account));\n+\n+    Set<Account> accountsMissingInSecondary = accountsInPrimary.stream()\n+        .filter(account -> secondaryAccountMap.get(account.getId()) == null)\n+        .collect(Collectors.toSet());\n+\n+    Set<Account> accountsDifferentInSecondary = new HashSet<>(accountsInPrimary);\n+    accountsDifferentInSecondary.removeAll(accountsInSecondary);\n+    accountsDifferentInSecondary.removeAll(accountsMissingInSecondary);\n+\n+    if (!accountsMissingInSecondary.isEmpty() || !accountsDifferentInSecondary.isEmpty()) {\n+      isSame = false;\n+\n+      StringBuilder accountsInfo = new StringBuilder();\n+\n+      if (!accountsMissingInSecondary.isEmpty()) {\n+        accountsInfo.append(\"[\");\n+        for (Account account : accountsMissingInSecondary) {\n+          accountsInfo.append(AccountCollectionSerde.accountToJsonNoContainers(account).toString()).append(\",\");\n+        }\n+        accountsInfo.append(\"]\");\n+        logger.warn(\"Accounts found in primary and absent in secondary = {}\", accountsInfo.toString());", "originalCommit": "bf379a3e50daf00d682d05ba2dedeae1c8c08062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjM1MTE2Mg==", "url": "https://github.com/linkedin/ambry/pull/1667#discussion_r512351162", "bodyText": "We could enhance this to return a mismatch count that can be used in a guage.", "author": "lightningrob", "createdAt": "2020-10-27T00:46:05Z", "path": "ambry-account/src/main/java/com/github/ambry/account/AccountUtils.java", "diffHunk": "@@ -70,4 +73,95 @@ static boolean hasDuplicateAccountIdOrName(Collection<Account> accounts) {\n     deprecatedContainers.addAll(accountService.getContainersByStatus(Container.ContainerStatus.INACTIVE));\n     return deprecatedContainers;\n   }\n+\n+  /**\n+   * Compares and logs differences (if any) in Accounts.\n+   * @param accountsInPrimary accounts in primary collection.\n+   * @param accountsInSecondary accounts in secondary collection.\n+   * @return true if accounts and their containers are same in both collections.\n+   */\n+  public static boolean compareAccounts(Collection<Account> accountsInPrimary,\n+      Collection<Account> accountsInSecondary) {\n+    boolean isSame = true;\n+    Map<Short, Account> secondaryAccountMap = new HashMap<>();\n+    accountsInSecondary.forEach(account -> secondaryAccountMap.put(account.getId(), account));\n+\n+    Set<Account> accountsMissingInSecondary = accountsInPrimary.stream()\n+        .filter(account -> secondaryAccountMap.get(account.getId()) == null)\n+        .collect(Collectors.toSet());\n+\n+    Set<Account> accountsDifferentInSecondary = new HashSet<>(accountsInPrimary);\n+    accountsDifferentInSecondary.removeAll(accountsInSecondary);\n+    accountsDifferentInSecondary.removeAll(accountsMissingInSecondary);\n+\n+    if (!accountsMissingInSecondary.isEmpty() || !accountsDifferentInSecondary.isEmpty()) {\n+      isSame = false;\n+\n+      StringBuilder accountsInfo = new StringBuilder();\n+\n+      if (!accountsMissingInSecondary.isEmpty()) {\n+        accountsInfo.append(\"[\");\n+        for (Account account : accountsMissingInSecondary) {\n+          accountsInfo.append(AccountCollectionSerde.accountToJsonNoContainers(account).toString()).append(\",\");\n+        }\n+        accountsInfo.append(\"]\");\n+        logger.warn(\"Accounts found in primary and absent in secondary = {}\", accountsInfo.toString());\n+      }\n+\n+      if (!accountsDifferentInSecondary.isEmpty()) {\n+        accountsInfo.setLength(0);\n+        accountsInfo.append(\"[\");\n+        for (Account account : accountsDifferentInSecondary) {\n+          accountsInfo.append(\"{Account = \")\n+              .append(account.toString())\n+              .append(\", primary = \")\n+              .append(AccountCollectionSerde.accountToJsonNoContainers(account).toString())\n+              .append(\", secondary = \")\n+              .append(AccountCollectionSerde.accountToJsonNoContainers(secondaryAccountMap.get(account.getId()))\n+                  .toString());\n+\n+          Set<Container> containersMissingInSecondary = account.getAllContainers()\n+              .stream()\n+              .filter(\n+                  container -> secondaryAccountMap.get(account.getId()).getContainerByName(container.getName()) == null)\n+              .collect(Collectors.toSet());\n+\n+          Set<Container> containersDifferentInSecondary = new HashSet<>(account.getAllContainers());\n+          containersDifferentInSecondary.removeAll(secondaryAccountMap.get(account.getId()).getAllContainers());\n+          containersDifferentInSecondary.removeAll(containersMissingInSecondary);\n+\n+          if (!containersMissingInSecondary.isEmpty()) {\n+            accountsInfo.append(\", Containers missing in secondary: [\");\n+            for (Container container : containersMissingInSecondary) {\n+              accountsInfo.append(container.toJson().toString()).append(\",\");\n+            }\n+            accountsInfo.append(\"]\");\n+          }\n+\n+          if (!containersDifferentInSecondary.isEmpty()) {\n+            accountsInfo.append(\", Containers different in secondary: [\");\n+            for (Container container : containersDifferentInSecondary) {\n+              accountsInfo.append(\"{container = \")\n+                  .append(container.toString())\n+                  .append(\", primary = \")\n+                  .append(container.toJson().toString())\n+                  .append(\", secondary = \")\n+                  .append(secondaryAccountMap.get(account.getId())\n+                      .getContainerByName(container.getName())\n+                      .toJson()\n+                      .toString())\n+                  .append(\"},\");\n+            }\n+            accountsInfo.append(\"]\");\n+          }\n+          accountsInfo.append(\"}\");\n+        }\n+        accountsInfo.append(\"]\");\n+\n+        logger.warn(\"Accounts mismatch in primary and secondary = {}\", accountsInfo.toString());\n+      }\n+    }\n+\n+    return isSame;", "originalCommit": "bf379a3e50daf00d682d05ba2dedeae1c8c08062", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}