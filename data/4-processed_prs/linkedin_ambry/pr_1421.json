{"pr_number": 1421, "pr_title": "Http2NetworkClient Implementation", "pr_createdAt": "2020-03-09T19:09:17Z", "pr_url": "https://github.com/linkedin/ambry/pull/1421", "timeline": [{"oid": "cbbf2f7ad56ce49fff243a9eab3a74a9c8bb4d1d", "url": "https://github.com/linkedin/ambry/commit/cbbf2f7ad56ce49fff243a9eab3a74a9c8bb4d1d", "message": "Http2NetworkClient Implementation.\n\nImplemented Http2NetworkClient and other http2 client related class.\nRemoved ClusterMapHttp2NetworkClientEndbaled, becuase we can only test router based http2 request(Http2 request for replication is not supported.)\nAdded RouterEnableHttp2NetworkClient.", "committedDate": "2020-03-09T19:10:53Z", "type": "forcePushed"}, {"oid": "bb67004ecfa8e2ae10f33d260c7c70c2ae8a0247", "url": "https://github.com/linkedin/ambry/commit/bb67004ecfa8e2ae10f33d260c7c70c2ae8a0247", "message": "Http2NetworkClient Implementation\n\nImplemented Http2NetworkClient and other http2 client related class.\nRemoved ClusterMapHttp2NetworkClientEndbaled, becuase we can only test router based http2 request(Http2 request for replication is not supported.)\nAdded RouterEnableHttp2NetworkClient.", "committedDate": "2020-03-09T19:12:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MTI3OA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391341278", "bodyText": "Don't think we need to add flush here, this should just be a write method.", "author": "justinlin-linkedin", "createdAt": "2020-03-12T00:21:12Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/AmbrySendToHttp2Adaptor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.network.Send;\n+import com.github.ambry.utils.ByteBufChannel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import java.io.IOException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Translates Ambry {@link Send} to the HTTP/2 frame objects.\n+ */\n+public class AmbrySendToHttp2Adaptor extends ChannelOutboundHandlerAdapter {\n+  private static final Logger logger = LoggerFactory.getLogger(AmbrySendToHttp2Adaptor.class);\n+\n+  public AmbrySendToHttp2Adaptor() {\n+\n+  }\n+\n+  /**\n+   * Handles conversion of {@link Send} to HTTP/2 frames.\n+   */\n+  @Override\n+  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+    if (!(msg instanceof Send)) {\n+      ctx.write(msg, promise);\n+    }\n+    Send send = (Send) msg;\n+    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+    DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+    ctx.write(headersFrame);\n+    // TODO: Make ByteBufChannel a RetainingByteBufChannel.\n+    ByteBufChannel byteBufChannel = new ByteBufChannel();\n+    try {\n+      send.writeTo(byteBufChannel);\n+    } catch (IOException e) {\n+      promise.setFailure(e);\n+    }\n+    DefaultHttp2DataFrame dataFrame = new DefaultHttp2DataFrame(byteBufChannel.getBuf(), true);\n+    ctx.write(dataFrame);\n+    ctx.flush();", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MTQ4OA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391971488", "bodyText": "tried to remove this flush. Everything stuck.", "author": "zzmao", "createdAt": "2020-03-13T00:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MTI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MTM3MA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391341370", "bodyText": "return here.", "author": "justinlin-linkedin", "createdAt": "2020-03-12T00:21:36Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/AmbrySendToHttp2Adaptor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.network.Send;\n+import com.github.ambry.utils.ByteBufChannel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import java.io.IOException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Translates Ambry {@link Send} to the HTTP/2 frame objects.\n+ */\n+public class AmbrySendToHttp2Adaptor extends ChannelOutboundHandlerAdapter {\n+  private static final Logger logger = LoggerFactory.getLogger(AmbrySendToHttp2Adaptor.class);\n+\n+  public AmbrySendToHttp2Adaptor() {\n+\n+  }\n+\n+  /**\n+   * Handles conversion of {@link Send} to HTTP/2 frames.\n+   */\n+  @Override\n+  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+    if (!(msg instanceof Send)) {\n+      ctx.write(msg, promise);", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5NjI0MA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391396240", "bodyText": "good catch", "author": "zzmao", "createdAt": "2020-03-12T04:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MTcxNQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391341715", "bodyText": "We should probably pass those parameter in the constructor of this adaptor, just in case later we would change those parameters to something else. Like if we ever wants to have a version 2 of ambry http2 server, than we can set the path to \"/v2\".", "author": "justinlin-linkedin", "createdAt": "2020-03-12T00:22:55Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/AmbrySendToHttp2Adaptor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.network.Send;\n+import com.github.ambry.utils.ByteBufChannel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import java.io.IOException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Translates Ambry {@link Send} to the HTTP/2 frame objects.\n+ */\n+public class AmbrySendToHttp2Adaptor extends ChannelOutboundHandlerAdapter {\n+  private static final Logger logger = LoggerFactory.getLogger(AmbrySendToHttp2Adaptor.class);\n+\n+  public AmbrySendToHttp2Adaptor() {\n+\n+  }\n+\n+  /**\n+   * Handles conversion of {@link Send} to HTTP/2 frames.\n+   */\n+  @Override\n+  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+    if (!(msg instanceof Send)) {\n+      ctx.write(msg, promise);\n+    }\n+    Send send = (Send) msg;\n+    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5NjM3Ng==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391396376", "bodyText": "pass path in constructor?", "author": "zzmao", "createdAt": "2020-03-12T04:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MTcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgwNTkxMQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r398805911", "bodyText": "got you. Will postpone this to follow up PRs.", "author": "zzmao", "createdAt": "2020-03-26T18:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MjI5OA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391342298", "bodyText": "the year should be 2020", "author": "justinlin-linkedin", "createdAt": "2020-03-12T00:25:21Z", "path": "ambry-utils/src/main/java/com.github.ambry.utils/ByteBufChannel.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0Mjc4Ng==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391342786", "bodyText": "how much do we have to do in order to switch to retaining bytebufchannel? If we change all the requests to implement ByteBufHolder, would that be enough?\nI am planning on changing the PutRequest, but just not sure what the interface would look like to suit your needs here.", "author": "justinlin-linkedin", "createdAt": "2020-03-12T00:27:26Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/AmbrySendToHttp2Adaptor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.network.Send;\n+import com.github.ambry.utils.ByteBufChannel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import java.io.IOException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Translates Ambry {@link Send} to the HTTP/2 frame objects.\n+ */\n+public class AmbrySendToHttp2Adaptor extends ChannelOutboundHandlerAdapter {\n+  private static final Logger logger = LoggerFactory.getLogger(AmbrySendToHttp2Adaptor.class);\n+\n+  public AmbrySendToHttp2Adaptor() {\n+\n+  }\n+\n+  /**\n+   * Handles conversion of {@link Send} to HTTP/2 frames.\n+   */\n+  @Override\n+  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+    if (!(msg instanceof Send)) {\n+      ctx.write(msg, promise);\n+    }\n+    Send send = (Send) msg;\n+    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+    DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+    ctx.write(headersFrame);\n+    // TODO: Make ByteBufChannel a RetainingByteBufChannel.\n+    ByteBufChannel byteBufChannel = new ByteBufChannel();", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5Njg2OA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391396868", "bodyText": "Make it a retaining bytebufchannel is also something I want to sync with you.\nIf we can support Send.getByteBut() eventually, then we don't need retaining bytebufchannel.", "author": "zzmao", "createdAt": "2020-03-12T04:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0Mjc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MjkxNA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391342914", "bodyText": "return here.\nand should probably do this before sending out the header.", "author": "justinlin-linkedin", "createdAt": "2020-03-12T00:27:59Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/AmbrySendToHttp2Adaptor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.network.Send;\n+import com.github.ambry.utils.ByteBufChannel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import java.io.IOException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Translates Ambry {@link Send} to the HTTP/2 frame objects.\n+ */\n+public class AmbrySendToHttp2Adaptor extends ChannelOutboundHandlerAdapter {\n+  private static final Logger logger = LoggerFactory.getLogger(AmbrySendToHttp2Adaptor.class);\n+\n+  public AmbrySendToHttp2Adaptor() {\n+\n+  }\n+\n+  /**\n+   * Handles conversion of {@link Send} to HTTP/2 frames.\n+   */\n+  @Override\n+  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+    if (!(msg instanceof Send)) {\n+      ctx.write(msg, promise);\n+    }\n+    Send send = (Send) msg;\n+    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+    DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+    ctx.write(headersFrame);\n+    // TODO: Make ByteBufChannel a RetainingByteBufChannel.\n+    ByteBufChannel byteBufChannel = new ByteBufChannel();\n+    try {\n+      send.writeTo(byteBufChannel);\n+    } catch (IOException e) {\n+      promise.setFailure(e);\n+    }", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5NjkyMw==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391396923", "bodyText": "sure.", "author": "zzmao", "createdAt": "2020-03-12T04:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MjkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MzE3OQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391343179", "bodyText": "I don't understand the header here? is this copied from the netty project?", "author": "justinlin-linkedin", "createdAt": "2020-03-12T00:28:56Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2ClientResponseHandler.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The Netty Project", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5NzI3Ng==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391397276", "bodyText": "No. just typo. Fixed.", "author": "zzmao", "createdAt": "2020-03-12T04:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MzE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NDc0NQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391354745", "bodyText": "what are the purpose of having two queues here?", "author": "justinlin-linkedin", "createdAt": "2020-03-12T01:17:40Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2ClientResponseHandler.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.network.RequestInfo;\n+import com.github.ambry.network.ResponseInfo;\n+import com.github.ambry.utils.SystemTime;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n+ */\n+@ChannelHandler.Sharable\n+public class Http2ClientResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());\n+  private Queue<ResponseInfo> responseInfoQueue0 = new ConcurrentLinkedQueue<>();\n+  private Queue<ResponseInfo> responseInfoQueue1 = new ConcurrentLinkedQueue<>();", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM5Nzc3OQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391397779", "bodyText": "to reduce lock contention in this produce consumer problem. While channelRead0 produces to one queue, sendAndPoll consumes the other one.\nsendAndPoll() needs a stop while processing response. switching between two queue achieves this naturally.", "author": "zzmao", "createdAt": "2020-03-12T04:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NDc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0MTEyMA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394441120", "bodyText": "Could a single ConcurrentLinkedQueue satisfy these requirements? It is a lock free queue where the producer (Http2ClientResponseHandler) will be CAS-ing on one end and then sendAndPoll will be CAS-ing on the other end, so contention between the two should be quite low, I feel.\nFor the end condition, couldn't that just be when queue.poll() returns null?", "author": "cgtz", "createdAt": "2020-03-18T15:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NDc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NTMxMA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391355310", "bodyText": "can we add pollTimeout at acquire method?", "author": "justinlin-linkedin", "createdAt": "2020-03-12T01:20:13Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2NetworkClient.java", "diffHunk": "@@ -17,38 +17,83 @@\n import com.github.ambry.commons.SSLFactory;\n import com.github.ambry.config.Http2ClientConfig;\n import com.github.ambry.network.NetworkClient;\n+import com.github.ambry.network.NetworkClientErrorCode;\n import com.github.ambry.network.RequestInfo;\n import com.github.ambry.network.ResponseInfo;\n+import com.github.ambry.utils.SystemTime;\n+import io.netty.channel.Channel;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.pool.ChannelPool;\n import io.netty.channel.pool.ChannelPoolMap;\n+import io.netty.util.AttributeKey;\n import java.net.InetSocketAddress;\n import java.util.List;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import java.util.ArrayList;\n+import java.util.Queue;\n import java.util.Set;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n /**\n  * A HTTP/2 implementation of {@link NetworkClient}.\n- * TODO: More implementation details will be added in next PR.\n  */\n public class Http2NetworkClient implements NetworkClient {\n   private static final Logger logger = LoggerFactory.getLogger(Http2NetworkClient.class);\n   private final EventLoopGroup eventLoopGroup;\n   private final ChannelPoolMap<InetSocketAddress, ChannelPool> pools;\n+  private Http2ClientResponseHandler http2ClientResponseHandler;\n+  public static AttributeKey<RequestInfo> REQUEST_INFO = AttributeKey.newInstance(\"RequestInfo\");\n \n   public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConfig http2ClientConfig,\n       SSLFactory sslFactory) {\n     this.eventLoopGroup = new NioEventLoopGroup(http2ClientConfig.http2NettyEventLoopGroupThreads);\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig);\n+    this.http2ClientResponseHandler = new Http2ClientResponseHandler();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n-    return null;\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    List<ResponseInfo> readyResponseInfo = new ArrayList<>();\n+    // Send request\n+    for (RequestInfo requestInfo : requestsToSend) {\n+      requestInfo.streamAcquireTime = SystemTime.getInstance().milliseconds();\n+      this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n+          .acquire()", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgwNDY4NA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r398804684", "bodyText": "The pollTimeout is used for response waiting and timeout.", "author": "zzmao", "createdAt": "2020-03-26T18:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjA3MA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391356070", "bodyText": "what do you want to remove it in the TODO? Keep HttpObjectAggregator seems fine to me.", "author": "justinlin-linkedin", "createdAt": "2020-03-12T01:23:19Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2StreamHandler.java", "diffHunk": "@@ -31,21 +33,25 @@\n   private NettyMetrics nettyMetrics;\n   private NettyConfig nettyConfig;\n   private PerformanceConfig performanceConfig;\n+  private Http2ClientConfig http2ClientConfig;\n   private RestRequestHandler requestHandler;\n \n   public Http2StreamHandler(NettyMetrics nettyMetrics, NettyConfig nettyConfig, PerformanceConfig performanceConfig,\n-      RestRequestHandler requestHandler) {\n+      Http2ClientConfig http2ClientConfig, RestRequestHandler requestHandler) {\n     this.nettyMetrics = nettyMetrics;\n     this.nettyConfig = nettyConfig;\n     this.performanceConfig = performanceConfig;\n+    this.http2ClientConfig = http2ClientConfig;\n     this.requestHandler = requestHandler;\n   }\n \n   @Override\n   public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n     ctx.pipeline().addLast(new Http2StreamFrameToHttpObjectCodec(true));\n+    // TODO: Remove HttpObjectAggregator. Currently, without HttpObjectAggregator, last httpContent can't be recognized as LastHttpContent.", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MjMwNg==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391972306", "bodyText": "HttpObjectAggregator caused an extra copy and extra cpu resource.\nI am actually thinking to remove NettyMessageProcessor.\nHttpObjectAggregator is reliable and simple.", "author": "zzmao", "createdAt": "2020-03-13T00:28:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU0NDAyOA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394544028", "bodyText": "What would be the pathway to removing HttpObjectAggregator? is it a bug in the Netty http2 handlers or a bug in NettyMessageProcessor?", "author": "cgtz", "createdAt": "2020-03-18T18:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgwNzQxNQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r398807415", "bodyText": "It looks like a compatible issue between http2 impl and NettyMessageProcessor.\nI need to re-consider what to do next step. Two choices:\n\nfix the bug\ndo not use NettyMessageProcessor\n\nWill fix this is follow up PRs.", "author": "zzmao", "createdAt": "2020-03-26T18:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk4NDQwNg==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r398984406", "bodyText": "Yeah, the NettyMessageProcessor doesn't expect a FullHttpRequest, it expects different http components. If we can get rid of NettyMessageProcessor here, I would totaly vote for it. NettyMessageProcessor does look like over complicated processor that was designed for frontend.", "author": "justinlin-linkedin", "createdAt": "2020-03-27T01:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk4NDY2NA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r398984664", "bodyText": "in the ambry server, we don't have multiple chunks, we don't have requests or response larger than 4MB. Lots of logic in the frontend just don't make too much sense in the ambry server.", "author": "justinlin-linkedin", "createdAt": "2020-03-27T01:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM4Nzk1MA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r400387950", "bodyText": "We do have requests and responses larger than 4 MB for replication batch-gets (and that period of time last year when we ran with 8 MB chunks), so there can be value from streaming. However, a lot of things, such as the way we prefetch blobs in the server, to get tangible benefit (other than abstract goals like sharing code btwn frontend/server) out of NettyMessageProcessor or similar pieces.", "author": "cgtz", "createdAt": "2020-03-30T18:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjE2Ng==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r391356166", "bodyText": "the year should be 2020", "author": "justinlin-linkedin", "createdAt": "2020-03-12T01:23:40Z", "path": "ambry-server/src/integration-test/java/com.github.ambry.server/Http2NetworkClientTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.", "originalCommit": "465a3d2cc87d5533584c7cb23550fceb4c5dd82e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "url": "https://github.com/linkedin/ambry/commit/1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "message": "address some comments", "committedDate": "2020-03-13T00:29:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1NTcxMA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394055710", "bodyText": "I think some time in the past, ambry supported only simple blobs, but up to 20 MB in size. I'm not sure how many blobs would be left for LinkedIn, but it might be good to set the default limit to something like 25 MB would probably be good.", "author": "cgtz", "createdAt": "2020-03-18T01:15:15Z", "path": "ambry-api/src/main/java/com.github.ambry/config/Http2ClientConfig.java", "diffHunk": "@@ -52,12 +53,23 @@\n   @Default(\"0\")\n   public final int http2NettyEventLoopGroupThreads;\n \n+  /**\n+   * Maximum content length for a full HTTP/2 content. Used in HttpObjectAggregator.\n+   * In HttpObjectAggregator, maxContentLength is not used to preallocate buffer,\n+   * but it throws exception if content length great than maxContentLength\n+   * TODO: Link this with blob chunk size.\n+   */\n+  @Config(HTTP2_MAX_CONTENT_LENGTH)\n+  @Default(\"10 * 1024 * 1024\")", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1ODcyNw==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394058727", "bodyText": "Could these be package private variables, or private with some setter methods?", "author": "cgtz", "createdAt": "2020-03-18T01:28:14Z", "path": "ambry-api/src/main/java/com.github.ambry/network/RequestInfo.java", "diffHunk": "@@ -25,6 +25,8 @@\n   private final Port port;\n   private final SendWithCorrelationId request;\n   private final ReplicaId replicaId;\n+  public long streamAcquireTime;", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA2MzkwNw==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394063907", "bodyText": "Should this promise be completed from within a listener on the flush? Does the promise represent when the message is written out to network, or is it when the OutboundHandler's business logic is done?", "author": "cgtz", "createdAt": "2020-03-18T01:50:03Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/AmbrySendToHttp2Adaptor.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.network.Send;\n+import com.github.ambry.utils.ByteBufChannel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import java.io.IOException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Translates Ambry {@link Send} to the HTTP/2 frame objects.\n+ */\n+public class AmbrySendToHttp2Adaptor extends ChannelOutboundHandlerAdapter {\n+  private static final Logger logger = LoggerFactory.getLogger(AmbrySendToHttp2Adaptor.class);\n+\n+  public AmbrySendToHttp2Adaptor() {\n+\n+  }\n+\n+  /**\n+   * Handles conversion of {@link Send} to HTTP/2 frames.\n+   */\n+  @Override\n+  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+    if (!(msg instanceof Send)) {\n+      ctx.write(msg, promise);\n+      return;\n+    }\n+    Send send = (Send) msg;\n+    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+    DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+    ctx.write(headersFrame);\n+    // TODO: Make ByteBufChannel a RetainingByteBufChannel.\n+    ByteBufChannel byteBufChannel = new ByteBufChannel();\n+    try {\n+      send.writeTo(byteBufChannel);\n+    } catch (IOException e) {\n+      promise.setFailure(e);\n+      return;\n+    }\n+    DefaultHttp2DataFrame dataFrame = new DefaultHttp2DataFrame(byteBufChannel.getBuf(), true);\n+    ctx.write(dataFrame);\n+    ctx.flush();\n+    promise.setSuccess();", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA4NzU0Ng==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394087546", "bodyText": "does this class and its methods need to be public?", "author": "cgtz", "createdAt": "2020-03-18T03:27:49Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2ClientResponseHandler.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.network.RequestInfo;\n+import com.github.ambry.network.ResponseInfo;\n+import com.github.ambry.utils.SystemTime;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n+ */\n+@ChannelHandler.Sharable\n+public class Http2ClientResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NTIyMw==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394445223", "bodyText": "This logic currently seems like it could lead to some busy-waiting when the system has a low request rate. In SocketNetworkClient, a timed wait is done with the select call and the wakeup call can be used by the router to unblock if some non-NetworkClient work needs to be done, whereas this implementation will return immediately if no requests are present.\nIn the comment above, I talked about how in the current implementation, the swapping of the queue may not be that useful. However, it could be useful if combined with a condvar monitor to signal when some new responses are ready.\nI also though that LinkedBlockingQueue may no be too bad for this use case since it has separate locks for put/take operations so contention shouldn't be too bad, but this queue does not natively support wakeup without interrupting the thread. One way to wakeup in this case would be to put an empty request object in the queue (like how the server does when shutting down a RequestResponseChannel", "author": "cgtz", "createdAt": "2020-03-18T15:42:33Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2NetworkClient.java", "diffHunk": "@@ -17,38 +17,83 @@\n import com.github.ambry.commons.SSLFactory;\n import com.github.ambry.config.Http2ClientConfig;\n import com.github.ambry.network.NetworkClient;\n+import com.github.ambry.network.NetworkClientErrorCode;\n import com.github.ambry.network.RequestInfo;\n import com.github.ambry.network.ResponseInfo;\n+import com.github.ambry.utils.SystemTime;\n+import io.netty.channel.Channel;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.pool.ChannelPool;\n import io.netty.channel.pool.ChannelPoolMap;\n+import io.netty.util.AttributeKey;\n import java.net.InetSocketAddress;\n import java.util.List;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import java.util.ArrayList;\n+import java.util.Queue;\n import java.util.Set;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n /**\n  * A HTTP/2 implementation of {@link NetworkClient}.\n- * TODO: More implementation details will be added in next PR.\n  */\n public class Http2NetworkClient implements NetworkClient {\n   private static final Logger logger = LoggerFactory.getLogger(Http2NetworkClient.class);\n   private final EventLoopGroup eventLoopGroup;\n   private final ChannelPoolMap<InetSocketAddress, ChannelPool> pools;\n+  private Http2ClientResponseHandler http2ClientResponseHandler;\n+  public static AttributeKey<RequestInfo> REQUEST_INFO = AttributeKey.newInstance(\"RequestInfo\");\n \n   public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConfig http2ClientConfig,\n       SSLFactory sslFactory) {\n     this.eventLoopGroup = new NioEventLoopGroup(http2ClientConfig.http2NettyEventLoopGroupThreads);\n     this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig);\n+    this.http2ClientResponseHandler = new Http2ClientResponseHandler();\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n-    return null;\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    List<ResponseInfo> readyResponseInfo = new ArrayList<>();\n+    // Send request\n+    for (RequestInfo requestInfo : requestsToSend) {\n+      requestInfo.streamAcquireTime = SystemTime.getInstance().milliseconds();\n+      this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n+          .acquire()\n+          .addListener((GenericFutureListener<Future<Channel>>) future -> {\n+            if (future.isSuccess()) {\n+              logger.trace(\n+                  \"Stream acquired: \" + (SystemTime.getInstance().milliseconds() - requestInfo.streamAcquireTime));\n+              Channel streamChannel = future.getNow();\n+              streamChannel.pipeline().addLast(http2ClientResponseHandler);\n+              streamChannel.pipeline().addLast(new AmbrySendToHttp2Adaptor());\n+              streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              streamChannel.write(requestInfo.getRequest());\n+              requestInfo.streamSendTime = SystemTime.getInstance().milliseconds();\n+            } else {\n+              logger.error(\"Couldn't acquire stream channel: \" + future.cause());\n+              readyResponseInfo.add(new ResponseInfo(requestInfo, NetworkClientErrorCode.NetworkError, null));\n+            }\n+          });\n+    }\n+    logger.trace(\"HTTP2 send request time: \" + (SystemTime.getInstance().milliseconds() - startTime));\n+    // TODO: close stream channel for requestsToDrop. Need a hashmap from corelationId to streamChannel\n+\n+    // Add the good responses to readyResponseInfo\n+    Queue<ResponseInfo> queue = http2ClientResponseHandler.getQueueToConsume();\n+    ResponseInfo responseInfo = queue.poll();\n+    while (responseInfo != null) {", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4MTU3Nw==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394581577", "bodyText": "To use one queue, I also prefer LinkedBlockingQueue  because it has a method drainTo, which takes all current available elements. This fits our use case.\n(To make sure we are in the same page): The busy loop happens when there is no/low request.\nRouter.run { \n     while() {\n         ....\n         client.sendAndPool()\n         ....\n     }\n}\n\nSo either one queue or two queues, we need a condition wait in sendAndPool() and be waken up when responses come.", "author": "zzmao", "createdAt": "2020-03-18T19:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYyMjIxOA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394622218", "bodyText": "Yep, I think we are on the same page. For a blocking queue example, you can look at LocalRequestResponseChannel. The only missing part is the implementation of wakeup, but I think that is doable with a method that puts a dummy element in the queue.\nWith the 2 queue system, you would need a condition variable to signal when the list is not empty.", "author": "cgtz", "createdAt": "2020-03-18T20:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0MzU4Mw==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r395843583", "bodyText": "@cgtz , I am changing to use one blocking queue. But still, I think a cv wait needed when there is no response in h2 client and a signal should be sent when a h2 response arrive, right?", "author": "zzmao", "createdAt": "2020-03-20T19:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1NTAwNA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r395855004", "bodyText": "I think there may be a way around having an additional condition variable, since LinkedBlockingQueue already has one inside. It already supports doing a timed wait and getting notified when a new element is present. The only case that would have to be handled differently would be the wakeup call. Here is an idea I had for how to make it work. Tell me if it makes sense (adapting some code from LocalRequestResponseChannel):\nFor the NetworkClient (consumer) side:\n  private static final ResponseInfo WAKEUP_MARKER = new ResponseInfo(null, null, null);\n  BlockingQueue<ResponseInfo> responseQueue = new LinkedBlockingQueue<>();\n  \n  List<ResponseInfo> sendAndPoll() {\n    // handle requests\n    \n    ResponseInfo firstResponse = null;\n    try {\n      firstResponse = responseQueue.poll(pollTimeoutMs, TimeUnit.MILLISECONDS);\n    } catch (InterruptedException ie) {\n      logger.debug(\"Interrupted polling responses\");\n    }\n    if (firstResponse == null) {\n      return Collections.emptyList();\n    }\n    // using a linked list to make removal easier (maybe there's a better way to handle this)\n    List<ResponseInfo> responseList = new LinkedList<>();\n    responseList.add(firstResponse);\n    responseQueue.drainTo(responseList);\n    // remove any wakeup markers, since they are just there to signal this thread to unblock itself\n    responseList.removeIf(responseInfo -> responseInfo == WAKEUP_MARKER);\n    return responseList;\n  }\n\n  void wakeup() {\n    // if sendAndPoll is currently executing a timed poll on the blocking queue, we need to put something there\n    // to wake it up before a response comes\n    try {\n      responseQueue.put(WAKEUP_MARKER);\n    } catch (InterruptedException e) {\n      logger.debug(\"Interrupted while waking up\");\n    }\n  }\nFor the ResponseHandler (producer) side:\n  void produce(ResponseInfo responseInfo) throws InterruptedException {\n    responseQueue.put(responseInfo);\n  }", "author": "cgtz", "createdAt": "2020-03-20T19:43:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1ODc1Mg==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r395858752", "bodyText": "Cool idea. Will use it.", "author": "zzmao", "createdAt": "2020-03-20T19:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NTIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3Njc1OA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394476758", "bodyText": "should this be changed back to trace before merging?", "author": "cgtz", "createdAt": "2020-03-18T16:24:05Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/AsyncRequestResponseHandler.java", "diffHunk": "@@ -579,7 +579,7 @@ protected void submitResponse(RestRequest restRequest, RestResponseChannel restR\n         } else {\n           response.readInto(restResponseChannel, responseWriteCallback);\n           inFlightResponsesCount.incrementAndGet();\n-          logger.trace(\"Response of size {} for request {} is scheduled to be sent\", response.getSize(),\n+          logger.info(\"Response of size {} for request {} is scheduled to be sent\", response.getSize(),", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3ODgzMA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394478830", "bodyText": "We should change this to instantiate the SslFactory within NetworkClientFactory, since there can be some incompatibilities between the HTTP2 factory and the one used for RestServer.", "author": "cgtz", "createdAt": "2020-03-18T16:26:59Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/RestServerMain.java", "diffHunk": "@@ -80,10 +81,10 @@ public static void main(String[] args) {\n    * @throws IOException\n    */\n   private static SSLFactory getSSLFactoryIfRequired(VerifiableProperties verifiableProperties) throws Exception {\n-    ClusterMapConfig clusterMapConfig = new ClusterMapConfig(verifiableProperties);\n-    if (clusterMapConfig.clusterMapHttp2NetworkClientEnabled) {\n+    if (new RouterConfig(verifiableProperties).routerEnableHttp2NetworkClient) {", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3OTg0MQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394479841", "bodyText": "Could you make a static method in RouterUtils to do the port selection?", "author": "cgtz", "createdAt": "2020-03-18T16:28:23Z", "path": "ambry-router/src/main/java/com.github.ambry.router/DeleteOperation.java", "diffHunk": "@@ -123,7 +124,12 @@ private void fetchRequests(RequestRegistrationCallback<DeleteOperation> requestR\n     while (replicaIterator.hasNext()) {\n       ReplicaId replica = replicaIterator.next();\n       String hostname = replica.getDataNodeId().getHostname();\n-      Port port = replica.getDataNodeId().getPortToConnectTo();\n+      Port port;", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMDA2MA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394520060", "bodyText": "final", "author": "cgtz", "createdAt": "2020-03-18T17:28:37Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2NetworkClient.java", "diffHunk": "@@ -17,38 +17,83 @@\n import com.github.ambry.commons.SSLFactory;\n import com.github.ambry.config.Http2ClientConfig;\n import com.github.ambry.network.NetworkClient;\n+import com.github.ambry.network.NetworkClientErrorCode;\n import com.github.ambry.network.RequestInfo;\n import com.github.ambry.network.ResponseInfo;\n+import com.github.ambry.utils.SystemTime;\n+import io.netty.channel.Channel;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.pool.ChannelPool;\n import io.netty.channel.pool.ChannelPoolMap;\n+import io.netty.util.AttributeKey;\n import java.net.InetSocketAddress;\n import java.util.List;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import java.util.ArrayList;\n+import java.util.Queue;\n import java.util.Set;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n /**\n  * A HTTP/2 implementation of {@link NetworkClient}.\n- * TODO: More implementation details will be added in next PR.\n  */\n public class Http2NetworkClient implements NetworkClient {\n   private static final Logger logger = LoggerFactory.getLogger(Http2NetworkClient.class);\n   private final EventLoopGroup eventLoopGroup;\n   private final ChannelPoolMap<InetSocketAddress, ChannelPool> pools;\n+  private Http2ClientResponseHandler http2ClientResponseHandler;\n+  public static AttributeKey<RequestInfo> REQUEST_INFO = AttributeKey.newInstance(\"RequestInfo\");", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMDE0NA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394520144", "bodyText": "final", "author": "cgtz", "createdAt": "2020-03-18T17:28:44Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2NetworkClient.java", "diffHunk": "@@ -17,38 +17,83 @@\n import com.github.ambry.commons.SSLFactory;\n import com.github.ambry.config.Http2ClientConfig;\n import com.github.ambry.network.NetworkClient;\n+import com.github.ambry.network.NetworkClientErrorCode;\n import com.github.ambry.network.RequestInfo;\n import com.github.ambry.network.ResponseInfo;\n+import com.github.ambry.utils.SystemTime;\n+import io.netty.channel.Channel;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.pool.ChannelPool;\n import io.netty.channel.pool.ChannelPoolMap;\n+import io.netty.util.AttributeKey;\n import java.net.InetSocketAddress;\n import java.util.List;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import java.util.ArrayList;\n+import java.util.Queue;\n import java.util.Set;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n /**\n  * A HTTP/2 implementation of {@link NetworkClient}.\n- * TODO: More implementation details will be added in next PR.\n  */\n public class Http2NetworkClient implements NetworkClient {\n   private static final Logger logger = LoggerFactory.getLogger(Http2NetworkClient.class);\n   private final EventLoopGroup eventLoopGroup;\n   private final ChannelPoolMap<InetSocketAddress, ChannelPool> pools;\n+  private Http2ClientResponseHandler http2ClientResponseHandler;", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU0NTk2Mg==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394545962", "bodyText": "commented code here", "author": "cgtz", "createdAt": "2020-03-18T18:10:53Z", "path": "ambry-server/src/integration-test/java/com.github.ambry.server/RouterServerHttp2Test.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.server;\n+\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.clustermap.MockClusterMap;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.commons.TestSSLUtils;\n+import com.github.ambry.config.RouterConfig;\n+import com.github.ambry.server.RouterServerTestFramework.*;\n+import com.github.ambry.utils.SystemTime;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Queue;\n+import java.util.Random;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static com.github.ambry.server.RouterServerTestFramework.*;\n+\n+\n+@RunWith(Parameterized.class)\n+public class RouterServerHttp2Test {\n+  private static MockCluster http2Cluster;\n+  private static RouterServerTestFramework testFramework;\n+  private static MetricRegistry routerMetricRegistry;\n+  private static long transmissionSendBytesCountBeforeTest;\n+  private static long transmissionReceiveBytesCountBeforeTest;\n+\n+  /**\n+   * Running for both regular and encrypted blobs\n+   * @return an array with both {@code false} and {@code true}.\n+   */\n+  @Parameterized.Parameters\n+  public static List<Object[]> data() {\n+    return Arrays.asList(new Object[][]{{false}, {true}});\n+  }\n+\n+  /**\n+   * Instantiates {@link RouterServerHttp2Test}\n+   * @param testEncryption {@code true} if blobs need to be tested w/ encryption. {@code false} otherwise\n+   */\n+  public RouterServerHttp2Test(boolean testEncryption) {\n+    testFramework.setTestEncryption(testEncryption);\n+  }\n+\n+  @BeforeClass\n+  public static void initializeTests() throws Exception {\n+    File trustStoreFile = File.createTempFile(\"truststore\", \".jks\");\n+\n+    // Set up router properties\n+    Properties routerProps = getRouterProperties(\"DC1\");\n+    TestSSLUtils.addSSLProperties(routerProps, \"DC1,DC2,DC3\", SSLFactory.Mode.CLIENT, trustStoreFile, \"http2-router\");\n+    TestSSLUtils.addHttp2Properties(routerProps, SSLFactory.Mode.CLIENT, false);\n+    routerProps.setProperty(RouterConfig.ROUTER_ENABLE_HTTP2_NETWORK_CLIENT, \"true\");\n+\n+    // Set up server properties\n+    Properties serverSSLProps = new Properties();\n+    TestSSLUtils.addSSLProperties(serverSSLProps, \"DC1,DC2,DC3\", SSLFactory.Mode.SERVER, trustStoreFile,\n+        \"http2-server\");\n+    TestSSLUtils.addHttp2Properties(serverSSLProps, SSLFactory.Mode.SERVER, false);\n+    serverSSLProps.setProperty(\"server.enable.store.data.prefetch\", \"true\");\n+\n+    http2Cluster = new MockCluster(serverSSLProps, false, SystemTime.getInstance());\n+    MockNotificationSystem notificationSystem = new MockNotificationSystem(http2Cluster.getClusterMap());\n+    http2Cluster.initializeServers(notificationSystem);\n+    http2Cluster.startServers();\n+    MockClusterMap routerClusterMap = http2Cluster.getClusterMap();\n+    // MockClusterMap returns a new registry by default. This is to ensure that each node (server, router and so on,\n+    // get a different registry. But at this point all server nodes have been initialized, and we want the router and\n+    // its components, which are going to be created, to use the same registry.\n+    routerClusterMap.createAndSetPermanentMetricRegistry();\n+\n+    testFramework = new RouterServerTestFramework(routerProps, routerClusterMap, notificationSystem);\n+    routerMetricRegistry = routerClusterMap.getMetricRegistry();\n+  }\n+\n+  @AfterClass\n+  public static void cleanup() throws IOException {\n+    testFramework.cleanup();\n+    long start = System.currentTimeMillis();\n+    System.out.println(\"RouterServerSSLTest::About to invoke cluster.cleanup()\");\n+    if (http2Cluster != null) {\n+      http2Cluster.cleanup();\n+    }\n+    System.out.println(\"RouterServerSSLTest::cluster.cleanup() took \" + (System.currentTimeMillis() - start) + \" ms.\");\n+  }\n+\n+  @Before\n+  public void before() {\n+    Map<String, Meter> meters = routerMetricRegistry.getMeters();\n+    transmissionSendBytesCountBeforeTest = meters.get(transmissionSendBytesMetricName).getCount();\n+    transmissionReceiveBytesCountBeforeTest = meters.get(transmissionReceiveBytesMetricName).getCount();\n+  }\n+\n+  @After\n+  public void after() {\n+//    TODO: assert metrics.", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU1NTE3MA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r394555170", "bodyText": "Generally for implementations of WritableByteChannel, I think you are supposed to copy the bytes instead of just wrapping them since ByteBuffers have no ref count system and may be reused by the writer afterwards. (This is what many of the code snippets for copying from ReadableByteChannel to WritableByteChannel do).\nI think for the router, it may be okay to keep this optimization present but I did find some cases that I was a little unsure about. The suspicious case I found was PutOperation where the buffer is cleared in prepareForBuilding. I think this method is only called after a chunk is cleared. This happens when a chunk operation is completed, so for requests that we care about, it hopefully won't cause issues, but a chunk operation being completed does not necessarily mean all requests have been successfully sent out (some could be stuck in the queue).", "author": "cgtz", "createdAt": "2020-03-18T18:26:49Z", "path": "ambry-utils/src/main/java/com.github.ambry.utils/ByteBufChannel.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.utils;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link WritableByteChannel} that stores the bytes written into it in a {@link ByteBuf}.\n+ */\n+public class ByteBufChannel implements WritableByteChannel {\n+  private final AtomicBoolean channelOpen = new AtomicBoolean(true);\n+  private CompositeByteBuf compositeBuffer = ByteBufAllocator.DEFAULT.compositeBuffer();\n+\n+  /**\n+   * Gets the {@link CompositeByteBuf} that is being used to receive writes.\n+   * @return the {@link ByteBuf} that is receives writes to this channel.\n+   */\n+  public ByteBuf getBuf() {\n+    return compositeBuffer;\n+  }\n+\n+  /**\n+   * The default constructor.\n+   */\n+  public ByteBufChannel() {\n+\n+  }\n+\n+  /**\n+   * Copies bytes from {@code src} into the composite buf.\n+   * @param src the source {@link ByteBuf} to copy bytes from.\n+   * @return the number of bytes copied.\n+   * @throws ClosedChannelException if the channel is closed when this function was called.\n+   */\n+  @Override\n+  public int write(ByteBuffer src) throws ClosedChannelException {\n+    int size = src.remaining();\n+    compositeBuffer.addComponent(true, Unpooled.wrappedBuffer(src));", "originalCommit": "1096bf912eb1ad3a90ff273ca0dc8c077c252d30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgzNTQ4NA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r398835484", "bodyText": "I noticed some PUT issue in EI test. Not sure yet.\nTo make everything safe, the latest change use copy in ByteBufChannel. Next step is to use Use  RetainingAsyncWritableChannel after PUT/GET request's writeTo(AsyncWritableChannel channel, Callback<Long> callback) is fully implemented.", "author": "zzmao", "createdAt": "2020-03-26T19:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU1NTE3MA=="}], "type": "inlineReview"}, {"oid": "82b7d02f182b4ff55a6d6ce31d597223760a28b4", "url": "https://github.com/linkedin/ambry/commit/82b7d02f182b4ff55a6d6ce31d597223760a28b4", "message": "Http2NetworkClient Implementation\n\nImplemented Http2NetworkClient and other http2 client related class.\nRemoved ClusterMapHttp2NetworkClientEndbaled, becuase we can only test router based http2 request(Http2 request for replication is not supported.)\nAdded RouterEnableHttp2NetworkClient.", "committedDate": "2020-03-26T01:19:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk4Mzg0MQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r398983841", "bodyText": "I think If you do writeAndFlush here, you can remove ctx.flush in AmbrySendToHttp2Adaptor.write method.\nThere is one more thing to consider, is that when the write method fails, it's not going to be captured by anything. We need to deal with that.", "author": "justinlin-linkedin", "createdAt": "2020-03-27T01:22:43Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2NetworkClient.java", "diffHunk": "@@ -17,38 +17,94 @@\n import com.github.ambry.commons.SSLFactory;\n import com.github.ambry.config.Http2ClientConfig;\n import com.github.ambry.network.NetworkClient;\n+import com.github.ambry.network.NetworkClientErrorCode;\n import com.github.ambry.network.RequestInfo;\n import com.github.ambry.network.ResponseInfo;\n+import io.netty.channel.Channel;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.pool.ChannelPool;\n import io.netty.channel.pool.ChannelPoolMap;\n+import io.netty.util.AttributeKey;\n import java.net.InetSocketAddress;\n+import java.util.Collections;\n import java.util.List;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import java.util.ArrayList;\n import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n /**\n  * A HTTP/2 implementation of {@link NetworkClient}.\n- * TODO: More implementation details will be added in next PR.\n  */\n public class Http2NetworkClient implements NetworkClient {\n   private static final Logger logger = LoggerFactory.getLogger(Http2NetworkClient.class);\n   private final EventLoopGroup eventLoopGroup;\n   private final ChannelPoolMap<InetSocketAddress, ChannelPool> pools;\n+  private final Http2ClientResponseHandler http2ClientResponseHandler;\n+  private final Http2ClientMetrics http2ClientMetrics;\n+  public static final ResponseInfo WAKEUP_MARKER = new ResponseInfo(null, null, null);\n+  static final AttributeKey<RequestInfo> REQUEST_INFO = AttributeKey.newInstance(\"RequestInfo\");\n \n   public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConfig http2ClientConfig,\n       SSLFactory sslFactory) {\n+    logger.info(\"Http2NetworkClient started\");\n     this.eventLoopGroup = new NioEventLoopGroup(http2ClientConfig.http2NettyEventLoopGroupThreads);\n-    this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig);\n+    this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics);\n+    this.http2ClientResponseHandler = new Http2ClientResponseHandler(this);\n+    this.http2ClientMetrics = http2ClientMetrics;\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n-    return null;\n+    long startTime = System.currentTimeMillis();\n+    List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n+    // Send request\n+    http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n+    for (RequestInfo requestInfo : requestsToSend) {\n+      long streamInitiateTime = System.currentTimeMillis();\n+      this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n+          .acquire()\n+          .addListener((GenericFutureListener<Future<Channel>>) future -> {\n+            if (future.isSuccess()) {\n+              http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n+              Channel streamChannel = future.getNow();\n+              streamChannel.pipeline().addLast(http2ClientResponseHandler);\n+              streamChannel.pipeline().addLast(new AmbrySendToHttp2Adaptor());\n+              streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              streamChannel.write(requestInfo.getRequest());", "originalCommit": "bb27ea052af89bc9983d08834e16962c7a5472c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzMTYyNg==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r400431626", "bodyText": "It works.\nLet me see how to handle write failure.", "author": "zzmao", "createdAt": "2020-03-30T19:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk4Mzg0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzMTI1NA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r401331254", "bodyText": "failure handling added.", "author": "zzmao", "createdAt": "2020-04-01T03:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk4Mzg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyNDMyOQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r399424329", "bodyText": "minor: add Count to the end of this metric name for consistency", "author": "cgtz", "createdAt": "2020-03-27T17:23:33Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2ClientMetrics.java", "diffHunk": "@@ -14,15 +14,62 @@\n \n package com.github.ambry.network.http2;\n \n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.Meter;\n import com.codahale.metrics.MetricRegistry;\n \n \n /**\n- * The metrics for HTTP/2 Client\n+ * Metrics for HTTP/2 Client\n  */\n public class Http2ClientMetrics {\n \n+  public final Histogram http2ConnectionAcquireTime;\n+  public final Histogram http2StreamAcquireTime;\n+  public final Histogram http2FirstStreamAcquireTime;\n+  public final Histogram http2RegularStreamAcquireTime;\n+  public final Histogram http2StreamRoundTripTime;\n+  public final Histogram http2ClientSendTime;\n+  public final Histogram http2ClientSendAndPollTime;\n+\n+  public final Counter http2NewPoolCount;\n+  public final Counter http2NewConnectionCount;\n+  public final Counter http2NewConnectionFailureCount;\n+  public final Counter http2NewStreamCount;\n+  public final Counter http2StreamAcquireFailureCount;\n+  public final Counter http2StreamSlipAcquire;", "originalCommit": "bb27ea052af89bc9983d08834e16962c7a5472c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyNjQ1Nw==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r399426457", "bodyText": "Add check for closed channel to this method?", "author": "cgtz", "createdAt": "2020-03-27T17:27:05Z", "path": "ambry-utils/src/main/java/com.github.ambry.utils/ByteBufChannel.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.utils;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.buffer.Unpooled;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\n+/**\n+ * A {@link WritableByteChannel} that stores the bytes written into it in a {@link ByteBuf}.\n+ */\n+public class ByteBufChannel implements WritableByteChannel {\n+  private final AtomicBoolean channelOpen = new AtomicBoolean(true);\n+  private CompositeByteBuf compositeBuffer = ByteBufAllocator.DEFAULT.compositeBuffer();\n+\n+  /**\n+   * Gets the {@link CompositeByteBuf} that is being used to receive writes.\n+   * @return the {@link ByteBuf} that is receives writes to this channel.\n+   */\n+  public ByteBuf getBuf() {\n+    return compositeBuffer;\n+  }\n+\n+  /**\n+   * The default constructor.\n+   */\n+  public ByteBufChannel() {\n+\n+  }\n+\n+  /**\n+   * Copies bytes from {@code src} into the composite buf.\n+   * @param src the source {@link ByteBuf} to copy bytes from.\n+   * @return the number of bytes copied.\n+   * @throws ClosedChannelException if the channel is closed when this function was called.\n+   */\n+  @Override\n+  public int write(ByteBuffer src) throws ClosedChannelException {", "originalCommit": "bb27ea052af89bc9983d08834e16962c7a5472c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1NjMxNQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r400356315", "bodyText": "extra empty line here", "author": "cgtz", "createdAt": "2020-03-30T17:12:01Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2ClientResponseHandler.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.network.http2;\n+\n+import com.github.ambry.network.RequestInfo;\n+import com.github.ambry.network.ResponseInfo;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n+ */\n+@ChannelHandler.Sharable\n+class Http2ClientResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n+  private LinkedBlockingQueue<ResponseInfo> responseInfoQueue = new LinkedBlockingQueue<>();\n+  private Http2NetworkClient http2NetworkClient;\n+\n+  public Http2ClientResponseHandler(Http2NetworkClient http2NetworkClient) {\n+    this.http2NetworkClient = http2NetworkClient;\n+  }\n+\n+  @Override\n+  protected void channelRead0(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {\n+\n+    ByteBuf dup = msg.content().retainedDuplicate();\n+    // Consume length\n+    dup.readLong();\n+    RequestInfo requestInfo = ctx.channel().attr(Http2NetworkClient.REQUEST_INFO).get();\n+    http2NetworkClient.getHttp2ClientMetrics().http2StreamRoundTripTime.update(\n+        System.currentTimeMillis() - requestInfo.getStreamSendTime());\n+    requestInfo.setStreamReceiveTime(System.currentTimeMillis());\n+    ResponseInfo responseInfo = new ResponseInfo(requestInfo, null, dup);\n+    responseInfoQueue.offer(responseInfo);\n+    // TODO: is this a good place to release stream channel?\n+    ctx.channel()\n+        .parent()\n+        .attr(Http2MultiplexedChannelPool.HTTP2_MULTIPLEXED_CHANNEL_POOL)\n+        .get()\n+        .release(ctx.channel());\n+  }\n+\n+  /**\n+   * Get the queue that are not being used by {@link Http2ClientResponseHandler#channelRead0}.\n+   * {@link Http2NetworkClient} consumes {@link ResponseInfo} from this queue.\n+   * from this queue.\n+   */\n+", "originalCommit": "bb27ea052af89bc9983d08834e16962c7a5472c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2Nzc4MQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r400367781", "bodyText": "Would this log every time a connection is closed? It may be worth setting this to debug and also include the remote hostname if possible.", "author": "cgtz", "createdAt": "2020-03-30T17:29:44Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2MultiplexedChannelPool.java", "diffHunk": "@@ -269,6 +299,7 @@ private boolean acquireStreamOnInitializedConnection(MultiplexedChannelRecord ch\n     multiplexedChannel.closeAndReleaseChild(childChannel);\n \n     if (multiplexedChannel.canBeClosedAndReleased()) {\n+      log.info(\"Parent channel closed.\");", "originalCommit": "bb27ea052af89bc9983d08834e16962c7a5472c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2OTEwNA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r400369104", "bodyText": "this isn't a linked list any more.", "author": "cgtz", "createdAt": "2020-03-30T17:31:51Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2NetworkClient.java", "diffHunk": "@@ -17,38 +17,94 @@\n import com.github.ambry.commons.SSLFactory;\n import com.github.ambry.config.Http2ClientConfig;\n import com.github.ambry.network.NetworkClient;\n+import com.github.ambry.network.NetworkClientErrorCode;\n import com.github.ambry.network.RequestInfo;\n import com.github.ambry.network.ResponseInfo;\n+import io.netty.channel.Channel;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.pool.ChannelPool;\n import io.netty.channel.pool.ChannelPoolMap;\n+import io.netty.util.AttributeKey;\n import java.net.InetSocketAddress;\n+import java.util.Collections;\n import java.util.List;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import java.util.ArrayList;\n import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n /**\n  * A HTTP/2 implementation of {@link NetworkClient}.\n- * TODO: More implementation details will be added in next PR.\n  */\n public class Http2NetworkClient implements NetworkClient {\n   private static final Logger logger = LoggerFactory.getLogger(Http2NetworkClient.class);\n   private final EventLoopGroup eventLoopGroup;\n   private final ChannelPoolMap<InetSocketAddress, ChannelPool> pools;\n+  private final Http2ClientResponseHandler http2ClientResponseHandler;\n+  private final Http2ClientMetrics http2ClientMetrics;\n+  public static final ResponseInfo WAKEUP_MARKER = new ResponseInfo(null, null, null);\n+  static final AttributeKey<RequestInfo> REQUEST_INFO = AttributeKey.newInstance(\"RequestInfo\");\n \n   public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConfig http2ClientConfig,\n       SSLFactory sslFactory) {\n+    logger.info(\"Http2NetworkClient started\");\n     this.eventLoopGroup = new NioEventLoopGroup(http2ClientConfig.http2NettyEventLoopGroupThreads);\n-    this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig);\n+    this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics);\n+    this.http2ClientResponseHandler = new Http2ClientResponseHandler(this);\n+    this.http2ClientMetrics = http2ClientMetrics;\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n-    return null;\n+    long startTime = System.currentTimeMillis();\n+    List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n+    // Send request\n+    http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n+    for (RequestInfo requestInfo : requestsToSend) {\n+      long streamInitiateTime = System.currentTimeMillis();\n+      this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n+          .acquire()\n+          .addListener((GenericFutureListener<Future<Channel>>) future -> {\n+            if (future.isSuccess()) {\n+              http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n+              Channel streamChannel = future.getNow();\n+              streamChannel.pipeline().addLast(http2ClientResponseHandler);\n+              streamChannel.pipeline().addLast(new AmbrySendToHttp2Adaptor());\n+              streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              streamChannel.write(requestInfo.getRequest());\n+              requestInfo.setStreamSendTime(System.currentTimeMillis());\n+            } else {\n+              logger.error(\"Couldn't acquire stream channel: \" + future.cause());\n+              readyResponseInfos.add(new ResponseInfo(requestInfo, NetworkClientErrorCode.NetworkError, null));\n+            }\n+          });\n+    }\n+    http2ClientMetrics.http2ClientSendTime.update(System.currentTimeMillis() - startTime);\n+    // TODO: close stream channel for requestsToDrop. Need a hashmap from corelationId to streamChannel\n+\n+    ResponseInfo firstResponse = null;\n+    try {\n+      firstResponse = http2ClientResponseHandler.getResponseInfoQueue().poll(pollTimeoutMs, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException ie) {\n+      logger.debug(\"Interrupted polling responses\");\n+    }\n+    if (firstResponse == null) {\n+      return Collections.emptyList();\n+    }\n+    // using a linked list to make removal easier (maybe there's a better way to handle this)", "originalCommit": "bb27ea052af89bc9983d08834e16962c7a5472c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM4MDQzNQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r400380435", "bodyText": "Are you sure we want to expose wakeup markers to the router layer? It seems like an internal detail of the NetworkClient.\nIf we just want to save on the iteration cost, one idea I had was to filter them out when inserting into the list. Unfortunately, since drainTo only accepts Collections, you may have to do something silly like this:\n    FilteredInserter<ResponseInfo> filteredInserter =\n        new FilteredInserter<>(readyResponseInfos, r -> r != WAKEUP_MARKER);\n    filteredInserter.add(firstResponse);\n    http2ClientResponseHandler.getResponseInfoQueue().drainTo(filteredInserter);\n    http2ClientMetrics.http2ClientSendRate.mark(readyResponseInfos.size());\n\n    http2ClientMetrics.http2ClientSendAndPollTime.update(System.currentTimeMillis() - startTime);\n    return readyResponseInfos;\n  }\n\n  private static class FilteredInserter<T> extends AbstractCollection<T> {\n    private final Collection<T> data;\n    private final Predicate<T> shouldAdd;\n\n    FilteredInserter(Collection<T> data, Predicate<T> shouldAdd) {\n      this.data = data;\n      this.shouldAdd = shouldAdd;\n    }\n\n    @Override\n    public boolean add(T t) {\n      if (shouldAdd.test(t)) {\n        return data.add(t);\n      }\n      return false;\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n      return data.iterator();\n    }\n\n    @Override\n    public int size() {\n      return data.size();\n    }\n  }", "author": "cgtz", "createdAt": "2020-03-30T17:49:26Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2NetworkClient.java", "diffHunk": "@@ -17,38 +17,94 @@\n import com.github.ambry.commons.SSLFactory;\n import com.github.ambry.config.Http2ClientConfig;\n import com.github.ambry.network.NetworkClient;\n+import com.github.ambry.network.NetworkClientErrorCode;\n import com.github.ambry.network.RequestInfo;\n import com.github.ambry.network.ResponseInfo;\n+import io.netty.channel.Channel;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.pool.ChannelPool;\n import io.netty.channel.pool.ChannelPoolMap;\n+import io.netty.util.AttributeKey;\n import java.net.InetSocketAddress;\n+import java.util.Collections;\n import java.util.List;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import java.util.ArrayList;\n import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n /**\n  * A HTTP/2 implementation of {@link NetworkClient}.\n- * TODO: More implementation details will be added in next PR.\n  */\n public class Http2NetworkClient implements NetworkClient {\n   private static final Logger logger = LoggerFactory.getLogger(Http2NetworkClient.class);\n   private final EventLoopGroup eventLoopGroup;\n   private final ChannelPoolMap<InetSocketAddress, ChannelPool> pools;\n+  private final Http2ClientResponseHandler http2ClientResponseHandler;\n+  private final Http2ClientMetrics http2ClientMetrics;\n+  public static final ResponseInfo WAKEUP_MARKER = new ResponseInfo(null, null, null);\n+  static final AttributeKey<RequestInfo> REQUEST_INFO = AttributeKey.newInstance(\"RequestInfo\");\n \n   public Http2NetworkClient(Http2ClientMetrics http2ClientMetrics, Http2ClientConfig http2ClientConfig,\n       SSLFactory sslFactory) {\n+    logger.info(\"Http2NetworkClient started\");\n     this.eventLoopGroup = new NioEventLoopGroup(http2ClientConfig.http2NettyEventLoopGroupThreads);\n-    this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig);\n+    this.pools = new Http2ChannelPoolMap(sslFactory, eventLoopGroup, http2ClientConfig, http2ClientMetrics);\n+    this.http2ClientResponseHandler = new Http2ClientResponseHandler(this);\n+    this.http2ClientMetrics = http2ClientMetrics;\n   }\n \n   @Override\n   public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop,\n       int pollTimeoutMs) {\n-    return null;\n+    long startTime = System.currentTimeMillis();\n+    List<ResponseInfo> readyResponseInfos = new ArrayList<>();\n+    // Send request\n+    http2ClientMetrics.http2ClientSendRate.mark(requestsToSend.size());\n+    for (RequestInfo requestInfo : requestsToSend) {\n+      long streamInitiateTime = System.currentTimeMillis();\n+      this.pools.get(InetSocketAddress.createUnresolved(requestInfo.getHost(), requestInfo.getPort().getPort()))\n+          .acquire()\n+          .addListener((GenericFutureListener<Future<Channel>>) future -> {\n+            if (future.isSuccess()) {\n+              http2ClientMetrics.http2StreamAcquireTime.update(System.currentTimeMillis() - streamInitiateTime);\n+              Channel streamChannel = future.getNow();\n+              streamChannel.pipeline().addLast(http2ClientResponseHandler);\n+              streamChannel.pipeline().addLast(new AmbrySendToHttp2Adaptor());\n+              streamChannel.attr(REQUEST_INFO).set(requestInfo);\n+              streamChannel.write(requestInfo.getRequest());\n+              requestInfo.setStreamSendTime(System.currentTimeMillis());\n+            } else {\n+              logger.error(\"Couldn't acquire stream channel: \" + future.cause());\n+              readyResponseInfos.add(new ResponseInfo(requestInfo, NetworkClientErrorCode.NetworkError, null));\n+            }\n+          });\n+    }\n+    http2ClientMetrics.http2ClientSendTime.update(System.currentTimeMillis() - startTime);\n+    // TODO: close stream channel for requestsToDrop. Need a hashmap from corelationId to streamChannel\n+\n+    ResponseInfo firstResponse = null;\n+    try {\n+      firstResponse = http2ClientResponseHandler.getResponseInfoQueue().poll(pollTimeoutMs, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException ie) {\n+      logger.debug(\"Interrupted polling responses\");\n+    }\n+    if (firstResponse == null) {\n+      return Collections.emptyList();\n+    }\n+    // using a linked list to make removal easier (maybe there's a better way to handle this)\n+    readyResponseInfos.add(firstResponse);\n+    http2ClientResponseHandler.getResponseInfoQueue().drainTo(readyResponseInfos);\n+    // wakeup markers will be detected in NonBlockingRouter#onResponse()", "originalCommit": "bb27ea052af89bc9983d08834e16962c7a5472c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzMTI5Nw==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r401331297", "bodyText": "thanks! FilteredInserter used.", "author": "zzmao", "createdAt": "2020-04-01T03:10:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM4MDQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM4MjA2MQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r400382061", "bodyText": "minor: change this to say 800 ms", "author": "cgtz", "createdAt": "2020-03-30T17:52:08Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/MultiplexedChannelRecord.java", "diffHunk": "@@ -131,10 +135,11 @@ protected void initChannel(Channel ch) throws Exception {\n   }\n \n   private void enableCloseIfIdleTask() {\n+    log.info(\"enableCloseIfIdleTask is enabled.\");\n     NettyUtils.warnIfNotInEventLoop(parentChannel.eventLoop());\n \n     // Don't poll more frequently than 1 second. Being overly-conservative is okay. Blowing up our CPU is not.", "originalCommit": "bb27ea052af89bc9983d08834e16962c7a5472c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzNzIxOQ==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r400437219", "bodyText": "The reason I changed it to 800ms is I saw some stream acquire latency is 100X ms. The change is to rule out it caused by this line. (and after the change I still see 100x ms, but anyway will keep this 800ms)", "author": "zzmao", "createdAt": "2020-03-30T19:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM4MjA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NDIyOA==", "url": "https://github.com/linkedin/ambry/pull/1421#discussion_r400574228", "bodyText": "Does the stream acquire time potentially include SSL handshakes on new connections leading to the high latency?", "author": "cgtz", "createdAt": "2020-03-31T00:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM4MjA2MQ=="}], "type": "inlineReview"}, {"oid": "0c2854b04c971df8d8963840752ff282b658d90c", "url": "https://github.com/linkedin/ambry/commit/0c2854b04c971df8d8963840752ff282b658d90c", "message": "add writeAndFlush handling", "committedDate": "2020-04-01T03:09:30Z", "type": "forcePushed"}, {"oid": "e51ac002534efe576da8b94a7738c4f9dc3e0e65", "url": "https://github.com/linkedin/ambry/commit/e51ac002534efe576da8b94a7738c4f9dc3e0e65", "message": "add writeAndFlush handling.", "committedDate": "2020-04-01T16:45:10Z", "type": "forcePushed"}, {"oid": "d02622e4a422aaad0238d5ab7c1924b9dc41dc61", "url": "https://github.com/linkedin/ambry/commit/d02622e4a422aaad0238d5ab7c1924b9dc41dc61", "message": "Http2NetworkClient Implementation\n\nImplemented Http2NetworkClient and other http2 client related class.\nRemoved ClusterMapHttp2NetworkClientEndbaled, becuase we can only test router based http2 request(Http2 request for replication is not supported.)\nAdded RouterEnableHttp2NetworkClient.", "committedDate": "2020-04-01T20:54:46Z", "type": "forcePushed"}, {"oid": "3a3157b418fe7ae23d736d9898b7948b3a3763ea", "url": "https://github.com/linkedin/ambry/commit/3a3157b418fe7ae23d736d9898b7948b3a3763ea", "message": "a fix", "committedDate": "2020-04-01T23:46:00Z", "type": "forcePushed"}, {"oid": "b0f090d70d500764f85c1c5e48724bfa40d62058", "url": "https://github.com/linkedin/ambry/commit/b0f090d70d500764f85c1c5e48724bfa40d62058", "message": "fix test error and rebase", "committedDate": "2020-04-02T00:56:28Z", "type": "forcePushed"}, {"oid": "ec372020ece4734b0da3a3e5ddb82d2294026898", "url": "https://github.com/linkedin/ambry/commit/ec372020ece4734b0da3a3e5ddb82d2294026898", "message": "Http2NetworkClient Implementation\n\nImplemented Http2NetworkClient and other http2 client related class.\nRemoved ClusterMapHttp2NetworkClientEndbaled, becuase we can only test router based http2 request(Http2 request for replication is not supported.)\nAdded RouterEnableHttp2NetworkClient.", "committedDate": "2020-04-02T22:29:18Z", "type": "commit"}, {"oid": "2c86cd33426713823aa311e8dd96f2da988fed0e", "url": "https://github.com/linkedin/ambry/commit/2c86cd33426713823aa311e8dd96f2da988fed0e", "message": "fix test error and rebase", "committedDate": "2020-04-02T22:29:18Z", "type": "commit"}, {"oid": "2c86cd33426713823aa311e8dd96f2da988fed0e", "url": "https://github.com/linkedin/ambry/commit/2c86cd33426713823aa311e8dd96f2da988fed0e", "message": "fix test error and rebase", "committedDate": "2020-04-02T22:29:18Z", "type": "forcePushed"}]}