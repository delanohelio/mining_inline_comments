{"pr_number": 1379, "pr_title": "Add handleUndeleteRequest method to AmbryRequests", "pr_createdAt": "2020-02-10T19:21:59Z", "pr_url": "https://github.com/linkedin/ambry/pull/1379", "timeline": [{"oid": "15c4975bd55a7bcdddd2ab8d9631be11ecf5e413", "url": "https://github.com/linkedin/ambry/commit/15c4975bd55a7bcdddd2ab8d9631be11ecf5e413", "message": "fix test", "committedDate": "2020-02-10T22:40:01Z", "type": "forcePushed"}, {"oid": "315196578d9aeb29921077a163f4f250496f6f8a", "url": "https://github.com/linkedin/ambry/commit/315196578d9aeb29921077a163f4f250496f6f8a", "message": "fix test", "committedDate": "2020-02-11T01:25:56Z", "type": "forcePushed"}, {"oid": "2fb5c4b3283bad6ad7e83cfd7b943c2ae3ee8b89", "url": "https://github.com/linkedin/ambry/commit/2fb5c4b3283bad6ad7e83cfd7b943c2ae3ee8b89", "message": "Add handleUndeleteRequest method to AmbryRequests", "committedDate": "2020-02-12T19:24:30Z", "type": "commit"}, {"oid": "7279ad26be40c10df363795b946e7e2b06197675", "url": "https://github.com/linkedin/ambry/commit/7279ad26be40c10df363795b946e7e2b06197675", "message": "fix test", "committedDate": "2020-02-12T19:24:30Z", "type": "commit"}, {"oid": "f91f71498656ad1f78a66557b12d63a17ec453cc", "url": "https://github.com/linkedin/ambry/commit/f91f71498656ad1f78a66557b12d63a17ec453cc", "message": "Add writeTo method to UndeleteResponse", "committedDate": "2020-02-12T19:24:30Z", "type": "commit"}, {"oid": "8dedd67c2f648f3b21ce2f67f6a0d33775b7bfea", "url": "https://github.com/linkedin/ambry/commit/8dedd67c2f648f3b21ce2f67f6a0d33775b7bfea", "message": "Fix", "committedDate": "2020-02-12T19:24:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MDkyMA==", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379050920", "bodyText": "storeToUndelete?", "author": "zzmao", "createdAt": "2020-02-13T18:48:20Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());", "originalCommit": "01605864ac2919dcf44d2791a7e7cfaef8b02e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MTcyNw==", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379051727", "bodyText": "ID_Deleted is the expected case, no?\nWhy no ID_Undeleted?", "author": "zzmao", "createdAt": "2020-02-13T18:49:52Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n+        short lifeVersion = storeToDelete.undelete(info);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n+        if (notification != null) {\n+          notification.onBlobReplicaUndeleted(currentNode.getHostname(), currentNode.getPort(),\n+              convertedStoreKey.getID(), BlobReplicaSourceType.PRIMARY);\n+        }\n+      }\n+    } catch (StoreException e) {\n+      boolean logInErrorLevel = false;\n+      if (e.getErrorCode() == StoreErrorCodes.ID_Not_Found) {\n+        metrics.idNotFoundError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.TTL_Expired) {\n+        metrics.ttlExpiredError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.ID_Deleted) {", "originalCommit": "01605864ac2919dcf44d2791a7e7cfaef8b02e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MjE2NQ==", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379052165", "bodyText": "unExpectedStoreUndeleteError?", "author": "zzmao", "createdAt": "2020-02-13T18:50:43Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n+        short lifeVersion = storeToDelete.undelete(info);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n+        if (notification != null) {\n+          notification.onBlobReplicaUndeleted(currentNode.getHostname(), currentNode.getPort(),\n+              convertedStoreKey.getID(), BlobReplicaSourceType.PRIMARY);\n+        }\n+      }\n+    } catch (StoreException e) {\n+      boolean logInErrorLevel = false;\n+      if (e.getErrorCode() == StoreErrorCodes.ID_Not_Found) {\n+        metrics.idNotFoundError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.TTL_Expired) {\n+        metrics.ttlExpiredError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.ID_Deleted) {\n+        metrics.idDeletedError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.Authorization_Failure) {\n+        metrics.deleteAuthorizationFailure.inc();\n+      } else {\n+        logInErrorLevel = true;\n+        metrics.unExpectedStoreDeleteError.inc();", "originalCommit": "01605864ac2919dcf44d2791a7e7cfaef8b02e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MjQxMw==", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379052413", "bodyText": "undeleteAuthorizationFailure?", "author": "zzmao", "createdAt": "2020-02-13T18:51:12Z", "path": "ambry-protocol/src/main/java/com.github.ambry.protocol/AmbryRequests.java", "diffHunk": "@@ -641,9 +644,78 @@ public void handleReplicaMetadataRequest(NetworkRequest request) throws IOExcept\n             metrics.replicaMetadataSendTimeInMs, metrics.replicaMetadataTotalTimeInMs, null, null, totalTimeSpent));\n   }\n \n-  private void sendPutResponse(RequestResponseChannel requestResponseChannel, PutResponse response, NetworkRequest request,\n-      Histogram responseQueueTime, Histogram responseSendTime, Histogram requestTotalTime, long totalTimeSpent,\n-      long blobSize, ServerMetrics metrics) throws InterruptedException {\n+  @Override\n+  public void handleUndeleteRequest(NetworkRequest request) throws IOException, InterruptedException {\n+    UndeleteRequest undeleteRequest =\n+        UndeleteRequest.readFrom(new DataInputStream(request.getInputStream()), clusterMap);\n+    long requestQueueTime = SystemTime.getInstance().milliseconds() - request.getStartTimeInMs();\n+    long totalTimeSpent = requestQueueTime;\n+    metrics.undeleteBlobRequestQueueTimeInMs.update(requestQueueTime);\n+    metrics.undeleteBlobRequestRate.mark();\n+    long startTime = SystemTime.getInstance().milliseconds();\n+    UndeleteResponse response = null;\n+    try {\n+      StoreKey convertedStoreKey = getConvertedStoreKeys(Collections.singletonList(undeleteRequest.getBlobId())).get(0);\n+      ServerErrorCode error =\n+          validateRequest(undeleteRequest.getBlobId().getPartition(), RequestOrResponseType.UndeleteRequest, false);\n+      if (error != ServerErrorCode.No_Error) {\n+        logger.error(\"Validating undelete request failed with error {} for request {}\", error, undeleteRequest);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), error);\n+      } else {\n+        BlobId convertedBlobId = (BlobId) convertedStoreKey;\n+        MessageInfo info =\n+            new MessageInfo(convertedBlobId, 0, convertedBlobId.getAccountId(), convertedBlobId.getContainerId(),\n+                undeleteRequest.getOperationTimeMs());\n+        Store storeToDelete = storeManager.getStore(undeleteRequest.getBlobId().getPartition());\n+        short lifeVersion = storeToDelete.undelete(info);\n+        response = new UndeleteResponse(undeleteRequest.getCorrelationId(), undeleteRequest.getClientId(), lifeVersion);\n+        if (notification != null) {\n+          notification.onBlobReplicaUndeleted(currentNode.getHostname(), currentNode.getPort(),\n+              convertedStoreKey.getID(), BlobReplicaSourceType.PRIMARY);\n+        }\n+      }\n+    } catch (StoreException e) {\n+      boolean logInErrorLevel = false;\n+      if (e.getErrorCode() == StoreErrorCodes.ID_Not_Found) {\n+        metrics.idNotFoundError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.TTL_Expired) {\n+        metrics.ttlExpiredError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.ID_Deleted) {\n+        metrics.idDeletedError.inc();\n+      } else if (e.getErrorCode() == StoreErrorCodes.Authorization_Failure) {\n+        metrics.deleteAuthorizationFailure.inc();", "originalCommit": "01605864ac2919dcf44d2791a7e7cfaef8b02e82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bec9a78176ab495dc8409efb70e58fdacd8cdf20", "url": "https://github.com/linkedin/ambry/commit/bec9a78176ab495dc8409efb70e58fdacd8cdf20", "message": "Address comments about metrics", "committedDate": "2020-02-13T19:18:23Z", "type": "commit"}, {"oid": "bec9a78176ab495dc8409efb70e58fdacd8cdf20", "url": "https://github.com/linkedin/ambry/commit/bec9a78176ab495dc8409efb70e58fdacd8cdf20", "message": "Address comments about metrics", "committedDate": "2020-02-13T19:18:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwMzQxMA==", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379603410", "bodyText": "Can we move this piece of code into isRequestEnabled() ?", "author": "jsjtzyy", "createdAt": "2020-02-14T19:23:27Z", "path": "ambry-server/src/main/java/com.github.ambry.server/AmbryServerRequests.java", "diffHunk": "@@ -614,6 +615,10 @@ protected ServerErrorCode validateRequest(PartitionId partition, RequestOrRespon\n       metrics.partitionReadOnlyError.inc();\n       return ServerErrorCode.Partition_ReadOnly;\n     }\n+    if (requestType.equals(RequestOrResponseType.UndeleteRequest) && !serverConfig.serverHandleUndeleteRequestEnabled) {\n+      metrics.temporarilyDisabledError.inc();\n+      return ServerErrorCode.Temporarily_Disabled;\n+    }", "originalCommit": "bec9a78176ab495dc8409efb70e58fdacd8cdf20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNzE0Nw==", "url": "https://github.com/linkedin/ambry/pull/1379#discussion_r379607147", "bodyText": "sure", "author": "justinlin-linkedin", "createdAt": "2020-02-14T19:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwMzQxMA=="}], "type": "inlineReview"}, {"oid": "bf924157a7c7c261c9ff91f5bbb4dadea5b51acd", "url": "https://github.com/linkedin/ambry/commit/bf924157a7c7c261c9ff91f5bbb4dadea5b51acd", "message": "Comments", "committedDate": "2020-02-14T19:31:47Z", "type": "commit"}]}