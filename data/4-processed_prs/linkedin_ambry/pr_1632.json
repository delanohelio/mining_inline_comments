{"pr_number": 1632, "pr_title": "[CLOUD_CONTAINER_DELETION] Implementation of helix task framework based service to sync deleted containers", "pr_createdAt": "2020-09-28T21:13:45Z", "pr_url": "https://github.com/linkedin/ambry/pull/1632", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4ODc3MA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499188770", "bodyText": "containerIdSet is never used.", "author": "jsjtzyy", "createdAt": "2020-10-03T23:02:43Z", "path": "ambry-account/src/test/java/com/github/ambry/account/AccountTestUtils.java", "diffHunk": "@@ -111,33 +113,11 @@ static void generateRefAccounts(Map<Short, Account> idToRefAccountMap,\n       Map<Short, Container> idToContainers = new HashMap<>();\n       List<Container> containers = new ArrayList<>();\n       Set<Short> containerIdSet = new HashSet<>();", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNTg4Mg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501205882", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T17:59:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4ODc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4ODc4MA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499188780", "bodyText": "nit: use method reference, change containerBuilder -> containerBuilder.build() to ContainerBuilder::build.", "author": "jsjtzyy", "createdAt": "2020-10-03T23:02:46Z", "path": "ambry-account/src/test/java/com/github/ambry/account/AccountTestUtils.java", "diffHunk": "@@ -111,33 +113,11 @@ static void generateRefAccounts(Map<Short, Account> idToRefAccountMap,\n       Map<Short, Container> idToContainers = new HashMap<>();\n       List<Container> containers = new ArrayList<>();\n       Set<Short> containerIdSet = new HashSet<>();\n-      for (int j = 0; j < containerCountPerAccount; j++) {\n-        short containerId = Utils.getRandomShort(random);\n-        if (!containerIdSet.add(containerId)) {\n-          j--;\n-          continue;\n-        }\n-        String containerName = UUID.randomUUID().toString();\n-        Container.ContainerStatus containerStatus =\n-            random.nextBoolean() ? Container.ContainerStatus.ACTIVE : Container.ContainerStatus.INACTIVE;\n-        String containerDescription = UUID.randomUUID().toString();\n-        boolean containerCaching = random.nextBoolean();\n-        boolean containerEncryption = random.nextBoolean();\n-        boolean containerPreviousEncryption = containerEncryption || random.nextBoolean();\n-        boolean mediaScanDisabled = random.nextBoolean();\n-        String replicationPolicy = TestUtils.getRandomString(10);\n-        boolean ttlRequired = random.nextBoolean();\n-        Container container = new ContainerBuilder(containerId, containerName, containerStatus, containerDescription,\n-            accountId).setEncrypted(containerEncryption)\n-            .setPreviouslyEncrypted(containerPreviousEncryption)\n-            .setCacheable(containerCaching)\n-            .setMediaScanDisabled(mediaScanDisabled)\n-            .setReplicationPolicy(replicationPolicy)\n-            .setTtlRequired(ttlRequired)\n-            .build();\n-        containers.add(container);\n-        idToContainers.put(containerId, container);\n-      }\n+      List<ContainerBuilder> containerBuilders = generateContainerBuilders(containerCountPerAccount, accountId);\n+\n+      containers.addAll(\n+          containerBuilders.stream().map(containerBuilder -> containerBuilder.build()).collect(Collectors.toList()));", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNjMzMg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501206332", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T18:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4ODc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4OTM4Mg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499189382", "bodyText": "In my humble opinion, this method is for particular test case and is not general enough to justify a helper method in AccountTestUtils. (Also it has duplicate code with generateRefAccounts). Can we move this piece of logic to its caller testGetDeprecatedContainers() in HelixAccountServiceTest.java?", "author": "jsjtzyy", "createdAt": "2020-10-03T23:13:12Z", "path": "ambry-account/src/test/java/com/github/ambry/account/AccountTestUtils.java", "diffHunk": "@@ -146,4 +126,87 @@ static void generateRefAccounts(Map<Short, Account> idToRefAccountMap,\n     }\n     assertEquals(\"Wrong number of generated accounts\", accountCount, idToRefAccountMap.size());\n   }\n+\n+  /**\n+   * Randomly generates a collection of {@link Account}s, which do not have the same id or name with needed container status.\n+   * @param idToRefAccountMap A map from id to {@link Account} to populate with the generated {@link Account}s.\n+   * @param idToRefContainerMap A map from name to {@link Account} to populate with the generated {@link Account}s.\n+   * @param accountIdSet A set of ids that could not be used to generate {@link Account}s.\n+   * @param accountCount The number of {@link Account}s to generate.\n+   * @param timestamp timestamp for delete trigger time.\n+   * @throws Exception\n+   */\n+  static void generateRefAccountsForDeprecationTest(Map<Short, Account> idToRefAccountMap,\n+      Map<Short, Map<Short, Container>> idToRefContainerMap, Set<Short> accountIdSet, int accountCount, long timestamp)\n+      throws Exception {\n+    idToRefAccountMap.clear();\n+    idToRefContainerMap.clear();\n+    for (int i = 0; i < accountCount; i++) {\n+      short accountId = Utils.getRandomShort(random);\n+      if (!accountIdSet.add(accountId)) {\n+        i--;\n+        continue;\n+      }\n+      String accountName = UUID.randomUUID().toString();\n+      Account.AccountStatus accountStatus =\n+          random.nextBoolean() ? Account.AccountStatus.ACTIVE : Account.AccountStatus.INACTIVE;\n+      Map<Short, Container> idToContainers = new HashMap<>();\n+      List<Container> containers = new ArrayList<>();\n+      Set<Short> containerIdSet = new HashSet<>();\n+      List<ContainerBuilder> containerBuilders = generateContainerBuilders(4, accountId);\n+      containerBuilders.get(0).setStatus(Container.ContainerStatus.ACTIVE);\n+      containerBuilders.get(1).setStatus(Container.ContainerStatus.INACTIVE);\n+      containerBuilders.get(2).setStatus(Container.ContainerStatus.DELETE_IN_PROGRESS);\n+      containerBuilders.get(2).setDeleteTriggerTime(timestamp);\n+      containerBuilders.get(3).setStatus(Container.ContainerStatus.DELETE_IN_PROGRESS);\n+      containerBuilders.get(3).setDeleteTriggerTime(timestamp + 10000);", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNzU4Mw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501207583", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T18:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4OTM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4OTUzOA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499189538", "bodyText": "If we decide to remove generateRefAccountsForDeprecationTest() method, we can return a list of containers instead of ContainerBuilder in this method.", "author": "jsjtzyy", "createdAt": "2020-10-03T23:15:43Z", "path": "ambry-account/src/test/java/com/github/ambry/account/AccountTestUtils.java", "diffHunk": "@@ -146,4 +126,87 @@ static void generateRefAccounts(Map<Short, Account> idToRefAccountMap,\n     }\n     assertEquals(\"Wrong number of generated accounts\", accountCount, idToRefAccountMap.size());\n   }\n+\n+  /**\n+   * Randomly generates a collection of {@link Account}s, which do not have the same id or name with needed container status.\n+   * @param idToRefAccountMap A map from id to {@link Account} to populate with the generated {@link Account}s.\n+   * @param idToRefContainerMap A map from name to {@link Account} to populate with the generated {@link Account}s.\n+   * @param accountIdSet A set of ids that could not be used to generate {@link Account}s.\n+   * @param accountCount The number of {@link Account}s to generate.\n+   * @param timestamp timestamp for delete trigger time.\n+   * @throws Exception\n+   */\n+  static void generateRefAccountsForDeprecationTest(Map<Short, Account> idToRefAccountMap,\n+      Map<Short, Map<Short, Container>> idToRefContainerMap, Set<Short> accountIdSet, int accountCount, long timestamp)\n+      throws Exception {\n+    idToRefAccountMap.clear();\n+    idToRefContainerMap.clear();\n+    for (int i = 0; i < accountCount; i++) {\n+      short accountId = Utils.getRandomShort(random);\n+      if (!accountIdSet.add(accountId)) {\n+        i--;\n+        continue;\n+      }\n+      String accountName = UUID.randomUUID().toString();\n+      Account.AccountStatus accountStatus =\n+          random.nextBoolean() ? Account.AccountStatus.ACTIVE : Account.AccountStatus.INACTIVE;\n+      Map<Short, Container> idToContainers = new HashMap<>();\n+      List<Container> containers = new ArrayList<>();\n+      Set<Short> containerIdSet = new HashSet<>();\n+      List<ContainerBuilder> containerBuilders = generateContainerBuilders(4, accountId);\n+      containerBuilders.get(0).setStatus(Container.ContainerStatus.ACTIVE);\n+      containerBuilders.get(1).setStatus(Container.ContainerStatus.INACTIVE);\n+      containerBuilders.get(2).setStatus(Container.ContainerStatus.DELETE_IN_PROGRESS);\n+      containerBuilders.get(2).setDeleteTriggerTime(timestamp);\n+      containerBuilders.get(3).setStatus(Container.ContainerStatus.DELETE_IN_PROGRESS);\n+      containerBuilders.get(3).setDeleteTriggerTime(timestamp + 10000);\n+\n+      containers.addAll(\n+          containerBuilders.stream().map(containerBuilder -> containerBuilder.build()).collect(Collectors.toList()));\n+      idToContainers = containers.stream().collect(Collectors.toMap(Container::getId, Function.identity()));\n+      Account account = new AccountBuilder(accountId, accountName, accountStatus).containers(containers).build();\n+      assertEquals(\"Wrong number of generated containers for the account\", 4, account.getAllContainers().size());\n+      idToRefAccountMap.put(accountId, account);\n+      idToRefContainerMap.put(accountId, idToContainers);\n+    }\n+    assertEquals(\"Wrong number of generated accounts\", accountCount, idToRefAccountMap.size());\n+  }\n+\n+  /**\n+   * Generate {@link ContainerBuilder}s for specified {@code accountId}.\n+   * @param numContainers number of {@link ContainerBuilder}s to generate.\n+   * @param accountId accountId for container.\n+   * @return {@link List} of {@link ContainerBuilder}s.\n+   */\n+  private static List<ContainerBuilder> generateContainerBuilders(int numContainers, short accountId) {", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwODk4MQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501208981", "bodyText": "This method is also being used by AccountTestUtils.generateRefAccounts . The idea to create this method is that it can be used as a common method for tests that need to create a certain number of containers. This will generate the required number of ContainerBuilders, and individual tests can then modify the builders if they need to. Note that Container objects are immutable, hence I am returning ContainerBuilder here.", "author": "ankagrawal", "createdAt": "2020-10-07T18:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4OTUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIxMzE0OQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499213149", "bodyText": "This can be simplified as:\ndeprecatedContainers.addAll(getContainersByStatus(Container.ContainerStatus.INACTIVE));", "author": "jsjtzyy", "createdAt": "2020-10-04T06:57:41Z", "path": "ambry-api/src/main/java/com/github/ambry/account/AccountService.java", "diffHunk": "@@ -122,6 +123,23 @@\n     return selectedContainers;\n   }\n \n+  /**\n+   * @return {@link Set} of {@link Container}s ready for deletion.\n+   */\n+  default Set<Container> getDeprecatedContainers(long containerDeletionRetentionDays) {\n+    Set<Container> deprecatedContainers = new HashSet<>();\n+    getContainersByStatus(Container.ContainerStatus.DELETE_IN_PROGRESS).forEach((container) -> {\n+      if (container.getDeleteTriggerTime() + TimeUnit.DAYS.toMillis(containerDeletionRetentionDays)\n+          <= System.currentTimeMillis()) {\n+        deprecatedContainers.add(container);\n+      }\n+    });\n+    getContainersByStatus(Container.ContainerStatus.INACTIVE).forEach((container) -> {\n+      deprecatedContainers.add(container);\n+    });", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MjEyOQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501272129", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T19:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIxMzE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NjQ2OA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499286468", "bodyText": "String.format(...) is unnecessary.", "author": "jsjtzyy", "createdAt": "2020-10-04T20:38:24Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/HelixVcrCluster.java", "diffHunk": "@@ -146,11 +162,31 @@ public void participate() throws Exception {\n         cloudConfig.vcrClusterZkConnectString);\n     VcrStateModelFactory stateModelFactory = Utils.getObj(cloudConfig.vcrHelixStateModelFactoryClass, this);\n     manager.getStateMachineEngine().registerStateModelFactory(stateModelFactory.getStateModelName(), stateModelFactory);\n+    registerContainerDeletionSyncTask(manager.getStateMachineEngine());\n     manager.connect();\n     helixAdmin = manager.getClusterManagmentTool();\n     logger.info(\"Participated in HelixVcrCluster successfully.\");\n   }\n \n+  /**\n+   * Register {@link CloudContainerDeletionSyncTask}s to sync deleted container information from account service to VCR.\n+   * @param engine the {@link StateMachineEngine} to register the task state model.\n+   */\n+  private void registerContainerDeletionSyncTask(StateMachineEngine engine) {\n+    Map<String, TaskFactory> taskFactoryMap = new HashMap<>();\n+    taskFactoryMap.put(String.format(\"%s\", CloudContainerDeletionSyncTask.class.getSimpleName()), new TaskFactory() {", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyNjcwMg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501226702", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T18:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NjQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NjczNw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499286737", "bodyText": "I know it is legacy code but, if possible, I would like to move ContainerDeletionRetentionDays to accountServiceConfig rather than storeConfig. Thus, the retention days would be within accountService and we don't have to pass the parameters to getDeprecatedContainers(). What do you think?", "author": "jsjtzyy", "createdAt": "2020-10-04T20:41:25Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/HelixVcrCluster.java", "diffHunk": "@@ -146,11 +162,31 @@ public void participate() throws Exception {\n         cloudConfig.vcrClusterZkConnectString);\n     VcrStateModelFactory stateModelFactory = Utils.getObj(cloudConfig.vcrHelixStateModelFactoryClass, this);\n     manager.getStateMachineEngine().registerStateModelFactory(stateModelFactory.getStateModelName(), stateModelFactory);\n+    registerContainerDeletionSyncTask(manager.getStateMachineEngine());\n     manager.connect();\n     helixAdmin = manager.getClusterManagmentTool();\n     logger.info(\"Participated in HelixVcrCluster successfully.\");\n   }\n \n+  /**\n+   * Register {@link CloudContainerDeletionSyncTask}s to sync deleted container information from account service to VCR.\n+   * @param engine the {@link StateMachineEngine} to register the task state model.\n+   */\n+  private void registerContainerDeletionSyncTask(StateMachineEngine engine) {\n+    Map<String, TaskFactory> taskFactoryMap = new HashMap<>();\n+    taskFactoryMap.put(String.format(\"%s\", CloudContainerDeletionSyncTask.class.getSimpleName()), new TaskFactory() {\n+      @Override\n+      public Task createNewTask(TaskCallbackContext context) {\n+        return new CloudContainerDeletionSyncTask(accountService, storeConfig.storeContainerDeletionRetentionDays,", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyOTc5NA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501229794", "bodyText": "Makes sense. But there doesn't seem to be any AccountServiceConfig class. I see that there are HelixAccountServiceConfig and MysqlAccountServiceConfig classes. We can either move this config to both the classes (but code duplication) or we can create a new class for this (but it will contain only one config for now). We also leave it as is for now. I don't have any preference for any of the options. Do let me know what would be the best course of action here.", "author": "ankagrawal", "createdAt": "2020-10-07T18:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NjczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MjMxNw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501292317", "bodyText": "After rebasing the code, I see that we do have a AccountServiceConfig class that has been recently created. I would still want to defer this change to a future PR. The reason is that containerDeletionRetentionDelays config is also being used in BlobStoreCompactor class. In order to pass AccountServiceConfig to this class, I will need to change a lot of other classes that are unrelated to this change.\nI have created a ticket https://jira01.corp.linkedin.com:8443/browse/AMBRY-7592 for this which I have assigned to the current sprint.", "author": "ankagrawal", "createdAt": "2020-10-07T20:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NjczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NzM5Mw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499287393", "bodyText": "These newly added parameters will be used in future PR?", "author": "jsjtzyy", "createdAt": "2020-10-04T20:49:07Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/StaticVcrClusterFactory.java", "diffHunk": "@@ -30,7 +32,8 @@\n   private final ClusterMap clusterMap;\n   private VirtualReplicatorCluster virtualReplicatorCluster;\n \n-  public StaticVcrClusterFactory(CloudConfig cloudConfig, ClusterMapConfig clusterMapConfig, ClusterMap clusterMap) {\n+  public StaticVcrClusterFactory(CloudConfig cloudConfig, ClusterMapConfig clusterMapConfig, ClusterMap clusterMap,\n+      AccountService accountService, StoreConfig storeConfig, CloudDestination cloudDestination) {", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzMDAwNQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501230005", "bodyText": "Yes.", "author": "ankagrawal", "createdAt": "2020-10-07T18:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4NzM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4OTM0NA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499289344", "bodyText": "There is no return of this method, we can update the java doc", "author": "jsjtzyy", "createdAt": "2020-10-04T21:12:13Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreCompactor.java", "diffHunk": "@@ -204,16 +202,11 @@ void compact(CompactionDetails details, byte[] bundleReadBuffer) throws IOExcept\n   private void getDeprecatedContainers() {", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1NzM5NQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501257395", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T19:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI4OTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2OTA2NQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499369065", "bodyText": "minor: can you update doc for other two param?", "author": "SophieGuo410", "createdAt": "2020-10-05T06:31:17Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudContainerDeletionSyncTask.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud;\n+\n+import com.github.ambry.account.AccountService;\n+import com.github.ambry.account.Container;\n+import java.util.Set;\n+import org.apache.helix.task.Task;\n+import org.apache.helix.task.TaskResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Helix task to get the deleted containers information from {@link com.github.ambry.account.AccountService} and update\n+ * it in CosmosDb DeleteContainers table.\n+ */\n+public class CloudContainerDeletionSyncTask implements Task {\n+  private static final Logger logger = LoggerFactory.getLogger(CloudContainerDeletionSyncTask.class);\n+  private final AccountService accountService;\n+  private final long containerDeletionRetentionDays;\n+  private final CloudDestination cloudDestination;\n+\n+  /**\n+   * Constructor for {@link CloudContainerDeletionSyncTask}.\n+   * @param accountService {@link AccountService} object.\n+   */", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNDg5Mg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501214892", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T18:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2OTA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3NzM5NA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499377394", "bodyText": "Do we need the cloudConfig and vcrMetrics in this class?", "author": "SophieGuo410", "createdAt": "2020-10-05T06:55:09Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureContainerCompactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud.azure;\n+\n+import com.azure.storage.blob.models.BlobErrorCode;\n+import com.azure.storage.blob.models.BlobStorageException;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.cloud.CloudRequestAgent;\n+import com.github.ambry.cloud.CloudStorageException;\n+import com.github.ambry.cloud.VcrMetrics;\n+import com.github.ambry.config.CloudConfig;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Class that compacts containers in the Azure cloud by purging blobs of deleted containers from\n+ * ABS and Cosmos.\n+ */\n+public class AzureContainerCompactor {\n+  static final String CONTAINER_DELETION_CHECKPOINT_FILE = \"container-deletion-checkpoint\";\n+  private static final Logger logger = LoggerFactory.getLogger(AzureContainerCompactor.class);\n+\n+  private final AzureBlobDataAccessor azureBlobDataAccessor;\n+  private final CosmosDataAccessor cosmosDataAccessor;\n+  private final CloudConfig cloudConfig;\n+  private final VcrMetrics vcrMetrics;\n+  private final AzureMetrics azureMetrics;\n+  private final CloudRequestAgent requestAgent;\n+\n+  /**\n+   * Constructor for {@link AzureContainerCompactor}.\n+   * @param azureBlobDataAccessor {@link AzureBlobDataAccessor} object to access Azure Blob Store.\n+   * @param cosmosDataAccessor {@link CosmosDataAccessor} object to access CosmosDb.\n+   * @param cloudConfig {@link CloudConfig} object.\n+   * @param vcrMetrics {@link VcrMetrics} object.\n+   * @param azureMetrics {@link AzureMetrics} object.\n+   */\n+  public AzureContainerCompactor(AzureBlobDataAccessor azureBlobDataAccessor, CosmosDataAccessor cosmosDataAccessor,\n+      CloudConfig cloudConfig, VcrMetrics vcrMetrics, AzureMetrics azureMetrics) {\n+    this.azureBlobDataAccessor = azureBlobDataAccessor;\n+    this.cosmosDataAccessor = cosmosDataAccessor;\n+    this.cloudConfig = cloudConfig;", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzMDUwNQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501230505", "bodyText": "This is for the next PR where I have implemented the actual compaction logic in this class.", "author": "ankagrawal", "createdAt": "2020-10-07T18:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3NzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3ODQyMw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499378423", "bodyText": "partitionPath is null, is this expected?", "author": "SophieGuo410", "createdAt": "2020-10-05T06:57:48Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureContainerCompactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud.azure;\n+\n+import com.azure.storage.blob.models.BlobErrorCode;\n+import com.azure.storage.blob.models.BlobStorageException;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.cloud.CloudRequestAgent;\n+import com.github.ambry.cloud.CloudStorageException;\n+import com.github.ambry.cloud.VcrMetrics;\n+import com.github.ambry.config.CloudConfig;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Class that compacts containers in the Azure cloud by purging blobs of deleted containers from\n+ * ABS and Cosmos.\n+ */\n+public class AzureContainerCompactor {\n+  static final String CONTAINER_DELETION_CHECKPOINT_FILE = \"container-deletion-checkpoint\";\n+  private static final Logger logger = LoggerFactory.getLogger(AzureContainerCompactor.class);\n+\n+  private final AzureBlobDataAccessor azureBlobDataAccessor;\n+  private final CosmosDataAccessor cosmosDataAccessor;\n+  private final CloudConfig cloudConfig;\n+  private final VcrMetrics vcrMetrics;\n+  private final AzureMetrics azureMetrics;\n+  private final CloudRequestAgent requestAgent;\n+\n+  /**\n+   * Constructor for {@link AzureContainerCompactor}.\n+   * @param azureBlobDataAccessor {@link AzureBlobDataAccessor} object to access Azure Blob Store.\n+   * @param cosmosDataAccessor {@link CosmosDataAccessor} object to access CosmosDb.\n+   * @param cloudConfig {@link CloudConfig} object.\n+   * @param vcrMetrics {@link VcrMetrics} object.\n+   * @param azureMetrics {@link AzureMetrics} object.\n+   */\n+  public AzureContainerCompactor(AzureBlobDataAccessor azureBlobDataAccessor, CosmosDataAccessor cosmosDataAccessor,\n+      CloudConfig cloudConfig, VcrMetrics vcrMetrics, AzureMetrics azureMetrics) {\n+    this.azureBlobDataAccessor = azureBlobDataAccessor;\n+    this.cosmosDataAccessor = cosmosDataAccessor;\n+    this.cloudConfig = cloudConfig;\n+    this.vcrMetrics = vcrMetrics;\n+    this.azureMetrics = azureMetrics;\n+    requestAgent = new CloudRequestAgent(cloudConfig, vcrMetrics);\n+  }\n+\n+  /**\n+   * Update newly deleted containers from {@code deletedContainers} to CosmosDb since last checkpoint.\n+   * @param deletedContainers {@link Set} of deleted {@link Container}s.\n+   * @throws CloudStorageException in case of any error.\n+   */\n+  public void updateDeletedContainers(Set<Container> deletedContainers) throws CloudStorageException {\n+    if (deletedContainers.isEmpty()) {\n+      logger.info(\"Got empty set to update deleted containers. Skipping update deleted containers to cloud.\");\n+      return;\n+    }\n+    long lastUpdatedContainerTimestamp = getLatestContainerDeletionTime();\n+    long newLastUpdateContainerTimestamp = requestAgent.doWithRetries(() -> cosmosDataAccessor.updateDeletedContainers(\n+        deletedContainers.stream()\n+            .filter(container -> container.getDeleteTriggerTime() >= lastUpdatedContainerTimestamp)\n+            .collect(Collectors.toSet())), \"updateDeletedContainer\", null);", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzMzE1Mg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501233152", "bodyText": "Yes its expected because update of deprecated container happens for all partitions.", "author": "ankagrawal", "createdAt": "2020-10-07T18:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM3ODQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM4MzM0NQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r499383345", "bodyText": "There's a situation that a container deletion has been canceled within the retention days so deleteTriggerTime will be back to 0, will you consider to sync that in the future implementation?", "author": "SophieGuo410", "createdAt": "2020-10-05T07:10:01Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/AzureContainerCompactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud.azure;\n+\n+import com.azure.storage.blob.models.BlobErrorCode;\n+import com.azure.storage.blob.models.BlobStorageException;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.cloud.CloudRequestAgent;\n+import com.github.ambry.cloud.CloudStorageException;\n+import com.github.ambry.cloud.VcrMetrics;\n+import com.github.ambry.config.CloudConfig;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Class that compacts containers in the Azure cloud by purging blobs of deleted containers from\n+ * ABS and Cosmos.\n+ */\n+public class AzureContainerCompactor {\n+  static final String CONTAINER_DELETION_CHECKPOINT_FILE = \"container-deletion-checkpoint\";\n+  private static final Logger logger = LoggerFactory.getLogger(AzureContainerCompactor.class);\n+\n+  private final AzureBlobDataAccessor azureBlobDataAccessor;\n+  private final CosmosDataAccessor cosmosDataAccessor;\n+  private final CloudConfig cloudConfig;\n+  private final VcrMetrics vcrMetrics;\n+  private final AzureMetrics azureMetrics;\n+  private final CloudRequestAgent requestAgent;\n+\n+  /**\n+   * Constructor for {@link AzureContainerCompactor}.\n+   * @param azureBlobDataAccessor {@link AzureBlobDataAccessor} object to access Azure Blob Store.\n+   * @param cosmosDataAccessor {@link CosmosDataAccessor} object to access CosmosDb.\n+   * @param cloudConfig {@link CloudConfig} object.\n+   * @param vcrMetrics {@link VcrMetrics} object.\n+   * @param azureMetrics {@link AzureMetrics} object.\n+   */\n+  public AzureContainerCompactor(AzureBlobDataAccessor azureBlobDataAccessor, CosmosDataAccessor cosmosDataAccessor,\n+      CloudConfig cloudConfig, VcrMetrics vcrMetrics, AzureMetrics azureMetrics) {\n+    this.azureBlobDataAccessor = azureBlobDataAccessor;\n+    this.cosmosDataAccessor = cosmosDataAccessor;\n+    this.cloudConfig = cloudConfig;\n+    this.vcrMetrics = vcrMetrics;\n+    this.azureMetrics = azureMetrics;\n+    requestAgent = new CloudRequestAgent(cloudConfig, vcrMetrics);\n+  }\n+\n+  /**\n+   * Update newly deleted containers from {@code deletedContainers} to CosmosDb since last checkpoint.\n+   * @param deletedContainers {@link Set} of deleted {@link Container}s.\n+   * @throws CloudStorageException in case of any error.\n+   */\n+  public void updateDeletedContainers(Set<Container> deletedContainers) throws CloudStorageException {", "originalCommit": "bf1bb0d24e5e1568cb2e3fb658a5a820080b0c7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4NjA5Nw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500486097", "bodyText": "I think we don't need this method in the interface as it is a specific case of getContainersByStatus().\nFor sure, the logic about retention days should not be in the interface.", "author": "lightningrob", "createdAt": "2020-10-06T17:50:22Z", "path": "ambry-api/src/main/java/com/github/ambry/account/AccountService.java", "diffHunk": "@@ -122,6 +123,23 @@\n     return selectedContainers;\n   }\n \n+  /**\n+   * @return {@link Set} of {@link Container}s ready for deletion.", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4NjYwNQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500486605", "bodyText": "This change was made in a previous PR.", "author": "lightningrob", "createdAt": "2020-10-06T17:51:13Z", "path": "ambry-api/src/main/java/com/github/ambry/account/Container.java", "diffHunk": "@@ -493,7 +493,7 @@ static Container fromJson(JSONObject json, short parentAccountId) throws JSONExc\n    * @return The metadata of the container.\n    * @throws JSONException If fails to compose metadata.\n    */\n-  JSONObject toJson() throws JSONException {\n+  public JSONObject toJson() throws JSONException {", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4NzE5Ng==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500487196", "bodyText": "Minor: would change deleted to \"deprecated\" or \"inactive\"", "author": "lightningrob", "createdAt": "2020-10-06T17:52:10Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudContainerCompactor.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud;\n+\n+\n+/**\n+ * Class that runs scheduled or on-demand compaction of blobs of deleted containers.", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMDU3OA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501210578", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T18:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4NzE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MTA1Mg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500491052", "bodyText": "It's not obvious what this method does.  I also wonder if this method belongs in the interface, since it seems fairly specific to the Azure impl.", "author": "lightningrob", "createdAt": "2020-10-06T17:58:23Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudDestination.java", "diffHunk": "@@ -137,4 +139,13 @@ boolean retrieveTokens(String partitionPath, String tokenFileName, OutputStream\n    * Halt any compactions in progress.\n    */\n   void stopCompaction();\n+\n+  /**\n+   * Update the deleted {@link Container}s to cloud.\n+   * @param deletedContainers {@link Set} of deleted {@link Container}s.\n+   * @param partitionIds {@link Collection} of cloud partition ids from where the container needs to be deleted.\n+   * @throws {@link CloudStorageException} if updating fails.\n+   */\n+  void updateDeletedContainers(Set<Container> deletedContainers, Collection<String> partitionIds)", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyMzY0Mg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501223642", "bodyText": "I should have named this better. Changed the name and comments. This method deprecates the specified containers for specified partitions in cloud.", "author": "ankagrawal", "createdAt": "2020-10-07T18:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MTA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU3NTQwNw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r502575407", "bodyText": "True, but the fact that the method takes set of partitions points to the Azure implementation that starts with the complete set and then tracks when each one is done.  Maybe you could argue that any implementation would need to do something similar, but I find the second parameter a bit of a code smell.", "author": "lightningrob", "createdAt": "2020-10-09T17:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MTA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY1MDg4Ng==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r502650886", "bodyText": "I have fixed the signatures and implementation to address this concern.", "author": "ankagrawal", "createdAt": "2020-10-09T20:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MTA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MjA1MA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500492050", "bodyText": "The word \"failed\" need to be there either way.", "author": "lightningrob", "createdAt": "2020-10-06T17:59:59Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudRequestAgent.java", "diffHunk": "@@ -55,7 +56,8 @@ public CloudRequestAgent(CloudConfig cloudConfig, VcrMetrics vcrMetrics) {\n     }\n     // Line should never be reached\n     throw new CloudStorageException(\n-        actionName + \" failed partition \" + partitionPath + \" made \" + attempts + \" attempts\");\n+        actionName + (!Utils.isNullOrEmpty(partitionPath) ? (\" failed partition \" + partitionPath) : \"\") + \" made \" + attempts", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyNDM0OA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501224348", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T18:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MjA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5Mzk0OA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500493948", "bodyText": "Please use different variable names to distinguish.", "author": "lightningrob", "createdAt": "2020-10-06T18:03:15Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/ContainerDeletionEntry.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud;\n+\n+import com.github.ambry.account.Container;\n+import com.github.ambry.clustermap.ClusterMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.json.JSONObject;\n+\n+\n+/**\n+ * Class representing container deletion status in cloud.\n+ */\n+public class ContainerDeletionEntry {\n+\n+  static final String VERSION_KEY = \"version\";\n+  static final String CONTAINER_ID_KEY = \"containerId\";\n+  static final String ACCOUNT_ID_KEY = \"accountId\";\n+  static final String CONTAINER_DELETE_TRIGGER_TIME_KEY = \"deleteTriggerTime\";\n+  static final String IS_DELETED_KEY = \"isDeleted\";\n+  static final String DELETE_PENDING_PARTITIONS_KEY = \"deletePendingPartitions\";\n+\n+  private static short JSON_VERSION_1 = 1;\n+\n+  private final short version;\n+  private final short containerId;\n+  private final short accountId;\n+  private final Set<String> deletePendingPartitions;\n+  private final long deleteTriggerTimestamp;\n+  private boolean isDeleted;\n+\n+  /**\n+   * Constructor for {@link ContainerDeletionEntry}.\n+   * @param containerId container id.\n+   * @param accountId account id of the container.\n+   * @param deleteTriggerTimestamp timestamp at which delete was triggered.\n+   */\n+  public ContainerDeletionEntry(short containerId, short accountId, long deleteTriggerTimestamp) {\n+    this.containerId = containerId;\n+    this.accountId = accountId;\n+    this.deleteTriggerTimestamp = deleteTriggerTimestamp;\n+    this.isDeleted = true;\n+    this.deletePendingPartitions = Collections.emptySet();\n+    this.version = JSON_VERSION_1;\n+  }\n+\n+  /**\n+   * Constructor for {@link ContainerDeletionEntry}.\n+   * @param containerId container id.\n+   * @param accountId account id of the container.\n+   * @param deleteTriggerTimestamp timestamp at which delete was triggered.\n+   * @param isDeleted {@code true} if all container blobs are deleted in cloud. {@code false} otherwise.\n+   * @param partitionIds {@link Collection} of all the cloud partition ids from which container is yet to be deleted.\n+   */\n+  public ContainerDeletionEntry(short containerId, short accountId, long deleteTriggerTimestamp, boolean isDeleted,\n+      Collection<String> partitionIds) {\n+    this.version = JSON_VERSION_1;\n+    this.containerId = containerId;\n+    this.accountId = accountId;\n+    this.deleteTriggerTimestamp = deleteTriggerTimestamp;\n+    this.isDeleted = isDeleted;\n+    if (!isDeleted) {\n+      deletePendingPartitions = new HashSet<>();\n+      deletePendingPartitions.addAll(partitionIds);\n+    } else {\n+      deletePendingPartitions = Collections.emptySet();\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for {@link ContainerDeletionEntry}. Used from deserialization.\n+   * @param version deserialized version.\n+   * @param containerId container id.\n+   * @param accountId account id of the container.\n+   * @param deleteTriggerTimestamp timestamp at which delete was triggered.\n+   * @param isDeleted {@code true} if all container blobs are deleted in cloud. {@code false} otherwise.\n+   * @param deletePendingPartitions {@link Collection} of all the cloud partition ids from which container is yet to be deleted.\n+   */\n+  private ContainerDeletionEntry(short version, short containerId, short accountId, long deleteTriggerTimestamp,\n+      boolean isDeleted, Collection<Object> deletePendingPartitions) {\n+    this.version = version;\n+    this.containerId = containerId;\n+    this.accountId = accountId;\n+    this.deleteTriggerTimestamp = deleteTriggerTimestamp;\n+    this.isDeleted = isDeleted;\n+    this.deletePendingPartitions = new HashSet<>();\n+    deletePendingPartitions.forEach(partitionId -> this.deletePendingPartitions.add((String) partitionId));", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyNTQ2OA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501225468", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T18:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5Mzk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NTUyOQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500495529", "bodyText": "If this is Cosmos specific, please move it to the cloud/azure package.", "author": "lightningrob", "createdAt": "2020-10-06T18:05:44Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/ContainerDeletionEntry.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud;\n+\n+import com.github.ambry.account.Container;\n+import com.github.ambry.clustermap.ClusterMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.json.JSONObject;\n+\n+\n+/**\n+ * Class representing container deletion status in cloud.\n+ */\n+public class ContainerDeletionEntry {\n+\n+  static final String VERSION_KEY = \"version\";\n+  static final String CONTAINER_ID_KEY = \"containerId\";\n+  static final String ACCOUNT_ID_KEY = \"accountId\";\n+  static final String CONTAINER_DELETE_TRIGGER_TIME_KEY = \"deleteTriggerTime\";\n+  static final String IS_DELETED_KEY = \"isDeleted\";\n+  static final String DELETE_PENDING_PARTITIONS_KEY = \"deletePendingPartitions\";\n+\n+  private static short JSON_VERSION_1 = 1;\n+\n+  private final short version;\n+  private final short containerId;\n+  private final short accountId;\n+  private final Set<String> deletePendingPartitions;\n+  private final long deleteTriggerTimestamp;\n+  private boolean isDeleted;\n+\n+  /**\n+   * Constructor for {@link ContainerDeletionEntry}.\n+   * @param containerId container id.\n+   * @param accountId account id of the container.\n+   * @param deleteTriggerTimestamp timestamp at which delete was triggered.\n+   */\n+  public ContainerDeletionEntry(short containerId, short accountId, long deleteTriggerTimestamp) {\n+    this.containerId = containerId;\n+    this.accountId = accountId;\n+    this.deleteTriggerTimestamp = deleteTriggerTimestamp;\n+    this.isDeleted = true;\n+    this.deletePendingPartitions = Collections.emptySet();\n+    this.version = JSON_VERSION_1;\n+  }\n+\n+  /**\n+   * Constructor for {@link ContainerDeletionEntry}.\n+   * @param containerId container id.\n+   * @param accountId account id of the container.\n+   * @param deleteTriggerTimestamp timestamp at which delete was triggered.\n+   * @param isDeleted {@code true} if all container blobs are deleted in cloud. {@code false} otherwise.\n+   * @param partitionIds {@link Collection} of all the cloud partition ids from which container is yet to be deleted.\n+   */\n+  public ContainerDeletionEntry(short containerId, short accountId, long deleteTriggerTimestamp, boolean isDeleted,\n+      Collection<String> partitionIds) {\n+    this.version = JSON_VERSION_1;\n+    this.containerId = containerId;\n+    this.accountId = accountId;\n+    this.deleteTriggerTimestamp = deleteTriggerTimestamp;\n+    this.isDeleted = isDeleted;\n+    if (!isDeleted) {\n+      deletePendingPartitions = new HashSet<>();\n+      deletePendingPartitions.addAll(partitionIds);\n+    } else {\n+      deletePendingPartitions = Collections.emptySet();\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for {@link ContainerDeletionEntry}. Used from deserialization.\n+   * @param version deserialized version.\n+   * @param containerId container id.\n+   * @param accountId account id of the container.\n+   * @param deleteTriggerTimestamp timestamp at which delete was triggered.\n+   * @param isDeleted {@code true} if all container blobs are deleted in cloud. {@code false} otherwise.\n+   * @param deletePendingPartitions {@link Collection} of all the cloud partition ids from which container is yet to be deleted.\n+   */\n+  private ContainerDeletionEntry(short version, short containerId, short accountId, long deleteTriggerTimestamp,\n+      boolean isDeleted, Collection<Object> deletePendingPartitions) {\n+    this.version = version;\n+    this.containerId = containerId;\n+    this.accountId = accountId;\n+    this.deleteTriggerTimestamp = deleteTriggerTimestamp;\n+    this.isDeleted = isDeleted;\n+    this.deletePendingPartitions = new HashSet<>();\n+    deletePendingPartitions.forEach(partitionId -> this.deletePendingPartitions.add((String) partitionId));\n+  }\n+\n+  /**\n+   * Create a {@link ContainerDeletionEntry} from specified {@link Container} in specified {@link ClusterMap}.\n+   * @param container {@link Container} from which to create deletion entry.\n+   * @param partitionIds {@link Collection} of partition ids.\n+   * @return {@link ContainerDeletionEntry} object.\n+   */\n+  public static ContainerDeletionEntry fromContainer(Container container, Collection<String> partitionIds) {\n+    return new ContainerDeletionEntry(container.getId(), container.getParentAccountId(),\n+        container.getDeleteTriggerTime(), false, partitionIds);\n+  }\n+\n+  /**\n+   * Create {@link ContainerDeletionEntry} from specified json.\n+   * @param jsonObject {@link JSONObject} representing the serialized {@link ContainerDeletionEntry}.\n+   * @return deserialized {@link ContainerDeletionEntry} object.\n+   */\n+  public static ContainerDeletionEntry fromJson(JSONObject jsonObject) {\n+    return new ContainerDeletionEntry((short) jsonObject.getInt(VERSION_KEY),\n+        (short) jsonObject.getInt(CONTAINER_ID_KEY), (short) jsonObject.getInt(ACCOUNT_ID_KEY),\n+        jsonObject.getLong(CONTAINER_DELETE_TRIGGER_TIME_KEY), jsonObject.getBoolean(IS_DELETED_KEY),\n+        jsonObject.getJSONArray(DELETE_PENDING_PARTITIONS_KEY).toList());\n+  }\n+\n+  /**\n+   * Mark the container as deleted in cloud.\n+   */\n+  public void markDeleted() {\n+    isDeleted = true;\n+  }\n+\n+  /**\n+   * Remove a delete pending partition.\n+   * @param partitionId partition to remove.\n+   */\n+  public void removePartition(String partitionId) {\n+    deletePendingPartitions.remove(partitionId);\n+  }\n+\n+  /**\n+   * @return deletion status of the container.\n+   */\n+  public boolean isDeleted() {\n+    return isDeleted;\n+  }\n+\n+  /**\n+   * @return delete trigger timestamp when the container deletion was triggered by customer.\n+   */\n+  public long getDeleteTriggerTimestamp() {\n+    return deleteTriggerTimestamp;\n+  }\n+\n+  /**\n+   * Serialize {@link Container} object to save to Cosmos.", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyNjIwMQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501226201", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T18:30:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NzExNg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500497116", "bodyText": "This change doesn't add much IMO.  I would move the retention part inside the original loop.", "author": "lightningrob", "createdAt": "2020-10-06T18:08:25Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreCompactor.java", "diffHunk": "@@ -204,16 +202,11 @@ void compact(CompactionDetails details, byte[] bundleReadBuffer) throws IOExcept\n   private void getDeprecatedContainers() {\n     deprecatedContainers.clear();\n     if (accountService != null) {\n-      accountService.getContainersByStatus(Container.ContainerStatus.DELETE_IN_PROGRESS).forEach((container) -> {\n-        if (container.getDeleteTriggerTime() + TimeUnit.DAYS.toMillis(config.storeContainerDeletionRetentionDays)\n-            <= System.currentTimeMillis()) {\n-          deprecatedContainers.add(new Pair<>(container.getParentAccountId(), container.getId()));\n-        }\n-      });\n+      Set<Container> containers = accountService.getDeprecatedContainers(config.storeContainerDeletionRetentionDays);", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1NzA4Ng==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501257086", "bodyText": "This change moves the logic to get deprecated containers from AccountService to a common place so. that it can be reused by multiple callers.", "author": "ankagrawal", "createdAt": "2020-10-07T19:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5NzExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMjY2Nw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500522667", "bodyText": "IMO it's too dangerous to do this as an upsert, since could potentially reset the set of partitions (to the full set) in a container that has already been deleted for some partitions.  If the entry already exist, is there any reason to update it?", "author": "lightningrob", "createdAt": "2020-10-06T18:49:34Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -519,6 +528,24 @@ public String queryChangeFeed(String requestContinuationToken, int maxFeedSize,\n     }\n   }\n \n+  /**\n+   * Add the {@link ContainerDeletionEntry} for newly deleted {@link Container}s to cosmos table.\n+   * @param deletedContainers {@link Set} of deleted {@link ContainerDeletionEntry}s.\n+   * @return the max deletion trigger time of all the added containers to serve as checkpoint for future update.\n+   */\n+  public long updateDeletedContainers(Set<ContainerDeletionEntry> deletedContainers) throws DocumentClientException {\n+    long latestContainerDeletionTimestamp = -1;\n+    for (ContainerDeletionEntry containerDeletionEntry : deletedContainers) {\n+      executeCosmosAction(() -> asyncDocumentClient.upsertDocument(cosmosDeletedContainerCollectionLink,", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2NjQyOQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501266429", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T19:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMjY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMzc5Mw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500523793", "bodyText": "What does this do?", "author": "lightningrob", "createdAt": "2020-10-06T18:51:29Z", "path": "ambry-cloud/src/test/java/com/github/ambry/cloud/azure/AzureContainerCompactorIntegrationTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud.azure;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.Timer;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.account.ContainerBuilder;\n+import com.github.ambry.cloud.CloudDestinationFactory;\n+import com.github.ambry.cloud.CloudStorageException;\n+import com.github.ambry.config.CloudConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.TestUtils;\n+import com.github.ambry.utils.Utils;\n+import com.microsoft.azure.cosmosdb.FeedOptions;\n+import com.microsoft.azure.cosmosdb.SqlQuerySpec;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+\n+@Ignore\n+@RunWith(MockitoJUnitRunner.class)\n+public class AzureContainerCompactorIntegrationTest {\n+\n+  private final Random random = new Random();\n+  private final String PROPS_FILE_NAME = \"azure-test.properties\";\n+  private AzureCloudConfig azureConfig;\n+  private VerifiableProperties verifiableProperties;\n+  private AzureCloudDestination cloudDestination;\n+\n+  @Before\n+  public void setup() throws ReflectiveOperationException {\n+    // TODO Create the required cosmos table as well as the required azure blob.\n+    Properties testProperties = new Properties();\n+    try (InputStream input = this.getClass().getClassLoader().getResourceAsStream(PROPS_FILE_NAME)) {\n+      if (input == null) {\n+        throw new IllegalStateException(\"Could not find resource: \" + PROPS_FILE_NAME);\n+      }\n+      testProperties.load(input);\n+    } catch (IOException ex) {\n+      throw new IllegalStateException(\"Could not load properties from resource: \" + PROPS_FILE_NAME);\n+    }\n+    testProperties.setProperty(\"clustermap.cluster.name\", \"Integration-Test\");\n+    testProperties.setProperty(\"clustermap.datacenter.name\", \"uswest\");\n+    testProperties.setProperty(\"clustermap.host.name\", \"localhost\");\n+    testProperties.setProperty(\"kms.default.container.key\",\n+        \"B374A26A71490437AA024E4FADD5B497FDFF1A8EA6FF12F6FB65AF2720B59CCF\");\n+\n+    testProperties.setProperty(CloudConfig.CLOUD_DELETED_BLOB_RETENTION_DAYS, String.valueOf(1));\n+    testProperties.setProperty(AzureCloudConfig.AZURE_PURGE_BATCH_SIZE, \"10\");\n+    verifiableProperties = new VerifiableProperties(testProperties);\n+    CloudConfig cloudConfig = new CloudConfig(verifiableProperties);\n+    this.azureConfig = new AzureCloudConfig(verifiableProperties);\n+    MetricRegistry registry = new MetricRegistry();\n+    CloudDestinationFactory cloudDestinationFactory =\n+        Utils.getObj(cloudConfig.cloudDestinationFactoryClass, verifiableProperties, registry);\n+    cloudDestination = (AzureCloudDestination) cloudDestinationFactory.getCloudDestination();\n+  }\n+\n+  @After\n+  public void destroy() throws IOException {\n+    // TODO destroy the abs blob and cosmos db\n+    if (cloudDestination != null) {\n+      cloudDestination.close();\n+    }\n+  }\n+\n+  @Test\n+  public void testUpdateDeletedContainer() throws CloudStorageException {\n+    Set<Container> containers = generateContainers(5);\n+    cloudDestination.updateDeletedContainers(containers, null);\n+    verifyCosmosData(containers);\n+    verifyCheckpoint(containers);\n+  }\n+\n+  private void verifyCosmosData(Set<Container> containers) {", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1ODkwNQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501258905", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T19:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMzc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNDE4NA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500524184", "bodyText": "Please add TODO lines for incomplete methods.", "author": "lightningrob", "createdAt": "2020-10-06T18:52:11Z", "path": "ambry-cloud/src/test/java/com/github/ambry/cloud/azure/AzureContainerCompactorIntegrationTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud.azure;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.Timer;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.account.ContainerBuilder;\n+import com.github.ambry.cloud.CloudDestinationFactory;\n+import com.github.ambry.cloud.CloudStorageException;\n+import com.github.ambry.config.CloudConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.TestUtils;\n+import com.github.ambry.utils.Utils;\n+import com.microsoft.azure.cosmosdb.FeedOptions;\n+import com.microsoft.azure.cosmosdb.SqlQuerySpec;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+\n+@Ignore\n+@RunWith(MockitoJUnitRunner.class)\n+public class AzureContainerCompactorIntegrationTest {\n+\n+  private final Random random = new Random();\n+  private final String PROPS_FILE_NAME = \"azure-test.properties\";\n+  private AzureCloudConfig azureConfig;\n+  private VerifiableProperties verifiableProperties;\n+  private AzureCloudDestination cloudDestination;\n+\n+  @Before\n+  public void setup() throws ReflectiveOperationException {\n+    // TODO Create the required cosmos table as well as the required azure blob.\n+    Properties testProperties = new Properties();\n+    try (InputStream input = this.getClass().getClassLoader().getResourceAsStream(PROPS_FILE_NAME)) {\n+      if (input == null) {\n+        throw new IllegalStateException(\"Could not find resource: \" + PROPS_FILE_NAME);\n+      }\n+      testProperties.load(input);\n+    } catch (IOException ex) {\n+      throw new IllegalStateException(\"Could not load properties from resource: \" + PROPS_FILE_NAME);\n+    }\n+    testProperties.setProperty(\"clustermap.cluster.name\", \"Integration-Test\");\n+    testProperties.setProperty(\"clustermap.datacenter.name\", \"uswest\");\n+    testProperties.setProperty(\"clustermap.host.name\", \"localhost\");\n+    testProperties.setProperty(\"kms.default.container.key\",\n+        \"B374A26A71490437AA024E4FADD5B497FDFF1A8EA6FF12F6FB65AF2720B59CCF\");\n+\n+    testProperties.setProperty(CloudConfig.CLOUD_DELETED_BLOB_RETENTION_DAYS, String.valueOf(1));\n+    testProperties.setProperty(AzureCloudConfig.AZURE_PURGE_BATCH_SIZE, \"10\");\n+    verifiableProperties = new VerifiableProperties(testProperties);\n+    CloudConfig cloudConfig = new CloudConfig(verifiableProperties);\n+    this.azureConfig = new AzureCloudConfig(verifiableProperties);\n+    MetricRegistry registry = new MetricRegistry();\n+    CloudDestinationFactory cloudDestinationFactory =\n+        Utils.getObj(cloudConfig.cloudDestinationFactoryClass, verifiableProperties, registry);\n+    cloudDestination = (AzureCloudDestination) cloudDestinationFactory.getCloudDestination();\n+  }\n+\n+  @After\n+  public void destroy() throws IOException {\n+    // TODO destroy the abs blob and cosmos db\n+    if (cloudDestination != null) {\n+      cloudDestination.close();\n+    }\n+  }\n+\n+  @Test\n+  public void testUpdateDeletedContainer() throws CloudStorageException {\n+    Set<Container> containers = generateContainers(5);\n+    cloudDestination.updateDeletedContainers(containers, null);\n+    verifyCosmosData(containers);\n+    verifyCheckpoint(containers);\n+  }\n+\n+  private void verifyCosmosData(Set<Container> containers) {\n+    String query = \"SELECT VALUE COUNT(1) FROM C\";\n+    SqlQuerySpec querySpec = new SqlQuerySpec(query);\n+    Timer timer = new Timer();\n+    cloudDestination.getCosmosDataAccessor()\n+        .executeCosmosQuery(azureConfig.cosmosDeletedContainerCollectionLink, null, querySpec, new FeedOptions(),\n+            timer);\n+  }\n+\n+  private void verifyCheckpoint(Set<Container> containers) {\n+", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1ODc5MA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501258790", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T19:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNDE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNTk0NQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500525945", "bodyText": "Please add TODO lines for incomplete methods.", "author": "lightningrob", "createdAt": "2020-10-06T18:55:18Z", "path": "ambry-cloud/src/test/java/com/github/ambry/cloud/azure/AzureContainerCompactorIntegrationTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud.azure;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.Timer;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.account.ContainerBuilder;\n+import com.github.ambry.cloud.CloudDestinationFactory;\n+import com.github.ambry.cloud.CloudStorageException;\n+import com.github.ambry.config.CloudConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.TestUtils;\n+import com.github.ambry.utils.Utils;\n+import com.microsoft.azure.cosmosdb.FeedOptions;\n+import com.microsoft.azure.cosmosdb.SqlQuerySpec;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+\n+@Ignore\n+@RunWith(MockitoJUnitRunner.class)\n+public class AzureContainerCompactorIntegrationTest {\n+\n+  private final Random random = new Random();\n+  private final String PROPS_FILE_NAME = \"azure-test.properties\";\n+  private AzureCloudConfig azureConfig;\n+  private VerifiableProperties verifiableProperties;\n+  private AzureCloudDestination cloudDestination;\n+\n+  @Before\n+  public void setup() throws ReflectiveOperationException {\n+    // TODO Create the required cosmos table as well as the required azure blob.\n+    Properties testProperties = new Properties();\n+    try (InputStream input = this.getClass().getClassLoader().getResourceAsStream(PROPS_FILE_NAME)) {\n+      if (input == null) {\n+        throw new IllegalStateException(\"Could not find resource: \" + PROPS_FILE_NAME);\n+      }\n+      testProperties.load(input);\n+    } catch (IOException ex) {\n+      throw new IllegalStateException(\"Could not load properties from resource: \" + PROPS_FILE_NAME);\n+    }\n+    testProperties.setProperty(\"clustermap.cluster.name\", \"Integration-Test\");\n+    testProperties.setProperty(\"clustermap.datacenter.name\", \"uswest\");\n+    testProperties.setProperty(\"clustermap.host.name\", \"localhost\");\n+    testProperties.setProperty(\"kms.default.container.key\",\n+        \"B374A26A71490437AA024E4FADD5B497FDFF1A8EA6FF12F6FB65AF2720B59CCF\");\n+\n+    testProperties.setProperty(CloudConfig.CLOUD_DELETED_BLOB_RETENTION_DAYS, String.valueOf(1));\n+    testProperties.setProperty(AzureCloudConfig.AZURE_PURGE_BATCH_SIZE, \"10\");\n+    verifiableProperties = new VerifiableProperties(testProperties);\n+    CloudConfig cloudConfig = new CloudConfig(verifiableProperties);\n+    this.azureConfig = new AzureCloudConfig(verifiableProperties);\n+    MetricRegistry registry = new MetricRegistry();\n+    CloudDestinationFactory cloudDestinationFactory =\n+        Utils.getObj(cloudConfig.cloudDestinationFactoryClass, verifiableProperties, registry);\n+    cloudDestination = (AzureCloudDestination) cloudDestinationFactory.getCloudDestination();\n+  }\n+\n+  @After\n+  public void destroy() throws IOException {\n+    // TODO destroy the abs blob and cosmos db\n+    if (cloudDestination != null) {\n+      cloudDestination.close();\n+    }\n+  }\n+\n+  @Test\n+  public void testUpdateDeletedContainer() throws CloudStorageException {\n+    Set<Container> containers = generateContainers(5);\n+    cloudDestination.updateDeletedContainers(containers, null);\n+    verifyCosmosData(containers);\n+    verifyCheckpoint(containers);\n+  }\n+\n+  private void verifyCosmosData(Set<Container> containers) {\n+    String query = \"SELECT VALUE COUNT(1) FROM C\";\n+    SqlQuerySpec querySpec = new SqlQuerySpec(query);\n+    Timer timer = new Timer();\n+    cloudDestination.getCosmosDataAccessor()\n+        .executeCosmosQuery(azureConfig.cosmosDeletedContainerCollectionLink, null, querySpec, new FeedOptions(),\n+            timer);\n+  }\n+\n+  private void verifyCheckpoint(Set<Container> containers) {\n+", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1ODg2NA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501258864", "bodyText": "fixed.", "author": "ankagrawal", "createdAt": "2020-10-07T19:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNTk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzMjE0MQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500532141", "bodyText": "Please move the logic to generate a random container to AccountTestUtils.\nThis code looks copied from AccountContainerTest.initializeRefContainers.", "author": "lightningrob", "createdAt": "2020-10-06T19:06:22Z", "path": "ambry-cloud/src/test/java/com/github/ambry/cloud/azure/AzureContainerCompactorIntegrationTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud.azure;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.Timer;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.account.ContainerBuilder;\n+import com.github.ambry.cloud.CloudDestinationFactory;\n+import com.github.ambry.cloud.CloudStorageException;\n+import com.github.ambry.config.CloudConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.utils.TestUtils;\n+import com.github.ambry.utils.Utils;\n+import com.microsoft.azure.cosmosdb.FeedOptions;\n+import com.microsoft.azure.cosmosdb.SqlQuerySpec;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+\n+@Ignore\n+@RunWith(MockitoJUnitRunner.class)\n+public class AzureContainerCompactorIntegrationTest {\n+\n+  private final Random random = new Random();\n+  private final String PROPS_FILE_NAME = \"azure-test.properties\";\n+  private AzureCloudConfig azureConfig;\n+  private VerifiableProperties verifiableProperties;\n+  private AzureCloudDestination cloudDestination;\n+\n+  @Before\n+  public void setup() throws ReflectiveOperationException {\n+    // TODO Create the required cosmos table as well as the required azure blob.\n+    Properties testProperties = new Properties();\n+    try (InputStream input = this.getClass().getClassLoader().getResourceAsStream(PROPS_FILE_NAME)) {\n+      if (input == null) {\n+        throw new IllegalStateException(\"Could not find resource: \" + PROPS_FILE_NAME);\n+      }\n+      testProperties.load(input);\n+    } catch (IOException ex) {\n+      throw new IllegalStateException(\"Could not load properties from resource: \" + PROPS_FILE_NAME);\n+    }\n+    testProperties.setProperty(\"clustermap.cluster.name\", \"Integration-Test\");\n+    testProperties.setProperty(\"clustermap.datacenter.name\", \"uswest\");\n+    testProperties.setProperty(\"clustermap.host.name\", \"localhost\");\n+    testProperties.setProperty(\"kms.default.container.key\",\n+        \"B374A26A71490437AA024E4FADD5B497FDFF1A8EA6FF12F6FB65AF2720B59CCF\");\n+\n+    testProperties.setProperty(CloudConfig.CLOUD_DELETED_BLOB_RETENTION_DAYS, String.valueOf(1));\n+    testProperties.setProperty(AzureCloudConfig.AZURE_PURGE_BATCH_SIZE, \"10\");\n+    verifiableProperties = new VerifiableProperties(testProperties);\n+    CloudConfig cloudConfig = new CloudConfig(verifiableProperties);\n+    this.azureConfig = new AzureCloudConfig(verifiableProperties);\n+    MetricRegistry registry = new MetricRegistry();\n+    CloudDestinationFactory cloudDestinationFactory =\n+        Utils.getObj(cloudConfig.cloudDestinationFactoryClass, verifiableProperties, registry);\n+    cloudDestination = (AzureCloudDestination) cloudDestinationFactory.getCloudDestination();\n+  }\n+\n+  @After\n+  public void destroy() throws IOException {\n+    // TODO destroy the abs blob and cosmos db\n+    if (cloudDestination != null) {\n+      cloudDestination.close();\n+    }\n+  }\n+\n+  @Test\n+  public void testUpdateDeletedContainer() throws CloudStorageException {\n+    Set<Container> containers = generateContainers(5);\n+    cloudDestination.updateDeletedContainers(containers, null);\n+    verifyCosmosData(containers);\n+    verifyCheckpoint(containers);\n+  }\n+\n+  private void verifyCosmosData(Set<Container> containers) {\n+    String query = \"SELECT VALUE COUNT(1) FROM C\";\n+    SqlQuerySpec querySpec = new SqlQuerySpec(query);\n+    Timer timer = new Timer();\n+    cloudDestination.getCosmosDataAccessor()\n+        .executeCosmosQuery(azureConfig.cosmosDeletedContainerCollectionLink, null, querySpec, new FeedOptions(),\n+            timer);\n+  }\n+\n+  private void verifyCheckpoint(Set<Container> containers) {\n+\n+  }\n+\n+  /**\n+   * Generate specified number of {@link Container}s.\n+   * @param numContainers number of {@link Container}s to generate.\n+   * @return {@link Set} of {@link Container}s.\n+   */\n+  private Set<Container> generateContainers(int numContainers) {", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1OTEwMw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501259103", "bodyText": "will do.. this class is work in progress right now.", "author": "ankagrawal", "createdAt": "2020-10-07T19:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzMjE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY1MTExNg==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r502651116", "bodyText": "this is fixed now.", "author": "ankagrawal", "createdAt": "2020-10-09T20:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzMjE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzNDI1OA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r500534258", "bodyText": "This task, like the updateDeletedContainers() methods, seems fairly specific to the Azure/Cosmos impl.  Can we move this to the cloud/azure package (make it Azure only), remove the method from CloudDestination interface, and call the method directly on the AzureContainerCompactor?", "author": "lightningrob", "createdAt": "2020-10-06T19:10:17Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudContainerDeletionSyncTask.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud;\n+\n+import com.github.ambry.account.AccountService;\n+import com.github.ambry.account.Container;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.helix.task.Task;\n+import org.apache.helix.task.TaskResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Helix task to get the deleted containers information from {@link com.github.ambry.account.AccountService} and update\n+ * it in CosmosDb DeleteContainers table.\n+ */\n+public class CloudContainerDeletionSyncTask implements Task {", "originalCommit": "572c1e21f5d50d9cb98d4f9c2cbf0570e55d435d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMjgzMw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501212833", "bodyText": "The intention of this class is not cloud implementation specific. The intention is to keep the cloud and account service in sync with regards to deprecated container information. As such this class just periodically takes the deprecated containers from account service and updates it to cloud, without any consideration about what cloud implementation it is.\nEach cloud implementation can then implement CloudDestination.updateDeletedContainers()  to decide what to do with the newly deprecated containers and how and where to store them.\nLet me know what do you think about this.", "author": "ankagrawal", "createdAt": "2020-10-07T18:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzNDI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMzUxMA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r501213510", "bodyText": "I see that my comments for the class were misleading. I have fixed that. Have also renamed the class as an attempt to better clarify the purpose.", "author": "ankagrawal", "createdAt": "2020-10-07T18:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzNDI1OA=="}], "type": "inlineReview"}, {"oid": "ed918f26115eba93394c1b651dafb88f70d7517d", "url": "https://github.com/linkedin/ambry/commit/ed918f26115eba93394c1b651dafb88f70d7517d", "message": "Initial implementation of Helix task to sync deleted containers between cloud and helix account service.", "committedDate": "2020-10-07T20:11:21Z", "type": "commit"}, {"oid": "53d2651cc5c777c43bfb60c681a44b397fb1f319", "url": "https://github.com/linkedin/ambry/commit/53d2651cc5c777c43bfb60c681a44b397fb1f319", "message": "Fix tests and cleanup.", "committedDate": "2020-10-07T20:11:55Z", "type": "commit"}, {"oid": "b4dba5e7d4fa7adfcacf282c25afb3ba42d0a82b", "url": "https://github.com/linkedin/ambry/commit/b4dba5e7d4fa7adfcacf282c25afb3ba42d0a82b", "message": "Fix BlobStoreCompactorTest", "committedDate": "2020-10-07T20:11:58Z", "type": "commit"}, {"oid": "4c7bfcfa9061e250ebd27e4581a9b0aa2060e80b", "url": "https://github.com/linkedin/ambry/commit/4c7bfcfa9061e250ebd27e4581a9b0aa2060e80b", "message": "Add unit tests", "committedDate": "2020-10-07T20:11:58Z", "type": "commit"}, {"oid": "f9b33eb2dd253b653b3f0c0a977bb8ff5b764fee", "url": "https://github.com/linkedin/ambry/commit/f9b33eb2dd253b653b3f0c0a977bb8ff5b764fee", "message": "Integration test (WIP)", "committedDate": "2020-10-07T20:11:58Z", "type": "commit"}, {"oid": "f1f29f224b314dc904d4a9314780cabfb5425614", "url": "https://github.com/linkedin/ambry/commit/f1f29f224b314dc904d4a9314780cabfb5425614", "message": "Save ContainerDeletionEntry for deleted containers in cloud.", "committedDate": "2020-10-07T20:11:58Z", "type": "commit"}, {"oid": "f13b8c513f9c6bdd655d2a6cc237c62ce2c12065", "url": "https://github.com/linkedin/ambry/commit/f13b8c513f9c6bdd655d2a6cc237c62ce2c12065", "message": "Fix tests", "committedDate": "2020-10-07T20:11:58Z", "type": "commit"}, {"oid": "1fd6b609a8f049936d0f7ec39b5523e16fd4b750", "url": "https://github.com/linkedin/ambry/commit/1fd6b609a8f049936d0f7ec39b5523e16fd4b750", "message": "Address review comments.", "committedDate": "2020-10-07T20:11:58Z", "type": "commit"}, {"oid": "1fd6b609a8f049936d0f7ec39b5523e16fd4b750", "url": "https://github.com/linkedin/ambry/commit/1fd6b609a8f049936d0f7ec39b5523e16fd4b750", "message": "Address review comments.", "committedDate": "2020-10-07T20:11:58Z", "type": "forcePushed"}, {"oid": "7e593ce817638c890575201931404b0053e94d4c", "url": "https://github.com/linkedin/ambry/commit/7e593ce817638c890575201931404b0053e94d4c", "message": "cleanup", "committedDate": "2020-10-07T20:34:55Z", "type": "commit"}, {"oid": "125d7ca858c6a277a37a0fdd6a203d7688549f07", "url": "https://github.com/linkedin/ambry/commit/125d7ca858c6a277a37a0fdd6a203d7688549f07", "message": "Add integration test", "committedDate": "2020-10-08T16:51:33Z", "type": "commit"}, {"oid": "b1b1a37ad3ef62e03c512d9ce8def77b56d12b8b", "url": "https://github.com/linkedin/ambry/commit/b1b1a37ad3ef62e03c512d9ce8def77b56d12b8b", "message": "fix tests", "committedDate": "2020-10-08T17:27:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxODY3Nw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r502018677", "bodyText": "Minor: Let's use Collection instead of Set for accounts/updateContainers to make it more general.", "author": "jsjtzyy", "createdAt": "2020-10-08T21:19:12Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudDestination.java", "diffHunk": "@@ -137,4 +139,13 @@ boolean retrieveTokens(String partitionPath, String tokenFileName, OutputStream\n    * Halt any compactions in progress.\n    */\n   void stopCompaction();\n+\n+  /**\n+   * Deprecate the specified {@link Container}s for specified partitions in cloud.\n+   * @param deprecatedContainers {@link Set} of deprecated {@link Container}s.\n+   * @param partitionIds {@link Collection} of cloud partition ids from where the container needs to be deprecated.\n+   * @throws {@link CloudStorageException} if updating fails.\n+   */\n+  void deprecateContainers(Set<Container> deprecatedContainers, Collection<String> partitionIds)", "originalCommit": "b1b1a37ad3ef62e03c512d9ce8def77b56d12b8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyMTM3Mw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r502021373", "bodyText": "Also, I wonder in which case the partitionIds don't equal to allPartitionIds? I am thinking if we can remove the partitionIds because container-to-partitions mapping is not clear to me.\n(Maybe it's not easy but I am trying to say the partitions might be passed into cloudDestination class, not in this method)", "author": "jsjtzyy", "createdAt": "2020-10-08T21:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxODY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU0NDg5OQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r502544899", "bodyText": "I had actually explored both the things that you have mentioned.\nThe reason I didn't go with Collections is that we would want a Set because it would be good to not have duplicates in the list of deprecatedContainers. Getting a non-duplicate list would mean that CloudDestination doesn't have to do any work to remove any duplicates.\nAbout the second comment, you are right that in production there is no scenario where partitionIds is not equal to allPartitionIds. Sure I can move the partitionIds to CloudDestination, the reason I didn't was because I didn't want to bring clustermap related logic to CloudDestination.\nI do not have any particular reservations about both the changes so I will go ahead and make the changes if you want.", "author": "ankagrawal", "createdAt": "2020-10-09T16:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxODY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyNTgyMQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r502025821", "bodyText": "Can you point me to the correct CloudDestinationFactory class whose constructor takes in clusterMap?  I didn't find one. Is it AzureCloudDestinationFactory?", "author": "jsjtzyy", "createdAt": "2020-10-08T21:34:38Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/VcrServer.java", "diffHunk": "@@ -131,14 +133,21 @@ public void startup() throws InstantiationException {\n       // verify the configs\n       properties.verify();\n \n-      virtualReplicatorCluster =\n-          ((VirtualReplicatorClusterFactory) Utils.getObj(cloudConfig.virtualReplicatorClusterFactoryClass, cloudConfig,\n-              clusterMapConfig, clusterMap)).getVirtualReplicatorCluster();\n-\n       // initialize cloud destination\n       if (cloudDestinationFactory == null) {\n-        cloudDestinationFactory = Utils.getObj(cloudConfig.cloudDestinationFactoryClass, properties, registry);\n+        cloudDestinationFactory = Utils.getObj(cloudConfig.cloudDestinationFactoryClass, properties, registry, clusterMap);", "originalCommit": "b1b1a37ad3ef62e03c512d9ce8def77b56d12b8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31442edb6e5c26bf3688eb449d9ba3a30bf864db", "url": "https://github.com/linkedin/ambry/commit/31442edb6e5c26bf3688eb449d9ba3a30bf864db", "message": "Fix import in AccountUpdateToolTest.", "committedDate": "2020-10-09T05:20:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU3NzQzOA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r502577438", "bodyText": "Class isn't referenced anywhere.", "author": "lightningrob", "createdAt": "2020-10-09T17:33:34Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/CloudContainerCompactor.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud;\n+\n+\n+/**\n+ * Class that runs scheduled or on-demand compaction of blobs of deprecated containers.\n+ */\n+public class CloudContainerCompactor {\n+", "originalCommit": "31442edb6e5c26bf3688eb449d9ba3a30bf864db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY0OTQ2Mw==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r502649463", "bodyText": "It was going to be reference in the next PR, but have removed it for now.", "author": "ankagrawal", "createdAt": "2020-10-09T20:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU3NzQzOA=="}], "type": "inlineReview"}, {"oid": "02c03f66d75b937b999eda52a08068a245a13268", "url": "https://github.com/linkedin/ambry/commit/02c03f66d75b937b999eda52a08068a245a13268", "message": "Address review comments.", "committedDate": "2020-10-09T19:57:34Z", "type": "commit"}, {"oid": "f8a6fb09868512881d527bf797c59be4c6455bb6", "url": "https://github.com/linkedin/ambry/commit/f8a6fb09868512881d527bf797c59be4c6455bb6", "message": "cleanup", "committedDate": "2020-10-09T20:00:16Z", "type": "commit"}, {"oid": "556ac6cd5593d8453c73dcf1d430a93b86b74ccd", "url": "https://github.com/linkedin/ambry/commit/556ac6cd5593d8453c73dcf1d430a93b86b74ccd", "message": "Remove unused class", "committedDate": "2020-10-09T20:28:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxOTc5NA==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r503519794", "bodyText": "Where is this method used?  If this will be used in future PR, try to re-use the other ctor to remove duplicate code:\n  public ContainerDeletionEntry(short containerId, short accountId, long deleteTriggerTimestamp) {\n    this(containerId, accountId, deleteTriggerTimestamp, true, Collections.emptyList());\n  }", "author": "jsjtzyy", "createdAt": "2020-10-12T20:36:02Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/ContainerDeletionEntry.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud.azure;\n+\n+import com.github.ambry.account.Container;\n+import com.github.ambry.clustermap.ClusterMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.json.JSONObject;\n+\n+\n+/**\n+ * Class representing container deletion status in cloud.\n+ */\n+public class ContainerDeletionEntry {\n+\n+  static final String VERSION_KEY = \"version\";\n+  static final String CONTAINER_ID_KEY = \"containerId\";\n+  static final String ACCOUNT_ID_KEY = \"accountId\";\n+  static final String CONTAINER_DELETE_TRIGGER_TIME_KEY = \"deleteTriggerTime\";\n+  static final String IS_DELETED_KEY = \"isDeleted\";\n+  static final String DELETE_PENDING_PARTITIONS_KEY = \"deletePendingPartitions\";\n+\n+  private static short JSON_VERSION_1 = 1;\n+\n+  private final short version;\n+  private final short containerId;\n+  private final short accountId;\n+  private final Set<String> deletePendingPartitions;\n+  private final long deleteTriggerTimestamp;\n+  private boolean isDeleted;\n+\n+  /**\n+   * Constructor for {@link ContainerDeletionEntry}.\n+   * @param containerId container id.\n+   * @param accountId account id of the container.\n+   * @param deleteTriggerTimestamp timestamp at which delete was triggered.\n+   */\n+  public ContainerDeletionEntry(short containerId, short accountId, long deleteTriggerTimestamp) {", "originalCommit": "556ac6cd5593d8453c73dcf1d430a93b86b74ccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUyMDgyOQ==", "url": "https://github.com/linkedin/ambry/pull/1632#discussion_r503520829", "bodyText": "nit: according to this java doc, I think we can rename isDeleted to allBlobsDeleted to make it more accurate and descriptive.", "author": "jsjtzyy", "createdAt": "2020-10-12T20:39:05Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/ContainerDeletionEntry.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/**\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.cloud.azure;\n+\n+import com.github.ambry.account.Container;\n+import com.github.ambry.clustermap.ClusterMap;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.json.JSONObject;\n+\n+\n+/**\n+ * Class representing container deletion status in cloud.\n+ */\n+public class ContainerDeletionEntry {\n+\n+  static final String VERSION_KEY = \"version\";\n+  static final String CONTAINER_ID_KEY = \"containerId\";\n+  static final String ACCOUNT_ID_KEY = \"accountId\";\n+  static final String CONTAINER_DELETE_TRIGGER_TIME_KEY = \"deleteTriggerTime\";\n+  static final String IS_DELETED_KEY = \"isDeleted\";\n+  static final String DELETE_PENDING_PARTITIONS_KEY = \"deletePendingPartitions\";\n+\n+  private static short JSON_VERSION_1 = 1;\n+\n+  private final short version;\n+  private final short containerId;\n+  private final short accountId;\n+  private final Set<String> deletePendingPartitions;\n+  private final long deleteTriggerTimestamp;\n+  private boolean isDeleted;\n+\n+  /**\n+   * Constructor for {@link ContainerDeletionEntry}.\n+   * @param containerId container id.\n+   * @param accountId account id of the container.\n+   * @param deleteTriggerTimestamp timestamp at which delete was triggered.\n+   */\n+  public ContainerDeletionEntry(short containerId, short accountId, long deleteTriggerTimestamp) {\n+    this.containerId = containerId;\n+    this.accountId = accountId;\n+    this.deleteTriggerTimestamp = deleteTriggerTimestamp;\n+    this.isDeleted = true;\n+    this.deletePendingPartitions = Collections.emptySet();\n+    this.version = JSON_VERSION_1;\n+  }\n+\n+  /**\n+   * Constructor for {@link ContainerDeletionEntry}.\n+   * @param containerId container id.\n+   * @param accountId account id of the container.\n+   * @param deleteTriggerTimestamp timestamp at which delete was triggered.\n+   * @param isDeleted {@code true} if all container blobs are deleted in cloud. {@code false} otherwise.", "originalCommit": "556ac6cd5593d8453c73dcf1d430a93b86b74ccd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1fde4de868da57065c977fa9adb86f5e63181ddc", "url": "https://github.com/linkedin/ambry/commit/1fde4de868da57065c977fa9adb86f5e63181ddc", "message": "fix tests", "committedDate": "2020-10-12T21:34:22Z", "type": "commit"}, {"oid": "c4354561735d50c8058965d4a45d4188a1e5aaaa", "url": "https://github.com/linkedin/ambry/commit/c4354561735d50c8058965d4a45d4188a1e5aaaa", "message": "Move getDeprecatedContainers to AccountUtils", "committedDate": "2020-10-12T22:29:50Z", "type": "commit"}, {"oid": "cb687b53aa34b0af80125efa783eb332aa963c2b", "url": "https://github.com/linkedin/ambry/commit/cb687b53aa34b0af80125efa783eb332aa963c2b", "message": "Fix tests", "committedDate": "2020-10-12T23:36:30Z", "type": "commit"}, {"oid": "2f10ef64fbdd3d3b6ba55bfeb9ff513b653932f3", "url": "https://github.com/linkedin/ambry/commit/2f10ef64fbdd3d3b6ba55bfeb9ff513b653932f3", "message": "Fix test", "committedDate": "2020-10-13T16:10:39Z", "type": "commit"}]}