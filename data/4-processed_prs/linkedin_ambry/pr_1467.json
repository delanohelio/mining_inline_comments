{"pr_number": 1467, "pr_title": "Add skeleton for router to support undelete", "pr_createdAt": "2020-04-09T16:24:36Z", "pr_url": "https://github.com/linkedin/ambry/pull/1467", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMzUzMA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406623530", "bodyText": "Java Doc", "author": "zzmao", "createdAt": "2020-04-10T06:33:37Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -287,6 +287,30 @@ private OperationController getOperationController() {\n     return futureResult;\n   }\n \n+  @Override\n+  public Future<Void> undeleteBlob(String blobId, String serviceId, Callback<Void> callback) {", "originalCommit": "56586050df9da58b9ae55c58deba855cd6b5af80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDA5Nw==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406624097", "bodyText": "???\nLooks like the implementation is also for GET?", "author": "zzmao", "createdAt": "2020-04-10T06:35:50Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +746,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob", "originalCommit": "56586050df9da58b9ae55c58deba855cd6b5af80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3OTg2MA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406879860", "bodyText": "well, I have to do a GET to fetch all the blob ids for this blob if it's a composite blob.", "author": "justinlin-linkedin", "createdAt": "2020-04-10T18:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDk5MQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406624991", "bodyText": "Based on my recent experience, default may cause some test issues because it brings in a default implementation. Prefer to have same interface as updateBlobTtl .", "author": "zzmao", "createdAt": "2020-04-10T06:39:07Z", "path": "ambry-api/src/main/java/com/github/ambry/router/Router.java", "diffHunk": "@@ -88,6 +88,22 @@\n    */\n   Future<Void> updateBlobTtl(String blobId, String serviceId, long expiresAtMs, Callback<Void> callback);\n \n+  /**\n+   * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+   * @param blobId The ID of the blob that needs to be undeleted.\n+   * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+   * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+   * @return A future that would contain information about whether the undelete succeeded or not, eventually.\n+   */\n+  default Future<Void> undeleteBlob(String blobId, String serviceId, Callback<Void> callback) {", "originalCommit": "56586050df9da58b9ae55c58deba855cd6b5af80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3OTkzNw==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r406879937", "bodyText": "I can remove it.", "author": "justinlin-linkedin", "createdAt": "2020-04-10T18:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNDk5MQ=="}], "type": "inlineReview"}, {"oid": "eb0e436fe160467c36ad52254d568602ae811fee", "url": "https://github.com/linkedin/ambry/commit/eb0e436fe160467c36ad52254d568602ae811fee", "message": "Remove default implmentation of undeleteBlob", "committedDate": "2020-04-10T18:30:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1ODk1OQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411658959", "bodyText": "completeUpdateBlobUndeleteOperation", "author": "zzmao", "createdAt": "2020-04-20T20:10:20Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "originalCommit": "eb0e436fe160467c36ad52254d568602ae811fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MjM1Ng==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411682356", "bodyText": "good catch.", "author": "justinlin-linkedin", "createdAt": "2020-04-20T20:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1ODk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA1MA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411660050", "bodyText": "The code looks like similar to updateBlobTtl. Is it possible to unify them?", "author": "zzmao", "createdAt": "2020-04-20T20:12:15Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,", "originalCommit": "eb0e436fe160467c36ad52254d568602ae811fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzAwNQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411683005", "bodyText": "I've tried to reuse most of them. The tricky. part is about those metrics and compete methods. I suppose there is way to reuse them but it seems not really necessary.", "author": "justinlin-linkedin", "createdAt": "2020-04-20T20:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2OTczMw==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411769733", "bodyText": "The code looks like similar to updateBlobTtl. Is it possible to unify them?\n\nI made some new change, will this make you happy?", "author": "justinlin-linkedin", "createdAt": "2020-04-20T23:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDg4OA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411660888", "bodyText": "Tracks callbacks for update operations(TtlUpdate, Undelete)....", "author": "zzmao", "createdAt": "2020-04-20T20:13:47Z", "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob", "originalCommit": "eb0e436fe160467c36ad52254d568602ae811fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzA1OQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411683059", "bodyText": "updated.", "author": "justinlin-linkedin", "createdAt": "2020-04-20T20:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg2NDUxOQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r409864519", "bodyText": "minor: there is no Callback to be invoked. Rephrase this comment please.", "author": "jsjtzyy", "createdAt": "2020-04-16T21:39:55Z", "path": "ambry-api/src/main/java/com/github/ambry/router/Router.java", "diffHunk": "@@ -167,4 +176,14 @@\n   default Future<Void> updateBlobTtl(String blobId, String serviceId, long expiresAtMs) {\n     return updateBlobTtl(blobId, serviceId, expiresAtMs, null);\n   }\n+\n+  /**\n+   * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.", "originalCommit": "eb0e436fe160467c36ad52254d568602ae811fee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg2NTU1Nw==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r409865557", "bodyText": "nit: format this file", "author": "jsjtzyy", "createdAt": "2020-04-16T21:42:13Z", "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob\n+ */\n+class BatchOperationCallbackTracker {\n+  static final FutureResult<Void> DUMMY_FUTURE = new FutureResult<>();\n+\n+  private final FutureResult<Void> futureResult;\n+  private final Callback<Void> callback;\n+  private final long numBlobIds;\n+  private final ConcurrentMap<BlobId, Boolean> blobIdToAck = new ConcurrentHashMap<>();\n+  private final AtomicLong ackedCount = new AtomicLong(0);\n+  private final AtomicBoolean completed = new AtomicBoolean(false);\n+\n+  /**\n+   * Constructor\n+   * @param blobIds the {@link BlobId}s being tracked\n+   * @param futureResult the {@link FutureResult} to be triggered once acks are received for all blobs\n+   * @param callback the {@link Callback} to be triggered once acks are received for all blobs\n+   */\n+  BatchOperationCallbackTracker(List<BlobId> blobIds, FutureResult<Void> futureResult,\n+      Callback<Void> callback) {", "originalCommit": "eb0e436fe160467c36ad52254d568602ae811fee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwNDU0OA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r409904548", "bodyText": "minor: for TtlUpdate and Undelete operations", "author": "jsjtzyy", "createdAt": "2020-04-16T23:23:01Z", "path": "ambry-router/src/main/java/com/github/ambry/router/BatchOperationCallbackTracker.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.commons.BlobId;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\n+/**\n+ * Tracks callbacks for TtlUpdate operations over multiple chunks of a single blob", "originalCommit": "eb0e436fe160467c36ad52254d568602ae811fee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjE1MQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411636151", "bodyText": "should be completeUndeleteBlobOperation", "author": "jsjtzyy", "createdAt": "2020-04-20T19:32:17Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);\n+        try {\n+          getBlob(blobIdStr, optionsInternal, internalCallback);\n+        } catch (RouterException e) {\n+          completeUpdateBlobTtlOperation(e, futureResult, callback);", "originalCommit": "eb0e436fe160467c36ad52254d568602ae811fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNzg5NA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411637894", "bodyText": "And try to write a test that covers this case.", "author": "jsjtzyy", "createdAt": "2020-04-20T19:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzM0NQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411683345", "bodyText": "Tests will be added at next PR, with the real implementation of UndeleteOperation.", "author": "justinlin-linkedin", "createdAt": "2020-04-20T20:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjk4OA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411636988", "bodyText": "you probably need a dedicated metric routerMetrics.ageAtUndelete", "author": "jsjtzyy", "createdAt": "2020-04-20T19:33:45Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -704,6 +750,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before TTL update)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)\n+            .build();\n+        GetBlobOptionsInternal optionsInternal =\n+            new GetBlobOptionsInternal(options, true, routerMetrics.ageAtTtlUpdate);", "originalCommit": "eb0e436fe160467c36ad52254d568602ae811fee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzQyNQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411683425", "bodyText": "good catch.", "author": "justinlin-linkedin", "createdAt": "2020-04-20T20:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzNjk4OA=="}], "type": "inlineReview"}, {"oid": "cde9fe3c136071f9d5add87eb0fd6c46de8e1c4b", "url": "https://github.com/linkedin/ambry/commit/cde9fe3c136071f9d5add87eb0fd6c46de8e1c4b", "message": "Add skeleton for router to support undelete", "committedDate": "2020-04-20T20:43:41Z", "type": "commit"}, {"oid": "648a87764e343992d3b77f4d79b93deb89ada2f0", "url": "https://github.com/linkedin/ambry/commit/648a87764e343992d3b77f4d79b93deb89ada2f0", "message": "Remove duplicate code", "committedDate": "2020-04-20T20:43:41Z", "type": "commit"}, {"oid": "ec8e31450b92d4f3abb9fae9fc8544e01511c559", "url": "https://github.com/linkedin/ambry/commit/ec8e31450b92d4f3abb9fae9fc8544e01511c559", "message": "Remove default implmentation of undeleteBlob", "committedDate": "2020-04-20T20:43:41Z", "type": "commit"}, {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "url": "https://github.com/linkedin/ambry/commit/0d56c055fab0b7f879b27c5083ba1a63da08e551", "message": "Address comments", "committedDate": "2020-04-20T20:49:20Z", "type": "commit"}, {"oid": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "url": "https://github.com/linkedin/ambry/commit/0d56c055fab0b7f879b27c5083ba1a63da08e551", "message": "Address comments", "committedDate": "2020-04-20T20:49:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Njc5NQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411746795", "bodyText": "I know the logic is mostly from TtlUpdate but let's be careful on Undelete own logic here. Note that GetOption.None returns all blobs that are not expired and not deleted.  I wonder if we should use Include_Deleted_Blobs for undelete operation. Please double check GetOption enum.", "author": "jsjtzyy", "createdAt": "2020-04-20T22:57:52Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouter.java", "diffHunk": "@@ -706,6 +752,55 @@ protected void deleteBlob(final String blobIdStr, final String serviceId, Future\n       routerCallback.onPollReady();\n     }\n \n+    /**\n+     * Requests for a blob to be undeleted asynchronously and invokes the {@link Callback} when the request completes.\n+     * @param blobIdStr The ID of the blob that needs to be undeleted in string form\n+     * @param serviceId The service ID of the service undeleting the blob. This can be null if unknown.\n+     * @param futureResult A future that would contain information about whether the undelete succeeded or not,\n+     *                     eventually.\n+     * @param callback The {@link Callback} which will be invoked on the completion of a request.\n+     */\n+    protected void undeleteBlob(final String blobIdStr, final String serviceId, FutureResult<Void> futureResult,\n+        final Callback<Void> callback) {\n+      // Can skip GET if we can determine this is not a metadata bllob\n+      if (isMaybeMetadataBlob(blobIdStr)) {\n+        Callback<GetBlobResultInternal> internalCallback = (GetBlobResultInternal result, Exception exception) -> {\n+          if (exception != null) {\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else if (result.getBlobResult != null) {\n+            exception = new RouterException(\n+                \"GET blob call returned the blob instead of just the store keys (before undelete)\",\n+                RouterErrorCode.UnexpectedInternalError);\n+            completeOperation(futureResult, callback, null, exception, false);\n+          } else {\n+            List<String> blobIdStrs = new ArrayList<>();\n+            blobIdStrs.add(blobIdStr);\n+            if (result.storeKeys != null) {\n+              result.storeKeys.forEach(key -> blobIdStrs.add(key.getID()));\n+            }\n+            // UndeleteManager undeletes all chunks in parallel\n+            currentOperationsCount.addAndGet(blobIdStrs.size());\n+            doUndeleteOperation(blobIdStrs, serviceId, futureResult, callback);\n+          }\n+        };\n+\n+        GetBlobOptions options = new GetBlobOptionsBuilder().operationType(GetBlobOptions.OperationType.All)\n+            .getOption(GetOption.None)", "originalCommit": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2OTUxMQ==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411769511", "bodyText": "you are right, that was a mistake. updated.", "author": "justinlin-linkedin", "createdAt": "2020-04-20T23:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Njc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Nzc1Mg==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411747752", "bodyText": "should beUndeleteOperation.class", "author": "jsjtzyy", "createdAt": "2020-04-20T22:59:55Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -243,6 +250,8 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n         metricRegistry.meter(MetricRegistry.name(GetBlobOperation.class, \"GetEncryptedBlobWithSegmentOperationRate\"));\n     deleteBlobOperationRate =\n         metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobOperationRate\"));\n+    undeleteBlobOperationRate =\n+        metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobOperationRate\"));", "originalCommit": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Nzg2Ng==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411747866", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-04-20T23:00:12Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -252,6 +261,8 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n         metricRegistry.meter(MetricRegistry.name(GetBlobOperation.class, \"GetBlobNotOriginateLocalOperationRate\"));\n     deleteBlobNotOriginateLocalOperationRate =\n         metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobNotOriginateLocalOperationRate\"));\n+    undeleteBlobNotOriginateLocalOperationRate =\n+        metricRegistry.meter(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobNotOriginateLocalOperationRate\"));", "originalCommit": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NzkxMA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411747910", "bodyText": "same here", "author": "jsjtzyy", "createdAt": "2020-04-20T23:00:20Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -282,6 +293,8 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n         metricRegistry.histogram(MetricRegistry.name(GetBlobOperation.class, \"GetEncryptedBlobOperationTotalTimeMs\"));\n     deleteBlobOperationLatencyMs =\n         metricRegistry.histogram(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobOperationLatencyMs\"));\n+    undeleteBlobOperationLatencyMs =\n+        metricRegistry.histogram(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobOperationLatencyMs\"));", "originalCommit": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0ODM2MA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411748360", "bodyText": "make sure all recently added metrics in this file have been updated to either UndeleteOperation.class or UndeleteManager.class", "author": "jsjtzyy", "createdAt": "2020-04-20T23:01:26Z", "path": "ambry-router/src/main/java/com/github/ambry/router/NonBlockingRouterMetrics.java", "diffHunk": "@@ -312,6 +325,7 @@ public NonBlockingRouterMetrics(ClusterMap clusterMap, RouterConfig routerConfig\n     getEncryptedBlobWithSegmentErrorCount =\n         metricRegistry.counter(MetricRegistry.name(GetBlobOperation.class, \"GetEncryptedBlobWithSegmentErrorCount\"));\n     deleteBlobErrorCount = metricRegistry.counter(MetricRegistry.name(DeleteOperation.class, \"DeleteBlobErrorCount\"));\n+    undeleteBlobErrorCount = metricRegistry.counter(MetricRegistry.name(DeleteOperation.class, \"UndeleteBlobErrorCount\"));", "originalCommit": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDczOA==", "url": "https://github.com/linkedin/ambry/pull/1467#discussion_r411754738", "bodyText": "redundant cast, can remove (UndeleteRequest)", "author": "jsjtzyy", "createdAt": "2020-04-20T23:17:48Z", "path": "ambry-router/src/main/java/com/github/ambry/router/UndeleteManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.router;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.AccountService;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.clustermap.ClusterMap;\n+import com.github.ambry.clustermap.ClusterMapUtils;\n+import com.github.ambry.commons.BlobId;\n+import com.github.ambry.commons.ResponseHandler;\n+import com.github.ambry.config.RouterConfig;\n+import com.github.ambry.network.RequestInfo;\n+import com.github.ambry.network.ResponseInfo;\n+import com.github.ambry.notification.NotificationSystem;\n+import com.github.ambry.protocol.UndeleteRequest;\n+import com.github.ambry.protocol.UndeleteResponse;\n+import com.github.ambry.utils.Pair;\n+import com.github.ambry.utils.Time;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+\n+/**\n+ * Handles {@link UndeleteOperation}. A {@code UndeleteManager} keeps track of all the Undelete\n+ * operations that are assigned to it, and manages their states and life cycles.\n+ */\n+public class UndeleteManager {\n+  private final ClusterMap clusterMap;\n+  private final NotificationSystem notificationSystem;\n+  private final Time time;\n+  private final ResponseHandler responseHandler;\n+  private final AccountService accountService;\n+  private final NonBlockingRouterMetrics routerMetrics;\n+  private final RouterConfig routerConfig;\n+  private final Set<UndeleteOperation> undeleteOperations = ConcurrentHashMap.newKeySet();\n+  private final Map<Integer, UndeleteOperation> correlationIdToUndeleteOperation = new HashMap<>();\n+  private final RequestRegistrationCallback<UndeleteOperation> requestRegistrationCallback =\n+      new RequestRegistrationCallback<>(correlationIdToUndeleteOperation);\n+\n+  /**\n+   * Creates a UndeleteManager.\n+   * @param clusterMap The {@link ClusterMap} of the cluster.\n+   * @param responseHandler The {@link ResponseHandler} used to notify failures for failure detection.\n+   * @param notificationSystem The {@link NotificationSystem} used for notifying undelete for blobs.\n+   * @param accountService The {@link AccountService} used for account/container id and name mapping.\n+   * @param routerConfig The {@link RouterConfig} containing the configs for the UndeleteManager.\n+   * @param routerMetrics The {@link NonBlockingRouterMetrics} to be used for reporting metrics.\n+   * @param time The {@link Time} instance to use.\n+   */\n+  UndeleteManager(ClusterMap clusterMap, ResponseHandler responseHandler, NotificationSystem notificationSystem,\n+      AccountService accountService, RouterConfig routerConfig, NonBlockingRouterMetrics routerMetrics, Time time) {\n+    this.clusterMap = clusterMap;\n+    this.responseHandler = responseHandler;\n+    this.notificationSystem = notificationSystem;\n+    this.accountService = accountService;\n+    this.routerConfig = routerConfig;\n+    this.routerMetrics = routerMetrics;\n+    this.time = time;\n+  }\n+\n+  /**\n+   * Submits {@link UndeleteOperation}(s) to this {@link UndeleteManager}.\n+   * @param blobIdStrs The original blobId strings\n+   * @param serviceId The service ID of the service undeleting the blob(s). This can be null if unknown.\n+   * @param futureResult The {@link FutureResult} that will contain the result eventually and exception if any.\n+   * @param callback The {@link Callback} that will be called on completion of the request.\n+   * @throws RouterException if the blobIdStr is invalid.\n+   */\n+  void submitUndeleteOperation(Collection<String> blobIdStrs, String serviceId, FutureResult<Void> futureResult,\n+      Callback<Void> callback) throws RouterException {\n+    List<BlobId> blobIds = new ArrayList<>();\n+    for (String blobIdStr : blobIdStrs) {\n+      BlobId blobId = RouterUtils.getBlobIdFromString(blobIdStr, clusterMap);\n+      if (blobId.getDatacenterId() != ClusterMapUtils.UNKNOWN_DATACENTER_ID\n+          && blobId.getDatacenterId() != clusterMap.getLocalDatacenterId()) {\n+        routerMetrics.undeleteBlobNotOriginateLocalOperationRate.mark();\n+      }\n+      blobIds.add(blobId);\n+    }\n+    if (blobIds.size() == 1) {\n+      UndeleteOperation undeleteOperation =\n+          new UndeleteOperation(clusterMap, routerConfig, routerMetrics, blobIds.get(0), serviceId, time.milliseconds(),\n+              callback, time, futureResult);\n+      undeleteOperations.add(undeleteOperation);\n+    } else {\n+      BatchOperationCallbackTracker tracker = new BatchOperationCallbackTracker(blobIds, futureResult, callback);\n+      long operationTimeMs = time.milliseconds();\n+      for (BlobId blobId : blobIds) {\n+        UndeleteOperation undeleteOperation =\n+            new UndeleteOperation(clusterMap, routerConfig, routerMetrics, blobId, serviceId, operationTimeMs,\n+                tracker.getCallback(blobId), time, BatchOperationCallbackTracker.DUMMY_FUTURE);\n+        undeleteOperations.add(undeleteOperation);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Polls all undelete operations and populates a list of {@link RequestInfo} to be sent to data nodes in order to\n+   * complete undelete operations.\n+   * @param requestsToSend list to be filled with the requests created.\n+   * @param requestsToDrop list to be filled with the requests to drop.\n+   */\n+  void poll(List<RequestInfo> requestsToSend, Set<Integer> requestsToDrop) {\n+    long startTime = time.milliseconds();\n+    requestRegistrationCallback.setRequestsToSend(requestsToSend);\n+    requestRegistrationCallback.setRequestsToDrop(requestsToDrop);\n+    for (UndeleteOperation op : undeleteOperations) {\n+      boolean exceptionEncountered = false;\n+      try {\n+        op.poll(requestRegistrationCallback);\n+      } catch (Exception e) {\n+        exceptionEncountered = true;\n+        op.setOperationException(new RouterException(\"Undelete poll encountered unexpected error\", e,\n+            RouterErrorCode.UnexpectedInternalError));\n+      }\n+      if (exceptionEncountered || op.isOperationComplete()) {\n+        if (undeleteOperations.remove(op)) {\n+          // In order to ensure that an operation is completed only once, call onComplete() only at the place where the\n+          // operation actually gets removed from the set of operations. See comment within close().\n+          onComplete(op);\n+        }\n+      }\n+    }\n+    routerMetrics.undeleteManagerPollTimeMs.update(time.milliseconds() - startTime);\n+  }\n+\n+  /**\n+   * Handles responses received for each of the {@link UndeleteOperation} within this UndeleteManager.\n+   * @param responseInfo the {@link ResponseInfo} containing the response.\n+   */\n+  void handleResponse(ResponseInfo responseInfo) {\n+    long startTime = time.milliseconds();\n+    UndeleteResponse undeleteResponse =\n+        RouterUtils.extractResponseAndNotifyResponseHandler(responseHandler, routerMetrics, responseInfo,\n+            UndeleteResponse::readFrom, UndeleteResponse::getError);\n+    RequestInfo routerRequestInfo = responseInfo.getRequestInfo();\n+    int correlationId = ((UndeleteRequest) routerRequestInfo.getRequest()).getCorrelationId();", "originalCommit": "0d56c055fab0b7f879b27c5083ba1a63da08e551", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b75acb470744e144990b1c3a62f908f6352e3e9f", "url": "https://github.com/linkedin/ambry/commit/b75acb470744e144990b1c3a62f908f6352e3e9f", "message": "Comments", "committedDate": "2020-04-20T23:50:50Z", "type": "commit"}]}