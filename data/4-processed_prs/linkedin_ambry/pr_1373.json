{"pr_number": 1373, "pr_title": "Add undelete method to BlobStore", "pr_createdAt": "2020-02-05T03:32:55Z", "pr_url": "https://github.com/linkedin/ambry/pull/1373", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAyOTQwMA==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376029400", "bodyText": "minor: undeleting", "author": "jsjtzyy", "createdAt": "2020-02-06T19:14:42Z", "path": "ambry-api/src/main/java/com.github.ambry/notification/NotificationSystem.java", "diffHunk": "@@ -57,6 +57,15 @@ void onBlobCreated(String blobId, BlobProperties blobProperties, Account account\n    */\n   void onBlobDeleted(String blobId, String serviceId, Account account, Container container);\n \n+  /**\n+   * Notifies the underlying system when a deleted blob is undeleted.\n+   * @param blobId The id of the blob whose deleted state has been replicated\n+   * @param serviceId The service ID of the service deleting the blob. This can be null if unknown.", "originalCommit": "60e973cc974ff3498e07739681bb43ee48bf5d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAyOTk4Mw==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376029983", "bodyText": "the blob was undeleted", "author": "jsjtzyy", "createdAt": "2020-02-06T19:15:52Z", "path": "ambry-api/src/main/java/com.github.ambry/notification/NotificationSystem.java", "diffHunk": "@@ -57,6 +57,15 @@ void onBlobCreated(String blobId, BlobProperties blobProperties, Account account\n    */\n   void onBlobDeleted(String blobId, String serviceId, Account account, Container container);\n \n+  /**\n+   * Notifies the underlying system when a deleted blob is undeleted.\n+   * @param blobId The id of the blob whose deleted state has been replicated", "originalCommit": "60e973cc974ff3498e07739681bb43ee48bf5d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzMDI4MQ==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376030281", "bodyText": "undeleted state", "author": "jsjtzyy", "createdAt": "2020-02-06T19:16:28Z", "path": "ambry-api/src/main/java/com.github.ambry/notification/NotificationSystem.java", "diffHunk": "@@ -86,4 +95,13 @@ void onBlobCreated(String blobId, BlobProperties blobProperties, Account account\n    */\n   void onBlobReplicaUpdated(String sourceHost, int port, String blobId, BlobReplicaSourceType sourceType,\n       UpdateType updateType, MessageInfo info);\n+\n+  /**\n+   * Notifies the underlying system when a undeleted state of a blob is replicated to a node\n+   * @param sourceHost The source host from where the notification is being invoked\n+   * @param port The port of the source host from where the notification is being invoked.\n+   * @param blobId The id of the blob whose deleted state has been replicated", "originalCommit": "60e973cc974ff3498e07739681bb43ee48bf5d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzMjIxMA==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376032210", "bodyText": "Any reason why we don't pass in MessageWriteSet? Is this because we undelete only one blob at a time?", "author": "jsjtzyy", "createdAt": "2020-02-06T19:20:43Z", "path": "ambry-api/src/main/java/com.github.ambry/store/Store.java", "diffHunk": "@@ -54,6 +54,13 @@\n    */\n   void delete(MessageWriteSet messageSetToDelete) throws StoreException;\n \n+  /**\n+   * Undelete the blob identified by {@code id}.\n+   * @param info The {@link MessageInfo} that carries some basic information about this operation.\n+   * @return the lifeVersion of the undeleted blob.\n+   */\n+  short undelete(MessageInfo info) throws StoreException;", "originalCommit": "60e973cc974ff3498e07739681bb43ee48bf5d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTU2Mg==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376149562", "bodyText": "MessgeWriteSet includes a serialized undelete record, which will be persisted on disk in the log. The problem is that this serialized record requires a lifeVersion, but we don't know the lifeVersion before we query the index. So here I pass a MessageInfo instead of MessageWriteSet. You can see in the BlobStore.undelete method, I create a MessageWriteSet in the end, with a lifeVersion.", "author": "justinlin-linkedin", "createdAt": "2020-02-07T00:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzMjIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzMzM0NA==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376033344", "bodyText": "good catch", "author": "jsjtzyy", "createdAt": "2020-02-06T19:23:03Z", "path": "ambry-commons/src/main/java/com.github.ambry.commons/LoggingNotificationSystem.java", "diffHunk": "@@ -64,22 +64,36 @@ public void onBlobDeleted(String blobId, String serviceId, Account account, Cont\n             : container.getName()) + \", containerId \" + (container == null ? null : container.getId()));\n   }\n \n+  @Override\n+  public void onBlobUndeleted(String blobId, String serviceId, Account account, Container container) {\n+    logger.debug(\"onBlobUndeleted \" + blobId,\n+        \", \" + serviceId + \", accountName \" + (account == null ? null : account.getName()) + \", accountId\" + (\n+            account == null ? null : account.getId()) + \", containerName \" + (container == null ? null\n+            : container.getName()) + \", containerId \" + (container == null ? null : container.getId()));\n+\n+  }\n+\n   @Override\n   public void onBlobReplicaCreated(String sourceHost, int port, String blobId, BlobReplicaSourceType sourceType) {\n     logger.debug(\"onBlobReplicaCreated \" + sourceHost + \", \" + port + \", \" + blobId + \", \" + sourceType);\n   }\n \n   @Override\n   public void onBlobReplicaDeleted(String sourceHost, int port, String blobId, BlobReplicaSourceType sourceType) {\n-    logger.debug(\"onBlobReplicaCreated \" + sourceHost + \", \" + port + \", \" + blobId + \", \" + sourceType);\n+    logger.debug(\"onBlobReplicaDeleted \" + sourceHost + \", \" + port + \", \" + blobId + \", \" + sourceType);", "originalCommit": "60e973cc974ff3498e07739681bb43ee48bf5d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA0MTQxOA==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376041418", "bodyText": "Note that, other methods (put, ttlUpdate, delete) in BlobStore are also invoked in Replication. When you implement undelete replication part, the LIFE_VERSION_FROM_FRONTEND check here probably needs to change.", "author": "jsjtzyy", "createdAt": "2020-02-06T19:39:11Z", "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "diffHunk": "@@ -612,6 +615,70 @@ public void updateTtl(MessageWriteSet messageSetToUpdate) throws StoreException\n     }\n   }\n \n+  @Override\n+  public short undelete(MessageInfo info) throws StoreException {\n+    checkStarted();\n+    final Timer.Context context = metrics.undeleteResponse.time();\n+    try {\n+      StoreKey id = info.getStoreKey();\n+      Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n+      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);", "originalCommit": "60e973cc974ff3498e07739681bb43ee48bf5d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTk5MQ==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376149991", "bodyText": "I actually have to change ttlupdate and delete later to make them aware of undelete in replication.", "author": "justinlin-linkedin", "createdAt": "2020-02-07T00:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA0MTQxOA=="}], "type": "inlineReview"}, {"oid": "a3f054e3905e39cd69280f27be2889c42b360d7c", "url": "https://github.com/linkedin/ambry/commit/a3f054e3905e39cd69280f27be2889c42b360d7c", "message": "typos", "committedDate": "2020-02-07T00:02:17Z", "type": "forcePushed"}, {"oid": "af8a080a3dddce54d2b451fc10afecf84f4175f9", "url": "https://github.com/linkedin/ambry/commit/af8a080a3dddce54d2b451fc10afecf84f4175f9", "message": "Add undelete method to blobstore", "committedDate": "2020-02-07T01:41:04Z", "type": "commit"}, {"oid": "dfe71febed979f971ff8bc557cb7a7f051637ba3", "url": "https://github.com/linkedin/ambry/commit/dfe71febed979f971ff8bc557cb7a7f051637ba3", "message": "Add test cases", "committedDate": "2020-02-07T01:41:04Z", "type": "commit"}, {"oid": "61c8af2814a98e08c6aeca7e348cd80c254f832a", "url": "https://github.com/linkedin/ambry/commit/61c8af2814a98e08c6aeca7e348cd80c254f832a", "message": "Fix the test", "committedDate": "2020-02-07T01:41:04Z", "type": "commit"}, {"oid": "0d039d506dcbf79eb82b21dfaf4c2cfb3840037a", "url": "https://github.com/linkedin/ambry/commit/0d039d506dcbf79eb82b21dfaf4c2cfb3840037a", "message": "Fix", "committedDate": "2020-02-07T01:41:04Z", "type": "commit"}, {"oid": "e64cd156b0efd690e0ae0995d4f2ab4c2f52ac8f", "url": "https://github.com/linkedin/ambry/commit/e64cd156b0efd690e0ae0995d4f2ab4c2f52ac8f", "message": "Comments", "committedDate": "2020-02-07T01:41:04Z", "type": "commit"}, {"oid": "052bf10a3c4f753c94a5a353cc4573466b5a7b21", "url": "https://github.com/linkedin/ambry/commit/052bf10a3c4f753c94a5a353cc4573466b5a7b21", "message": "typos", "committedDate": "2020-02-07T01:41:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0Nzc2Mg==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r376647762", "bodyText": "Add a TODO here: update blobStoreStats for Undelete.", "author": "jsjtzyy", "createdAt": "2020-02-07T23:02:38Z", "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "diffHunk": "@@ -612,6 +615,70 @@ public void updateTtl(MessageWriteSet messageSetToUpdate) throws StoreException\n     }\n   }\n \n+  @Override\n+  public short undelete(MessageInfo info) throws StoreException {\n+    checkStarted();\n+    final Timer.Context context = metrics.undeleteResponse.time();\n+    try {\n+      StoreKey id = info.getStoreKey();\n+      Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n+      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);\n+      IndexValue latestValue = values.get(0);\n+      short lifeVersion = (short) (latestValue.getLifeVersion() + 1);\n+      MessageFormatInputStream stream =\n+          new UndeleteMessageFormatInputStream(id, info.getAccountId(), info.getContainerId(),\n+              info.getOperationTimeMs(), lifeVersion);\n+      // Update info to add stream size;\n+      info =\n+          new MessageInfo(id, stream.getSize(), info.getAccountId(), info.getContainerId(), info.getOperationTimeMs());\n+      ArrayList<MessageInfo> infoList = new ArrayList<>();\n+      infoList.add(info);\n+      MessageFormatWriteSet writeSet = new MessageFormatWriteSet(stream, infoList, false);\n+      if (!info.getStoreKey().isAccountContainerMatch(latestValue.getAccountId(), latestValue.getContainerId())) {\n+        if (config.storeValidateAuthorization) {\n+          throw new StoreException(\n+              \"UNDELETE authorization failure. Key: \" + info.getStoreKey() + \" Actually accountId: \"\n+                  + latestValue.getAccountId() + \"Actually containerId: \" + latestValue.getContainerId(),\n+              StoreErrorCodes.Authorization_Failure);\n+        } else {\n+          logger.warn(\"UNDELETE authorization failure. Key: {} Actually accountId: {} Actually containerId: {}\",\n+              info.getStoreKey(), latestValue.getAccountId(), latestValue.getContainerId());\n+          metrics.undeleteAuthorizationFailureCount.inc();\n+        }\n+      }\n+      synchronized (storeWriteLock) {\n+        Offset currentIndexEndOffset = index.getCurrentEndOffset();\n+        if (!currentIndexEndOffset.equals(indexEndOffsetBeforeCheck)) {\n+          FileSpan fileSpan = new FileSpan(indexEndOffsetBeforeCheck, currentIndexEndOffset);\n+          IndexValue value =\n+              index.findKey(info.getStoreKey(), fileSpan, EnumSet.allOf(PersistentIndex.IndexEntryType.class));\n+          if (value != null) {\n+            throw new StoreException(\"Cannot undelete id \" + info.getStoreKey() + \" since concurrent operation occurs\",\n+                StoreErrorCodes.Life_Version_Conflict);\n+          }\n+        }\n+        Offset endOffsetOfLastMessage = log.getEndOffset();\n+        writeSet.writeTo(log);\n+        logger.trace(\"Store : {} undelete mark written to log\", dataDir);\n+        FileSpan fileSpan = log.getFileSpanForMessage(endOffsetOfLastMessage, info.getSize());\n+        index.markAsUndeleted(info.getStoreKey(), fileSpan, info.getOperationTimeMs());", "originalCommit": "a3f054e3905e39cd69280f27be2889c42b360d7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIzMjE3NQ==", "url": "https://github.com/linkedin/ambry/pull/1373#discussion_r377232175", "bodyText": "It's clear when oldest/latest is used in variable. I would like to suggest also use var oldest/latest in validateSanityForUndelete, instead of first/last. To be consistent.", "author": "zzmao", "createdAt": "2020-02-10T18:16:19Z", "path": "ambry-store/src/main/java/com.github.ambry.store/BlobStore.java", "diffHunk": "@@ -612,6 +615,70 @@ public void updateTtl(MessageWriteSet messageSetToUpdate) throws StoreException\n     }\n   }\n \n+  @Override\n+  public short undelete(MessageInfo info) throws StoreException {\n+    checkStarted();\n+    final Timer.Context context = metrics.undeleteResponse.time();\n+    try {\n+      StoreKey id = info.getStoreKey();\n+      Offset indexEndOffsetBeforeCheck = index.getCurrentEndOffset();\n+      List<IndexValue> values = index.findAllIndexValuesForKey(id, null);\n+      index.validateSanityForUndelete(id, values, IndexValue.LIFE_VERSION_FROM_FRONTEND);\n+      IndexValue latestValue = values.get(0);", "originalCommit": "a3f054e3905e39cd69280f27be2889c42b360d7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "39ad87d8701a5c9301d9dc5fd4a317b5c94f1f55", "url": "https://github.com/linkedin/ambry/commit/39ad87d8701a5c9301d9dc5fd4a317b5c94f1f55", "message": "Rename some variables", "committedDate": "2020-02-10T18:32:17Z", "type": "forcePushed"}, {"oid": "363a72d49045c14141d1f053881425dac0018a1d", "url": "https://github.com/linkedin/ambry/commit/363a72d49045c14141d1f053881425dac0018a1d", "message": "Rename some variables", "committedDate": "2020-02-10T18:33:32Z", "type": "commit"}, {"oid": "363a72d49045c14141d1f053881425dac0018a1d", "url": "https://github.com/linkedin/ambry/commit/363a72d49045c14141d1f053881425dac0018a1d", "message": "Rename some variables", "committedDate": "2020-02-10T18:33:32Z", "type": "forcePushed"}]}