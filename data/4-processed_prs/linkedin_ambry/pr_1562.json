{"pr_number": 1562, "pr_title": "Support querying sealed partitions in cluster by HelixBootstrapTool", "pr_createdAt": "2020-06-12T03:42:14Z", "pr_url": "https://github.com/linkedin/ambry/pull/1562", "timeline": [{"oid": "aba1cefc07be93bcaa367b6134d7c56940e55266", "url": "https://github.com/linkedin/ambry/commit/aba1cefc07be93bcaa367b6134d7c56940e55266", "message": "Support querying sealed partitions in cluster by HelixBootstrapTool\n\nThis PR introduces a new option in Helix bootstrap tool that allows user\nto query current sealed partitions across all datacenters. The tool prints\nout detailed info (such as sealed replicas on each host) and also the aggregated\nresult (sealed partition across all colos)", "committedDate": "2020-06-12T03:33:41Z", "type": "commit"}, {"oid": "155ee6e5c8904434716a7ac48a37da940fd150d7", "url": "https://github.com/linkedin/ambry/commit/155ee6e5c8904434716a7ac48a37da940fd150d7", "message": "print out non-existent sealed replicas", "committedDate": "2020-06-16T03:13:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3OTE3MA==", "url": "https://github.com/linkedin/ambry/pull/1562#discussion_r441879170", "bodyText": "return the set of sealed partitions...", "author": "xuhao417347761", "createdAt": "2020-06-17T23:01:59Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -1298,6 +1324,93 @@ private void validateAndClose() {\n     }\n   }\n \n+  /**\n+   * Get sealed partitions from Helix cluster.\n+   * @return the total number of sealed partitions across all DCs.", "originalCommit": "155ee6e5c8904434716a7ac48a37da940fd150d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3Nzg0MQ==", "url": "https://github.com/linkedin/ambry/pull/1562#discussion_r442377841", "bodyText": "fixed", "author": "jsjtzyy", "createdAt": "2020-06-18T17:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3OTE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MzQ5MA==", "url": "https://github.com/linkedin/ambry/pull/1562#discussion_r442343490", "bodyText": "replicasOnNode is a set of all replicas on a node, you may want to log the node id here.", "author": "xuhao417347761", "createdAt": "2020-06-18T16:13:05Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixBootstrapUpgradeUtil.java", "diffHunk": "@@ -1298,6 +1324,93 @@ private void validateAndClose() {\n     }\n   }\n \n+  /**\n+   * Get sealed partitions from Helix cluster.\n+   * @return the total number of sealed partitions across all DCs.\n+   */\n+  private Set<String> getSealedPartitionsInHelixCluster() throws Exception {\n+    info(\"Aggregating sealed partitions from cluster {} in Helix\", clusterName);\n+    CountDownLatch sealedPartitionLatch = new CountDownLatch(adminForDc.size());\n+    AtomicInteger errorCount = new AtomicInteger();\n+    Map<String, Set<String>> dcToSealedPartitions = new ConcurrentHashMap<>();\n+    Map<String, Set<String>> nodeToNonExistentReplicas = new ConcurrentHashMap<>();\n+    for (Datacenter dc : staticClusterMap.hardwareLayout.getDatacenters()) {\n+      HelixAdmin admin = adminForDc.get(dc.getName());\n+      if (admin == null) {\n+        info(\"Skipping {}\", dc.getName());\n+        continue;\n+      }\n+      ensureOrThrow(zkClientForDc.get(dc.getName()) == null ? admin.getClusters().contains(clusterName)\n+              : ZKUtil.isClusterSetup(clusterName, zkClientForDc.get(dc.getName())),\n+          \"Cluster not found in ZK \" + dataCenterToZkAddress.get(dc.getName()));\n+      Utils.newThread(() -> {\n+        try {\n+          getSealedPartitionsInDc(dc, dcToSealedPartitions, nodeToNonExistentReplicas);\n+        } catch (Throwable t) {\n+          logger.error(\"[{}] error message: {}\", dc.getName().toUpperCase(), t.getMessage());\n+          errorCount.getAndIncrement();\n+        } finally {\n+          sealedPartitionLatch.countDown();\n+        }\n+      }, false).start();\n+    }\n+    sealedPartitionLatch.await(10, TimeUnit.MINUTES);\n+    ensureOrThrow(errorCount.get() == 0, \"Error occurred when aggregating sealed partitions in cluster \" + clusterName);\n+    Set<String> sealedPartitionsInCluster = new HashSet<>();\n+    info(\"========================= Summary =========================\");\n+    for (Map.Entry<String, Set<String>> entry : dcToSealedPartitions.entrySet()) {\n+      info(\"Dc {} has {} sealed partitions.\", entry.getKey(), entry.getValue().size());\n+      sealedPartitionsInCluster.addAll(entry.getValue());\n+    }\n+    info(\"========================= Sealed Partitions across All DCs =========================\");\n+    info(\"Total number of sealed partitions in cluster = {}\", sealedPartitionsInCluster.size());\n+    info(\"Sealed partitions are {}\", sealedPartitionsInCluster.toString());\n+    if (!nodeToNonExistentReplicas.isEmpty()) {\n+      info(\"Following {} nodes have sealed replica that are not actually present\", nodeToNonExistentReplicas.size());\n+      for (Map.Entry<String, Set<String>> entry : nodeToNonExistentReplicas.entrySet()) {\n+        info(\"{} has non-existent replicas: {}\", entry.getKey(), entry.getValue().toString());\n+      }\n+    }\n+    info(\"Successfully aggregate sealed from cluster {} in Helix\", clusterName);\n+    return sealedPartitionsInCluster;\n+  }\n+\n+  /**\n+   * Get sealed partitions from given datacenter.\n+   * @param dc the datacenter where sealed partitions come from.\n+   * @param dcToSealedPartitions a map to track sealed partitions in each dc. This entry associated with given dc will\n+   *                             be populated in this method.\n+   * @param nodeToNonExistentReplicas a map to track if any replica is in sealed list but not actually on local node.\n+   */\n+  private void getSealedPartitionsInDc(Datacenter dc, Map<String, Set<String>> dcToSealedPartitions,\n+      Map<String, Set<String>> nodeToNonExistentReplicas) {\n+    String dcName = dc.getName();\n+    dcToSealedPartitions.put(dcName, new HashSet<>());\n+    HelixAdmin admin = adminForDc.get(dcName);\n+    Set<String> allInstancesInHelix = new HashSet<>(admin.getInstancesInCluster(clusterName));\n+    for (DataNodeId dataNodeId : dc.getDataNodes()) {\n+      DataNode dataNode = (DataNode) dataNodeId;\n+      Set<String> replicasOnNode = staticClusterMap.getReplicas(dataNode)\n+          .stream()\n+          .map(replicaId -> replicaId.getPartitionId().toPathString())\n+          .collect(Collectors.toSet());\n+      String instanceName = getInstanceName(dataNode);\n+      ensureOrThrow(allInstancesInHelix.contains(instanceName), \"Instance not present in Helix \" + instanceName);\n+      InstanceConfig instanceConfig = admin.getInstanceConfig(clusterName, instanceName);\n+      List<String> sealedReplicas = instanceConfig.getRecord().getListField(ClusterMapUtils.SEALED_STR);\n+      if (sealedReplicas != null) {\n+        for (String sealedReplica : sealedReplicas) {\n+          info(\"Replica {} is sealed on {}\", sealedReplica, instanceName);\n+          dcToSealedPartitions.get(dcName).add(sealedReplica);\n+          if (!replicasOnNode.contains(sealedReplica)) {\n+            logger.warn(\"Replica {} is in sealed list but not on node {}\", sealedReplica, replicasOnNode);", "originalCommit": "155ee6e5c8904434716a7ac48a37da940fd150d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3NzkzOA==", "url": "https://github.com/linkedin/ambry/pull/1562#discussion_r442377938", "bodyText": "Good catch, fixed", "author": "jsjtzyy", "createdAt": "2020-06-18T17:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MzQ5MA=="}], "type": "inlineReview"}, {"oid": "ecdfa5f7e4e08394e6cf32deb600ee0531ef0d2d", "url": "https://github.com/linkedin/ambry/commit/ecdfa5f7e4e08394e6cf32deb600ee0531ef0d2d", "message": "address Hao's comment", "committedDate": "2020-06-18T17:10:04Z", "type": "commit"}]}