{"pr_number": 1365, "pr_title": "Azure batch deletes", "pr_createdAt": "2020-01-24T00:27:47Z", "pr_url": "https://github.com/linkedin/ambry/pull/1365", "timeline": [{"oid": "46c545773d5b85fea1df54ce066de405f10858c0", "url": "https://github.com/linkedin/ambry/commit/46c545773d5b85fea1df54ce066de405f10858c0", "message": "First cut at batch blob deletes", "committedDate": "2019-12-21T01:57:11Z", "type": "commit"}, {"oid": "2d404f35c365a4485406744f64ca76eac3b9b8f3", "url": "https://github.com/linkedin/ambry/commit/2d404f35c365a4485406744f64ca76eac3b9b8f3", "message": "Update azure storage lib to fix batch delete bug", "committedDate": "2020-01-23T23:53:30Z", "type": "commit"}, {"oid": "5e1afe24679a3e699c57998612cd2c7d82dd7fd9", "url": "https://github.com/linkedin/ambry/commit/5e1afe24679a3e699c57998612cd2c7d82dd7fd9", "message": "Merge branch 'master' of github.com:linkedin/ambry into azure-batch-deletes", "committedDate": "2020-01-24T00:15:51Z", "type": "commit"}, {"oid": "4fb33e7869127836470c7330767266ea4c36e2bf", "url": "https://github.com/linkedin/ambry/commit/4fb33e7869127836470c7330767266ea4c36e2bf", "message": "Fix merge issues from rebase.", "committedDate": "2020-01-24T00:24:47Z", "type": "commit"}, {"oid": "5b0993ec9974e5b4c75db3e2d6291b0e74f5a55d", "url": "https://github.com/linkedin/ambry/commit/5b0993ec9974e5b4c75db3e2d6291b0e74f5a55d", "message": "Fix test", "committedDate": "2020-01-24T00:52:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NDkyOQ==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r371984929", "bodyText": "Lets make this final. Also add the comment about batch size <= 256 here. Along with that add additional comment that once added to AzureCloudConfig, we should validate this is <= 256.", "author": "ankagrawal", "createdAt": "2020-01-28T18:39:25Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -55,12 +63,15 @@\n   private static final Logger logger = LoggerFactory.getLogger(AzureBlobDataAccessor.class);\n   private static final String SEPARATOR = \"-\";\n   private final BlobServiceClient storageClient;\n+  private final BlobBatchClient blobBatchClient;\n   private final Configuration storageConfiguration;\n   private final AzureMetrics azureMetrics;\n   private final String clusterName;\n   // Containers known to exist in the storage account\n   private final Set<String> knownContainers = ConcurrentHashMap.newKeySet();\n   private ProxyOptions proxyOptions;\n+  // TODO: add to AzureCloudConfig\n+  private int purgeBatchSize = 100;", "originalCommit": "5b0993ec9974e5b4c75db3e2d6291b0e74f5a55d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MDE4Nw==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r373290187", "bodyText": "Added to config class and moved comment there.", "author": "lightningrob", "createdAt": "2020-01-31T02:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NDkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NTE4MA==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r371985180", "bodyText": "I think we should move this comment to where we define the purgeBatchSize variable. Also see more comments about purgeBatchSize above.", "author": "ankagrawal", "createdAt": "2020-01-28T18:39:57Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -302,13 +317,47 @@ public boolean updateBlobMetadata(BlobId blobId, String fieldName, Object value)\n   /**\n    * Permanently delete the specified blobs in Azure storage.\n    * @param blobMetadataList the list of {@link CloudBlobMetadata} referencing the blobs to purge.\n-   * @return the number of blobs successfully purged.\n+   * @return list of {@link CloudBlobMetadata} referencing the blobs successfully purged.\n    * @throws BlobStorageException if the purge operation fails.\n    */\n-  public int purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n-    // TODO: use batch api to delete all\n-    // https://github.com/Azure/azure-sdk-for-java/tree/master/sdk/storage/azure-storage-blob-batch\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+  public List<CloudBlobMetadata> purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n+\n+    // Per docs.microsoft.com/en-us/rest/api/storageservices/blob-batch, must use batch size <= 256", "originalCommit": "5b0993ec9974e5b4c75db3e2d6291b0e74f5a55d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NzY4NQ==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r371987685", "bodyText": "minor-XXS: maybe rename \"someBlobs\" to \"batchofBlobs\"", "author": "ankagrawal", "createdAt": "2020-01-28T18:45:02Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -302,13 +317,47 @@ public boolean updateBlobMetadata(BlobId blobId, String fieldName, Object value)\n   /**\n    * Permanently delete the specified blobs in Azure storage.\n    * @param blobMetadataList the list of {@link CloudBlobMetadata} referencing the blobs to purge.\n-   * @return the number of blobs successfully purged.\n+   * @return list of {@link CloudBlobMetadata} referencing the blobs successfully purged.\n    * @throws BlobStorageException if the purge operation fails.\n    */\n-  public int purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n-    // TODO: use batch api to delete all\n-    // https://github.com/Azure/azure-sdk-for-java/tree/master/sdk/storage/azure-storage-blob-batch\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+  public List<CloudBlobMetadata> purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n+\n+    // Per docs.microsoft.com/en-us/rest/api/storageservices/blob-batch, must use batch size <= 256\n+    List<CloudBlobMetadata> deletedBlobs = new ArrayList<>();\n+    List<List<CloudBlobMetadata>> partitionedLists = Lists.partition(blobMetadataList, purgeBatchSize);\n+    for (List<CloudBlobMetadata> someBlobs : partitionedLists) {", "originalCommit": "5b0993ec9974e5b4c75db3e2d6291b0e74f5a55d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwMjk0MQ==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r372002941", "bodyText": "We should make the Duration.ofHours(1) configurable. Atleast final private for now.", "author": "ankagrawal", "createdAt": "2020-01-28T19:15:24Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -302,13 +317,47 @@ public boolean updateBlobMetadata(BlobId blobId, String fieldName, Object value)\n   /**\n    * Permanently delete the specified blobs in Azure storage.\n    * @param blobMetadataList the list of {@link CloudBlobMetadata} referencing the blobs to purge.\n-   * @return the number of blobs successfully purged.\n+   * @return list of {@link CloudBlobMetadata} referencing the blobs successfully purged.\n    * @throws BlobStorageException if the purge operation fails.\n    */\n-  public int purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n-    // TODO: use batch api to delete all\n-    // https://github.com/Azure/azure-sdk-for-java/tree/master/sdk/storage/azure-storage-blob-batch\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+  public List<CloudBlobMetadata> purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n+\n+    // Per docs.microsoft.com/en-us/rest/api/storageservices/blob-batch, must use batch size <= 256\n+    List<CloudBlobMetadata> deletedBlobs = new ArrayList<>();\n+    List<List<CloudBlobMetadata>> partitionedLists = Lists.partition(blobMetadataList, purgeBatchSize);\n+    for (List<CloudBlobMetadata> someBlobs : partitionedLists) {\n+      BlobBatch blobBatch = blobBatchClient.getBlobBatch();\n+      List<Response<Void>> responseList = new ArrayList<>();\n+      for (CloudBlobMetadata blobMetadata : someBlobs) {\n+        String containerName = getAzureContainerName(blobMetadata);\n+        String blobName = getAzureBlobName(blobMetadata);\n+        responseList.add(blobBatch.deleteBlob(containerName, blobName));\n+      }\n+      blobBatchClient.submitBatchWithResponse(blobBatch, false, Duration.ofHours(1), Context.NONE);", "originalCommit": "5b0993ec9974e5b4c75db3e2d6291b0e74f5a55d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MDMzNg==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r373290336", "bodyText": "Made private final and changed to 1 minute.", "author": "lightningrob", "createdAt": "2020-01-31T02:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwMjk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyNDQ3OQ==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r372124479", "bodyText": "can the statuscode returned by exception be one of OK, ACCEPTED, NOT_FOUND or GONE? If not, then maybe we can move the try catch block to include switch as well.", "author": "ankagrawal", "createdAt": "2020-01-28T23:54:45Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -302,13 +317,47 @@ public boolean updateBlobMetadata(BlobId blobId, String fieldName, Object value)\n   /**\n    * Permanently delete the specified blobs in Azure storage.\n    * @param blobMetadataList the list of {@link CloudBlobMetadata} referencing the blobs to purge.\n-   * @return the number of blobs successfully purged.\n+   * @return list of {@link CloudBlobMetadata} referencing the blobs successfully purged.\n    * @throws BlobStorageException if the purge operation fails.\n    */\n-  public int purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n-    // TODO: use batch api to delete all\n-    // https://github.com/Azure/azure-sdk-for-java/tree/master/sdk/storage/azure-storage-blob-batch\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+  public List<CloudBlobMetadata> purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n+\n+    // Per docs.microsoft.com/en-us/rest/api/storageservices/blob-batch, must use batch size <= 256\n+    List<CloudBlobMetadata> deletedBlobs = new ArrayList<>();\n+    List<List<CloudBlobMetadata>> partitionedLists = Lists.partition(blobMetadataList, purgeBatchSize);\n+    for (List<CloudBlobMetadata> someBlobs : partitionedLists) {\n+      BlobBatch blobBatch = blobBatchClient.getBlobBatch();\n+      List<Response<Void>> responseList = new ArrayList<>();\n+      for (CloudBlobMetadata blobMetadata : someBlobs) {\n+        String containerName = getAzureContainerName(blobMetadata);\n+        String blobName = getAzureBlobName(blobMetadata);\n+        responseList.add(blobBatch.deleteBlob(containerName, blobName));\n+      }\n+      blobBatchClient.submitBatchWithResponse(blobBatch, false, Duration.ofHours(1), Context.NONE);\n+      for (int j = 0; j < responseList.size(); j++) {\n+        Response<Void> response = responseList.get(j);\n+        CloudBlobMetadata blobMetadata = someBlobs.get(j);\n+        // Note: Response.getStatusCode() throws exception on any error.\n+        int statusCode;\n+        try {\n+          statusCode = response.getStatusCode();\n+        } catch (BlobStorageException bex) {\n+          statusCode = bex.getStatusCode();", "originalCommit": "5b0993ec9974e5b4c75db3e2d6291b0e74f5a55d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4NjgyNw==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r373286827", "bodyText": "They throw exception if the http status is not the \"expected\" value, which in this case is Accepted.", "author": "lightningrob", "createdAt": "2020-01-31T02:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyNDQ3OQ=="}], "type": "inlineReview"}, {"oid": "805a9932963048e079de165b1ed757116477437f", "url": "https://github.com/linkedin/ambry/commit/805a9932963048e079de165b1ed757116477437f", "message": "Address Ankur's review comments", "committedDate": "2020-01-31T02:21:30Z", "type": "commit"}, {"oid": "994decafe82416deb29570ed0b991fc3c89afd90", "url": "https://github.com/linkedin/ambry/commit/994decafe82416deb29570ed0b991fc3c89afd90", "message": "Merge branch 'master' of github.com:linkedin/ambry into azure-batch-deletes", "committedDate": "2020-01-31T05:53:22Z", "type": "commit"}, {"oid": "0a174038358ca7cbeeb6389145131970c7e9bd5f", "url": "https://github.com/linkedin/ambry/commit/0a174038358ca7cbeeb6389145131970c7e9bd5f", "message": "Fix test issue", "committedDate": "2020-01-31T19:43:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNDc4OA==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r373734788", "bodyText": "make static?", "author": "cgtz", "createdAt": "2020-01-31T23:58:19Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -55,12 +62,15 @@\n   private static final Logger logger = LoggerFactory.getLogger(AzureBlobDataAccessor.class);\n   private static final String SEPARATOR = \"-\";\n   private final BlobServiceClient storageClient;\n+  private final BlobBatchClient blobBatchClient;\n   private final Configuration storageConfiguration;\n   private final AzureMetrics azureMetrics;\n   private final String clusterName;\n   // Containers known to exist in the storage account\n   private final Set<String> knownContainers = ConcurrentHashMap.newKeySet();\n   private ProxyOptions proxyOptions;\n+  private final int purgeBatchSize;\n+  private final int batchPurgeTimeoutSec = 60;", "originalCommit": "0a174038358ca7cbeeb6389145131970c7e9bd5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxNzAyMw==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374217023", "bodyText": "So, the caller of this method will know to retry on the blobs that are not in the returned list?", "author": "cgtz", "createdAt": "2020-02-03T16:51:38Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -302,13 +318,46 @@ public boolean updateBlobMetadata(BlobId blobId, String fieldName, Object value)\n   /**\n    * Permanently delete the specified blobs in Azure storage.\n    * @param blobMetadataList the list of {@link CloudBlobMetadata} referencing the blobs to purge.\n-   * @return the number of blobs successfully purged.\n+   * @return list of {@link CloudBlobMetadata} referencing the blobs successfully purged.\n    * @throws BlobStorageException if the purge operation fails.\n    */\n-  public int purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n-    // TODO: use batch api to delete all\n-    // https://github.com/Azure/azure-sdk-for-java/tree/master/sdk/storage/azure-storage-blob-batch\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+  public List<CloudBlobMetadata> purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n+\n+    List<CloudBlobMetadata> deletedBlobs = new ArrayList<>();\n+    List<List<CloudBlobMetadata>> partitionedLists = Lists.partition(blobMetadataList, purgeBatchSize);\n+    for (List<CloudBlobMetadata> batchOfBlobs : partitionedLists) {\n+      BlobBatch blobBatch = blobBatchClient.getBlobBatch();\n+      List<Response<Void>> responseList = new ArrayList<>();\n+      for (CloudBlobMetadata blobMetadata : batchOfBlobs) {\n+        String containerName = getAzureContainerName(blobMetadata);\n+        String blobName = getAzureBlobName(blobMetadata);\n+        responseList.add(blobBatch.deleteBlob(containerName, blobName));\n+      }\n+      blobBatchClient.submitBatchWithResponse(blobBatch, false, Duration.ofSeconds(batchPurgeTimeoutSec), Context.NONE);\n+      for (int j = 0; j < responseList.size(); j++) {\n+        Response<Void> response = responseList.get(j);\n+        CloudBlobMetadata blobMetadata = batchOfBlobs.get(j);\n+        // Note: Response.getStatusCode() throws exception on any error.\n+        int statusCode;\n+        try {\n+          statusCode = response.getStatusCode();\n+        } catch (BlobStorageException bex) {\n+          statusCode = bex.getStatusCode();\n+        }\n+        switch (statusCode) {\n+          case HttpURLConnection.HTTP_OK:\n+          case HttpURLConnection.HTTP_ACCEPTED:\n+          case HttpURLConnection.HTTP_NOT_FOUND:\n+          case HttpURLConnection.HTTP_GONE:\n+            // blob was deleted or already gone\n+            deletedBlobs.add(blobMetadata);\n+            break;\n+          default:\n+            logger.error(\"Deleting blob {} got status {}\", blobMetadata.getId(), statusCode);", "originalCommit": "0a174038358ca7cbeeb6389145131970c7e9bd5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwNTE0Mw==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374305143", "bodyText": "Right.  They will be returned by the Cosmos query on the next compaction run (since we are not deleting those records).", "author": "lightningrob", "createdAt": "2020-02-03T19:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxNzAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMDA3Mw==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374220073", "bodyText": "Apparently, the client will throw a general RuntimeException (looking at the code its IllegalStateException) and not BlobStorageException if it times out. We should make sure that the callers are prepared to handle that. It may be worth documenting in the javadocs too.", "author": "cgtz", "createdAt": "2020-02-03T16:57:07Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -302,13 +318,46 @@ public boolean updateBlobMetadata(BlobId blobId, String fieldName, Object value)\n   /**\n    * Permanently delete the specified blobs in Azure storage.\n    * @param blobMetadataList the list of {@link CloudBlobMetadata} referencing the blobs to purge.\n-   * @return the number of blobs successfully purged.\n+   * @return list of {@link CloudBlobMetadata} referencing the blobs successfully purged.\n    * @throws BlobStorageException if the purge operation fails.\n    */\n-  public int purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n-    // TODO: use batch api to delete all\n-    // https://github.com/Azure/azure-sdk-for-java/tree/master/sdk/storage/azure-storage-blob-batch\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+  public List<CloudBlobMetadata> purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws BlobStorageException {\n+\n+    List<CloudBlobMetadata> deletedBlobs = new ArrayList<>();\n+    List<List<CloudBlobMetadata>> partitionedLists = Lists.partition(blobMetadataList, purgeBatchSize);\n+    for (List<CloudBlobMetadata> batchOfBlobs : partitionedLists) {\n+      BlobBatch blobBatch = blobBatchClient.getBlobBatch();\n+      List<Response<Void>> responseList = new ArrayList<>();\n+      for (CloudBlobMetadata blobMetadata : batchOfBlobs) {\n+        String containerName = getAzureContainerName(blobMetadata);\n+        String blobName = getAzureBlobName(blobMetadata);\n+        responseList.add(blobBatch.deleteBlob(containerName, blobName));\n+      }\n+      blobBatchClient.submitBatchWithResponse(blobBatch, false, Duration.ofSeconds(batchPurgeTimeoutSec), Context.NONE);", "originalCommit": "0a174038358ca7cbeeb6389145131970c7e9bd5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwODQzMQ==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374308431", "bodyText": "Good point.  I  think it's okay to let the RuntimeException be thrown, but will add to the javadoc.", "author": "lightningrob", "createdAt": "2020-02-03T19:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMDA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMTYyNQ==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374231625", "bodyText": "I just want to confirm my understanding of the compaction logic: In the case where deletedBlobs.size() < blobMetadataList.size(), we rely on the fact that not deleting the record from cosmos will allow the dead blobs query to return the same blob ID in future compaction iterations?", "author": "cgtz", "createdAt": "2020-02-03T17:19:05Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureCloudDestination.java", "diffHunk": "@@ -349,51 +352,48 @@ private boolean updateBlobMetadata(BlobId blobId, String fieldName, Object value\n   }\n \n   @Override\n-  public boolean purgeBlob(CloudBlobMetadata blobMetadata) throws CloudStorageException {\n-    String blobId = blobMetadata.getId();\n-    String blobFileName = azureBlobDataAccessor.getAzureBlobName(blobMetadata);\n-    String containerName = azureBlobDataAccessor.getAzureContainerName(blobMetadata);\n-    String partitionPath = blobMetadata.getPartitionId();\n-    azureMetrics.blobDeleteRequestCount.inc();\n+  public int purgeBlobs(List<CloudBlobMetadata> blobMetadataList) throws CloudStorageException {\n+    if (blobMetadataList.isEmpty()) {\n+      return 0;\n+    }\n+    azureMetrics.blobDeleteRequestCount.inc(blobMetadataList.size());\n     Timer.Context deleteTimer = azureMetrics.blobDeletionTime.time();\n     try {\n-      // delete blob from storage\n-      boolean deletionDone = azureBlobDataAccessor.deleteFile(containerName, blobFileName);\n-\n-      // Delete the document too\n-      try {\n-        cosmosDataAccessor.deleteMetadata(blobMetadata);\n-        deletionDone = true;\n-        logger.debug(\"Purged blob {} from partition {}.\", blobId, partitionPath);\n-      } catch (DocumentClientException dex) {\n-        if (dex.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n-          logger.warn(\"Could not find metadata for blob {} to delete\", blobId);\n-        } else {\n-          throw dex;\n-        }\n+      List<CloudBlobMetadata> deletedBlobs = azureBlobDataAccessor.purgeBlobs(blobMetadataList);\n+      azureMetrics.blobDeletedCount.inc(deletedBlobs.size());\n+      azureMetrics.blobDeleteErrorCount.inc(blobMetadataList.size() - deletedBlobs.size());\n+\n+      // Remove them from Cosmos too\n+      for (CloudBlobMetadata blobMetadata : deletedBlobs) {\n+        deleteFromCosmos(blobMetadata);\n       }\n-      azureMetrics.blobDeletedCount.inc(deletionDone ? 1 : 0);\n-      return deletionDone;\n-    } catch (Exception e) {\n-      azureMetrics.blobDeleteErrorCount.inc();\n-      String error = (e instanceof DocumentClientException) ? \"Failed to delete metadata document for blob \" + blobId\n-          : \"Failed to delete blob \" + blobId + \", storage path: \" + containerName + \"/\" + blobFileName;\n-      throw toCloudStorageException(error, e);\n+      return deletedBlobs.size();", "originalCommit": "0a174038358ca7cbeeb6389145131970c7e9bd5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyODk4Mw==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374328983", "bodyText": "Right.", "author": "lightningrob", "createdAt": "2020-02-03T20:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMzY4Mw==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374233683", "bodyText": "If we want to use guava directly in Ambry (I'm not against this since it has a lot of useful things), it might be good to explicitly reference the desired version in our build files. Interestingly, our dependencies seem to transitively bring in 3 versions of guava.", "author": "cgtz", "createdAt": "2020-02-03T17:23:17Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -32,12 +36,15 @@\n import com.github.ambry.commons.BlobId;\n import com.github.ambry.config.CloudConfig;\n import com.github.ambry.utils.Utils;\n+import com.google.common.collect.Lists;", "originalCommit": "0a174038358ca7cbeeb6389145131970c7e9bd5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzNTkxNA==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374235914", "bodyText": "If we decide not to use guava directly we can add a partition method to Utils.java (the impl is pretty simple), or just use List::subList", "author": "cgtz", "createdAt": "2020-02-03T17:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMzY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMyOTM3OA==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374329378", "bodyText": "Added Utils.partitionList() and refactored AzureCloudDestination.getBlobMetadata() to use it as well.", "author": "lightningrob", "createdAt": "2020-02-03T20:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIzMzY4Mw=="}], "type": "inlineReview"}, {"oid": "73c5d5935acc0bf9f0fcae9da577c951a676c69d", "url": "https://github.com/linkedin/ambry/commit/73c5d5935acc0bf9f0fcae9da577c951a676c69d", "message": "Moved list partitioning logic to Utils.partitionList()", "committedDate": "2020-02-03T20:39:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDExNA==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374474114", "bodyText": "could this loop be simplified to:\nfor (int start = 0; start < inputList.size(); start += batchSize) {\n  int end = Math.min(start + batchSize, inputList.size());\n  partitionedLists.add(inputList.subList(start, end));\n}\n\nI may be missing an edge case here though", "author": "cgtz", "createdAt": "2020-02-04T04:55:39Z", "path": "ambry-utils/src/main/java/com.github.ambry.utils/Utils.java", "diffHunk": "@@ -912,6 +913,30 @@ public static DataInputStream createDataInputStreamFromBuffer(Object buffer, boo\n         .collect(Collectors.toCollection(collectionFactory));\n   }\n \n+  /**\n+   * Partition the input list into a List of smaller sublists, each one limited to the specified batch size.\n+   * Method inspired by the Guava utility Lists.partition(List<T> list, int size).\n+   * @param inputList the input list to partition.\n+   * @param batchSize the maximum size of the returned sublists.\n+   * @return the partitioned list of sublists.\n+   */\n+  public static <T> List<List<T>> partitionList(List<T> inputList, int batchSize) {\n+    Objects.requireNonNull(inputList, \"Input list cannot be null\");\n+    if (batchSize < 1) {\n+      throw new IllegalArgumentException(\"Invalid batchSize: \" + batchSize);\n+    }\n+    List<List<T>> partitionedLists = new ArrayList<>();\n+    for (int j = 0; j < inputList.size() / batchSize + 1; j++) {", "originalCommit": "73c5d5935acc0bf9f0fcae9da577c951a676c69d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc0ODM2Mw==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374748363", "bodyText": "So I was thinking about this partition thing and it seems that we don't really need a full list and just need an iterable that we can do a for loop on. Something like this could work, I think:\n  public static <T> Iterable<List<T>> partition(List<T> list, int batchSize) {\n    return () -> new Iterator<List<T>>() {\n      int nextStart = 0;\n\n      @Override\n      public boolean hasNext() {\n        return nextStart < list.size();\n      }\n\n      @Override\n      public List<T> next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        int start = nextStart;\n        nextStart += batchSize;\n        return list.subList(start, Math.min(start + batchSize, list.size()));\n      }\n    };\n  }", "author": "cgtz", "createdAt": "2020-02-04T15:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2MDUxNw==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374960517", "bodyText": "I'm not sure this is a big improvement.  I prefer to mimic the guava utility.  Once we upgrade to a newer JDK, we can probably retire the utility and use the Collections one.", "author": "lightningrob", "createdAt": "2020-02-04T22:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NDEyNA==", "url": "https://github.com/linkedin/ambry/pull/1365#discussion_r374964124", "bodyText": "I made the simplification you suggested.", "author": "lightningrob", "createdAt": "2020-02-04T22:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NDExNA=="}], "type": "inlineReview"}, {"oid": "06e5b3f59fcbf7ffc8e14bb8a18ac8bc39d3ae5c", "url": "https://github.com/linkedin/ambry/commit/06e5b3f59fcbf7ffc8e14bb8a18ac8bc39d3ae5c", "message": "Simplify Utils.partitionList() per Casey's feedback.", "committedDate": "2020-02-04T22:37:49Z", "type": "commit"}]}