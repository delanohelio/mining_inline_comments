{"pr_number": 1358, "pr_title": "Add custom serializer to reduce size of CloudBlobMetadata", "pr_createdAt": "2020-01-15T01:08:22Z", "pr_url": "https://github.com/linkedin/ambry/pull/1358", "timeline": [{"oid": "e51d0bf4c6c17a9ff119ccd919be17307b22d80f", "url": "https://github.com/linkedin/ambry/commit/e51d0bf4c6c17a9ff119ccd919be17307b22d80f", "message": "Custom serializer to reduce size of CloudBlobMetadata\nRemove cloudBlobName field in favor of naming version", "committedDate": "2020-01-15T01:02:05Z", "type": "commit"}, {"oid": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "url": "https://github.com/linkedin/ambry/commit/3647502fd233b6b7860b0ea7c3a7dba90b86141b", "message": "Revert enabling of test", "committedDate": "2020-01-15T01:07:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MjYwNA==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r366982604", "bodyText": "could you explain the purpose of these constructors? Would the value passed in always be CloudBlobMetadata.class?", "author": "cgtz", "createdAt": "2020-01-15T16:40:34Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {", "originalCommit": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NjQyNQ==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367156425", "bodyText": "I removed this constructor.  It was in an example I looked at but doesn't seem to be needed here.  I guess it's used for base classes that have multiple derived classes with different serializations?", "author": "lightningrob", "createdAt": "2020-01-15T23:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MjYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4Mjc1MA==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r366982750", "bodyText": "what does passing a null type in mean?", "author": "cgtz", "createdAt": "2020-01-15T16:40:50Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);", "originalCommit": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NTA0Nw==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367155047", "bodyText": "The default constructor is required by the Jackson serializer.  The value passed to the super class doesn't seem to be used.  Regardless, I changed it to pass the actual class type.", "author": "lightningrob", "createdAt": "2020-01-15T23:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4Mjc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk5ODUxNA==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r366998514", "bodyText": "The javadocs for ObjectMapper say that the instance is thread safe and should be reused: https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/ObjectMapper.html. Could you make the ObjectMapper instance private static final?", "author": "cgtz", "createdAt": "2020-01-15T17:09:56Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();", "originalCommit": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2OTc4Mg==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367069782", "bodyText": "Yes, forgot to do that.", "author": "lightningrob", "createdAt": "2020-01-15T19:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk5ODUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwMTQyNw==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367001427", "bodyText": "This also seems a little inefficient that you have to convert to a json node and then iterate through it to go back to the map. I guess the alternative is manually constructing the map, but that has the tradeoff of more duplicate code.", "author": "cgtz", "createdAt": "2020-01-15T17:15:47Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;", "originalCommit": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzNTcwNA==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367135704", "bodyText": "I changed it to convert directly to a map.  It still does json serialization internally, so not as efficient as handcrafting the map.  But I prefer to avoid handcrafting since it's easy to forget to keep it in sync.", "author": "lightningrob", "createdAt": "2020-01-15T22:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwMTQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NjUxNg==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367696516", "bodyText": "cool, that TypeReference serializer seems useful.", "author": "cgtz", "createdAt": "2020-01-16T23:09:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwMTQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNTI3Ng==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367015276", "bodyText": "I wonder if there is any reason to set FIELD_ENCRYPTION_ORIGIN if the value is EncryptionOrigin.ROUTER? I can't think of an immediate need other than being able to write analytics queries to count # of encrypted blobs.", "author": "cgtz", "createdAt": "2020-01-15T17:43:33Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {\n+      super(t);\n+    }\n+\n+    @Override\n+    public void serialize(CloudBlobMetadata value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n+\n+      gen.writeStartObject();\n+      // Required fields\n+      gen.writeStringField(FIELD_ID, value.id);\n+      gen.writeStringField(FIELD_PARTITION_ID, value.partitionId);\n+      gen.writeNumberField(FIELD_ACCOUNT_ID, value.accountId);\n+      gen.writeNumberField(FIELD_CONTAINER_ID, value.containerId);\n+      gen.writeNumberField(FIELD_SIZE, value.size);\n+      // Optional fields with default values to exclude\n+      if (value.creationTime > 0) {\n+        gen.writeNumberField(FIELD_CREATION_TIME, value.creationTime);\n+      }\n+      if (value.uploadTime > 0) {\n+        gen.writeNumberField(FIELD_UPLOAD_TIME, value.uploadTime);\n+      }\n+      if (value.deletionTime > 0) {\n+        gen.writeNumberField(FIELD_DELETION_TIME, value.deletionTime);\n+      }\n+      if (value.expirationTime > 0) {\n+        gen.writeNumberField(FIELD_EXPIRATION_TIME, value.expirationTime);\n+      }\n+      if (value.namingScheme > 0) {\n+        gen.writeNumberField(FIELD_NAMING_SCHEME, value.namingScheme);\n+      }\n+      // Encryption fields that may or may not apply\n+      if (value.encryptionOrigin == EncryptionOrigin.VCR) {\n+        gen.writeStringField(FIELD_ENCRYPTION_ORIGIN, value.encryptionOrigin.toString());", "originalCommit": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MDE2Nw==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367070167", "bodyText": "Good point, I'll include that.", "author": "lightningrob", "createdAt": "2020-01-15T19:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyODgxMQ==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367028811", "bodyText": "Instead of adding a new constructor to CloudBlobMetadata just for this purpose, could you just call getClusterAwareAzureContainerName(blobID.getPartitionId().toPathString())?", "author": "cgtz", "createdAt": "2020-01-15T18:12:53Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -364,24 +363,55 @@ private BlobContainerClient getContainer(String containerName, boolean autoCreat\n   }\n \n   /**\n-   * @return the name of the Azure storage container where blobs in the specified partition are stored.\n-   * @param partitionPath the lexical path of the Ambry partition.\n+   * @return the name of the Azure storage container to store the specified blob.\n+   * @param blobId the id of the blob to store.\n    */\n-  private String getAzureContainerName(String partitionPath) {\n+  String getAzureContainerName(BlobId blobId) {\n+    return getAzureContainerName(new CloudBlobMetadata(blobId));", "originalCommit": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MDU4OQ==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367070589", "bodyText": "I want to make the implementation more flexible, to use partition, account/container, etc.", "author": "lightningrob", "createdAt": "2020-01-15T19:42:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyODgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyOTE4NA==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367029184", "bodyText": "Is this constructor only for the getAzureContainerName method?", "author": "cgtz", "createdAt": "2020-01-15T18:13:39Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -75,6 +97,14 @@\n   public CloudBlobMetadata() {\n   }\n \n+  /**\n+   * Constructor from {@link BlobId}.  All other metadata are ignored.\n+   * @param blobId The BlobId for metadata record.\n+   */\n+  public CloudBlobMetadata(BlobId blobId) {", "originalCommit": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MjM5MQ==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367072391", "bodyText": "Yes, it might be overkill.  I can remove it.", "author": "lightningrob", "createdAt": "2020-01-15T19:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyOTE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MDMzMw==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367050333", "bodyText": "minor, but it may be worth making these constants into an unmodifiable list so they won't be tampered with.\npublic static final List<String> REQUIRED_FIELDS = Collections.unmodifiableList(Arrays.asList(FIELD_ID, FIELD_ACCOUNT_ID, ...))", "author": "cgtz", "createdAt": "2020-01-15T18:58:52Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -14,27 +14,49 @@\n package com.github.ambry.cloud;\n \n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.github.ambry.commons.BlobId;\n import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Objects;\n \n \n /**\n  * Blob metadata document POJO class.\n  */\n+@JsonSerialize(using = CloudBlobMetadata.MetadataSerializer.class)\n+@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n public class CloudBlobMetadata {\n+  public static final String FIELD_ID = \"id\";\n+  public static final String FIELD_PARTITION_ID = \"partitionId\";\n+  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n+  public static final String FIELD_CONTAINER_ID = \"containerId\";\n+  public static final String FIELD_SIZE = \"size\";\n   public static final String FIELD_CREATION_TIME = \"creationTime\";\n   public static final String FIELD_UPLOAD_TIME = \"uploadTime\";\n   public static final String FIELD_DELETION_TIME = \"deletionTime\";\n   public static final String FIELD_EXPIRATION_TIME = \"expirationTime\";\n-  public static final String FIELD_ACCOUNT_ID = \"accountId\";\n-  public static final String FIELD_CONTAINER_ID = \"containerId\";\n   public static final String FIELD_ENCRYPTION_ORIGIN = \"encryptionOrigin\";\n   public static final String FIELD_VCR_KMS_CONTEXT = \"vcrKmsContext\";\n   public static final String FIELD_CRYPTO_AGENT_FACTORY = \"cryptoAgentFactory\";\n-  public static final String FIELD_CLOUD_BLOB_NAME = \"cloudBlobName\";\n+  public static final String FIELD_ENCRYPTED_SIZE = \"encryptedSize\";\n+  public static final String FIELD_NAMING_SCHEME = \"namingScheme\";\n+\n+  public static final String[] REQUIRED_FIELDS =\n+      new String[]{FIELD_ID, FIELD_ACCOUNT_ID, FIELD_CONTAINER_ID, FIELD_PARTITION_ID, FIELD_SIZE, FIELD_UPLOAD_TIME};", "originalCommit": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3MjcyOA==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367072728", "bodyText": "Can a final array be tampered with?", "author": "lightningrob", "createdAt": "2020-01-15T19:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MDMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5ODgzNg==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367698836", "bodyText": "Yep, only the reference to the array is immutable but the items inside the array may be changed.\npublic class FinalArray {\n  private static class ArrayHolder {\n    static final String[] ARRAY = {\"a\", \"b\", \"c\"};\n  }\n  public static void main(String[] args) {\n    System.out.println(Arrays.toString(ArrayHolder.ARRAY));\n    ArrayHolder.ARRAY[2] = \"d\";\n    System.out.println(Arrays.toString(ArrayHolder.ARRAY));\n  }\n}\nOutput:\n[a, b, c]\n[a, b, d]", "author": "cgtz", "createdAt": "2020-01-16T23:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MDMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2MjUzMg==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368062532", "bodyText": "Yeah, that's true.  For now, I moved these arrays to the test class since they weren't being used anywhere else.", "author": "lightningrob", "createdAt": "2020-01-17T17:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MDMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MTIwMw==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367051203", "bodyText": "should these time fields be >= 0, since technically 0 could be a valid timestamp?", "author": "cgtz", "createdAt": "2020-01-15T19:00:48Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -399,8 +420,72 @@ public boolean equals(Object o) {\n       return false;\n     }\n     CloudBlobMetadata om = (CloudBlobMetadata) o;\n-    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && creationTime == om.creationTime\n+    return (Objects.equals(id, om.id) && Objects.equals(partitionId, om.partitionId) && accountId == om.accountId\n+        && containerId == om.containerId && size == om.size && creationTime == om.creationTime\n         && uploadTime == om.uploadTime && expirationTime == om.expirationTime && deletionTime == om.deletionTime\n-        && size == om.size && accountId == om.accountId && containerId == om.containerId);\n+        && namingScheme == om.namingScheme && encryptionOrigin == om.encryptionOrigin && Objects.equals(vcrKmsContext,\n+        om.vcrKmsContext) && Objects.equals(cryptoAgentFactory, om.cryptoAgentFactory)\n+        && encryptedSize == om.encryptedSize);\n+  }\n+\n+  /**\n+   * @return a {@link HashMap} of metadata key-value pairs.\n+   */\n+  public HashMap<String, String> toMap() {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    HashMap<String, String> map = new HashMap<>();\n+    ObjectNode node = objectMapper.convertValue(this, ObjectNode.class);\n+    node.fieldNames().forEachRemaining(fieldName -> {\n+      map.put(fieldName, node.get(fieldName).asText());\n+    });\n+    return map;\n+  }\n+\n+  /** Custom serializer for CloudBlobMetadata class that omits fields with default values. */\n+  static class MetadataSerializer extends StdSerializer<CloudBlobMetadata> {\n+\n+    public MetadataSerializer() {\n+      this(null);\n+    }\n+\n+    public MetadataSerializer(Class<CloudBlobMetadata> t) {\n+      super(t);\n+    }\n+\n+    @Override\n+    public void serialize(CloudBlobMetadata value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n+\n+      gen.writeStartObject();\n+      // Required fields\n+      gen.writeStringField(FIELD_ID, value.id);\n+      gen.writeStringField(FIELD_PARTITION_ID, value.partitionId);\n+      gen.writeNumberField(FIELD_ACCOUNT_ID, value.accountId);\n+      gen.writeNumberField(FIELD_CONTAINER_ID, value.containerId);\n+      gen.writeNumberField(FIELD_SIZE, value.size);\n+      // Optional fields with default values to exclude\n+      if (value.creationTime > 0) {\n+        gen.writeNumberField(FIELD_CREATION_TIME, value.creationTime);\n+      }\n+      if (value.uploadTime > 0) {\n+        gen.writeNumberField(FIELD_UPLOAD_TIME, value.uploadTime);\n+      }\n+      if (value.deletionTime > 0) {", "originalCommit": "3647502fd233b6b7860b0ea7c3a7dba90b86141b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzNjA5Nw==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r367136097", "bodyText": "I don't see any practical use case for 0 to be a valid timestamp.", "author": "lightningrob", "createdAt": "2020-01-15T22:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MTIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2ODY1NQ==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368068655", "bodyText": "That is true, unless a time traveler from 1970 uploads a blob. We can keep this as is", "author": "cgtz", "createdAt": "2020-01-17T18:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1MTIwMw=="}], "type": "inlineReview"}, {"oid": "924341da1b110971eac32d63848ea10694ab9545", "url": "https://github.com/linkedin/ambry/commit/924341da1b110971eac32d63848ea10694ab9545", "message": "Merge branch 'master' of github.com:linkedin/ambry into blobmetadata-reduction", "committedDate": "2020-01-15T19:44:04Z", "type": "commit"}, {"oid": "0c0d210b027b480f1c6b1460ba659681f7a6d4ca", "url": "https://github.com/linkedin/ambry/commit/0c0d210b027b480f1c6b1460ba659681f7a6d4ca", "message": "Address Casey's review comments.", "committedDate": "2020-01-15T22:11:20Z", "type": "commit"}, {"oid": "05b1ae5e45a81d4232c29c735764f764787041d6", "url": "https://github.com/linkedin/ambry/commit/05b1ae5e45a81d4232c29c735764f764787041d6", "message": "Include encryptionOrigin in serialization when value is ROUTER", "committedDate": "2020-01-15T23:05:59Z", "type": "commit"}, {"oid": "a7686f628cb07f8581ce104efe894e0b3f390efb", "url": "https://github.com/linkedin/ambry/commit/a7686f628cb07f8581ce104efe894e0b3f390efb", "message": "Removed unneded constructor", "committedDate": "2020-01-15T23:11:51Z", "type": "commit"}, {"oid": "75fa5562932cec3e9e9c11b841c760d638a93d5f", "url": "https://github.com/linkedin/ambry/commit/75fa5562932cec3e9e9c11b841c760d638a93d5f", "message": "Remove static arrays from prod class\nAdd JsonIgnoreProperties to allow removal of fields from schema", "committedDate": "2020-01-17T17:54:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NTA0MQ==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368085041", "bodyText": "javadocs missing.", "author": "ankagrawal", "createdAt": "2020-01-17T18:53:31Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -303,20 +321,12 @@ public CloudBlobMetadata setVcrKmsContext(String vcrKmsContext) {\n     return this;\n   }\n \n-  /**\n-   * @return the blob's name in cloud.\n-   */\n-  public String getCloudBlobName() {\n-    return cloudBlobName;\n+  public int getNamingScheme() {", "originalCommit": "75fa5562932cec3e9e9c11b841c760d638a93d5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NTUxNQ==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368085515", "bodyText": "javadocs missing.", "author": "ankagrawal", "createdAt": "2020-01-17T18:54:39Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -303,20 +321,12 @@ public CloudBlobMetadata setVcrKmsContext(String vcrKmsContext) {\n     return this;\n   }\n \n-  /**\n-   * @return the blob's name in cloud.\n-   */\n-  public String getCloudBlobName() {\n-    return cloudBlobName;\n+  public int getNamingScheme() {\n+    return namingScheme;\n   }\n \n-  /**\n-   * Sets blob's name in cloud.\n-   * @param cloudBlobName the blob's name in cloud.\n-   * @return this instance.\n-   */\n-  public CloudBlobMetadata setCloudBlobName(String cloudBlobName) {\n-    this.cloudBlobName = cloudBlobName;\n+  public CloudBlobMetadata setNamingScheme(int namingScheme) {", "originalCommit": "75fa5562932cec3e9e9c11b841c760d638a93d5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NjY0Mw==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368086643", "bodyText": "what does namingScheme represent?", "author": "ankagrawal", "createdAt": "2020-01-17T18:57:16Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/CloudBlobMetadata.java", "diffHunk": "@@ -43,12 +63,12 @@\n   private long size;\n   private int accountId;\n   private int containerId;\n-  private long expirationTime;\n-  private long deletionTime;\n-  private EncryptionOrigin encryptionOrigin;\n+  private long expirationTime = Utils.Infinite_Time;\n+  private long deletionTime = Utils.Infinite_Time;\n+  private int namingScheme = 0;", "originalCommit": "75fa5562932cec3e9e9c11b841c760d638a93d5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1NDc1OA==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368154758", "bodyText": "Renaming to nameSchemeVersion.  It's the version of the scheme used to derive the blob name in Azure storage.  Version 0 (default) will be the scheme we use now.  It lets us remove cloudBlobName from the metadata record which take up a lot of space.", "author": "lightningrob", "createdAt": "2020-01-17T22:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NjY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4OTYzNw==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368089637", "bodyText": "Looks like we are passing blobid to this method now (instead of partitionID as earlier), and then creating CloudBlobMetadata object out of it, but only really using partitionId eventually. Unless I missed something, do we really need these changes?", "author": "ankagrawal", "createdAt": "2020-01-17T19:04:49Z", "path": "ambry-cloud/src/main/java/com.github.ambry.cloud/azure/AzureBlobDataAccessor.java", "diffHunk": "@@ -364,24 +363,56 @@ private BlobContainerClient getContainer(String containerName, boolean autoCreat\n   }\n \n   /**\n-   * @return the name of the Azure storage container where blobs in the specified partition are stored.\n-   * @param partitionPath the lexical path of the Ambry partition.\n+   * @return the name of the Azure storage container to store the specified blob.\n+   * @param blobId the id of the blob to store.\n    */\n-  private String getAzureContainerName(String partitionPath) {\n+  String getAzureContainerName(BlobId blobId) {", "originalCommit": "75fa5562932cec3e9e9c11b841c760d638a93d5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1NDI4NQ==", "url": "https://github.com/linkedin/ambry/pull/1358#discussion_r368154285", "bodyText": "This is to support deriving the Azure container name from either the blob's partition (for backup) or the account/container (for live).", "author": "lightningrob", "createdAt": "2020-01-17T22:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4OTYzNw=="}], "type": "inlineReview"}, {"oid": "7cd1fd3e8baa54fc3d77d1a6b426cb273e6ca455", "url": "https://github.com/linkedin/ambry/commit/7cd1fd3e8baa54fc3d77d1a6b426cb273e6ca455", "message": "Address Ankur's review comments.", "committedDate": "2020-01-17T22:04:38Z", "type": "commit"}]}