{"pr_number": 1351, "pr_title": "Add HTTP2 port type and generalize ConnectedChannel", "pr_createdAt": "2020-01-06T20:53:27Z", "pr_url": "https://github.com/linkedin/ambry/pull/1351", "timeline": [{"oid": "723d20cf747229aa19535527fc876dddeddeb06a", "url": "https://github.com/linkedin/ambry/commit/723d20cf747229aa19535527fc876dddeddeb06a", "message": "Add HTTP2 port type and generalize ConnectedChannel\n\nAdd HTTP2 port type.\nRefactor ConnectedChannel interface to adopt Http2BlockingChannel.\nAdd Http2BlockingChannel for test.", "committedDate": "2020-01-06T20:50:14Z", "type": "commit"}, {"oid": "6fe7cc0de5df34239f7fe37df164f10263f09161", "url": "https://github.com/linkedin/ambry/commit/6fe7cc0de5df34239f7fe37df164f10263f09161", "message": "remove system.out", "committedDate": "2020-01-06T21:20:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQzNzA0MA==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364437040", "bodyText": "Perhaps a CloudDataNode should have the same support for http2 that AmbryDataNode does, since it corresponds to a VCR which will eventually support http2 transport.", "author": "cgtz", "createdAt": "2020-01-08T20:50:52Z", "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/CloudDataNode.java", "diffHunk": "@@ -94,6 +94,16 @@ public boolean hasSSLPort() {\n     return sslPort != null;\n   }\n \n+  @Override\n+  public int getHttp2Port() {\n+    return -1;", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQzNzU3MA==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364437570", "bodyText": "same comment for DataNode since this is the static clustermap analog to AmbryDataNode. This would require adding an \"http2port\" field to the json schema", "author": "cgtz", "createdAt": "2020-01-08T20:52:10Z", "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/DataNode.java", "diffHunk": "@@ -111,6 +111,16 @@ public boolean hasSSLPort() {\n     return ports.containsKey(PortType.SSL);\n   }\n \n+  @Override\n+  public int getHttp2Port() {\n+    return -1;", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzMzIzMg==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364533232", "bodyText": "Could you explain the difference between this factory and NettySslFactory in the docs (i.e. alpn)?", "author": "cgtz", "createdAt": "2020-01-09T02:20:19Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettySslHttp2Factory.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.commons.JdkSslFactory;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.handler.codec.http2.Http2SecurityUtil;\n+import io.netty.handler.ssl.ApplicationProtocolConfig;\n+import io.netty.handler.ssl.ApplicationProtocolNames;\n+import io.netty.handler.ssl.SslContext;\n+import io.netty.handler.ssl.SslContextBuilder;\n+import io.netty.handler.ssl.SupportedCipherSuiteFilter;\n+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n+import io.netty.handler.ssl.util.SelfSignedCertificate;\n+import java.io.IOException;\n+import java.security.GeneralSecurityException;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLParameters;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.rest.NettySslFactory.*;\n+\n+\n+/**\n+ * An HTTP/2 specific implementation of {@link SSLFactory} that uses Netty's SSL libraries for HTTP2.\n+ * This has the benefit of using OpenSSL instead of JDK's SSL implementation when the netty-tcnative library is loaded.\n+ * OpenSSL shows significant performance enhancements over the JDK implementation.", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzMzYwNA==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364533604", "bodyText": "I think there may not be a valid case for supporting the getSSLContext() method for HTTP2, since it was mostly present so that BlockingChannelConnectionPool could use blocking SSLSockets instead of SSLEngines, but there won't be that need with HTTP2. Instead, getSSLContext() could just throw UnsupportedOperationException.", "author": "cgtz", "createdAt": "2020-01-09T02:22:03Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/NettySslHttp2Factory.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.commons.JdkSslFactory;\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.handler.codec.http2.Http2SecurityUtil;\n+import io.netty.handler.ssl.ApplicationProtocolConfig;\n+import io.netty.handler.ssl.ApplicationProtocolNames;\n+import io.netty.handler.ssl.SslContext;\n+import io.netty.handler.ssl.SslContextBuilder;\n+import io.netty.handler.ssl.SupportedCipherSuiteFilter;\n+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n+import io.netty.handler.ssl.util.SelfSignedCertificate;\n+import java.io.IOException;\n+import java.security.GeneralSecurityException;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLParameters;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.github.ambry.rest.NettySslFactory.*;\n+\n+\n+/**\n+ * An HTTP/2 specific implementation of {@link SSLFactory} that uses Netty's SSL libraries for HTTP2.\n+ * This has the benefit of using OpenSSL instead of JDK's SSL implementation when the netty-tcnative library is loaded.\n+ * OpenSSL shows significant performance enhancements over the JDK implementation.\n+ */\n+public class NettySslHttp2Factory implements SSLFactory {\n+  private static final Logger logger = LoggerFactory.getLogger(NettySslFactory.class);\n+  private final SslContext nettyServerSslContext;\n+  private final SslContext nettyClientSslContext;\n+  private final SSLContext jdkSslContext;\n+  private final String endpointIdentification;\n+\n+  /**\n+   * Instantiate a {@link NettySslFactory} from a config.\n+   * @param sslConfig the {@link SSLConfig} to use.\n+   * @throws GeneralSecurityException\n+   * @throws IOException\n+   */\n+  public NettySslHttp2Factory(SSLConfig sslConfig) throws GeneralSecurityException, IOException {\n+    nettyServerSslContext = getServerSslContext(sslConfig);\n+    nettyClientSslContext = getClientSslContext(sslConfig);\n+    // Netty's OpenSsl based implementation does not use the JDK SSLContext so we have to fall back to the JDK based\n+    // factory to support this method.\n+\n+    jdkSslContext = sslConfig.sslHttp2SelfSign ? null : new JdkSslFactory(sslConfig).getSSLContext();", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzNTMyMw==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364535323", "bodyText": "Could you add a disclaimer to the javadoc to mention that production systems should not use this option as it is relatively insecure.", "author": "cgtz", "createdAt": "2020-01-09T02:31:25Z", "path": "ambry-api/src/main/java/com.github.ambry/config/SSLConfig.java", "diffHunk": "@@ -145,6 +145,20 @@\n   @Default(\"com.github.ambry.commons.JdkSslFactory\")\n   public final String sslFactory;\n \n+  /**\n+   * The implementation of {@link com.github.ambry.commons.SSLFactory} to use.\n+   */\n+  @Config(\"ssl.http2.factory\")\n+  @Default(\"com.github.ambry.rest.NettySslHttp2Factory\")\n+  public final String sslHttp2Factory;\n+\n+  /**\n+   * Use self signed HTTP2 SSL certification if true.", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzNjQ1OQ==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364536459", "bodyText": "does this need to be implemented? For example, shutting down the EventLoopGroup?", "author": "cgtz", "createdAt": "2020-01-09T02:37:38Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.network.ChannelOutput;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.Send;\n+import com.github.ambry.rest.NettySslHttp2Factory;\n+import com.github.ambry.utils.ByteBufferChannel;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A HTTP2 implementation of {@link ConnectedChannel}\n+ */\n+public class Http2BlockingChannel implements ConnectedChannel {\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());\n+  private Channel channel;\n+  private Http2ResponseHandler http2ResponseHandler;\n+  private String hostName;\n+  private int port;\n+\n+  public Http2BlockingChannel(String hostName, int port) {\n+    http2ResponseHandler = new Http2ResponseHandler();\n+    this.hostName = hostName;\n+    this.port = port;\n+  }\n+\n+  @Override\n+  public void connect() throws IOException {\n+    Bootstrap b = new Bootstrap();\n+    b.group(new NioEventLoopGroup());\n+    b.channel(NioSocketChannel.class);\n+    b.option(ChannelOption.SO_KEEPALIVE, true);\n+    b.remoteAddress(hostName, port);\n+    SSLFactory sslFactory;\n+    try {\n+      sslFactory = new NettySslHttp2Factory(new SSLConfig(new VerifiableProperties(new Properties())));\n+    } catch (GeneralSecurityException e) {\n+      throw new IOException(e);\n+    }\n+    b.handler(new Http2ClientChannelInitializer(sslFactory, hostName, port));\n+\n+    // Start the client.\n+    channel = b.connect().syncUninterruptibly().channel();\n+    logger.info(\"Connected to remote host\");\n+  }\n+\n+  @Override\n+  public void disconnect() throws IOException {\n+", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzNjk5Mg==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364536992", "bodyText": "This or something similar may actually have to become production code in the future to support replication.", "author": "cgtz", "createdAt": "2020-01-09T02:40:55Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.network.ChannelOutput;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.Send;\n+import com.github.ambry.rest.NettySslHttp2Factory;\n+import com.github.ambry.utils.ByteBufferChannel;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A HTTP2 implementation of {@link ConnectedChannel}\n+ */\n+public class Http2BlockingChannel implements ConnectedChannel {", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzODEyMg==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364538122", "bodyText": "implement these 2 methods?", "author": "cgtz", "createdAt": "2020-01-09T02:46:42Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.network.ChannelOutput;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.Send;\n+import com.github.ambry.rest.NettySslHttp2Factory;\n+import com.github.ambry.utils.ByteBufferChannel;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A HTTP2 implementation of {@link ConnectedChannel}\n+ */\n+public class Http2BlockingChannel implements ConnectedChannel {\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());\n+  private Channel channel;\n+  private Http2ResponseHandler http2ResponseHandler;\n+  private String hostName;\n+  private int port;\n+\n+  public Http2BlockingChannel(String hostName, int port) {\n+    http2ResponseHandler = new Http2ResponseHandler();\n+    this.hostName = hostName;\n+    this.port = port;\n+  }\n+\n+  @Override\n+  public void connect() throws IOException {\n+    Bootstrap b = new Bootstrap();\n+    b.group(new NioEventLoopGroup());\n+    b.channel(NioSocketChannel.class);\n+    b.option(ChannelOption.SO_KEEPALIVE, true);\n+    b.remoteAddress(hostName, port);\n+    SSLFactory sslFactory;\n+    try {\n+      sslFactory = new NettySslHttp2Factory(new SSLConfig(new VerifiableProperties(new Properties())));\n+    } catch (GeneralSecurityException e) {\n+      throw new IOException(e);\n+    }\n+    b.handler(new Http2ClientChannelInitializer(sslFactory, hostName, port));\n+\n+    // Start the client.\n+    channel = b.connect().syncUninterruptibly().channel();\n+    logger.info(\"Connected to remote host\");\n+  }\n+\n+  @Override\n+  public void disconnect() throws IOException {\n+\n+  }\n+\n+  @Override\n+  public void send(Send request) throws IOException {\n+    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n+    while (!request.isSendComplete()) {\n+      request.writeTo(byteBufferChannel);\n+    }\n+    byteBufferChannel.getBuffer().position(0);\n+    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n+\n+    Http2ClientStreamInitializer initializer = new Http2ClientStreamInitializer(http2ResponseHandler);\n+    Http2StreamChannel childChannel =\n+        new Http2StreamChannelBootstrap(channel).handler(initializer).open().syncUninterruptibly().getNow();\n+    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+\n+    DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+    DefaultHttp2DataFrame dataFrame = new DefaultHttp2DataFrame(byteBuf, true);\n+    ChannelPromise childChannelPromise = childChannel.newPromise();\n+    childChannel.write(headersFrame);\n+    ChannelFuture channelFuture = childChannel.write(dataFrame);\n+    childChannel.flush();\n+    http2ResponseHandler.put(channelFuture, childChannelPromise);\n+  }\n+\n+  @Override\n+  public ChannelOutput receive() throws IOException {\n+    Http2ResponseHandler.StreamResult streamResult = http2ResponseHandler.awaitResponses(5, TimeUnit.SECONDS);\n+    DataInputStream dataInputStream = new NettyByteBufDataInputStream(streamResult.getByteBuf());\n+    return new ChannelOutput(dataInputStream, dataInputStream.readLong());\n+  }\n+\n+  @Override\n+  public String getRemoteHost() {\n+    return null;", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzODU4OA==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364538588", "bodyText": "Does this need to be public?", "author": "cgtz", "createdAt": "2020-01-09T02:49:24Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2ClientChannelInitializer.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class Http2ClientChannelInitializer extends ChannelInitializer<SocketChannel> {", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzODY0Mg==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364538642", "bodyText": "final when possible", "author": "cgtz", "createdAt": "2020-01-09T02:49:47Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.network.ChannelOutput;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.Send;\n+import com.github.ambry.rest.NettySslHttp2Factory;\n+import com.github.ambry.utils.ByteBufferChannel;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A HTTP2 implementation of {@link ConnectedChannel}\n+ */\n+public class Http2BlockingChannel implements ConnectedChannel {\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());\n+  private Channel channel;\n+  private Http2ResponseHandler http2ResponseHandler;", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzODkxNg==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364538916", "bodyText": "private?", "author": "cgtz", "createdAt": "2020-01-09T02:51:19Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2ClientChannelInitializer.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class Http2ClientChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final SSLFactory sslFactory;\n+  String host;\n+  int port;\n+\n+  /**\n+   * Construct a {@link Http2ClientChannelInitializer}.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public Http2ClientChannelInitializer(SSLFactory sslFactory, String host, int port) {\n+    this.host = host;\n+    this.port = port;\n+    this.sslFactory = sslFactory;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    ChannelPipeline pipeline = ch.pipeline();\n+    if (sslFactory == null) {\n+      throw new IllegalArgumentException(\"ssl factory shouldn't be null\");\n+    }\n+    SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(host, port, SSLFactory.Mode.CLIENT));\n+    pipeline.addLast(sslHandler);\n+    pipeline.addLast(Http2FrameCodecBuilder.forClient().build());\n+    pipeline.addLast(new Http2MultiplexHandler(new DummyChildHandler()));\n+  }\n+\n+  public class DummyChildHandler extends ChannelInboundHandlerAdapter {", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzODkzNw==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r364538937", "bodyText": "private/final?", "author": "cgtz", "createdAt": "2020-01-09T02:51:26Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2ClientChannelInitializer.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+public class Http2ClientChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final SSLFactory sslFactory;\n+  String host;", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NDY4Ng==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r365474686", "bodyText": "does this currently support a single stream per connection at a time? I guess for the integration tests, this should suffice for now.", "author": "cgtz", "createdAt": "2020-01-10T23:54:23Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2ResponseHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.github.ambry.server;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http2.HttpConversionUtil;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames\n+ */\n+@ChannelHandler.Sharable\n+public class Http2ResponseHandler extends SimpleChannelInboundHandler<FullHttpResponse> {\n+\n+  protected final Logger logger = LoggerFactory.getLogger(getClass());\n+  private StreamResult streamResult;\n+\n+  public Http2ResponseHandler() {\n+\n+  }\n+\n+  /**\n+   * Track the {@link ChannelFuture} and {@link ChannelPromise}\n+   *\n+   * @param writeFuture A future that represent the request write operation\n+   * @param promise The promise object that will be used to wait/notify events\n+   * @return The previous object associated with {@code streamId}\n+   * @see Http2ResponseHandler#awaitResponses(long, TimeUnit)\n+   */\n+  public void put(ChannelFuture writeFuture, ChannelPromise promise) {\n+    streamResult = new StreamResult(writeFuture, promise);", "originalCommit": "6fe7cc0de5df34239f7fe37df164f10263f09161", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTEzOA==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r365479138", "bodyText": "Yes, one stream per connection at a time. For test only now. Will improve it once we get enough client knowledge/experience.", "author": "zzmao", "createdAt": "2020-01-11T00:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NDY4Ng=="}], "type": "inlineReview"}, {"oid": "b7a68374a6266d4897f3ce1e8da09dbe402ee965", "url": "https://github.com/linkedin/ambry/commit/b7a68374a6266d4897f3ce1e8da09dbe402ee965", "message": "Address comments", "committedDate": "2020-01-13T19:47:31Z", "type": "commit"}, {"oid": "37d2c2292e321034e4759f34e856fc461b639cb6", "url": "https://github.com/linkedin/ambry/commit/37d2c2292e321034e4759f34e856fc461b639cb6", "message": "update validate port", "committedDate": "2020-01-13T23:31:34Z", "type": "commit"}, {"oid": "57c7106b8df2c3ae9690a2c0d0a3e3b216b9546f", "url": "https://github.com/linkedin/ambry/commit/57c7106b8df2c3ae9690a2c0d0a3e3b216b9546f", "message": "fix test failure", "committedDate": "2020-01-14T00:19:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MjY4MQ==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r366682681", "bodyText": "This is designed to be a blocking channel where only one http request can be sent and received at a time. This is not really how we will use http2. So this is a just a test class that will never be used in production?", "author": "justinlin-linkedin", "createdAt": "2020-01-15T03:34:16Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.network.ChannelOutput;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.Send;\n+import com.github.ambry.rest.NettySslHttp2Factory;\n+import com.github.ambry.utils.ByteBufferChannel;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n+ * to support replication in the future.\n+ */\n+public class Http2BlockingChannel implements ConnectedChannel {", "originalCommit": "57c7106b8df2c3ae9690a2c0d0a3e3b216b9546f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDUxOQ==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r367030519", "bodyText": "Replication also uses Blocking Channel, so we will use it in the future. But not this version, it will be improved.", "author": "zzmao", "createdAt": "2020-01-15T18:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MjY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MzU5NA==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r366683594", "bodyText": "this is weird given that we have initialized the handler in the connect method. It seems like all we need from connect method is just a functional channel so we can build a http2 stream handler on top of that channel?", "author": "justinlin-linkedin", "createdAt": "2020-01-15T03:39:36Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.network.ChannelOutput;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.Send;\n+import com.github.ambry.rest.NettySslHttp2Factory;\n+import com.github.ambry.utils.ByteBufferChannel;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n+ * to support replication in the future.\n+ */\n+public class Http2BlockingChannel implements ConnectedChannel {\n+  private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n+  private final Http2ResponseHandler http2ResponseHandler;\n+  private final String hostName;\n+  private final int port;\n+  private EventLoopGroup workerGroup;\n+  private Channel channel;\n+\n+  public Http2BlockingChannel(String hostName, int port) {\n+    http2ResponseHandler = new Http2ResponseHandler();\n+    this.hostName = hostName;\n+    this.port = port;\n+  }\n+\n+  @Override\n+  public void connect() throws IOException {\n+    workerGroup = new NioEventLoopGroup();\n+    Bootstrap b = new Bootstrap();\n+    b.group(workerGroup);\n+    b.channel(NioSocketChannel.class);\n+    b.option(ChannelOption.SO_KEEPALIVE, true);\n+    b.remoteAddress(hostName, port);\n+    SSLFactory sslFactory;\n+    try {\n+      sslFactory = new NettySslHttp2Factory(new SSLConfig(new VerifiableProperties(new Properties())));\n+    } catch (GeneralSecurityException e) {\n+      throw new IOException(e);\n+    }\n+    b.handler(new Http2ClientChannelInitializer(sslFactory, hostName, port));\n+\n+    // Start the client.\n+    channel = b.connect().syncUninterruptibly().channel();\n+    logger.info(\"Connected to remote host\");\n+  }\n+\n+  @Override\n+  public void disconnect() throws IOException {\n+    channel.disconnect().syncUninterruptibly();\n+    workerGroup.shutdownGracefully();\n+  }\n+\n+  @Override\n+  public void send(Send request) throws IOException {\n+    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n+    while (!request.isSendComplete()) {\n+      request.writeTo(byteBufferChannel);\n+    }\n+    byteBufferChannel.getBuffer().position(0);\n+    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n+\n+    Http2ClientStreamInitializer initializer = new Http2ClientStreamInitializer(http2ResponseHandler);\n+    Http2StreamChannel childChannel =\n+        new Http2StreamChannelBootstrap(channel).handler(initializer).open().syncUninterruptibly().getNow();", "originalCommit": "57c7106b8df2c3ae9690a2c0d0a3e3b216b9546f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDg0OQ==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r367030849", "bodyText": "yes, http2 stream channel is a child channel of http2 connection channel.", "author": "zzmao", "createdAt": "2020-01-15T18:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4NDQzMA==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r366684430", "bodyText": "why do we need a promise here? childChannel should write headerFrame and dataFrame in order. We can avoid one of them by just checking the second write's future.", "author": "justinlin-linkedin", "createdAt": "2020-01-15T03:44:21Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2BlockingChannel.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.network.ChannelOutput;\n+import com.github.ambry.network.ConnectedChannel;\n+import com.github.ambry.network.Send;\n+import com.github.ambry.rest.NettySslHttp2Factory;\n+import com.github.ambry.utils.ByteBufferChannel;\n+import com.github.ambry.utils.NettyByteBufDataInputStream;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http2.DefaultHttp2DataFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2Headers;\n+import io.netty.handler.codec.http2.DefaultHttp2HeadersFrame;\n+import io.netty.handler.codec.http2.Http2Headers;\n+import io.netty.handler.codec.http2.Http2StreamChannel;\n+import io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.util.Properties;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A HTTP2 implementation of {@link ConnectedChannel}. This implementation is for test now. It will be imporved to\n+ * to support replication in the future.\n+ */\n+public class Http2BlockingChannel implements ConnectedChannel {\n+  private static final Logger logger = LoggerFactory.getLogger(Http2BlockingChannel.class);\n+  private final Http2ResponseHandler http2ResponseHandler;\n+  private final String hostName;\n+  private final int port;\n+  private EventLoopGroup workerGroup;\n+  private Channel channel;\n+\n+  public Http2BlockingChannel(String hostName, int port) {\n+    http2ResponseHandler = new Http2ResponseHandler();\n+    this.hostName = hostName;\n+    this.port = port;\n+  }\n+\n+  @Override\n+  public void connect() throws IOException {\n+    workerGroup = new NioEventLoopGroup();\n+    Bootstrap b = new Bootstrap();\n+    b.group(workerGroup);\n+    b.channel(NioSocketChannel.class);\n+    b.option(ChannelOption.SO_KEEPALIVE, true);\n+    b.remoteAddress(hostName, port);\n+    SSLFactory sslFactory;\n+    try {\n+      sslFactory = new NettySslHttp2Factory(new SSLConfig(new VerifiableProperties(new Properties())));\n+    } catch (GeneralSecurityException e) {\n+      throw new IOException(e);\n+    }\n+    b.handler(new Http2ClientChannelInitializer(sslFactory, hostName, port));\n+\n+    // Start the client.\n+    channel = b.connect().syncUninterruptibly().channel();\n+    logger.info(\"Connected to remote host\");\n+  }\n+\n+  @Override\n+  public void disconnect() throws IOException {\n+    channel.disconnect().syncUninterruptibly();\n+    workerGroup.shutdownGracefully();\n+  }\n+\n+  @Override\n+  public void send(Send request) throws IOException {\n+    ByteBufferChannel byteBufferChannel = new ByteBufferChannel(ByteBuffer.allocate((int) request.sizeInBytes()));\n+    while (!request.isSendComplete()) {\n+      request.writeTo(byteBufferChannel);\n+    }\n+    byteBufferChannel.getBuffer().position(0);\n+    ByteBuf byteBuf = Unpooled.wrappedBuffer(byteBufferChannel.getBuffer());\n+\n+    Http2ClientStreamInitializer initializer = new Http2ClientStreamInitializer(http2ResponseHandler);\n+    Http2StreamChannel childChannel =\n+        new Http2StreamChannelBootstrap(channel).handler(initializer).open().syncUninterruptibly().getNow();\n+    Http2Headers http2Headers = new DefaultHttp2Headers().method(HttpMethod.POST.asciiName()).scheme(\"https\").path(\"/\");\n+\n+    DefaultHttp2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(http2Headers, false);\n+    DefaultHttp2DataFrame dataFrame = new DefaultHttp2DataFrame(byteBuf, true);\n+    ChannelPromise childChannelPromise = childChannel.newPromise();\n+    childChannel.write(headersFrame);\n+    ChannelFuture channelFuture = childChannel.write(dataFrame);\n+    childChannel.flush();\n+    http2ResponseHandler.put(channelFuture, childChannelPromise);", "originalCommit": "57c7106b8df2c3ae9690a2c0d0a3e3b216b9546f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNDE0Mg==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r367034142", "bodyText": "channelFuture = childChannel.write(dataFrame)\nThis future is ready when write done(send out), but we need a response comes back. childChannelPromise is set to be ready when response comes back.", "author": "zzmao", "createdAt": "2020-01-15T18:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4NDQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE3ODMwMA==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r367178300", "bodyText": "just new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()) would do.", "author": "justinlin-linkedin", "createdAt": "2020-01-16T00:34:30Z", "path": "ambry-server/src/test/java/com.github.ambry.server/Http2ClientChannelInitializer.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.server;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n+ * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ */\n+class Http2ClientChannelInitializer extends ChannelInitializer<SocketChannel> {\n+  private final SSLFactory sslFactory;\n+  private final String host;\n+  private final int port;\n+\n+  /**\n+   * Construct a {@link Http2ClientChannelInitializer}.\n+   * @param sslFactory the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public Http2ClientChannelInitializer(SSLFactory sslFactory, String host, int port) {\n+    this.host = host;\n+    this.port = port;\n+    this.sslFactory = sslFactory;\n+  }\n+\n+  @Override\n+  protected void initChannel(SocketChannel ch) throws Exception {\n+    ChannelPipeline pipeline = ch.pipeline();\n+    if (sslFactory == null) {\n+      throw new IllegalArgumentException(\"ssl factory shouldn't be null\");\n+    }\n+    SslHandler sslHandler = new SslHandler(sslFactory.createSSLEngine(host, port, SSLFactory.Mode.CLIENT));\n+    pipeline.addLast(sslHandler);\n+    pipeline.addLast(Http2FrameCodecBuilder.forClient().build());\n+    pipeline.addLast(new Http2MultiplexHandler(new DummyChildHandler()));", "originalCommit": "57c7106b8df2c3ae9690a2c0d0a3e3b216b9546f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MTMxMA==", "url": "https://github.com/linkedin/ambry/pull/1351#discussion_r367161310", "bodyText": "Up to you, but do you want to add this cleaner error handling to AmbryDataNode?", "author": "cgtz", "createdAt": "2020-01-15T23:29:42Z", "path": "ambry-clustermap/src/main/java/com.github.ambry.clustermap/CloudDataNode.java", "diffHunk": "@@ -84,14 +87,32 @@ public int getPort() {\n     return plainTextPort.getPort();\n   }\n \n+  @Override\n+  public boolean hasSSLPort() {\n+    return sslPort != null;\n+  }\n+\n   @Override\n   public int getSSLPort() {\n-    return sslPort.getPort();\n+    if (hasSSLPort()) {\n+      return sslPort.getPort();\n+    } else {\n+      throw new IllegalStateException(\"No SSL port exists for the Data Node \" + hostName + \":\" + plainTextPort);\n+    }\n   }\n \n   @Override\n-  public boolean hasSSLPort() {\n-    return sslPort != null;\n+  public boolean hasHttp2Port() {\n+    return http2Port != null;\n+  }\n+\n+  @Override\n+  public int getHttp2Port() {\n+    if (hasHttp2Port()) {\n+      return http2Port.getPort();\n+    } else {\n+      throw new IllegalStateException(\"No HTTP2 port exists for the Data Node \" + hostName + \":\" + plainTextPort);", "originalCommit": "57c7106b8df2c3ae9690a2c0d0a3e3b216b9546f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c2c13389df67d43eaed7bacc51066fccff0d93b6", "url": "https://github.com/linkedin/ambry/commit/c2c13389df67d43eaed7bacc51066fccff0d93b6", "message": "address minor comments", "committedDate": "2020-01-16T01:03:08Z", "type": "commit"}]}