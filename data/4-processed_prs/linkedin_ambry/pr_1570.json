{"pr_number": 1570, "pr_title": "Change sanity check logic for undelete so recovery can work", "pr_createdAt": "2020-06-18T00:16:18Z", "pr_url": "https://github.com/linkedin/ambry/pull/1570", "timeline": [{"oid": "b8de17f35c5379a5a4f9fe6f3446dd663c27a787", "url": "https://github.com/linkedin/ambry/commit/b8de17f35c5379a5a4f9fe6f3446dd663c27a787", "message": "Change sanity check logic for undelete", "committedDate": "2020-06-18T15:44:59Z", "type": "commit"}, {"oid": "854067eac86b6cac7d60499c195054f105d310a7", "url": "https://github.com/linkedin/ambry/commit/854067eac86b6cac7d60499c195054f105d310a7", "message": "Add more test", "committedDate": "2020-06-18T15:44:59Z", "type": "commit"}, {"oid": "efe7a2bc4ae8c922a640a1bf2479752b816ceff8", "url": "https://github.com/linkedin/ambry/commit/efe7a2bc4ae8c922a640a1bf2479752b816ceff8", "message": "typo", "committedDate": "2020-06-18T15:44:59Z", "type": "commit"}, {"oid": "54e37b00f018131c6154d5262103c70b47fdd59d", "url": "https://github.com/linkedin/ambry/commit/54e37b00f018131c6154d5262103c70b47fdd59d", "message": "Fix the test", "committedDate": "2020-06-18T15:44:59Z", "type": "commit"}, {"oid": "62ccc8693af1daff936bc398c25a08fa2f3fe523", "url": "https://github.com/linkedin/ambry/commit/62ccc8693af1daff936bc398c25a08fa2f3fe523", "message": "Rearrange", "committedDate": "2020-06-18T17:02:40Z", "type": "commit"}, {"oid": "62ccc8693af1daff936bc398c25a08fa2f3fe523", "url": "https://github.com/linkedin/ambry/commit/62ccc8693af1daff936bc398c25a08fa2f3fe523", "message": "Rearrange", "committedDate": "2020-06-18T17:02:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwNzk5OA==", "url": "https://github.com/linkedin/ambry/pull/1570#discussion_r442407998", "bodyText": "In this case, we still recovery Undelete index, but P can't be accessed, right?", "author": "zzmao", "createdAt": "2020-06-18T18:03:25Z", "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -980,35 +964,54 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, lon\n    * @throws StoreException if there is any problem writing the index record\n    */\n   IndexValue markAsUndeleted(StoreKey id, FileSpan fileSpan, long operationTimeMs) throws StoreException {\n-    return markAsUndeleted(id, fileSpan, operationTimeMs, MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n+    return markAsUndeleted(id, fileSpan, null, operationTimeMs, MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n   }\n \n   /**\n    * Marks a blob as undeleted\n    * @param id the {@link StoreKey} of the blob\n    * @param fileSpan the file span represented by this entry in the log\n    * @param operationTimeMs the time of the update operation\n+   * @param info this needs to be non-null in the case of recovery and replicateion. Can be {@code null} otherwise. Used if the PUT\n+   *             record could not be found\n    * @param lifeVersion lifeVersion of this undelete record.\n    * @return the {@link IndexValue} of the undelete record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  IndexValue markAsUndeleted(StoreKey id, FileSpan fileSpan, long operationTimeMs, short lifeVersion)\n+  IndexValue markAsUndeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs, short lifeVersion)\n       throws StoreException {\n     boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     validateFileSpan(fileSpan, true);\n+    long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     List<IndexValue> values =\n         findAllIndexValuesForKey(id, null, EnumSet.allOf(IndexEntryType.class), validIndexSegments);\n-    validateSanityForUndelete(id, values, lifeVersion);\n-    // This value is the delete IndexValue\n-    IndexValue value = values.get(0);\n-    maybeChangeExpirationDate(value, values);\n-    lifeVersion = hasLifeVersion ? lifeVersion : (short) (value.getLifeVersion() + 1);\n-    long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n-    IndexValue newValue =\n-        new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(), operationTimeMs,\n-            value.getAccountId(), value.getContainerId(), lifeVersion);\n-    newValue.setNewOffset(fileSpan.getStartOffset());\n-    newValue.setNewSize(size);\n+    IndexValue newValue;\n+    if (info != null) {\n+      // This is from recovery. In recovery, we don't need to do any sanity check because\n+      // 1. we already know the IndexValue has it's source in the log.\n+      // 2. some sanity check will fail.\n+      //    assume we have P, D, U, D in the log, then a compaction cycle compacted P and first D,", "originalCommit": "62ccc8693af1daff936bc398c25a08fa2f3fe523", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxMzkyMg==", "url": "https://github.com/linkedin/ambry/pull/1570#discussion_r442413922", "bodyText": "That's right. We used to think that when there is a U, there must be a P before U. This is wrong. After compaction, anything could happen. After compaction, in this case, we are left with only U and D, without any P. And recovery need to work for this case as well.", "author": "justinlin-linkedin", "createdAt": "2020-06-18T18:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwNzk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNTMwMA==", "url": "https://github.com/linkedin/ambry/pull/1570#discussion_r442425300", "bodyText": "typo: replication", "author": "jsjtzyy", "createdAt": "2020-06-18T18:35:22Z", "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -980,35 +964,54 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, lon\n    * @throws StoreException if there is any problem writing the index record\n    */\n   IndexValue markAsUndeleted(StoreKey id, FileSpan fileSpan, long operationTimeMs) throws StoreException {\n-    return markAsUndeleted(id, fileSpan, operationTimeMs, MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n+    return markAsUndeleted(id, fileSpan, null, operationTimeMs, MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n   }\n \n   /**\n    * Marks a blob as undeleted\n    * @param id the {@link StoreKey} of the blob\n    * @param fileSpan the file span represented by this entry in the log\n    * @param operationTimeMs the time of the update operation\n+   * @param info this needs to be non-null in the case of recovery and replicateion. Can be {@code null} otherwise. Used if the PUT", "originalCommit": "62ccc8693af1daff936bc398c25a08fa2f3fe523", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyMDg2Nw==", "url": "https://github.com/linkedin/ambry/pull/1570#discussion_r442520867", "bodyText": "minor: this can be more descriptive like invalid lifeVersion -1 (although I know this exception should not happen in practice)", "author": "jsjtzyy", "createdAt": "2020-06-18T21:47:45Z", "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -980,35 +964,54 @@ IndexValue markAsPermanent(StoreKey id, FileSpan fileSpan, MessageInfo info, lon\n    * @throws StoreException if there is any problem writing the index record\n    */\n   IndexValue markAsUndeleted(StoreKey id, FileSpan fileSpan, long operationTimeMs) throws StoreException {\n-    return markAsUndeleted(id, fileSpan, operationTimeMs, MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n+    return markAsUndeleted(id, fileSpan, null, operationTimeMs, MessageInfo.LIFE_VERSION_FROM_FRONTEND);\n   }\n \n   /**\n    * Marks a blob as undeleted\n    * @param id the {@link StoreKey} of the blob\n    * @param fileSpan the file span represented by this entry in the log\n    * @param operationTimeMs the time of the update operation\n+   * @param info this needs to be non-null in the case of recovery and replicateion. Can be {@code null} otherwise. Used if the PUT\n+   *             record could not be found\n    * @param lifeVersion lifeVersion of this undelete record.\n    * @return the {@link IndexValue} of the undelete record\n    * @throws StoreException if there is any problem writing the index record\n    */\n-  IndexValue markAsUndeleted(StoreKey id, FileSpan fileSpan, long operationTimeMs, short lifeVersion)\n+  IndexValue markAsUndeleted(StoreKey id, FileSpan fileSpan, MessageInfo info, long operationTimeMs, short lifeVersion)\n       throws StoreException {\n     boolean hasLifeVersion = IndexValue.hasLifeVersion(lifeVersion);\n     validateFileSpan(fileSpan, true);\n+    long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n     List<IndexValue> values =\n         findAllIndexValuesForKey(id, null, EnumSet.allOf(IndexEntryType.class), validIndexSegments);\n-    validateSanityForUndelete(id, values, lifeVersion);\n-    // This value is the delete IndexValue\n-    IndexValue value = values.get(0);\n-    maybeChangeExpirationDate(value, values);\n-    lifeVersion = hasLifeVersion ? lifeVersion : (short) (value.getLifeVersion() + 1);\n-    long size = fileSpan.getEndOffset().getOffset() - fileSpan.getStartOffset().getOffset();\n-    IndexValue newValue =\n-        new IndexValue(value.getSize(), value.getOffset(), value.getFlags(), value.getExpiresAtMs(), operationTimeMs,\n-            value.getAccountId(), value.getContainerId(), lifeVersion);\n-    newValue.setNewOffset(fileSpan.getStartOffset());\n-    newValue.setNewSize(size);\n+    IndexValue newValue;\n+    if (info != null) {\n+      // This is from recovery. In recovery, we don't need to do any sanity check because\n+      // 1. we already know the IndexValue has it's source in the log.\n+      // 2. some sanity check will fail.\n+      //    assume we have P, D, U, D in the log, then a compaction cycle compacted P and first D,\n+      //    then we only have U and second D. U in this case, will have no prior records.\n+      if (!hasLifeVersion) {\n+        throw new StoreException(\"MessageInfo of undelete carries invalid lifeVersion\",", "originalCommit": "62ccc8693af1daff936bc398c25a08fa2f3fe523", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNDUyNA==", "url": "https://github.com/linkedin/ambry/pull/1570#discussion_r442524524", "bodyText": "add a comment here to help understanding the context", "author": "jsjtzyy", "createdAt": "2020-06-18T21:57:12Z", "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -324,15 +324,13 @@ private void recover(MessageStoreRecovery recovery) throws StoreException, IOExc\n           // removes from the tracking structure if a delete was being expected for the key\n           deleteExpectedKeys.remove(info.getStoreKey());\n         } else if (info.isUndeleted()) {\n-          markAsUndeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info.getOperationTimeMs(),\n-              info.getLifeVersion());\n+          markAsUndeleted(info.getStoreKey(), new FileSpan(runningOffset, infoEndOffset), info,\n+              info.getOperationTimeMs(), info.getLifeVersion());\n           logger.info(\n               \"Index : {} updated message with key {} by inserting undelete entry of size {} ttl {} lifeVersion {}\",\n               dataDir, info.getStoreKey(), info.getSize(), info.getExpirationTimeInMs(), info.getLifeVersion());\n           if (value == null) {\n-            // Undelete record indicates that a put and/or a delete record were expected.\n-            throw new StoreException(\"Put record were expected but were not encountered for key: \" + info.getStoreKey(),\n-                StoreErrorCodes.Initialization_Error);\n+            deleteExpectedKeys.add(info.getStoreKey());", "originalCommit": "62ccc8693af1daff936bc398c25a08fa2f3fe523", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzOTAyOA==", "url": "https://github.com/linkedin/ambry/pull/1570#discussion_r442539028", "bodyText": "remove -> remote", "author": "jsjtzyy", "createdAt": "2020-06-18T22:39:21Z", "path": "ambry-store/src/main/java/com/github/ambry/store/PersistentIndex.java", "diffHunk": "@@ -722,15 +720,22 @@ private IndexValue findKey(StoreKey key, FileSpan fileSpan, EnumSet<IndexEntryTy\n    */\n   void validateSanityForUndelete(StoreKey key, List<IndexValue> values, short lifeVersion) throws StoreException {\n     if (values == null || values.isEmpty()) {\n-      throw new StoreException(\"Id \" + key + \" not present in index \" + dataDir, StoreErrorCodes.ID_Not_Found);\n+      throw new StoreException(\"Id \" + key + \" not found in \" + dataDir, StoreErrorCodes.ID_Not_Found);\n     }\n     if (!IndexValue.hasLifeVersion(lifeVersion)) {\n       validateSanityForUndeleteWithoutLifeVersion(key, values);\n       return;\n     }\n-    // This is from recovery or replication, make sure the last value is a put and the first value's lifeVersion is strictly\n-    // less than the given lifeVersion. We don't care about the first value's type, it can be a put, ttl_update or delete, it\n-    // can even be an undelete.\n+    // This is from replication. For replication, undelete should be permitted only when\n+    // 1. The oldest record is PUT\n+    // 2. the latest record's lifeVersion is less then undelete's lifeVersion.\n+    // 3. Replication doesn't care if the latest record is delete or not. In local, we can have a PUT record when\n+    // the remote has PUT, DELETE, UNDELETE. When replicating from remote, local has to insert UNDELETE, where\n+    // there is no prior DELETE.\n+    // 4. Replication doesn't care if the latest record is expired or not. In local, we can have a PUT record when\n+    // the remove has PUT, DELETE, UNDELETE TTL_UPDATE. When replicating from remote, PUT might already have expired.", "originalCommit": "62ccc8693af1daff936bc398c25a08fa2f3fe523", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MTI3NA==", "url": "https://github.com/linkedin/ambry/pull/1570#discussion_r442541274", "bodyText": "This is only used for testing, right?  (Also format the file please)", "author": "jsjtzyy", "createdAt": "2020-06-18T22:46:18Z", "path": "ambry-store/src/main/java/com/github/ambry/store/IndexValue.java", "diffHunk": "@@ -362,6 +362,14 @@ void setNewOffset(Offset newOffset) {\n     setOriginalMessageOffset(oldOffset);\n   }\n \n+  /**\n+   * Updates the {@link #lifeVersion} of this {@link IndexValue}.\n+   * @param lifeVersion the new lifeVersion to set.\n+   */\n+  void setNewLifeVersion(short lifeVersion) {", "originalCommit": "62ccc8693af1daff936bc398c25a08fa2f3fe523", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Mzg4OA==", "url": "https://github.com/linkedin/ambry/pull/1570#discussion_r442543888", "bodyText": "Looks like if valueFromTgtIdx != null, we only check version and undelete state, and we still add a new index entry to tgtIndex?", "author": "jsjtzyy", "createdAt": "2020-06-18T22:55:09Z", "path": "ambry-store/src/main/java/com/github/ambry/store/BlobStoreCompactor.java", "diffHunk": "@@ -767,16 +768,27 @@ private boolean copyRecords(LogSegment logSegmentToCopy, List<IndexEntry> srcInd\n               }\n             } else if (srcValue.isUndelete()) {\n               if (valueFromTgtIdx != null) {\n-                tgtIndex.markAsUndeleted(srcIndexEntry.getKey(), fileSpan, srcValue.getOperationTimeInMs(),\n-                    srcValue.getLifeVersion());\n-              } else {\n-                IndexValue tgtValue = new IndexValue(srcValue.getSize(), fileSpan.getStartOffset(), srcValue.getFlags(),\n-                    srcValue.getExpiresAtMs(), srcValue.getOperationTimeInMs(), srcValue.getAccountId(),\n-                    srcValue.getContainerId(), srcValue.getLifeVersion());\n-                tgtValue.setFlag(IndexValue.Flags.Undelete_Index);\n-                tgtValue.clearOriginalMessageOffset();\n-                tgtIndex.addToIndex(new IndexEntry(srcIndexEntry.getKey(), tgtValue), fileSpan);\n+                // Here don't use markAsUndelete method. In markAsUndelete, multiple sanity check would be applied. But\n+                // target index might only contain incomplete blob history, which would fail sanity check.\n+                // Here we do a different check to make sure we don't insert undelete with lower lifeVersion.\n+                if (valueFromTgtIdx.isUndelete()) {\n+                  throw new StoreException(\n+                      \"Id \" + srcIndexEntry.getKey() + \" already has undelete \" + valueFromTgtIdx + \" in index \"\n+                          + dataDir, StoreErrorCodes.ID_Undeleted);\n+                }\n+                // Undelete would increase the life version\n+                if (valueFromTgtIdx.getLifeVersion() >= srcValue.getLifeVersion()) {\n+                  throw new StoreException(\n+                      \"Id \" + srcIndexEntry.getKey() + \" has bad lifeversion \" + valueFromTgtIdx + \" in index \"\n+                          + dataDir, StoreErrorCodes.Life_Version_Conflict);\n+                }", "originalCommit": "62ccc8693af1daff936bc398c25a08fa2f3fe523", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Njc5OA==", "url": "https://github.com/linkedin/ambry/pull/1570#discussion_r442546798", "bodyText": "We are throwing an error when the valueFromTgtIndex is not what we expect. The idea is that, in target index, if there are already index value existed for this key, then it can't be an undelete. Compaction would remove all previous undelete in the same segment. And it's lifeVersion can't be equal or greater than the undelete's lifeVersion. It' pretty easy to understand why it can't be greater than undelete, for example if we have PUT in the target index, and it's lifeVersion has to be smaller than the undelete. Also it can't be equal to undelete, because undelete always increase the lifeVersion.", "author": "justinlin-linkedin", "createdAt": "2020-06-18T23:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Mzg4OA=="}], "type": "inlineReview"}, {"oid": "22a2d1d93faf82c7c44829f24f5164d1be7af185", "url": "https://github.com/linkedin/ambry/commit/22a2d1d93faf82c7c44829f24f5164d1be7af185", "message": "Address comments", "committedDate": "2020-06-18T23:08:50Z", "type": "commit"}]}