{"pr_number": 1510, "pr_title": "Allow router to send cross-colo request to dc with most replicas", "pr_createdAt": "2020-05-07T05:08:38Z", "pr_url": "https://github.com/linkedin/ambry/pull/1510", "timeline": [{"oid": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea", "url": "https://github.com/linkedin/ambry/commit/56c2e957a6bb0a64c67d5c6d24a19405899e2cea", "message": "minor changes and unit test", "committedDate": "2020-05-08T05:12:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MTg1NQ==", "url": "https://github.com/linkedin/ambry/pull/1510#discussion_r426991855", "bodyText": "Minor: please add blank lines before and after this new section for readability.", "author": "lightningrob", "createdAt": "2020-05-19T02:20:15Z", "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -159,48 +161,66 @@\n       case PutOperation:\n         eligibleReplicas =\n             getEligibleReplicas(partitionId, datacenterName, EnumSet.of(ReplicaState.STANDBY, ReplicaState.LEADER));\n-        diskSuccessTarget = routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n-            routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n-        diskParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n+        diskReplicaSuccessTarget =\n+            routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n+                routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n             : routerConfig.routerPutRequestParallelism;\n         crossColoEnabled = false;\n         break;\n       case DeleteOperation:\n-        diskSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n-        diskParallelism = routerConfig.routerDeleteRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerDeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case TtlUpdateOperation:\n-        diskSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n-        diskParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case UndeleteOperation:\n-        diskParallelism = routerConfig.routerUndeleteRequestParallelism;\n+        diskReplicaParallelism = routerConfig.routerUndeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         // Undelete operation need to get global quorum. It will require a different criteria for success.\n         // Here set the success target to the number of eligible replicas.\n-        diskSuccessTarget = eligibleReplicas.size();\n+        diskReplicaSuccessTarget = eligibleReplicas.size();\n         break;\n       default:\n         throw new IllegalArgumentException(\"Unsupported operation: \" + routerOperation);\n     }\n-    if (diskParallelism < 1 || cloudParallelism < 1) {\n+    if (diskReplicaParallelism < 1 || cloudReplicaParallelism < 1) {\n       throw new IllegalArgumentException(\n-          \"Parallelism has to be > 0. diskParallelism=\" + diskParallelism + \", cloudParallelism=\" + cloudParallelism\n-              + \", routerOperation=\" + routerOperation);\n+          \"Parallelism has to be > 0. diskParallelism=\" + diskReplicaParallelism + \", cloudParallelism=\"\n+              + cloudReplicaParallelism + \", routerOperation=\" + routerOperation);\n     }\n \n     // Order the replicas so that local healthy replicas are ordered and returned first,\n     // then the remote healthy ones, and finally the possibly down ones.\n     List<? extends ReplicaId> replicas =\n         routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas : partitionId.getReplicaIds();\n+    // In a case where a certain dc is decommissioned and blobs previously uploaded to this dc now have a unrecognizable", "originalCommit": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MjE3OQ==", "url": "https://github.com/linkedin/ambry/pull/1510#discussion_r426992179", "bodyText": "Minor: operation tracker", "author": "lightningrob", "createdAt": "2020-05-19T02:21:24Z", "path": "ambry-router/src/main/java/com/github/ambry/router/SimpleOperationTracker.java", "diffHunk": "@@ -159,48 +161,66 @@\n       case PutOperation:\n         eligibleReplicas =\n             getEligibleReplicas(partitionId, datacenterName, EnumSet.of(ReplicaState.STANDBY, ReplicaState.LEADER));\n-        diskSuccessTarget = routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n-            routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n-        diskParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n+        diskReplicaSuccessTarget =\n+            routerConfig.routerGetEligibleReplicasByStateEnabled ? Math.max(eligibleReplicas.size() - 1,\n+                routerConfig.routerPutSuccessTarget) : routerConfig.routerPutSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas.size()\n             : routerConfig.routerPutRequestParallelism;\n         crossColoEnabled = false;\n         break;\n       case DeleteOperation:\n-        diskSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n-        diskParallelism = routerConfig.routerDeleteRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerDeleteSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerDeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case TtlUpdateOperation:\n-        diskSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n-        diskParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n+        diskReplicaSuccessTarget = routerConfig.routerTtlUpdateSuccessTarget;\n+        diskReplicaParallelism = routerConfig.routerTtlUpdateRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         break;\n       case UndeleteOperation:\n-        diskParallelism = routerConfig.routerUndeleteRequestParallelism;\n+        diskReplicaParallelism = routerConfig.routerUndeleteRequestParallelism;\n         crossColoEnabled = true;\n         eligibleReplicas = getEligibleReplicas(partitionId, null,\n             EnumSet.of(ReplicaState.BOOTSTRAP, ReplicaState.STANDBY, ReplicaState.LEADER));\n         // Undelete operation need to get global quorum. It will require a different criteria for success.\n         // Here set the success target to the number of eligible replicas.\n-        diskSuccessTarget = eligibleReplicas.size();\n+        diskReplicaSuccessTarget = eligibleReplicas.size();\n         break;\n       default:\n         throw new IllegalArgumentException(\"Unsupported operation: \" + routerOperation);\n     }\n-    if (diskParallelism < 1 || cloudParallelism < 1) {\n+    if (diskReplicaParallelism < 1 || cloudReplicaParallelism < 1) {\n       throw new IllegalArgumentException(\n-          \"Parallelism has to be > 0. diskParallelism=\" + diskParallelism + \", cloudParallelism=\" + cloudParallelism\n-              + \", routerOperation=\" + routerOperation);\n+          \"Parallelism has to be > 0. diskParallelism=\" + diskReplicaParallelism + \", cloudParallelism=\"\n+              + cloudReplicaParallelism + \", routerOperation=\" + routerOperation);\n     }\n \n     // Order the replicas so that local healthy replicas are ordered and returned first,\n     // then the remote healthy ones, and finally the possibly down ones.\n     List<? extends ReplicaId> replicas =\n         routerConfig.routerGetEligibleReplicasByStateEnabled ? eligibleReplicas : partitionId.getReplicaIds();\n+    // In a case where a certain dc is decommissioned and blobs previously uploaded to this dc now have a unrecognizable\n+    // dc id. Current clustermap code will treat originating dc as null if dc id is not identifiable. To improve success\n+    // rate of cross-colo requests(GET/DELETE/TTLUpdate), operation tracker should be allowed to try remote dc with most\n+    // replicas first. This is useful in cluster with \"unbalanced\" replica distribution (i.e. 3 replicas in local dc and\n+    // 1 replica per remote dc)\n+    if (originatingDcName == null && routerConfig.routerCrossColoRequestToDcWithMostReplicas) {\n+      Map<String, Long> dcToReplicaCnt = replicas.stream()\n+          .collect(Collectors.groupingBy(e -> e.getDataNodeId().getDatacenterName(), Collectors.counting()));\n+      List<Map.Entry<String, Long>> entryList = new ArrayList<>(dcToReplicaCnt.entrySet());\n+      entryList.sort(Map.Entry.comparingByValue());\n+      // we assign a dc with most replicas to \"originatingDcName\", which only takes effect when populating replica pool\n+      // (replicas in that colo have higher priority than other remote colos). Note that, \"this.originatingDcName\" still\n+      // keeps the actual originating dc name (which is null). This value forces operation track to go through replicas", "originalCommit": "56c2e957a6bb0a64c67d5c6d24a19405899e2cea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MzgyMg==", "url": "https://github.com/linkedin/ambry/pull/1510#discussion_r426993822", "bodyText": "I recommend using a different variable name than originatingDcName.  Making it different from the class variable is too confusing.", "author": "lightningrob", "createdAt": "2020-05-19T02:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5MjE3OQ=="}], "type": "inlineReview"}, {"oid": "e5bcd422bb5ba845435cd36b686daa82d941b39c", "url": "https://github.com/linkedin/ambry/commit/e5bcd422bb5ba845435cd36b686daa82d941b39c", "message": "Allow router to send cross-colo request to dc with most replicas\n\nIn a case where a certain dc is decommissioned and blobs previously uploaded\nto this dc now have a unrecognizable dc id. Clustermap will treat originating dc\nof this blob as null. When request didn't succeed in local dc, operation tracker\nshould be allowed to try on remote dc with most replicas first so as to improve\nsuccess rate of cross-colo requests(i.e GET/DELETE etc). This is useful in cluster\nwith \"unbalanced\" replica distribution (i.e. 3 replicas in local dc and 1 replica\nper remote dc).", "committedDate": "2020-05-19T04:57:38Z", "type": "commit"}, {"oid": "5795170e8e1fd8152930dab99c2fe0bf22f33560", "url": "https://github.com/linkedin/ambry/commit/5795170e8e1fd8152930dab99c2fe0bf22f33560", "message": "minor changes and unit test", "committedDate": "2020-05-19T04:57:38Z", "type": "commit"}, {"oid": "29676ee2528d2cbb3c138aaf95f3b857e0fd62eb", "url": "https://github.com/linkedin/ambry/commit/29676ee2528d2cbb3c138aaf95f3b857e0fd62eb", "message": "address Rob's comments", "committedDate": "2020-05-19T05:16:44Z", "type": "commit"}, {"oid": "29676ee2528d2cbb3c138aaf95f3b857e0fd62eb", "url": "https://github.com/linkedin/ambry/commit/29676ee2528d2cbb3c138aaf95f3b857e0fd62eb", "message": "address Rob's comments", "committedDate": "2020-05-19T05:16:44Z", "type": "forcePushed"}]}