{"pr_number": 1588, "pr_title": " Introduce CompositeDataNodeConfigSource", "pr_createdAt": "2020-07-13T20:34:23Z", "pr_url": "https://github.com/linkedin/ambry/pull/1588", "timeline": [{"oid": "3a0adee9596bbc4e25e104a56ecf13dec4def7d4", "url": "https://github.com/linkedin/ambry/commit/3a0adee9596bbc4e25e104a56ecf13dec4def7d4", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls.", "committedDate": "2020-07-13T20:52:08Z", "type": "forcePushed"}, {"oid": "cb2b07bb035aba3f0b658ea1e3b0ee03be65fffb", "url": "https://github.com/linkedin/ambry/commit/cb2b07bb035aba3f0b658ea1e3b0ee03be65fffb", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls.", "committedDate": "2020-07-13T20:52:28Z", "type": "forcePushed"}, {"oid": "0dd95825618aa3fcfd9244619c10b3a1c75b261f", "url": "https://github.com/linkedin/ambry/commit/0dd95825618aa3fcfd9244619c10b3a1c75b261f", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls.", "committedDate": "2020-07-20T20:51:17Z", "type": "forcePushed"}, {"oid": "f522c513f5476b152c35facc0370a966487b918d", "url": "https://github.com/linkedin/ambry/commit/f522c513f5476b152c35facc0370a966487b918d", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls.", "committedDate": "2020-07-22T01:19:17Z", "type": "forcePushed"}, {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "url": "https://github.com/linkedin/ambry/commit/a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls.", "committedDate": "2020-07-24T23:41:14Z", "type": "commit"}, {"oid": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "url": "https://github.com/linkedin/ambry/commit/a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "message": "Introduce CompositeDataNodeConfigSource\n\n- Add CompositeDataNodeConfigSource that can be used to verify that two\n  config sources are consistent with each other during a migration. Only\n  the primary config source will be used as the source of truth for\n  other components.\n- Add config to allow switching between different config source impls.", "committedDate": "2020-07-24T23:41:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyNDUyMQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461324521", "bodyText": "configSeen is used to compare consistency between primary and secondary source. It relies on DataNodeConfigChange, if the change is triggered by sealed list, I wonder where the DataNodeConfigChange for secondary source comes from?  (If ambry server only updates one source, i.e. InstanceConfig)", "author": "jsjtzyy", "createdAt": "2020-07-28T05:20:19Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();\n+    } else {\n+      // only set up consistency checking for the first listener. Other listeners will just use with the primary src\n+      primarySource.addDataNodeConfigChangeListener(userListener);\n+    }\n+  }\n+\n+  @Override\n+  public boolean set(DataNodeConfig config) {\n+    boolean primaryResult = primarySource.set(config);\n+    try {\n+      boolean secondaryResult = secondarySource.set(config);\n+      if (primaryResult != secondaryResult) {\n+        metrics.setInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for set({}). sourceOfTruth={}, secondarySource={}\", config, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.setInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.set({})\", config, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public DataNodeConfig get(String instanceName) {\n+    DataNodeConfig primaryResult = primarySource.get(instanceName);\n+    try {\n+      DataNodeConfig secondaryResult = secondarySource.get(instanceName);\n+      if (!Objects.equals(primaryResult, secondaryResult)) {\n+        metrics.getInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for get({}). sourceOfTruth={}, secondarySource={}\", instanceName, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.getInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.get({})\", instanceName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  /**\n+   * Long running background task to periodically check for consistency between two listeners.\n+   */\n+  private static class ConsistencyChecker implements Runnable {\n+    private final Time time;\n+    private final DataNodeConfigSourceMetrics metrics;\n+    private final RecordingListener primaryListener;\n+    private final RecordingListener secondaryListener;\n+\n+    /**\n+     * @param time {@link Time} instance.\n+     * @param metrics {@link DataNodeConfigSourceMetrics} instance.\n+     * @param primaryListener the first {@link RecordingListener} to compare.\n+     * @param secondaryListener the second {@link RecordingListener} to compare.\n+     */\n+    public ConsistencyChecker(Time time, DataNodeConfigSourceMetrics metrics, RecordingListener primaryListener,\n+        RecordingListener secondaryListener) {\n+      this.time = time;\n+      this.metrics = metrics;\n+      this.primaryListener = primaryListener;\n+      this.secondaryListener = secondaryListener;\n+    }\n+\n+    @Override\n+    public void run() {\n+      long lastSuccessTimeMs = time.milliseconds();\n+      while (!Thread.currentThread().isInterrupted()) {\n+        try {\n+          time.sleep(CHECK_PERIOD_MS);\n+        } catch (InterruptedException e) {\n+          LOGGER.warn(\"ConsistencyChecker sleep interrupted, shutting down\");\n+          Thread.currentThread().interrupt();\n+          break;\n+        }\n+        long currentTimeMs = time.milliseconds();\n+        Map<String, DataNodeConfig> primaryConfigsSeen = primaryListener.configsSeen;\n+        Map<String, DataNodeConfig> secondaryConfigsSeen = secondaryListener.configsSeen;\n+        if (primaryConfigsSeen.equals(secondaryConfigsSeen)) {\n+          lastSuccessTimeMs = currentTimeMs;\n+          metrics.listenerConsistentCount.inc();\n+          LOGGER.debug(\"Sources consistent at {}\", currentTimeMs);\n+        } else if ((currentTimeMs - CHECK_PERIOD_MS * MAX_PERIODS_WITH_INCONSISTENCY) >= lastSuccessTimeMs) {\n+          metrics.listenerInconsistentCount.inc();\n+          LOGGER.warn(\"Inconsistency detected for multiple periods. primary={}, secondary={}\", primaryConfigsSeen,\n+              secondaryConfigsSeen);\n+        } else {\n+          metrics.listenerTrendingInconsistentCount.inc();\n+          LOGGER.debug(\"Inconsistency detected at {}, waiting to see if state converges. primary={}, secondary={}\",\n+              currentTimeMs, primaryConfigsSeen, secondaryConfigsSeen);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A listener that keeps a map of all of the configs it has seen that can be used for checking consistency.\n+   */\n+  private static class RecordingListener implements DataNodeConfigChangeListener {\n+    final Map<String, DataNodeConfig> configsSeen = new ConcurrentHashMap<>();\n+    private final DataNodeConfigChangeListener userListener;\n+\n+    /**\n+     * @param userListener if non-null, this listener will be notified on any change.\n+     */\n+    public RecordingListener(DataNodeConfigChangeListener userListener) {\n+      this.userListener = userListener;\n+    }\n+\n+    @Override\n+    public void onDataNodeConfigChange(Iterable<DataNodeConfig> configs) {\n+      if (userListener != null) {\n+        userListener.onDataNodeConfigChange(configs);\n+      }\n+      for (DataNodeConfig config : configs) {\n+        configsSeen.put(config.getInstanceName(), config);\n+      }", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY4OTgwOQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461689809", "bodyText": "You are right in that there will be an inconsistency if the server was only using the InstanceConfig adapter. However, my idea was that we would run all servers with CompositeDataNodeConfigSource, where the set() method will make a call to both sources.", "author": "cgtz", "createdAt": "2020-07-28T15:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyNDUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1OTI1Ng==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461759256", "bodyText": "Just to confirm, it seems addDataNodeConfigChangeListener for CompositeDataNodeConfigSource is called in one place (DatacenterInitializer) for now, so the else branch is temporarily not used? It's added here for other listener (if any) to introduce in the future?", "author": "jsjtzyy", "createdAt": "2020-07-28T17:42:52Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();\n+    } else {\n+      // only set up consistency checking for the first listener. Other listeners will just use with the primary src\n+      primarySource.addDataNodeConfigChangeListener(userListener);", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ5NjA2Mw==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r462496063", "bodyText": "Yes, the else branch is not used by production code. I added it since the interface does not have any limitations about how many times this method can be called and neither do the InstanceConfig...Adapter and PropertyStore...Adapter impls", "author": "cgtz", "createdAt": "2020-07-29T18:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1OTI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU2NzYxNw==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r462567617", "bodyText": "I see, it makes sense.", "author": "jsjtzyy", "createdAt": "2020-07-29T20:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1OTI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NDYxMw==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461764613", "bodyText": "I need more clarification here. In this doc, for each operation (addDataNodeConfigChangeListener, get, set), looks like it only catches the exception from secondary source, is there any specific reason? In migration, both primary and secondary source can be InstanceConfig, PropertyStore, Is this because primary is source of truth and if there is an exception from primary, the exception is thrown immediately and whole operation fails?", "author": "jsjtzyy", "createdAt": "2020-07-28T17:51:41Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ5ODIwMg==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r462498202", "bodyText": "Yes, I envisioned the primary to be the source of truth. So, if the primary throws an exception we should propagate it back to the caller as if they were using the primary source only. However, we do not want errors that happen in the less vetted secondary source to affect the health of the server/frontend. By catching and logging them, we can investigate at a later time.", "author": "cgtz", "createdAt": "2020-07-29T18:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NDYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NjAwNQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461766005", "bodyText": "If there is an exception from secondary source, do we really need to initiate consistency checker? I expect it to report inconsistency always (probably good for alerting?)", "author": "jsjtzyy", "createdAt": "2020-07-28T17:53:46Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ5ODk1MQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r462498951", "bodyText": "That is true. I changed this to just not start the thread and just introduce a new metric that fires if attaching the secondary listener fails instead of letting the consistencychecker run and fail continuously.", "author": "cgtz", "createdAt": "2020-07-29T18:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NjAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3NzEwNA==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461777104", "bodyText": "nit: can we just call it listener or changeListener instead of userListener?", "author": "jsjtzyy", "createdAt": "2020-07-28T18:12:44Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3OTc0NQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461779745", "bodyText": "same here,  I think changeListener or listener would suffice. (Two cents)", "author": "jsjtzyy", "createdAt": "2020-07-28T18:17:23Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();\n+    } else {\n+      // only set up consistency checking for the first listener. Other listeners will just use with the primary src\n+      primarySource.addDataNodeConfigChangeListener(userListener);\n+    }\n+  }\n+\n+  @Override\n+  public boolean set(DataNodeConfig config) {\n+    boolean primaryResult = primarySource.set(config);\n+    try {\n+      boolean secondaryResult = secondarySource.set(config);\n+      if (primaryResult != secondaryResult) {\n+        metrics.setInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for set({}). sourceOfTruth={}, secondarySource={}\", config, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.setInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.set({})\", config, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public DataNodeConfig get(String instanceName) {\n+    DataNodeConfig primaryResult = primarySource.get(instanceName);\n+    try {\n+      DataNodeConfig secondaryResult = secondarySource.get(instanceName);\n+      if (!Objects.equals(primaryResult, secondaryResult)) {\n+        metrics.getInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for get({}). sourceOfTruth={}, secondarySource={}\", instanceName, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.getInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.get({})\", instanceName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  /**\n+   * Long running background task to periodically check for consistency between two listeners.\n+   */\n+  private static class ConsistencyChecker implements Runnable {\n+    private final Time time;\n+    private final DataNodeConfigSourceMetrics metrics;\n+    private final RecordingListener primaryListener;\n+    private final RecordingListener secondaryListener;\n+\n+    /**\n+     * @param time {@link Time} instance.\n+     * @param metrics {@link DataNodeConfigSourceMetrics} instance.\n+     * @param primaryListener the first {@link RecordingListener} to compare.\n+     * @param secondaryListener the second {@link RecordingListener} to compare.\n+     */\n+    public ConsistencyChecker(Time time, DataNodeConfigSourceMetrics metrics, RecordingListener primaryListener,\n+        RecordingListener secondaryListener) {\n+      this.time = time;\n+      this.metrics = metrics;\n+      this.primaryListener = primaryListener;\n+      this.secondaryListener = secondaryListener;\n+    }\n+\n+    @Override\n+    public void run() {\n+      long lastSuccessTimeMs = time.milliseconds();\n+      while (!Thread.currentThread().isInterrupted()) {\n+        try {\n+          time.sleep(CHECK_PERIOD_MS);\n+        } catch (InterruptedException e) {\n+          LOGGER.warn(\"ConsistencyChecker sleep interrupted, shutting down\");\n+          Thread.currentThread().interrupt();\n+          break;\n+        }\n+        long currentTimeMs = time.milliseconds();\n+        Map<String, DataNodeConfig> primaryConfigsSeen = primaryListener.configsSeen;\n+        Map<String, DataNodeConfig> secondaryConfigsSeen = secondaryListener.configsSeen;\n+        if (primaryConfigsSeen.equals(secondaryConfigsSeen)) {\n+          lastSuccessTimeMs = currentTimeMs;\n+          metrics.listenerConsistentCount.inc();\n+          LOGGER.debug(\"Sources consistent at {}\", currentTimeMs);\n+        } else if ((currentTimeMs - CHECK_PERIOD_MS * MAX_PERIODS_WITH_INCONSISTENCY) >= lastSuccessTimeMs) {\n+          metrics.listenerInconsistentCount.inc();\n+          LOGGER.warn(\"Inconsistency detected for multiple periods. primary={}, secondary={}\", primaryConfigsSeen,\n+              secondaryConfigsSeen);\n+        } else {\n+          metrics.listenerTrendingInconsistentCount.inc();\n+          LOGGER.debug(\"Inconsistency detected at {}, waiting to see if state converges. primary={}, secondary={}\",\n+              currentTimeMs, primaryConfigsSeen, secondaryConfigsSeen);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A listener that keeps a map of all of the configs it has seen that can be used for checking consistency.\n+   */\n+  private static class RecordingListener implements DataNodeConfigChangeListener {\n+    final Map<String, DataNodeConfig> configsSeen = new ConcurrentHashMap<>();\n+    private final DataNodeConfigChangeListener userListener;", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4MjMzMQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461782331", "bodyText": "optional:  maybe rename RecordingListener to ConfigChangeRecorder (or DataNodeConfigRecorder)", "author": "jsjtzyy", "createdAt": "2020-07-28T18:21:53Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener userListener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      RecordingListener primaryListener = new RecordingListener(userListener);\n+      RecordingListener secondaryListener = new RecordingListener(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+      } catch (Exception e) {\n+        LOGGER.error(\"Error from secondarySource.addDataNodeConfigChangeListener({})\", userListener, e);\n+      }\n+      Utils.newThread(\"DataNodeConfigConsistencyChecker\",\n+          new ConsistencyChecker(time, metrics, primaryListener, secondaryListener), false).start();\n+    } else {\n+      // only set up consistency checking for the first listener. Other listeners will just use with the primary src\n+      primarySource.addDataNodeConfigChangeListener(userListener);\n+    }\n+  }\n+\n+  @Override\n+  public boolean set(DataNodeConfig config) {\n+    boolean primaryResult = primarySource.set(config);\n+    try {\n+      boolean secondaryResult = secondarySource.set(config);\n+      if (primaryResult != secondaryResult) {\n+        metrics.setInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for set({}). sourceOfTruth={}, secondarySource={}\", config, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.setInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.set({})\", config, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  @Override\n+  public DataNodeConfig get(String instanceName) {\n+    DataNodeConfig primaryResult = primarySource.get(instanceName);\n+    try {\n+      DataNodeConfig secondaryResult = secondarySource.get(instanceName);\n+      if (!Objects.equals(primaryResult, secondaryResult)) {\n+        metrics.getInconsistentCount.inc();\n+        LOGGER.error(\"Results differ for get({}). sourceOfTruth={}, secondarySource={}\", instanceName, primaryResult,\n+            secondaryResult);\n+      }\n+    } catch (Exception e) {\n+      metrics.getInconsistentCount.inc();\n+      LOGGER.error(\"Error from secondarySource.get({})\", instanceName, e);\n+    }\n+    return primaryResult;\n+  }\n+\n+  /**\n+   * Long running background task to periodically check for consistency between two listeners.\n+   */\n+  private static class ConsistencyChecker implements Runnable {\n+    private final Time time;\n+    private final DataNodeConfigSourceMetrics metrics;\n+    private final RecordingListener primaryListener;\n+    private final RecordingListener secondaryListener;\n+\n+    /**\n+     * @param time {@link Time} instance.\n+     * @param metrics {@link DataNodeConfigSourceMetrics} instance.\n+     * @param primaryListener the first {@link RecordingListener} to compare.\n+     * @param secondaryListener the second {@link RecordingListener} to compare.\n+     */\n+    public ConsistencyChecker(Time time, DataNodeConfigSourceMetrics metrics, RecordingListener primaryListener,\n+        RecordingListener secondaryListener) {\n+      this.time = time;\n+      this.metrics = metrics;\n+      this.primaryListener = primaryListener;\n+      this.secondaryListener = secondaryListener;\n+    }\n+\n+    @Override\n+    public void run() {\n+      long lastSuccessTimeMs = time.milliseconds();\n+      while (!Thread.currentThread().isInterrupted()) {\n+        try {\n+          time.sleep(CHECK_PERIOD_MS);\n+        } catch (InterruptedException e) {\n+          LOGGER.warn(\"ConsistencyChecker sleep interrupted, shutting down\");\n+          Thread.currentThread().interrupt();\n+          break;\n+        }\n+        long currentTimeMs = time.milliseconds();\n+        Map<String, DataNodeConfig> primaryConfigsSeen = primaryListener.configsSeen;\n+        Map<String, DataNodeConfig> secondaryConfigsSeen = secondaryListener.configsSeen;\n+        if (primaryConfigsSeen.equals(secondaryConfigsSeen)) {\n+          lastSuccessTimeMs = currentTimeMs;\n+          metrics.listenerConsistentCount.inc();\n+          LOGGER.debug(\"Sources consistent at {}\", currentTimeMs);\n+        } else if ((currentTimeMs - CHECK_PERIOD_MS * MAX_PERIODS_WITH_INCONSISTENCY) >= lastSuccessTimeMs) {\n+          metrics.listenerInconsistentCount.inc();\n+          LOGGER.warn(\"Inconsistency detected for multiple periods. primary={}, secondary={}\", primaryConfigsSeen,\n+              secondaryConfigsSeen);\n+        } else {\n+          metrics.listenerTrendingInconsistentCount.inc();\n+          LOGGER.debug(\"Inconsistency detected at {}, waiting to see if state converges. primary={}, secondary={}\",\n+              currentTimeMs, primaryConfigsSeen, secondaryConfigsSeen);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A listener that keeps a map of all of the configs it has seen that can be used for checking consistency.\n+   */\n+  private static class RecordingListener implements DataNodeConfigChangeListener {", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4Mzg5OQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461783899", "bodyText": "How about calling it listenerTransientInconsistentCount?", "author": "jsjtzyy", "createdAt": "2020-07-28T18:24:36Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DataNodeConfigSourceMetrics.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.MetricRegistry;\n+\n+\n+/**\n+ * Metrics for {@link DataNodeConfigSource} implementations\n+ */\n+class DataNodeConfigSourceMetrics {\n+  final Counter setInconsistentCount;\n+  final Counter getInconsistentCount;\n+  final Counter listenerInconsistentCount;\n+  final Counter listenerTrendingInconsistentCount;", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NDkzMg==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461784932", "bodyText": "I know this metrics is helpful for testing but in practice I feel like we don't really need it. The other two inconsistent metrics should give us sufficient alerting. What do you think?", "author": "jsjtzyy", "createdAt": "2020-07-28T18:26:18Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DataNodeConfigSourceMetrics.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.codahale.metrics.Counter;\n+import com.codahale.metrics.MetricRegistry;\n+\n+\n+/**\n+ * Metrics for {@link DataNodeConfigSource} implementations\n+ */\n+class DataNodeConfigSourceMetrics {\n+  final Counter setInconsistentCount;\n+  final Counter getInconsistentCount;\n+  final Counter listenerInconsistentCount;\n+  final Counter listenerTrendingInconsistentCount;\n+  final Counter listenerConsistentCount;\n+\n+  DataNodeConfigSourceMetrics(MetricRegistry registry) {\n+    setInconsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"SetInconsistentCount\"));\n+    getInconsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"GetInconsistentCount\"));\n+    listenerInconsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"ListenerInconsistentCount\"));\n+    listenerTrendingInconsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"ListenerTrendingInconsistentCount\"));\n+    listenerConsistentCount =\n+        registry.counter(MetricRegistry.name(CompositeDataNodeConfigSource.class, \"ListenerConsistentCount\"));", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwODcxMg==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r462508712", "bodyText": "that is true, i guess I can just check that the other 2 metrics did not fire in the test", "author": "cgtz", "createdAt": "2020-07-29T18:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NDkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NTg3MA==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461785870", "bodyText": "Just a random thought, are we able to remove these metrics after migration is complete?", "author": "jsjtzyy", "createdAt": "2020-07-28T18:28:02Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DatacenterInitializer.java", "diffHunk": "@@ -92,6 +94,7 @@\n     this.clusterChangeHandlerCallback = clusterChangeHandlerCallback;\n     this.helixClusterManagerCallback = helixClusterManagerCallback;\n     this.helixClusterManagerMetrics = helixClusterManagerMetrics;\n+    this.dataNodeConfigSourceMetrics = dataNodeConfigSourceMetrics;", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyNDgxMQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r462524811", "bodyText": "We can probably remove these metrics and CompositeDataNodeConfigSource unless you can think of any metrics that would be useful to have in the PropertyStore based impl.", "author": "cgtz", "createdAt": "2020-07-29T19:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NTg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MjM3OQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461872379", "bodyText": "Just realize that the reason we need dcName is to construct PropertyStoreToDataNodeConfigAdapter. And the reason constructor needs that is we didn't add a DATACENTER_STR in the simple field of ZNRecord (we do have a simple field for dc in InstanceConfig). Any reason for this? (I probably missed previous context, let me know if I am wrong)", "author": "jsjtzyy", "createdAt": "2020-07-28T20:54:11Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/DatacenterInitializer.java", "diffHunk": "@@ -197,7 +200,8 @@ private DcInfo initializeHelixDatacenter() throws Exception {\n     // notification for a change from within the same thread that adds the listener, in the context of the add\n     // call. Therefore, when the call to add a listener returns, the initial notification will have been\n     // received and handled.\n-    DataNodeConfigSource dataNodeConfigSource = new InstanceConfigToDataNodeConfigAdapter(manager, clusterMapConfig);\n+    DataNodeConfigSource dataNodeConfigSource =\n+        ClusterMapUtils.getDataNodeConfigSource(clusterMapConfig, manager, dcName, dataNodeConfigSourceMetrics);", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyNzkwOQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r462527909", "bodyText": "I felt that it was extra data that did not need to be in each znode since it can be inferred from the zookeeper connected to. If you think that it is better to have it there (for example, if we perform multi-datacenter aggregation in the future), I can definitely add it back in. What do you think?", "author": "cgtz", "createdAt": "2020-07-29T19:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MjM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3MDM2NQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r462570365", "bodyText": "I see your point but I feel like adding DATACENTER_STR field won't bring too much overhead and in the long term I believe multi-datacenter aggregation is needed. I see two benefits of aggregation view:  1. reduce cross-colo read qps on ZK. 2. speed up startup time for both fronend/server (don't need to wait for remote dc initial notification). Adding DATACENTER_STR back is helpful in future case.", "author": "jsjtzyy", "createdAt": "2020-07-29T20:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MjM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY2MzUwNA==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r463663504", "bodyText": "Sure, that definitely makes sense so that we won't have  to make an incremental schema change in the future just for this. My most recent commit has added the datacenter field back.", "author": "cgtz", "createdAt": "2020-07-31T15:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MjM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MjgzMg==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461872832", "bodyText": "Remove these imports?", "author": "jsjtzyy", "createdAt": "2020-07-28T20:54:57Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixFactory.java", "diffHunk": "@@ -13,6 +13,8 @@\n  */\n package com.github.ambry.clustermap;\n \n+import com.github.ambry.config.ClusterMapConfig;\n+import com.github.ambry.utils.SystemTime;", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4MzY3NA==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461883674", "bodyText": "This is never used, we can remove it.", "author": "jsjtzyy", "createdAt": "2020-07-28T21:14:37Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -261,30 +263,38 @@ public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n           \"HelixParticipant only works with the AmbryReplica implementation of ReplicaId\");\n     }\n     synchronized (helixAdministrationLock) {\n-      List<String> disabledReplicas = new ArrayList<>(getDisabledReplicas());\n       String partitionName = replicaId.getPartitionId().toPathString();\n \n       // 1. invoke Helix native method to enable/disable partition on local node, this will trigger subsequent state\n       //    transition on given replica. This method modifies MapFields in InstanceConfig.\n+      boolean instanceConfigUpdated = false;", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NjY2OQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r461886669", "bodyText": "The current logic is correct but I am thinking if we can simplify this. setReplicaDisabledState method is only called when local node tries to enable/disable local replica. The enabled/disabled replica is always reflected by \"disabled list\" in dataNodeConfig. So I am thinking we don't have to check currentlyEnabled == disable. Instead, we may consider moving this piece of code into if (dataNodeConfigChanged) block. Only when the \"disabled list\" is updated, we call enable/disable partition in InstanceConfig. Hope my point makes some sense.", "author": "jsjtzyy", "createdAt": "2020-07-28T21:20:42Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/HelixParticipant.java", "diffHunk": "@@ -261,30 +263,38 @@ public void setReplicaDisabledState(ReplicaId replicaId, boolean disable) {\n           \"HelixParticipant only works with the AmbryReplica implementation of ReplicaId\");\n     }\n     synchronized (helixAdministrationLock) {\n-      List<String> disabledReplicas = new ArrayList<>(getDisabledReplicas());\n       String partitionName = replicaId.getPartitionId().toPathString();\n \n       // 1. invoke Helix native method to enable/disable partition on local node, this will trigger subsequent state\n       //    transition on given replica. This method modifies MapFields in InstanceConfig.\n+      boolean instanceConfigUpdated = false;\n       InstanceConfig instanceConfig = getInstanceConfig();\n       String resourceNameForPartition = getResourceNameOfPartition(helixAdmin, clusterName, partitionName);\n       logger.info(\"{} replica {} on current node\", disable ? \"Disabling\" : \"Enabling\", partitionName);\n-      instanceConfig.setInstanceEnabledForPartition(resourceNameForPartition, partitionName, !disable);\n+      boolean currentlyEnabled = instanceConfig.getInstanceEnabledForPartition(resourceNameForPartition, partitionName);\n+      if (currentlyEnabled == disable) {\n+        instanceConfig.setInstanceEnabledForPartition(resourceNameForPartition, partitionName, !disable);\n+        if (!helixAdmin.setInstanceConfig(clusterName, instanceName, instanceConfig)) {\n+          logger.warn(\"setReplicaDisabledState() failed InstanceConfig update\");\n+        }\n+      }", "originalCommit": "a84c48368de03f995ca709ec0f4dc4e8a4a459ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNDU5NQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r462534595", "bodyText": "Sure, that makes sense, and will save a HelixAdmin call in many cases. I will implement that", "author": "cgtz", "createdAt": "2020-07-29T19:26:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NjY2OQ=="}], "type": "inlineReview"}, {"oid": "658fce8da7c77c927053a547aacc801a91b33d23", "url": "https://github.com/linkedin/ambry/commit/658fce8da7c77c927053a547aacc801a91b33d23", "message": "Address Yingyi's comments", "committedDate": "2020-07-29T19:38:25Z", "type": "commit"}, {"oid": "63d5df894dcf5c87dd8439827421f9591107f4a5", "url": "https://github.com/linkedin/ambry/commit/63d5df894dcf5c87dd8439827421f9591107f4a5", "message": "Add datacenter back to propertystore config record", "committedDate": "2020-07-31T15:00:46Z", "type": "commit"}, {"oid": "fa03bf24f57a03fb28eb339136680ad8bd641faa", "url": "https://github.com/linkedin/ambry/commit/fa03bf24f57a03fb28eb339136680ad8bd641faa", "message": "Add missing blank line", "committedDate": "2020-07-31T15:02:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2NTA0OQ==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r465665049", "bodyText": "Curious .. Why do we need to create a periodic thread to check consistency? Why can't we check on each call to ConfigChangeRecorder.onDataNodeConfigChange which is where we seem to be setting ConfigChangeRecorder.configsSeen.", "author": "ankagrawal", "createdAt": "2020-08-05T11:39:51Z", "path": "ambry-clustermap/src/main/java/com/github/ambry/clustermap/CompositeDataNodeConfigSource.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *\n+ */\n+\n+package com.github.ambry.clustermap;\n+\n+import com.github.ambry.utils.Time;\n+import com.github.ambry.utils.Utils;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * An implementation of {@link DataNodeConfigSource} that combines two sources. The \"primary\" acts as the source of\n+ * truth for users of this class, but results obtained are compared against the \"secondary\" source. This class can be\n+ * useful for safe migrations between different backing stores.\n+ */\n+public class CompositeDataNodeConfigSource implements DataNodeConfigSource {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(CompositeDataNodeConfigSource.class);\n+  static final long CHECK_PERIOD_MS = TimeUnit.MINUTES.toMillis(5);\n+  static final int MAX_PERIODS_WITH_INCONSISTENCY = 3;\n+  private final DataNodeConfigSource primarySource;\n+  private final DataNodeConfigSource secondarySource;\n+  private final DataNodeConfigSourceMetrics metrics;\n+  private final Time time;\n+  private final AtomicBoolean recordingListenersRegistered = new AtomicBoolean(false);\n+\n+  /**\n+   * @param primarySource the source of truth for users of this class.\n+   * @param secondarySource all operations are also attempted against this source, but if the results of the operation\n+   *                        differ from the primary, inconsistencies are just recorded with logs and metrics.\n+   * @param time a {@link Time} instance used for consistency verification.\n+   * @param metrics a {@link DataNodeConfigSourceMetrics} instance to use.\n+   */\n+  public CompositeDataNodeConfigSource(DataNodeConfigSource primarySource, DataNodeConfigSource secondarySource,\n+      Time time, DataNodeConfigSourceMetrics metrics) {\n+    this.primarySource = primarySource;\n+    this.secondarySource = secondarySource;\n+    this.time = time;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public void addDataNodeConfigChangeListener(DataNodeConfigChangeListener listener) throws Exception {\n+    if (recordingListenersRegistered.compareAndSet(false, true)) {\n+      ConfigChangeRecorder primaryListener = new ConfigChangeRecorder(listener);\n+      ConfigChangeRecorder secondaryListener = new ConfigChangeRecorder(null);\n+      primarySource.addDataNodeConfigChangeListener(primaryListener);\n+      try {\n+        secondarySource.addDataNodeConfigChangeListener(secondaryListener);\n+        Utils.newThread(\"DataNodeConfigConsistencyChecker\",", "originalCommit": "fa03bf24f57a03fb28eb339136680ad8bd641faa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY3NDc5OA==", "url": "https://github.com/linkedin/ambry/pull/1588#discussion_r465674798", "bodyText": "I too would prefer to lazily check when onDataNodeConfigChange is called and actually implemented it at first before switching to the background thread approach. I saw an issue in the following scenario:\n\nListener 1 gets a notification. This indicates that there is a transient inconsistency but we don't want to alert yet since the update for listener 2 could come before or after.\nListener 2 just never gets a notification. Without a background thread to check periodically, nothing will alert until another listener notification comes, potentially far in the future.\n\nIf we assume that notifications come frequently enough (and a situation where both listeners stop receiving notifications is rare), we could probably go back to this approach.", "author": "cgtz", "createdAt": "2020-08-05T11:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY2NTA0OQ=="}], "type": "inlineReview"}]}