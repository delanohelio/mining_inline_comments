{"pr_number": 1439, "pr_title": "Support netty bytebuf in PutOperation", "pr_createdAt": "2020-03-25T23:58:48Z", "pr_url": "https://github.com/linkedin/ambry/pull/1439", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxNjgyNA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r398816824", "bodyText": "remove?", "author": "zzmao", "createdAt": "2020-03-26T18:55:46Z", "path": "ambry-network/src/main/java/com.github.ambry.network/Selector.java", "diffHunk": "@@ -788,6 +788,7 @@ private NetworkSend write(SelectionKey key, Transmission transmission) {\n     } catch (IOException e) {\n       // We have key information if we log IOException here.\n       handleReadWriteIOException(e, key);\n+      //transmission.networkSend.getPayload().release();", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAxODE1NQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401018155", "bodyText": "not directly in the scope of this PR, but since you're making changes, could you make this inner class static along with DecryptJobResult.", "author": "cgtz", "createdAt": "2020-03-31T15:43:52Z", "path": "ambry-router/src/main/java/com.github.ambry.router/EncryptJob.java", "diffHunk": "@@ -103,25 +112,31 @@ public void closeJob(GeneralSecurityException gse) {\n    */\n   class EncryptJobResult {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAyMTc1OA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401021758", "bodyText": "Could this just be buf.readBytes(dest) instead of iterating through the nio buffers?", "author": "cgtz", "createdAt": "2020-03-31T15:48:40Z", "path": "ambry-router/src/test/java/com.github.ambry.router/ChunkFillTest.java", "diffHunk": "@@ -319,20 +319,20 @@ private void fillChunksAndAssertSuccess() throws Exception {\n   private void assertDataIdentity(ClusterMap clusterMap) throws IOException {\n     if (!testEncryption) {\n       ByteBuffer dest = ByteBuffer.allocate(totalSizeWritten);\n-      for (ByteBuffer buf : compositeBuffers) {\n+      for (ByteBuf buf : compositeBuffers) {\n         Assert.assertNotNull(\"All chunks should have come in\", buf);\n-        buf.flip();\n-        dest.put(buf);\n+        for (ByteBuffer buffer: buf.nioBuffers()) {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NTM2OA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401965368", "bodyText": "This is easier. dest will read all the ByteBufs in the array of compositeBuffers, so buf.readBytes(dest) would fail. We have to set limit on dest before reading bytes from buf. But in this way, we don't have to.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAyMTc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0MTEwNw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401041107", "bodyText": "why was the leak helper disabled for this test case?", "author": "cgtz", "createdAt": "2020-03-31T16:15:41Z", "path": "ambry-router/src/test/java/com.github.ambry.router/NonBlockingRouterTest.java", "diffHunk": "@@ -411,6 +413,7 @@ public void testRouterNoPartitionInLocalDC() throws Exception {\n    */\n   @Test\n   public void testRequestResponseHandlerThreadExitFlow() throws Exception {\n+    nettyByteBufLeakHelper.setDisabled(true);", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NTk2NA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401965964", "bodyText": "There are tests in NonBlockingRouterTest that needs creates new ByteBuf by putting a blob to the in memory router but never release it. Those tests are going to break the leak detector helper. That's why I disable the leak detector helper for those tests.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0MTEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0NzI0OQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401047249", "bodyText": "nit: if less then -> is less than, than this -> then this", "author": "cgtz", "createdAt": "2020-03-31T16:24:31Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -562,9 +587,11 @@ void fillChunks() {\n         }\n       }\n       if (chunkFillingCompletedSuccessfully) {\n+        // If the blob size if less then 4MB or the last chunk size is less than 4MB, than this lastChunk will be", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMDI1MA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401110250", "bodyText": "there is an empty if condition here", "author": "cgtz", "createdAt": "2020-03-31T18:03:43Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -528,10 +551,12 @@ void fillChunks() {\n       PutChunk chunkToFill;\n       while (!isChunkFillingDone()) {\n         // Attempt to fill a chunk\n-        if (channelReadBuffer == null) {\n-          channelReadBuffer = chunkFillerChannel.getNextChunk(0);\n+        if (channelReadBuf == null) {\n+          channelReadBuf = chunkFillerChannel.getNextByteBuf(0);\n+          if (channelReadBuf != null) {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyNjA4MQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401126081", "bodyText": "Could this be a lower log level? Or moved inside of the if (lastChunk != null) check so it only is printed if there was a chunk still being built?", "author": "cgtz", "createdAt": "2020-03-31T18:30:22Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -575,10 +602,21 @@ void fillChunks() {\n           }\n         }\n       }\n+      if (operationCompleted) {\n+        logger.info(\"Clear unfinished chunk since operation is completed\");", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MTI2MA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401161260", "bodyText": "The clear() method does not seem like it was meant to be called from non-main threads. Is it necessary to do all of the cleanup or just call releaseBlobContent here and in fillChunks()?", "author": "cgtz", "createdAt": "2020-03-31T19:29:06Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1152,42 +1147,62 @@ private void encryptChunk() {\n         logger.trace(\"Submitting encrypt job for chunk at index {}\", chunkIndex);\n         cryptoJobHandler.submitJob(\n             new EncryptJob(passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(),\n-                isMetadataChunk() ? null : buf, ByteBuffer.wrap(chunkUserMetadata), kms.getRandomKey(), cryptoService,\n-                kms, encryptJobMetricsTracker, (EncryptJob.EncryptJobResult result, Exception exception) -> {\n-              logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n-              encryptJobMetricsTracker.onJobResultProcessingStart();\n-              if (exception == null && !isOperationComplete()) {\n-                if (!isMetadataChunk()) {\n-                  buf = result.getEncryptedBlobContent();\n-                }\n-                encryptedPerBlobKey = result.getEncryptedKey();\n-                chunkUserMetadata = result.getEncryptedUserMetadata().array();\n-                logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n-                prepareForSending();\n-                chunkReadyAtMs = time.milliseconds();\n-              } else {\n-                encryptJobMetricsTracker.incrementOperationError();\n-                if (!isOperationComplete()) {\n-                  logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n-                  setOperationExceptionAndComplete(\n-                      new RouterException(\"Exception thrown on encrypting the content for chunk at index \" + chunkIndex,\n-                          exception, RouterErrorCode.UnexpectedInternalError));\n-                } else {\n-                  logger.trace(\n-                      \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n-                      chunkIndex, getOperationException(), exception);\n-                }\n-              }\n-              routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n-              encryptJobMetricsTracker.onJobResultProcessingComplete();\n-              routerCallback.onPollReady();\n-            }));\n+                isMetadataChunk() ? null : toEncrypt.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n+                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker,\n+                (EncryptJob.EncryptJobResult result, Exception exception) -> {\n+                  logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n+                  if (!isMetadataChunk()) {\n+                    releaseBlobContent();\n+                  }\n+                  encryptJobMetricsTracker.onJobResultProcessingStart();\n+                  if (exception == null && !isOperationComplete()) {\n+                    if (!isMetadataChunk()) {\n+                      buf = result.getEncryptedBlobContent();\n+                    }\n+                    encryptedPerBlobKey = result.getEncryptedKey();\n+                    chunkUserMetadata = result.getEncryptedUserMetadata().array();\n+                    logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n+                    prepareForSending();\n+                    chunkReadyAtMs = time.milliseconds();\n+                  } else {\n+                    encryptJobMetricsTracker.incrementOperationError();\n+                    if (!isOperationComplete()) {\n+                      logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n+                      // If we are here, then the result is null. no need to release it.\n+                      setOperationExceptionAndComplete(new RouterException(\n+                          \"Exception thrown on encrypting the content for chunk at index \" + chunkIndex, exception,\n+                          RouterErrorCode.UnexpectedInternalError));\n+                    } else {\n+                      logger.trace(\n+                          \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n+                          chunkIndex, getOperationException(), exception);\n+                      // If we are here, then the operation is completed and the exception could be null, in this case,\n+                      // we have to release the content in the result.\n+                      if (result != null) {\n+                        result.release();\n+                      }\n+                    }\n+                  }\n+                  routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n+                  encryptJobMetricsTracker.onJobResultProcessingComplete();\n+                  routerCallback.onPollReady();\n+                  // double check if the operation is not completed. If so, we have to release the buf here, since in\n+                  // main thread, chunk might already be released.\n+                  if (isOperationComplete()) {\n+                    logger.info(\"Clear put chunk in encryption callback since operation is completed\");\n+                    clear();", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjA4MQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966081", "bodyText": "make sense", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MTI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2MzA0Mg==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401163042", "bodyText": "This lambda is quite long. Could you move it to a helper function. e.g. void onEncryptionComplete(EncryptJobResult, Exception)?", "author": "cgtz", "createdAt": "2020-03-31T19:32:25Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1152,42 +1147,62 @@ private void encryptChunk() {\n         logger.trace(\"Submitting encrypt job for chunk at index {}\", chunkIndex);\n         cryptoJobHandler.submitJob(\n             new EncryptJob(passedInBlobProperties.getAccountId(), passedInBlobProperties.getContainerId(),\n-                isMetadataChunk() ? null : buf, ByteBuffer.wrap(chunkUserMetadata), kms.getRandomKey(), cryptoService,\n-                kms, encryptJobMetricsTracker, (EncryptJob.EncryptJobResult result, Exception exception) -> {\n-              logger.trace(\"Processing encrypt job callback for chunk at index {}\", chunkIndex);\n-              encryptJobMetricsTracker.onJobResultProcessingStart();\n-              if (exception == null && !isOperationComplete()) {\n-                if (!isMetadataChunk()) {\n-                  buf = result.getEncryptedBlobContent();\n-                }\n-                encryptedPerBlobKey = result.getEncryptedKey();\n-                chunkUserMetadata = result.getEncryptedUserMetadata().array();\n-                logger.trace(\"Completing encrypt job result for chunk at index {}\", chunkIndex);\n-                prepareForSending();\n-                chunkReadyAtMs = time.milliseconds();\n-              } else {\n-                encryptJobMetricsTracker.incrementOperationError();\n-                if (!isOperationComplete()) {\n-                  logger.trace(\"Setting exception from encrypt of chunk at index {} \", chunkIndex, exception);\n-                  setOperationExceptionAndComplete(\n-                      new RouterException(\"Exception thrown on encrypting the content for chunk at index \" + chunkIndex,\n-                          exception, RouterErrorCode.UnexpectedInternalError));\n-                } else {\n-                  logger.trace(\n-                      \"Ignoring exception from encrypt job for chunk at index {} as operation exception {} is set already\",\n-                      chunkIndex, getOperationException(), exception);\n-                }\n-              }\n-              routerMetrics.encryptTimeMs.update(time.milliseconds() - chunkEncryptReadyAtMs);\n-              encryptJobMetricsTracker.onJobResultProcessingComplete();\n-              routerCallback.onPollReady();\n-            }));\n+                isMetadataChunk() ? null : toEncrypt.retainedDuplicate(), ByteBuffer.wrap(chunkUserMetadata),\n+                kms.getRandomKey(), cryptoService, kms, encryptJobMetricsTracker,\n+                (EncryptJob.EncryptJobResult result, Exception exception) -> {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NTEzMw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401165133", "bodyText": "It seems like this buffer is retained and then retained again with toEncrypt.retainedDuplicate() and then released at the end of this method. Could the retain from this line and release on 1204 be removed?", "author": "cgtz", "createdAt": "2020-03-31T19:36:15Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1144,6 +1138,7 @@ private void prepareForSending() {\n      * Submits encrypt job for the given {@link PutChunk} and processes the callback for the same\n      */\n     private void encryptChunk() {\n+      ByteBuf toEncrypt = buf.retain();", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjEzNA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966134", "bodyText": "legacy code.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NTEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2ODI4NA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401168284", "bodyText": "for declaringtoWrite and remaininSlice you can remove the assignment part because of each of them are assigned by all the cases afterwards", "author": "cgtz", "createdAt": "2020-03-31T19:42:03Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjIyOA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966228", "bodyText": "updated to new code.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2ODI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2ODM4OQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401168389", "bodyText": "size unused", "author": "cgtz", "createdAt": "2020-03-31T19:42:16Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;\n+      if (buf == null) {\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MTQzNw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401171437", "bodyText": "The javadocs for CompositeByteBuf recommend using the alloc.compositeBuffer() methods if possible. Probably since the allocators seem to wrap the buffer with extra leak detection stuff (see AbstractByteBufAllocator). Also, the third param is the max number of child components in the buffer, not the max size in bytes. I guess it is still valuable to raise the limit since the default limit seems to be 16 from AbstractByteBufAllocator.\nThis can probably be composite = buf.isDirect()? buf.alloc().compositeDirectBuffer(maxComponents) : buf.alloc().compositeHeapBuffer(maxComponents) instead.", "author": "cgtz", "createdAt": "2020-03-31T19:47:56Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;\n+      if (buf == null) {\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();\n+        // buf already has some bytes\n+        if (buf instanceof CompositeByteBuf) {\n+          // Buf is already a CompositeByteBuf, then just add the slice from\n+          ((CompositeByteBuf) buf).addComponent(true, remainingSlice);\n+        } else {\n+          CompositeByteBuf composite =\n+              new CompositeByteBuf(buf.alloc(), buf.isDirect(), routerConfig.routerMaxPutChunkSizeBytes);", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjI2Mw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966263", "bodyText": "make sense.", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEwMw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401177103", "bodyText": "What if channelReadBuf was already a CompositeByteBuf? Would it be safer to just initialize the buffer in prepareForBuilding instead of use type checking logic here? The only thing that I think would be lost would be if the buffer came with a non-default allocator and the logic about direct vs not, but I don't think either of these will be used in practice unless the composite buffers capacity is expanded or components are squashed together inside.", "author": "cgtz", "createdAt": "2020-03-31T19:57:58Z", "path": "ambry-router/src/main/java/com.github.ambry.router/PutOperation.java", "diffHunk": "@@ -1211,22 +1225,43 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite = 0;\n+      if (buf == null) {\n+        if (channelReadBuf.readableBytes() > routerConfig.routerMaxPutChunkSizeBytes) {\n+          toWrite = routerConfig.routerMaxPutChunkSizeBytes;\n+          buf = channelReadBuf.readRetainedSlice(routerConfig.routerMaxPutChunkSizeBytes);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          buf = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        ByteBuf remainingSlice = null;\n+        if (channelReadBuf.readableBytes() > remainingSize) {\n+          toWrite = remainingSize;\n+          remainingSlice = channelReadBuf.readRetainedSlice(remainingSize);\n+        } else {\n+          toWrite = channelReadBuf.readableBytes();\n+          remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        }\n+        int size = buf.readableBytes();\n+        // buf already has some bytes\n+        if (buf instanceof CompositeByteBuf) {", "originalCommit": "06c6a6e01f9632d3c206ef1ed9cdadeabc85b8b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjY2Nw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401966667", "bodyText": "I was under the impression that channelReadBuf is passed to PutOperation from HttpContent and shouldn't be composite bytebuf. Is there cases where it will be composite bytebuf?", "author": "justinlin-linkedin", "createdAt": "2020-04-01T23:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3MTE4MA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r401971180", "bodyText": "You're probably right that there are no cases in practice with the chunked HttpContents we use. I just wanted to not make too many assumptions about the input in case something changes down the line", "author": "cgtz", "createdAt": "2020-04-01T23:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3ODE1MQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r403378151", "bodyText": "If we keep this code as it's, then when the channelReadBuf is a CompositeByteBuf, then when we do channelReadBuf.readRetainedSlice, it returns a unpooled ByteBuf. I suppose the code would still operate, but just not with the optimized memory arranagement.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T23:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzEwMw=="}], "type": "inlineReview"}, {"oid": "7898d32775be9befbe576ff3fe427a21d04afb26", "url": "https://github.com/linkedin/ambry/commit/7898d32775be9befbe576ff3fe427a21d04afb26", "message": "Rebase", "committedDate": "2020-04-01T20:30:20Z", "type": "forcePushed"}, {"oid": "be15980490dd0d8fec8fdf7d7f5d8545dba2be3e", "url": "https://github.com/linkedin/ambry/commit/be15980490dd0d8fec8fdf7d7f5d8545dba2be3e", "message": "Comments", "committedDate": "2020-04-01T20:36:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNTc0NQ==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r402515745", "bodyText": "any reason to increase it?", "author": "zzmao", "createdAt": "2020-04-02T18:13:24Z", "path": "ambry-router/src/main/java/com/github/ambry/router/CryptoJobHandler.java", "diffHunk": "@@ -71,7 +71,7 @@ public void close() {\n         }\n       }\n       try {\n-        scheduler.awaitTermination(1000, TimeUnit.MILLISECONDS);\n+        scheduler.awaitTermination(10000, TimeUnit.MILLISECONDS);", "originalCommit": "573eefe64025e2a6cc69c95eb02dd89b155b471f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3OTc0Ng==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r403379746", "bodyText": "for testing purpose, i will revert.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T23:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNTc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzQ5NA==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r402523494", "bodyText": "Can you explain a little bit how fillFrom triggered?  I am not familiar with this area.\nFor 1 MB blob put, will it trigger fillFrom multiple times?\nMy concern here is if this will cause many small ByteBufs in buf.", "author": "zzmao", "createdAt": "2020-04-02T18:26:53Z", "path": "ambry-router/src/main/java/com/github/ambry/router/PutOperation.java", "diffHunk": "@@ -1211,22 +1229,33 @@ void onFillComplete(boolean updateMetric) {\n     }\n \n     /**\n-     * Fill the buffer of the current chunk with the data from the given {@link ByteBuffer}.\n-     * @param channelReadBuffer the {@link ByteBuffer} from which to read data.\n+     * Fill the buffer of the current chunk with the data from the given {@link ByteBuf}.\n+     * @param channelReadBuf the {@link ByteBuf} from which to read data.\n      * @return the number of bytes transferred in this operation.\n      */\n-    int fillFrom(ByteBuffer channelReadBuffer) {\n-      int toWrite = Math.min(channelReadBuffer.remaining(), buf.remaining());\n-      if (channelReadBuffer.remaining() > buf.remaining()) {\n-        // Manipulate limit of the source buffer in order to read only enough to fill the chunk\n-        int savedLimit = channelReadBuffer.limit();\n-        channelReadBuffer.limit(channelReadBuffer.position() + buf.remaining());\n-        buf.put(channelReadBuffer);\n-        channelReadBuffer.limit(savedLimit);\n+    int fillFrom(ByteBuf channelReadBuf) {\n+      int toWrite;\n+      if (buf == null) {\n+        // If current buf is null, then only read the up to routerMaxPutChunkSizeBytes.\n+        toWrite = Math.min(channelReadBuf.readableBytes(), routerConfig.routerMaxPutChunkSizeBytes);\n+        buf = channelReadBuf.readRetainedSlice(toWrite);\n       } else {\n-        buf.put(channelReadBuffer);\n+        int remainingSize = routerConfig.routerMaxPutChunkSizeBytes - buf.readableBytes();\n+        toWrite = Math.min(channelReadBuf.readableBytes(), remainingSize);\n+        ByteBuf remainingSlice = channelReadBuf.readRetainedSlice(toWrite);\n+        // buf already has some bytes", "originalCommit": "573eefe64025e2a6cc69c95eb02dd89b155b471f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3OTE4Nw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r403379187", "bodyText": "It depends on how the http content works. For http put request, frontend would receive a bunch of netty httpContents, each http content carries a netty bytebuf, which is channelReadBuf. PutManager has a running thread that calls fillFrom periodically.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T23:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3OTU3Nw==", "url": "https://github.com/linkedin/ambry/pull/1439#discussion_r403379577", "bodyText": "If we have a 1MB blob, if the frontend receives 10 100K bytebuf, then the final buf would have 10 small ByteBuf. But the important thing is this is zero-copy bytebuf. We don't have to move any bytes from one place to another.", "author": "justinlin-linkedin", "createdAt": "2020-04-03T23:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzQ5NA=="}], "type": "inlineReview"}, {"oid": "ca1583e6dd81d1097a856553990b84b354114732", "url": "https://github.com/linkedin/ambry/commit/ca1583e6dd81d1097a856553990b84b354114732", "message": "Using Netty ByteByte in PutOperation", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "3ba16d5908141ec0955d17afbd5617dbab4ab6db", "url": "https://github.com/linkedin/ambry/commit/3ba16d5908141ec0955d17afbd5617dbab4ab6db", "message": "Comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "1436919a5886e64d89587704ca0682c1e4e1a71f", "url": "https://github.com/linkedin/ambry/commit/1436919a5886e64d89587704ca0682c1e4e1a71f", "message": "Comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "url": "https://github.com/linkedin/ambry/commit/1ce21a3cc3a1d51e28602ba7997a18d0ce303994", "message": "Address comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "800d95e84c472219464019dded7a628f5d7ca084", "url": "https://github.com/linkedin/ambry/commit/800d95e84c472219464019dded7a628f5d7ca084", "message": "Comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "8081abee24fdbf49e321a60604957fb09f666b79", "url": "https://github.com/linkedin/ambry/commit/8081abee24fdbf49e321a60604957fb09f666b79", "message": "Another comments", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "2897ff86eb5d41c300a7c539fd52eef00b0dd429", "url": "https://github.com/linkedin/ambry/commit/2897ff86eb5d41c300a7c539fd52eef00b0dd429", "message": "Fix test failure", "committedDate": "2020-04-03T23:02:41Z", "type": "commit"}, {"oid": "cec396a216436b638079bd8c60fee71151eb19c7", "url": "https://github.com/linkedin/ambry/commit/cec396a216436b638079bd8c60fee71151eb19c7", "message": "Address comments", "committedDate": "2020-04-03T23:16:39Z", "type": "commit"}, {"oid": "cec396a216436b638079bd8c60fee71151eb19c7", "url": "https://github.com/linkedin/ambry/commit/cec396a216436b638079bd8c60fee71151eb19c7", "message": "Address comments", "committedDate": "2020-04-03T23:16:39Z", "type": "forcePushed"}]}