{"pr_number": 1619, "pr_title": "Initial PR to support storing account metadata in MySql database", "pr_createdAt": "2020-09-08T17:06:18Z", "pr_url": "https://github.com/linkedin/ambry/pull/1619", "timeline": [{"oid": "be9e90b17bef2d3a7ec6102b67a100d6d23aedb5", "url": "https://github.com/linkedin/ambry/commit/be9e90b17bef2d3a7ec6102b67a100d6d23aedb5", "message": "Setup feature branch for mysql account store", "committedDate": "2020-08-24T05:47:05Z", "type": "commit"}, {"oid": "4224edfc3631dd248193c210a9359af14a34bccd", "url": "https://github.com/linkedin/ambry/commit/4224edfc3631dd248193c210a9359af14a34bccd", "message": "Add AccountMetadata table schema and AccountTable class", "committedDate": "2020-08-24T20:12:39Z", "type": "commit"}, {"oid": "2b9e63f9b982d7ece80a1da671a48a7e6d53b598", "url": "https://github.com/linkedin/ambry/commit/2b9e63f9b982d7ece80a1da671a48a7e6d53b598", "message": "Merge pull request #1 from Arun-LinkedIn/mysql-accounts-mybranch\n\nAdd AccountMetadata table schema and AccountTable class", "committedDate": "2020-08-24T20:34:04Z", "type": "commit"}, {"oid": "806c2d0300e433820a9b1a6cea43b5c0d3e982e6", "url": "https://github.com/linkedin/ambry/commit/806c2d0300e433820a9b1a6cea43b5c0d3e982e6", "message": "Command line tool to initialize and compare/validate mysql tables with zk", "committedDate": "2020-08-27T22:26:25Z", "type": "commit"}, {"oid": "8972648a21c58cfc33371c5e0e9aed4f768bc379", "url": "https://github.com/linkedin/ambry/commit/8972648a21c58cfc33371c5e0e9aed4f768bc379", "message": "Changes to:\n1. Remove container information from accounts before populating Account table\n2. Print more details for mismatched containers", "committedDate": "2020-08-31T02:17:26Z", "type": "commit"}, {"oid": "7f3c64f42a3510863ee64769110a14979021f45a", "url": "https://github.com/linkedin/ambry/commit/7f3c64f42a3510863ee64769110a14979021f45a", "message": " Update helper method in AccountSerdeUtils to exclude containers while building json for Accounts (used while storing Accounts in DB)", "committedDate": "2020-08-31T22:42:16Z", "type": "commit"}, {"oid": "16aa623e47f63fd2b695246a6a7bc6de9571bce6", "url": "https://github.com/linkedin/ambry/commit/16aa623e47f63fd2b695246a6a7bc6de9571bce6", "message": "Merge pull request #2 from Arun-LinkedIn/mysql-accounts-mybranch\n\nCommand line tool to initialize and compare/validate mysql tables with zk", "committedDate": "2020-08-31T23:40:38Z", "type": "commit"}, {"oid": "9e6463968b29240ca8a445e550084648dd07b912", "url": "https://github.com/linkedin/ambry/commit/9e6463968b29240ca8a445e550084648dd07b912", "message": "Refactor/rename classes and add unit tests", "committedDate": "2020-09-04T06:50:02Z", "type": "commit"}, {"oid": "dec12d1e20328bda46a1288a2536ba4c6acffc51", "url": "https://github.com/linkedin/ambry/commit/dec12d1e20328bda46a1288a2536ba4c6acffc51", "message": "Enhancements to MySqlDataAccessor", "committedDate": "2020-09-08T07:01:40Z", "type": "commit"}, {"oid": "167bc13f41956394414138176ec9523327e5eb48", "url": "https://github.com/linkedin/ambry/commit/167bc13f41956394414138176ec9523327e5eb48", "message": "Add missing license and javadoc", "committedDate": "2020-09-09T05:04:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4Mzk3OQ==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r485983979", "bodyText": "Nit: seems like copy paste error", "author": "Arun-LinkedIn", "createdAt": "2020-09-09T23:55:18Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/MySqlConfig.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.config.Config;\n+import com.github.ambry.config.Default;\n+import com.github.ambry.config.VerifiableProperties;\n+\n+\n+/**\n+ * Config for MySql database connection.\n+ */\n+public class MySqlConfig {\n+\n+  public static final String MYSQL_URL = \"mysql.url\";\n+  public static final String MYSQL_USER = \"mysql.user\";\n+  public static final String MYSQL_PASSWORD = \"mysql.password\";\n+  /**\n+   * Flag indicating whether to use DirectHttps CosmosDB connection mode.\n+   * Provides better performance but may not work with all firewall settings.", "originalCommit": "167bc13f41956394414138176ec9523327e5eb48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "url": "https://github.com/linkedin/ambry/commit/6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "message": "Address Arun review comment", "committedDate": "2020-09-10T16:43:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzOTkwNA==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486639904", "bodyText": "Line 86 and 88 can be removed.", "author": "jsjtzyy", "createdAt": "2020-09-10T21:19:55Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.AccountSerdeUtils;\n+import com.github.ambry.account.Container;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * Account Data Access Object.\n+ */\n+public class AccountDao {\n+\n+  public static final String ACCOUNT_TABLE = \"Accounts\";\n+  public static final String ACCOUNT_INFO = \"accountInfo\";\n+  public static final String VERSION = \"version\";\n+  public static final String CREATION_TIME = \"creationTime\";\n+  public static final String LAST_MODIFIED_TIME = \"lastModifiedTime\";\n+\n+  private final MySqlDataAccessor dataAccessor;\n+  private final String insertSql;\n+  private final String getSinceSql;\n+\n+  public AccountDao(MySqlDataAccessor dataAccessor) {\n+    this.dataAccessor = dataAccessor;\n+    insertSql =\n+        String.format(\"insert into %s (%s, %s, %s, %s) values (?, ?, now(), now())\", ACCOUNT_TABLE, ACCOUNT_INFO,\n+            VERSION, CREATION_TIME, LAST_MODIFIED_TIME);\n+    getSinceSql =\n+        String.format(\"select %s, %s from %s where %s > ?\", ACCOUNT_INFO, LAST_MODIFIED_TIME, ACCOUNT_TABLE,\n+            LAST_MODIFIED_TIME);\n+  }\n+\n+  /**\n+   * Add an account to the database.\n+   * @param account the account to insert.\n+   * @throws SQLException\n+   */\n+  public void addAccount(Account account) throws SQLException {\n+    try {\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertSql);\n+      insertStatement.setString(1, AccountSerdeUtils.accountToJson(account, true));\n+      insertStatement.setInt(2, account.getSnapshotVersion());\n+      insertStatement.executeUpdate();\n+    } catch (SQLException e) {\n+      // TODO: record failure, parse exception to figure out what we did wrong (eg. id or name collision)\n+      // For now, assume connection issue.\n+      dataAccessor.reset();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets all accounts that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Account}.\n+   * @throws SQLException\n+   */\n+  public List<Account> getNewAccounts(long updatedSince) throws SQLException {\n+    List<Account> accounts = new ArrayList<>();\n+    Timestamp sinceTime = new Timestamp(updatedSince);\n+    PreparedStatement getSinceStatement = dataAccessor.getPreparedStatement(getSinceSql);\n+    getSinceStatement.setTimestamp(1, sinceTime);\n+    try (ResultSet rs = getSinceStatement.executeQuery()) {\n+      while (rs.next()) {\n+        String accountJson = rs.getString(ACCOUNT_INFO);\n+        Timestamp lastModifiedTime = rs.getTimestamp(LAST_MODIFIED_TIME);\n+        Account account = AccountSerdeUtils.accountFromJson(accountJson);\n+        //account.setLastModifiedTime(lastModifiedTime);", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3NzI4MA==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486777280", "bodyText": "Changed to a TODO", "author": "lightningrob", "createdAt": "2020-09-11T05:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzOTkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0MDgxMA==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486640810", "bodyText": "Minor: format this file to clean up some unused imports", "author": "jsjtzyy", "createdAt": "2020-09-10T21:21:40Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/AccountDao.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.AccountSerdeUtils;\n+import com.github.ambry.account.Container;", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1MjI4NQ==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486652285", "bodyText": "I wonder where the CONTAINER_ID will be used. I don't see it in the table and container object should contain the id already.", "author": "jsjtzyy", "createdAt": "2020-09-10T21:47:32Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/ContainerDao.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.account.AccountSerdeUtils;\n+import com.github.ambry.account.Container;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * Container Data Access Object.\n+ */\n+public class ContainerDao {\n+  public static final String CONTAINER_TABLE = \"Containers\";\n+  // TODO: make Container key constants public\n+  public static final String ACCOUNT_ID = \"accountId\";\n+  public static final String CONTAINER_ID = \"containerId\";", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3ODE5Ng==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486778196", "bodyText": "containerId is a derived field in the table schema, and it will be used in update queries to be added.", "author": "lightningrob", "createdAt": "2020-09-11T05:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1MjI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1NjY3Ng==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486656676", "bodyText": "Just curious, looks like the version is always 1, and when will it be bumped?", "author": "jsjtzyy", "createdAt": "2020-09-10T21:57:59Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/ContainerDao.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.account.AccountSerdeUtils;\n+import com.github.ambry.account.Container;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * Container Data Access Object.\n+ */\n+public class ContainerDao {\n+  public static final String CONTAINER_TABLE = \"Containers\";\n+  // TODO: make Container key constants public\n+  public static final String ACCOUNT_ID = \"accountId\";\n+  public static final String CONTAINER_ID = \"containerId\";\n+  public static final String CONTAINER_INFO = \"containerInfo\";\n+  public static final String VERSION = \"version\";\n+  public static final String CREATION_TIME = \"creationTime\";\n+  public static final String LAST_MODIFIED_TIME = \"lastModifiedTime\";\n+\n+  private final MySqlDataAccessor dataAccessor;\n+  private final String insertSql;\n+  private final String getSinceSql;\n+  private final String getByAccountSql;\n+\n+  public ContainerDao(MySqlDataAccessor dataAccessor) {\n+    this.dataAccessor = dataAccessor;\n+    insertSql =\n+        String.format(\"insert into %s (%s, %s, %s, %s, %s) values (?, ?, 1, now(), now())\", CONTAINER_TABLE, ACCOUNT_ID,", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3ODM5NA==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486778394", "bodyText": "On updates (will be in the next PR)", "author": "lightningrob", "createdAt": "2020-09-11T05:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1NjY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY3NTgyMg==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486675822", "bodyText": "same here,  both line 127 and 129 can be removed", "author": "jsjtzyy", "createdAt": "2020-09-10T22:49:10Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/ContainerDao.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.account.AccountSerdeUtils;\n+import com.github.ambry.account.Container;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * Container Data Access Object.\n+ */\n+public class ContainerDao {\n+  public static final String CONTAINER_TABLE = \"Containers\";\n+  // TODO: make Container key constants public\n+  public static final String ACCOUNT_ID = \"accountId\";\n+  public static final String CONTAINER_ID = \"containerId\";\n+  public static final String CONTAINER_INFO = \"containerInfo\";\n+  public static final String VERSION = \"version\";\n+  public static final String CREATION_TIME = \"creationTime\";\n+  public static final String LAST_MODIFIED_TIME = \"lastModifiedTime\";\n+\n+  private final MySqlDataAccessor dataAccessor;\n+  private final String insertSql;\n+  private final String getSinceSql;\n+  private final String getByAccountSql;\n+\n+  public ContainerDao(MySqlDataAccessor dataAccessor) {\n+    this.dataAccessor = dataAccessor;\n+    insertSql =\n+        String.format(\"insert into %s (%s, %s, %s, %s, %s) values (?, ?, 1, now(), now())\", CONTAINER_TABLE, ACCOUNT_ID,\n+            CONTAINER_INFO, VERSION, CREATION_TIME, LAST_MODIFIED_TIME);\n+    getSinceSql =\n+        String.format(\"select %s, %s, %s from %s where %s > ?\", ACCOUNT_ID, CONTAINER_INFO, LAST_MODIFIED_TIME,\n+            CONTAINER_TABLE, LAST_MODIFIED_TIME);\n+    getByAccountSql =\n+        String.format(\"select %s, %s, %s from %s where %s = ?\", ACCOUNT_ID, CONTAINER_INFO, LAST_MODIFIED_TIME,\n+            CONTAINER_TABLE, ACCOUNT_ID);\n+  }\n+\n+  /**\n+   * Add a container to the database.\n+   * @param accountId the container's parent account id.\n+   * @param container the container to insert.\n+   * @throws SQLException\n+   */\n+  public void addContainer(int accountId, Container container) throws SQLException {\n+    try {\n+      // Note: assuming autocommit for now\n+      PreparedStatement insertStatement = dataAccessor.getPreparedStatement(insertSql);\n+      insertStatement.setInt(1, accountId);\n+      insertStatement.setString(2, AccountSerdeUtils.containerToJson(container));\n+      insertStatement.executeUpdate();\n+    } catch (SQLException e) {\n+      // TODO: record failure, parse exception to figure out what we did wrong (eg. id or name collision)\n+      // For now, assume connection issue.\n+      dataAccessor.reset();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets the containers in a specified account.\n+   * @param accountId the id for the account.\n+   * @return a list of {@link Container}.\n+   * @throws SQLException\n+   */\n+  public List<Container> getContainers(int accountId) throws SQLException {\n+    PreparedStatement getByAccountStatement = dataAccessor.getPreparedStatement(getByAccountSql);\n+    getByAccountStatement.setInt(1, accountId);\n+    try (ResultSet rs = getByAccountStatement.executeQuery()) {\n+      return convertResultSet(rs);\n+    } catch (SQLException e) {\n+      // record failure, parse exception, ...\n+      dataAccessor.reset();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Gets all containers that have been created or modified since the specified time.\n+   * @param updatedSince the last modified time used to filter.\n+   * @return a list of {@link Container}.\n+   * @throws SQLException\n+   */\n+  public List<Container> getNewContainers(long updatedSince) throws SQLException {\n+    Timestamp sinceTime = new Timestamp(updatedSince);\n+    PreparedStatement getSinceStatement = dataAccessor.getPreparedStatement(getSinceSql);\n+    getSinceStatement.setTimestamp(1, sinceTime);\n+    try (ResultSet rs = getSinceStatement.executeQuery()) {\n+      return convertResultSet(rs);\n+    } catch (SQLException e) {\n+      // record failure, parse exception, ...\n+      dataAccessor.reset();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Convert a query result set to a list of containers.\n+   * @param resultSet the result set.\n+   * @return a list of containers.\n+   * @throws SQLException\n+   */\n+  private List<Container> convertResultSet(ResultSet resultSet) throws SQLException {\n+    List<Container> containers = new ArrayList<>();\n+    while (resultSet.next()) {\n+      int accountId = resultSet.getInt(ACCOUNT_ID);\n+      String containerJson = resultSet.getString(CONTAINER_INFO);\n+      Timestamp lastModifiedTime = resultSet.getTimestamp(LAST_MODIFIED_TIME);\n+      Container container = AccountSerdeUtils.containerFromJson(containerJson, (short) accountId);\n+      //container.setLastModifiedTime(lastModifiedTime);", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc3ODYyNg==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486778626", "bodyText": "changed to TODO", "author": "lightningrob", "createdAt": "2020-09-11T05:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY3NTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY3NjIyOQ==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486676229", "bodyText": "Format this file to remove unused import.", "author": "jsjtzyy", "createdAt": "2020-09-10T22:50:24Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/MySqlConfig.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.config.Config;\n+import com.github.ambry.config.Default;", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MDE4OA==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486680188", "bodyText": "format this file", "author": "jsjtzyy", "createdAt": "2020-09-10T23:02:55Z", "path": "ambry-account/src/main/java/com/github/ambry/account/mysql/MySqlDataAccessor.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import java.sql.Connection;\n+import java.sql.Driver;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Data Accessor to connect to MySql database.\n+ */\n+public class MySqlDataAccessor {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlDataAccessor.class);\n+  private final String mysqlUrl;\n+  private final String mysqlUser;\n+  private final String mysqlPassword;\n+  private final Driver mysqlDriver;\n+  private Connection activeConnection;\n+  private final Map<String, PreparedStatement> statementCache = new HashMap<>();\n+\n+  /** Production constructor */\n+  public MySqlDataAccessor(MySqlConfig config) throws SQLException {\n+    // TODO: this will become a list of url's with info on which ones are writeable\n+    // Q: Can we assume url's share credentials or does each need its own?\n+    mysqlUrl = config.mysqlUrl;\n+    mysqlUser = config.mysqlUser;\n+    mysqlPassword = config.mysqlPassword;\n+    // Initialize driver\n+    mysqlDriver = DriverManager.getDriver(mysqlUrl);\n+    // AccountService needs to work if mysql is down.  Mysql can also reboot.\n+    try {\n+      getDatabaseConnection();\n+    } catch (SQLException e) {\n+      // try again later\n+    }\n+  }\n+\n+  /** Test constructor */\n+  public MySqlDataAccessor(MySqlConfig config, Driver mysqlDriver) {\n+    mysqlUrl = config.mysqlUrl;\n+    mysqlUser = config.mysqlUser;\n+    mysqlPassword = config.mysqlPassword;\n+    this.mysqlDriver = mysqlDriver;\n+  }\n+\n+  /**\n+   * @return a JDBC {@link Connection} to the database.  An existing connection will be reused.\n+   * @throws SQLException\n+   */\n+  public synchronized Connection getDatabaseConnection() throws SQLException {\n+    if (activeConnection != null && activeConnection.isValid(5)) {\n+      return activeConnection;\n+    }\n+    if (activeConnection != null) {\n+      activeConnection.close();\n+    }\n+    // TODO: when we have list of hosts, try them in order and track whether the one we get can handle writes\n+    Properties credentials = new Properties();\n+    credentials.setProperty(\"user\", mysqlUser);\n+    credentials.setProperty(\"password\", mysqlPassword);\n+    activeConnection = mysqlDriver.connect(mysqlUrl, credentials);\n+    return activeConnection;\n+  }\n+\n+  /**\n+   * @return a {@link PreparedStatement} using the supplied SQL text.\n+   * @param sql the SQL text to use.\n+   * @throws SQLException\n+   */\n+  public synchronized PreparedStatement getPreparedStatement(String sql) throws SQLException {\n+    PreparedStatement statement = statementCache.get(sql);\n+    if (statement != null) {\n+      return statement;\n+    }\n+    Connection connection = getDatabaseConnection();\n+    statement = connection.prepareStatement(sql);\n+    statementCache.put(sql, statement);\n+    return statement;\n+  }\n+\n+  /**\n+   * Reset to initial state.\n+   * This should be called after a failed database operation.\n+   */\n+  synchronized void reset() {\n+    for (PreparedStatement statement: statementCache.values()) {", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MTc1Nw==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486681757", "bodyText": "nit: 0l-> 0L", "author": "jsjtzyy", "createdAt": "2020-09-10T23:07:50Z", "path": "ambry-account/src/test/java/com/github/ambry/account/mysql/AccountDaoTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.AccountBuilder;\n+import com.github.ambry.account.AccountSerdeUtils;\n+import com.github.ambry.config.VerifiableProperties;\n+import java.sql.Connection;\n+import java.sql.Driver;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Properties;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/** Unit test for AccountDao class */\n+@RunWith(MockitoJUnitRunner.class)\n+public class AccountDaoTest {\n+\n+  private final short accountId = 101;\n+  private final String accountName = \"samza\";\n+  private final Account testAccount;\n+  private final String accountJson;\n+  private final MySqlDataAccessor dataAccessor;\n+  private final Connection mockConnection;\n+  private final AccountDao accountDao;\n+\n+  public AccountDaoTest() throws SQLException {\n+    testAccount = new AccountBuilder(accountId, accountName, Account.AccountStatus.ACTIVE).build();\n+    accountJson = AccountSerdeUtils.accountToJson(testAccount, true);\n+    mockConnection = mock(Connection.class);\n+    PreparedStatement mockInsertStatement = mock(PreparedStatement.class);\n+    when(mockConnection.prepareStatement(contains(\"insert into\"))).thenReturn(mockInsertStatement);\n+    when(mockInsertStatement.executeUpdate()).thenReturn(1);\n+    PreparedStatement mockQueryStatement = mock(PreparedStatement.class);\n+    when(mockConnection.prepareStatement(startsWith(\"select\"))).thenReturn(mockQueryStatement);\n+    ResultSet mockResultSet = mock(ResultSet.class);\n+    when(mockResultSet.next()).thenReturn(true).thenReturn(false);\n+    when(mockResultSet.getString(eq(AccountDao.ACCOUNT_INFO))).thenReturn(accountJson);\n+    when(mockQueryStatement.executeQuery()).thenReturn(mockResultSet);\n+    dataAccessor = getDataAccessor(mockConnection);\n+    accountDao = new AccountDao(dataAccessor);\n+  }\n+\n+  /**\n+   * Utility to get a {@link MySqlDataAccessor}.\n+   * @param mockConnection the connection to use.\n+   * @return the {@link MySqlDataAccessor}.\n+   * @throws SQLException\n+   */\n+  static MySqlDataAccessor getDataAccessor(Connection mockConnection) throws SQLException {\n+    Driver mockDriver = mock(Driver.class);\n+    when(mockDriver.connect(anyString(), any(Properties.class))).thenReturn(mockConnection);\n+    //lenient().when(mockConnection.isValid(anyInt())).thenReturn(true);\n+    Properties properties = new Properties();\n+    properties.setProperty(MySqlConfig.MYSQL_URL, \"jdbc:mysql://localhost/AccountMetadata\");\n+    properties.setProperty(MySqlConfig.MYSQL_USER, \"ambry\");\n+    properties.setProperty(MySqlConfig.MYSQL_PASSWORD, \"ambry\");\n+    MySqlConfig config = new MySqlConfig(new VerifiableProperties(properties));\n+    MySqlDataAccessor dataAccessor = new MySqlDataAccessor(config, mockDriver);\n+    when(dataAccessor.getDatabaseConnection()).thenReturn(mockConnection);\n+    return dataAccessor;\n+  }\n+\n+  @Test\n+  public void testAddAccount() throws Exception {\n+    accountDao.addAccount(testAccount);\n+  }\n+\n+  @Test\n+  public void testGetAccounts() throws Exception {\n+    List<Account> accountList = accountDao.getNewAccounts(0l);", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MTkzMQ==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486681931", "bodyText": "remove this", "author": "jsjtzyy", "createdAt": "2020-09-10T23:08:29Z", "path": "ambry-account/src/test/java/com/github/ambry/account/mysql/AccountDaoTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.AccountBuilder;\n+import com.github.ambry.account.AccountSerdeUtils;\n+import com.github.ambry.config.VerifiableProperties;\n+import java.sql.Connection;\n+import java.sql.Driver;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Properties;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/** Unit test for AccountDao class */\n+@RunWith(MockitoJUnitRunner.class)\n+public class AccountDaoTest {\n+\n+  private final short accountId = 101;\n+  private final String accountName = \"samza\";\n+  private final Account testAccount;\n+  private final String accountJson;\n+  private final MySqlDataAccessor dataAccessor;\n+  private final Connection mockConnection;\n+  private final AccountDao accountDao;\n+\n+  public AccountDaoTest() throws SQLException {\n+    testAccount = new AccountBuilder(accountId, accountName, Account.AccountStatus.ACTIVE).build();\n+    accountJson = AccountSerdeUtils.accountToJson(testAccount, true);\n+    mockConnection = mock(Connection.class);\n+    PreparedStatement mockInsertStatement = mock(PreparedStatement.class);\n+    when(mockConnection.prepareStatement(contains(\"insert into\"))).thenReturn(mockInsertStatement);\n+    when(mockInsertStatement.executeUpdate()).thenReturn(1);\n+    PreparedStatement mockQueryStatement = mock(PreparedStatement.class);\n+    when(mockConnection.prepareStatement(startsWith(\"select\"))).thenReturn(mockQueryStatement);\n+    ResultSet mockResultSet = mock(ResultSet.class);\n+    when(mockResultSet.next()).thenReturn(true).thenReturn(false);\n+    when(mockResultSet.getString(eq(AccountDao.ACCOUNT_INFO))).thenReturn(accountJson);\n+    when(mockQueryStatement.executeQuery()).thenReturn(mockResultSet);\n+    dataAccessor = getDataAccessor(mockConnection);\n+    accountDao = new AccountDao(dataAccessor);\n+  }\n+\n+  /**\n+   * Utility to get a {@link MySqlDataAccessor}.\n+   * @param mockConnection the connection to use.\n+   * @return the {@link MySqlDataAccessor}.\n+   * @throws SQLException\n+   */\n+  static MySqlDataAccessor getDataAccessor(Connection mockConnection) throws SQLException {\n+    Driver mockDriver = mock(Driver.class);\n+    when(mockDriver.connect(anyString(), any(Properties.class))).thenReturn(mockConnection);\n+    //lenient().when(mockConnection.isValid(anyInt())).thenReturn(true);", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MjIxMQ==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486682211", "bodyText": "Can we get the account to verify?", "author": "jsjtzyy", "createdAt": "2020-09-10T23:09:21Z", "path": "ambry-account/src/test/java/com/github/ambry/account/mysql/AccountDaoTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.account.Account;\n+import com.github.ambry.account.AccountBuilder;\n+import com.github.ambry.account.AccountSerdeUtils;\n+import com.github.ambry.config.VerifiableProperties;\n+import java.sql.Connection;\n+import java.sql.Driver;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.Properties;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/** Unit test for AccountDao class */\n+@RunWith(MockitoJUnitRunner.class)\n+public class AccountDaoTest {\n+\n+  private final short accountId = 101;\n+  private final String accountName = \"samza\";\n+  private final Account testAccount;\n+  private final String accountJson;\n+  private final MySqlDataAccessor dataAccessor;\n+  private final Connection mockConnection;\n+  private final AccountDao accountDao;\n+\n+  public AccountDaoTest() throws SQLException {\n+    testAccount = new AccountBuilder(accountId, accountName, Account.AccountStatus.ACTIVE).build();\n+    accountJson = AccountSerdeUtils.accountToJson(testAccount, true);\n+    mockConnection = mock(Connection.class);\n+    PreparedStatement mockInsertStatement = mock(PreparedStatement.class);\n+    when(mockConnection.prepareStatement(contains(\"insert into\"))).thenReturn(mockInsertStatement);\n+    when(mockInsertStatement.executeUpdate()).thenReturn(1);\n+    PreparedStatement mockQueryStatement = mock(PreparedStatement.class);\n+    when(mockConnection.prepareStatement(startsWith(\"select\"))).thenReturn(mockQueryStatement);\n+    ResultSet mockResultSet = mock(ResultSet.class);\n+    when(mockResultSet.next()).thenReturn(true).thenReturn(false);\n+    when(mockResultSet.getString(eq(AccountDao.ACCOUNT_INFO))).thenReturn(accountJson);\n+    when(mockQueryStatement.executeQuery()).thenReturn(mockResultSet);\n+    dataAccessor = getDataAccessor(mockConnection);\n+    accountDao = new AccountDao(dataAccessor);\n+  }\n+\n+  /**\n+   * Utility to get a {@link MySqlDataAccessor}.\n+   * @param mockConnection the connection to use.\n+   * @return the {@link MySqlDataAccessor}.\n+   * @throws SQLException\n+   */\n+  static MySqlDataAccessor getDataAccessor(Connection mockConnection) throws SQLException {\n+    Driver mockDriver = mock(Driver.class);\n+    when(mockDriver.connect(anyString(), any(Properties.class))).thenReturn(mockConnection);\n+    //lenient().when(mockConnection.isValid(anyInt())).thenReturn(true);\n+    Properties properties = new Properties();\n+    properties.setProperty(MySqlConfig.MYSQL_URL, \"jdbc:mysql://localhost/AccountMetadata\");\n+    properties.setProperty(MySqlConfig.MYSQL_USER, \"ambry\");\n+    properties.setProperty(MySqlConfig.MYSQL_PASSWORD, \"ambry\");\n+    MySqlConfig config = new MySqlConfig(new VerifiableProperties(properties));\n+    MySqlDataAccessor dataAccessor = new MySqlDataAccessor(config, mockDriver);\n+    when(dataAccessor.getDatabaseConnection()).thenReturn(mockConnection);\n+    return dataAccessor;\n+  }\n+\n+  @Test\n+  public void testAddAccount() throws Exception {\n+    accountDao.addAccount(testAccount);", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4Mzg0Nw==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486783847", "bodyText": "Hard to do in a unit test since nothing is cached.  Integration test will do this.", "author": "lightningrob", "createdAt": "2020-09-11T05:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MjIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MjY3MQ==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486682671", "bodyText": "Same here, is it viable to get the container to verify?", "author": "jsjtzyy", "createdAt": "2020-09-10T23:10:47Z", "path": "ambry-account/src/test/java/com/github/ambry/account/mysql/ContainerDaoTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account.mysql;\n+\n+import com.github.ambry.account.AccountSerdeUtils;\n+import com.github.ambry.account.Container;\n+import com.github.ambry.account.ContainerBuilder;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.List;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+/** Unit test for ContainerDao class */\n+@RunWith(MockitoJUnitRunner.class)\n+public class ContainerDaoTest {\n+\n+  private final short accountId = 101;\n+  private final short containerId = 1;\n+  private final String containerName = \"state-backup\";\n+  private final Container testContainer;\n+  private final String containerJson;\n+  private final String accountName = \"samza\";\n+  private final MySqlDataAccessor dataAccessor;\n+  private final Connection mockConnection;\n+  private final ContainerDao containerDao;\n+\n+  public ContainerDaoTest() throws SQLException {\n+    testContainer =\n+        new ContainerBuilder(containerId, containerName, Container.ContainerStatus.ACTIVE, \"\", accountId).build();\n+    containerJson = AccountSerdeUtils.containerToJson(testContainer);\n+    mockConnection = mock(Connection.class);\n+    PreparedStatement mockInsertStatement = mock(PreparedStatement.class);\n+    when(mockConnection.prepareStatement(contains(\"insert into\"))).thenReturn(mockInsertStatement);\n+    when(mockInsertStatement.executeUpdate()).thenReturn(1);\n+    PreparedStatement mockQueryStatement = mock(PreparedStatement.class);\n+    when(mockConnection.prepareStatement(startsWith(\"select\"))).thenReturn(mockQueryStatement);\n+    ResultSet mockResultSet = mock(ResultSet.class);\n+    when(mockQueryStatement.executeQuery()).thenReturn(mockResultSet);\n+    when(mockResultSet.next()).thenReturn(true).thenReturn(false);\n+    when(mockResultSet.getInt(eq(ContainerDao.ACCOUNT_ID))).thenReturn((int) accountId);\n+    when(mockResultSet.getString(eq(ContainerDao.CONTAINER_INFO))).thenReturn(containerJson);\n+    dataAccessor = AccountDaoTest.getDataAccessor(mockConnection);\n+    containerDao = new ContainerDao(dataAccessor);\n+  }\n+\n+  @Test\n+  public void testAddContainer() throws Exception {\n+    containerDao.addContainer(accountId, testContainer);", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MzQwNQ==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486683405", "bodyText": "format this file", "author": "jsjtzyy", "createdAt": "2020-09-10T23:13:07Z", "path": "ambry-tools/src/main/java/com/github/ambry/account/MySqlAccountsDBTool.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.account.mysql.AccountDao;\n+import com.github.ambry.account.mysql.ContainerDao;\n+import com.github.ambry.account.mysql.MySqlConfig;\n+import com.github.ambry.account.mysql.MySqlDataAccessor;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.HelixPropertyStoreConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.tools.util.ToolUtils;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import joptsimple.ArgumentAcceptingOptionSpec;\n+import joptsimple.OptionParser;\n+import joptsimple.OptionSet;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.zookeeper.data.Stat;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * <p>\n+ *   This is a command-line tool can be used to either:\n+ *    a) populate list of {@link Account}s and {@link Container}s into MySQL DB from {@code ZooKeeper} store\n+ *    b) compare list of {@link Account}s and {@link Container}s in MySQL DB with {@code ZooKeeper} store\n+ *   This can be used to validate that accounts and containers are correctly being updated in MySQL during migration phase and\n+ *   are in sync with ZK storage.\n+ *\n+ *   This tool takes in following parameters:\n+ *    1. 'propsFile' file which contains DB credentials needed to connect to MySQL url, username, password;\n+ *    2. 'operation' which tells to the type of operation. Supported operations are a)init, b)compare\n+ *    3. 'zkServer' - connect string of zookeeper server\n+ *    4. 'zkStorePath' - path of znode\n+ *\n+ *   A sample usage of the tool is:\n+ *     java -Dlog4j.configuration=file:../config/log4j.properties -cp ambry.jar com.github.ambry.account.MySqlAccountsDBTool\n+ *     --propsFile mysql.properties --operation init --zkServer localhost:2181  --storePath /Ambry/test/helixPropertyStore\n+ *\n+ *  A propsFile should contain:\n+ *    db.url=jdbc:mysql://localhost/db\n+ *    user=user\n+ *    password=password\n+ * </p>\n+ */\n+\n+public class MySqlAccountsDBTool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountsDBTool.class);\n+  private static String PROPSFILE = \"propsFile\";\n+  private static String OPERATION = \"operation\";\n+  private static String ZKSERVER = \"zkServer\";\n+  private static String STOREPATH = \"storePath\";\n+  private static final int ZK_CLIENT_CONNECTION_TIMEOUT_MS = 5000;\n+  private static final int ZK_CLIENT_SESSION_TIMEOUT_MS = 20000;\n+  static final String ACCOUNT_METADATA_MAP_KEY = \"accountMetadata\";\n+  static final String RELATIVE_ACCOUNT_METADATA_PATH = \"/account_metadata/full_data\";\n+\n+  private final MySqlDataAccessor mySqlDataAccessor;\n+  private final AccountDao accountDao;\n+  private final ContainerDao containerDao;\n+  private final HelixPropertyStore<ZNRecord> helixPropertyStore;\n+  private final String fullZKAccountMetadataPath;\n+\n+  enum OPERATION_TYPE {\n+    INIT, COMPARE\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    OptionParser parser = new OptionParser();\n+\n+    ArgumentAcceptingOptionSpec<String> propsFileOpt =\n+        parser.accepts(PROPSFILE, \"Properties file path\").withRequiredArg().describedAs(PROPSFILE).ofType(String.class);\n+\n+    ArgumentAcceptingOptionSpec<String> operationOpt =\n+        parser.accepts(OPERATION, \"Supported operations are 'init' and 'compare'\")\n+            .withRequiredArg()\n+            .describedAs(OPERATION)\n+            .ofType(String.class);\n+\n+    ArgumentAcceptingOptionSpec<String> zkServerOpt = parser.accepts(ZKSERVER, \"The address of ZooKeeper server\")\n+        .withRequiredArg()\n+        .describedAs(ZKSERVER)\n+        .ofType(String.class);\n+\n+    ArgumentAcceptingOptionSpec<String> storePathOpt = parser.accepts(STOREPATH,\n+        \"The root path of helix property store in the ZooKeeper. \"\n+            + \"Must start with /, and must not end with /. It is recommended to make root path in the form of \"\n+            + \"/ambry/<clustername>/helixPropertyStore. This option is required if source of storage is zookeeper.\")\n+        .withRequiredArg()\n+        .describedAs(STOREPATH)\n+        .ofType(String.class);\n+\n+    ArgumentAcceptingOptionSpec<Integer> zkConnectionTimeoutMsOpt = parser.accepts(\"zkConnectionTimeout\",\n+        \"Optional timeout in millisecond for connecting to the ZooKeeper server. This option is not required, \"\n+            + \"and the default value is 5000.\")\n+        .withRequiredArg()\n+        .describedAs(\"zk_connection_timeout\")\n+        .ofType(Integer.class)\n+        .defaultsTo(ZK_CLIENT_CONNECTION_TIMEOUT_MS);\n+\n+    ArgumentAcceptingOptionSpec<Integer> zkSessionTimeoutMsOpt = parser.accepts(\"zkSessionTimeout\",\n+        \"Optional timeout in millisecond for session to the ZooKeeper server. This option is not required, \"\n+            + \"and the default value is 20000.\")\n+        .withRequiredArg()\n+        .describedAs(\"zk_session_timeout\")\n+        .ofType(Integer.class)\n+        .defaultsTo(ZK_CLIENT_SESSION_TIMEOUT_MS);\n+\n+    parser.accepts(\"help\", \"print this help message.\");\n+    parser.accepts(\"h\", \"print this help message.\");\n+\n+    OptionSet options = parser.parse(args);\n+    if (options.has(\"help\") || options.has(\"h\")) {\n+      parser.printHelpOn(System.out);\n+      System.exit(0);\n+    }\n+\n+    // ensure mandatory arguments (propsFile, operation, zk address, zk store path) are present\n+    ToolUtils.ensureOrExit(Arrays.asList(propsFileOpt, operationOpt, zkServerOpt, storePathOpt), options, parser);\n+    String propsFilePath = options.valueOf(propsFileOpt);\n+    String operation = options.valueOf(operationOpt);\n+    MySqlAccountsDBTool.OPERATION_TYPE operationType = null;\n+    try {\n+      operationType = Enum.valueOf(MySqlAccountsDBTool.OPERATION_TYPE.class, operation.toUpperCase());\n+    } catch (Exception e) {\n+      System.out.println(\"Invalid operation: \" + operation + \". Supported operations: init, compare\");\n+      parser.printHelpOn(System.out);\n+      System.exit(1);\n+    }\n+    String zkServer = options.valueOf(zkServerOpt);\n+    String storePath = options.valueOf(storePathOpt);\n+    Integer zkConnectionTimeoutMs = options.valueOf(zkConnectionTimeoutMsOpt);\n+    Integer zkSessionTimeoutMs = options.valueOf(zkSessionTimeoutMsOpt);\n+\n+    try {\n+      Properties properties = Utils.loadProps(propsFilePath);\n+      properties.setProperty(HelixPropertyStoreConfig.HELIX_ZK_CLIENT_CONNECTION_TIMEOUT_MS,\n+          String.valueOf(zkConnectionTimeoutMs));\n+      properties.setProperty(HelixPropertyStoreConfig.HELIX_ZK_CLIENT_SESSION_TIMEOUT_MS,\n+          String.valueOf(zkSessionTimeoutMs));\n+      properties.setProperty(HelixPropertyStoreConfig.HELIX_ROOT_PATH, storePath);\n+      VerifiableProperties verifiableProperties = new VerifiableProperties(properties);\n+\n+      MySqlAccountsDBTool mySqlAccountsDBTool = new MySqlAccountsDBTool(verifiableProperties, zkServer);\n+\n+      if (operationType == OPERATION_TYPE.INIT) {\n+        mySqlAccountsDBTool.initialize();\n+      } else if (operationType == OPERATION_TYPE.COMPARE) {\n+        mySqlAccountsDBTool.compare();\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"MySQL accounts validation failed\", e);\n+    }\n+  }\n+\n+  public MySqlAccountsDBTool(VerifiableProperties verifiableProperties, String zkServer) throws SQLException {\n+\n+    this.mySqlDataAccessor = new MySqlDataAccessor(new MySqlConfig(verifiableProperties));\n+    this.accountDao = new AccountDao(mySqlDataAccessor);\n+    this.containerDao = new ContainerDao(mySqlDataAccessor);\n+    //Create helix property store\n+    HelixPropertyStoreConfig helixPropertyStoreConfig = new HelixPropertyStoreConfig(verifiableProperties);\n+    this.helixPropertyStore = CommonUtils.createHelixPropertyStore(zkServer, helixPropertyStoreConfig, null);\n+\n+    //store the complete path of metadata in zk for logging\n+    fullZKAccountMetadataPath = helixPropertyStoreConfig.rootPath + RELATIVE_ACCOUNT_METADATA_PATH;\n+  }\n+\n+  private void cleanup() throws SQLException {\n+    Statement statement = mySqlDataAccessor.getDatabaseConnection().createStatement();\n+    int numDeleted = statement.executeUpdate(\"delete from \" + ContainerDao.CONTAINER_TABLE);\n+    logger.info(\"Deleted {} containers\", numDeleted);\n+    int numDeletedAccounts = statement.executeUpdate(\"delete from \" + AccountDao.ACCOUNT_TABLE);\n+    logger.info(\"Deleted {} Accounts\", numDeletedAccounts);\n+  }\n+\n+  /**\n+   * Initializes db from zk\n+   */\n+  public void initialize() throws SQLException {\n+\n+    // clean the account and container tables in DB\n+    cleanup();\n+\n+    //get the list of accounts from zk in the form of map account id -> account json (as string)\n+    long startTimeMs = SystemTime.getInstance().milliseconds();\n+    Map<String, String> accountMap = fetchAccountMetadataFromZK();\n+    if (accountMap == null) {\n+      logger.info(\"Account metadata in ZK is empty\");\n+      return;\n+    }\n+    long zkFetchTimeMs = SystemTime.getInstance().milliseconds();\n+    logger.info(\"Fetched account metadata from zk path={}, took time={} ms\", fullZKAccountMetadataPath,\n+        zkFetchTimeMs - startTimeMs);\n+\n+    AccountInfoMap accountInfoMap = new AccountInfoMap(new AccountServiceMetrics(new MetricRegistry()), accountMap);\n+\n+    // Populate Account and Container tables\n+    for (Account account : accountInfoMap.getAccounts()) {\n+      for (Container container : account.getAllContainers()) {\n+        containerDao.addContainer(account.getId(), container);\n+      }\n+      accountDao.addAccount(account);\n+    }\n+\n+    logger.info(\"Initialized account metadata in DB from ZK path {}, took time={} ms\", fullZKAccountMetadataPath,\n+        System.currentTimeMillis() - zkFetchTimeMs);\n+  }\n+\n+  /**\n+   * compares db with zk and prints the accounts (IDs) that are different\n+   */\n+  public void compare() throws SQLException {\n+\n+    //get the list of accounts from zk in the form of map account id -> account json (as string)\n+    long startTimeMs = SystemTime.getInstance().milliseconds();\n+    Map<String, String> accountMapFromZK = fetchAccountMetadataFromZK();\n+    if (accountMapFromZK == null) {\n+      logger.info(\"Account metadata in ZK is empty\");\n+      return;\n+    }\n+    long zkFetchTimeMs = SystemTime.getInstance().milliseconds();\n+    logger.info(\"Fetched account metadata from zk path={}, took time={} ms\", fullZKAccountMetadataPath,\n+        zkFetchTimeMs - startTimeMs);\n+\n+    Set<Account> accountSetFromZK = (accountMapFromZK.values()\n+        .stream()\n+        .map(accountString -> Account.fromJson(new JSONObject(accountString)))\n+        .collect(Collectors.toSet()));\n+\n+    // Query the list of all Account from mysql\n+    Set<Account> accountSetFromDB = new HashSet<>(accountDao.getNewAccounts(0));\n+\n+    // Query the list of containers for each Account and add them to the Account\n+    accountSetFromDB.forEach(account -> {\n+      try {\n+        containerDao.getContainers(account.getId())", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MzY3Ng==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486683676", "bodyText": "return; is unnecessary here", "author": "jsjtzyy", "createdAt": "2020-09-10T23:14:00Z", "path": "ambry-tools/src/main/java/com/github/ambry/account/MySqlAccountsDBTool.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.account.mysql.AccountDao;\n+import com.github.ambry.account.mysql.ContainerDao;\n+import com.github.ambry.account.mysql.MySqlConfig;\n+import com.github.ambry.account.mysql.MySqlDataAccessor;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.HelixPropertyStoreConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.tools.util.ToolUtils;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import joptsimple.ArgumentAcceptingOptionSpec;\n+import joptsimple.OptionParser;\n+import joptsimple.OptionSet;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.zookeeper.data.Stat;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * <p>\n+ *   This is a command-line tool can be used to either:\n+ *    a) populate list of {@link Account}s and {@link Container}s into MySQL DB from {@code ZooKeeper} store\n+ *    b) compare list of {@link Account}s and {@link Container}s in MySQL DB with {@code ZooKeeper} store\n+ *   This can be used to validate that accounts and containers are correctly being updated in MySQL during migration phase and\n+ *   are in sync with ZK storage.\n+ *\n+ *   This tool takes in following parameters:\n+ *    1. 'propsFile' file which contains DB credentials needed to connect to MySQL url, username, password;\n+ *    2. 'operation' which tells to the type of operation. Supported operations are a)init, b)compare\n+ *    3. 'zkServer' - connect string of zookeeper server\n+ *    4. 'zkStorePath' - path of znode\n+ *\n+ *   A sample usage of the tool is:\n+ *     java -Dlog4j.configuration=file:../config/log4j.properties -cp ambry.jar com.github.ambry.account.MySqlAccountsDBTool\n+ *     --propsFile mysql.properties --operation init --zkServer localhost:2181  --storePath /Ambry/test/helixPropertyStore\n+ *\n+ *  A propsFile should contain:\n+ *    db.url=jdbc:mysql://localhost/db\n+ *    user=user\n+ *    password=password\n+ * </p>\n+ */\n+\n+public class MySqlAccountsDBTool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountsDBTool.class);\n+  private static String PROPSFILE = \"propsFile\";\n+  private static String OPERATION = \"operation\";\n+  private static String ZKSERVER = \"zkServer\";\n+  private static String STOREPATH = \"storePath\";\n+  private static final int ZK_CLIENT_CONNECTION_TIMEOUT_MS = 5000;\n+  private static final int ZK_CLIENT_SESSION_TIMEOUT_MS = 20000;\n+  static final String ACCOUNT_METADATA_MAP_KEY = \"accountMetadata\";\n+  static final String RELATIVE_ACCOUNT_METADATA_PATH = \"/account_metadata/full_data\";\n+\n+  private final MySqlDataAccessor mySqlDataAccessor;\n+  private final AccountDao accountDao;\n+  private final ContainerDao containerDao;\n+  private final HelixPropertyStore<ZNRecord> helixPropertyStore;\n+  private final String fullZKAccountMetadataPath;\n+\n+  enum OPERATION_TYPE {\n+    INIT, COMPARE\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    OptionParser parser = new OptionParser();\n+\n+    ArgumentAcceptingOptionSpec<String> propsFileOpt =\n+        parser.accepts(PROPSFILE, \"Properties file path\").withRequiredArg().describedAs(PROPSFILE).ofType(String.class);\n+\n+    ArgumentAcceptingOptionSpec<String> operationOpt =\n+        parser.accepts(OPERATION, \"Supported operations are 'init' and 'compare'\")\n+            .withRequiredArg()\n+            .describedAs(OPERATION)\n+            .ofType(String.class);\n+\n+    ArgumentAcceptingOptionSpec<String> zkServerOpt = parser.accepts(ZKSERVER, \"The address of ZooKeeper server\")\n+        .withRequiredArg()\n+        .describedAs(ZKSERVER)\n+        .ofType(String.class);\n+\n+    ArgumentAcceptingOptionSpec<String> storePathOpt = parser.accepts(STOREPATH,\n+        \"The root path of helix property store in the ZooKeeper. \"\n+            + \"Must start with /, and must not end with /. It is recommended to make root path in the form of \"\n+            + \"/ambry/<clustername>/helixPropertyStore. This option is required if source of storage is zookeeper.\")\n+        .withRequiredArg()\n+        .describedAs(STOREPATH)\n+        .ofType(String.class);\n+\n+    ArgumentAcceptingOptionSpec<Integer> zkConnectionTimeoutMsOpt = parser.accepts(\"zkConnectionTimeout\",\n+        \"Optional timeout in millisecond for connecting to the ZooKeeper server. This option is not required, \"\n+            + \"and the default value is 5000.\")\n+        .withRequiredArg()\n+        .describedAs(\"zk_connection_timeout\")\n+        .ofType(Integer.class)\n+        .defaultsTo(ZK_CLIENT_CONNECTION_TIMEOUT_MS);\n+\n+    ArgumentAcceptingOptionSpec<Integer> zkSessionTimeoutMsOpt = parser.accepts(\"zkSessionTimeout\",\n+        \"Optional timeout in millisecond for session to the ZooKeeper server. This option is not required, \"\n+            + \"and the default value is 20000.\")\n+        .withRequiredArg()\n+        .describedAs(\"zk_session_timeout\")\n+        .ofType(Integer.class)\n+        .defaultsTo(ZK_CLIENT_SESSION_TIMEOUT_MS);\n+\n+    parser.accepts(\"help\", \"print this help message.\");\n+    parser.accepts(\"h\", \"print this help message.\");\n+\n+    OptionSet options = parser.parse(args);\n+    if (options.has(\"help\") || options.has(\"h\")) {\n+      parser.printHelpOn(System.out);\n+      System.exit(0);\n+    }\n+\n+    // ensure mandatory arguments (propsFile, operation, zk address, zk store path) are present\n+    ToolUtils.ensureOrExit(Arrays.asList(propsFileOpt, operationOpt, zkServerOpt, storePathOpt), options, parser);\n+    String propsFilePath = options.valueOf(propsFileOpt);\n+    String operation = options.valueOf(operationOpt);\n+    MySqlAccountsDBTool.OPERATION_TYPE operationType = null;\n+    try {\n+      operationType = Enum.valueOf(MySqlAccountsDBTool.OPERATION_TYPE.class, operation.toUpperCase());\n+    } catch (Exception e) {\n+      System.out.println(\"Invalid operation: \" + operation + \". Supported operations: init, compare\");\n+      parser.printHelpOn(System.out);\n+      System.exit(1);\n+    }\n+    String zkServer = options.valueOf(zkServerOpt);\n+    String storePath = options.valueOf(storePathOpt);\n+    Integer zkConnectionTimeoutMs = options.valueOf(zkConnectionTimeoutMsOpt);\n+    Integer zkSessionTimeoutMs = options.valueOf(zkSessionTimeoutMsOpt);\n+\n+    try {\n+      Properties properties = Utils.loadProps(propsFilePath);\n+      properties.setProperty(HelixPropertyStoreConfig.HELIX_ZK_CLIENT_CONNECTION_TIMEOUT_MS,\n+          String.valueOf(zkConnectionTimeoutMs));\n+      properties.setProperty(HelixPropertyStoreConfig.HELIX_ZK_CLIENT_SESSION_TIMEOUT_MS,\n+          String.valueOf(zkSessionTimeoutMs));\n+      properties.setProperty(HelixPropertyStoreConfig.HELIX_ROOT_PATH, storePath);\n+      VerifiableProperties verifiableProperties = new VerifiableProperties(properties);\n+\n+      MySqlAccountsDBTool mySqlAccountsDBTool = new MySqlAccountsDBTool(verifiableProperties, zkServer);\n+\n+      if (operationType == OPERATION_TYPE.INIT) {\n+        mySqlAccountsDBTool.initialize();\n+      } else if (operationType == OPERATION_TYPE.COMPARE) {\n+        mySqlAccountsDBTool.compare();\n+      }\n+    } catch (Exception e) {\n+      logger.error(\"MySQL accounts validation failed\", e);\n+    }\n+  }\n+\n+  public MySqlAccountsDBTool(VerifiableProperties verifiableProperties, String zkServer) throws SQLException {\n+\n+    this.mySqlDataAccessor = new MySqlDataAccessor(new MySqlConfig(verifiableProperties));\n+    this.accountDao = new AccountDao(mySqlDataAccessor);\n+    this.containerDao = new ContainerDao(mySqlDataAccessor);\n+    //Create helix property store\n+    HelixPropertyStoreConfig helixPropertyStoreConfig = new HelixPropertyStoreConfig(verifiableProperties);\n+    this.helixPropertyStore = CommonUtils.createHelixPropertyStore(zkServer, helixPropertyStoreConfig, null);\n+\n+    //store the complete path of metadata in zk for logging\n+    fullZKAccountMetadataPath = helixPropertyStoreConfig.rootPath + RELATIVE_ACCOUNT_METADATA_PATH;\n+  }\n+\n+  private void cleanup() throws SQLException {\n+    Statement statement = mySqlDataAccessor.getDatabaseConnection().createStatement();\n+    int numDeleted = statement.executeUpdate(\"delete from \" + ContainerDao.CONTAINER_TABLE);\n+    logger.info(\"Deleted {} containers\", numDeleted);\n+    int numDeletedAccounts = statement.executeUpdate(\"delete from \" + AccountDao.ACCOUNT_TABLE);\n+    logger.info(\"Deleted {} Accounts\", numDeletedAccounts);\n+  }\n+\n+  /**\n+   * Initializes db from zk\n+   */\n+  public void initialize() throws SQLException {\n+\n+    // clean the account and container tables in DB\n+    cleanup();\n+\n+    //get the list of accounts from zk in the form of map account id -> account json (as string)\n+    long startTimeMs = SystemTime.getInstance().milliseconds();\n+    Map<String, String> accountMap = fetchAccountMetadataFromZK();\n+    if (accountMap == null) {\n+      logger.info(\"Account metadata in ZK is empty\");\n+      return;\n+    }\n+    long zkFetchTimeMs = SystemTime.getInstance().milliseconds();\n+    logger.info(\"Fetched account metadata from zk path={}, took time={} ms\", fullZKAccountMetadataPath,\n+        zkFetchTimeMs - startTimeMs);\n+\n+    AccountInfoMap accountInfoMap = new AccountInfoMap(new AccountServiceMetrics(new MetricRegistry()), accountMap);\n+\n+    // Populate Account and Container tables\n+    for (Account account : accountInfoMap.getAccounts()) {\n+      for (Container container : account.getAllContainers()) {\n+        containerDao.addContainer(account.getId(), container);\n+      }\n+      accountDao.addAccount(account);\n+    }\n+\n+    logger.info(\"Initialized account metadata in DB from ZK path {}, took time={} ms\", fullZKAccountMetadataPath,\n+        System.currentTimeMillis() - zkFetchTimeMs);\n+  }\n+\n+  /**\n+   * compares db with zk and prints the accounts (IDs) that are different\n+   */\n+  public void compare() throws SQLException {\n+\n+    //get the list of accounts from zk in the form of map account id -> account json (as string)\n+    long startTimeMs = SystemTime.getInstance().milliseconds();\n+    Map<String, String> accountMapFromZK = fetchAccountMetadataFromZK();\n+    if (accountMapFromZK == null) {\n+      logger.info(\"Account metadata in ZK is empty\");\n+      return;\n+    }\n+    long zkFetchTimeMs = SystemTime.getInstance().milliseconds();\n+    logger.info(\"Fetched account metadata from zk path={}, took time={} ms\", fullZKAccountMetadataPath,\n+        zkFetchTimeMs - startTimeMs);\n+\n+    Set<Account> accountSetFromZK = (accountMapFromZK.values()\n+        .stream()\n+        .map(accountString -> Account.fromJson(new JSONObject(accountString)))\n+        .collect(Collectors.toSet()));\n+\n+    // Query the list of all Account from mysql\n+    Set<Account> accountSetFromDB = new HashSet<>(accountDao.getNewAccounts(0));\n+\n+    // Query the list of containers for each Account and add them to the Account\n+    accountSetFromDB.forEach(account -> {\n+      try {\n+        containerDao.getContainers(account.getId())\n+            .forEach(account::updateContainerMap);\n+      } catch (SQLException e) {\n+        logger.error(\"MySQL querying containers failed\", e);\n+        return;", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc4Njg5OQ==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486786899", "bodyText": "Removed the try/catch", "author": "lightningrob", "createdAt": "2020-09-11T05:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MzY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4NDQ3Ng==", "url": "https://github.com/linkedin/ambry/pull/1619#discussion_r486684476", "bodyText": "Could you add some comments for these two operations?", "author": "jsjtzyy", "createdAt": "2020-09-10T23:16:32Z", "path": "ambry-tools/src/main/java/com/github/ambry/account/MySqlAccountsDBTool.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+package com.github.ambry.account;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.github.ambry.account.mysql.AccountDao;\n+import com.github.ambry.account.mysql.ContainerDao;\n+import com.github.ambry.account.mysql.MySqlConfig;\n+import com.github.ambry.account.mysql.MySqlDataAccessor;\n+import com.github.ambry.commons.CommonUtils;\n+import com.github.ambry.config.HelixPropertyStoreConfig;\n+import com.github.ambry.config.VerifiableProperties;\n+import com.github.ambry.tools.util.ToolUtils;\n+import com.github.ambry.utils.SystemTime;\n+import com.github.ambry.utils.Utils;\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import joptsimple.ArgumentAcceptingOptionSpec;\n+import joptsimple.OptionParser;\n+import joptsimple.OptionSet;\n+import org.apache.helix.AccessOption;\n+import org.apache.helix.store.HelixPropertyStore;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.zookeeper.data.Stat;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * <p>\n+ *   This is a command-line tool can be used to either:\n+ *    a) populate list of {@link Account}s and {@link Container}s into MySQL DB from {@code ZooKeeper} store\n+ *    b) compare list of {@link Account}s and {@link Container}s in MySQL DB with {@code ZooKeeper} store\n+ *   This can be used to validate that accounts and containers are correctly being updated in MySQL during migration phase and\n+ *   are in sync with ZK storage.\n+ *\n+ *   This tool takes in following parameters:\n+ *    1. 'propsFile' file which contains DB credentials needed to connect to MySQL url, username, password;\n+ *    2. 'operation' which tells to the type of operation. Supported operations are a)init, b)compare\n+ *    3. 'zkServer' - connect string of zookeeper server\n+ *    4. 'zkStorePath' - path of znode\n+ *\n+ *   A sample usage of the tool is:\n+ *     java -Dlog4j.configuration=file:../config/log4j.properties -cp ambry.jar com.github.ambry.account.MySqlAccountsDBTool\n+ *     --propsFile mysql.properties --operation init --zkServer localhost:2181  --storePath /Ambry/test/helixPropertyStore\n+ *\n+ *  A propsFile should contain:\n+ *    db.url=jdbc:mysql://localhost/db\n+ *    user=user\n+ *    password=password\n+ * </p>\n+ */\n+\n+public class MySqlAccountsDBTool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(MySqlAccountsDBTool.class);\n+  private static String PROPSFILE = \"propsFile\";\n+  private static String OPERATION = \"operation\";\n+  private static String ZKSERVER = \"zkServer\";\n+  private static String STOREPATH = \"storePath\";\n+  private static final int ZK_CLIENT_CONNECTION_TIMEOUT_MS = 5000;\n+  private static final int ZK_CLIENT_SESSION_TIMEOUT_MS = 20000;\n+  static final String ACCOUNT_METADATA_MAP_KEY = \"accountMetadata\";\n+  static final String RELATIVE_ACCOUNT_METADATA_PATH = \"/account_metadata/full_data\";\n+\n+  private final MySqlDataAccessor mySqlDataAccessor;\n+  private final AccountDao accountDao;\n+  private final ContainerDao containerDao;\n+  private final HelixPropertyStore<ZNRecord> helixPropertyStore;\n+  private final String fullZKAccountMetadataPath;\n+\n+  enum OPERATION_TYPE {\n+    INIT, COMPARE", "originalCommit": "6509cc9cf6ff368adaf874d99a5a1ecc4ed3a45b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "54aa66aa50554155c44ca68a3950cf3536d5196f", "url": "https://github.com/linkedin/ambry/commit/54aa66aa50554155c44ca68a3950cf3536d5196f", "message": "Address Yingyi review comments", "committedDate": "2020-09-11T05:51:29Z", "type": "commit"}]}