{"pr_number": 1531, "pr_title": "Integrate Cosmos BulkDelete stored procedure into compaction.", "pr_createdAt": "2020-05-22T18:06:20Z", "pr_url": "https://github.com/linkedin/ambry/pull/1531", "timeline": [{"oid": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354", "url": "https://github.com/linkedin/ambry/commit/ea7e1fe93fb11f53f0e856825e1074b80d3b9354", "message": "Integrate Cosmos BulkDelete stored procedure into compaction.", "committedDate": "2020-05-22T18:04:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTQ0NA==", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430641444", "bodyText": "when continuation is true, we just try again with the same list of blob IDs. Is the stored procedure idempotent?", "author": "cgtz", "createdAt": "2020-05-26T19:05:00Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -136,16 +164,83 @@ void testConnectivity() {\n   }\n \n   /**\n-   * Delete the blob metadata document in the CosmosDB collection.\n-   * @param blobMetadata the blob metadata document.\n-   * @return the {@link ResourceResponse} returned by the operation, if successful.\n+   * Delete the blob metadata document in the CosmosDB collection, if it exists.\n+   * @param blobMetadata the blob metadata document to delete.\n+   * @return {@code true} if the record was deleted, {@code false} if it was not found.\n    * @throws DocumentClientException if the operation failed.\n    */\n-  ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n+  boolean deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentDeleteTime);\n+    try {\n+      // Note: not timing here since bulk deletions are timed.\n+      executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(), null);\n+      return true;\n+    } catch (DocumentClientException dex) {\n+      if (dex.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n+        // Can happen on retry\n+        logger.debug(\"Could not find metadata for blob {} to delete\", blobMetadata.getId());\n+        return false;\n+      } else {\n+        throw dex;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents in the CosmosDB collection.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  void deleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    if (bulkDeleteEnabled) {\n+      for (List<CloudBlobMetadata> batchOfBlobs : Utils.partitionList(blobMetadataList, purgeBatchSize)) {\n+        bulkDeleteMetadata(batchOfBlobs);\n+      }\n+    } else {\n+      for (CloudBlobMetadata metadata : blobMetadataList) {\n+        deleteMetadata(metadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents from CosmosDB using the BulkDelete stored procedure.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  private void bulkDeleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    String partitionPath = blobMetadataList.get(0).getPartitionId();\n+    RequestOptions options = getRequestOptions(partitionPath);\n+\n+    // stored proc link provided in config.  Test for it at startup and use if available.\n+    String quotedBlobIds =\n+        blobMetadataList.stream().map(metadata -> '\"' + metadata.getId() + '\"').collect(Collectors.joining(\",\"));\n+    String query = String.format(BULK_DELETE_QUERY, quotedBlobIds);\n+    String sprocLink = cosmosCollectionLink + BULK_DELETE_SPROC;\n+    boolean more = true;\n+    int deleteCount = 0;\n+    double requestCharge = 0;\n+    try {\n+      while (more) {\n+        StoredProcedureResponse response =\n+            asyncDocumentClient.executeStoredProcedure(sprocLink, options, new String[]{query}).toBlocking().single();", "originalCommit": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MDc2Mg==", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430860762", "bodyText": "Yes.  It's idempotent because the sproc first runs the query to get records matching the IN filter, which will simply be smaller if some records have been deleted on prior executions.  Though I was not able to trigger this case during testing, likely because the batch size was small.", "author": "lightningrob", "createdAt": "2020-05-27T05:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTg3NQ==", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430641875", "bodyText": "does this count include blobs that were already deleted from previous iterations?", "author": "cgtz", "createdAt": "2020-05-26T19:05:48Z", "path": "ambry-cloud/src/main/java/com/github/ambry/cloud/azure/CosmosDataAccessor.java", "diffHunk": "@@ -136,16 +164,83 @@ void testConnectivity() {\n   }\n \n   /**\n-   * Delete the blob metadata document in the CosmosDB collection.\n-   * @param blobMetadata the blob metadata document.\n-   * @return the {@link ResourceResponse} returned by the operation, if successful.\n+   * Delete the blob metadata document in the CosmosDB collection, if it exists.\n+   * @param blobMetadata the blob metadata document to delete.\n+   * @return {@code true} if the record was deleted, {@code false} if it was not found.\n    * @throws DocumentClientException if the operation failed.\n    */\n-  ResourceResponse<Document> deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n+  boolean deleteMetadata(CloudBlobMetadata blobMetadata) throws DocumentClientException {\n     String docLink = getDocumentLink(blobMetadata.getId());\n     RequestOptions options = getRequestOptions(blobMetadata.getPartitionId());\n-    return executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(),\n-        azureMetrics.documentDeleteTime);\n+    try {\n+      // Note: not timing here since bulk deletions are timed.\n+      executeCosmosAction(() -> asyncDocumentClient.deleteDocument(docLink, options).toBlocking().single(), null);\n+      return true;\n+    } catch (DocumentClientException dex) {\n+      if (dex.getStatusCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n+        // Can happen on retry\n+        logger.debug(\"Could not find metadata for blob {} to delete\", blobMetadata.getId());\n+        return false;\n+      } else {\n+        throw dex;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents in the CosmosDB collection.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  void deleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    if (bulkDeleteEnabled) {\n+      for (List<CloudBlobMetadata> batchOfBlobs : Utils.partitionList(blobMetadataList, purgeBatchSize)) {\n+        bulkDeleteMetadata(batchOfBlobs);\n+      }\n+    } else {\n+      for (CloudBlobMetadata metadata : blobMetadataList) {\n+        deleteMetadata(metadata);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Delete the blob metadata documents from CosmosDB using the BulkDelete stored procedure.\n+   * @param blobMetadataList the list of blob metadata documents to delete.\n+   * @throws DocumentClientException if the operation failed.\n+   */\n+  private void bulkDeleteMetadata(List<CloudBlobMetadata> blobMetadataList) throws DocumentClientException {\n+    String partitionPath = blobMetadataList.get(0).getPartitionId();\n+    RequestOptions options = getRequestOptions(partitionPath);\n+\n+    // stored proc link provided in config.  Test for it at startup and use if available.\n+    String quotedBlobIds =\n+        blobMetadataList.stream().map(metadata -> '\"' + metadata.getId() + '\"').collect(Collectors.joining(\",\"));\n+    String query = String.format(BULK_DELETE_QUERY, quotedBlobIds);\n+    String sprocLink = cosmosCollectionLink + BULK_DELETE_SPROC;\n+    boolean more = true;\n+    int deleteCount = 0;\n+    double requestCharge = 0;\n+    try {\n+      while (more) {\n+        StoredProcedureResponse response =\n+            asyncDocumentClient.executeStoredProcedure(sprocLink, options, new String[]{query}).toBlocking().single();\n+        requestCharge += response.getRequestCharge();\n+        Document responseDoc = response.getResponseAsDocument();\n+        more = responseDoc.getBoolean(PROPERTY_CONTINUATION);\n+        deleteCount += responseDoc.getInt(PROPERTY_DELETED);", "originalCommit": "ea7e1fe93fb11f53f0e856825e1074b80d3b9354", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MTAwNg==", "url": "https://github.com/linkedin/ambry/pull/1531#discussion_r430861006", "bodyText": "It should not.", "author": "lightningrob", "createdAt": "2020-05-27T05:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTg3NQ=="}], "type": "inlineReview"}, {"oid": "5a54a9e101ac976a4830487fee36a15f7395e8e7", "url": "https://github.com/linkedin/ambry/commit/5a54a9e101ac976a4830487fee36a15f7395e8e7", "message": "Check in BulkDelete stored procedure as resource", "committedDate": "2020-05-27T06:01:23Z", "type": "commit"}, {"oid": "411306503bce4fc15ca7eca736a81e1ae8a64df8", "url": "https://github.com/linkedin/ambry/commit/411306503bce4fc15ca7eca736a81e1ae8a64df8", "message": "Exclude resource from license check", "committedDate": "2020-05-27T07:10:05Z", "type": "commit"}]}