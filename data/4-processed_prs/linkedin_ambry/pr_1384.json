{"pr_number": 1384, "pr_title": "Add 3 basic classes for HTTP2 based NetworkClient implementation.", "pr_createdAt": "2020-02-13T23:21:20Z", "pr_url": "https://github.com/linkedin/ambry/pull/1384", "timeline": [{"oid": "a28abc2547087ef081a50ff24461dd80e3aab61b", "url": "https://github.com/linkedin/ambry/commit/a28abc2547087ef081a50ff24461dd80e3aab61b", "message": "Add Http2ChannelPoolMap MultiplexedChannelRecord and Http2MultiplexedChannelPool.\n\nAdd the 3 basic classes for http2.", "committedDate": "2020-02-14T01:43:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjA2NQ==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r379872065", "bodyText": "Could you call this Http2ClientChannelInitializer and replace the one used for Http2BlockingChannel with this one?", "author": "cgtz", "createdAt": "2020-02-16T03:22:37Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelInitializer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.\n+ */\n+public class Http2ChannelInitializer extends AbstractChannelPoolHandler {", "originalCommit": "a28abc2547087ef081a50ff24461dd80e3aab61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MzgwNQ==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381553805", "bodyText": "Http2ClientChannelInitializer is Channelnitializer, which is not a AbstractChannelPoolHandler.\nWe probably need to keep two classes.\nI can rename this(Http2ChannelInitializer) to Http2ChannelPoolHanlder and try to avoid dup code.", "author": "zzmao", "createdAt": "2020-02-19T21:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1OTQ1MQ==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381559451", "bodyText": "Http2ClientChannelInitializer class is removed. Do inline initialization in Http2BlockingChannel::channel().", "author": "zzmao", "createdAt": "2020-02-19T21:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjExOA==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r379872118", "bodyText": "You should only need one shared sslFactory for all channels. I would prefer only parsing the configs once", "author": "cgtz", "createdAt": "2020-02-16T03:23:47Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelInitializer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.commons.SSLFactory;\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n+import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n+import io.netty.handler.codec.http2.Http2MultiplexHandler;\n+import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.ssl.SslHandler;\n+\n+\n+/**\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.\n+ */\n+public class Http2ChannelInitializer extends AbstractChannelPoolHandler {\n+  private final SSLConfig sslConfig;\n+  private final String host;\n+  private final int port;\n+\n+  /**\n+   * Construct a {@link Http2ChannelInitializer}.\n+   * @param sslConfig the {@link SSLFactory} to use for generating {@link javax.net.ssl.SSLEngine} instances,\n+   *                   or {@code null} if SSL is not enabled in this pipeline.\n+   */\n+  public Http2ChannelInitializer(SSLConfig sslConfig, RequestInfo requestInfo) {\n+    this.sslConfig = sslConfig;\n+    this.host = requestInfo.getHost();\n+    this.port = requestInfo.getPort().getPort();\n+  }\n+\n+  @Override\n+  public void channelCreated(Channel ch) throws Exception {\n+    ChannelPipeline pipeline = ch.pipeline();\n+    SSLFactory sslFactory = new NettySslHttp2Factory(sslConfig);", "originalCommit": "a28abc2547087ef081a50ff24461dd80e3aab61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MzkzNA==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381553934", "bodyText": "ok", "author": "zzmao", "createdAt": "2020-02-19T21:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQyNw==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r379872427", "bodyText": "looks like this is not used with Http2ChannelPoolMap", "author": "cgtz", "createdAt": "2020-02-16T03:32:20Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ClientChannelInitializer.java", "diffHunk": "@@ -26,8 +26,7 @@\n \n \n /**\n- * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n- * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.", "originalCommit": "a28abc2547087ef081a50ff24461dd80e3aab61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NDUzNA==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381554534", "bodyText": "fixed. For Http2BlockingChannel", "author": "zzmao", "createdAt": "2020-02-19T21:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2MDU1NA==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381560554", "bodyText": "This class is removed.", "author": "zzmao", "createdAt": "2020-02-19T21:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQ5NQ==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r379872495", "bodyText": "Maybe construct SSLFactory outside (i.e. in the NetworkClientFactory impl) and pass it into this constructor since it should be able to shared across all instances.", "author": "cgtz", "createdAt": "2020-02-16T03:34:11Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolMap.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.pool.AbstractChannelPoolMap;\n+import io.netty.channel.pool.ChannelPool;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+\n+\n+public class Http2ChannelPoolMap extends AbstractChannelPoolMap<RequestInfo, ChannelPool> {\n+  private final EventLoopGroup eventLoopGroup;\n+  private final SSLConfig sslConfig;\n+\n+  public Http2ChannelPoolMap(SSLConfig sslConfig, EventLoopGroup eventLoopGroup) {", "originalCommit": "a28abc2547087ef081a50ff24461dd80e3aab61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2MDY2OA==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381560668", "bodyText": "SSLFactory is used.", "author": "zzmao", "createdAt": "2020-02-19T21:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg3MjQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQwMjkwOQ==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r380402909", "bodyText": "It seems that RequestInfo isn't exactly the right key to use for Http2ChannelPoolMap and Http2ChannelInitializer for a couple reasons:\n\nIt doesn't have hashcode and equals defined, and a separate object is created for each request, so a new pool will created for each request, instead of each host:port combo\nIt includes info about the request body, which is not relevant to the pool (i think).\n\nInstead, you could use InetSocketAddress and pass this directly into Bootstrap::remoteAddress. The impl of Bootstrap::remoteAddress(String inetHost, int inetPort) would call InetSocketAddress.createUnresolved(inetHost, inetPort) anyways.", "author": "cgtz", "createdAt": "2020-02-18T00:08:00Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolMap.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright 2016 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.rest;\n+\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.network.RequestInfo;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.pool.AbstractChannelPoolMap;\n+import io.netty.channel.pool.ChannelPool;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+\n+\n+public class Http2ChannelPoolMap extends AbstractChannelPoolMap<RequestInfo, ChannelPool> {", "originalCommit": "a28abc2547087ef081a50ff24461dd80e3aab61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2OTkzNQ==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381569935", "bodyText": "InetSocketAddress is used.", "author": "zzmao", "createdAt": "2020-02-19T21:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQwMjkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYyNTA5OA==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r381625098", "bodyText": "I am wondering if it's easier to create a sub package under ambry.rest like ambry.rest.http2 so we can put all the http2 related files under this package.", "author": "justinlin-linkedin", "createdAt": "2020-02-20T00:27:41Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/GoAwayException.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*", "originalCommit": "0038c71bc55118e38e48fe08d810b7936a6701f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzMDkzOQ==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382230939", "bodyText": "should be ChannelPoolHandler", "author": "cgtz", "createdAt": "2020-02-20T20:09:11Z", "path": "ambry-rest/src/main/java/com.github.ambry.rest/Http2ChannelPoolHandler.java", "diffHunk": "@@ -15,42 +15,39 @@\n package com.github.ambry.rest;\n \n import com.github.ambry.commons.SSLFactory;\n+import io.netty.channel.Channel;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelPipeline;\n-import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n import io.netty.handler.codec.http2.Http2MultiplexHandler;\n import io.netty.handler.codec.http2.Http2Settings;\n import io.netty.handler.ssl.SslHandler;\n \n \n /**\n- * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n- * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.", "originalCommit": "0038c71bc55118e38e48fe08d810b7936a6701f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTU5Mg==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382945592", "bodyText": "I guess this method requires assertions to be disabled for l158-163 to even take effect?", "author": "cgtz", "createdAt": "2020-02-22T22:13:53Z", "path": "ambry-commons/src/main/java/com.github.ambry.commons/NettyUtils.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2010-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * Modifications copyright (C) 2020 <Linkedin/zzmao>\n+ */\n+\n+package com.github.ambry.commons;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.concurrent.EventExecutor;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import io.netty.util.concurrent.Promise;\n+import io.netty.util.concurrent.SucceededFuture;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public final class NettyUtils {\n+  /**\n+   * Completed succeed future.\n+   */\n+  public static final SucceededFuture<?> SUCCEEDED_FUTURE = new SucceededFuture<>(null, null);\n+\n+  private static final Logger log = LoggerFactory.getLogger(NettyUtils.class);\n+\n+  private NettyUtils() {\n+  }\n+\n+  /**\n+   * Creates a {@link BiConsumer} that notifies the promise of any failures either via the {@link Throwable} passed into the\n+   * BiConsumer of as a result of running the successFunction.\n+   *\n+   * @param successFunction Function called to process the successful result and map it into the result to notify the promise\n+   * with.\n+   * @param promise Promise to notify of success or failure.\n+   * @param <SuccessT> Success type.\n+   * @param <PromiseT> Type being fulfilled by the promise.\n+   * @return BiConsumer that can be used in a {@link CompletableFuture#whenComplete(BiConsumer)} method.\n+   */\n+  public static <SuccessT, PromiseT> BiConsumer<SuccessT, ? super Throwable> promiseNotifyingBiConsumer(\n+      Function<SuccessT, PromiseT> successFunction, Promise<PromiseT> promise) {\n+    return (success, fail) -> {\n+      if (fail != null) {\n+        promise.setFailure(fail);\n+      } else {\n+        try {\n+          promise.setSuccess(successFunction.apply(success));\n+        } catch (Throwable e) {\n+          promise.setFailure(e);\n+        }\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Creates a {@link BiConsumer} that notifies the promise of any failures either via the throwable passed into the BiConsumer\n+   * or as a result of running the successConsumer. This assumes that the successConsumer will notify the promise when it\n+   * completes successfully.\n+   *\n+   * @param successConsumer BiConsumer to call if the result is successful. Promise is also passed and must be notified on\n+   * success.\n+   * @param promise Promise to notify.\n+   * @param <SuccessT> Success type.\n+   * @param <PromiseT> Type being fulfilled by the Promise.\n+   * @return BiConsumer that can be used in a {@link CompletableFuture#whenComplete(BiConsumer)} method.\n+   */\n+  public static <SuccessT, PromiseT> BiConsumer<SuccessT, ? super Throwable> asyncPromiseNotifyingBiConsumer(\n+      BiConsumer<SuccessT, Promise<PromiseT>> successConsumer, Promise<PromiseT> promise) {\n+    return (success, fail) -> {\n+      if (fail != null) {\n+        promise.setFailure(fail);\n+      } else {\n+        try {\n+          successConsumer.accept(success, promise);\n+        } catch (Throwable e) {\n+          // If the successConsumer fails synchronously then we can notify the promise. If it fails asynchronously\n+          // it's up to the successConsumer to notify.\n+          promise.setFailure(e);\n+        }\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Create a {@link GenericFutureListener} that will notify the provided {@link Promise} on success and failure.\n+   *\n+   * @param channelPromise Promise to notify.\n+   * @return GenericFutureListener\n+   */\n+  public static <T> GenericFutureListener<Future<T>> promiseNotifyingListener(Promise<T> channelPromise) {\n+    return future -> {\n+      if (future.isSuccess()) {\n+        channelPromise.setSuccess(future.getNow());\n+      } else {\n+        channelPromise.setFailure(future.cause());\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Runs a task in the given {@link EventExecutor}. Runs immediately if the current thread is in the\n+   * eventExecutor.\n+   *\n+   * @param eventExecutor Executor to run task in.\n+   * @param runnable Task to run.\n+   */\n+  public static void doInEventLoop(EventExecutor eventExecutor, Runnable runnable) {\n+    if (eventExecutor.inEventLoop()) {\n+      runnable.run();\n+    } else {\n+      eventExecutor.submit(runnable);\n+    }\n+  }\n+\n+  /**\n+   * Runs a task in the given {@link EventExecutor}. Runs immediately if the current thread is in the\n+   * eventExecutor. Notifies the given {@link Promise} if a failure occurs.\n+   *\n+   * @param eventExecutor Executor to run task in.\n+   * @param runnable Task to run.\n+   * @param promise Promise to notify if failure occurs.\n+   */\n+  public static void doInEventLoop(EventExecutor eventExecutor, Runnable runnable, Promise<?> promise) {\n+    try {\n+      if (eventExecutor.inEventLoop()) {\n+        runnable.run();\n+      } else {\n+        eventExecutor.submit(() -> {\n+          try {\n+            runnable.run();\n+          } catch (Throwable e) {\n+            promise.setFailure(e);\n+          }\n+        });\n+      }\n+    } catch (Throwable e) {\n+      promise.setFailure(e);\n+    }\n+  }\n+\n+  public static void warnIfNotInEventLoop(EventLoop loop) {\n+    assert loop.inEventLoop();", "originalCommit": "6c209845b0a6ec10ac72813c34b1eddb58162a9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTY5MA==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382945690", "bodyText": "Ah, I see that assertions are disabled by default for production code, so this makes sense: https://stackoverflow.com/questions/29120928/why-is-assert-not-enabled-by-default-in-java", "author": "cgtz", "createdAt": "2020-02-22T22:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTc5Mw==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382945793", "bodyText": "sSLEngine -> sslEngine", "author": "cgtz", "createdAt": "2020-02-22T22:16:36Z", "path": "ambry-commons/src/test/java/com.github.ambry.commons/NettySslHttp2FactoryTest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2018 LinkedIn Corp. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ */\n+\n+package com.github.ambry.commons;\n+\n+import com.github.ambry.config.SSLConfig;\n+import com.github.ambry.utils.Utils;\n+import java.io.File;\n+import javax.net.ssl.SSLEngine;\n+import org.junit.Test;\n+\n+\n+/**\n+ * Test {@link NettySslFactory}\n+ */\n+public class NettySslHttp2FactoryTest {\n+\n+  /**\n+   * Run sanity checks for {@link NettySslHttp2Factory}. Make sure no exception.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testHttp2SSLFactory() throws Exception {\n+    //server\n+    File trustStoreFile = File.createTempFile(\"truststore\", \".jks\");\n+    SSLConfig serverSslConfig =\n+        new SSLConfig(TestSSLUtils.createHttp2Props(\"DC1,DC2,DC3\", SSLFactory.Mode.SERVER, trustStoreFile, \"server\"));\n+    NettySslHttp2Factory sslFactory = Utils.getObj(NettySslHttp2Factory.class.getName(), serverSslConfig);\n+    SSLEngine sSLEngine = sslFactory.createSSLEngine(\"localhost\", 9095, SSLFactory.Mode.SERVER);", "originalCommit": "6c209845b0a6ec10ac72813c34b1eddb58162a9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTg3OQ==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382945879", "bodyText": "remove println", "author": "cgtz", "createdAt": "2020-02-22T22:18:16Z", "path": "ambry-commons/src/test/java/com.github.ambry.commons/TestSSLUtils.java", "diffHunk": "@@ -320,6 +350,7 @@ public static void testSSLFactoryImpl(String factoryClassName) throws Exception\n     SSLServerSocketFactory serverSocketFactory = sslContext.getServerSocketFactory();\n     Assert.assertNotNull(serverSocketFactory);\n     SSLEngine serverSideSSLEngine = sslFactory.createSSLEngine(\"localhost\", 9095, SSLFactory.Mode.SERVER);\n+    System.out.println(serverSideSSLEngine.getWantClientAuth());", "originalCommit": "6c209845b0a6ec10ac72813c34b1eddb58162a9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NjExMw==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382946113", "bodyText": "add newline", "author": "cgtz", "createdAt": "2020-02-22T22:23:09Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/GoAwayException.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2010-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * Modifications copyright (C) 2020 <Linkedin/zzmao>\n+ */\n+package com.github.ambry.network.http2;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+\n+/**\n+ * Exception thrown when a GOAWAY frame is sent by the service.\n+ */\n+class GoAwayException extends IOException {\n+  private final String message;\n+\n+  GoAwayException(long errorCode, ByteBuf debugData) {\n+    this.message = String.format(\n+        \"GOAWAY received from service, requesting this stream be closed. \" + \"Error Code = %d, Debug Data = %s\",\n+        errorCode, debugData.toString(StandardCharsets.UTF_8));\n+  }\n+\n+  @Override\n+  public String getMessage() {\n+    return message;\n+  }\n+}", "originalCommit": "6c209845b0a6ec10ac72813c34b1eddb58162a9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NzA5Ng==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382947096", "bodyText": "change doc to say ChannelPoolHandler", "author": "cgtz", "createdAt": "2020-02-22T22:40:07Z", "path": "ambry-network/src/main/java/com.github.ambry.network/http2/Http2ChannelPoolHandler.java", "diffHunk": "@@ -12,45 +12,42 @@\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n-package com.github.ambry.rest;\n+package com.github.ambry.network.http2;\n \n import com.github.ambry.commons.SSLFactory;\n+import io.netty.channel.Channel;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelPipeline;\n-import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.pool.AbstractChannelPoolHandler;\n import io.netty.handler.codec.http2.Http2FrameCodecBuilder;\n import io.netty.handler.codec.http2.Http2MultiplexHandler;\n import io.netty.handler.codec.http2.Http2Settings;\n import io.netty.handler.ssl.SslHandler;\n \n \n /**\n- * A {@link ChannelInitializer} to be used with {@link Http2BlockingChannel}. Calling {@link #initChannel(SocketChannel)}\n- * adds the necessary handlers to a channel's pipeline so that it may handle requests.\n+ * A {@link ChannelInitializer} to be used with {@link Http2ChannelPoolMap}.", "originalCommit": "6c209845b0a6ec10ac72813c34b1eddb58162a9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MDA0NA==", "url": "https://github.com/linkedin/ambry/pull/1384#discussion_r382950044", "bodyText": "Is this import needed?", "author": "cgtz", "createdAt": "2020-02-22T23:38:39Z", "path": "ambry-server/src/integration-test/java/com.github.ambry.server/ServerTestUtil.java", "diffHunk": "@@ -122,6 +124,7 @@\n import java.util.concurrent.atomic.AtomicReference;\n import javax.net.ssl.SSLSocketFactory;\n import org.junit.Assert;\n+import org.junit.Test;", "originalCommit": "6c209845b0a6ec10ac72813c34b1eddb58162a9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8aaa62457e257bdf1706ee49974c8566ca811a19", "url": "https://github.com/linkedin/ambry/commit/8aaa62457e257bdf1706ee49974c8566ca811a19", "message": "address cgetz comments", "committedDate": "2020-02-24T22:09:17Z", "type": "forcePushed"}, {"oid": "7282eb1f1e61543b7cb70b5af1fa0721f485ff70", "url": "https://github.com/linkedin/ambry/commit/7282eb1f1e61543b7cb70b5af1fa0721f485ff70", "message": "address cgetz comments", "committedDate": "2020-02-24T22:14:27Z", "type": "forcePushed"}, {"oid": "370588dc99910bc1f4e927066a981c2095f483c6", "url": "https://github.com/linkedin/ambry/commit/370588dc99910bc1f4e927066a981c2095f483c6", "message": "fix merge issue", "committedDate": "2020-02-25T18:12:25Z", "type": "forcePushed"}, {"oid": "698374e5155e905251e5f864ddd69f214d993cd2", "url": "https://github.com/linkedin/ambry/commit/698374e5155e905251e5f864ddd69f214d993cd2", "message": "Add Http2ChannelPoolMap MultiplexedChannelRecord and Http2MultiplexedChannelPool.\n\nAdd the 3 basic classes for http2.", "committedDate": "2020-02-25T22:58:53Z", "type": "forcePushed"}, {"oid": "983ca1ac7293bdfe469b04c0170c5cb0b36529f5", "url": "https://github.com/linkedin/ambry/commit/983ca1ac7293bdfe469b04c0170c5cb0b36529f5", "message": "Add Http2ChannelPoolMap MultiplexedChannelRecord and Http2MultiplexedChannelPool.\n\nAdd the 3 basic classes for http2.", "committedDate": "2020-02-26T00:42:32Z", "type": "commit"}, {"oid": "983ca1ac7293bdfe469b04c0170c5cb0b36529f5", "url": "https://github.com/linkedin/ambry/commit/983ca1ac7293bdfe469b04c0170c5cb0b36529f5", "message": "Add Http2ChannelPoolMap MultiplexedChannelRecord and Http2MultiplexedChannelPool.\n\nAdd the 3 basic classes for http2.", "committedDate": "2020-02-26T00:42:32Z", "type": "forcePushed"}]}