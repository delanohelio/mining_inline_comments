{"pr_number": 1628, "pr_title": "[Container API] Introducing create/update container APIs in AccountService", "pr_createdAt": "2020-09-22T05:55:58Z", "pr_url": "https://github.com/linkedin/ambry/pull/1628", "timeline": [{"oid": "61354a955b1d37022d47017835d3ea7cecdd21c7", "url": "https://github.com/linkedin/ambry/commit/61354a955b1d37022d47017835d3ea7cecdd21c7", "message": "[Container API] Introducing create/update container APIs in AccountService\n\nWhen number of containers in single account keeps growing, it becomes expensive to transmit whole account\nto clients, edit on client side and send it back. This PR introduces some container management APIs (prototype)\nto help create/update container within frontend to avoid unnecessary transmission overhead. Also, this PR\nincorprates the logic to generate container id.", "committedDate": "2020-09-22T21:02:19Z", "type": "commit"}, {"oid": "61354a955b1d37022d47017835d3ea7cecdd21c7", "url": "https://github.com/linkedin/ambry/commit/61354a955b1d37022d47017835d3ea7cecdd21c7", "message": "[Container API] Introducing create/update container APIs in AccountService\n\nWhen number of containers in single account keeps growing, it becomes expensive to transmit whole account\nto clients, edit on client side and send it back. This PR introduces some container management APIs (prototype)\nto help create/update container within frontend to avoid unnecessary transmission overhead. Also, this PR\nincorprates the logic to generate container id.", "committedDate": "2020-09-22T21:02:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NjgxOQ==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493046819", "bodyText": "These two methods are added for initial review (we can discuss what signature is acceptable). I can remove them after review is done.", "author": "jsjtzyy", "createdAt": "2020-09-22T21:34:10Z", "path": "ambry-api/src/main/java/com/github/ambry/account/AccountService.java", "diffHunk": "@@ -107,6 +108,36 @@\n    */\n   public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer);\n \n+  /**\n+   * Add a new container to an existing account.\n+   * @param accountName the name of account in which new container will be added.\n+   * @param newContainer the new container to add.\n+   * @return a pair of account id and container id strings associated with existing account and new container.\n+   */\n+  default Pair<String, String> addContainer(String accountName, Container newContainer) {\n+    throw new UnsupportedOperationException(\"This method is not supported\");\n+  }\n+\n+  /**\n+   * Update attributes of an existing container.\n+   * @param accountName the name of account which container belongs to.\n+   * @param updatedContainer the updated {@link Container} used to replace current one.\n+   * @return {@code true} if container is successfully updated. {@code false} otherwise.\n+   */\n+  default boolean updateContainer(String accountName, Container updatedContainer) {\n+    throw new UnsupportedOperationException(\"This method is not supported\");\n+  }\n+\n+  /**\n+   * Get an existing container from a given account.\n+   * @param accountName the name of account which container belongs to.\n+   * @param containerId the id of container to get.\n+   * @return the requested {@link Container} object or null if not present.\n+   */\n+  default Container getContainer(String accountName, String containerId) {\n+    throw new UnsupportedOperationException(\"This method is not supported\");", "originalCommit": "61354a955b1d37022d47017835d3ea7cecdd21c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA3MDcxNw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493070717", "bodyText": "It seems strange to have accountName and containerId in same signature.", "author": "lightningrob", "createdAt": "2020-09-22T22:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NjgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NzgyMA==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493197820", "bodyText": "My bad, I was trying to use containerName but somehow it became containerId.", "author": "jsjtzyy", "createdAt": "2020-09-23T04:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NjgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MDExMA==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493060110", "bodyText": "Probably can omit this file from the PR.", "author": "lightningrob", "createdAt": "2020-09-22T22:05:07Z", "path": "ambry-frontend/src/main/java/com/github/ambry/frontend/PostAccountsHandler.java", "diffHunk": "@@ -17,6 +17,7 @@\n import com.github.ambry.account.Account;\n import com.github.ambry.account.AccountCollectionSerde;\n import com.github.ambry.account.AccountService;\n+import com.github.ambry.commons.Callback;", "originalCommit": "61354a955b1d37022d47017835d3ea7cecdd21c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NzQyNg==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493197426", "bodyText": "Omitted", "author": "jsjtzyy", "createdAt": "2020-09-23T04:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MDExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MjQyMg==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493062422", "bodyText": "This is tricky since \"editable\" concept is not well defined in OS ambry.\nAlso, should make this instance method taking only one Container argument to compare.", "author": "lightningrob", "createdAt": "2020-09-22T22:11:11Z", "path": "ambry-api/src/main/java/com/github/ambry/account/Container.java", "diffHunk": "@@ -476,6 +480,24 @@ public static void setCurrentJsonVersion(short currentJsonVersion) {\n     Container.currentJsonVersion = currentJsonVersion;\n   }\n \n+  /**\n+   * Check if two containers' editable fields are same.\n+   * @param container1 the {@link Container} to compare.\n+   * @param container2 the {@link Container} to compare.\n+   * @return {@code true} if two containers are equivalent in terms of editable fields. {@code false} otherwise.\n+   */\n+  public static boolean containerEditableFieldsAreSame(Container container1, Container container2) {", "originalCommit": "61354a955b1d37022d47017835d3ea7cecdd21c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NzU3Mw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493197573", "bodyText": "Yeah, I changed it to instance method and renamed it to \"isSameContainer\"", "author": "jsjtzyy", "createdAt": "2020-09-23T04:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MjQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MzMxOQ==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493063319", "bodyText": "This can be confusing to someone who is only aware of OS ambry.", "author": "lightningrob", "createdAt": "2020-09-22T22:13:32Z", "path": "ambry-api/src/main/java/com/github/ambry/account/Container.java", "diffHunk": "@@ -84,6 +84,7 @@\n   static final boolean CACHEABLE_DEFAULT_VALUE = true;\n   static final Set<String> CONTENT_TYPE_WHITELIST_FOR_FILENAMES_ON_DOWNLOAD_DEFAULT_VALUE = Collections.emptySet();\n \n+  public static final short CONTAINER_ID_START_RANGE = 8;", "originalCommit": "61354a955b1d37022d47017835d3ea7cecdd21c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NzYzMw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493197633", "bodyText": "True, make this as a config", "author": "jsjtzyy", "createdAt": "2020-09-23T04:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MzMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2OTY1MQ==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493069651", "bodyText": "This entire method is generic except for the line that updates the underlying store.  Can we move it to the base class?  Maybe AccountService can also have a method like getMetadataStore().", "author": "lightningrob", "createdAt": "2020-09-22T22:30:24Z", "path": "ambry-account/src/main/java/com/github/ambry/account/HelixAccountService.java", "diffHunk": "@@ -246,6 +250,69 @@ public boolean updateAccounts(Collection<Account> accounts) {\n     return updateAccountsWithAccountMetadataStore(accounts, accountMetadataStore);\n   }\n \n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Override\n+  public Pair<String, String> addContainer(String accountName, Container newContainer) {", "originalCommit": "61354a955b1d37022d47017835d3ea7cecdd21c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyMjY2Ng==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493722666", "bodyText": "Good point. The only blocker here is how to pass in a config to specify \"container id start number\". Or can we hard code it somewhere? (I am thinking if container id can start from 0)", "author": "jsjtzyy", "createdAt": "2020-09-23T16:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2OTY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNjg4Nw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493806887", "bodyText": "Since you added it to config, can you make the method generic now?", "author": "lightningrob", "createdAt": "2020-09-23T18:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2OTY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkyNDc1MQ==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493924751", "bodyText": "Sure, will do", "author": "jsjtzyy", "createdAt": "2020-09-23T22:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2OTY1MQ=="}], "type": "inlineReview"}, {"oid": "8234e62e08b5ef9cebdd36e28af9e624e31b014b", "url": "https://github.com/linkedin/ambry/commit/8234e62e08b5ef9cebdd36e28af9e624e31b014b", "message": "comments", "committedDate": "2020-09-23T04:34:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyODE1Nw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493728157", "bodyText": "Why are the numerical IDs returned as a pair of strings instead of Pair<Short, Short>?", "author": "cgtz", "createdAt": "2020-09-23T16:27:22Z", "path": "ambry-account/src/main/java/com/github/ambry/account/HelixAccountService.java", "diffHunk": "@@ -246,6 +250,69 @@ public boolean updateAccounts(Collection<Account> accounts) {\n     return updateAccountsWithAccountMetadataStore(accounts, accountMetadataStore);\n   }\n \n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Override\n+  public Pair<String, String> addContainer(String accountName, Container newContainer) {\n+    checkOpen();\n+    if (accountName == null || accountName.isEmpty() || newContainer == null || newContainer.getName() == null\n+        || newContainer.getName().isEmpty()) {\n+      logger.error(\"Account name: {} or container: {} is invalid\", accountName, newContainer);\n+      throw new IllegalArgumentException(\"Account or container name is null or empty\");\n+    }\n+    Account account = getAccountByName(accountName);\n+    if (account == null) {\n+      logger.error(\"Account {} is not found\", accountName);\n+      throw new IllegalArgumentException(\"Account \" + accountName + \" is not found\");\n+    }\n+    String accountId = String.valueOf(account.getId());\n+    for (Container container : account.getAllContainers()) {\n+      // make sure there is no conflict container (conflict means a container with same name but different attributes already exists).\n+      if (container.getName().equals(newContainer.getName())) {\n+        if (containerEditableFieldsAreSame(container, newContainer)) {\n+          // If an exactly same container already exists, we directly return its id. Adding same container multiple times\n+          // should be no-op.\n+          return new Pair<>(accountId, String.valueOf(container.getId()));", "originalCommit": "8234e62e08b5ef9cebdd36e28af9e624e31b014b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzczMzI5Mw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493733293", "bodyText": "I find containerId/accountId are short type, however, they are int in closed source code. Considering we may change the type to int in the future, so I want to use String here no matter what type of accountId/containerId are.", "author": "jsjtzyy", "createdAt": "2020-09-23T16:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyODE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc5ODEzMw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493798133", "bodyText": "Yes, we will need to change containerId to int.  AccountId can stay short; we may want to also make it int for consistency, if we don't run out of bits in blobId.", "author": "lightningrob", "createdAt": "2020-09-23T18:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyODE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgxNDkwMA==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493814900", "bodyText": "why not change this to Pair<Integer, Integer> then? That would fit both shorts and ints and allow for future flexibility.\nI would like to point out that changing container ID to an int isn't the simplest change. There are implications in the blob ID, blob properties, and index value binary formats. A new version of each one will likely be required along with a staged rollout.", "author": "cgtz", "createdAt": "2020-09-23T18:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyODE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1MzQ1NQ==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493853455", "bodyText": "I see the complexity of changing container id to int. For now, sure, I can change the return type to Integer.", "author": "jsjtzyy", "createdAt": "2020-09-23T19:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyODE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzczMDQwMA==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493730400", "bodyText": "ContainerBuilder has a copy constructor, could we use that here?", "author": "cgtz", "createdAt": "2020-09-23T16:30:46Z", "path": "ambry-account/src/main/java/com/github/ambry/account/HelixAccountService.java", "diffHunk": "@@ -246,6 +250,69 @@ public boolean updateAccounts(Collection<Account> accounts) {\n     return updateAccountsWithAccountMetadataStore(accounts, accountMetadataStore);\n   }\n \n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Override\n+  public Pair<String, String> addContainer(String accountName, Container newContainer) {\n+    checkOpen();\n+    if (accountName == null || accountName.isEmpty() || newContainer == null || newContainer.getName() == null\n+        || newContainer.getName().isEmpty()) {\n+      logger.error(\"Account name: {} or container: {} is invalid\", accountName, newContainer);\n+      throw new IllegalArgumentException(\"Account or container name is null or empty\");\n+    }\n+    Account account = getAccountByName(accountName);\n+    if (account == null) {\n+      logger.error(\"Account {} is not found\", accountName);\n+      throw new IllegalArgumentException(\"Account \" + accountName + \" is not found\");\n+    }\n+    String accountId = String.valueOf(account.getId());\n+    for (Container container : account.getAllContainers()) {\n+      // make sure there is no conflict container (conflict means a container with same name but different attributes already exists).\n+      if (container.getName().equals(newContainer.getName())) {\n+        if (containerEditableFieldsAreSame(container, newContainer)) {\n+          // If an exactly same container already exists, we directly return its id. Adding same container multiple times\n+          // should be no-op.\n+          return new Pair<>(accountId, String.valueOf(container.getId()));\n+        } else {\n+          logger.error(\"A container: {} already exists with different attributes\", container.getName());\n+          throw new IllegalArgumentException(\"There is a conflicting container in account \" + accountName);\n+        }\n+      }\n+    }\n+    // if code reaches here, it means no duplicate container in this account\n+    // generate container id for new container\n+    short nextContainerId = account.getAllContainers()\n+        .stream()\n+        .map(Container::getId)\n+        .max(Short::compareTo)\n+        .map(maxId -> (short) (maxId + 1))\n+        .orElse(CONTAINER_ID_START_RANGE);\n+    // construct a container based on input container and next containerId\n+    Container containerToAdd = new ContainerBuilder(nextContainerId, newContainer.getName(), newContainer.getStatus(),", "originalCommit": "8234e62e08b5ef9cebdd36e28af9e624e31b014b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc0MTk2Mg==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493741962", "bodyText": "Yep, we can. Thanks for the suggestion.", "author": "jsjtzyy", "createdAt": "2020-09-23T16:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzczMDQwMA=="}], "type": "inlineReview"}, {"oid": "aa22af1731edac9ce0457015ddb1a17c9f1be9ce", "url": "https://github.com/linkedin/ambry/commit/aa22af1731edac9ce0457015ddb1a17c9f1be9ce", "message": "address Casey's comments", "committedDate": "2020-09-23T16:49:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNDYzMw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493804633", "bodyText": "The PostAccountsHandler will have method updateContainers that takes a collection of (new or updated) containers in the payload.  Would it make more sense to mirror that in this interface?  Otherwise the handler will need to get the existing containers, compare with the input and call add() and update() as appropriate.  Which may be okay.  But the MySqlAccountService should ideally make all the updates in a single transaction (in case multiple containers are added/updated).", "author": "lightningrob", "createdAt": "2020-09-23T18:33:47Z", "path": "ambry-api/src/main/java/com/github/ambry/account/AccountService.java", "diffHunk": "@@ -107,6 +108,36 @@\n    */\n   public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer);\n \n+  /**\n+   * Add a new container to an existing account.\n+   * @param accountName the name of account in which new container will be added.\n+   * @param newContainer the new container to add.\n+   * @return a pair of account id and container id strings associated with existing account and new container.\n+   */\n+  default Pair<String, String> addContainer(String accountName, Container newContainer) {", "originalCommit": "aa22af1731edac9ce0457015ddb1a17c9f1be9ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxMzcyNQ==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493913725", "bodyText": "How about calling this updateContainers (plural) and accepting a collection of containers?", "author": "lightningrob", "createdAt": "2020-09-23T21:46:03Z", "path": "ambry-api/src/main/java/com/github/ambry/account/AccountService.java", "diffHunk": "@@ -107,6 +108,36 @@\n    */\n   public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer);\n \n+  /**\n+   * Add a new container to an existing account.\n+   * @param accountName the name of account in which new container will be added.\n+   * @param newContainer the new container to add.\n+   * @return a pair of account id and container id strings associated with existing account and new container.\n+   */\n+  default Pair<String, String> addContainer(String accountName, Container newContainer) {\n+    throw new UnsupportedOperationException(\"This method is not supported\");\n+  }\n+\n+  /**\n+   * Update attributes of an existing container.\n+   * @param accountName the name of account which container belongs to.\n+   * @param updatedContainer the updated {@link Container} used to replace current one.\n+   * @return {@code true} if container is successfully updated. {@code false} otherwise.\n+   */\n+  default boolean updateContainer(String accountName, Container updatedContainer) {", "originalCommit": "aa22af1731edac9ce0457015ddb1a17c9f1be9ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkyODE2Ng==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r493928166", "bodyText": "Yeah, I actually renamed it already, will push out the change to github after rest changes are done.", "author": "jsjtzyy", "createdAt": "2020-09-23T22:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxMzcyNQ=="}], "type": "inlineReview"}, {"oid": "43477f8a06f88f955f59d526f086dbb8214560d5", "url": "https://github.com/linkedin/ambry/commit/43477f8a06f88f955f59d526f086dbb8214560d5", "message": "Address Rob's comments", "committedDate": "2020-09-24T04:40:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA0NzI2MQ==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r494047261", "bodyText": "May be we can make it O(n) by storing existing container names in hash set?", "author": "Arun-LinkedIn", "createdAt": "2020-09-24T05:29:30Z", "path": "ambry-account/src/main/java/com/github/ambry/account/HelixAccountService.java", "diffHunk": "@@ -253,56 +253,62 @@ public boolean updateAccounts(Collection<Account> accounts) {\n    * {@inheritDoc}\n    */\n   @Override\n-  public Pair<String, String> addContainer(String accountName, Container newContainer) {\n+  public Collection<Container> addContainers(String accountName, Collection<Container> containers) {\n     checkOpen();\n-    if (accountName == null || accountName.isEmpty() || newContainer == null || newContainer.getName() == null\n-        || newContainer.getName().isEmpty()) {\n-      logger.error(\"Account name: {} or container: {} is invalid\", accountName, newContainer);\n-      throw new IllegalArgumentException(\"Account or container name is null or empty\");\n+    // input validation\n+    if (accountName == null || accountName.isEmpty() || containers == null || containers.isEmpty()) {\n+      throw new IllegalArgumentException(\"Account or container is null or empty\");\n     }\n     Account account = getAccountByName(accountName);\n     if (account == null) {\n       logger.error(\"Account {} is not found\", accountName);\n       throw new IllegalArgumentException(\"Account \" + accountName + \" is not found\");\n     }\n-    String accountId = String.valueOf(account.getId());\n-    for (Container container : account.getAllContainers()) {\n-      // make sure there is no conflict container (conflict means a container with same name but different attributes already exists).\n-      if (container.getName().equals(newContainer.getName())) {\n-        if (container.isSameContainer(newContainer)) {\n-          // If an exactly same container already exists, we directly return its id. Adding same container multiple times\n-          // should be no-op.\n-          return new Pair<>(accountId, String.valueOf(container.getId()));\n-        } else {\n-          logger.error(\"A container: {} already exists with different attributes\", container.getName());\n-          throw new IllegalArgumentException(\"There is a conflicting container in account \" + accountName);\n+    Set<Container> existingContainers = new HashSet<>();\n+    Set<Container> newContainers = new HashSet<>(containers);\n+    for (Container existingContainer : account.getAllContainers()) {\n+      for (Container newContainer : containers) {", "originalCommit": "43477f8a06f88f955f59d526f086dbb8214560d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA0Nzk0Nw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r494047947", "bodyText": "Good point, thanks for the suggestion. Will make changes based on hashmap.", "author": "jsjtzyy", "createdAt": "2020-09-24T05:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA0NzI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA0NTQ4Mg==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r494045482", "bodyText": "Minor: conflicting container", "author": "lightningrob", "createdAt": "2020-09-24T05:23:13Z", "path": "ambry-account/src/main/java/com/github/ambry/account/HelixAccountService.java", "diffHunk": "@@ -253,56 +253,62 @@ public boolean updateAccounts(Collection<Account> accounts) {\n    * {@inheritDoc}\n    */\n   @Override\n-  public Pair<String, String> addContainer(String accountName, Container newContainer) {\n+  public Collection<Container> addContainers(String accountName, Collection<Container> containers) {\n     checkOpen();\n-    if (accountName == null || accountName.isEmpty() || newContainer == null || newContainer.getName() == null\n-        || newContainer.getName().isEmpty()) {\n-      logger.error(\"Account name: {} or container: {} is invalid\", accountName, newContainer);\n-      throw new IllegalArgumentException(\"Account or container name is null or empty\");\n+    // input validation\n+    if (accountName == null || accountName.isEmpty() || containers == null || containers.isEmpty()) {\n+      throw new IllegalArgumentException(\"Account or container is null or empty\");\n     }\n     Account account = getAccountByName(accountName);\n     if (account == null) {\n       logger.error(\"Account {} is not found\", accountName);\n       throw new IllegalArgumentException(\"Account \" + accountName + \" is not found\");\n     }\n-    String accountId = String.valueOf(account.getId());\n-    for (Container container : account.getAllContainers()) {\n-      // make sure there is no conflict container (conflict means a container with same name but different attributes already exists).\n-      if (container.getName().equals(newContainer.getName())) {\n-        if (container.isSameContainer(newContainer)) {\n-          // If an exactly same container already exists, we directly return its id. Adding same container multiple times\n-          // should be no-op.\n-          return new Pair<>(accountId, String.valueOf(container.getId()));\n-        } else {\n-          logger.error(\"A container: {} already exists with different attributes\", container.getName());\n-          throw new IllegalArgumentException(\"There is a conflicting container in account \" + accountName);\n+    Set<Container> existingContainers = new HashSet<>();\n+    Set<Container> newContainers = new HashSet<>(containers);\n+    for (Container existingContainer : account.getAllContainers()) {\n+      for (Container newContainer : containers) {\n+        // make sure there is no conflict container (conflict means a container with same name but different attributes already exists).", "originalCommit": "43477f8a06f88f955f59d526f086dbb8214560d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA0ODk2Ng==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r494048966", "bodyText": "The Helix impl returns all containers (added or already exist).  Javadoc should mention that existing containers are ignored.", "author": "lightningrob", "createdAt": "2020-09-24T05:34:55Z", "path": "ambry-api/src/main/java/com/github/ambry/account/AccountService.java", "diffHunk": "@@ -109,22 +108,22 @@\n   public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer);\n \n   /**\n-   * Add a new container to an existing account.\n+   * Add a collection of containers to an existing account.\n    * @param accountName the name of account in which new container will be added.\n-   * @param newContainer the new container to add.\n-   * @return a pair of account id and container id strings associated with existing account and new container.\n+   * @param containers a collection of containers to add.\n+   * @return a collection of containers that are successfully added.", "originalCommit": "43477f8a06f88f955f59d526f086dbb8214560d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1MjE4NQ==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r494052185", "bodyText": "Even if we don't update in-memory account here, may be it might eventually get updated later when fetchAndUpdateCache() is called by background updater thread or on ZK notification (similar to how accounts in cache get updated today after updateAccounts() is called from PostAccountsHandler).", "author": "Arun-LinkedIn", "createdAt": "2020-09-24T05:45:30Z", "path": "ambry-account/src/main/java/com/github/ambry/account/HelixAccountService.java", "diffHunk": "@@ -253,56 +253,62 @@ public boolean updateAccounts(Collection<Account> accounts) {\n    * {@inheritDoc}\n    */\n   @Override\n-  public Pair<String, String> addContainer(String accountName, Container newContainer) {\n+  public Collection<Container> addContainers(String accountName, Collection<Container> containers) {\n     checkOpen();\n-    if (accountName == null || accountName.isEmpty() || newContainer == null || newContainer.getName() == null\n-        || newContainer.getName().isEmpty()) {\n-      logger.error(\"Account name: {} or container: {} is invalid\", accountName, newContainer);\n-      throw new IllegalArgumentException(\"Account or container name is null or empty\");\n+    // input validation\n+    if (accountName == null || accountName.isEmpty() || containers == null || containers.isEmpty()) {\n+      throw new IllegalArgumentException(\"Account or container is null or empty\");\n     }\n     Account account = getAccountByName(accountName);\n     if (account == null) {\n       logger.error(\"Account {} is not found\", accountName);\n       throw new IllegalArgumentException(\"Account \" + accountName + \" is not found\");\n     }\n-    String accountId = String.valueOf(account.getId());\n-    for (Container container : account.getAllContainers()) {\n-      // make sure there is no conflict container (conflict means a container with same name but different attributes already exists).\n-      if (container.getName().equals(newContainer.getName())) {\n-        if (container.isSameContainer(newContainer)) {\n-          // If an exactly same container already exists, we directly return its id. Adding same container multiple times\n-          // should be no-op.\n-          return new Pair<>(accountId, String.valueOf(container.getId()));\n-        } else {\n-          logger.error(\"A container: {} already exists with different attributes\", container.getName());\n-          throw new IllegalArgumentException(\"There is a conflicting container in account \" + accountName);\n+    Set<Container> existingContainers = new HashSet<>();\n+    Set<Container> newContainers = new HashSet<>(containers);\n+    for (Container existingContainer : account.getAllContainers()) {\n+      for (Container newContainer : containers) {\n+        // make sure there is no conflict container (conflict means a container with same name but different attributes already exists).\n+        if (existingContainer.getName().equals(newContainer.getName())) {\n+          if (existingContainer.isSameContainer(newContainer)) {\n+            // If an exactly same container already exists, we directly return its id. Adding same container multiple times\n+            // should be no-op.\n+            existingContainers.add(existingContainer);\n+          } else {\n+            throw new IllegalArgumentException(\"There is a conflicting container in account \" + accountName);\n+          }\n         }\n       }\n     }\n-    // if code reaches here, it means no duplicate container in this account\n-    // generate container id for new container\n+    newContainers.removeAll(existingContainers);\n+\n+    // if code reaches here, it means no conflicting container in this account\n     short nextContainerId = account.getAllContainers()\n         .stream()\n         .map(Container::getId)\n         .max(Short::compareTo)\n         .map(maxId -> (short) (maxId + 1))\n         .orElse(config.containerIdStartNumber);\n     // construct a container based on input container and next containerId\n-    Container containerToAdd =\n-        new ContainerBuilder(newContainer).setId(nextContainerId).setParentAccountId(account.getId()).build();\n-    account.updateContainerMap(containerToAdd);\n-    List<Account> accounts = Collections.singletonList(account);\n-    boolean hasSucceeded = false;\n-    if (accountInfoMapRef.get().hasConflictingAccount(accounts)) {\n-      logger.debug(\"Accounts={} conflict with the accounts in local cache. Cancel the update operation.\", accounts);\n-      accountServiceMetrics.updateAccountErrorCount.inc();\n-    } else {\n-      hasSucceeded = accountMetadataStore.updateAccounts(accounts);\n+    List<Container> createdContainers = new ArrayList<>();\n+    for (Container container : newContainers) {\n+      createdContainers.add(\n+          new ContainerBuilder(container).setId(nextContainerId).setParentAccountId(account.getId()).build());\n+      ++nextContainerId;\n     }\n+    // In case updating account metadata store failed, we do a deep copy of original account. Thus, we don't have to\n+    // revert changes in original account when there is a failure.\n+    Account accountCopy = new AccountBuilder(account).build();\n+    accountCopy.updateContainerMap(createdContainers);\n+    boolean hasSucceeded = updateAccounts(Collections.singletonList(accountCopy));\n     if (!hasSucceeded) {\n       throw new IllegalStateException(\"Account update failed for \" + accountName);\n     }\n-    return new Pair<>(accountId, String.valueOf(nextContainerId));\n+    // after metadata store is successfully updated, we safely update original account\n+    account.updateContainerMap(createdContainers);", "originalCommit": "43477f8a06f88f955f59d526f086dbb8214560d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1NzQ4Nw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r494057487", "bodyText": "Yes, that's true. However, I think updating the in-mem account immediately doesn't do harm to the correctness. It ensures the in-mem account immediately has latest view (in case ZK notification missed and there is subsequent request against new container immediately after the creation).", "author": "jsjtzyy", "createdAt": "2020-09-24T06:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1MjE4NQ=="}], "type": "inlineReview"}, {"oid": "1afbb6459f4de8228f9b2bbc4a14afd3242e1e06", "url": "https://github.com/linkedin/ambry/commit/1afbb6459f4de8228f9b2bbc4a14afd3242e1e06", "message": "address comments from Rob and Arun", "committedDate": "2020-09-24T06:31:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ1NDM3OQ==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r494454379", "bodyText": "I think these methods should throw exceptions (might need to create one).  They can't return false, and having the impl throw IllegalStateException on any failure doesn't feel right.", "author": "lightningrob", "createdAt": "2020-09-24T16:29:59Z", "path": "ambry-api/src/main/java/com/github/ambry/account/AccountService.java", "diffHunk": "@@ -107,6 +107,37 @@\n    */\n   public boolean removeAccountUpdateConsumer(Consumer<Collection<Account>> accountUpdateConsumer);\n \n+  /**\n+   * Add a collection of containers to an existing account.\n+   * @param accountName the name of account in which new container will be added.\n+   * @param containers a collection of containers to add.\n+   * @return a collection of containers that are successfully added. If original input containers includes existing one,\n+   *         the existing containers will be ignored and not present in the result.\n+   */\n+  default Collection<Container> addContainers(String accountName, Collection<Container> containers) {", "originalCommit": "1afbb6459f4de8228f9b2bbc4a14afd3242e1e06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ4NjYwNA==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r494486604", "bodyText": "Yes, I was trying to use RestException but felt not appropriate. I can introduce new type of exception, for example, AccountServiceException. What do you think?", "author": "jsjtzyy", "createdAt": "2020-09-24T17:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ1NDM3OQ=="}], "type": "inlineReview"}, {"oid": "b4a8f0aac29bd777eeb6d6bafe541610d7323969", "url": "https://github.com/linkedin/ambry/commit/b4a8f0aac29bd777eeb6d6bafe541610d7323969", "message": "introduced AccountServiceException", "committedDate": "2020-09-24T17:56:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxNDk3Mw==", "url": "https://github.com/linkedin/ambry/pull/1628#discussion_r494514973", "bodyText": "updateAccounts can also throw AccountServiceException (future PR)", "author": "lightningrob", "createdAt": "2020-09-24T18:11:57Z", "path": "ambry-account/src/main/java/com/github/ambry/account/HelixAccountService.java", "diffHunk": "@@ -305,7 +307,8 @@ public boolean updateAccounts(Collection<Account> accounts) {\n       accountCopy.updateContainerMap(createdContainers);\n       boolean hasSucceeded = updateAccounts(Collections.singletonList(accountCopy));", "originalCommit": "b4a8f0aac29bd777eeb6d6bafe541610d7323969", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}