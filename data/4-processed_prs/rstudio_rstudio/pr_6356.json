{"pr_number": 6356, "pr_title": "Feature/database", "pr_createdAt": "2020-02-27T22:51:03Z", "pr_url": "https://github.com/rstudio/rstudio/pull/6356", "timeline": [{"oid": "6620f517ab57306fb729163398c4fc180e580790", "url": "https://github.com/rstudio/rstudio/commit/6620f517ab57306fb729163398c4fc180e580790", "message": "Create basic SOCI dependency script, and test that SOCI builds and links properly with RStudio", "committedDate": "2020-02-06T21:26:53Z", "type": "commit"}, {"oid": "88ed41b962313ec5d81f37e79f89a1855523012d", "url": "https://github.com/rstudio/rstudio/commit/88ed41b962313ec5d81f37e79f89a1855523012d", "message": "SOCI dependency installer script fixes for OSX", "committedDate": "2020-02-06T21:52:47Z", "type": "commit"}, {"oid": "6a0fc0f3bdb2dc4ceb7d84c6ceb7c36297b25d83", "url": "https://github.com/rstudio/rstudio/commit/6a0fc0f3bdb2dc4ceb7d84c6ceb7c36297b25d83", "message": "Update Linux installers to install SQLite and PostgreSQL client libs", "committedDate": "2020-02-06T22:02:17Z", "type": "commit"}, {"oid": "c07836d2b061f624f014efa232da01ced5a458e0", "url": "https://github.com/rstudio/rstudio/commit/c07836d2b061f624f014efa232da01ced5a458e0", "message": "Add postgres install for osx", "committedDate": "2020-02-06T22:14:27Z", "type": "commit"}, {"oid": "d8414177e49e6199d0afd1130eec7907515c6b39", "url": "https://github.com/rstudio/rstudio/commit/d8414177e49e6199d0afd1130eec7907515c6b39", "message": "Now copying db client libs to Linux package and setting RPATH=", "committedDate": "2020-02-07T17:01:00Z", "type": "commit"}, {"oid": "d819bd721d7ebc7ca32939edf8c5fa266f4a9354", "url": "https://github.com/rstudio/rstudio/commit/d819bd721d7ebc7ca32939edf8c5fa266f4a9354", "message": "Add packaging of database libraries for OSX", "committedDate": "2020-02-07T18:58:24Z", "type": "commit"}, {"oid": "239c431d0fde2dfb008e8cb7e881864a05dec4ae", "url": "https://github.com/rstudio/rstudio/commit/239c431d0fde2dfb008e8cb7e881864a05dec4ae", "message": "Added install-soci Windows dependency script, which currently successfully builds soci_core and soci_sqlite", "committedDate": "2020-02-10T18:37:45Z", "type": "commit"}, {"oid": "994d252576378f409117b78b6697b0bdfbd11e65", "url": "https://github.com/rstudio/rstudio/commit/994d252576378f409117b78b6697b0bdfbd11e65", "message": "Got SOCI+SQLite building/linking with RStudio codebase", "committedDate": "2020-02-10T20:37:00Z", "type": "commit"}, {"oid": "5cfc91d9003a89a7e859b4cc7dd56d0b3a038708", "url": "https://github.com/rstudio/rstudio/commit/5cfc91d9003a89a7e859b4cc7dd56d0b3a038708", "message": "Added support for both x86 and x64 SOCI and SQLite builds. Because of the dependency on OpenSSL, PostgreSQL will not support x86.", "committedDate": "2020-02-10T23:03:47Z", "type": "commit"}, {"oid": "96907e7ac28bb23758e0bb30b996c19c317e867b", "url": "https://github.com/rstudio/rstudio/commit/96907e7ac28bb23758e0bb30b996c19c317e867b", "message": "Now building and integrating libpq with Windows version of RStudio", "committedDate": "2020-02-11T17:36:55Z", "type": "commit"}, {"oid": "6b5eb19db552c04159ecc63fbb6d8110a957e537", "url": "https://github.com/rstudio/rstudio/commit/6b5eb19db552c04159ecc63fbb6d8110a957e537", "message": "Add SOCI to NOTICE file for copyright", "committedDate": "2020-02-11T20:26:45Z", "type": "commit"}, {"oid": "5b8b46f5c5bef7dac89f4e2827651ff198152b25", "url": "https://github.com/rstudio/rstudio/commit/5b8b46f5c5bef7dac89f4e2827651ff198152b25", "message": "Workaround fix to get PACKAGE_OS propagating to OSX builds. The  specifier is empty for some reason, but the build numbers propagate as expected", "committedDate": "2020-02-18T16:25:07Z", "type": "commit"}, {"oid": "94be71f95f290bbaae27058897ff4425a2b9ede1", "url": "https://github.com/rstudio/rstudio/commit/94be71f95f290bbaae27058897ff4425a2b9ede1", "message": "Revert \"Workaround fix to get PACKAGE_OS propagating to OSX builds. The  specifier is empty for some reason, but the build numbers propagate as expected\"\n\nThis reverts commit 5b8b46f5c5bef7dac89f4e2827651ff198152b25.", "committedDate": "2020-02-18T16:26:13Z", "type": "commit"}, {"oid": "00128e890783463ca66d4297d2b1a2e243876306", "url": "https://github.com/rstudio/rstudio/commit/00128e890783463ca66d4297d2b1a2e243876306", "message": "Add basic database code - connection and statement execution", "committedDate": "2020-02-19T17:46:47Z", "type": "commit"}, {"oid": "074862008ec8c5a7fe04089bd838b11e704f064b", "url": "https://github.com/rstudio/rstudio/commit/074862008ec8c5a7fe04089bd838b11e704f064b", "message": "Added integration of soci errors with boost error codes", "committedDate": "2020-02-19T19:03:13Z", "type": "commit"}, {"oid": "8646405cabe55ae0c91ebeb83b42cb644d84f1d5", "url": "https://github.com/rstudio/rstudio/commit/8646405cabe55ae0c91ebeb83b42cb644d84f1d5", "message": "Add postgresql connection code and rework db test to only use wrapper interface", "committedDate": "2020-02-19T20:29:41Z", "type": "commit"}, {"oid": "88134af8b064b89868963bc0fb5574941c20b430", "url": "https://github.com/rstudio/rstudio/commit/88134af8b064b89868963bc0fb5574941c20b430", "message": "Fix postgresql connection string and add postgres test", "committedDate": "2020-02-19T20:50:06Z", "type": "commit"}, {"oid": "40887684e82718eba3004ad1403d967e15907535", "url": "https://github.com/rstudio/rstudio/commit/40887684e82718eba3004ad1403d967e15907535", "message": "Added transaction and connection pool support", "committedDate": "2020-02-21T20:41:58Z", "type": "commit"}, {"oid": "bb9335063ac58c45898b296db1b07346371f0527", "url": "https://github.com/rstudio/rstudio/commit/bb9335063ac58c45898b296db1b07346371f0527", "message": "WIP - Database schema updater", "committedDate": "2020-02-21T22:12:38Z", "type": "commit"}, {"oid": "400da671eb05d6e91157968a9c0401bcf9c32e4b", "url": "https://github.com/rstudio/rstudio/commit/400da671eb05d6e91157968a9c0401bcf9c32e4b", "message": "First working implementation of database schema updater and associated tests", "committedDate": "2020-02-24T22:21:56Z", "type": "commit"}, {"oid": "039eff769552981ad3d83dcf73634c816f2ccc91", "url": "https://github.com/rstudio/rstudio/commit/039eff769552981ad3d83dcf73634c816f2ccc91", "message": "Added bulk select capability, and added testing of bulk inserts", "committedDate": "2020-02-25T21:25:47Z", "type": "commit"}, {"oid": "a020fb86c0d4c39274ec247f1d2d89f26dd68b14", "url": "https://github.com/rstudio/rstudio/commit/a020fb86c0d4c39274ec247f1d2d89f26dd68b14", "message": "Merge branch 'v1.4' into feature/database", "committedDate": "2020-02-25T21:29:03Z", "type": "commit"}, {"oid": "fa484e3083d3c6d0a940f76ff51e16dbecca92ac", "url": "https://github.com/rstudio/rstudio/commit/fa484e3083d3c6d0a940f76ff51e16dbecca92ac", "message": "Lay down first version of ServerDatabase for initializing database connection in server processes, and performing schema updates", "committedDate": "2020-02-26T21:44:45Z", "type": "commit"}, {"oid": "273d94eee65ec5d69fa074c4f0ce5d33dd65826b", "url": "https://github.com/rstudio/rstudio/commit/273d94eee65ec5d69fa074c4f0ce5d33dd65826b", "message": "Add default database.conf file on install", "committedDate": "2020-02-26T22:17:18Z", "type": "commit"}, {"oid": "ad186b379e4a3de21e7c171aa8f596220e6cd946", "url": "https://github.com/rstudio/rstudio/commit/ad186b379e4a3de21e7c171aa8f596220e6cd946", "message": "Fix SOCI library load paths on Linux and make default database.conf file user read write only", "committedDate": "2020-02-27T16:39:05Z", "type": "commit"}, {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e", "url": "https://github.com/rstudio/rstudio/commit/ac749e316dbc2ab48842f19646e43301acb7c41e", "message": "Port revocation list storage to DB", "committedDate": "2020-02-27T20:59:12Z", "type": "commit"}, {"oid": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "url": "https://github.com/rstudio/rstudio/commit/d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "message": "Linux SOCI build fixes", "committedDate": "2020-02-28T23:02:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NzY0NQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385957645", "bodyText": "I think it's more common to package the libraries in a separate folder; e.g. at $ORIGIN/../lib. Would that be workable here?", "author": "kevinushey", "createdAt": "2020-02-28T22:48:44Z", "path": "CMakeGlobals.txt", "diffHunk": "@@ -261,8 +261,15 @@ endfunction()\n # define custom installation macro to strip symbols from the binary\n macro(add_stripped_executable _target)\n    add_executable(${_target} ${ARGN})\n+\n+   # set RPATH=$ORIGIN to ensure that any bundled libraries are found in our binary dir\n+   set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\n+   set_target_properties(${_target} PROPERTIES INSTALL_RPATH \\$ORIGIN)", "originalCommit": "ac749e316dbc2ab48842f19646e43301acb7c41e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4MjgyMw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386482823", "bodyText": "I had trouble getting that working on all the various platforms, but was able to get everything working out of the bin dir, so figured for now to just go with the simple approach.", "author": "kfeinauer", "createdAt": "2020-03-02T15:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1ODAyMw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385958023", "bodyText": "This should be install-soci now.", "author": "kevinushey", "createdAt": "2020-02-28T22:50:11Z", "path": "dependencies/windows/install-soci/install-soci.R", "diffHunk": "@@ -0,0 +1,97 @@\n+# some laziness to ensure we move to the 'install-crashpad' folder\n+if (file.exists(\"rstudio.Rproj\"))\n+   setwd(\"dependencies/windows/install-crashpad\")", "originalCommit": "ac749e316dbc2ab48842f19646e43301acb7c41e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1ODMxMQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385958311", "bodyText": "Nit: normalizePath() will emit an error if the path doesn't already exist, so you might want to use normalizePath(..., mustWork = FALSE) here.", "author": "kevinushey", "createdAt": "2020-02-28T22:51:11Z", "path": "dependencies/windows/install-soci/install-soci.R", "diffHunk": "@@ -0,0 +1,97 @@\n+# some laziness to ensure we move to the 'install-crashpad' folder\n+if (file.exists(\"rstudio.Rproj\"))\n+   setwd(\"dependencies/windows/install-crashpad\")\n+\n+source(\"../tools.R\")\n+section(\"The working directory is: '%s'\", getwd())\n+progress(\"Producing SOCI build\")\n+owd <- getwd()\n+\n+# initialize log directory (for when things go wrong)\n+unlink(\"logs\", recursive = TRUE)\n+dir.create(\"logs\")\n+options(log.dir = normalizePath(\"logs\"))\n+\n+# put RStudio tools on PATH\n+PATH$prepend(\"../tools\")\n+\n+# initialize variables\n+output_dir <- normalizePath(file.path(owd, \"..\"), winslash = \"\\\\\")\n+boost_dir <- normalizePath(file.path(output_dir, \"boost-1.69.0-win-msvc141-release-static\\\\boost64\"), winslash = \"\\\\\")\n+soci_branch <- \"release/4.0\"\n+soci_dir <- file.path(owd, \"soci\")\n+soci_build_dir <- file.path(soci_dir, \"build\")\n+sqlite_dir <- file.path(owd, \"sqlite\")\n+postgresql_dir <- file.path(owd, \"postgresql\")\n+sqlite_header_zip_url <- \"https://sqlite.org/2020/sqlite-amalgamation-3310100.zip\"\n+sqlite_header_zip <- file.path(sqlite_dir, \"sqlite-header.zip\")\n+sqlite_header_dir <- file.path(sqlite_dir, \"sqlite-amalgamation-3310100\")\n+postgresql_zip <- file.path(owd, \"win-postgresql.zip\")\n+postgresql_zip_url <- \"https://rstudio-buildtools.s3.amazonaws.com/win-postgresql.zip\"\n+\n+downloadAndUnzip <- function(outputFile, extractDir, url) {\n+   # download zip if we don't already have it\n+   if (!file.exists(outputFile)) {\n+      section(\"Downloading '%s' from '%s'\", outputFile, url)\n+\t  download(url, destfile = outputFile)\n+\t  if (!file.exists(outputFile))\n+\t     fatal(\"Failed to download '%s'\", outputFile)\n+   }\n+   \n+   # extract zip file\n+   progress(\"Extracting zip file '%s'\", outputFile)\n+   unzip(outputFile, exdir = extractDir)\n+}\n+\n+if (!file.exists(normalizePath(file.path(soci_build_dir, \"x64\\\\lib\\\\Release\\\\libsoci_core_4_0.lib\"), winslash = \"\\\\\"))) {", "originalCommit": "ac749e316dbc2ab48842f19646e43301acb7c41e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MDg0Mg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385960842", "bodyText": "This will break if the version of postgresql installed by Brew happens to change. You can access the current path using:\nbrew --prefix postgresql\n\nOr, alternatively, Homebrew normally symlinks the current version of a formula to /usr/local/opt, so you could just check:\n/usr/local/opt/postgresql\n\ninstead.\nAside: libpq and postgresql are separate formula; are you sure you want to use the postgres includes here or do you want to use libpq specifically?", "author": "kevinushey", "createdAt": "2020-02-28T23:00:00Z", "path": "src/cpp/CMakeLists.txt", "diffHunk": "@@ -355,6 +361,110 @@ else()\n    endif()\n endif()\n \n+# SOCI\n+if(UNIX)\n+   set(RSTUDIO_TOOLS_SOCI \"/opt/rstudio-tools/soci\")\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/include\")\n+else()\n+   set(RSTUDIO_TOOLS_SOCI \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/soci\")\n+   if(RSTUDIO_SESSION_WIN32)\n+      set(SOCI_ARCH \"x86\")\n+   else()\n+      set(SOCI_ARCH \"x64\")\n+   endif()\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/include\")\n+endif()\n+\n+set(SOCI_INCLUDE_DIR \"${RSTUDIO_TOOLS_SOCI}/include\")\n+include_directories(SYSTEM ${SOCI_INCLUDE_DIR})\n+include_directories(SYSTEM ${SOCI_INCLUDE_BUILD_DIR})\n+\n+# database library includes\n+if (UNIX)\n+   if (APPLE)\n+      # We assume that libpq is available under the default brew install location\n+      # since we install postgresql via brew in install-dependencies-osx\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include\")\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include/libpq\")", "originalCommit": "ac749e316dbc2ab48842f19646e43301acb7c41e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4NDk5Ng==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386484996", "bodyText": "Because of how the includes are set up in SOCI, both of these paths are necessary, so this was intentional.", "author": "kfeinauer", "createdAt": "2020-03-02T16:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MDg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTM0OQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385961349", "bodyText": "Nit: because the above is a fatal error you could just endif() and save a level of indentation.", "author": "kevinushey", "createdAt": "2020-02-28T23:01:48Z", "path": "src/cpp/CMakeLists.txt", "diffHunk": "@@ -355,6 +361,110 @@ else()\n    endif()\n endif()\n \n+# SOCI\n+if(UNIX)\n+   set(RSTUDIO_TOOLS_SOCI \"/opt/rstudio-tools/soci\")\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/include\")\n+else()\n+   set(RSTUDIO_TOOLS_SOCI \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/soci\")\n+   if(RSTUDIO_SESSION_WIN32)\n+      set(SOCI_ARCH \"x86\")\n+   else()\n+      set(SOCI_ARCH \"x64\")\n+   endif()\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/include\")\n+endif()\n+\n+set(SOCI_INCLUDE_DIR \"${RSTUDIO_TOOLS_SOCI}/include\")\n+include_directories(SYSTEM ${SOCI_INCLUDE_DIR})\n+include_directories(SYSTEM ${SOCI_INCLUDE_BUILD_DIR})\n+\n+# database library includes\n+if (UNIX)\n+   if (APPLE)\n+      # We assume that libpq is available under the default brew install location\n+      # since we install postgresql via brew in install-dependencies-osx\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include\")\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include/libpq\")\n+   else()\n+      include_directories(SYSTEM \"/usr/include/postgresql\")\n+   endif()\n+elseif(WIN32)\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite-amalgamation-3310100\")\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/include\")\n+endif()\n+\n+# find SOCI libraries\n+if(UNIX)\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/lib\")\n+   if (NOT APPLE)\n+      set(LIB_SUFFIX \".so\")\n+      set(SOCI_LIB_SYMLINK \"${LIB_SUFFIX}.4.0\")\n+      set(SOCI_LIB_SUFFIX \"${LIB_SUFFIX}.4.0.0\")\n+   else()\n+      set(LIB_SUFFIX \".dylib\")\n+      set(SOCI_LIB_SYMLINK \".4.0${LIB_SUFFIX}\")\n+      set(SOCI_LIB_SUFFIX \".4.0.0${LIB_SUFFIX}\")\n+   endif()\n+   file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/*${LIB_SUFFIX}\")\n+else()\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/lib\")\n+   if(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Debug/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-debug-${SOCI_ARCH}.lib\")\n+   else()\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Release/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-release-${SOCI_ARCH}.lib\")\n+   endif()\n+endif()\n+list(LENGTH SOCI_LIBRARIES SOCI_LIB_COUNT)\n+\n+if (SOCI_LIB_COUNT EQUAL 0)\n+   message(FATAL_ERROR \"No SOCI libraries found under ${SOCI_LIBRARY_DIR}. Ensure the SOCI dependency is installed and try again.\")\n+else()", "originalCommit": "ac749e316dbc2ab48842f19646e43301acb7c41e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTg0MQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385961841", "bodyText": "Do we need to add something to NOTICE for libsqlite?", "author": "kevinushey", "createdAt": "2020-02-28T23:03:42Z", "path": "src/cpp/CMakeLists.txt", "diffHunk": "@@ -355,6 +361,110 @@ else()\n    endif()\n endif()\n \n+# SOCI\n+if(UNIX)\n+   set(RSTUDIO_TOOLS_SOCI \"/opt/rstudio-tools/soci\")\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/include\")\n+else()\n+   set(RSTUDIO_TOOLS_SOCI \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/soci\")\n+   if(RSTUDIO_SESSION_WIN32)\n+      set(SOCI_ARCH \"x86\")\n+   else()\n+      set(SOCI_ARCH \"x64\")\n+   endif()\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/include\")\n+endif()\n+\n+set(SOCI_INCLUDE_DIR \"${RSTUDIO_TOOLS_SOCI}/include\")\n+include_directories(SYSTEM ${SOCI_INCLUDE_DIR})\n+include_directories(SYSTEM ${SOCI_INCLUDE_BUILD_DIR})\n+\n+# database library includes\n+if (UNIX)\n+   if (APPLE)\n+      # We assume that libpq is available under the default brew install location\n+      # since we install postgresql via brew in install-dependencies-osx\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include\")\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include/libpq\")\n+   else()\n+      include_directories(SYSTEM \"/usr/include/postgresql\")\n+   endif()\n+elseif(WIN32)\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite-amalgamation-3310100\")\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/include\")\n+endif()\n+\n+# find SOCI libraries\n+if(UNIX)\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/lib\")\n+   if (NOT APPLE)\n+      set(LIB_SUFFIX \".so\")\n+      set(SOCI_LIB_SYMLINK \"${LIB_SUFFIX}.4.0\")\n+      set(SOCI_LIB_SUFFIX \"${LIB_SUFFIX}.4.0.0\")\n+   else()\n+      set(LIB_SUFFIX \".dylib\")\n+      set(SOCI_LIB_SYMLINK \".4.0${LIB_SUFFIX}\")\n+      set(SOCI_LIB_SUFFIX \".4.0.0${LIB_SUFFIX}\")\n+   endif()\n+   file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/*${LIB_SUFFIX}\")\n+else()\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/lib\")\n+   if(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Debug/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-debug-${SOCI_ARCH}.lib\")\n+   else()\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Release/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-release-${SOCI_ARCH}.lib\")\n+   endif()\n+endif()\n+list(LENGTH SOCI_LIBRARIES SOCI_LIB_COUNT)\n+\n+if (SOCI_LIB_COUNT EQUAL 0)\n+   message(FATAL_ERROR \"No SOCI libraries found under ${SOCI_LIBRARY_DIR}. Ensure the SOCI dependency is installed and try again.\")\n+else()\n+   message(STATUS \"SOCI libraries found under ${SOCI_LIBRARY_DIR}.\")\n+\n+   # ensure the soci/sqlite/postgres libraries are installed with the installation package\n+   if(UNIX)\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_core${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_sqlite3${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_postgresql${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+\n+      GET_PREREQUISITES(\"${SOCI_LIBRARY_DIR}/libsoci_sqlite3${SOCI_LIB_SUFFIX}\" SQLITE_LIBS \"0\" \"0\" \".\" \"\")\n+      foreach(LIBRARY IN LISTS SQLITE_LIBS)\n+         string(FIND \"${LIBRARY}\" \"libsqlite3\" INDEX)\n+         if(INDEX GREATER \"-1\")\n+            set(SQLITE_LIB \"${LIBRARY}\")\n+         endif()\n+      endforeach(LIBRARY)\n+\n+      GET_PREREQUISITES(\"${SOCI_LIBRARY_DIR}/libsoci_postgresql${SOCI_LIB_SUFFIX}\" POSTGRES_LIBS \"0\" \"0\" \".\" \"\")\n+      foreach(LIBRARY IN LISTS POSTGRES_LIBS)\n+         string(FIND \"${LIBRARY}\" \"libpq\" INDEX)\n+         if(INDEX GREATER \"-1\")\n+            set(POSTGRES_LIB \"${LIBRARY}\")\n+         endif()\n+      endforeach(LIBRARY)\n+\n+      get_filename_component(SQLITE_LIB \"${SQLITE_LIB}\" REALPATH)\n+      get_filename_component(POSTGRES_LIB \"${POSTGRES_LIB}\" REALPATH)\n+      message(STATUS \"SQLite lib: ${SQLITE_LIB}\")\n+      message(STATUS \"PostgreSQL lib: ${POSTGRES_LIB}\")\n+      install(PROGRAMS \"${SQLITE_LIB}\" DESTINATION ${RSTUDIO_INSTALL_BIN})", "originalCommit": "ac749e316dbc2ab48842f19646e43301acb7c41e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4NzY1NA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386487654", "bodyText": "No, it's actually public domain!", "author": "kfeinauer", "createdAt": "2020-03-02T16:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTk0MA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385961940", "bodyText": "Similarly: NOTICE for libpq?", "author": "kevinushey", "createdAt": "2020-02-28T23:04:04Z", "path": "src/cpp/CMakeLists.txt", "diffHunk": "@@ -355,6 +361,110 @@ else()\n    endif()\n endif()\n \n+# SOCI\n+if(UNIX)\n+   set(RSTUDIO_TOOLS_SOCI \"/opt/rstudio-tools/soci\")\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/include\")\n+else()\n+   set(RSTUDIO_TOOLS_SOCI \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/soci\")\n+   if(RSTUDIO_SESSION_WIN32)\n+      set(SOCI_ARCH \"x86\")\n+   else()\n+      set(SOCI_ARCH \"x64\")\n+   endif()\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/include\")\n+endif()\n+\n+set(SOCI_INCLUDE_DIR \"${RSTUDIO_TOOLS_SOCI}/include\")\n+include_directories(SYSTEM ${SOCI_INCLUDE_DIR})\n+include_directories(SYSTEM ${SOCI_INCLUDE_BUILD_DIR})\n+\n+# database library includes\n+if (UNIX)\n+   if (APPLE)\n+      # We assume that libpq is available under the default brew install location\n+      # since we install postgresql via brew in install-dependencies-osx\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include\")\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include/libpq\")\n+   else()\n+      include_directories(SYSTEM \"/usr/include/postgresql\")\n+   endif()\n+elseif(WIN32)\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite-amalgamation-3310100\")\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/include\")\n+endif()\n+\n+# find SOCI libraries\n+if(UNIX)\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/lib\")\n+   if (NOT APPLE)\n+      set(LIB_SUFFIX \".so\")\n+      set(SOCI_LIB_SYMLINK \"${LIB_SUFFIX}.4.0\")\n+      set(SOCI_LIB_SUFFIX \"${LIB_SUFFIX}.4.0.0\")\n+   else()\n+      set(LIB_SUFFIX \".dylib\")\n+      set(SOCI_LIB_SYMLINK \".4.0${LIB_SUFFIX}\")\n+      set(SOCI_LIB_SUFFIX \".4.0.0${LIB_SUFFIX}\")\n+   endif()\n+   file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/*${LIB_SUFFIX}\")\n+else()\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/lib\")\n+   if(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Debug/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-debug-${SOCI_ARCH}.lib\")\n+   else()\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Release/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-release-${SOCI_ARCH}.lib\")\n+   endif()\n+endif()\n+list(LENGTH SOCI_LIBRARIES SOCI_LIB_COUNT)\n+\n+if (SOCI_LIB_COUNT EQUAL 0)\n+   message(FATAL_ERROR \"No SOCI libraries found under ${SOCI_LIBRARY_DIR}. Ensure the SOCI dependency is installed and try again.\")\n+else()\n+   message(STATUS \"SOCI libraries found under ${SOCI_LIBRARY_DIR}.\")\n+\n+   # ensure the soci/sqlite/postgres libraries are installed with the installation package\n+   if(UNIX)\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_core${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_sqlite3${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_postgresql${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+\n+      GET_PREREQUISITES(\"${SOCI_LIBRARY_DIR}/libsoci_sqlite3${SOCI_LIB_SUFFIX}\" SQLITE_LIBS \"0\" \"0\" \".\" \"\")\n+      foreach(LIBRARY IN LISTS SQLITE_LIBS)\n+         string(FIND \"${LIBRARY}\" \"libsqlite3\" INDEX)\n+         if(INDEX GREATER \"-1\")\n+            set(SQLITE_LIB \"${LIBRARY}\")\n+         endif()\n+      endforeach(LIBRARY)\n+\n+      GET_PREREQUISITES(\"${SOCI_LIBRARY_DIR}/libsoci_postgresql${SOCI_LIB_SUFFIX}\" POSTGRES_LIBS \"0\" \"0\" \".\" \"\")\n+      foreach(LIBRARY IN LISTS POSTGRES_LIBS)\n+         string(FIND \"${LIBRARY}\" \"libpq\" INDEX)\n+         if(INDEX GREATER \"-1\")\n+            set(POSTGRES_LIB \"${LIBRARY}\")\n+         endif()\n+      endforeach(LIBRARY)\n+\n+      get_filename_component(SQLITE_LIB \"${SQLITE_LIB}\" REALPATH)\n+      get_filename_component(POSTGRES_LIB \"${POSTGRES_LIB}\" REALPATH)\n+      message(STATUS \"SQLite lib: ${SQLITE_LIB}\")\n+      message(STATUS \"PostgreSQL lib: ${POSTGRES_LIB}\")\n+      install(PROGRAMS \"${SQLITE_LIB}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${POSTGRES_LIB}\" DESTINATION ${RSTUDIO_INSTALL_BIN})", "originalCommit": "ac749e316dbc2ab48842f19646e43301acb7c41e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4Nzc0Nw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386487747", "bodyText": "Good catch, will add!", "author": "kfeinauer", "createdAt": "2020-03-02T16:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MjY0MA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385962640", "bodyText": "Will we need to worry about queries which include ; as part of e.g. strings or something similar?", "author": "kevinushey", "createdAt": "2020-02-28T23:07:05Z", "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,635 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::split(queries, queryStr, boost::is_any_of(\";\"));", "originalCommit": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU1MDU1OA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386550558", "bodyText": "Yes, this is a good point. My next commit will fix this by using regex_split", "author": "kfeinauer", "createdAt": "2020-03-02T17:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MjY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MzU3MQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385963571", "bodyText": "This seems useful enough to factor into a helper function somewhere (IIRC we need to ensure 0600 permissions on a variety of files like this)", "author": "kevinushey", "createdAt": "2020-02-28T23:11:13Z", "path": "src/cpp/server_core/ServerDatabase.cpp", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * ServerDatabase.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <server_core/ServerDatabase.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/thread.hpp>\n+\n+#include <core/Log.hpp>\n+#include <core/Settings.hpp>\n+#include <core/system/Environment.hpp>\n+#include <core/system/System.hpp>\n+#include <shared_core/Error.hpp>\n+\n+namespace rstudio {\n+namespace server_core {\n+namespace database {\n+\n+using namespace core;\n+using namespace core::database;\n+\n+namespace {\n+\n+// settings constants\n+constexpr const char* kDatabaseProvider = \"provider\";\n+constexpr const char* kDatabaseProviderSqlite = \"sqlite\";\n+constexpr const char* kDatabaseProviderPostgresql = \"postgresql\";\n+constexpr const char* kSqliteDatabaseDirectory = \"directory\";\n+constexpr const char* kDefaultSqliteDatabaseDirectory = \"/var/run/rstudio-server\";\n+constexpr const char* kDatabaseHost = \"host\";\n+constexpr const char* kDefaultDatabaseHost = \"localhost\";\n+constexpr const char* kDatabasePort = \"port\";\n+constexpr const char* kDefaultPostgresqlDatabasePort = \"5432\";\n+constexpr const char* kDatabaseUser = \"user\";\n+constexpr const char* kDefaultPostgresqlDatabaseUser = \"postgres\";\n+constexpr const char* kDatabasePassword = \"password\";\n+constexpr const char* kPostgresqlDatabaseConnectionTimeoutSeconds = \"connnection-timeout-seconds\";\n+constexpr const int   kDefaultPostgresqlDatabaseConnectionTimeoutSeconds = 10;\n+\n+// environment variables\n+constexpr const char* kServerTmpDirEnvVar = \"RS_SERVER_TMP_DIR\";\n+constexpr const char* kDatabaseMigrationsPathEnvVar = \"RS_DB_MIGRATIONS_PATH\";\n+\n+//misc constants\n+constexpr const size_t kDefaultConnectionPoolSize = 4;\n+\n+boost::shared_ptr<ConnectionPool> s_connectionPool;\n+\n+Error readOptions(ConnectionOptions* pOptions)\n+{\n+   FilePath optionsFile(\"/etc/rstudio/database.conf\");\n+   if (optionsFile.exists())\n+   {\n+      // the database configuration file can potentially contain sensitive information\n+      // log a warning if permissions are too lax\n+      FileMode fileMode;\n+      Error error = optionsFile.getFileMode(fileMode);\n+      if (error)\n+      {\n+         LOG_ERROR_MESSAGE(\"Could not determine file permissions for database configuration file: \" +", "originalCommit": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU1NzEwMg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386557102", "bodyText": "I think this really depends on what you want to do with the file / what you want to log, whether or not you want to exit to make this really generic. The real meat of it is in getFileMode at any rate. Will leave this unresolved to solicit feedback from others. If there's more desire to make a utility function for this, I can attempt to do so!", "author": "kfeinauer", "createdAt": "2020-03-02T18:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MzU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NDQzMA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385964430", "bodyText": "Does rserver still exit gracefully with this static variable?", "author": "kevinushey", "createdAt": "2020-02-28T23:14:42Z", "path": "src/cpp/server_core/ServerDatabase.cpp", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * ServerDatabase.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <server_core/ServerDatabase.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/thread.hpp>\n+\n+#include <core/Log.hpp>\n+#include <core/Settings.hpp>\n+#include <core/system/Environment.hpp>\n+#include <core/system/System.hpp>\n+#include <shared_core/Error.hpp>\n+\n+namespace rstudio {\n+namespace server_core {\n+namespace database {\n+\n+using namespace core;\n+using namespace core::database;\n+\n+namespace {\n+\n+// settings constants\n+constexpr const char* kDatabaseProvider = \"provider\";\n+constexpr const char* kDatabaseProviderSqlite = \"sqlite\";\n+constexpr const char* kDatabaseProviderPostgresql = \"postgresql\";\n+constexpr const char* kSqliteDatabaseDirectory = \"directory\";\n+constexpr const char* kDefaultSqliteDatabaseDirectory = \"/var/run/rstudio-server\";\n+constexpr const char* kDatabaseHost = \"host\";\n+constexpr const char* kDefaultDatabaseHost = \"localhost\";\n+constexpr const char* kDatabasePort = \"port\";\n+constexpr const char* kDefaultPostgresqlDatabasePort = \"5432\";\n+constexpr const char* kDatabaseUser = \"user\";\n+constexpr const char* kDefaultPostgresqlDatabaseUser = \"postgres\";\n+constexpr const char* kDatabasePassword = \"password\";\n+constexpr const char* kPostgresqlDatabaseConnectionTimeoutSeconds = \"connnection-timeout-seconds\";\n+constexpr const int   kDefaultPostgresqlDatabaseConnectionTimeoutSeconds = 10;\n+\n+// environment variables\n+constexpr const char* kServerTmpDirEnvVar = \"RS_SERVER_TMP_DIR\";\n+constexpr const char* kDatabaseMigrationsPathEnvVar = \"RS_DB_MIGRATIONS_PATH\";\n+\n+//misc constants\n+constexpr const size_t kDefaultConnectionPoolSize = 4;\n+\n+boost::shared_ptr<ConnectionPool> s_connectionPool;", "originalCommit": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4OTUxOQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386489519", "bodyText": "Yes, any thread that could hold a reference to this will be stopped before it exits.", "author": "kfeinauer", "createdAt": "2020-03-02T16:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NDQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NDg3Mg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385964872", "bodyText": "I'd remove this and just ask users to reference the admin guide, as this could become stale as new databases are supported.", "author": "kevinushey", "createdAt": "2020-02-28T23:16:25Z", "path": "src/cpp/server/extras/conf/database.conf", "diffHunk": "@@ -0,0 +1,34 @@\n+# This file contains database configuration.\n+#\n+# RStudio Server needs an external database for storage of specific configuration and runtime information.\n+# At present, SQLite and PostgreSQL databases are supported.", "originalCommit": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NjcxNQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386496715", "bodyText": "I'm not overly worried about adding support for new databases and this becoming stale. We match feature parity with Connect, which has only had support for SQLite and PostgreSQL for some time now. I think at best, we'd add support for ODBC (which essentially adds support for all databases).\nAlso, it is common to provide such easy-to-change configurations for pro installations, so figured we'd just add this here since we will likely want an install for pro.", "author": "kfeinauer", "createdAt": "2020-03-02T16:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NDg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5ODIxMQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386498211", "bodyText": "I think I misunderstood your comment - I think you were suggesting we just take out line 4? I can make that change!", "author": "kfeinauer", "createdAt": "2020-03-02T16:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NDg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NTM4Mw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385965383", "bodyText": "Does this still work even with our copy of Boost? (a bit surprised it does since we do the extra symbol namespacing work for the bundles of Boost we build)", "author": "kevinushey", "createdAt": "2020-02-28T23:18:30Z", "path": "dependencies/common/install-soci", "diffHunk": "@@ -0,0 +1,64 @@\n+#!/usr/bin/env bash\n+\n+#\n+# install-soci\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+set -e\n+\n+# install dir \n+INSTALL_DIR=`pwd`\n+\n+# vars\n+BOOST_VERSION=\"1_69_0\"\n+RSTUDIO_TOOLS_DIR=/opt/rstudio-tools\n+SOCI_DIR=$RSTUDIO_TOOLS_DIR/soci\n+SOCI_BIN_DIR=$SOCI_DIR/build\n+SOCI_BRANCH=release/4.0\n+BOOST_DIR=\"$RSTUDIO_TOOLS_DIR/boost/boost_$BOOST_VERSION\"\n+\n+# install SOCI if it isn't already installed\n+if ! ls $SOCI_BIN_DIR/lib/libsoci_core* &> /dev/null\n+then\n+   cd $RSTUDIO_TOOLS_DIR\n+\n+   # download SOCI from source\n+   if ! [ -d \"$SOCI_DIR\" ]\n+   then\n+      git clone git://github.com/SOCI/soci.git\n+   fi\n+   cd $SOCI_DIR\n+\n+   # checkout desired soci branch (version pinned)\n+   git checkout \"$SOCI_BRANCH\"  \n+\n+   # make build directory\n+   mkdir -p $SOCI_BIN_DIR\n+   cd $SOCI_BIN_DIR\n+\n+   # create symlink to our boost datetime library so it is properly discovered by the SOCI build\n+   ln -sf \"$BOOST_DIR/lib/libboost_date_time.a\" \"$BOOST_DIR/lib/rstudio_boost_date_time.a\"", "originalCommit": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MDM3Nw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386490377", "bodyText": "Yes, this is what that was tested against (whatever boost we install via install-dependencies). This was required to compile with boost support.", "author": "kfeinauer", "createdAt": "2020-03-02T16:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NjY1OA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385966658", "bodyText": "Do we need to sanitize any of these strings? (I guess in theory these are only ever read from a config file, which should be considered safe / trusted but worth confirming this is true.)", "author": "kevinushey", "createdAt": "2020-02-28T23:23:17Z", "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,635 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");", "originalCommit": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MDkwMA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386490900", "bodyText": "I don't think so. Like you said, this is coming from a trusted source and PostgreSQL is also picky about what strings it accepts in a connection string.", "author": "kfeinauer", "createdAt": "2020-03-02T16:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NjY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NzEzMA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385967130", "bodyText": "I'm not as familiar on what the best practices are re: database updates + schema versioning. Do you have any recommended resources for getting better acquainted?", "author": "kevinushey", "createdAt": "2020-02-28T23:25:25Z", "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,635 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::split(queries, queryStr, boost::is_any_of(\";\"));\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                              Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available\n+   boost::shared_ptr<Connection> connection;\n+   connections_.deque(&connection, boost::posix_time::pos_infin);\n+\n+   // create wrapper PooledConnection around retrieved Connection\n+   return boost::shared_ptr<IConnection>(new PooledConnection(shared_from_this(), connection));\n+}\n+\n+void ConnectionPool::returnConnection(const boost::shared_ptr<Connection>& connection)\n+{\n+   connections_.enque(connection);\n+}\n+\n+Transaction::Transaction(const boost::shared_ptr<IConnection>& connection) :\n+   connection_(connection),\n+   transaction_(connection->session())\n+{\n+}\n+\n+void Transaction::commit()\n+{\n+   transaction_.commit();\n+}\n+\n+void Transaction::rollback()\n+{\n+   transaction_.rollback();\n+}\n+\n+SchemaUpdater::SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                             const FilePath& migrationsPath) :\n+   connection_(connection),\n+   migrationsPath_(migrationsPath)\n+{\n+}\n+\n+Error SchemaUpdater::migrationFiles(std::vector<FilePath>* pMigrationFiles)\n+{\n+   std::vector<FilePath> children;\n+   Error error = migrationsPath_.getChildren(children);\n+   if (error)\n+      return error;\n+\n+   for (const FilePath& file : children)\n+   {\n+      std::string extension = file.getExtensionLowerCase();\n+      if (extension == SQL_EXTENSION ||\n+          extension == SQLITE_EXTENSION ||\n+          extension == POSTGRESQL_EXTENSION)\n+      {\n+         pMigrationFiles->push_back(file);\n+      }\n+   }\n+\n+   return Success();\n+}\n+\n+Error SchemaUpdater::highestMigrationVersion(std::string* pVersion)\n+{\n+   std::vector<FilePath> files;\n+   Error error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   if (files.empty())\n+   {\n+      // no migration files - we do not consider this an error, but instead\n+      // simply consider that this database cannot be migrated past version 0\n+      *pVersion = \"0\";\n+      return Success();\n+   }\n+\n+   // sort descending - highest version filename wins\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() > b.getStem();\n+   };\n+   std::sort(files.begin(), files.end(), comparator);\n+\n+   *pVersion = files.at(0).getStem();\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isSchemaVersionPresent(bool* pIsPresent)\n+{\n+   std::string queryStr;\n+   if (connection_->driverName() == SQLITE_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM sqlite_master WHERE type='table' AND name='\") + SCHEMA_TABLE + \"'\";\n+   }\n+   else if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM information_schema.tables WHERE table_name='\") + SCHEMA_TABLE +\n+                 \"' AND table_schema = current_schema\";\n+   }\n+   else\n+   {\n+      return DatabaseError(soci::soci_error(\"Unsupported database driver\"));\n+   }\n+\n+   int count = 0;\n+   Query query = connection_->query(queryStr)\n+         .withOutput(count);\n+   Error error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pIsPresent = count > 0;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::databaseSchemaVersion(std::string* pVersion)\n+{\n+   bool versionPresent = false;\n+   Error error = isSchemaVersionPresent(&versionPresent);\n+   if (error)\n+      return error;\n+\n+   std::string currentSchemaVersion = \"0\";\n+   if (!versionPresent)\n+   {\n+      // no schema version present - add the table to the database so it is available\n+      // for updating whenever migrations occur\n+      error = connection_->executeStr(std::string(\"CREATE TABLE \") + SCHEMA_TABLE + \"(current_version text)\");\n+      if (error)\n+         return error;\n+\n+      Query query = connection_->query(std::string(\"INSERT INTO \") + SCHEMA_TABLE + \" VALUES (:val)\")\n+            .withInput(currentSchemaVersion);\n+      error = connection_->execute(query);\n+      if (error)\n+         return error;\n+\n+      *pVersion = currentSchemaVersion;\n+      return Success();\n+   }\n+\n+   Query query = connection_->query(std::string(\"SELECT current_version FROM \") + SCHEMA_TABLE)\n+         .withOutput(currentSchemaVersion);\n+\n+   error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pVersion = currentSchemaVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isUpToDate(bool* pUpToDate)\n+{\n+   std::string version;\n+   Error error = databaseSchemaVersion(&version);\n+   if (error)\n+      return error;\n+\n+   std::string migrationVersion;\n+   error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   *pUpToDate = version >= migrationVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::update()\n+{\n+   std::string migrationVersion;\n+   Error error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   std::string currentVersion;\n+   error = databaseSchemaVersion(&currentVersion);\n+   if (currentVersion < migrationVersion)\n+      return updateToVersion(migrationVersion);\n+   else\n+      return Success();\n+}\n+\n+Error SchemaUpdater::updateToVersion(const std::string& maxVersion)", "originalCommit": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MjIwOQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386492209", "bodyText": "This was pretty much taken from Connect's implementation: https://github.com/rstudio/connect/blob/master/src/connect/store/version.go#L261-L345\nThis is similar to how many popular tools do things as well. See https://flywaydb.org/documentation/migrations", "author": "kfeinauer", "createdAt": "2020-03-02T16:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NzEzMA=="}], "type": "inlineReview"}, {"oid": "50194adcba2d3a866ba740dfda598e9a0a6a9997", "url": "https://github.com/rstudio/rstudio/commit/50194adcba2d3a866ba740dfda598e9a0a6a9997", "message": "Code review feedback", "committedDate": "2020-03-02T16:17:35Z", "type": "commit"}, {"oid": "54da3323e95898c0149a32c909f2de06f9e618ff", "url": "https://github.com/rstudio/rstudio/commit/54da3323e95898c0149a32c909f2de06f9e618ff", "message": "Code review feedback", "committedDate": "2020-03-02T16:24:16Z", "type": "commit"}, {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "url": "https://github.com/rstudio/rstudio/commit/d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "message": "Code review feedback - add support for nested ; within multi-query strings", "committedDate": "2020-03-02T17:59:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMzYzNg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386633636", "bodyText": "Should this file (and some of the others that were added for installing DB dependencies) have a copyright comment at the top?", "author": "MariaSemple", "createdAt": "2020-03-02T20:32:20Z", "path": "dependencies/windows/install-soci/install-soci.R", "diffHunk": "@@ -0,0 +1,97 @@\n+# some laziness to ensure we move to the 'install-crashpad' folder", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNTExOA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387325118", "bodyText": "It seems none of the other dependency install scripts have the copyright header for whatever reason, so this just follows that pattern.", "author": "kfeinauer", "createdAt": "2020-03-03T22:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMzYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyODE2Mg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386728162", "bodyText": "Does this regex prevent splitting on ; characters within literal strings? For example SELECT * FROM Users WHERE User.name LIKE '%;%'; ? It looks to me like it might cut off the last part of the query and cause syntax errors, but it also might not be an issue if no part of our queries are from user generated values.", "author": "MariaSemple", "createdAt": "2020-03-03T00:13:01Z", "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,638 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNTgyOA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387325828", "bodyText": "Correct, this explicitly will not split on that, it will split on only the very last ;, because the regex requires newline after the ;.", "author": "kfeinauer", "createdAt": "2020-03-03T22:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyODE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzMjkwNA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387332904", "bodyText": "Ah, I think that makes sense since we'll never get a full query (or set of multiple queries) from the user directly - just values for filtering or inserting, right? Can it (or does it need to) support ;  followed by \\\\n within the literal filter data?", "author": "MariaSemple", "createdAt": "2020-03-03T22:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyODE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0NTA0OQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387345049", "bodyText": "I really don't think we need to support that. This is only for schema update queries - it's not ever going to be 100% perfect (without vastly overcomplicating this code). I think as written is good enough - this isn't user hardened, it only needs to work for our particular crafted queries in our migration scripts, which I think should pretty much have us covered 100%.", "author": "kfeinauer", "createdAt": "2020-03-03T22:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyODE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyODY3Nw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386728677", "bodyText": "Nit: alignment is off here.", "author": "MariaSemple", "createdAt": "2020-03-03T00:14:43Z", "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,638 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                              Rowset& rowset)", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNDI5Ng==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386734296", "bodyText": "Does the transaction need to be rolled back before returning here (and elsewhere), or will it automatically roll back on destruction?", "author": "MariaSemple", "createdAt": "2020-03-03T00:33:18Z", "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,638 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                              Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available\n+   boost::shared_ptr<Connection> connection;\n+   connections_.deque(&connection, boost::posix_time::pos_infin);\n+\n+   // create wrapper PooledConnection around retrieved Connection\n+   return boost::shared_ptr<IConnection>(new PooledConnection(shared_from_this(), connection));\n+}\n+\n+void ConnectionPool::returnConnection(const boost::shared_ptr<Connection>& connection)\n+{\n+   connections_.enque(connection);\n+}\n+\n+Transaction::Transaction(const boost::shared_ptr<IConnection>& connection) :\n+   connection_(connection),\n+   transaction_(connection->session())\n+{\n+}\n+\n+void Transaction::commit()\n+{\n+   transaction_.commit();\n+}\n+\n+void Transaction::rollback()\n+{\n+   transaction_.rollback();\n+}\n+\n+SchemaUpdater::SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                             const FilePath& migrationsPath) :\n+   connection_(connection),\n+   migrationsPath_(migrationsPath)\n+{\n+}\n+\n+Error SchemaUpdater::migrationFiles(std::vector<FilePath>* pMigrationFiles)\n+{\n+   std::vector<FilePath> children;\n+   Error error = migrationsPath_.getChildren(children);\n+   if (error)\n+      return error;\n+\n+   for (const FilePath& file : children)\n+   {\n+      std::string extension = file.getExtensionLowerCase();\n+      if (extension == SQL_EXTENSION ||\n+          extension == SQLITE_EXTENSION ||\n+          extension == POSTGRESQL_EXTENSION)\n+      {\n+         pMigrationFiles->push_back(file);\n+      }\n+   }\n+\n+   return Success();\n+}\n+\n+Error SchemaUpdater::highestMigrationVersion(std::string* pVersion)\n+{\n+   std::vector<FilePath> files;\n+   Error error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   if (files.empty())\n+   {\n+      // no migration files - we do not consider this an error, but instead\n+      // simply consider that this database cannot be migrated past version 0\n+      *pVersion = \"0\";\n+      return Success();\n+   }\n+\n+   // sort descending - highest version filename wins\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() > b.getStem();\n+   };\n+   std::sort(files.begin(), files.end(), comparator);\n+\n+   *pVersion = files.at(0).getStem();\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isSchemaVersionPresent(bool* pIsPresent)\n+{\n+   std::string queryStr;\n+   if (connection_->driverName() == SQLITE_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM sqlite_master WHERE type='table' AND name='\") + SCHEMA_TABLE + \"'\";\n+   }\n+   else if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM information_schema.tables WHERE table_name='\") + SCHEMA_TABLE +\n+                 \"' AND table_schema = current_schema\";\n+   }\n+   else\n+   {\n+      return DatabaseError(soci::soci_error(\"Unsupported database driver\"));\n+   }\n+\n+   int count = 0;\n+   Query query = connection_->query(queryStr)\n+         .withOutput(count);\n+   Error error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pIsPresent = count > 0;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::databaseSchemaVersion(std::string* pVersion)\n+{\n+   bool versionPresent = false;\n+   Error error = isSchemaVersionPresent(&versionPresent);\n+   if (error)\n+      return error;\n+\n+   std::string currentSchemaVersion = \"0\";\n+   if (!versionPresent)\n+   {\n+      // no schema version present - add the table to the database so it is available\n+      // for updating whenever migrations occur\n+      error = connection_->executeStr(std::string(\"CREATE TABLE \") + SCHEMA_TABLE + \"(CurrentVersion text)\");\n+      if (error)\n+         return error;\n+\n+      Query query = connection_->query(std::string(\"INSERT INTO \") + SCHEMA_TABLE + \" VALUES (:val)\")\n+            .withInput(currentSchemaVersion);\n+      error = connection_->execute(query);\n+      if (error)\n+         return error;\n+\n+      *pVersion = currentSchemaVersion;\n+      return Success();\n+   }\n+\n+   Query query = connection_->query(std::string(\"SELECT CurrentVersion FROM \") + SCHEMA_TABLE)\n+         .withOutput(currentSchemaVersion);\n+\n+   error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pVersion = currentSchemaVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isUpToDate(bool* pUpToDate)\n+{\n+   std::string version;\n+   Error error = databaseSchemaVersion(&version);\n+   if (error)\n+      return error;\n+\n+   std::string migrationVersion;\n+   error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   *pUpToDate = version >= migrationVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::update()\n+{\n+   std::string migrationVersion;\n+   Error error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   std::string currentVersion;\n+   error = databaseSchemaVersion(&currentVersion);\n+   if (currentVersion < migrationVersion)\n+      return updateToVersion(migrationVersion);\n+   else\n+      return Success();\n+}\n+\n+Error SchemaUpdater::updateToVersion(const std::string& maxVersion)\n+{\n+   // create a transaction to perform the following steps:\n+   // 1. Check the current database schema version\n+   // 2. Check if we need to update\n+   // 3. Update (if necessary)\n+   // 4. Save new database schema version\n+   // performing this in a transaction ensures that we rollback if anything\n+   // fails, and also ensures that other nodes cannot update concurrently\n+   Transaction transaction(connection_);\n+\n+   // for postgresql, specifically lock the version table in exclusive mode\n+   // to ensure that no other connection can use the version table AT ALL\n+   // during this schema update\n+   if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      Query query = connection_->query(std::string(\"LOCK \") + SCHEMA_TABLE + \" IN ACCESS EXCLUSIVE MODE\");\n+      Error error = connection_->execute(query);\n+      if (error)\n+         return error;", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNjA4NA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387326084", "bodyText": "The transaction automatically rolls back in the destructor of the Transaction object.", "author": "kfeinauer", "createdAt": "2020-03-03T22:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNDI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2MzA3Mw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386763073", "bodyText": "Does returning here prevent the rest of the tests from running?", "author": "MariaSemple", "createdAt": "2020-03-03T02:14:42Z", "path": "src/cpp/core/DatabaseTests.cpp", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * DatabaseTests.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <tests/TestThat.hpp>\n+\n+#include <core/Database.hpp>\n+#include <core/FileSerializer.hpp>\n+#include <core/system/System.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/boost-tuple.h>\n+#include <soci/session.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+namespace rstudio {\n+namespace unit_tests {\n+\n+using namespace core;\n+using namespace core::database;\n+\n+core::database::SqliteConnectionOptions sqliteConnectionOptions()\n+{\n+   return SqliteConnectionOptions { \"/tmp/rstudio-test-db\" };\n+}\n+\n+core::database::PostgresqlConnectionOptions postgresConnectionOptions()\n+{\n+   PostgresqlConnectionOptions options;\n+   options.connectionTimeoutSeconds = 10;\n+   options.database = \"rstudio-test\";\n+   options.host = \"localhost\";\n+   options.user = \"postgres\";\n+   options.password = \"postgres\";\n+\n+   return options;\n+}\n+\n+TEST_CASE(\"Database\", \"[.database]\")\n+{\n+   test_that(\"Test Setup\")\n+   {\n+      // ensure that the test databases do not exist\n+      FilePath sqliteDbPath(\"/tmp/rstudio-test-db\");\n+      sqliteDbPath.removeIfExists();\n+\n+      boost::shared_ptr<IConnection> connection;\n+      Error error = connect(postgresConnectionOptions(), &connection);\n+      if (error)\n+         return;", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNjMyOA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387326328", "bodyText": "Yes, and that is intended - if the test database cannot be connected to, we won't run the tests. This is also okay because these tests are never run automatically.", "author": "kfeinauer", "createdAt": "2020-03-03T22:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2MzA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzMTYzMg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387331632", "bodyText": "Yeah, that makes sense. I just wasn't sure if a return exits the whole test case or just the test_that section.", "author": "MariaSemple", "createdAt": "2020-03-03T22:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2MzA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NDU2Mg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386764562", "bodyText": "What do you think about adding a test case for unusual characters on inserts or filters? Like \\ or ; in usernames or other fields?", "author": "MariaSemple", "createdAt": "2020-03-03T02:20:56Z", "path": "src/cpp/core/DatabaseTests.cpp", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * DatabaseTests.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <tests/TestThat.hpp>\n+\n+#include <core/Database.hpp>\n+#include <core/FileSerializer.hpp>\n+#include <core/system/System.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/boost-tuple.h>\n+#include <soci/session.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+namespace rstudio {\n+namespace unit_tests {\n+\n+using namespace core;\n+using namespace core::database;\n+\n+core::database::SqliteConnectionOptions sqliteConnectionOptions()\n+{\n+   return SqliteConnectionOptions { \"/tmp/rstudio-test-db\" };\n+}\n+\n+core::database::PostgresqlConnectionOptions postgresConnectionOptions()\n+{\n+   PostgresqlConnectionOptions options;\n+   options.connectionTimeoutSeconds = 10;\n+   options.database = \"rstudio-test\";\n+   options.host = \"localhost\";\n+   options.user = \"postgres\";\n+   options.password = \"postgres\";\n+\n+   return options;\n+}\n+\n+TEST_CASE(\"Database\", \"[.database]\")\n+{\n+   test_that(\"Test Setup\")\n+   {\n+      // ensure that the test databases do not exist\n+      FilePath sqliteDbPath(\"/tmp/rstudio-test-db\");\n+      sqliteDbPath.removeIfExists();\n+\n+      boost::shared_ptr<IConnection> connection;\n+      Error error = connect(postgresConnectionOptions(), &connection);\n+      if (error)\n+         return;\n+\n+      std::string queryStr =\n+         R\"\"(\n+         DROP SCHEMA public CASCADE;\n+         CREATE SCHEMA public;\n+         GRANT ALL ON SCHEMA public TO postgres;\n+         GRANT ALL ON SCHEMA public TO public;\n+         )\"\";\n+\n+      connection->executeStr(queryStr);\n+   }\n+\n+   test_that(\"Can create SQLite database\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      Query query = connection->query(\"create table Test(id int, text varchar(255))\");\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      int id = 10;\n+      std::string text = \"Hello, database!\";\n+\n+      query = connection->query(\"insert into Test(id, text) values(:id, :text)\")\n+            .withInput(id)\n+            .withInput(text);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      boost::tuple<int, std::string> row;\n+      query = connection->query(\"select id, text from Test where id = (:id)\")\n+            .withInput(id)\n+            .withOutput(row);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      CHECK(row.get<0>() == id);\n+      CHECK(row.get<1>() == text);\n+   }\n+\n+   test_that(\"Can create PostgreSQL database\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(postgresConnectionOptions(), &connection));\n+\n+      Query query = connection->query(\"create table Test(id int, text varchar(255))\");\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      int id = 10;\n+      std::string text = \"Hello, database!\";\n+\n+      query = connection->query(\"insert into Test(id, text) values(:id, :text)\")\n+            .withInput(id)\n+            .withInput(text);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      boost::tuple<int, std::string> row;\n+      query = connection->query(\"select id, text from Test where id = (:id)\")\n+            .withInput(id)\n+            .withOutput(row);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      CHECK(row.get<0>() == id);\n+      CHECK(row.get<1>() == text);\n+   }\n+\n+   test_that(\"Can perform transactions\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      Transaction transaction(connection);\n+      int numFailed = 0;\n+      bool dataReturned = false;\n+\n+      // verify that we can commit a transaction\n+      Query query = connection->query(\"insert into Test(id, text) values(:id, :text)\");\n+      for (int id = 0; id < 100; ++id)\n+      {\n+         std::string text = \"Test text \" + core::safe_convert::numberToString(id);\n+         query.withInput(id).withInput(text);\n+\n+         if (connection->execute(query))\n+            ++numFailed;\n+      }\n+\n+      REQUIRE(numFailed == 0);\n+      transaction.commit();\n+\n+      boost::tuple<int, std::string> row;\n+      query = connection->query(\"select id, text from Test where id = 50\")\n+            .withOutput(row);\n+\n+      REQUIRE_FALSE(connection->execute(query, &dataReturned));\n+      REQUIRE(dataReturned);\n+      REQUIRE(row.get<0>() == 50);\n+      REQUIRE(row.get<1>() == \"Test text 50\");\n+\n+      // now attempt to rollback a transaction\n+      Transaction transaction2(connection);\n+      query = connection->query(\"insert into Test(id, text) values(:id, :text)\");\n+      for (int id = 100; id < 200; ++id)\n+      {\n+         std::string text = \"Test text \" + core::safe_convert::numberToString(id);\n+         query.withInput(id).withInput(text);\n+\n+         if (connection->execute(query))\n+            ++numFailed;\n+      }\n+\n+      REQUIRE(numFailed == 0);\n+      transaction2.rollback();\n+\n+      query = connection->query(\"select id, text from Test where id = 150\")\n+            .withOutput(row);\n+\n+      // expect no data\n+      REQUIRE_FALSE(connection->execute(query, &dataReturned));\n+      REQUIRE_FALSE(dataReturned);\n+   }\n+\n+   test_that(\"Can bulk select\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      Rowset rows;\n+      Query query = connection->query(\"select id, text from Test where id >= 50 and id <= 100\");\n+      REQUIRE_FALSE(connection->execute(query, rows));\n+\n+      int i = 0;\n+      for (RowsetIterator it = rows.begin(); it != rows.end(); ++it)\n+      {\n+         Row& row = *it;\n+         REQUIRE(row.get<int>(0) == i + 50);\n+         REQUIRE(row.get<std::string>(1) == \"Test text \" + safe_convert::numberToString(i+50));\n+         ++i;\n+      }\n+   }\n+\n+   test_that(\"Can bulk insert\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      std::vector<int> rowIds {1000, 2000, 3000, 4000, 5000};\n+      std::vector<std::string> rowTexts {\"1000\", \"2000\", \"3000\", \"4000\", \"5000\"};\n+\n+      Query query = connection->query(\"insert into Test values (:id, :txt)\")\n+            .withInput(rowIds)\n+            .withInput(rowTexts);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      Query selectQuery = connection->query(\"select * from Test where id >= 1000\");\n+\n+      Rowset rowset;\n+      REQUIRE_FALSE(connection->execute(selectQuery, rowset));\n+      int i = 1;\n+      for (RowsetIterator it = rowset.begin(); it != rowset.end(); ++it)\n+      {\n+         Row& row = *it;\n+         REQUIRE(row.get<int>(0) == i * 1000);\n+         REQUIRE(row.get<std::string>(1) == safe_convert::numberToString(i*1000));\n+         ++i;\n+      }\n+   }\n+\n+   test_that(\"Can use connection pool\")\n+   {\n+      boost::shared_ptr<ConnectionPool> connectionPool;\n+      REQUIRE_FALSE(createConnectionPool(5, sqliteConnectionOptions(), &connectionPool));\n+\n+      boost::shared_ptr<IConnection> connection = connectionPool->getConnection();\n+      boost::tuple<int, std::string> row;\n+      Query query = connection->query(\"select id, text from Test where id = 50\")\n+            .withOutput(row);\n+\n+      bool dataReturned = false;\n+      REQUIRE_FALSE(connection->execute(query, &dataReturned));\n+      REQUIRE(dataReturned);\n+\n+      boost::shared_ptr<IConnection> connection2 = connectionPool->getConnection();\n+      Query query2 = connection2->query(\"select id, text from Test where id = 25\")\n+            .withOutput(row);\n+\n+      dataReturned = false;\n+      REQUIRE_FALSE(connection2->execute(query2, &dataReturned));\n+      REQUIRE(dataReturned);\n+   }\n+\n+   test_that(\"Can update schemas\")\n+   {\n+      // generate some schema files\n+      std::string schema1 =\n+         R\"\"(\n+         CREATE TABLE TestTable1_Persons(\n+            id int NOT NULL,\n+            first_name varchar(255),\n+            last_name varchar(255) NOT NULL,\n+            email_address varchar(255)\n+         );\n+\n+         CREATE TABLE TestTable2_AccountHolders(\n+            id int,\n+            fk_person_id int\n+         );\n+         )\"\";\n+\n+      // sqlite cannot alter tables very well, so adding constraints necessitates dropping\n+      // and re-creating the tables\n+      std::string schema2Sqlite =\n+         R\"\"(\n+         CREATE TABLE TestTable1_Persons_new(\n+            id int NOT NULL,\n+            first_name varchar(255),\n+            last_name varchar(255),\n+            email_address varchar(255),\n+            PRIMARY KEY (id)\n+         );\n+\n+         DROP TABLE TestTable1_Persons;\n+         ALTER TABLE TestTable1_Persons_new RENAME TO TestTable1_Persons;\n+\n+         CREATE TABLE TestTable2_AccountHolders_new(\n+            id int,\n+            fk_person_id int,\n+            PRIMARY KEY (id),\n+            FOREIGN KEY (fk_person_id) REFERENCES TestTable1_Persons(id)\n+         );\n+\n+         DROP TABLE TestTable2_AccountHolders;\n+         ALTER TABLE TestTable2_AccountHolders_new RENAME TO TestTable2_AccountHolders;\n+         )\"\";\n+\n+      // postgresql supports modification of tables\n+      std::string schema2Postgresql =\n+         R\"\"(\n+         ALTER TABLE TestTable1_Persons\n+         ADD PRIMARY KEY (id);\n+\n+         ALTER TABLE TestTable2_AccountHolders\n+         ADD PRIMARY KEY (id);\n+\n+         ALTER TABLE TestTable2_AccountHolders\n+         ADD FOREIGN KEY (fk_person_id) REFERENCES TestTable1_Persons(id);\n+         )\"\";\n+\n+      std::string schema3Sqlite =\n+         R\"\"(\n+         CREATE TABLE TestTable2_AccountHolders_new(\n+            id int,\n+            fk_person_id int,\n+            creation_time text,\n+            PRIMARY KEY (id),\n+            FOREIGN KEY (fk_person_id) REFERENCES TestTable1_Persons(id)\n+         );\n+\n+         DROP TABLE TestTable2_AccountHolders;\n+         ALTER TABLE TestTable2_AccountHolders_new RENAME TO TestTable2_AccountHolders;\n+         )\"\";\n+\n+      std::string schema3Postgresql =\n+         R\"\"(\n+         ALTER TABLE TestTable2_AccountHolders\n+         ADD COLUMN creation_time text;\n+         )\"\";\n+\n+      FilePath workingDir = core::system::currentWorkingDir(core::system::currentProcessId());\n+      FilePath outFile1 = workingDir.completeChildPath(\"1_InitialTables.sql\");\n+      FilePath outFile2Sqlite = workingDir.completeChildPath(\"2_ConstraintsForInitialTables.sqlite\");\n+      FilePath outFile2Postgresql = workingDir.completeChildPath(\"2_ConstraintsForInitialTables.postgresql\");\n+      FilePath outFile3Sqlite = workingDir.completeChildPath(\"3_AddAccountCreationTime.sqlite\");\n+      FilePath outFile3Postgresql = workingDir.completeChildPath(\"3_AddAccountCreationTime.postgresql\");\n+\n+      REQUIRE_FALSE(writeStringToFile(outFile1, schema1));\n+      REQUIRE_FALSE(writeStringToFile(outFile2Sqlite, schema2Sqlite));\n+      REQUIRE_FALSE(writeStringToFile(outFile2Postgresql, schema2Postgresql));\n+      REQUIRE_FALSE(writeStringToFile(outFile3Sqlite, schema3Sqlite));\n+      REQUIRE_FALSE(writeStringToFile(outFile3Postgresql, schema3Postgresql));\n+\n+      boost::shared_ptr<IConnection> sqliteConnection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &sqliteConnection));\n+\n+      boost::shared_ptr<IConnection> postgresConnection;\n+      REQUIRE_FALSE(connect(postgresConnectionOptions(), &postgresConnection));\n+\n+      SchemaUpdater sqliteUpdater(sqliteConnection, workingDir);\n+      SchemaUpdater postgresUpdater(postgresConnection, workingDir);\n+\n+      REQUIRE_FALSE(sqliteUpdater.update());\n+      REQUIRE_FALSE(postgresUpdater.update());\n+\n+      std::string currentSchemaVersion;\n+      REQUIRE_FALSE(sqliteUpdater.databaseSchemaVersion(&currentSchemaVersion));\n+      REQUIRE(currentSchemaVersion == \"3_AddAccountCreationTime\");\n+      currentSchemaVersion.clear();\n+      REQUIRE_FALSE(postgresUpdater.databaseSchemaVersion(&currentSchemaVersion));\n+      REQUIRE(currentSchemaVersion == \"3_AddAccountCreationTime\");\n+\n+      // ensure repeated calls to update work without error\n+      REQUIRE_FALSE(sqliteUpdater.update());\n+      REQUIRE_FALSE(postgresUpdater.update());\n+\n+      // ensure we can insert data as expected (given our expected constraints)\n+      int id = 1;\n+      std::string firstName = \"Billy\";\n+      std::string lastName = \"Joel\";\n+      std::string email = \"bjoel@example.com\";\n+      std::string creationTime = \"03/03/2020 12:00:00\";\n+\n+      // create queries - we will be executing them multiple times, so bind input just before execution\n+      Query sqliteInsertQuery = sqliteConnection->query(\"INSERT INTO TestTable1_Persons VALUES (:id, :fname, :lname, :email)\");\n+      Query postgresInsertQuery = postgresConnection->query(\"INSERT INTO TestTable1_Persons VALUES (:id, :fname, :lname, :email)\");\n+      Query sqliteInsertQuery2 = sqliteConnection->query(\"INSERT INTO TestTable2_AccountHolders VALUES (:id, :pid, :time)\");\n+      Query postgresInsertQuery2 = postgresConnection->query(\"INSERT INTO TestTable2_AccountHolders VALUES (:id, :pid, :time)\");\n+\n+      // should fail - FK constraint\n+      sqliteInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      postgresInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK(sqliteConnection->execute(sqliteInsertQuery2));\n+      CHECK(postgresConnection->execute(postgresInsertQuery2));\n+\n+      // should succeed - properly ordered\n+      sqliteInsertQuery\n+            .withInput(id, \"id\")\n+            .withInput(firstName, \"fname\")\n+            .withInput(lastName, \"lname\")\n+            .withInput(email, \"email\");\n+      CHECK_FALSE(sqliteConnection->execute(sqliteInsertQuery));\n+      sqliteInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK_FALSE(sqliteConnection->execute(sqliteInsertQuery2));\n+      postgresInsertQuery\n+            .withInput(id, \"id\")\n+            .withInput(firstName, \"fname\")\n+            .withInput(lastName, \"lname\")\n+            .withInput(email, \"email\");\n+      CHECK_FALSE(postgresConnection->execute(postgresInsertQuery));\n+      postgresInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK_FALSE(postgresConnection->execute(postgresInsertQuery2));\n+\n+      // should fail - PK constraint\n+      sqliteInsertQuery\n+            .withInput(id, \"id\")\n+            .withInput(firstName, \"fname\")\n+            .withInput(lastName, \"lname\")\n+            .withInput(email, \"email\");\n+      CHECK(sqliteConnection->execute(sqliteInsertQuery));\n+      sqliteInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK(sqliteConnection->execute(sqliteInsertQuery2));\n+      postgresInsertQuery\n+            .withInput(id, \"id\")\n+            .withInput(firstName, \"fname\")\n+            .withInput(lastName, \"lname\")\n+            .withInput(email, \"email\");\n+      CHECK(postgresConnection->execute(postgresInsertQuery));\n+      postgresInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK(postgresConnection->execute(postgresInsertQuery2));\n+   }\n+\n+   test_that(\"Can execute str with multiple queries\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      std::string queryStr =\n+            \"CREATE TABLE TestTable_3(\"\n+            \"A text, B text\\n);            \\n\"\n+            \"INSERT INTO TestTable_3 VALUES (\\\"Hello\\\", \\\"World;      \\\");\\n\"\n+            \"INSERT INTO TestTable_3 VALUES (\\\"Hello2\\\", \\\";;;\\\");\";\n+\n+      REQUIRE_FALSE(connection->executeStr(queryStr));\n+\n+      Query selectQuery = connection->query(\"select * from TestTable_3 order by A asc\");\n+\n+      Rowset rowset;\n+      REQUIRE_FALSE(connection->execute(selectQuery, rowset));\n+      int i = 0;\n+      std::string vals[2][2];\n+      vals[0][0] = \"Hello\";\n+      vals[0][1] = \"World;      \";\n+      vals[1][0] = \"Hello2\";\n+      vals[1][1] = \";;;\";\n+      for (RowsetIterator it = rowset.begin(); it != rowset.end(); ++it)\n+      {\n+         Row& row = *it;\n+         REQUIRE(row.get<std::string>(0) == vals[i][0]);\n+         REQUIRE(row.get<std::string>(1) == vals[i][1]);\n+         ++i;\n+      }\n+   }\n+}", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNjkyMw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387326923", "bodyText": "That's actually covered in this particular test case.", "author": "kfeinauer", "createdAt": "2020-03-03T22:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NDU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NTk4Nw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386765987", "bodyText": "Nit: The variable name suggests it updates the schema to no higher than the provided version. Is that the behaviour, or will it always update to exactly the specified version?", "author": "MariaSemple", "createdAt": "2020-03-03T02:26:05Z", "path": "src/cpp/core/include/core/Database.hpp", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Database.hpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#ifndef CORE_DATABASE_HPP\n+#define CORE_DATABASE_HPP\n+\n+#include <core/Thread.hpp>\n+#include <shared_core/FilePath.hpp>\n+\n+#include <boost/optional.hpp>\n+#include <boost/shared_ptr.hpp>\n+#include <boost/variant.hpp>\n+\n+#define SOCI_USE_BOOST 1\n+#include <soci/soci.h>\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+struct SqliteConnectionOptions\n+{\n+   std::string file;\n+};\n+\n+struct PostgresqlConnectionOptions\n+{\n+   std::string database;\n+   std::string host;\n+   std::string port;\n+   std::string user;\n+   std::string password;\n+   int connectionTimeoutSeconds;\n+};\n+\n+typedef boost::variant<SqliteConnectionOptions, PostgresqlConnectionOptions> ConnectionOptions;\n+using InputParameter = soci::details::use_type_ptr;\n+using OutputParameter = soci::details::into_type_ptr;\n+\n+class Connection;\n+class ConnectionPool;\n+class Transaction;\n+\n+class Query\n+{\n+public:\n+   Query(const std::string& sqlStatement,\n+         soci::session& session);\n+\n+   template <typename T>\n+   Query& withInput(const T& val)\n+   {\n+      statement_.exchange(soci::use(val));\n+      return *this;\n+   }\n+\n+   template <typename T>\n+   Query& withInput(const T& val, const std::string& varName)\n+   {\n+      statement_.exchange(soci::use(val, varName));\n+      return *this;\n+   }\n+\n+   template <typename T>\n+   Query& withOutput(T& out)\n+   {\n+      statement_.exchange(soci::into(out));\n+      return *this;\n+   }\n+\n+   template <typename T>\n+   Query& withOutput(T& out, const std::string& varName)\n+   {\n+      statement_.exchange(soci::into(out, varName));\n+      return *this;\n+   }\n+\n+private:\n+   friend class Connection;\n+   friend class Rowset;\n+\n+   soci::statement statement_;\n+   boost::optional<soci::soci_error> prepareError_;\n+};\n+\n+using Row = soci::row;\n+using RowsetIterator = soci::rowset_iterator<Row>;\n+\n+class Rowset\n+{\n+public:\n+   RowsetIterator begin();\n+   RowsetIterator end();\n+\n+private:\n+   friend class Connection;\n+\n+   Row row_;\n+   boost::optional<Query&> query_;\n+};\n+\n+class IConnection\n+{\n+public:\n+   virtual Query query(const std::string& sqlStatement) = 0;\n+\n+   virtual Error execute(Query& query,\n+                         Rowset& rowset) = 0;\n+\n+   virtual Error execute(Query& query,\n+                         bool* pDataReturned = nullptr) = 0;\n+\n+   virtual Error executeStr(const std::string& queryStr) = 0;\n+\n+   virtual std::string driverName() const = 0;\n+\n+   virtual soci::session& session() = 0;\n+};\n+\n+class Connection : public IConnection\n+{\n+public:\n+   virtual ~Connection() {}\n+\n+   Query query(const std::string& sqlStatement) override;\n+\n+   Error execute(Query& query,\n+                 Rowset& rowset) override;\n+\n+   Error execute(Query& query,\n+                 bool* pDataReturned = nullptr) override;\n+\n+   Error executeStr(const std::string& queryStr) override;\n+\n+   std::string driverName() const override;\n+\n+   soci::session& session() override { return session_; }\n+\n+private:\n+   friend class ConnectVisitor;\n+   friend class Transaction;\n+\n+   // private constructor - use global connect function\n+   Connection(const soci::backend_factory& factory,\n+              const std::string& connectionStr);\n+\n+   soci::session session_;\n+};\n+\n+class PooledConnection : public IConnection\n+{\n+public:\n+   virtual ~PooledConnection();\n+\n+   Query query(const std::string& sqlStatement) override;\n+\n+   Error execute(Query& query,\n+                 Rowset& rowset) override;\n+\n+   Error execute(Query& query,\n+                 bool* pDataReturned = nullptr) override;\n+\n+   Error executeStr(const std::string& queryStr) override;\n+\n+   std::string driverName() const override;\n+\n+   soci::session& session() override { return connection_->session(); }\n+\n+private:\n+   friend class ConnectionPool;\n+\n+   // private constructor - get PooledConnection from ConnectionPool\n+   PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                    const boost::shared_ptr<Connection>& connection);\n+\n+   boost::shared_ptr<ConnectionPool> pool_;\n+   boost::shared_ptr<Connection> connection_;\n+};\n+\n+class ConnectionPool : public boost::enable_shared_from_this<ConnectionPool>\n+{\n+public:\n+   boost::shared_ptr<IConnection> getConnection();\n+\n+private:\n+   friend class PooledConnection;\n+   friend Error createConnectionPool(size_t poolSize,\n+                                     const ConnectionOptions& options,\n+                                     boost::shared_ptr<ConnectionPool>* pPool);\n+\n+   void returnConnection(const boost::shared_ptr<Connection>& connection);\n+\n+   thread::ThreadsafeQueue<boost::shared_ptr<Connection>> connections_;\n+};\n+\n+class Transaction\n+{\n+public:\n+   Transaction(const boost::shared_ptr<IConnection>& connection);\n+\n+   void commit();\n+   void rollback();\n+\n+   // when this class goes out of scope, the transaction\n+   // is automatically aborted if not previously committed\n+\n+private:\n+   boost::shared_ptr<IConnection> connection_;\n+   soci::transaction transaction_;\n+};\n+\n+static constexpr const char* SQLITE_DRIVER = \"sqlite3\";\n+static constexpr const char* POSTGRESQL_DRIVER = \"postgresql\";\n+\n+class SchemaUpdater\n+{\n+public:\n+   SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                 const FilePath& migrationsPath);\n+\n+   // updates the database schema to the highest version\n+   Error update();\n+\n+   // updates the database schema to the specified version\n+   Error updateToVersion(const std::string& maxVersion);", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNzk2MQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387327961", "bodyText": "Both - it will update to no higher than the specified version, and if that version exists, that's what it will be updated to.\nBut that break condition was something I forgot to add to the code, so will update with that in there.", "author": "kfeinauer", "createdAt": "2020-03-03T22:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NTk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzMzc3Mw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387333773", "bodyText": "Could you update the comment to reflect that as well?", "author": "MariaSemple", "createdAt": "2020-03-03T22:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NTk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI4ODEwMg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387288102", "bodyText": "Is it not possible to create the database on startup, if it doesn't exist?", "author": "MariaSemple", "createdAt": "2020-03-03T20:55:54Z", "path": "src/cpp/server/extras/conf/database.conf", "diffHunk": "@@ -0,0 +1,32 @@\n+# This file contains database configuration.\n+#\n+# RStudio Server needs an external database for storage of specific configuration and runtime information.\n+#\n+# Simply uncomment the lines below and modify it to suit your needs.\n+# For more documentation, see the RStudio Server Pro Admin Guide.\n+#\n+#\n+# =========================================================================================================\n+# sqlite configuration\n+# =========================================================================================================\n+# Specifies the database provider to use\n+#provider=sqlite\n+# Directory in which the sqlite database will be written\n+#directory=/var/run/rstudio-server\n+# =========================================================================================================\n+# postgresql configuration\n+# =========================================================================================================\n+# Note: when connecting to a PostgreSQL database, a default empty rstudio database must first be created!", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyODQxMw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387328413", "bodyText": "This is generally not done for a variety of reasons (from what I understand), and for example is not something done by Connect (which a lot of this is modeled off of). So I will not attempt to automatically create the database.", "author": "kfeinauer", "createdAt": "2020-03-03T22:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI4ODEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI5MjA0OA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387292048", "bodyText": "Do you think it would be a good idea to update the diagnostics collection script to collect this file as part of this PR? I think we need to sanitize the password field whether or not it's commented out, as admins may edit the value to their real password and then later comment it out while they try to get things working.", "author": "MariaSemple", "createdAt": "2020-03-03T21:03:36Z", "path": "src/cpp/server/extras/conf/database.conf", "diffHunk": "@@ -0,0 +1,32 @@\n+# This file contains database configuration.\n+#\n+# RStudio Server needs an external database for storage of specific configuration and runtime information.\n+#\n+# Simply uncomment the lines below and modify it to suit your needs.\n+# For more documentation, see the RStudio Server Pro Admin Guide.\n+#\n+#\n+# =========================================================================================================\n+# sqlite configuration\n+# =========================================================================================================\n+# Specifies the database provider to use\n+#provider=sqlite\n+# Directory in which the sqlite database will be written\n+#directory=/var/run/rstudio-server\n+# =========================================================================================================\n+# postgresql configuration\n+# =========================================================================================================\n+# Note: when connecting to a PostgreSQL database, a default empty rstudio database must first be created!\n+# Specifies the database provider to use\n+#provider=postgresql\n+# Specifies the host (hostname or IP address) of the database host\n+#host=localhost\n+# Specifies the TCP port where the database is listening for connections\n+#port=5432\n+# Specifies the database connection username\n+#username=postgres\n+# Specifies the database connection password\n+#password=postgres", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc2Nzk1NA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387767954", "bodyText": "I think this isn't really necessary for collection at this stage. Generally, if there is actually a database problem, we'll need to look into data within their database tables, which this file is not going to help, so a further dialog would be required there anyway which makes the hassle of collecting this file and sanitizing it not worth including in this PR.", "author": "kfeinauer", "createdAt": "2020-03-04T16:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI5MjA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwNDc5NQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387304795", "bodyText": "When does this happen now? Is a DB required to run RSP after this change?", "author": "MariaSemple", "createdAt": "2020-03-03T21:30:11Z", "path": "src/cpp/server/auth/ServerAuthHandler.cpp", "diffHunk": "@@ -93,39 +94,110 @@ void updateCredentialsNotSupported(\n    pConnection->writeResponse();\n }\n \n-bool isCookieRevoked(const std::string& cookie)\n+Error readRevocationListFromDatabase(std::vector<std::string>* pEntries)\n {\n-   boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n+   // establish a new transaction with the database\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   Transaction transaction(connection);\n+\n+   // first, delete all stale cookies from the database\n+   std::string expiration = date_time::format(boost::posix_time::microsec_clock::universal_time(),\n+                                              date_time::kIso8601Format);\n+   Query deleteQuery = connection->query(\"DELETE FROM RevokedCookie WHERE Expiration <= :val\")\n+         .withInput(expiration);\n+   Error error = connection->execute(deleteQuery);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not delete expired revoked cookies from the database\");\n+      return error;\n+   }\n+\n+   // get all cookie entries from the database\n+   Query fetchQuery = connection->query(\"SELECT CookieData FROM RevokedCookie\");\n+   Rowset rowset;\n+   error = connection->execute(fetchQuery, rowset);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not retrieve revoked cookies from the database\");\n+      return error;\n+   }\n+\n+   for (RowsetIterator it = rowset.begin(); it != rowset.end(); ++it)\n+   {\n+      Row& row = *it;\n+      pEntries->push_back(row.get<std::string>(0));\n+   }\n+\n+   transaction.commit();\n+   return Success();\n+}\n+\n+void removeStaleCookieFromDatabase(const RevokedCookie& cookie)\n+{\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   std::string expiration = date_time::format(cookie.expiration, date_time::kIso8601Format);\n+   Query query = connection->query(\"DELETE FROM RevokedCookie WHERE Expiration = :exp AND CookieData = :dat\")\n+         .withInput(expiration)\n+         .withInput(cookie.cookie);\n+\n+   Error error = connection->execute(query);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not delete expired revoked cookie from the database\");\n+      LOG_ERROR(error);\n+   }\n+}\n+\n+\n+Error writeRevokedCookieToDatabase(const RevokedCookie& cookie,\n+                                   boost::shared_ptr<IConnection> connection = boost::shared_ptr<IConnection>())\n+{\n+   std::string expiration = date_time::format(cookie.expiration, date_time::kIso8601Format);\n+\n+   // use existing connection if passed in, otherwise grab a new one\n+   if (!connection)\n+      connection = server_core::database::getConnection();\n+\n+   Query query = connection->query(\"INSERT INTO RevokedCookie VALUES (:exp, :dat)\")\n+         .withInput(expiration)\n+         .withInput(cookie.cookie);\n+\n+   Error error = connection->execute(query);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not insert revoked cookie into the database\");\n+      return error;\n+   }\n+\n+   return Success();\n+}\n+\n+Error writeRevokedCookiesToDatabase()\n+{\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   Transaction transaction(connection);\n \n    LOCK_MUTEX(s_mutex)\n    {\n-      // check for cookie in revocation list, deleting expired elements as we go\n-      for (auto it = s_revokedCookies.begin(); it != s_revokedCookies.end();)\n+      for (auto it = s_revokedCookies.begin(); it != s_revokedCookies.end(); ++it)\n       {\n-         const RevokedCookie& other = *it;\n-         if (other.cookie == cookie)\n-            return true;\n-\n-         if (other.expiration <= now)\n-         {\n-            it = s_revokedCookies.erase(it);\n-            continue;\n-         }\n-         else\n-         {\n-            ++it;\n-         }\n+         const RevokedCookie& cookie = *it;\n+         Error error = writeRevokedCookieToDatabase(cookie, connection);\n+         if (error)\n+            return error;\n       }\n    }\n    END_LOCK_MUTEX\n \n-   return false;\n+   transaction.commit();\n+   return Success();\n }\n \n-Error readRevocationList(std::vector<std::string>* pEntries)\n+Error readRevocationListFromFile(const FilePath& revocationList,", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0MzI3NA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387343274", "bodyText": "This only happens when migrating an existing file collection to the database for the first time. Then after, the file is never used again.", "author": "kfeinauer", "createdAt": "2020-03-03T22:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwNDc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwNzIyNA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387307224", "bodyText": "Nit: there's no need to exit the first if and re-enter the second if as they have the same condition.", "author": "MariaSemple", "createdAt": "2020-03-03T21:35:06Z", "path": "src/cpp/server/auth/ServerAuthHandler.cpp", "diffHunk": "@@ -444,98 +506,85 @@ Error initialize()\n {\n    // initialize by loading the current contents of the revocation list into memory\n \n-   // create revocation list directory and ensure the server user has permission to write to it\n+   // first, look for an existing file-based revocation list\n+   // RStudio versions prior to 1.4 wrote the list to a file, as database integration did not yet exist\n    FilePath rootDir = options().authRevocationListDir();\n-   Error error = rootDir.ensureDirectory();\n-   if (error)\n-   {\n-      error.addProperty(\"description\", \"Could not create revocation list directory \" + rootDir.getAbsolutePath());\n-      return error;\n-   }\n-\n-   core::system::User serverUser;\n-   if (core::system::effectiveUserIsRoot())\n-   {\n-      error = core::system::User::getUserFromIdentifier(options().serverUser(), serverUser);\n-      if (error)\n-      {\n-         error.addProperty(\"description\", \"Could not get server user details\");\n-         return error;\n-      }\n-\n-      error = rootDir.changeOwnership(serverUser);\n-      if (error)\n-      {\n-         error.addProperty(\"description\", \"Could not change ownership of revocation list directory \" + rootDir.getAbsolutePath());\n-         return error;\n-      }\n-   }\n-\n-   s_revocationList = rootDir.completeChildPath(\"revocation-list\");\n-   s_revocationLockFile = rootDir.completeChildPath(\"revocation-list.lock\");\n+   FilePath revocationList = rootDir.completeChildPath(\"revocation-list\");\n+   FilePath revocationLockFile = rootDir.completeChildPath(\"revocation-list.lock\");\n \n    // create a file lock to gain exclusive access to the revocation list\n    boost::shared_ptr<FileLock> lock = FileLock::createDefault();\n    int numTries = 0;\n \n+   bool lockAcquired = false;\n    while (numTries < 30)\n    {\n-      ScopedFileLock fileLock(lock, s_revocationLockFile);\n-      Error error = fileLock.error();\n-      if (error)\n+      // only attempt file locking if the revocation list exists\n+      // if it does not, then we have already previously migrated to the database\n+      if (revocationList.exists())\n       {\n-         // if we could not acquire the lock, some other rserver process has\n-         // keep trying for some time before giving up\n-         ++numTries;\n-         boost::this_thread::sleep(boost::posix_time::seconds(1));\n-         continue;\n+         Error error = lock->acquire(revocationLockFile);\n+         if (error)\n+         {\n+            // if we could not acquire the lock, some other rserver process has\n+            // keep trying for some time before giving up\n+            ++numTries;\n+            boost::this_thread::sleep(boost::posix_time::seconds(1));\n+            continue;\n+         }\n+\n+         lockAcquired = true;\n       }\n \n       // successfully acquired lock\n-      // create file if it does not exist\n-      error = s_revocationList.ensureFile();\n-      if (error)\n+      // migrate the revocation list file to the database if it exists\n+      if (revocationList.exists())\n       {", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMTEwMQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387311101", "bodyText": "Would it be meaningfully more efficient to use multi-row insertion rather than inserting each individually? Also, do you think there'd be any efficiency gain by not inserting values which are already in the DB? Or is this method only called when the DB is empty?", "author": "MariaSemple", "createdAt": "2020-03-03T21:42:48Z", "path": "src/cpp/server/auth/ServerAuthHandler.cpp", "diffHunk": "@@ -93,39 +94,110 @@ void updateCredentialsNotSupported(\n    pConnection->writeResponse();\n }\n \n-bool isCookieRevoked(const std::string& cookie)\n+Error readRevocationListFromDatabase(std::vector<std::string>* pEntries)\n {\n-   boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n+   // establish a new transaction with the database\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   Transaction transaction(connection);\n+\n+   // first, delete all stale cookies from the database\n+   std::string expiration = date_time::format(boost::posix_time::microsec_clock::universal_time(),\n+                                              date_time::kIso8601Format);\n+   Query deleteQuery = connection->query(\"DELETE FROM RevokedCookie WHERE Expiration <= :val\")\n+         .withInput(expiration);\n+   Error error = connection->execute(deleteQuery);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not delete expired revoked cookies from the database\");\n+      return error;\n+   }\n+\n+   // get all cookie entries from the database\n+   Query fetchQuery = connection->query(\"SELECT CookieData FROM RevokedCookie\");\n+   Rowset rowset;\n+   error = connection->execute(fetchQuery, rowset);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not retrieve revoked cookies from the database\");\n+      return error;\n+   }\n+\n+   for (RowsetIterator it = rowset.begin(); it != rowset.end(); ++it)\n+   {\n+      Row& row = *it;\n+      pEntries->push_back(row.get<std::string>(0));\n+   }\n+\n+   transaction.commit();\n+   return Success();\n+}\n+\n+void removeStaleCookieFromDatabase(const RevokedCookie& cookie)\n+{\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   std::string expiration = date_time::format(cookie.expiration, date_time::kIso8601Format);\n+   Query query = connection->query(\"DELETE FROM RevokedCookie WHERE Expiration = :exp AND CookieData = :dat\")\n+         .withInput(expiration)\n+         .withInput(cookie.cookie);\n+\n+   Error error = connection->execute(query);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not delete expired revoked cookie from the database\");\n+      LOG_ERROR(error);\n+   }\n+}\n+\n+\n+Error writeRevokedCookieToDatabase(const RevokedCookie& cookie,\n+                                   boost::shared_ptr<IConnection> connection = boost::shared_ptr<IConnection>())\n+{\n+   std::string expiration = date_time::format(cookie.expiration, date_time::kIso8601Format);\n+\n+   // use existing connection if passed in, otherwise grab a new one\n+   if (!connection)\n+      connection = server_core::database::getConnection();\n+\n+   Query query = connection->query(\"INSERT INTO RevokedCookie VALUES (:exp, :dat)\")\n+         .withInput(expiration)\n+         .withInput(cookie.cookie);\n+\n+   Error error = connection->execute(query);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not insert revoked cookie into the database\");\n+      return error;\n+   }\n+\n+   return Success();\n+}\n+\n+Error writeRevokedCookiesToDatabase()\n+{\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   Transaction transaction(connection);\n \n    LOCK_MUTEX(s_mutex)\n    {\n-      // check for cookie in revocation list, deleting expired elements as we go\n-      for (auto it = s_revokedCookies.begin(); it != s_revokedCookies.end();)\n+      for (auto it = s_revokedCookies.begin(); it != s_revokedCookies.end(); ++it)\n       {\n-         const RevokedCookie& other = *it;\n-         if (other.cookie == cookie)\n-            return true;\n-\n-         if (other.expiration <= now)\n-         {\n-            it = s_revokedCookies.erase(it);\n-            continue;\n-         }\n-         else\n-         {\n-            ++it;\n-         }\n+         const RevokedCookie& cookie = *it;\n+         Error error = writeRevokedCookieToDatabase(cookie, connection);", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0NzE5OA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387347198", "bodyText": "We're really not handling a lot of volume here (we're not bulk importing a lot of data). I think for ease of code understanding and simplicity, this is good enough.", "author": "kfeinauer", "createdAt": "2020-03-03T23:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMTEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDQ5Mw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387314493", "bodyText": "Nit: Is it necessary to have both the expiration value and the cookie data to uniquely identify the revoked cookie, or would it suffice to just have the cookie data? I doubt it will come up though, since I don't think composite keys are really any more expensive than single-column primary keys (especially with only two columns), and it seems unlikely that we'll ever get two identical cookies with different expiration dates (assuming that's not something that we do on purpose).", "author": "MariaSemple", "createdAt": "2020-03-03T21:49:32Z", "path": "src/cpp/server/db/20200226141952248_AddRevokedCookie.sql", "diffHunk": "@@ -0,0 +1,5 @@\n+CREATE TABLE RevokedCookie(\n+   Expiration text NOT NULL,\n+   CookieData text NOT NULL,\n+   PRIMARY KEY (Expiration, CookieData)", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0NzcyNA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387347724", "bodyText": "I want the expiration on its own column so we can use the database to filter for the bulk delete query. Having the composite key here is going to be negligible performance loss (and this is not super performance critical code at any rate), so I'd rather keep both columns.", "author": "kfeinauer", "createdAt": "2020-03-03T23:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM1NTA2NA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387355064", "bodyText": "Oh, I didn't mean to remove the expiration column, just to remove it from the primary key if it's not required for unique entry identification. You're right about the performance though - that wouldn't be the reason to change it.", "author": "MariaSemple", "createdAt": "2020-03-03T23:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM1NzIzNQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387357235", "bodyText": "That's a good point - since the Expiration is derivative data (it's redundantly stored on CookieData), then there's no reason for it to be part of the primary key. It just made sense in my initial thoughts. I'll change this.", "author": "kfeinauer", "createdAt": "2020-03-03T23:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM1ODA1Ng==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387358056", "bodyText": "Actually, I do want the Expiration partially indexed for faster sorting (since we sort by expiration). I'll need to research more on how compound primary keys affect this.", "author": "kfeinauer", "createdAt": "2020-03-03T23:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2MzkxMQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387363911", "bodyText": "Are you sure it's a partial index that you want, or a full index? At any rate you should be able to create an index on a non-primary-key column using CREATE INDEX RCExpiryIndex ON RevokedCookies (Expiration); or something like it. It makes insertion into the table slower though, so if you're going to do that you may want to revise the code that writes all the revoked cookies to the table (assuming that happens with any frequency).", "author": "MariaSemple", "createdAt": "2020-03-03T23:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc4OTk2Nw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387789967", "bodyText": "The overhead that this index is going to add, especially for such a small table that doesn't see a very high volume, is minimal and not worth reworking any of the insert code IMO.", "author": "kfeinauer", "createdAt": "2020-03-04T16:38:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDkxNA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387314914", "bodyText": "Could you add a comment to each SQL file to describe the purpose of the table and it's fields?", "author": "MariaSemple", "createdAt": "2020-03-03T21:50:21Z", "path": "src/cpp/server/db/20200226141952248_AddRevokedCookie.sql", "diffHunk": "@@ -0,0 +1,5 @@\n+CREATE TABLE RevokedCookie(", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc4OTQ4OQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387789489", "bodyText": "Done", "author": "kfeinauer", "createdAt": "2020-03-04T16:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxODU2Mw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387318563", "bodyText": "Could this lead to a hang if we leak pooled connections anywhere? I suppose we probably won't leak a pooled connection, though, as they're always handed out using smart pointers.", "author": "MariaSemple", "createdAt": "2020-03-03T21:57:38Z", "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,638 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                              Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available\n+   boost::shared_ptr<Connection> connection;\n+   connections_.deque(&connection, boost::posix_time::pos_infin);", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0Nzk5MA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387347990", "bodyText": "This will hang until there is a connection available in the pool, which is what I intended. And like you said, they are handed out via shared ptr to help ensure that they are not leaked.", "author": "kfeinauer", "createdAt": "2020-03-03T23:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxODU2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5MzY0NA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387893644", "bodyText": "Right, I know that hanging until one is available is intended. The concern would be around hanging forever if for some reason the connections are all never returned. Do you think it would be worth setting some very long timeout and then logging an error and exiting? That way it will be easier to find such an issue, in the unlikely event that one every occurs?", "author": "MariaSemple", "createdAt": "2020-03-04T19:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxODU2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM1MjIxOA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388352218", "bodyText": "I think exiting is a little heavy handed, but I think logging that there's a potential hang isn't a bad idea. I'll add this.", "author": "kfeinauer", "createdAt": "2020-03-05T15:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxODU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMDU2Nw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387320567", "bodyText": "Do we ever initialize the server database without attempting to update the schema? If not, is the parameter there because we plan to in the future?", "author": "MariaSemple", "createdAt": "2020-03-03T22:01:37Z", "path": "src/cpp/server/ServerMain.cpp", "diffHunk": "@@ -622,6 +624,11 @@ int main(int argc, char * const argv[])\n       if (error)\n          return core::system::exitFailure(error, ERROR_LOCATION);\n \n+      // initialize database connectivity\n+      error = server_core::database::initialize(true);", "originalCommit": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0ODE2Ng==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387348166", "bodyText": "We don't yet, but we will. I want derivative processes of rserver to not run migrations, even though they may need to connect to the database (like rserver-monitor).", "author": "kfeinauer", "createdAt": "2020-03-03T23:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMDU2Nw=="}], "type": "inlineReview"}, {"oid": "e9fcf257e32a059f946f2072a6379b381079efdc", "url": "https://github.com/rstudio/rstudio/commit/e9fcf257e32a059f946f2072a6379b381079efdc", "message": "Code review feedback", "committedDate": "2020-03-03T22:51:24Z", "type": "commit"}, {"oid": "1d174a9c90eef4057fa6a1a9551e21fc0a159f1d", "url": "https://github.com/rstudio/rstudio/commit/1d174a9c90eef4057fa6a1a9551e21fc0a159f1d", "message": "Code review feedback", "committedDate": "2020-03-03T22:57:36Z", "type": "commit"}, {"oid": "eef353b619055cb6b15b603f87ddd23d44bddb2a", "url": "https://github.com/rstudio/rstudio/commit/eef353b619055cb6b15b603f87ddd23d44bddb2a", "message": "Code review feedback - remove redundant if statement", "committedDate": "2020-03-03T22:59:53Z", "type": "commit"}, {"oid": "f1faec5b4b791b2e6e3a5dec4f523db32c3a7ec0", "url": "https://github.com/rstudio/rstudio/commit/f1faec5b4b791b2e6e3a5dec4f523db32c3a7ec0", "message": "Fix compile error", "committedDate": "2020-03-03T23:00:22Z", "type": "commit"}, {"oid": "2c357455a5bdf7a509d8978e34acd41057cc9561", "url": "https://github.com/rstudio/rstudio/commit/2c357455a5bdf7a509d8978e34acd41057cc9561", "message": "Fix whitespace", "committedDate": "2020-03-03T23:04:28Z", "type": "commit"}, {"oid": "4ae86cc2d06e203d0ed524b495467492a83485f7", "url": "https://github.com/rstudio/rstudio/commit/4ae86cc2d06e203d0ed524b495467492a83485f7", "message": "Quote current version table name to ensure that the casing is honored. Because we have to select from metadata tables to check for its existence, it is important that it has the correct casing", "committedDate": "2020-03-03T23:27:24Z", "type": "commit"}, {"oid": "a7f2a6293e5fae410c124986800c435b181ed445", "url": "https://github.com/rstudio/rstudio/commit/a7f2a6293e5fae410c124986800c435b181ed445", "message": "Code review feedback - rework index on RevokedCookie table and add comments", "committedDate": "2020-03-04T16:37:28Z", "type": "commit"}, {"oid": "dc45ebcd8f1990f9c68f53eecd389f86b01df511", "url": "https://github.com/rstudio/rstudio/commit/dc45ebcd8f1990f9c68f53eecd389f86b01df511", "message": "Code review feedback - introduce the timeout concept for grabbing a connection from the pool, and spit out errors for long periods of blocking time when no timeout is specified", "committedDate": "2020-03-05T15:32:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMjU4MQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388532581", "bodyText": "We don't formally have a dependency on homebrew for dev machines, although in practice I think we all use it. I'm fine with introducing one, but make sure you also update the wikis if you do, and maybe add check here to see if homebrew is installed (so attempting to set up a machine w/o homebrew will give a more useful error).", "author": "jmcphers", "createdAt": "2020-03-05T20:03:53Z", "path": "dependencies/osx/install-dependencies-osx", "diffHunk": "@@ -22,6 +22,9 @@ then\n   ./install-overlay\n fi\n \n+# install postgres, needed by SOCI\n+brew install postgres", "originalCommit": "dc45ebcd8f1990f9c68f53eecd389f86b01df511", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNTUzMg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388535532", "bodyText": "Isn't this going to use character ordering (\"2\" > \"11\")?", "author": "jmcphers", "createdAt": "2020-03-05T20:10:05Z", "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,665 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available, but log an error\n+   // if this takes a long time, because we want to ensure that if we are in a hang\n+   // condition (i.e. threads are not properly returning connections to the pool) we\n+   // let the users/developers know that something is fishy\n+   boost::shared_ptr<Connection> connection;\n+   while (true)\n+   {\n+      if (connections_.deque(&connection, boost::posix_time::seconds(30)))\n+      {\n+         // create wrapper PooledConnection around retrieved Connection\n+         return boost::shared_ptr<IConnection>(new PooledConnection(shared_from_this(), connection));\n+      }\n+      else\n+      {\n+         LOG_ERROR_MESSAGE(\"Potential hang detected: could not get database connection from pool \"\n+                           \"after 30 seconds. If issue persists, please notify RStudio Support\");\n+      }\n+   }\n+}\n+\n+bool ConnectionPool::getConnection(boost::shared_ptr<IConnection>* pConnection,\n+                                   const boost::posix_time::time_duration& maxWait)\n+{\n+   boost::shared_ptr<Connection> connection;\n+   if (!connections_.deque(&connection, maxWait))\n+      return false;\n+\n+   pConnection->reset(new PooledConnection(shared_from_this(), connection));\n+   return true;\n+}\n+\n+void ConnectionPool::returnConnection(const boost::shared_ptr<Connection>& connection)\n+{\n+   connections_.enque(connection);\n+}\n+\n+Transaction::Transaction(const boost::shared_ptr<IConnection>& connection) :\n+   connection_(connection),\n+   transaction_(connection->session())\n+{\n+}\n+\n+void Transaction::commit()\n+{\n+   transaction_.commit();\n+}\n+\n+void Transaction::rollback()\n+{\n+   transaction_.rollback();\n+}\n+\n+SchemaUpdater::SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                             const FilePath& migrationsPath) :\n+   connection_(connection),\n+   migrationsPath_(migrationsPath)\n+{\n+}\n+\n+Error SchemaUpdater::migrationFiles(std::vector<FilePath>* pMigrationFiles)\n+{\n+   std::vector<FilePath> children;\n+   Error error = migrationsPath_.getChildren(children);\n+   if (error)\n+      return error;\n+\n+   for (const FilePath& file : children)\n+   {\n+      std::string extension = file.getExtensionLowerCase();\n+      if (extension == SQL_EXTENSION ||\n+          extension == SQLITE_EXTENSION ||\n+          extension == POSTGRESQL_EXTENSION)\n+      {\n+         pMigrationFiles->push_back(file);\n+      }\n+   }\n+\n+   return Success();\n+}\n+\n+Error SchemaUpdater::highestMigrationVersion(std::string* pVersion)\n+{\n+   std::vector<FilePath> files;\n+   Error error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   if (files.empty())\n+   {\n+      // no migration files - we do not consider this an error, but instead\n+      // simply consider that this database cannot be migrated past version 0\n+      *pVersion = \"0\";\n+      return Success();\n+   }\n+\n+   // sort descending - highest version filename wins\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() > b.getStem();", "originalCommit": "dc45ebcd8f1990f9c68f53eecd389f86b01df511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MDAxMA==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388540010", "bodyText": "Upon further review I see that the filenames are formatted by convention so that character ordering is sufficient. I think we might make this clearer by using an \"initial version\" that looks like the incremental additional versions, and/or adding some docs stating explicitly how to format the filenames so this constraint is maintained.", "author": "jmcphers", "createdAt": "2020-03-05T20:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNTUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjAxMw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388536013", "bodyText": "As above re: string comparison of versions.", "author": "jmcphers", "createdAt": "2020-03-05T20:11:05Z", "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,665 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available, but log an error\n+   // if this takes a long time, because we want to ensure that if we are in a hang\n+   // condition (i.e. threads are not properly returning connections to the pool) we\n+   // let the users/developers know that something is fishy\n+   boost::shared_ptr<Connection> connection;\n+   while (true)\n+   {\n+      if (connections_.deque(&connection, boost::posix_time::seconds(30)))\n+      {\n+         // create wrapper PooledConnection around retrieved Connection\n+         return boost::shared_ptr<IConnection>(new PooledConnection(shared_from_this(), connection));\n+      }\n+      else\n+      {\n+         LOG_ERROR_MESSAGE(\"Potential hang detected: could not get database connection from pool \"\n+                           \"after 30 seconds. If issue persists, please notify RStudio Support\");\n+      }\n+   }\n+}\n+\n+bool ConnectionPool::getConnection(boost::shared_ptr<IConnection>* pConnection,\n+                                   const boost::posix_time::time_duration& maxWait)\n+{\n+   boost::shared_ptr<Connection> connection;\n+   if (!connections_.deque(&connection, maxWait))\n+      return false;\n+\n+   pConnection->reset(new PooledConnection(shared_from_this(), connection));\n+   return true;\n+}\n+\n+void ConnectionPool::returnConnection(const boost::shared_ptr<Connection>& connection)\n+{\n+   connections_.enque(connection);\n+}\n+\n+Transaction::Transaction(const boost::shared_ptr<IConnection>& connection) :\n+   connection_(connection),\n+   transaction_(connection->session())\n+{\n+}\n+\n+void Transaction::commit()\n+{\n+   transaction_.commit();\n+}\n+\n+void Transaction::rollback()\n+{\n+   transaction_.rollback();\n+}\n+\n+SchemaUpdater::SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                             const FilePath& migrationsPath) :\n+   connection_(connection),\n+   migrationsPath_(migrationsPath)\n+{\n+}\n+\n+Error SchemaUpdater::migrationFiles(std::vector<FilePath>* pMigrationFiles)\n+{\n+   std::vector<FilePath> children;\n+   Error error = migrationsPath_.getChildren(children);\n+   if (error)\n+      return error;\n+\n+   for (const FilePath& file : children)\n+   {\n+      std::string extension = file.getExtensionLowerCase();\n+      if (extension == SQL_EXTENSION ||\n+          extension == SQLITE_EXTENSION ||\n+          extension == POSTGRESQL_EXTENSION)\n+      {\n+         pMigrationFiles->push_back(file);\n+      }\n+   }\n+\n+   return Success();\n+}\n+\n+Error SchemaUpdater::highestMigrationVersion(std::string* pVersion)\n+{\n+   std::vector<FilePath> files;\n+   Error error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   if (files.empty())\n+   {\n+      // no migration files - we do not consider this an error, but instead\n+      // simply consider that this database cannot be migrated past version 0\n+      *pVersion = \"0\";\n+      return Success();\n+   }\n+\n+   // sort descending - highest version filename wins\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() > b.getStem();\n+   };\n+   std::sort(files.begin(), files.end(), comparator);\n+\n+   *pVersion = files.at(0).getStem();\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isSchemaVersionPresent(bool* pIsPresent)\n+{\n+   std::string queryStr;\n+   if (connection_->driverName() == SQLITE_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM sqlite_master WHERE type='table' AND name='\") + SCHEMA_TABLE + \"'\";\n+   }\n+   else if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM information_schema.tables WHERE table_name='\") + SCHEMA_TABLE +\n+                 \"' AND table_schema = current_schema\";\n+   }\n+   else\n+   {\n+      return DatabaseError(soci::soci_error(\"Unsupported database driver\"));\n+   }\n+\n+   int count = 0;\n+   Query query = connection_->query(queryStr)\n+         .withOutput(count);\n+   Error error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pIsPresent = count > 0;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::databaseSchemaVersion(std::string* pVersion)\n+{\n+   bool versionPresent = false;\n+   Error error = isSchemaVersionPresent(&versionPresent);\n+   if (error)\n+      return error;\n+\n+   std::string currentSchemaVersion = \"0\";\n+   if (!versionPresent)\n+   {\n+      // no schema version present - add the table to the database so it is available\n+      // for updating whenever migrations occur\n+      error = connection_->executeStr(std::string(\"CREATE TABLE \\\"\") + SCHEMA_TABLE + \"\\\" (CurrentVersion text)\");\n+      if (error)\n+         return error;\n+\n+      Query query = connection_->query(std::string(\"INSERT INTO \\\"\") + SCHEMA_TABLE + \"\\\" VALUES (:val)\")\n+            .withInput(currentSchemaVersion);\n+      error = connection_->execute(query);\n+      if (error)\n+         return error;\n+\n+      *pVersion = currentSchemaVersion;\n+      return Success();\n+   }\n+\n+   Query query = connection_->query(std::string(\"SELECT CurrentVersion FROM \\\"\") + SCHEMA_TABLE + \"\\\"\")\n+         .withOutput(currentSchemaVersion);\n+\n+   error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pVersion = currentSchemaVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isUpToDate(bool* pUpToDate)\n+{\n+   std::string version;\n+   Error error = databaseSchemaVersion(&version);\n+   if (error)\n+      return error;\n+\n+   std::string migrationVersion;\n+   error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   *pUpToDate = version >= migrationVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::update()\n+{\n+   std::string migrationVersion;\n+   Error error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   std::string currentVersion;\n+   error = databaseSchemaVersion(&currentVersion);\n+   if (currentVersion < migrationVersion)\n+      return updateToVersion(migrationVersion);\n+   else\n+      return Success();\n+}\n+\n+Error SchemaUpdater::updateToVersion(const std::string& maxVersion)\n+{\n+   // create a transaction to perform the following steps:\n+   // 1. Check the current database schema version\n+   // 2. Check if we need to update\n+   // 3. Update (if necessary)\n+   // 4. Save new database schema version\n+   // performing this in a transaction ensures that we rollback if anything\n+   // fails, and also ensures that other nodes cannot update concurrently\n+   Transaction transaction(connection_);\n+\n+   // for postgresql, specifically lock the version table in exclusive mode\n+   // to ensure that no other connection can use the version table AT ALL\n+   // during this schema update\n+   if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      Query query = connection_->query(std::string(\"LOCK \\\"\") + SCHEMA_TABLE + \"\\\" IN ACCESS EXCLUSIVE MODE\");\n+      Error error = connection_->execute(query);\n+      if (error)\n+         return error;\n+   }\n+\n+   std::string currentVersion;\n+   Error error = databaseSchemaVersion(&currentVersion);\n+   if (error)\n+      return error;\n+\n+   if (currentVersion >= maxVersion)\n+      return Success();\n+\n+   std::vector<FilePath> files;\n+   error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   // sort ascending\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() < b.getStem();", "originalCommit": "dc45ebcd8f1990f9c68f53eecd389f86b01df511", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNzY4MQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388537681", "bodyText": "Can we add a README to this parent folder that explains how to name files and perform schema upgrades for devs?", "author": "jmcphers", "createdAt": "2020-03-05T20:13:49Z", "path": "src/cpp/server/db/20200226141952248_AddRevokedCookie.sql", "diffHunk": "@@ -0,0 +1,19 @@\n+/* Stores revoked auth cookies - cookies that are not yet expired, but", "originalCommit": "dc45ebcd8f1990f9c68f53eecd389f86b01df511", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0dbc43f186e42197fbe2a085f87515ed57046b4a", "url": "https://github.com/rstudio/rstudio/commit/0dbc43f186e42197fbe2a085f87515ed57046b4a", "message": "Code review feedback - make script to generate schema files and add readme", "committedDate": "2020-03-05T22:09:58Z", "type": "commit"}, {"oid": "144891e8e9739ef94d229418c7cb1706b994a80c", "url": "https://github.com/rstudio/rstudio/commit/144891e8e9739ef94d229418c7cb1706b994a80c", "message": "Script early exit for bad invocation", "committedDate": "2020-03-05T22:13:52Z", "type": "commit"}, {"oid": "c08b6314bfa74a120e79cc0731c6b33918b6d96f", "url": "https://github.com/rstudio/rstudio/commit/c08b6314bfa74a120e79cc0731c6b33918b6d96f", "message": "Spell out that homebrew is required for osx depdencies script", "committedDate": "2020-03-05T22:18:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyOTI1NQ==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388629255", "bodyText": "Nit: I think we normally put output parameters last.", "author": "MariaSemple", "createdAt": "2020-03-05T23:42:27Z", "path": "src/cpp/core/include/core/Database.hpp", "diffHunk": "@@ -192,8 +192,15 @@ class PooledConnection : public IConnection\n class ConnectionPool : public boost::enable_shared_from_this<ConnectionPool>\n {\n public:\n+   // get a connection from the connection pool, blocking until one becomes available\n    boost::shared_ptr<IConnection> getConnection();\n \n+   // get a connection from the connection pool, waiting for at most maxWait for one\n+   // to become available. if no connection becomes available, false is returned and\n+   // the connection is empty, otherwise the connection is set and true is returned\n+   bool getConnection(boost::shared_ptr<IConnection>* pConnection,\n+                      const boost::posix_time::time_duration& maxWait);", "originalCommit": "c08b6314bfa74a120e79cc0731c6b33918b6d96f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDM1Ng==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388630356", "bodyText": "Nit: Is it necessary to have such a detailed timestamp? Are we likely to publish multiple versions of the same table that differ only by microseconds (or even hours)?", "author": "MariaSemple", "createdAt": "2020-03-05T23:46:22Z", "path": "src/cpp/server/db/README.md", "diffHunk": "@@ -0,0 +1,23 @@\n+## Server Database Schemas\n+\n+This folder contains the database schemas for the RStudio Server database. These schemas are copied to the build output directory, and are applied to the database every time `rserver` is started.\n+\n+Schema files rely on a file format convention containing the following:\n+* The date time at which the script was generated in the format YYYYMMDDHHmmssuuu (where uuu is microseconds)", "originalCommit": "c08b6314bfa74a120e79cc0731c6b33918b6d96f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNTMzMg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388905332", "bodyText": "No, but it absolutely ensures no duplicates. Also, I picked a method that was easy to script, so that plays a big part into what I chose to do (see ./make-schema.sh", "author": "kfeinauer", "createdAt": "2020-03-06T13:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDgyNg==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388630826", "bodyText": "Out of curiosity, what happens when there is a .sql and a .sqlite/.postgresql file for the same table? Is the most specific file type run?", "author": "MariaSemple", "createdAt": "2020-03-05T23:48:07Z", "path": "src/cpp/server/db/README.md", "diffHunk": "@@ -0,0 +1,23 @@\n+## Server Database Schemas\n+\n+This folder contains the database schemas for the RStudio Server database. These schemas are copied to the build output directory, and are applied to the database every time `rserver` is started.\n+\n+Schema files rely on a file format convention containing the following:\n+* The date time at which the script was generated in the format YYYYMMDDHHmmssuuu (where uuu is microseconds)\n+* An underscore separating the date time from the friendly name\n+* A friendly name for what the script does\n+* A file extension, which can be `.sql`, `.sqlite`, or `.postgresql`. `.sql` files will be run for any database type, but the other two extensions are reserved for only running if the database in use corresponds to that file extension.", "originalCommit": "c08b6314bfa74a120e79cc0731c6b33918b6d96f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNDk0Nw==", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388904947", "bodyText": "Updated README with answer", "author": "kfeinauer", "createdAt": "2020-03-06T13:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDgyNg=="}], "type": "inlineReview"}, {"oid": "74c563ac6606e522fed8b91b4ce7b8935ed6b33a", "url": "https://github.com/rstudio/rstudio/commit/74c563ac6606e522fed8b91b4ce7b8935ed6b33a", "message": "Update README", "committedDate": "2020-03-06T13:35:09Z", "type": "commit"}, {"oid": "d5b55894f9b72752c0274b0f802be4525c974bd6", "url": "https://github.com/rstudio/rstudio/commit/d5b55894f9b72752c0274b0f802be4525c974bd6", "message": "Merge branch 'feature/database' of https://github.com/rstudio/rstudio into feature/database", "committedDate": "2020-03-06T13:36:27Z", "type": "commit"}, {"oid": "693a30623b58c40b31e3dc027f987b4e71d6f360", "url": "https://github.com/rstudio/rstudio/commit/693a30623b58c40b31e3dc027f987b4e71d6f360", "message": "Code review feedback - change parameter order", "committedDate": "2020-03-06T13:40:58Z", "type": "commit"}]}