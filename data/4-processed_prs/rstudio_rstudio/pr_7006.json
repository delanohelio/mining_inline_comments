{"pr_number": 7006, "pr_title": "handle raw strings in backend tokenizer", "pr_createdAt": "2020-05-29T19:06:41Z", "pr_url": "https://github.com/rstudio/rstudio/pull/7006", "timeline": [{"oid": "7cb1e7fb61ef7c4542a7e66599898a80cba715ed", "url": "https://github.com/rstudio/rstudio/commit/7cb1e7fb61ef7c4542a7e66599898a80cba715ed", "message": "handle raw strings in backend tokenizer", "committedDate": "2020-05-29T18:58:32Z", "type": "commit"}, {"oid": "dae0f9dfefe0a07298c9326b5458eb2607c4ea77", "url": "https://github.com/rstudio/rstudio/commit/dae0f9dfefe0a07298c9326b5458eb2607c4ea77", "message": "restore iterator state on error; avoid case fall-through", "committedDate": "2020-05-29T19:22:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NTI1NA==", "url": "https://github.com/rstudio/rstudio/pull/7006#discussion_r432695254", "bodyText": "\ud83d\ude31", "author": "jmcphers", "createdAt": "2020-05-29T19:38:32Z", "path": "src/cpp/core/r_util/RTokenizer.cpp", "diffHunk": "@@ -217,6 +238,113 @@ RToken RTokenizer::matchWhitespace()\n    return consumeToken(RToken::WHITESPACE, tokenLength(tokenPatterns().WHITESPACE));\n }\n \n+Error RTokenizer::matchRawStringLiteral(RToken* pToken)\n+{\n+   auto start = pos_;\n+   \n+   // consume leading 'r' or 'R'\n+   wchar_t firstChar = eat();\n+   if (!(firstChar == L'r' || firstChar == L'R'))\n+   {\n+      pos_ = start;\n+      return tokenizeError(\n+               \"expected 'r' or 'R' at start of raw string literal\",\n+               ERROR_LOCATION);\n+   }\n+   \n+   // consume quote character\n+   wchar_t quoteChar = eat();\n+   if (!(quoteChar == L'\"' || quoteChar == L'\\''))\n+   {\n+      pos_ = start;\n+      return tokenizeError(\n+               \"expected quote character at start of raw string literal\",\n+               ERROR_LOCATION);\n+   }\n+   \n+   // consume an optional number of hyphens\n+   int hyphenCount = 0;\n+   wchar_t ch = eat();\n+   while (ch == L'-')\n+   {\n+      hyphenCount++;\n+      ch = eat();\n+   }\n+   \n+   // okay, we're now sitting on open parenthesis\n+   wchar_t lhs = ch;\n+   \n+   // form right boundary character based on consumed parenthesis.\n+   // if it wasn't a parenthesis, just look for the associated closing quote\n+   wchar_t rhs;\n+   if (lhs == L'(')\n+   {\n+      rhs = L')';\n+   }\n+   else if (lhs == L'{')\n+   {\n+      rhs = L'}';\n+   }\n+   else if (lhs == L'[')\n+   {\n+      rhs = L']';\n+   }\n+   else\n+   {\n+      pos_ = start;\n+      return tokenizeError(\n+               \"expected opening bracket at start of raw string literal\",\n+               ERROR_LOCATION);\n+   }\n+   \n+   // start searching for the end of the raw string\n+   bool valid = false;\n+   \n+   while (true)\n+   {\n+      // i know, i know -- a label!? we use that here just because\n+      // we need to 'break' out of a nested loop below, and just\n+      // using a simple goto is cleaner than having e.g. an extra\n+      // boolean flag tracking whether we should 'continue'\n+      LOOP:", "originalCommit": "dae0f9dfefe0a07298c9326b5458eb2607c4ea77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}