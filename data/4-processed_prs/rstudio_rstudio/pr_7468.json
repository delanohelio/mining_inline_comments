{"pr_number": 7468, "pr_title": "Delay rendering of Ace instances in visual mode", "pr_createdAt": "2020-07-28T19:35:28Z", "pr_url": "https://github.com/rstudio/rstudio/pull/7468", "timeline": [{"oid": "646ebb4e7d05e63ebfa5e9582984abf97616e69e", "url": "https://github.com/rstudio/rstudio/commit/646ebb4e7d05e63ebfa5e9582984abf97616e69e", "message": "delay rendering of embedded Ace widgets (WIP)", "committedDate": "2020-07-28T00:10:39Z", "type": "commit"}, {"oid": "48a7b79b4627fc13090b902f939676dfb5a476d6", "url": "https://github.com/rstudio/rstudio/commit/48a7b79b4627fc13090b902f939676dfb5a476d6", "message": "Merge remote-tracking branch 'origin/master' into feature/ace-visual-perf-v2", "committedDate": "2020-07-28T18:03:04Z", "type": "commit"}, {"oid": "65bae8bca3a98ba65a827f6a76a0efe7ae426a44", "url": "https://github.com/rstudio/rstudio/commit/65bae8bca3a98ba65a827f6a76a0efe7ae426a44", "message": "improve fidelity of preview; destroy queue when done", "committedDate": "2020-07-28T19:02:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzMzAwMA==", "url": "https://github.com/rstudio/rstudio/pull/7468#discussion_r461833000", "bodyText": "IIUC, querying offsetHeight can trigger reflow, so this might be expensive to do in a scroll handler. Not sure if this is an issue in practice for us but wonder if this is worth looking at?", "author": "kevinushey", "createdAt": "2020-07-28T19:46:49Z", "path": "src/gwt/panmirror/src/editor/src/optional/ace/render_queue.ts", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * render_queue.ts\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+import { CodeBlockNodeView } from './ace';\n+\n+/**\n+ * Represents a queue of Ace editor instances that are rendered asynchronously.\n+ */\n+export class AceRenderQueue {\n+  private readonly renderQueue: CodeBlockNodeView[] = [];\n+\n+  private renderCompleted: boolean = false;\n+  private renderTimer: number = 0;\n+  private container?: HTMLElement;\n+  private needsSort: boolean = true;\n+  private bypass: number = 5;\n+  private observer?: IntersectionObserver;\n+  private visible: boolean = true;\n+\n+  /**\n+   * Sets (or replaces) the scroll container hosting the render queue. The\n+   * scroll container is used to prioritize the queue (i.e. objects in the\n+   * viewport or close to it are to be given more priority).\n+   * \n+   * @param container The HTML element of the scroll container\n+   */\n+  public setContainer(container: HTMLElement) {\n+\n+    // Handler for scroll events in the container\n+    const handleScroll = (evt: Event) => {\n+      // Whenever a scroll event occurs, we need to re-sort the queue so that\n+      // objects in or closest to the viewport are given priority.\n+      this.needsSort = true;\n+\n+      // If we don't think we're visible but we're scrolling and have height,\n+      // then we are in fact visible. (This catches a case where the\n+      // intsersection observer created below doesn't fire for visiblity\n+      // changes.)\n+      if (!this.visible && this.container && this.container.offsetHeight > 0) {", "originalCommit": "65bae8bca3a98ba65a827f6a76a0efe7ae426a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1NzE2NA==", "url": "https://github.com/rstudio/rstudio/pull/7468#discussion_r461857164", "bodyText": "That's a good question. In practice it's not an issue. this.visible is true almost all the time (short circuiting the rest of the logic), and when it's not, the container doesn't get scroll events -- so the only time we'd ever check the offsetHeight is when we are in an unexpected case (we are getting scroll events somehow even though we don't think we are visible). In this case we confirm that we are actually visible by checking the offsetHeight, after which visible becomes true so we don't check again.", "author": "jmcphers", "createdAt": "2020-07-28T20:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzMzAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzMzYwMg==", "url": "https://github.com/rstudio/rstudio/pull/7468#discussion_r461833602", "bodyText": "Do we need to support IE11?", "author": "kevinushey", "createdAt": "2020-07-28T19:47:35Z", "path": "src/gwt/panmirror/src/editor/src/optional/ace/render_queue.ts", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * render_queue.ts\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+import { CodeBlockNodeView } from './ace';\n+\n+/**\n+ * Represents a queue of Ace editor instances that are rendered asynchronously.\n+ */\n+export class AceRenderQueue {\n+  private readonly renderQueue: CodeBlockNodeView[] = [];\n+\n+  private renderCompleted: boolean = false;\n+  private renderTimer: number = 0;\n+  private container?: HTMLElement;\n+  private needsSort: boolean = true;\n+  private bypass: number = 5;\n+  private observer?: IntersectionObserver;\n+  private visible: boolean = true;\n+\n+  /**\n+   * Sets (or replaces) the scroll container hosting the render queue. The\n+   * scroll container is used to prioritize the queue (i.e. objects in the\n+   * viewport or close to it are to be given more priority).\n+   * \n+   * @param container The HTML element of the scroll container\n+   */\n+  public setContainer(container: HTMLElement) {\n+\n+    // Handler for scroll events in the container\n+    const handleScroll = (evt: Event) => {\n+      // Whenever a scroll event occurs, we need to re-sort the queue so that\n+      // objects in or closest to the viewport are given priority.\n+      this.needsSort = true;\n+\n+      // If we don't think we're visible but we're scrolling and have height,\n+      // then we are in fact visible. (This catches a case where the\n+      // intsersection observer created below doesn't fire for visiblity\n+      // changes.)\n+      if (!this.visible && this.container && this.container.offsetHeight > 0) {\n+        this.visible = true;\n+        this.processRenderQueue();\n+      }\n+    };\n+\n+    // Skip if we're already looking at this container\n+    if (this.container === container) {\n+      return;\n+    }\n+\n+    // Clean up handlers on any previous container\n+    if (this.container) {\n+      this.container.removeEventListener(\"scroll\", handleScroll);\n+    }\n+    if (this.observer) {\n+      this.observer.disconnect();\n+    }\n+\n+    this.container = container;\n+\n+    // Create intersection observer to ensure that we don't needlessly churn\n+    // through renders while offscreen.\n+    this.observer = new IntersectionObserver((entries: IntersectionObserverEntry[]) => {", "originalCommit": "65bae8bca3a98ba65a827f6a76a0efe7ae426a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2MDEyOQ==", "url": "https://github.com/rstudio/rstudio/pull/7468#discussion_r461860129", "bodyText": "That's a good question. @jjallaire do you know whether visual mode is supported in IE11? (IntersectionObserver has a pretty straightforward polyfill if we need one)", "author": "jmcphers", "createdAt": "2020-07-28T20:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzMzYwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTIwMw==", "url": "https://github.com/rstudio/rstudio/pull/7468#discussion_r462189203", "bodyText": "I believe that we've tried to preserve support for IE11. This is driven by IDE requirements though, so if the IDE decides to drop IE11 visual mode is fine dropping it. Note that we added this polyfill to the IDE already for IE11: https://github.com/rstudio/rstudio/tree/master/src/gwt/www/js/core-js. So your call either drop IE11 or add the polyfill.", "author": "jjallaire", "createdAt": "2020-07-29T10:09:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzMzYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzNDMwNQ==", "url": "https://github.com/rstudio/rstudio/pull/7468#discussion_r461834305", "bodyText": "Should this.renderTimer be reset to 0 here?", "author": "kevinushey", "createdAt": "2020-07-28T19:48:31Z", "path": "src/gwt/panmirror/src/editor/src/optional/ace/render_queue.ts", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * render_queue.ts\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+import { CodeBlockNodeView } from './ace';\n+\n+/**\n+ * Represents a queue of Ace editor instances that are rendered asynchronously.\n+ */\n+export class AceRenderQueue {\n+  private readonly renderQueue: CodeBlockNodeView[] = [];\n+\n+  private renderCompleted: boolean = false;\n+  private renderTimer: number = 0;\n+  private container?: HTMLElement;\n+  private needsSort: boolean = true;\n+  private bypass: number = 5;\n+  private observer?: IntersectionObserver;\n+  private visible: boolean = true;\n+\n+  /**\n+   * Sets (or replaces) the scroll container hosting the render queue. The\n+   * scroll container is used to prioritize the queue (i.e. objects in the\n+   * viewport or close to it are to be given more priority).\n+   * \n+   * @param container The HTML element of the scroll container\n+   */\n+  public setContainer(container: HTMLElement) {\n+\n+    // Handler for scroll events in the container\n+    const handleScroll = (evt: Event) => {\n+      // Whenever a scroll event occurs, we need to re-sort the queue so that\n+      // objects in or closest to the viewport are given priority.\n+      this.needsSort = true;\n+\n+      // If we don't think we're visible but we're scrolling and have height,\n+      // then we are in fact visible. (This catches a case where the\n+      // intsersection observer created below doesn't fire for visiblity\n+      // changes.)\n+      if (!this.visible && this.container && this.container.offsetHeight > 0) {\n+        this.visible = true;\n+        this.processRenderQueue();\n+      }\n+    };\n+\n+    // Skip if we're already looking at this container\n+    if (this.container === container) {\n+      return;\n+    }\n+\n+    // Clean up handlers on any previous container\n+    if (this.container) {\n+      this.container.removeEventListener(\"scroll\", handleScroll);\n+    }\n+    if (this.observer) {\n+      this.observer.disconnect();\n+    }\n+\n+    this.container = container;\n+\n+    // Create intersection observer to ensure that we don't needlessly churn\n+    // through renders while offscreen.\n+    this.observer = new IntersectionObserver((entries: IntersectionObserverEntry[]) => {\n+      for (const entry of entries) {\n+        if (entry.isIntersecting && !this.visible) {\n+          // We just became visible; process the render queue now.\n+          this.visible = true;\n+          this.processRenderQueue();\n+        }\n+        if (!entry.isIntersecting && this.visible) {\n+          // We just lost visibility; end processing of the render queue. (Note\n+          // that we only do this when connected to the DOM as another reason\n+          // the element can become invisible is ProseMirror swapping it out\n+          // internally.)\n+          if (this.container?.parentElement) {\n+            this.visible = false;\n+            if (this.renderTimer > 0) {\n+              window.clearTimeout(this.renderTimer);", "originalCommit": "65bae8bca3a98ba65a827f6a76a0efe7ae426a44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2MzQyMw==", "url": "https://github.com/rstudio/rstudio/pull/7468#discussion_r461863423", "bodyText": "It should, I've made that change.", "author": "jmcphers", "createdAt": "2020-07-28T20:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzNDMwNQ=="}], "type": "inlineReview"}, {"oid": "41f66205b9d1aac10dc50a1fb2c27b26d02abdea", "url": "https://github.com/rstudio/rstudio/commit/41f66205b9d1aac10dc50a1fb2c27b26d02abdea", "message": "clear render timer consistently", "committedDate": "2020-07-28T20:37:37Z", "type": "commit"}, {"oid": "39211cf622d6d7b197d217f1057fcb96aa034fe2", "url": "https://github.com/rstudio/rstudio/commit/39211cf622d6d7b197d217f1057fcb96aa034fe2", "message": "Merge remote-tracking branch 'origin/master' into feature/ace-visual-perf-v2", "committedDate": "2020-07-28T20:43:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5MjkxMg==", "url": "https://github.com/rstudio/rstudio/pull/7468#discussion_r462192912", "bodyText": "When the underlying Ace editor is actually created, do we need to forward the selection in the case that the user has managed to logically get the selection there before it has been rendered?", "author": "jjallaire", "createdAt": "2020-07-29T10:16:48Z", "path": "src/gwt/panmirror/src/editor/src/optional/ace/ace.ts", "diffHunk": "@@ -367,6 +252,9 @@ class CodeBlockNodeView implements NodeView {\n   }\n \n   public setSelection(anchor: number, head: number) {\n+    if (!this.aceEditor || !this.editSession) {", "originalCommit": "39211cf622d6d7b197d217f1057fcb96aa034fe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}