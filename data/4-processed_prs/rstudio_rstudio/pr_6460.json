{"pr_number": 6460, "pr_title": "Make openssl verification work on windows by importing windows cert store certificates", "pr_createdAt": "2020-03-12T19:42:03Z", "pr_url": "https://github.com/rstudio/rstudio/pull/6460", "timeline": [{"oid": "c22ee9fff8f7bb5fc885bfac6fd451b6eb4f74b3", "url": "https://github.com/rstudio/rstudio/commit/c22ee9fff8f7bb5fc885bfac6fd451b6eb4f74b3", "message": "Make openssl verification work on windows by importing windows cert store certificates", "committedDate": "2020-03-12T19:40:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyNDM1Ng==", "url": "https://github.com/rstudio/rstudio/pull/6460#discussion_r391924356", "bodyText": "If I understand correctly, this line is un-necessary. Given the docs here (https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-certenumcertificatesinstore):\n\nThe returned pointer is freed when passed as the pPrevCertContext parameter on a subsequent call. Otherwise, the pointer must be freed by calling CertFreeCertificateContext. A non-NULL pPrevCertContext passed to CertEnumCertificatesInStore is always freed even for an error.\n\nSo calling CertEnumCertificatesInStore() as above should automatically free these contexts.", "author": "kevinushey", "createdAt": "2020-03-12T21:53:14Z", "path": "src/cpp/core/include/core/http/TcpIpAsyncClientSsl.hpp", "diffHunk": "@@ -154,6 +183,56 @@ class TcpIpAsyncClientSsl\n       return util::isSslShutdownError(ec);\n    }\n \n+#ifdef _WIN32\n+   struct WindowsCertificateStore\n+   {\n+      WindowsCertificateStore()\n+      {\n+         // load certificates from important stores\n+         LPCSTR stores[] = {\"ROOT\", \"CA\"};\n+         for (const LPCSTR& store : stores)\n+         {\n+             HCERTSTORE hStore = nullptr;\n+             hStore = CertOpenSystemStore(NULL, store);\n+             if (!hStore)\n+             {\n+                LOG_ERROR_MESSAGE(\"Could not open certificate store\");\n+                return;\n+             }\n+\n+             PCCERT_CONTEXT pContext = nullptr;\n+             while (pContext = CertEnumCertificatesInStore(hStore, pContext))\n+             {\n+                // convert the certificate returned from the Windows store into a\n+                // format that OpenSSL can understand\n+                X509* x509 = nullptr;\n+                x509 = d2i_X509(nullptr,\n+                                const_cast<const unsigned char**>(\n+                                   reinterpret_cast<const unsigned char* const*>(&pContext->pbCertEncoded)),\n+                                pContext->cbCertEncoded);\n+                if (x509)\n+                   certificates.push_back(x509);\n+             }\n+\n+             CertFreeCertificateContext(pContext);", "originalCommit": "c22ee9fff8f7bb5fc885bfac6fd451b6eb4f74b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMDA0OQ==", "url": "https://github.com/rstudio/rstudio/pull/6460#discussion_r391930049", "bodyText": "One thing that's not clear to me -- does this need to be aware of how the certificate is encoded? (that is, dwCertEncodingType).", "author": "kevinushey", "createdAt": "2020-03-12T22:01:59Z", "path": "src/cpp/core/include/core/http/TcpIpAsyncClientSsl.hpp", "diffHunk": "@@ -154,6 +183,56 @@ class TcpIpAsyncClientSsl\n       return util::isSslShutdownError(ec);\n    }\n \n+#ifdef _WIN32\n+   struct WindowsCertificateStore\n+   {\n+      WindowsCertificateStore()\n+      {\n+         // load certificates from important stores\n+         LPCSTR stores[] = {\"ROOT\", \"CA\"};\n+         for (const LPCSTR& store : stores)\n+         {\n+             HCERTSTORE hStore = nullptr;\n+             hStore = CertOpenSystemStore(NULL, store);\n+             if (!hStore)\n+             {\n+                LOG_ERROR_MESSAGE(\"Could not open certificate store\");\n+                return;\n+             }\n+\n+             PCCERT_CONTEXT pContext = nullptr;\n+             while (pContext = CertEnumCertificatesInStore(hStore, pContext))\n+             {\n+                // convert the certificate returned from the Windows store into a\n+                // format that OpenSSL can understand\n+                X509* x509 = nullptr;\n+                x509 = d2i_X509(nullptr,", "originalCommit": "c22ee9fff8f7bb5fc885bfac6fd451b6eb4f74b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMzg3Nw==", "url": "https://github.com/rstudio/rstudio/pull/6460#discussion_r391933877", "bodyText": "Also from https://linux.die.net/man/3/d2i_x509:\n\nIf the call is successful *in is incremented to the byte following the parsed data.\n\nGiven that it tries to mutate this argument I wonder if we should copy it (pbCertEncoded) to our own temporary variable just to be safe? This also gives us an opportunity to case it as appropriate.", "author": "kevinushey", "createdAt": "2020-03-12T22:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MTAyMA==", "url": "https://github.com/rstudio/rstudio/pull/6460#discussion_r392281020", "bodyText": "@kevinushey The windows cert is always in an ASN encoding, so as far as I can tell we do not need to worry about dwCertEncodingType.", "author": "kfeinauer", "createdAt": "2020-03-13T14:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMDA0OQ=="}], "type": "inlineReview"}, {"oid": "57a0b588dcd4fa1a6bd19c37391f516dc184035c", "url": "https://github.com/rstudio/rstudio/commit/57a0b588dcd4fa1a6bd19c37391f516dc184035c", "message": "Code review feedback", "committedDate": "2020-03-13T15:05:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0NzYxMQ==", "url": "https://github.com/rstudio/rstudio/pull/6460#discussion_r392347611", "bodyText": "If there are a bunch of certificates in the Windows store and a couple fail to be added to the OpenSSL cert store, will the logs indicate which ones? (looks like they won't unless it's in the error object somewhere that I missed)", "author": "jmcphers", "createdAt": "2020-03-13T16:46:43Z", "path": "src/cpp/core/include/core/http/TcpIpAsyncClientSsl.hpp", "diffHunk": "@@ -62,6 +69,28 @@ class TcpIpAsyncClientSsl\n             if (ec)\n                LOG_ERROR(Error(ec, ERROR_LOCATION));\n          }\n+\n+      #ifdef _WIN32\n+         // on Windows, OpenSSL does not support loading certificates from the Windows certificate store\n+         // because of this, each time we need to verify certificates, we initialize\n+         // all certificates individually with OpenSSL\n+         const WindowsCertificateStore& certStore = getCertificateStore();\n+         for (const auto& cert : certStore.certificates)\n+         {\n+            if (X509_STORE* store = SSL_CTX_get_cert_store(sslContext_.native_handle()))\n+            {\n+               if (::X509_STORE_add_cert(store, cert) != 1)\n+               {\n+                  boost::system::error_code ec = rstudio_boost::system::error_code(\n+                              static_cast<int>(::ERR_get_error()),\n+                              boost::asio::error::get_ssl_category());\n+                  Error error(ec, ERROR_LOCATION);\n+                  error.addProperty(\"Description\", \"Could not add Windows certificate to OpenSSL cert store\");", "originalCommit": "57a0b588dcd4fa1a6bd19c37391f516dc184035c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MDk5Mg==", "url": "https://github.com/rstudio/rstudio/pull/6460#discussion_r392350992", "bodyText": "No. This would be difficult to do correctly (would need a lot of dev time + testing to figure out how to extract the CA name to add to the log information, was not easy for me to figure out looking at openssl documentation), which indeed makes this log error less useful than I wanted it to be. However, I figured leaving it in would be worth something, as it could possibly help us troubleshoot an install in the wild that isn't validating properly.", "author": "kfeinauer", "createdAt": "2020-03-13T16:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0NzYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjY2OQ==", "url": "https://github.com/rstudio/rstudio/pull/6460#discussion_r392352669", "bodyText": "Actually I'll look into this - found an article talking about this.", "author": "kfeinauer", "createdAt": "2020-03-13T16:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0NzYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjY3Mg==", "url": "https://github.com/rstudio/rstudio/pull/6460#discussion_r392352672", "bodyText": "Okay, I was hoping it would be more straightforward!", "author": "jmcphers", "createdAt": "2020-03-13T16:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0NzYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0ODUzMA==", "url": "https://github.com/rstudio/rstudio/pull/6460#discussion_r392348530", "bodyText": "Nit: \"Meyer's\" singleton", "author": "jmcphers", "createdAt": "2020-03-13T16:48:06Z", "path": "src/cpp/core/include/core/http/TcpIpAsyncClientSsl.hpp", "diffHunk": "@@ -154,6 +183,51 @@ class TcpIpAsyncClientSsl\n       return util::isSslShutdownError(ec);\n    }\n \n+#ifdef _WIN32\n+   struct WindowsCertificateStore\n+   {\n+      WindowsCertificateStore()\n+      {\n+         // load certificates from important stores\n+         LPCSTR stores[] = {\"ROOT\", \"CA\"};\n+         for (const LPCSTR& store : stores)\n+         {\n+             HCERTSTORE hStore = CertOpenSystemStore(NULL, store);\n+             if (!hStore)\n+             {\n+                LOG_ERROR_MESSAGE(\"Could not open certificate store\");\n+                return;\n+             }\n+\n+             PCCERT_CONTEXT pContext = nullptr;\n+             while (pContext = CertEnumCertificatesInStore(hStore, pContext))\n+             {\n+                // convert the certificate returned from the Windows store into a\n+                // format that OpenSSL can understand\n+                const BYTE* certPtr = pContext->pbCertEncoded;\n+                X509* x509 = d2i_X509(nullptr, &certPtr, pContext->cbCertEncoded);\n+                if (x509)\n+                   certificates.push_back(x509);\n+             }\n+\n+             CertCloseStore(hStore, 0);\n+         }\n+      }\n+\n+      // certificate pointers - these are intentionally leaked\n+      // as they need to be available for the entire run of the program\n+      std::vector<X509*> certificates;\n+   };\n+\n+   static const WindowsCertificateStore& getCertificateStore()\n+   {\n+       // Myers singleton - guarantees this is thread safe", "originalCommit": "57a0b588dcd4fa1a6bd19c37391f516dc184035c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a18a24aec5fbdb32d844ce6ffad9ba4f9a36eba1", "url": "https://github.com/rstudio/rstudio/commit/a18a24aec5fbdb32d844ce6ffad9ba4f9a36eba1", "message": "Code review feedback", "committedDate": "2020-03-13T16:53:22Z", "type": "commit"}, {"oid": "09688e052d428c55341fbc8d63370f3077cb11e6", "url": "https://github.com/rstudio/rstudio/commit/09688e052d428c55341fbc8d63370f3077cb11e6", "message": "Code review feedback - log the subject name of any certs that fail to add", "committedDate": "2020-03-13T17:19:46Z", "type": "commit"}]}