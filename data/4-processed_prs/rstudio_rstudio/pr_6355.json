{"pr_number": 6355, "pr_title": "Ensure packages are installed in correct order to eliminate duplication", "pr_createdAt": "2020-02-27T22:36:26Z", "pr_url": "https://github.com/rstudio/rstudio/pull/6355", "timeline": [{"oid": "b537481078abcbe25c3f61a9068d931f0c359728", "url": "https://github.com/rstudio/rstudio/commit/b537481078abcbe25c3f61a9068d931f0c359728", "message": "stubs and outline for capturing deps (WIP)", "committedDate": "2020-02-25T18:43:43Z", "type": "commit"}, {"oid": "c27f2889e980fe2897ee2d275b227ecd41b22444", "url": "https://github.com/rstudio/rstudio/commit/c27f2889e980fe2897ee2d275b227ecd41b22444", "message": "add test for simple topological sorting", "committedDate": "2020-02-25T23:19:39Z", "type": "commit"}, {"oid": "65f4ff98845829e0119987dba1be7ccc64c62ff5", "url": "https://github.com/rstudio/rstudio/commit/65f4ff98845829e0119987dba1be7ccc64c62ff5", "message": "map sorted packages to full dependency records", "committedDate": "2020-02-26T00:16:29Z", "type": "commit"}, {"oid": "2c89ea1282c1542129d97176aa5d1b52816fcfc1", "url": "https://github.com/rstudio/rstudio/commit/2c89ea1282c1542129d97176aa5d1b52816fcfc1", "message": "complete R side of dependency graph resolution", "committedDate": "2020-02-26T20:28:40Z", "type": "commit"}, {"oid": "e1b48c8404b066895e3edade4a1e31a238aef923", "url": "https://github.com/rstudio/rstudio/commit/e1b48c8404b066895e3edade4a1e31a238aef923", "message": "add user pref and generate appropriate installation script", "committedDate": "2020-02-27T19:55:16Z", "type": "commit"}, {"oid": "3e6bee165929cb2bdaf24b31b15116c9aa20a7e1", "url": "https://github.com/rstudio/rstudio/commit/3e6bee165929cb2bdaf24b31b15116c9aa20a7e1", "message": "omit dependencies already installed", "committedDate": "2020-02-27T22:13:03Z", "type": "commit"}, {"oid": "fb938ec9ed4ff811bf22ae28d7cc7d623f72f7c3", "url": "https://github.com/rstudio/rstudio/commit/fb938ec9ed4ff811bf22ae28d7cc7d623f72f7c3", "message": "use renv to install packages even in combined mode", "committedDate": "2020-02-27T22:25:13Z", "type": "commit"}, {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "url": "https://github.com/rstudio/rstudio/commit/ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "message": "balance parens", "committedDate": "2020-02-27T22:38:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3NzY2OQ==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385477669", "bodyText": "Double-checking: if a package is installed, but its dependencies are not installed (or not up-to-date), those dependencies would still get installed. Is that correct?", "author": "kevinushey", "createdAt": "2020-02-28T02:24:27Z", "path": "src/cpp/session/modules/SessionDependencies.R", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# SessionDependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+# Topographically sorts a list of packages (nodes) by their dependencies (edges). Note that this is\n+# not meant to be a general-purpose topo sort algorithm, and that it returns packages in the correct\n+# installation order, which is the exact reverse of traditional topological order. For example,\n+# given packages with dependencies a -> b -> c, we would want to install packages in the order \"c\",\n+# \"b\", and then \"a\".\n+.rs.addFunction(\"topoSortPackages\", function(nodes, edges) {\n+   # List of sorted packages\n+   sorted <- c()\n+\n+   # All nodes are unvisited to begin with\n+   visited <- c()\n+\n+   # Define recursive descent function for dependencies\n+   visit <- function(node, stack) {\n+      if (node %in% visited) {\n+         return()\n+      }\n+      if (node %in% stack) {\n+         # We visited this node while visiting itself; this is a dependency loop.\n+         stop(\"Package dependency graph is not a directed acyclic graph.\")\n+      }\n+\n+      # Visit all the edges of this node\n+      stack <- c(stack, node)\n+      for (edge in edges) {\n+         if (identical(edge$from, node)) {\n+            visit(edge$to, stack)\n+         }\n+      }\n+\n+      visited <<- c(visited, node)\n+      sorted <<- c(sorted, node)\n+   }\n+\n+   # Keep visiting unvisited nodes until we have visited all of them\n+   while (length(visited) < length(nodes)) {\n+      for (node in nodes) {\n+         if (!(node %in% visited)) {\n+            visit(node, c())\n+            break\n+         }\n+      }\n+   }\n+\n+   # Return topologically sorted list\n+   sorted\n+})\n+\n+.rs.addFunction(\"expandPkgDependencies\", function(dependencies) {\n+   .rs.expandDependencies(available.packages(), installed.packages(), dependencies)\n+})\n+\n+.rs.addFunction(\"expandDependencies\", function(available, installed, dependencies) {\n+   # A list of nodes (package names) to be installed\n+   nodes <- c()\n+\n+   # A list of details for packages to be installed\n+   packages <- dependencies\n+\n+   # A vector of lists, with \"from\" and \"to\" named elements giving the dependencies\n+   edges <- list()\n+\n+   # Get the dependencies of each package\n+   for (dep in dependencies) {\n+      # Add the package itself to the list of nodes\n+      nodes <- c(nodes, dep$name)\n+   }\n+\n+   # Look for dependencies of each package\n+   for (dep in dependencies) {\n+      # Dependencies are discovered from these three fields\n+      fields <- c(\"Depends\", \"Imports\", \"LinkingTo\")\n+      for (field in fields) {\n+         # Read contents for field (ignore if no contents)\n+         contents <- available[dep$name, field]\n+         if (!is.character(contents))\n+            next\n+\n+         # Split into a list of individual package names, using comma/whitespace as a delimiter\n+         prereqs <- strsplit(contents, \"\\\\s*,\\\\s*\")[[1]]\n+\n+         # Parse the package names into groups:\n+         # 1. The package name\n+         # 2. The package's requirements\n+         # 3. The package's version\n+         parsed <- regexec(\"([a-zA-Z0-9._]+)(?:\\\\s*\\\\(([><=]+)\\\\s*([0-9.-]+)\\\\))?\", prereqs)\n+         matches <- regmatches(prereqs, parsed)\n+\n+         # Decompose matches into additional nodes\n+         for (match in matches) {\n+            if (length(match) < 2)\n+               next\n+\n+            # Extract package name from regex result\n+            pkgName <- match[[2]]\n+\n+            # Ignore packages that don't have an entry in the availability list\n+            if (!(pkgName %in% rownames(available)))\n+                next\n+\n+            # Append to node list if we don't know about it already...\n+            if (!pkgName %in% nodes) {\n+               nodes <- c(nodes, pkgName)\n+\n+               # ... and it isn't already installed.\n+               if (!(pkgName %in% rownames(installed)))", "originalCommit": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5Mjg3MQ==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385492871", "bodyText": "Also, IIUC this doesn't check whether the installed package is new enough (e.g. pkg 1.0.0 is installed but 1.0.1 is required)", "author": "kevinushey", "createdAt": "2020-02-28T03:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3NzY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcwNDU3MA==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r386704570", "bodyText": "if a package is installed, but its dependencies are not installed (or not up-to-date), those dependencies would still get installed. Is that correct?\n\nYep.\n\nthis doesn't check whether the installed package is new enough (e.g. pkg 1.0.0 is installed but 1.0.1 is required)\n\nThat's true. I'll add a test and check for that.", "author": "jmcphers", "createdAt": "2020-03-02T23:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3NzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3ODUzNA==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385478534", "bodyText": "Nit: setting this explicitly will fail on Linux and may fail on macOS:\n> install.packages(\"digest\", type = \"both\")\nInstalling package into '/root/R/x86_64-pc-linux-gnu-library/3.4'\n(as 'lib' is unspecified)\nError in install.packages(\"digest\", type = \"both\") :\n  type == \"both\" can only be used on Windows or a CRAN build for macOS\n\nI'd recommend just leaving this unset / to the default value.", "author": "kevinushey", "createdAt": "2020-02-28T02:28:16Z", "path": "src/cpp/session/modules/SessionDependencies.cpp", "diffHunk": "@@ -381,6 +463,10 @@ Error installDependencies(const json::JsonRpcRequest& request,\n             {\n                script += \"options(pkgType = 'source'); \";\n             }\n+            else\n+            {\n+               script += \"options(pkgType = 'both'); \";", "originalCommit": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMDU5MQ==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r386730591", "bodyText": "Done!", "author": "jmcphers", "createdAt": "2020-03-03T00:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3ODUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3ODk1Mg==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385478952", "bodyText": "Nit: the result of available.packages() is normally a matrix rather than a data frame, and I don't think we explicitly convert the matrix to a data.frame when we use it. Would be worth testing with a matrix just to be sure we're mocking everything as expected.", "author": "kevinushey", "createdAt": "2020-02-28T02:30:21Z", "path": "src/cpp/tests/testthat/test-dependencies.R", "diffHunk": "@@ -0,0 +1,115 @@\n+#\n+# test-dependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+context(\"dependencies\")\n+\n+test_that(\"simple topological sort works\", {\n+   # unsorted nodes\n+   nodes <- c(\"b\", \"a\", \"c\")\n+\n+   # edges a -> b -> c\n+   edges <- list(\n+      list(from = \"a\", to = \"b\"),\n+      list(from = \"b\", to = \"c\"))\n+   \n+   # in this configuration we'd expect to install package c, then package b, then package a\n+   expect_equal(.rs.topoSortPackages(nodes, edges), \n+                c(\"c\", \"b\", \"a\"))\n+})\n+\n+test_that(\"simple expansion and sorting is done correctly\", {\n+   # simulation of available.packages for a simple set of packages, foo -> bar -> baz\n+   available <- data.frame(", "originalCommit": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMDkwNQ==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r386730905", "bodyText": "I've switched to matrices for the test data.", "author": "jmcphers", "createdAt": "2020-03-03T00:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3ODk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MTUyNA==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385491524", "bodyText": "Could we also add a test case where multiple packages depend on the same package?", "author": "kevinushey", "createdAt": "2020-02-28T03:28:53Z", "path": "src/cpp/tests/testthat/test-dependencies.R", "diffHunk": "@@ -0,0 +1,115 @@\n+#\n+# test-dependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+context(\"dependencies\")\n+\n+test_that(\"simple topological sort works\", {\n+   # unsorted nodes\n+   nodes <- c(\"b\", \"a\", \"c\")\n+\n+   # edges a -> b -> c\n+   edges <- list(\n+      list(from = \"a\", to = \"b\"),\n+      list(from = \"b\", to = \"c\"))\n+   \n+   # in this configuration we'd expect to install package c, then package b, then package a\n+   expect_equal(.rs.topoSortPackages(nodes, edges), \n+                c(\"c\", \"b\", \"a\"))\n+})\n+\n+test_that(\"simple expansion and sorting is done correctly\", {\n+   # simulation of available.packages for a simple set of packages, foo -> bar -> baz\n+   available <- data.frame(\n+         Package   = c(\"foo\",                      \"bar\", \"baz\"),\n+         Version   = c(\"1.0\",                      \"1.1\", \"2.0\"),\n+         Depends   = c(\"R (>= 3.2), bar (>= 1.1)\",  NA,    NA),\n+         Imports   = c(NA,                          \"baz\", NA),\n+         LinkingTo = c(NA,                          NA,    NA),\n+         stringsAsFactors = FALSE)\n+   rownames(available) <- available[[1]]\n+\n+   # simulation of the dependencies we want to install; just one package\n+   dependencies <- list(list(\n+         name     = \"foo\",\n+         location = \"cran\",\n+         version  = \"1.0\",\n+         source   = FALSE))\n+\n+   result <- .rs.expandDependencies(available, data.frame(), dependencies)\n+\n+   expect_equal(!!result, list(\n+         list(name     = \"bar\",\n+              location = \"cran\",\n+              version  = \"1.1\",\n+              source   = FALSE),\n+         list(name     = \"foo\",\n+              location = \"cran\",\n+              version  = \"1.0\",\n+              source   = FALSE)))\n+})", "originalCommit": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNDMzMg==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r386734332", "bodyText": "Done. (It worked out of the box, thankfully!)", "author": "jmcphers", "createdAt": "2020-03-03T00:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MTUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MTc5MQ==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385491791", "bodyText": "I think we should test for is.na() here as well (since this could be NA_character_)", "author": "kevinushey", "createdAt": "2020-02-28T03:30:13Z", "path": "src/cpp/session/modules/SessionDependencies.R", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# SessionDependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+# Topographically sorts a list of packages (nodes) by their dependencies (edges). Note that this is\n+# not meant to be a general-purpose topo sort algorithm, and that it returns packages in the correct\n+# installation order, which is the exact reverse of traditional topological order. For example,\n+# given packages with dependencies a -> b -> c, we would want to install packages in the order \"c\",\n+# \"b\", and then \"a\".\n+.rs.addFunction(\"topoSortPackages\", function(nodes, edges) {\n+   # List of sorted packages\n+   sorted <- c()\n+\n+   # All nodes are unvisited to begin with\n+   visited <- c()\n+\n+   # Define recursive descent function for dependencies\n+   visit <- function(node, stack) {\n+      if (node %in% visited) {\n+         return()\n+      }\n+      if (node %in% stack) {\n+         # We visited this node while visiting itself; this is a dependency loop.\n+         stop(\"Package dependency graph is not a directed acyclic graph.\")\n+      }\n+\n+      # Visit all the edges of this node\n+      stack <- c(stack, node)\n+      for (edge in edges) {\n+         if (identical(edge$from, node)) {\n+            visit(edge$to, stack)\n+         }\n+      }\n+\n+      visited <<- c(visited, node)\n+      sorted <<- c(sorted, node)\n+   }\n+\n+   # Keep visiting unvisited nodes until we have visited all of them\n+   while (length(visited) < length(nodes)) {\n+      for (node in nodes) {\n+         if (!(node %in% visited)) {\n+            visit(node, c())\n+            break\n+         }\n+      }\n+   }\n+\n+   # Return topologically sorted list\n+   sorted\n+})\n+\n+.rs.addFunction(\"expandPkgDependencies\", function(dependencies) {\n+   .rs.expandDependencies(available.packages(), installed.packages(), dependencies)\n+})\n+\n+.rs.addFunction(\"expandDependencies\", function(available, installed, dependencies) {\n+   # A list of nodes (package names) to be installed\n+   nodes <- c()\n+\n+   # A list of details for packages to be installed\n+   packages <- dependencies\n+\n+   # A vector of lists, with \"from\" and \"to\" named elements giving the dependencies\n+   edges <- list()\n+\n+   # Get the dependencies of each package\n+   for (dep in dependencies) {\n+      # Add the package itself to the list of nodes\n+      nodes <- c(nodes, dep$name)\n+   }\n+\n+   # Look for dependencies of each package\n+   for (dep in dependencies) {\n+      # Dependencies are discovered from these three fields\n+      fields <- c(\"Depends\", \"Imports\", \"LinkingTo\")\n+      for (field in fields) {\n+         # Read contents for field (ignore if no contents)\n+         contents <- available[dep$name, field]\n+         if (!is.character(contents))", "originalCommit": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNDk3OA==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r386734978", "bodyText": "Done!", "author": "jmcphers", "createdAt": "2020-03-03T00:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MTc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MjY1Ng==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385492656", "bodyText": "Nit: do we need to be careful about the type argument here? Since we might want to install some packages from sources, and others from binaries, and the result of available.packages(type = \"source\") versus available.packages(type = \"binary\") could differ.", "author": "kevinushey", "createdAt": "2020-02-28T03:34:25Z", "path": "src/cpp/session/modules/SessionDependencies.R", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# SessionDependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+# Topographically sorts a list of packages (nodes) by their dependencies (edges). Note that this is\n+# not meant to be a general-purpose topo sort algorithm, and that it returns packages in the correct\n+# installation order, which is the exact reverse of traditional topological order. For example,\n+# given packages with dependencies a -> b -> c, we would want to install packages in the order \"c\",\n+# \"b\", and then \"a\".\n+.rs.addFunction(\"topoSortPackages\", function(nodes, edges) {\n+   # List of sorted packages\n+   sorted <- c()\n+\n+   # All nodes are unvisited to begin with\n+   visited <- c()\n+\n+   # Define recursive descent function for dependencies\n+   visit <- function(node, stack) {\n+      if (node %in% visited) {\n+         return()\n+      }\n+      if (node %in% stack) {\n+         # We visited this node while visiting itself; this is a dependency loop.\n+         stop(\"Package dependency graph is not a directed acyclic graph.\")\n+      }\n+\n+      # Visit all the edges of this node\n+      stack <- c(stack, node)\n+      for (edge in edges) {\n+         if (identical(edge$from, node)) {\n+            visit(edge$to, stack)\n+         }\n+      }\n+\n+      visited <<- c(visited, node)\n+      sorted <<- c(sorted, node)\n+   }\n+\n+   # Keep visiting unvisited nodes until we have visited all of them\n+   while (length(visited) < length(nodes)) {\n+      for (node in nodes) {\n+         if (!(node %in% visited)) {\n+            visit(node, c())\n+            break\n+         }\n+      }\n+   }\n+\n+   # Return topologically sorted list\n+   sorted\n+})\n+\n+.rs.addFunction(\"expandPkgDependencies\", function(dependencies) {\n+   .rs.expandDependencies(available.packages(), installed.packages(), dependencies)", "originalCommit": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNTYxOA==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r386735618", "bodyText": "Maybe we can just get away with using both here? Let's discuss realtime.", "author": "jmcphers", "createdAt": "2020-03-03T00:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MjY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NTMwMA==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385495300", "bodyText": "What happens if a CRAN package depends on a CRAN source package (ie: something installed in the next step)?", "author": "kevinushey", "createdAt": "2020-02-28T03:48:59Z", "path": "src/cpp/session/modules/SessionDependencies.cpp", "diffHunk": "@@ -291,67 +326,114 @@ Error unsatisfiedDependencies(const json::JsonRpcRequest& request,\n    return Success();\n }\n \n-Error installDependencies(const json::JsonRpcRequest& request,\n-                          json::JsonRpcResponse* pResponse)\n+// Builds an installation script which will install all the dependencies at once. \n+std::string buildCombinedInstallScript(const std::vector<Dependency>& deps)\n {\n-   // get list of dependencies\n-   json::Array depsJson;\n-   std::string context;\n-   Error error = json::readParams(request.params, &context, &depsJson);\n-   if (error)\n-      return error;\n-   std::vector<Dependency> deps = dependenciesFromJson(depsJson);\n+   bool isRenv = module_context::isRenvActive();\n+   std::vector<std::string> cranPackages;\n+   std::vector<std::string> cranSourcePackages;\n+   std::vector<std::string> embeddedPackages;\n+   std::string cmd;\n+\n+   // Sort the dependencies into CRAN packages installed with defaults, CRAN packages explicitly\n+   // installed as source, and embedded packages.\n+   for (const Dependency& dep: deps)\n+   {\n+      if (dep.location == kCRANPackageDependency)\n+      {\n+         if (dep.source)\n+            cranSourcePackages.push_back(\"'\" + dep.name + \"'\");\n+         else\n+            cranPackages.push_back(\"'\" + dep.name + \"'\");\n+      }\n+      else if (dep.location == kEmbeddedPackageDependency)\n+      {\n+         EmbeddedPackage pkg = embeddedPackageInfo(dep.name);\n+         if (!pkg.empty())\n+            embeddedPackages.push_back(pkg.archivePath);\n+      }\n+   }\n \n-   // Ensure we have a writeable user library\n-   error = r::exec::RFunction(\".rs.ensureWriteableUserLibrary\").call();\n-   if (error)\n-      return error;\n+   // Install the CRAN packages with a single call\n+   if (!cranPackages.empty())", "originalCommit": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNjM0MA==", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r386736340", "bodyText": "A good question! That would theoretically be a problem, but this is logic copied wholesale from 1.2 in an attempt to reduce risk, and so my inclination is to leave it undisturbed unless we have evidence it's causing real issues (practically speaking we rarely insist on source packages so I don't think this has happened often, if ever).", "author": "jmcphers", "createdAt": "2020-03-03T00:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NTMwMA=="}], "type": "inlineReview"}, {"oid": "67adb796e70f7e8b2807224d894c261448197595", "url": "https://github.com/rstudio/rstudio/commit/67adb796e70f7e8b2807224d894c261448197595", "message": "Merge remote-tracking branch 'origin/master' into bugfix/package-deps-topo", "committedDate": "2020-03-02T23:02:50Z", "type": "commit"}, {"oid": "0d8b7ed40b64b50a5669179ee3cc9d44e41ec021", "url": "https://github.com/rstudio/rstudio/commit/0d8b7ed40b64b50a5669179ee3cc9d44e41ec021", "message": "use a matrix for more realistic tests", "committedDate": "2020-03-02T23:29:37Z", "type": "commit"}, {"oid": "9a2343b6eeb99bf59aba3752dbee19b8a84a95db", "url": "https://github.com/rstudio/rstudio/commit/9a2343b6eeb99bf59aba3752dbee19b8a84a95db", "message": "ensure dependencies replaced when too old", "committedDate": "2020-03-03T00:17:17Z", "type": "commit"}, {"oid": "7042725efb4a36f6d1a2e773ee241a6187fee236", "url": "https://github.com/rstudio/rstudio/commit/7042725efb4a36f6d1a2e773ee241a6187fee236", "message": "save and restore default renv package install type", "committedDate": "2020-03-03T00:32:51Z", "type": "commit"}, {"oid": "1fad551295e474809c407c35300a6dbfad74293e", "url": "https://github.com/rstudio/rstudio/commit/1fad551295e474809c407c35300a6dbfad74293e", "message": "add a test for multiple dependencies on one package", "committedDate": "2020-03-03T00:33:08Z", "type": "commit"}, {"oid": "2861e2cccfccd3b6914d0d5bb05b07639fe52092", "url": "https://github.com/rstudio/rstudio/commit/2861e2cccfccd3b6914d0d5bb05b07639fe52092", "message": "test contents for NA missing values", "committedDate": "2020-03-03T00:35:15Z", "type": "commit"}, {"oid": "3f30896b3f0ec142555af6fc2a07fdb3f3dc8567", "url": "https://github.com/rstudio/rstudio/commit/3f30896b3f0ec142555af6fc2a07fdb3f3dc8567", "message": "explicitly get source and binary packages on Win/MacOS", "committedDate": "2020-03-03T18:42:36Z", "type": "commit"}]}