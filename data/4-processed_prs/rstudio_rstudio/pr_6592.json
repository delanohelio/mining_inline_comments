{"pr_number": 6592, "pr_title": "Implement custom fonts for RStudio Server", "pr_createdAt": "2020-04-04T03:34:04Z", "pr_url": "https://github.com/rstudio/rstudio/pull/6592", "timeline": [{"oid": "e83eb0b91225a4ee013e1722d3f3b5a4fad0d9a1", "url": "https://github.com/rstudio/rstudio/commit/e83eb0b91225a4ee013e1722d3f3b5a4fad0d9a1", "message": "implement scanning for installed fonts and CSS gen", "committedDate": "2020-04-02T23:56:26Z", "type": "commit"}, {"oid": "d47e46ab8db52736d3698cde674c92e5c9eb61f7", "url": "https://github.com/rstudio/rstudio/commit/d47e46ab8db52736d3698cde674c92e5c9eb61f7", "message": "get installed fonts via RPC", "committedDate": "2020-04-03T00:49:54Z", "type": "commit"}, {"oid": "2048ae94ea20bfc8f1f1611528bff709e640a399", "url": "https://github.com/rstudio/rstudio/commit/2048ae94ea20bfc8f1f1611528bff709e640a399", "message": "add pref for server font", "committedDate": "2020-04-03T18:59:56Z", "type": "commit"}, {"oid": "9e2feda0c2ec881be03550adaad43bfcedd7b556", "url": "https://github.com/rstudio/rstudio/commit/9e2feda0c2ec881be03550adaad43bfcedd7b556", "message": "implement font preview in prefs pane", "committedDate": "2020-04-03T19:00:21Z", "type": "commit"}, {"oid": "48fb19ae1441d19dc7b190957c43dfcf9756aa8e", "url": "https://github.com/rstudio/rstudio/commit/48fb19ae1441d19dc7b190957c43dfcf9756aa8e", "message": "add font loading element to document root", "committedDate": "2020-04-03T20:04:06Z", "type": "commit"}, {"oid": "e931c6e4d7eaa55b834decfd37d820a337e2550a", "url": "https://github.com/rstudio/rstudio/commit/e931c6e4d7eaa55b834decfd37d820a337e2550a", "message": "load auxiliary styles in font CSS", "committedDate": "2020-04-03T22:36:13Z", "type": "commit"}, {"oid": "cadae8ad97fa39fc4ea0ab7d85ed7e3f9cccacd8", "url": "https://github.com/rstudio/rstudio/commit/cadae8ad97fa39fc4ea0ab7d85ed7e3f9cccacd8", "message": "allow for fonts defined by the browser", "committedDate": "2020-04-03T23:49:35Z", "type": "commit"}, {"oid": "397c74340081357f381504e5a42e9ba441ad24d6", "url": "https://github.com/rstudio/rstudio/commit/397c74340081357f381504e5a42e9ba441ad24d6", "message": "add some more choices for browser fonts", "committedDate": "2020-04-03T23:57:31Z", "type": "commit"}, {"oid": "81255eab3b0244e9bc4a68e241f859176dbbcbaf", "url": "https://github.com/rstudio/rstudio/commit/81255eab3b0244e9bc4a68e241f859176dbbcbaf", "message": "set web font in initial preview", "committedDate": "2020-04-04T00:04:41Z", "type": "commit"}, {"oid": "b41647c2e847271a1d3d866c6deffb7b79a89599", "url": "https://github.com/rstudio/rstudio/commit/b41647c2e847271a1d3d866c6deffb7b79a89599", "message": "install a README", "committedDate": "2020-04-04T02:37:21Z", "type": "commit"}, {"oid": "a4916c8d0438e41c7ed0457689eee88b6295ece0", "url": "https://github.com/rstudio/rstudio/commit/a4916c8d0438e41c7ed0457689eee88b6295ece0", "message": "allow fallback to previous behavior", "committedDate": "2020-04-04T03:04:17Z", "type": "commit"}, {"oid": "30015d99ca812c698d1cf9c4a045c9da56dff22f", "url": "https://github.com/rstudio/rstudio/commit/30015d99ca812c698d1cf9c4a045c9da56dff22f", "message": "clean up comments", "committedDate": "2020-04-04T03:18:25Z", "type": "commit"}, {"oid": "908763be85065ed01a28c9de9b0b17e235422ab2", "url": "https://github.com/rstudio/rstudio/commit/908763be85065ed01a28c9de9b0b17e235422ab2", "message": "add OS-specific fallback fonts", "committedDate": "2020-04-06T16:54:45Z", "type": "commit"}, {"oid": "78f7ad07c72be4eb64610ff94300d76ec9be6768", "url": "https://github.com/rstudio/rstudio/commit/78f7ad07c72be4eb64610ff94300d76ec9be6768", "message": "update NEWS", "committedDate": "2020-04-06T17:30:01Z", "type": "commit"}, {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e", "url": "https://github.com/rstudio/rstudio/commit/f30c294e4e083e2ced06934272e84c107fd8db5e", "message": "Merge remote-tracking branch 'origin/master' into feature/server-web-fonts", "committedDate": "2020-04-06T18:31:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NzMxNg==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404397316", "bodyText": "nit, update copyright year in header", "author": "gtritchie", "createdAt": "2020-04-06T21:24:00Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/themes/AceThemes.java", "diffHunk": "@@ -28,6 +28,7 @@\n ", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5ODI3NA==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404398274", "bodyText": "Might as well move this down to line 89 where it is first used (and only used inside that block as far as I can see).", "author": "gtritchie", "createdAt": "2020-04-06T21:25:54Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/themes/AceThemes.java", "diffHunk": "@@ -74,6 +78,33 @@ private void applyTheme(Document document, final AceTheme theme)\n       currentStyleEl.setRel(\"stylesheet\");\n       currentStyleEl.setId(linkId_);\n       currentStyleEl.setHref(themeUrl.toString());\n+      \n+      // In server mode, augment the theme with a font if we have one\n+      LinkElement fontEl = null;", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5OTM4OQ==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404399389", "bodyText": "fontId_ (and, actually, linkId_) could be local variables inside applyTheme().", "author": "gtritchie", "createdAt": "2020-04-06T21:28:08Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/themes/AceThemes.java", "diffHunk": "@@ -249,6 +280,8 @@ public void onError(ServerError error)\n    private ThemeServerOperations themeServerOperations_;\n    private final EventBus events_;\n    private final Provider<UserState> state_;\n+   private final Provider<UserPrefs> prefs_;\n    private final String linkId_ = \"rstudio-acethemes-linkelement\";\n+   private final String fontId_ = \"rstudio-fontelement\";", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMDA4Ng==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404400086", "bodyText": "Don't think this is used.", "author": "gtritchie", "createdAt": "2020-04-06T21:29:28Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/prefs/views/AppearancePreferencesPane.java", "diffHunk": "@@ -40,13 +43,19 @@\n import org.rstudio.studio.client.common.FileDialogs;\n import org.rstudio.studio.client.common.GlobalDisplay;\n import org.rstudio.studio.client.common.dependencies.DependencyManager;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n import org.rstudio.studio.client.workbench.WorkbenchContext;\n import org.rstudio.studio.client.workbench.prefs.model.UserPrefs;\n import org.rstudio.studio.client.workbench.prefs.model.UserState;\n import org.rstudio.studio.client.workbench.views.source.editors.text.themes.AceTheme;\n import org.rstudio.studio.client.workbench.views.source.editors.text.themes.AceThemes;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.themes.model.ThemeServerOperations;\n \n+import java.util.ArrayList;", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMTUwNg==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404401506", "bodyText": "Can leave out String  in new, i.e. new TreeSet<>();", "author": "gtritchie", "createdAt": "2020-04-06T21:32:30Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/prefs/views/AppearancePreferencesPane.java", "diffHunk": "@@ -617,16 +672,77 @@ public boolean execute()\n                return true;\n          \n             String[] fontList = fonts.split(\"\\\\n\");\n-            String value = fontFace_.getValue();\n-            value = value.replaceAll(\"\\\\\\\"\", \"\");\n-            fontFace_.setLabel(\"Editor font:\");\n-            fontFace_.setChoices(fontList, fontList);\n-            fontFace_.setValue(value);\n+            populateFontList(fontList);\n             return false;\n          }\n          \n       }, 100);\n    }\n+   \n+   private void getInstalledFontList()\n+   {\n+      // Search for installed fixed-width fonts on this web browser.\n+      final Set<String> browserFonts = new TreeSet<String>();", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMjI0OA==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404402248", "bodyText": "nit, update copyright in header", "author": "gtritchie", "createdAt": "2020-04-06T21:33:43Z", "path": "src/gwt/src/org/rstudio/studio/client/workbench/prefs/views/AceEditorPreview.java", "diffHunk": "@@ -26,6 +26,7 @@\n import org.rstudio.core.client.theme.ThemeFonts;", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNDA4MA==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404404080", "bodyText": "nit, copyright year in header", "author": "gtritchie", "createdAt": "2020-04-06T21:37:36Z", "path": "src/gwt/src/org/rstudio/studio/client/server/remote/RemoteServer.java", "diffHunk": "@@ -6154,6 +6154,12 @@ public void pandocListExtensions(String format, ServerRequestCallback<String> ca\n       sendRequest(RPC_SCOPE, PANDOC_LIST_EXTENSIONS, format, callback);", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNDQyMQ==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404404421", "bodyText": "nit, copyright year in header", "author": "gtritchie", "createdAt": "2020-04-06T21:38:21Z", "path": "src/gwt/src/org/rstudio/studio/client/common/sourcemarkers/SourceMarkerItemCodec.java", "diffHunk": "@@ -19,6 +19,7 @@\n import org.rstudio.core.client.CodeNavigationTarget;", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2Mg==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404406962", "bodyText": "ultrai-nit: Most new files use Copyright (c) 2020 by RStudio, PBC. and leave out the 2009-", "author": "gtritchie", "createdAt": "2020-04-06T21:43:44Z", "path": "src/cpp/session/modules/SessionFonts.hpp", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * SessionFonts.hpp\n+ *\n+ * Copyright (C) 2009-20 by RStudio, PBC", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTAxNw==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404411017", "bodyText": "Could use: for (const auto& fontExtension : s_fontExtensions) here and if (ext == fontExtension) below.", "author": "gtritchie", "createdAt": "2020-04-06T21:52:42Z", "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTI1OA==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404411258", "bodyText": "don't need this return", "author": "gtritchie", "createdAt": "2020-04-06T21:53:14Z", "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+   {\n+      if (ext == s_fontExtensions.at(i))\n+         return true;\n+   }\n+\n+   // No extensions match\n+   return false;\n+}\n+\n+// The path to the user-specific font folder\n+core::FilePath userFontFolder()\n+{\n+   return core::system::xdg::userConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// The path to the system-wide font folder\n+core::FilePath systemFontFolder()\n+{\n+   return core::system::xdg::systemConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// Generates a CSS snippet from a font file.\n+Error generateCssFromFile(const FilePath& file,\n+                          const std::string& fontName,\n+                          const std::vector<std::string>& parents,\n+                          std::string *pCss)\n+{\n+   pCss->append(\"@font-face {\\n\"\n+                \"  font-family: \\\"\" + fontName + \"\\\";\\n\"\n+                \"  src: url('../files/\");\n+\n+   // Build URL to font file from parent folders. \n+   for (const auto& parent: parents)\n+   {\n+      pCss->append(parent + \"/\");\n+   }\n+   pCss->append(file.getFilename() + \"');\\n\");\n+\n+   // Convert each parent folder\n+   for (const auto& parent: parents)\n+   {\n+      // Check to see whether this directory looks like a font weight\n+      // font style.\n+      auto weight = safe_convert::stringTo<int>(parent);\n+      if (weight)\n+      {\n+         // Looks like a number, so generate a weight rule and recurse.\n+         pCss->append(\"  font-weight: \" + parent + \";\\n\");\n+      }\n+      else if (parent == \"oblique\" || parent == \"italic\")\n+      {\n+         // It's a style\n+         pCss->append(\"  font-style: \" + parent + \";\\n\");\n+      }\n+   }\n+\n+   pCss->append(\"}\\n\\n\");\n+   return Success();\n+}\n+\n+// Generates CSS from a directory representing a number of variants of a single font face. The\n+// directory structure is used to provide font metadata. For instance, a font with regular (400) and\n+// bold (700) weights might be stored as follows:\n+//\n+// + Victor Mono/\n+// |\n+// +--+ 400/\n+// |  |\n+// |  +-- Victor Mono Regular.woff\n+// |  \n+// +--+ 700/\n+//    |\n+//    +-- Victor Mono Bold.woff\n+//\n+Error generateCssFromDir(const FilePath& dir,\n+                         const std::string& fontName,\n+                         const std::vector<std::string>& parents,\n+                         std::string *pCss)\n+{\n+   std::vector<FilePath> files;\n+   Error error = dir.getChildren(files);\n+   if (error)\n+   {\n+      return error;\n+   }\n+   \n+   for (const auto& file: files)\n+   {\n+      std::string name = file.getFilename();\n+      if (file.isDirectory())\n+      {\n+         // This is a directory, probably representing a font weight or style\n+         std::vector<std::string> newParents(parents);\n+         newParents.push_back(name);\n+         error = generateCssFromDir(file, fontName, newParents, pCss);\n+      }\n+      else if (isFontFile(file))\n+      {\n+         // This is an ordinary font file\n+         error = generateCssFromFile(file, fontName, parents, pCss);\n+      }\n+\n+      if (error)\n+      {\n+         // Log and clear any errors encountered while processing this font\n+         LOG_ERROR(error);\n+         error = Success();\n+      }\n+   }\n+\n+   return error;\n+}\n+\n+// Handles an HTTP request for a specific font file.\n+void handleFontFileRequest(const http::Request& request,\n+                           http::Response* pResponse)\n+{\n+   std::string prefix = \"/\" kFontFiles;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+   \n+   // Check user font folder first\n+   FilePath fontFile = userFontFolder().completeChildPath(fileName);\n+   if (!fontFile.exists())\n+   {\n+      // Not found in user fonts; fall back to system\n+      fontFile = systemFontFolder().completeChildPath(fileName);\n+   }\n+\n+   pResponse->setCacheableFile(fontFile, request);\n+   return;", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTgzOQ==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404411839", "bodyText": "Like earlier could use range-for loop here.", "author": "gtritchie", "createdAt": "2020-04-06T21:54:25Z", "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+   {\n+      if (ext == s_fontExtensions.at(i))\n+         return true;\n+   }\n+\n+   // No extensions match\n+   return false;\n+}\n+\n+// The path to the user-specific font folder\n+core::FilePath userFontFolder()\n+{\n+   return core::system::xdg::userConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// The path to the system-wide font folder\n+core::FilePath systemFontFolder()\n+{\n+   return core::system::xdg::systemConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// Generates a CSS snippet from a font file.\n+Error generateCssFromFile(const FilePath& file,\n+                          const std::string& fontName,\n+                          const std::vector<std::string>& parents,\n+                          std::string *pCss)\n+{\n+   pCss->append(\"@font-face {\\n\"\n+                \"  font-family: \\\"\" + fontName + \"\\\";\\n\"\n+                \"  src: url('../files/\");\n+\n+   // Build URL to font file from parent folders. \n+   for (const auto& parent: parents)\n+   {\n+      pCss->append(parent + \"/\");\n+   }\n+   pCss->append(file.getFilename() + \"');\\n\");\n+\n+   // Convert each parent folder\n+   for (const auto& parent: parents)\n+   {\n+      // Check to see whether this directory looks like a font weight\n+      // font style.\n+      auto weight = safe_convert::stringTo<int>(parent);\n+      if (weight)\n+      {\n+         // Looks like a number, so generate a weight rule and recurse.\n+         pCss->append(\"  font-weight: \" + parent + \";\\n\");\n+      }\n+      else if (parent == \"oblique\" || parent == \"italic\")\n+      {\n+         // It's a style\n+         pCss->append(\"  font-style: \" + parent + \";\\n\");\n+      }\n+   }\n+\n+   pCss->append(\"}\\n\\n\");\n+   return Success();\n+}\n+\n+// Generates CSS from a directory representing a number of variants of a single font face. The\n+// directory structure is used to provide font metadata. For instance, a font with regular (400) and\n+// bold (700) weights might be stored as follows:\n+//\n+// + Victor Mono/\n+// |\n+// +--+ 400/\n+// |  |\n+// |  +-- Victor Mono Regular.woff\n+// |  \n+// +--+ 700/\n+//    |\n+//    +-- Victor Mono Bold.woff\n+//\n+Error generateCssFromDir(const FilePath& dir,\n+                         const std::string& fontName,\n+                         const std::vector<std::string>& parents,\n+                         std::string *pCss)\n+{\n+   std::vector<FilePath> files;\n+   Error error = dir.getChildren(files);\n+   if (error)\n+   {\n+      return error;\n+   }\n+   \n+   for (const auto& file: files)\n+   {\n+      std::string name = file.getFilename();\n+      if (file.isDirectory())\n+      {\n+         // This is a directory, probably representing a font weight or style\n+         std::vector<std::string> newParents(parents);\n+         newParents.push_back(name);\n+         error = generateCssFromDir(file, fontName, newParents, pCss);\n+      }\n+      else if (isFontFile(file))\n+      {\n+         // This is an ordinary font file\n+         error = generateCssFromFile(file, fontName, parents, pCss);\n+      }\n+\n+      if (error)\n+      {\n+         // Log and clear any errors encountered while processing this font\n+         LOG_ERROR(error);\n+         error = Success();\n+      }\n+   }\n+\n+   return error;\n+}\n+\n+// Handles an HTTP request for a specific font file.\n+void handleFontFileRequest(const http::Request& request,\n+                           http::Response* pResponse)\n+{\n+   std::string prefix = \"/\" kFontFiles;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+   \n+   // Check user font folder first\n+   FilePath fontFile = userFontFolder().completeChildPath(fileName);\n+   if (!fontFile.exists())\n+   {\n+      // Not found in user fonts; fall back to system\n+      fontFile = systemFontFolder().completeChildPath(fileName);\n+   }\n+\n+   pResponse->setCacheableFile(fontFile, request);\n+   return;\n+}\n+\n+// Handles an HTTP request for font CSS. This will typically look something like:\n+//\n+// GET /fonts/css/Victor Mono.css\n+//\n+// The request is fulfilled by automatically generating the appropriate CSS @font-face rule(s) for\n+// the font and returning them in the body of the request.\n+void handleFontCssRequest(const http::Request& request,\n+                          http::Response* pResponse)\n+{\n+   Error error;\n+   std::string css;\n+   std::string prefix = \"/\"  kFontCss;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+\n+   // Strip off \".css\" to get name of font\n+   size_t idx = fileName.find(\".css\");\n+   if (idx != std::string::npos)\n+   {\n+      fileName = fileName.substr(0, idx);\n+   }\n+   \n+   // Enumerate user and system font directories\n+   std::vector<FilePath> dirs;\n+   dirs.push_back(userFontFolder());\n+   dirs.push_back(systemFontFolder());\n+\n+   for (const auto& dir: dirs)\n+   {\n+      FilePath subDir = dir.completeChildPath(fileName);\n+      if (subDir.exists() && subDir.isDirectory())\n+      {\n+         // Folder full of font files\n+         std::vector<std::string> parents;\n+         parents.push_back(fileName);\n+         error = generateCssFromDir(subDir, fileName, parents, &css);\n+      }\n+      else\n+      {\n+         // An individual font file; determine extension\n+         for (size_t i = 0; i < s_fontExtensions.size(); i++)", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjExMg==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404412112", "bodyText": "don't need this return", "author": "gtritchie", "createdAt": "2020-04-06T21:55:00Z", "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+   {\n+      if (ext == s_fontExtensions.at(i))\n+         return true;\n+   }\n+\n+   // No extensions match\n+   return false;\n+}\n+\n+// The path to the user-specific font folder\n+core::FilePath userFontFolder()\n+{\n+   return core::system::xdg::userConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// The path to the system-wide font folder\n+core::FilePath systemFontFolder()\n+{\n+   return core::system::xdg::systemConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// Generates a CSS snippet from a font file.\n+Error generateCssFromFile(const FilePath& file,\n+                          const std::string& fontName,\n+                          const std::vector<std::string>& parents,\n+                          std::string *pCss)\n+{\n+   pCss->append(\"@font-face {\\n\"\n+                \"  font-family: \\\"\" + fontName + \"\\\";\\n\"\n+                \"  src: url('../files/\");\n+\n+   // Build URL to font file from parent folders. \n+   for (const auto& parent: parents)\n+   {\n+      pCss->append(parent + \"/\");\n+   }\n+   pCss->append(file.getFilename() + \"');\\n\");\n+\n+   // Convert each parent folder\n+   for (const auto& parent: parents)\n+   {\n+      // Check to see whether this directory looks like a font weight\n+      // font style.\n+      auto weight = safe_convert::stringTo<int>(parent);\n+      if (weight)\n+      {\n+         // Looks like a number, so generate a weight rule and recurse.\n+         pCss->append(\"  font-weight: \" + parent + \";\\n\");\n+      }\n+      else if (parent == \"oblique\" || parent == \"italic\")\n+      {\n+         // It's a style\n+         pCss->append(\"  font-style: \" + parent + \";\\n\");\n+      }\n+   }\n+\n+   pCss->append(\"}\\n\\n\");\n+   return Success();\n+}\n+\n+// Generates CSS from a directory representing a number of variants of a single font face. The\n+// directory structure is used to provide font metadata. For instance, a font with regular (400) and\n+// bold (700) weights might be stored as follows:\n+//\n+// + Victor Mono/\n+// |\n+// +--+ 400/\n+// |  |\n+// |  +-- Victor Mono Regular.woff\n+// |  \n+// +--+ 700/\n+//    |\n+//    +-- Victor Mono Bold.woff\n+//\n+Error generateCssFromDir(const FilePath& dir,\n+                         const std::string& fontName,\n+                         const std::vector<std::string>& parents,\n+                         std::string *pCss)\n+{\n+   std::vector<FilePath> files;\n+   Error error = dir.getChildren(files);\n+   if (error)\n+   {\n+      return error;\n+   }\n+   \n+   for (const auto& file: files)\n+   {\n+      std::string name = file.getFilename();\n+      if (file.isDirectory())\n+      {\n+         // This is a directory, probably representing a font weight or style\n+         std::vector<std::string> newParents(parents);\n+         newParents.push_back(name);\n+         error = generateCssFromDir(file, fontName, newParents, pCss);\n+      }\n+      else if (isFontFile(file))\n+      {\n+         // This is an ordinary font file\n+         error = generateCssFromFile(file, fontName, parents, pCss);\n+      }\n+\n+      if (error)\n+      {\n+         // Log and clear any errors encountered while processing this font\n+         LOG_ERROR(error);\n+         error = Success();\n+      }\n+   }\n+\n+   return error;\n+}\n+\n+// Handles an HTTP request for a specific font file.\n+void handleFontFileRequest(const http::Request& request,\n+                           http::Response* pResponse)\n+{\n+   std::string prefix = \"/\" kFontFiles;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+   \n+   // Check user font folder first\n+   FilePath fontFile = userFontFolder().completeChildPath(fileName);\n+   if (!fontFile.exists())\n+   {\n+      // Not found in user fonts; fall back to system\n+      fontFile = systemFontFolder().completeChildPath(fileName);\n+   }\n+\n+   pResponse->setCacheableFile(fontFile, request);\n+   return;\n+}\n+\n+// Handles an HTTP request for font CSS. This will typically look something like:\n+//\n+// GET /fonts/css/Victor Mono.css\n+//\n+// The request is fulfilled by automatically generating the appropriate CSS @font-face rule(s) for\n+// the font and returning them in the body of the request.\n+void handleFontCssRequest(const http::Request& request,\n+                          http::Response* pResponse)\n+{\n+   Error error;\n+   std::string css;\n+   std::string prefix = \"/\"  kFontCss;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+\n+   // Strip off \".css\" to get name of font\n+   size_t idx = fileName.find(\".css\");\n+   if (idx != std::string::npos)\n+   {\n+      fileName = fileName.substr(0, idx);\n+   }\n+   \n+   // Enumerate user and system font directories\n+   std::vector<FilePath> dirs;\n+   dirs.push_back(userFontFolder());\n+   dirs.push_back(systemFontFolder());\n+\n+   for (const auto& dir: dirs)\n+   {\n+      FilePath subDir = dir.completeChildPath(fileName);\n+      if (subDir.exists() && subDir.isDirectory())\n+      {\n+         // Folder full of font files\n+         std::vector<std::string> parents;\n+         parents.push_back(fileName);\n+         error = generateCssFromDir(subDir, fileName, parents, &css);\n+      }\n+      else\n+      {\n+         // An individual font file; determine extension\n+         for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+         {\n+            FilePath fontFile = dir.completeChildPath(\n+                  fileName + s_fontExtensions[i]);\n+            if (fontFile.exists())\n+            {\n+               // Generate CSS for the font file\n+               error = generateCssFromFile(fontFile, fileName, std::vector<std::string>(), &css);\n+               if (error)\n+               {\n+                  LOG_ERROR(error);\n+               }\n+\n+               // We found a matching font; bail here\n+               break;\n+            }\n+         }\n+      }\n+   }\n+\n+   // It's okay if there was no matching font found at this point, since on RStudio Server the font\n+   // can be provided by the browser instead of the server. We will still generate a font-specific\n+   // stylesheet below.\n+   //\n+   // Append override rules for basic fixed-width elements. This stylesheet overrides a few key\n+   // styles in themeStyles.css with the specified font.\n+   //\n+   std::map<std::string,std::string> vars;\n+   vars[\"font\"] = fileName;\n+   std::ostringstream oss;\n+   error = core::text::renderTemplate(\n+      session::options().rResourcesPath().completeChildPath(\"themes/css/fonts.css\"), vars, oss);\n+   if (error)\n+   {\n+      LOG_ERROR(error);\n+   }\n+   else\n+   {\n+      css.append(oss.str());\n+   }\n+\n+   // Return the accumulated stylesheet\n+   pResponse->setContentType(\"text/css\");\n+   pResponse->setBody(css);\n+\n+   return;", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjgzMw==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404412833", "bodyText": "Should you log this error or do something else with it, otherwise it's unused.", "author": "gtritchie", "createdAt": "2020-04-06T21:56:16Z", "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+   {\n+      if (ext == s_fontExtensions.at(i))\n+         return true;\n+   }\n+\n+   // No extensions match\n+   return false;\n+}\n+\n+// The path to the user-specific font folder\n+core::FilePath userFontFolder()\n+{\n+   return core::system::xdg::userConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// The path to the system-wide font folder\n+core::FilePath systemFontFolder()\n+{\n+   return core::system::xdg::systemConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// Generates a CSS snippet from a font file.\n+Error generateCssFromFile(const FilePath& file,\n+                          const std::string& fontName,\n+                          const std::vector<std::string>& parents,\n+                          std::string *pCss)\n+{\n+   pCss->append(\"@font-face {\\n\"\n+                \"  font-family: \\\"\" + fontName + \"\\\";\\n\"\n+                \"  src: url('../files/\");\n+\n+   // Build URL to font file from parent folders. \n+   for (const auto& parent: parents)\n+   {\n+      pCss->append(parent + \"/\");\n+   }\n+   pCss->append(file.getFilename() + \"');\\n\");\n+\n+   // Convert each parent folder\n+   for (const auto& parent: parents)\n+   {\n+      // Check to see whether this directory looks like a font weight\n+      // font style.\n+      auto weight = safe_convert::stringTo<int>(parent);\n+      if (weight)\n+      {\n+         // Looks like a number, so generate a weight rule and recurse.\n+         pCss->append(\"  font-weight: \" + parent + \";\\n\");\n+      }\n+      else if (parent == \"oblique\" || parent == \"italic\")\n+      {\n+         // It's a style\n+         pCss->append(\"  font-style: \" + parent + \";\\n\");\n+      }\n+   }\n+\n+   pCss->append(\"}\\n\\n\");\n+   return Success();\n+}\n+\n+// Generates CSS from a directory representing a number of variants of a single font face. The\n+// directory structure is used to provide font metadata. For instance, a font with regular (400) and\n+// bold (700) weights might be stored as follows:\n+//\n+// + Victor Mono/\n+// |\n+// +--+ 400/\n+// |  |\n+// |  +-- Victor Mono Regular.woff\n+// |  \n+// +--+ 700/\n+//    |\n+//    +-- Victor Mono Bold.woff\n+//\n+Error generateCssFromDir(const FilePath& dir,\n+                         const std::string& fontName,\n+                         const std::vector<std::string>& parents,\n+                         std::string *pCss)\n+{\n+   std::vector<FilePath> files;\n+   Error error = dir.getChildren(files);\n+   if (error)\n+   {\n+      return error;\n+   }\n+   \n+   for (const auto& file: files)\n+   {\n+      std::string name = file.getFilename();\n+      if (file.isDirectory())\n+      {\n+         // This is a directory, probably representing a font weight or style\n+         std::vector<std::string> newParents(parents);\n+         newParents.push_back(name);\n+         error = generateCssFromDir(file, fontName, newParents, pCss);\n+      }\n+      else if (isFontFile(file))\n+      {\n+         // This is an ordinary font file\n+         error = generateCssFromFile(file, fontName, parents, pCss);\n+      }\n+\n+      if (error)\n+      {\n+         // Log and clear any errors encountered while processing this font\n+         LOG_ERROR(error);\n+         error = Success();\n+      }\n+   }\n+\n+   return error;\n+}\n+\n+// Handles an HTTP request for a specific font file.\n+void handleFontFileRequest(const http::Request& request,\n+                           http::Response* pResponse)\n+{\n+   std::string prefix = \"/\" kFontFiles;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+   \n+   // Check user font folder first\n+   FilePath fontFile = userFontFolder().completeChildPath(fileName);\n+   if (!fontFile.exists())\n+   {\n+      // Not found in user fonts; fall back to system\n+      fontFile = systemFontFolder().completeChildPath(fileName);\n+   }\n+\n+   pResponse->setCacheableFile(fontFile, request);\n+   return;\n+}\n+\n+// Handles an HTTP request for font CSS. This will typically look something like:\n+//\n+// GET /fonts/css/Victor Mono.css\n+//\n+// The request is fulfilled by automatically generating the appropriate CSS @font-face rule(s) for\n+// the font and returning them in the body of the request.\n+void handleFontCssRequest(const http::Request& request,\n+                          http::Response* pResponse)\n+{\n+   Error error;\n+   std::string css;\n+   std::string prefix = \"/\"  kFontCss;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+\n+   // Strip off \".css\" to get name of font\n+   size_t idx = fileName.find(\".css\");\n+   if (idx != std::string::npos)\n+   {\n+      fileName = fileName.substr(0, idx);\n+   }\n+   \n+   // Enumerate user and system font directories\n+   std::vector<FilePath> dirs;\n+   dirs.push_back(userFontFolder());\n+   dirs.push_back(systemFontFolder());\n+\n+   for (const auto& dir: dirs)\n+   {\n+      FilePath subDir = dir.completeChildPath(fileName);\n+      if (subDir.exists() && subDir.isDirectory())\n+      {\n+         // Folder full of font files\n+         std::vector<std::string> parents;\n+         parents.push_back(fileName);\n+         error = generateCssFromDir(subDir, fileName, parents, &css);", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMzUxMg==", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404413512", "bodyText": "nit, copyright header year update", "author": "gtritchie", "createdAt": "2020-04-06T21:57:46Z", "path": "src/cpp/server/ServerMain.cpp", "diffHunk": "@@ -231,6 +231,7 @@ void httpServerAddHandlers()\n    uri_handlers::add(\"/mathjax\", secureAsyncHttpHandler(proxyContentRequest));", "originalCommit": "f30c294e4e083e2ced06934272e84c107fd8db5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "66edabe481b12e6a61987eb40b47343e79726adc", "url": "https://github.com/rstudio/rstudio/commit/66edabe481b12e6a61987eb40b47343e79726adc", "message": "code review feedback", "committedDate": "2020-04-06T22:30:28Z", "type": "commit"}]}