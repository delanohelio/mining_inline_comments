{"pr_number": 1483, "pr_title": "[eclipse/xtext#1777] converted xtend code to java", "pr_createdAt": "2020-07-01T08:12:44Z", "pr_url": "https://github.com/eclipse/xtext-eclipse/pull/1483", "timeline": [{"oid": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "url": "https://github.com/eclipse/xtext-eclipse/commit/a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "message": "[eclipse/xtext#1777] converted xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-02T09:15:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwNzk2NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449407965", "bodyText": "Please to \"return new ArrayList<>();\" instead.", "author": "ArneDeutsch", "createdAt": "2020-07-03T06:53:57Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyOTIxMQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449429211", "bodyText": "i dont want to change semantics here", "author": "cdietrich", "createdAt": "2020-07-03T07:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwNzk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwOTcxOQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449409719", "bodyText": "Could be simplified a lot using Collections.singletonMap and using unmodifiableMap without extra newHashMap.", "author": "ArneDeutsch", "createdAt": "2020-07-03T06:58:22Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();\n+\t\treturn result;\n+\t}\n+\n+\tprotected IndexState build(BuildRequest buildRequest) {\n+\t\tclean();\n+\t\tindexState = incrementalBuilder.build(buildRequest, (URI it) -> getLanguages().getResourceServiceProvider(it)).getIndexState();\n+\t\treturn indexState;\n+\t}\n+\n+\tprotected void withOutputConfig(BuildRequest it, Procedure1<? super OutputConfiguration> init) {\n+\t\tOutputConfiguration config = Iterables.getFirst(configurationProvider.getOutputConfigurations(), null);\n+\t\tinit.apply(config);\n+\t\tOutputConfigurationAdapter adapter = new OutputConfigurationAdapter(Collections.unmodifiableMap(", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAwMjA0MQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r450002041", "bodyText": "?", "author": "cdietrich", "createdAt": "2020-07-06T06:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwOTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY1MjM4MA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r450652380", "bodyText": "new OutputConfigurationAdapter(Collections.singletonMap(languageName, Collections.singleton(config))", "author": "szarnekow", "createdAt": "2020-07-07T07:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQwOTcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMTAxMA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449411010", "bodyText": "Collections.emptyList would do.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:01:54Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();\n+\t\treturn result;\n+\t}\n+\n+\tprotected IndexState build(BuildRequest buildRequest) {\n+\t\tclean();\n+\t\tindexState = incrementalBuilder.build(buildRequest, (URI it) -> getLanguages().getResourceServiceProvider(it)).getIndexState();\n+\t\treturn indexState;\n+\t}\n+\n+\tprotected void withOutputConfig(BuildRequest it, Procedure1<? super OutputConfiguration> init) {\n+\t\tOutputConfiguration config = Iterables.getFirst(configurationProvider.getOutputConfigurations(), null);\n+\t\tinit.apply(config);\n+\t\tOutputConfigurationAdapter adapter = new OutputConfigurationAdapter(Collections.unmodifiableMap(\n+\t\t\t\tCollectionLiterals.newHashMap(Pair.of(languageName, Collections.unmodifiableSet(Sets.newHashSet(config))))));\n+\t\tit.getResourceSet().eAdapters().add(adapter);\n+\t}\n+\n+\tprotected abstract IResourceServiceProvider.Registry getLanguages();\n+\n+\tprotected BuildRequest newBuildRequest(Procedure1<? super BuildRequest> init) {\n+\t\tBuildRequest result = new BuildRequest();\n+\t\tResourceDescriptionsData newIndex = indexState.getResourceDescriptions().copy();\n+\t\tresult.setBaseDir(uri(\"\"));\n+\t\tXtextResourceSet rs = resourceSetProvider.get();\n+\t\trs.getURIConverter().getURIHandlers().clear();\n+\t\trs.getURIConverter().getURIHandlers().add(inMemoryURIHandler);\n+\t\trs.setClasspathURIContext(AbstractIncrementalBuilderTest.class.getClassLoader());\n+\t\tProjectDescription projectDescription = new ProjectDescription();\n+\t\tprojectDescription.setName(\"test-project\");\n+\t\tprojectDescription.attachToEmfObject(rs);\n+\t\tChunkedResourceDescriptions index = new ChunkedResourceDescriptions(Collections.emptyMap(), rs);\n+\t\tindex.setContainer(projectDescription.getName(), newIndex);\n+\t\tresult.setResourceSet(rs);\n+\t\tresult.setDirtyFiles(Collections.unmodifiableList(new ArrayList<>()));", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMTA5Mw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449411093", "bodyText": "Collections.emptyList would do.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:02:06Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();\n+\t\treturn result;\n+\t}\n+\n+\tprotected IndexState build(BuildRequest buildRequest) {\n+\t\tclean();\n+\t\tindexState = incrementalBuilder.build(buildRequest, (URI it) -> getLanguages().getResourceServiceProvider(it)).getIndexState();\n+\t\treturn indexState;\n+\t}\n+\n+\tprotected void withOutputConfig(BuildRequest it, Procedure1<? super OutputConfiguration> init) {\n+\t\tOutputConfiguration config = Iterables.getFirst(configurationProvider.getOutputConfigurations(), null);\n+\t\tinit.apply(config);\n+\t\tOutputConfigurationAdapter adapter = new OutputConfigurationAdapter(Collections.unmodifiableMap(\n+\t\t\t\tCollectionLiterals.newHashMap(Pair.of(languageName, Collections.unmodifiableSet(Sets.newHashSet(config))))));\n+\t\tit.getResourceSet().eAdapters().add(adapter);\n+\t}\n+\n+\tprotected abstract IResourceServiceProvider.Registry getLanguages();\n+\n+\tprotected BuildRequest newBuildRequest(Procedure1<? super BuildRequest> init) {\n+\t\tBuildRequest result = new BuildRequest();\n+\t\tResourceDescriptionsData newIndex = indexState.getResourceDescriptions().copy();\n+\t\tresult.setBaseDir(uri(\"\"));\n+\t\tXtextResourceSet rs = resourceSetProvider.get();\n+\t\trs.getURIConverter().getURIHandlers().clear();\n+\t\trs.getURIConverter().getURIHandlers().add(inMemoryURIHandler);\n+\t\trs.setClasspathURIContext(AbstractIncrementalBuilderTest.class.getClassLoader());\n+\t\tProjectDescription projectDescription = new ProjectDescription();\n+\t\tprojectDescription.setName(\"test-project\");\n+\t\tprojectDescription.attachToEmfObject(rs);\n+\t\tChunkedResourceDescriptions index = new ChunkedResourceDescriptions(Collections.emptyMap(), rs);\n+\t\tindex.setContainer(projectDescription.getName(), newIndex);\n+\t\tresult.setResourceSet(rs);\n+\t\tresult.setDirtyFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setDeletedFiles(Collections.unmodifiableList(new ArrayList<>()));", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMjA4NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449412084", "bodyText": "Generic seems superflues.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:04:40Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();\n+\t\treturn result;\n+\t}\n+\n+\tprotected IndexState build(BuildRequest buildRequest) {\n+\t\tclean();\n+\t\tindexState = incrementalBuilder.build(buildRequest, (URI it) -> getLanguages().getResourceServiceProvider(it)).getIndexState();\n+\t\treturn indexState;\n+\t}\n+\n+\tprotected void withOutputConfig(BuildRequest it, Procedure1<? super OutputConfiguration> init) {\n+\t\tOutputConfiguration config = Iterables.getFirst(configurationProvider.getOutputConfigurations(), null);\n+\t\tinit.apply(config);\n+\t\tOutputConfigurationAdapter adapter = new OutputConfigurationAdapter(Collections.unmodifiableMap(\n+\t\t\t\tCollectionLiterals.newHashMap(Pair.of(languageName, Collections.unmodifiableSet(Sets.newHashSet(config))))));\n+\t\tit.getResourceSet().eAdapters().add(adapter);\n+\t}\n+\n+\tprotected abstract IResourceServiceProvider.Registry getLanguages();\n+\n+\tprotected BuildRequest newBuildRequest(Procedure1<? super BuildRequest> init) {\n+\t\tBuildRequest result = new BuildRequest();\n+\t\tResourceDescriptionsData newIndex = indexState.getResourceDescriptions().copy();\n+\t\tresult.setBaseDir(uri(\"\"));\n+\t\tXtextResourceSet rs = resourceSetProvider.get();\n+\t\trs.getURIConverter().getURIHandlers().clear();\n+\t\trs.getURIConverter().getURIHandlers().add(inMemoryURIHandler);\n+\t\trs.setClasspathURIContext(AbstractIncrementalBuilderTest.class.getClassLoader());\n+\t\tProjectDescription projectDescription = new ProjectDescription();\n+\t\tprojectDescription.setName(\"test-project\");\n+\t\tprojectDescription.attachToEmfObject(rs);\n+\t\tChunkedResourceDescriptions index = new ChunkedResourceDescriptions(Collections.emptyMap(), rs);\n+\t\tindex.setContainer(projectDescription.getName(), newIndex);\n+\t\tresult.setResourceSet(rs);\n+\t\tresult.setDirtyFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setDeletedFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setAfterValidate((URI uri, Iterable<Issue> issues) -> {\n+\t\t\tIterables.<Issue> addAll(this.issues, issues);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMjQxMw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449412413", "bodyText": "Remove braces, semicolon and return to make it one liner. Also remove type of lambda parameter.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:05:23Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();\n+\t\treturn result;\n+\t}\n+\n+\tprotected IndexState build(BuildRequest buildRequest) {\n+\t\tclean();\n+\t\tindexState = incrementalBuilder.build(buildRequest, (URI it) -> getLanguages().getResourceServiceProvider(it)).getIndexState();\n+\t\treturn indexState;\n+\t}\n+\n+\tprotected void withOutputConfig(BuildRequest it, Procedure1<? super OutputConfiguration> init) {\n+\t\tOutputConfiguration config = Iterables.getFirst(configurationProvider.getOutputConfigurations(), null);\n+\t\tinit.apply(config);\n+\t\tOutputConfigurationAdapter adapter = new OutputConfigurationAdapter(Collections.unmodifiableMap(\n+\t\t\t\tCollectionLiterals.newHashMap(Pair.of(languageName, Collections.unmodifiableSet(Sets.newHashSet(config))))));\n+\t\tit.getResourceSet().eAdapters().add(adapter);\n+\t}\n+\n+\tprotected abstract IResourceServiceProvider.Registry getLanguages();\n+\n+\tprotected BuildRequest newBuildRequest(Procedure1<? super BuildRequest> init) {\n+\t\tBuildRequest result = new BuildRequest();\n+\t\tResourceDescriptionsData newIndex = indexState.getResourceDescriptions().copy();\n+\t\tresult.setBaseDir(uri(\"\"));\n+\t\tXtextResourceSet rs = resourceSetProvider.get();\n+\t\trs.getURIConverter().getURIHandlers().clear();\n+\t\trs.getURIConverter().getURIHandlers().add(inMemoryURIHandler);\n+\t\trs.setClasspathURIContext(AbstractIncrementalBuilderTest.class.getClassLoader());\n+\t\tProjectDescription projectDescription = new ProjectDescription();\n+\t\tprojectDescription.setName(\"test-project\");\n+\t\tprojectDescription.attachToEmfObject(rs);\n+\t\tChunkedResourceDescriptions index = new ChunkedResourceDescriptions(Collections.emptyMap(), rs);\n+\t\tindex.setContainer(projectDescription.getName(), newIndex);\n+\t\tresult.setResourceSet(rs);\n+\t\tresult.setDirtyFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setDeletedFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setAfterValidate((URI uri, Iterable<Issue> issues) -> {\n+\t\t\tIterables.<Issue> addAll(this.issues, issues);\n+\t\t\treturn IterableExtensions.isEmpty(issues);\n+\t\t});\n+\t\tresult.setAfterDeleteFile((URI uri) -> {", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMjc3MQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449412771", "bodyText": "Remove braces, semicolon and return to make it one liner. Also remove types of lambda parameters.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:06:22Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();\n+\t\treturn result;\n+\t}\n+\n+\tprotected IndexState build(BuildRequest buildRequest) {\n+\t\tclean();\n+\t\tindexState = incrementalBuilder.build(buildRequest, (URI it) -> getLanguages().getResourceServiceProvider(it)).getIndexState();\n+\t\treturn indexState;\n+\t}\n+\n+\tprotected void withOutputConfig(BuildRequest it, Procedure1<? super OutputConfiguration> init) {\n+\t\tOutputConfiguration config = Iterables.getFirst(configurationProvider.getOutputConfigurations(), null);\n+\t\tinit.apply(config);\n+\t\tOutputConfigurationAdapter adapter = new OutputConfigurationAdapter(Collections.unmodifiableMap(\n+\t\t\t\tCollectionLiterals.newHashMap(Pair.of(languageName, Collections.unmodifiableSet(Sets.newHashSet(config))))));\n+\t\tit.getResourceSet().eAdapters().add(adapter);\n+\t}\n+\n+\tprotected abstract IResourceServiceProvider.Registry getLanguages();\n+\n+\tprotected BuildRequest newBuildRequest(Procedure1<? super BuildRequest> init) {\n+\t\tBuildRequest result = new BuildRequest();\n+\t\tResourceDescriptionsData newIndex = indexState.getResourceDescriptions().copy();\n+\t\tresult.setBaseDir(uri(\"\"));\n+\t\tXtextResourceSet rs = resourceSetProvider.get();\n+\t\trs.getURIConverter().getURIHandlers().clear();\n+\t\trs.getURIConverter().getURIHandlers().add(inMemoryURIHandler);\n+\t\trs.setClasspathURIContext(AbstractIncrementalBuilderTest.class.getClassLoader());\n+\t\tProjectDescription projectDescription = new ProjectDescription();\n+\t\tprojectDescription.setName(\"test-project\");\n+\t\tprojectDescription.attachToEmfObject(rs);\n+\t\tChunkedResourceDescriptions index = new ChunkedResourceDescriptions(Collections.emptyMap(), rs);\n+\t\tindex.setContainer(projectDescription.getName(), newIndex);\n+\t\tresult.setResourceSet(rs);\n+\t\tresult.setDirtyFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setDeletedFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setAfterValidate((URI uri, Iterable<Issue> issues) -> {\n+\t\t\tIterables.<Issue> addAll(this.issues, issues);\n+\t\t\treturn IterableExtensions.isEmpty(issues);\n+\t\t});\n+\t\tresult.setAfterDeleteFile((URI uri) -> {\n+\t\t\tdeleted.add(uri);\n+\t\t});\n+\t\tresult.setAfterGenerateFile((URI source, URI target) -> {", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMzA4NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449413085", "bodyText": "Use RuntimeException instead!?", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:07:11Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();\n+\t\treturn result;\n+\t}\n+\n+\tprotected IndexState build(BuildRequest buildRequest) {\n+\t\tclean();\n+\t\tindexState = incrementalBuilder.build(buildRequest, (URI it) -> getLanguages().getResourceServiceProvider(it)).getIndexState();\n+\t\treturn indexState;\n+\t}\n+\n+\tprotected void withOutputConfig(BuildRequest it, Procedure1<? super OutputConfiguration> init) {\n+\t\tOutputConfiguration config = Iterables.getFirst(configurationProvider.getOutputConfigurations(), null);\n+\t\tinit.apply(config);\n+\t\tOutputConfigurationAdapter adapter = new OutputConfigurationAdapter(Collections.unmodifiableMap(\n+\t\t\t\tCollectionLiterals.newHashMap(Pair.of(languageName, Collections.unmodifiableSet(Sets.newHashSet(config))))));\n+\t\tit.getResourceSet().eAdapters().add(adapter);\n+\t}\n+\n+\tprotected abstract IResourceServiceProvider.Registry getLanguages();\n+\n+\tprotected BuildRequest newBuildRequest(Procedure1<? super BuildRequest> init) {\n+\t\tBuildRequest result = new BuildRequest();\n+\t\tResourceDescriptionsData newIndex = indexState.getResourceDescriptions().copy();\n+\t\tresult.setBaseDir(uri(\"\"));\n+\t\tXtextResourceSet rs = resourceSetProvider.get();\n+\t\trs.getURIConverter().getURIHandlers().clear();\n+\t\trs.getURIConverter().getURIHandlers().add(inMemoryURIHandler);\n+\t\trs.setClasspathURIContext(AbstractIncrementalBuilderTest.class.getClassLoader());\n+\t\tProjectDescription projectDescription = new ProjectDescription();\n+\t\tprojectDescription.setName(\"test-project\");\n+\t\tprojectDescription.attachToEmfObject(rs);\n+\t\tChunkedResourceDescriptions index = new ChunkedResourceDescriptions(Collections.emptyMap(), rs);\n+\t\tindex.setContainer(projectDescription.getName(), newIndex);\n+\t\tresult.setResourceSet(rs);\n+\t\tresult.setDirtyFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setDeletedFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setAfterValidate((URI uri, Iterable<Issue> issues) -> {\n+\t\t\tIterables.<Issue> addAll(this.issues, issues);\n+\t\t\treturn IterableExtensions.isEmpty(issues);\n+\t\t});\n+\t\tresult.setAfterDeleteFile((URI uri) -> {\n+\t\t\tdeleted.add(uri);\n+\t\t});\n+\t\tresult.setAfterGenerateFile((URI source, URI target) -> {\n+\t\t\tgenerated.put(source, target);\n+\t\t});\n+\t\tresult.setState(new IndexState(newIndex, indexState.getFileMappings().copy()));\n+\t\tinit.apply(result);\n+\t\treturn result;\n+\t}\n+\n+\tprotected URI delete(URI uri) {\n+\t\ttry {\n+\t\t\tinMemoryURIHandler.delete(uri, Collections.emptyMap());\n+\t\t\treturn uri;\n+\t\t} catch (IOException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NTc4NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449665785", "bodyText": "dont want to change the semantics on deprecated class", "author": "cdietrich", "createdAt": "2020-07-03T17:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMzA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMzY5Mw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449413693", "bodyText": "Use RuntimeException instead!?", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:08:45Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();\n+\t\treturn result;\n+\t}\n+\n+\tprotected IndexState build(BuildRequest buildRequest) {\n+\t\tclean();\n+\t\tindexState = incrementalBuilder.build(buildRequest, (URI it) -> getLanguages().getResourceServiceProvider(it)).getIndexState();\n+\t\treturn indexState;\n+\t}\n+\n+\tprotected void withOutputConfig(BuildRequest it, Procedure1<? super OutputConfiguration> init) {\n+\t\tOutputConfiguration config = Iterables.getFirst(configurationProvider.getOutputConfigurations(), null);\n+\t\tinit.apply(config);\n+\t\tOutputConfigurationAdapter adapter = new OutputConfigurationAdapter(Collections.unmodifiableMap(\n+\t\t\t\tCollectionLiterals.newHashMap(Pair.of(languageName, Collections.unmodifiableSet(Sets.newHashSet(config))))));\n+\t\tit.getResourceSet().eAdapters().add(adapter);\n+\t}\n+\n+\tprotected abstract IResourceServiceProvider.Registry getLanguages();\n+\n+\tprotected BuildRequest newBuildRequest(Procedure1<? super BuildRequest> init) {\n+\t\tBuildRequest result = new BuildRequest();\n+\t\tResourceDescriptionsData newIndex = indexState.getResourceDescriptions().copy();\n+\t\tresult.setBaseDir(uri(\"\"));\n+\t\tXtextResourceSet rs = resourceSetProvider.get();\n+\t\trs.getURIConverter().getURIHandlers().clear();\n+\t\trs.getURIConverter().getURIHandlers().add(inMemoryURIHandler);\n+\t\trs.setClasspathURIContext(AbstractIncrementalBuilderTest.class.getClassLoader());\n+\t\tProjectDescription projectDescription = new ProjectDescription();\n+\t\tprojectDescription.setName(\"test-project\");\n+\t\tprojectDescription.attachToEmfObject(rs);\n+\t\tChunkedResourceDescriptions index = new ChunkedResourceDescriptions(Collections.emptyMap(), rs);\n+\t\tindex.setContainer(projectDescription.getName(), newIndex);\n+\t\tresult.setResourceSet(rs);\n+\t\tresult.setDirtyFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setDeletedFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setAfterValidate((URI uri, Iterable<Issue> issues) -> {\n+\t\t\tIterables.<Issue> addAll(this.issues, issues);\n+\t\t\treturn IterableExtensions.isEmpty(issues);\n+\t\t});\n+\t\tresult.setAfterDeleteFile((URI uri) -> {\n+\t\t\tdeleted.add(uri);\n+\t\t});\n+\t\tresult.setAfterGenerateFile((URI source, URI target) -> {\n+\t\t\tgenerated.put(source, target);\n+\t\t});\n+\t\tresult.setState(new IndexState(newIndex, indexState.getFileMappings().copy()));\n+\t\tinit.apply(result);\n+\t\treturn result;\n+\t}\n+\n+\tprotected URI delete(URI uri) {\n+\t\ttry {\n+\t\t\tinMemoryURIHandler.delete(uri, Collections.emptyMap());\n+\t\t\treturn uri;\n+\t\t} catch (IOException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected URI uri(String path) {\n+\t\treturn URI.createURI(InMemoryURIHandler.SCHEME + \":/\" + path);\n+\t}\n+\n+\tprotected URI operator_minus(String path, String content) {\n+\t\ttry {\n+\t\t\tURI uri = uri(path);\n+\t\t\tOutputStream outputStream = inMemoryURIHandler.createOutputStream(uri, Collections.emptyMap());\n+\t\t\ttry {\n+\t\t\t\toutputStream.write(content.getBytes());\n+\t\t\t\toutputStream.close();\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NTk0Ng==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449665946", "bodyText": "dont what to refactor deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxMzY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxNDE4NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449414184", "bodyText": "Use more modern version of try-catch and remove \"close()\" operation then.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:09:56Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/build/AbstractIncrementalBuilderTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.build;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.Constants;\n+import org.eclipse.xtext.build.BuildRequest;\n+import org.eclipse.xtext.build.IncrementalBuilder;\n+import org.eclipse.xtext.build.IndexState;\n+import org.eclipse.xtext.generator.OutputConfiguration;\n+import org.eclipse.xtext.generator.OutputConfigurationAdapter;\n+import org.eclipse.xtext.generator.OutputConfigurationProvider;\n+import org.eclipse.xtext.junit4.util.InMemoryURIHandler;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.resource.impl.ChunkedResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsData;\n+import org.eclipse.xtext.validation.Issue;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Before;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Named;\n+\n+/**\n+ * Abstract base class for testing languages in the incremental builder.\n+ * \n+ * @since 2.9\n+ * \n+ * @noreference\n+ * @noimplement\n+ * \n+ * @deprecated Use org.eclipse.xtext.testing.builder.AbstractIncrementalBuilderTest instead.\n+ */\n+@Beta\n+@Deprecated\n+public abstract class AbstractIncrementalBuilderTest {\n+\t@Inject\n+\tprotected IncrementalBuilder incrementalBuilder;\n+\n+\t@Inject\n+\tprotected IndexState indexState;\n+\n+\t@Inject\n+\tprotected Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\t@Named(Constants.LANGUAGE_NAME)\n+\tprivate String languageName;\n+\n+\t@Inject\n+\tprivate OutputConfigurationProvider configurationProvider;\n+\n+\tprotected Multimap<URI, URI> generated;\n+\n+\tprotected List<URI> deleted;\n+\n+\tprotected List<Issue> issues;\n+\n+\tprotected InMemoryURIHandler inMemoryURIHandler;\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tclean();\n+\t\tinMemoryURIHandler = new InMemoryURIHandler();\n+\t}\n+\n+\tprotected List<Issue> clean() {\n+\t\tList<Issue> result = null;\n+\t\tgenerated = ArrayListMultimap.create();\n+\t\tdeleted = new ArrayList<>();\n+\t\tresult = issues = new ArrayList<>();\n+\t\treturn result;\n+\t}\n+\n+\tprotected IndexState build(BuildRequest buildRequest) {\n+\t\tclean();\n+\t\tindexState = incrementalBuilder.build(buildRequest, (URI it) -> getLanguages().getResourceServiceProvider(it)).getIndexState();\n+\t\treturn indexState;\n+\t}\n+\n+\tprotected void withOutputConfig(BuildRequest it, Procedure1<? super OutputConfiguration> init) {\n+\t\tOutputConfiguration config = Iterables.getFirst(configurationProvider.getOutputConfigurations(), null);\n+\t\tinit.apply(config);\n+\t\tOutputConfigurationAdapter adapter = new OutputConfigurationAdapter(Collections.unmodifiableMap(\n+\t\t\t\tCollectionLiterals.newHashMap(Pair.of(languageName, Collections.unmodifiableSet(Sets.newHashSet(config))))));\n+\t\tit.getResourceSet().eAdapters().add(adapter);\n+\t}\n+\n+\tprotected abstract IResourceServiceProvider.Registry getLanguages();\n+\n+\tprotected BuildRequest newBuildRequest(Procedure1<? super BuildRequest> init) {\n+\t\tBuildRequest result = new BuildRequest();\n+\t\tResourceDescriptionsData newIndex = indexState.getResourceDescriptions().copy();\n+\t\tresult.setBaseDir(uri(\"\"));\n+\t\tXtextResourceSet rs = resourceSetProvider.get();\n+\t\trs.getURIConverter().getURIHandlers().clear();\n+\t\trs.getURIConverter().getURIHandlers().add(inMemoryURIHandler);\n+\t\trs.setClasspathURIContext(AbstractIncrementalBuilderTest.class.getClassLoader());\n+\t\tProjectDescription projectDescription = new ProjectDescription();\n+\t\tprojectDescription.setName(\"test-project\");\n+\t\tprojectDescription.attachToEmfObject(rs);\n+\t\tChunkedResourceDescriptions index = new ChunkedResourceDescriptions(Collections.emptyMap(), rs);\n+\t\tindex.setContainer(projectDescription.getName(), newIndex);\n+\t\tresult.setResourceSet(rs);\n+\t\tresult.setDirtyFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setDeletedFiles(Collections.unmodifiableList(new ArrayList<>()));\n+\t\tresult.setAfterValidate((URI uri, Iterable<Issue> issues) -> {\n+\t\t\tIterables.<Issue> addAll(this.issues, issues);\n+\t\t\treturn IterableExtensions.isEmpty(issues);\n+\t\t});\n+\t\tresult.setAfterDeleteFile((URI uri) -> {\n+\t\t\tdeleted.add(uri);\n+\t\t});\n+\t\tresult.setAfterGenerateFile((URI source, URI target) -> {\n+\t\t\tgenerated.put(source, target);\n+\t\t});\n+\t\tresult.setState(new IndexState(newIndex, indexState.getFileMappings().copy()));\n+\t\tinit.apply(result);\n+\t\treturn result;\n+\t}\n+\n+\tprotected URI delete(URI uri) {\n+\t\ttry {\n+\t\t\tinMemoryURIHandler.delete(uri, Collections.emptyMap());\n+\t\t\treturn uri;\n+\t\t} catch (IOException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected URI uri(String path) {\n+\t\treturn URI.createURI(InMemoryURIHandler.SCHEME + \":/\" + path);\n+\t}\n+\n+\tprotected URI operator_minus(String path, String content) {\n+\t\ttry {\n+\t\t\tURI uri = uri(path);\n+\t\t\tOutputStream outputStream = inMemoryURIHandler.createOutputStream(uri, Collections.emptyMap());\n+\t\t\ttry {", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NTg1Mw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449665853", "bodyText": "dont what to refactor deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxNDE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxNTA0OA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449415048", "bodyText": "Moving the inner class to the end would be more readalble to me.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:11:55Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/ide/AbstractHierarchyBuilderTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.ide;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import javax.inject.Provider;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.ide.editor.hierarchy.AbstractHierarchyBuilder;\n+import org.eclipse.xtext.ide.editor.hierarchy.IHierarchyBuilder;\n+import org.eclipse.xtext.ide.editor.hierarchy.IHierarchyNode;\n+import org.eclipse.xtext.ide.editor.hierarchy.IHierarchyNodeReference;\n+import org.eclipse.xtext.junit4.validation.ValidationTestHelper;\n+import org.eclipse.xtext.resource.EObjectAtOffsetHelper;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.ui.editor.findrefs.SimpleLocalResourceAccess;\n+import org.eclipse.xtext.util.LazyStringInputStream;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Assert;\n+\n+/**\n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+@SuppressWarnings(\"deprecation\")\n+public abstract class AbstractHierarchyBuilderTest {\n+\tprotected static class HierarchyBuilderTestConfiguration {", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAwNQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449666005", "bodyText": "dont what to refactor deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxNTA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxNTM1NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449415354", "bodyText": "AbstractHierarchyBuilderTest.HierarchyBuilderTestConfiguration => HierarchyBuilderTestConfiguration\n(remove superflues prefix at all places in this class).", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:12:42Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/ide/AbstractHierarchyBuilderTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.ide;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import javax.inject.Provider;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.ide.editor.hierarchy.AbstractHierarchyBuilder;\n+import org.eclipse.xtext.ide.editor.hierarchy.IHierarchyBuilder;\n+import org.eclipse.xtext.ide.editor.hierarchy.IHierarchyNode;\n+import org.eclipse.xtext.ide.editor.hierarchy.IHierarchyNodeReference;\n+import org.eclipse.xtext.junit4.validation.ValidationTestHelper;\n+import org.eclipse.xtext.resource.EObjectAtOffsetHelper;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.ui.editor.findrefs.SimpleLocalResourceAccess;\n+import org.eclipse.xtext.util.LazyStringInputStream;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Assert;\n+\n+/**\n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+@SuppressWarnings(\"deprecation\")\n+public abstract class AbstractHierarchyBuilderTest {\n+\tprotected static class HierarchyBuilderTestConfiguration {\n+\t\tprivate Function1<? super ResourceSet, ? extends IHierarchyBuilder> hierarchyBuilderProvider;\n+\n+\t\tprivate Collection<Pair<String, String>> models = new ArrayList<>();\n+\n+\t\tprivate int index;\n+\n+\t\tprivate String resourceURI;\n+\n+\t\tprivate String expectedHierarchy;\n+\n+\t\tpublic Function1<? super ResourceSet, ? extends IHierarchyBuilder> getHierarchyBuilderProvider() {\n+\t\t\treturn hierarchyBuilderProvider;\n+\t\t}\n+\n+\t\tpublic void setHierarchyBuilderProvider(Function1<? super ResourceSet, ? extends IHierarchyBuilder> hierarchyBuilderProvider) {\n+\t\t\tthis.hierarchyBuilderProvider = hierarchyBuilderProvider;\n+\t\t}\n+\n+\t\tpublic Collection<Pair<String, String>> getModels() {\n+\t\t\treturn models;\n+\t\t}\n+\n+\t\tpublic void setModels(Collection<Pair<String, String>> models) {\n+\t\t\tthis.models = models;\n+\t\t}\n+\n+\t\tpublic int getIndex() {\n+\t\t\treturn index;\n+\t\t}\n+\n+\t\tpublic void setIndex(int index) {\n+\t\t\tthis.index = index;\n+\t\t}\n+\n+\t\tpublic String getResourceURI() {\n+\t\t\treturn resourceURI;\n+\t\t}\n+\n+\t\tpublic void setResourceURI(String resourceURI) {\n+\t\t\tthis.resourceURI = resourceURI;\n+\t\t}\n+\n+\t\tpublic String getExpectedHierarchy() {\n+\t\t\treturn expectedHierarchy;\n+\t\t}\n+\n+\t\tpublic void setExpectedHierarchy(String expectedHierarchy) {\n+\t\t\tthis.expectedHierarchy = expectedHierarchy;\n+\t\t}\n+\t}\n+\n+\t@Inject\n+\tprivate ValidationTestHelper validationTestHelper;\n+\n+\t@Inject\n+\tprivate EObjectAtOffsetHelper eObjectAtOffsetHelper;\n+\n+\t@Inject\n+\tprivate Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\tprivate IResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\tprotected void testBuildHierarchy(Procedure1<? super AbstractHierarchyBuilderTest.HierarchyBuilderTestConfiguration> configurator) {", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxNzA3OQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449417079", "bodyText": "throw new RuntimeException", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:16:52Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/ide/AbstractHierarchyBuilderTest.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.ide;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import javax.inject.Provider;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.ide.editor.hierarchy.AbstractHierarchyBuilder;\n+import org.eclipse.xtext.ide.editor.hierarchy.IHierarchyBuilder;\n+import org.eclipse.xtext.ide.editor.hierarchy.IHierarchyNode;\n+import org.eclipse.xtext.ide.editor.hierarchy.IHierarchyNodeReference;\n+import org.eclipse.xtext.junit4.validation.ValidationTestHelper;\n+import org.eclipse.xtext.resource.EObjectAtOffsetHelper;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.XtextResource;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.ui.editor.findrefs.SimpleLocalResourceAccess;\n+import org.eclipse.xtext.util.LazyStringInputStream;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pair;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+import org.junit.Assert;\n+\n+/**\n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+@SuppressWarnings(\"deprecation\")\n+public abstract class AbstractHierarchyBuilderTest {\n+\tprotected static class HierarchyBuilderTestConfiguration {\n+\t\tprivate Function1<? super ResourceSet, ? extends IHierarchyBuilder> hierarchyBuilderProvider;\n+\n+\t\tprivate Collection<Pair<String, String>> models = new ArrayList<>();\n+\n+\t\tprivate int index;\n+\n+\t\tprivate String resourceURI;\n+\n+\t\tprivate String expectedHierarchy;\n+\n+\t\tpublic Function1<? super ResourceSet, ? extends IHierarchyBuilder> getHierarchyBuilderProvider() {\n+\t\t\treturn hierarchyBuilderProvider;\n+\t\t}\n+\n+\t\tpublic void setHierarchyBuilderProvider(Function1<? super ResourceSet, ? extends IHierarchyBuilder> hierarchyBuilderProvider) {\n+\t\t\tthis.hierarchyBuilderProvider = hierarchyBuilderProvider;\n+\t\t}\n+\n+\t\tpublic Collection<Pair<String, String>> getModels() {\n+\t\t\treturn models;\n+\t\t}\n+\n+\t\tpublic void setModels(Collection<Pair<String, String>> models) {\n+\t\t\tthis.models = models;\n+\t\t}\n+\n+\t\tpublic int getIndex() {\n+\t\t\treturn index;\n+\t\t}\n+\n+\t\tpublic void setIndex(int index) {\n+\t\t\tthis.index = index;\n+\t\t}\n+\n+\t\tpublic String getResourceURI() {\n+\t\t\treturn resourceURI;\n+\t\t}\n+\n+\t\tpublic void setResourceURI(String resourceURI) {\n+\t\t\tthis.resourceURI = resourceURI;\n+\t\t}\n+\n+\t\tpublic String getExpectedHierarchy() {\n+\t\t\treturn expectedHierarchy;\n+\t\t}\n+\n+\t\tpublic void setExpectedHierarchy(String expectedHierarchy) {\n+\t\t\tthis.expectedHierarchy = expectedHierarchy;\n+\t\t}\n+\t}\n+\n+\t@Inject\n+\tprivate ValidationTestHelper validationTestHelper;\n+\n+\t@Inject\n+\tprivate EObjectAtOffsetHelper eObjectAtOffsetHelper;\n+\n+\t@Inject\n+\tprivate Provider<XtextResourceSet> resourceSetProvider;\n+\n+\t@Inject\n+\tprivate IResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\tprotected void testBuildHierarchy(Procedure1<? super AbstractHierarchyBuilderTest.HierarchyBuilderTestConfiguration> configurator) {\n+\t\tAbstractHierarchyBuilderTest.HierarchyBuilderTestConfiguration configuration = new AbstractHierarchyBuilderTest.HierarchyBuilderTestConfiguration();\n+\t\tconfigurator.apply(configuration);\n+\t\tResourceSet resourceSet = createResourceSet(configuration);\n+\t\tIHierarchyBuilder hierarchyBuilder = configuration.hierarchyBuilderProvider.apply(resourceSet);\n+\t\tString resourceURI = null;\n+\t\tif (configuration.resourceURI == null) {\n+\t\t\tresourceURI = Iterables.getLast(configuration.models, null).getKey();\n+\t\t} else {\n+\t\t\tresourceURI = configuration.resourceURI;\n+\t\t}\n+\t\tXtextResource resource = (XtextResource) resourceSet.getResource(URI.createURI(resourceURI), false);\n+\t\tURI rootURI = EcoreUtil2\n+\t\t\t\t.getPlatformResourceOrNormalizedURI(eObjectAtOffsetHelper.resolveElementAt(resource, configuration.index));\n+\t\tString actualHierarchy = toExpectation(rootURI, hierarchyBuilder);\n+\t\tAssert.assertEquals(configuration.expectedHierarchy, actualHierarchy);\n+\t}\n+\n+\tprotected ResourceSet createResourceSet(AbstractHierarchyBuilderTest.HierarchyBuilderTestConfiguration configuration) {\n+\t\ttry {\n+\t\t\tXtextResourceSet resourceSet = resourceSetProvider.get();\n+\t\t\tfor (Pair<String, String> model : configuration.models) {\n+\t\t\t\tResource resource = resourceSet.createResource(URI.createURI(model.getKey()));\n+\t\t\t\tresource.load(new LazyStringInputStream(model.getValue(), \"UTF-8\"), null);\n+\t\t\t\tvalidationTestHelper.assertNoIssues(resource);\n+\t\t\t}\n+\t\t\treturn resourceSet;\n+\t\t} catch (IOException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjE4NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449666185", "bodyText": "dont want to refactor deprectaed class", "author": "cdietrich", "createdAt": "2020-07-03T17:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxNzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxOTcyMg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449419722", "bodyText": "LoggingTester.LogEntry  => LogEntry", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:22:55Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/logging/LoggingTester.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.logging;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.log4j.Appender;\n+import org.apache.log4j.AppenderSkeleton;\n+import org.apache.log4j.Category;\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.apache.log4j.spi.Filter;\n+import org.apache.log4j.spi.LoggingEvent;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+import org.junit.Assert;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.common.primitives.Longs;\n+\n+/**\n+ * @deprecated Use org.eclipse.xtext.testing.logging.LoggingTester instead\n+ */\n+@Deprecated\n+public class LoggingTester {\n+\tpublic static class LogCapture {\n+\t\tprivate final List<LoggingTester.LogEntry> logEntries;\n+\n+\t\tpublic void assertNoLogEntries() {\n+\t\t\tassertNumberOfLogEntries(0);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(Level level, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, level, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number) {\n+\t\t\tassertNumberOfLogEntries(number, new String[] {});\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(number, null, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, Level level, String... messageParts) {\n+\t\t\tIterable<LoggingTester.LogEntry> passed = Iterables.filter(logEntries, (LoggingTester.LogEntry log) -> {\n+\t\t\t\treturn (level == null || Objects.equal(log.level, level)) && \n+\t\t\t\t\tIterableExtensions.forall(messageParts == null ? null : Arrays.asList(messageParts), (String it) -> log.message.contains(it));\n+\t\t\t});\n+\t\t\tif (Iterables.size(passed) != number) {\n+\t\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\t\tif (number == 0) {\n+\t\t\t\t\tbuilder.append(\"Expected no log entries\");\n+\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t} else {\n+\t\t\t\t\tif (number == 1) {\n+\t\t\t\t\t\tbuilder.append(\"Expected a log entry\");\n+\t\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tbuilder.append(\"Expected \");\n+\t\t\t\t\t\tbuilder.append(number);\n+\t\t\t\t\t\tbuilder.append(\" log entries\");\n+\t\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (level != null) {\n+\t\t\t\t\tbuilder.append(\"with \");\n+\t\t\t\t\tbuilder.append(level);\n+\t\t\t\t\tbuilder.append(\" level\");\n+\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(\"containing the phrases \");\n+\t\t\t\tbuilder.append(IterableExtensions.join(messageParts == null ? null : Arrays.asList(messageParts), \", \", (String it) -> \"\\\"\" + it + \"\\\"\"));\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tbuilder.append(\"but got\");\n+\t\t\t\tbuilder.newLine();\n+\t\t\t\tbuilder.append(logEntries);\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tAssert.fail(builder.toString());\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic LogCapture(List<LoggingTester.LogEntry> logEntries) {\n+\t\t\tthis.logEntries = logEntries;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((logEntries == null) ? 0 : logEntries.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogCapture other = (LogCapture) obj;\n+\t\t\tif (logEntries == null) {\n+\t\t\t\tif (other.logEntries != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!logEntries.equals(other.logEntries))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"logEntries\", logEntries);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic List<LoggingTester.LogEntry> getLogEntries() {\n+\t\t\treturn logEntries;\n+\t\t}\n+\t}\n+\n+\tpublic static class LogEntry {\n+\t\tprivate final String message;\n+\n+\t\tprivate final String source;\n+\n+\t\tprivate final long timeStamp;\n+\n+\t\tprivate final Level level;\n+\n+\t\tpublic LogEntry(String message, String source, long timeStamp, Level level) {\n+\t\t\tthis.message = message;\n+\t\t\tthis.source = source;\n+\t\t\tthis.timeStamp = timeStamp;\n+\t\t\tthis.level = level;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((level == null) ? 0 : level.hashCode());\n+\t\t\tresult = prime * result + ((message == null) ? 0 : message.hashCode());\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\tresult = prime * result + (int) (timeStamp ^ (timeStamp >>> 32));\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogEntry other = (LogEntry) obj;\n+\t\t\tif (level == null) {\n+\t\t\t\tif (other.level != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!level.equals(other.level))\n+\t\t\t\treturn false;\n+\t\t\tif (message == null) {\n+\t\t\t\tif (other.message != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!message.equals(other.message))\n+\t\t\t\treturn false;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\tif (timeStamp != other.timeStamp)\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"message\", message);\n+\t\t\tb.add(\"source\", source);\n+\t\t\tb.add(\"timeStamp\", timeStamp);\n+\t\t\tb.add(\"level\", level);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getMessage() {\n+\t\t\treturn message;\n+\t\t}\n+\n+\t\tpublic String getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\n+\t\tpublic long getTimeStamp() {\n+\t\t\treturn timeStamp;\n+\t\t}\n+\n+\t\tpublic Level getLevel() {\n+\t\t\treturn level;\n+\t\t}\n+\t}\n+\n+\tprivate static class QueueAppender extends AppenderSkeleton {\n+\t\tprivate final Queue<LoggingTester.LogEntry> events = new ConcurrentLinkedQueue<LoggingTester.LogEntry>();\n+\n+\t\t@Override\n+\t\tpublic boolean requiresLayout() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() {\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void append(LoggingEvent event) {\n+\t\t\tLoggingTester.LogEntry entry = new LoggingTester.LogEntry(event.getRenderedMessage(), event.getLoggerName(),", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMDAzNQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449420035", "bodyText": "Better remove this method then to supress the warning!?", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:23:40Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/logging/LoggingTester.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.logging;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.log4j.Appender;\n+import org.apache.log4j.AppenderSkeleton;\n+import org.apache.log4j.Category;\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.apache.log4j.spi.Filter;\n+import org.apache.log4j.spi.LoggingEvent;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+import org.junit.Assert;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.common.primitives.Longs;\n+\n+/**\n+ * @deprecated Use org.eclipse.xtext.testing.logging.LoggingTester instead\n+ */\n+@Deprecated\n+public class LoggingTester {\n+\tpublic static class LogCapture {\n+\t\tprivate final List<LoggingTester.LogEntry> logEntries;\n+\n+\t\tpublic void assertNoLogEntries() {\n+\t\t\tassertNumberOfLogEntries(0);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(Level level, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, level, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number) {\n+\t\t\tassertNumberOfLogEntries(number, new String[] {});\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(number, null, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, Level level, String... messageParts) {\n+\t\t\tIterable<LoggingTester.LogEntry> passed = Iterables.filter(logEntries, (LoggingTester.LogEntry log) -> {\n+\t\t\t\treturn (level == null || Objects.equal(log.level, level)) && \n+\t\t\t\t\tIterableExtensions.forall(messageParts == null ? null : Arrays.asList(messageParts), (String it) -> log.message.contains(it));\n+\t\t\t});\n+\t\t\tif (Iterables.size(passed) != number) {\n+\t\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\t\tif (number == 0) {\n+\t\t\t\t\tbuilder.append(\"Expected no log entries\");\n+\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t} else {\n+\t\t\t\t\tif (number == 1) {\n+\t\t\t\t\t\tbuilder.append(\"Expected a log entry\");\n+\t\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tbuilder.append(\"Expected \");\n+\t\t\t\t\t\tbuilder.append(number);\n+\t\t\t\t\t\tbuilder.append(\" log entries\");\n+\t\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (level != null) {\n+\t\t\t\t\tbuilder.append(\"with \");\n+\t\t\t\t\tbuilder.append(level);\n+\t\t\t\t\tbuilder.append(\" level\");\n+\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(\"containing the phrases \");\n+\t\t\t\tbuilder.append(IterableExtensions.join(messageParts == null ? null : Arrays.asList(messageParts), \", \", (String it) -> \"\\\"\" + it + \"\\\"\"));\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tbuilder.append(\"but got\");\n+\t\t\t\tbuilder.newLine();\n+\t\t\t\tbuilder.append(logEntries);\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tAssert.fail(builder.toString());\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic LogCapture(List<LoggingTester.LogEntry> logEntries) {\n+\t\t\tthis.logEntries = logEntries;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((logEntries == null) ? 0 : logEntries.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogCapture other = (LogCapture) obj;\n+\t\t\tif (logEntries == null) {\n+\t\t\t\tif (other.logEntries != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!logEntries.equals(other.logEntries))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"logEntries\", logEntries);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic List<LoggingTester.LogEntry> getLogEntries() {\n+\t\t\treturn logEntries;\n+\t\t}\n+\t}\n+\n+\tpublic static class LogEntry {\n+\t\tprivate final String message;\n+\n+\t\tprivate final String source;\n+\n+\t\tprivate final long timeStamp;\n+\n+\t\tprivate final Level level;\n+\n+\t\tpublic LogEntry(String message, String source, long timeStamp, Level level) {\n+\t\t\tthis.message = message;\n+\t\t\tthis.source = source;\n+\t\t\tthis.timeStamp = timeStamp;\n+\t\t\tthis.level = level;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((level == null) ? 0 : level.hashCode());\n+\t\t\tresult = prime * result + ((message == null) ? 0 : message.hashCode());\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\tresult = prime * result + (int) (timeStamp ^ (timeStamp >>> 32));\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogEntry other = (LogEntry) obj;\n+\t\t\tif (level == null) {\n+\t\t\t\tif (other.level != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!level.equals(other.level))\n+\t\t\t\treturn false;\n+\t\t\tif (message == null) {\n+\t\t\t\tif (other.message != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!message.equals(other.message))\n+\t\t\t\treturn false;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\tif (timeStamp != other.timeStamp)\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"message\", message);\n+\t\t\tb.add(\"source\", source);\n+\t\t\tb.add(\"timeStamp\", timeStamp);\n+\t\t\tb.add(\"level\", level);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getMessage() {\n+\t\t\treturn message;\n+\t\t}\n+\n+\t\tpublic String getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\n+\t\tpublic long getTimeStamp() {\n+\t\t\treturn timeStamp;\n+\t\t}\n+\n+\t\tpublic Level getLevel() {\n+\t\t\treturn level;\n+\t\t}\n+\t}\n+\n+\tprivate static class QueueAppender extends AppenderSkeleton {\n+\t\tprivate final Queue<LoggingTester.LogEntry> events = new ConcurrentLinkedQueue<LoggingTester.LogEntry>();\n+\n+\t\t@Override\n+\t\tpublic boolean requiresLayout() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() {\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void append(LoggingEvent event) {\n+\t\t\tLoggingTester.LogEntry entry = new LoggingTester.LogEntry(event.getRenderedMessage(), event.getLoggerName(),\n+\t\t\t\t\tevent.getTimeStamp(), event.getLevel());\n+\t\t\tevents.add(entry);\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic Queue<LoggingTester.LogEntry> getEvents() {\n+\t\t\treturn events;\n+\t\t}\n+\t}\n+\n+\tprivate static class SourceFilter extends Filter {\n+\t\tprivate final Logger source;\n+\n+\t\t@Override\n+\t\tpublic int decide(LoggingEvent event) {\n+\t\t\tif (Objects.equal(event.getLoggerName(), source.getName())) {\n+\t\t\t\treturn Filter.DENY;\n+\t\t\t} else {\n+\t\t\t\treturn Filter.NEUTRAL;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic SourceFilter(Logger source) {\n+\t\t\tthis.source = source;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tSourceFilter other = (SourceFilter) obj;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn new ToStringBuilder(this).addAllFields().toString();\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjQ5Ng==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449666496", "bodyText": "dont want to refactor deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMDAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMDI1NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449420255", "bodyText": "LoggingTester.QueueAppender => QueueAppender", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:24:13Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/logging/LoggingTester.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.logging;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.log4j.Appender;\n+import org.apache.log4j.AppenderSkeleton;\n+import org.apache.log4j.Category;\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.apache.log4j.spi.Filter;\n+import org.apache.log4j.spi.LoggingEvent;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+import org.junit.Assert;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.common.primitives.Longs;\n+\n+/**\n+ * @deprecated Use org.eclipse.xtext.testing.logging.LoggingTester instead\n+ */\n+@Deprecated\n+public class LoggingTester {\n+\tpublic static class LogCapture {\n+\t\tprivate final List<LoggingTester.LogEntry> logEntries;\n+\n+\t\tpublic void assertNoLogEntries() {\n+\t\t\tassertNumberOfLogEntries(0);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(Level level, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, level, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number) {\n+\t\t\tassertNumberOfLogEntries(number, new String[] {});\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(number, null, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, Level level, String... messageParts) {\n+\t\t\tIterable<LoggingTester.LogEntry> passed = Iterables.filter(logEntries, (LoggingTester.LogEntry log) -> {\n+\t\t\t\treturn (level == null || Objects.equal(log.level, level)) && \n+\t\t\t\t\tIterableExtensions.forall(messageParts == null ? null : Arrays.asList(messageParts), (String it) -> log.message.contains(it));\n+\t\t\t});\n+\t\t\tif (Iterables.size(passed) != number) {\n+\t\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\t\tif (number == 0) {\n+\t\t\t\t\tbuilder.append(\"Expected no log entries\");\n+\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t} else {\n+\t\t\t\t\tif (number == 1) {\n+\t\t\t\t\t\tbuilder.append(\"Expected a log entry\");\n+\t\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tbuilder.append(\"Expected \");\n+\t\t\t\t\t\tbuilder.append(number);\n+\t\t\t\t\t\tbuilder.append(\" log entries\");\n+\t\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (level != null) {\n+\t\t\t\t\tbuilder.append(\"with \");\n+\t\t\t\t\tbuilder.append(level);\n+\t\t\t\t\tbuilder.append(\" level\");\n+\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(\"containing the phrases \");\n+\t\t\t\tbuilder.append(IterableExtensions.join(messageParts == null ? null : Arrays.asList(messageParts), \", \", (String it) -> \"\\\"\" + it + \"\\\"\"));\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tbuilder.append(\"but got\");\n+\t\t\t\tbuilder.newLine();\n+\t\t\t\tbuilder.append(logEntries);\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tAssert.fail(builder.toString());\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic LogCapture(List<LoggingTester.LogEntry> logEntries) {\n+\t\t\tthis.logEntries = logEntries;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((logEntries == null) ? 0 : logEntries.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogCapture other = (LogCapture) obj;\n+\t\t\tif (logEntries == null) {\n+\t\t\t\tif (other.logEntries != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!logEntries.equals(other.logEntries))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"logEntries\", logEntries);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic List<LoggingTester.LogEntry> getLogEntries() {\n+\t\t\treturn logEntries;\n+\t\t}\n+\t}\n+\n+\tpublic static class LogEntry {\n+\t\tprivate final String message;\n+\n+\t\tprivate final String source;\n+\n+\t\tprivate final long timeStamp;\n+\n+\t\tprivate final Level level;\n+\n+\t\tpublic LogEntry(String message, String source, long timeStamp, Level level) {\n+\t\t\tthis.message = message;\n+\t\t\tthis.source = source;\n+\t\t\tthis.timeStamp = timeStamp;\n+\t\t\tthis.level = level;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((level == null) ? 0 : level.hashCode());\n+\t\t\tresult = prime * result + ((message == null) ? 0 : message.hashCode());\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\tresult = prime * result + (int) (timeStamp ^ (timeStamp >>> 32));\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogEntry other = (LogEntry) obj;\n+\t\t\tif (level == null) {\n+\t\t\t\tif (other.level != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!level.equals(other.level))\n+\t\t\t\treturn false;\n+\t\t\tif (message == null) {\n+\t\t\t\tif (other.message != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!message.equals(other.message))\n+\t\t\t\treturn false;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\tif (timeStamp != other.timeStamp)\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"message\", message);\n+\t\t\tb.add(\"source\", source);\n+\t\t\tb.add(\"timeStamp\", timeStamp);\n+\t\t\tb.add(\"level\", level);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getMessage() {\n+\t\t\treturn message;\n+\t\t}\n+\n+\t\tpublic String getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\n+\t\tpublic long getTimeStamp() {\n+\t\t\treturn timeStamp;\n+\t\t}\n+\n+\t\tpublic Level getLevel() {\n+\t\t\treturn level;\n+\t\t}\n+\t}\n+\n+\tprivate static class QueueAppender extends AppenderSkeleton {\n+\t\tprivate final Queue<LoggingTester.LogEntry> events = new ConcurrentLinkedQueue<LoggingTester.LogEntry>();\n+\n+\t\t@Override\n+\t\tpublic boolean requiresLayout() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() {\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void append(LoggingEvent event) {\n+\t\t\tLoggingTester.LogEntry entry = new LoggingTester.LogEntry(event.getRenderedMessage(), event.getLoggerName(),\n+\t\t\t\t\tevent.getTimeStamp(), event.getLevel());\n+\t\t\tevents.add(entry);\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic Queue<LoggingTester.LogEntry> getEvents() {\n+\t\t\treturn events;\n+\t\t}\n+\t}\n+\n+\tprivate static class SourceFilter extends Filter {\n+\t\tprivate final Logger source;\n+\n+\t\t@Override\n+\t\tpublic int decide(LoggingEvent event) {\n+\t\t\tif (Objects.equal(event.getLoggerName(), source.getName())) {\n+\t\t\t\treturn Filter.DENY;\n+\t\t\t} else {\n+\t\t\t\treturn Filter.NEUTRAL;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic SourceFilter(Logger source) {\n+\t\t\tthis.source = source;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tSourceFilter other = (SourceFilter) obj;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn new ToStringBuilder(this).addAllFields().toString();\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic Logger getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\t}\n+\n+\tpublic static LoggingTester.LogCapture captureLogging(Level level, Class<?> source, Runnable action) {\n+\t\tLogger logger = Logger.getLogger(source);\n+\t\tLoggingTester.QueueAppender appender = new LoggingTester.QueueAppender();", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMDM4MQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449420381", "bodyText": "LoggingTester.SourceFilter  => SourceFilter", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:24:31Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/logging/LoggingTester.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.logging;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.log4j.Appender;\n+import org.apache.log4j.AppenderSkeleton;\n+import org.apache.log4j.Category;\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.apache.log4j.spi.Filter;\n+import org.apache.log4j.spi.LoggingEvent;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+import org.junit.Assert;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.common.primitives.Longs;\n+\n+/**\n+ * @deprecated Use org.eclipse.xtext.testing.logging.LoggingTester instead\n+ */\n+@Deprecated\n+public class LoggingTester {\n+\tpublic static class LogCapture {\n+\t\tprivate final List<LoggingTester.LogEntry> logEntries;\n+\n+\t\tpublic void assertNoLogEntries() {\n+\t\t\tassertNumberOfLogEntries(0);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(Level level, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, level, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number) {\n+\t\t\tassertNumberOfLogEntries(number, new String[] {});\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(number, null, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, Level level, String... messageParts) {\n+\t\t\tIterable<LoggingTester.LogEntry> passed = Iterables.filter(logEntries, (LoggingTester.LogEntry log) -> {\n+\t\t\t\treturn (level == null || Objects.equal(log.level, level)) && \n+\t\t\t\t\tIterableExtensions.forall(messageParts == null ? null : Arrays.asList(messageParts), (String it) -> log.message.contains(it));\n+\t\t\t});\n+\t\t\tif (Iterables.size(passed) != number) {\n+\t\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\t\tif (number == 0) {\n+\t\t\t\t\tbuilder.append(\"Expected no log entries\");\n+\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t} else {\n+\t\t\t\t\tif (number == 1) {\n+\t\t\t\t\t\tbuilder.append(\"Expected a log entry\");\n+\t\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tbuilder.append(\"Expected \");\n+\t\t\t\t\t\tbuilder.append(number);\n+\t\t\t\t\t\tbuilder.append(\" log entries\");\n+\t\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (level != null) {\n+\t\t\t\t\tbuilder.append(\"with \");\n+\t\t\t\t\tbuilder.append(level);\n+\t\t\t\t\tbuilder.append(\" level\");\n+\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(\"containing the phrases \");\n+\t\t\t\tbuilder.append(IterableExtensions.join(messageParts == null ? null : Arrays.asList(messageParts), \", \", (String it) -> \"\\\"\" + it + \"\\\"\"));\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tbuilder.append(\"but got\");\n+\t\t\t\tbuilder.newLine();\n+\t\t\t\tbuilder.append(logEntries);\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tAssert.fail(builder.toString());\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic LogCapture(List<LoggingTester.LogEntry> logEntries) {\n+\t\t\tthis.logEntries = logEntries;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((logEntries == null) ? 0 : logEntries.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogCapture other = (LogCapture) obj;\n+\t\t\tif (logEntries == null) {\n+\t\t\t\tif (other.logEntries != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!logEntries.equals(other.logEntries))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"logEntries\", logEntries);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic List<LoggingTester.LogEntry> getLogEntries() {\n+\t\t\treturn logEntries;\n+\t\t}\n+\t}\n+\n+\tpublic static class LogEntry {\n+\t\tprivate final String message;\n+\n+\t\tprivate final String source;\n+\n+\t\tprivate final long timeStamp;\n+\n+\t\tprivate final Level level;\n+\n+\t\tpublic LogEntry(String message, String source, long timeStamp, Level level) {\n+\t\t\tthis.message = message;\n+\t\t\tthis.source = source;\n+\t\t\tthis.timeStamp = timeStamp;\n+\t\t\tthis.level = level;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((level == null) ? 0 : level.hashCode());\n+\t\t\tresult = prime * result + ((message == null) ? 0 : message.hashCode());\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\tresult = prime * result + (int) (timeStamp ^ (timeStamp >>> 32));\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogEntry other = (LogEntry) obj;\n+\t\t\tif (level == null) {\n+\t\t\t\tif (other.level != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!level.equals(other.level))\n+\t\t\t\treturn false;\n+\t\t\tif (message == null) {\n+\t\t\t\tif (other.message != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!message.equals(other.message))\n+\t\t\t\treturn false;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\tif (timeStamp != other.timeStamp)\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"message\", message);\n+\t\t\tb.add(\"source\", source);\n+\t\t\tb.add(\"timeStamp\", timeStamp);\n+\t\t\tb.add(\"level\", level);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getMessage() {\n+\t\t\treturn message;\n+\t\t}\n+\n+\t\tpublic String getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\n+\t\tpublic long getTimeStamp() {\n+\t\t\treturn timeStamp;\n+\t\t}\n+\n+\t\tpublic Level getLevel() {\n+\t\t\treturn level;\n+\t\t}\n+\t}\n+\n+\tprivate static class QueueAppender extends AppenderSkeleton {\n+\t\tprivate final Queue<LoggingTester.LogEntry> events = new ConcurrentLinkedQueue<LoggingTester.LogEntry>();\n+\n+\t\t@Override\n+\t\tpublic boolean requiresLayout() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() {\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void append(LoggingEvent event) {\n+\t\t\tLoggingTester.LogEntry entry = new LoggingTester.LogEntry(event.getRenderedMessage(), event.getLoggerName(),\n+\t\t\t\t\tevent.getTimeStamp(), event.getLevel());\n+\t\t\tevents.add(entry);\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic Queue<LoggingTester.LogEntry> getEvents() {\n+\t\t\treturn events;\n+\t\t}\n+\t}\n+\n+\tprivate static class SourceFilter extends Filter {\n+\t\tprivate final Logger source;\n+\n+\t\t@Override\n+\t\tpublic int decide(LoggingEvent event) {\n+\t\t\tif (Objects.equal(event.getLoggerName(), source.getName())) {\n+\t\t\t\treturn Filter.DENY;\n+\t\t\t} else {\n+\t\t\t\treturn Filter.NEUTRAL;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic SourceFilter(Logger source) {\n+\t\t\tthis.source = source;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tSourceFilter other = (SourceFilter) obj;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn new ToStringBuilder(this).addAllFields().toString();\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic Logger getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\t}\n+\n+\tpublic static LoggingTester.LogCapture captureLogging(Level level, Class<?> source, Runnable action) {\n+\t\tLogger logger = Logger.getLogger(source);\n+\t\tLoggingTester.QueueAppender appender = new LoggingTester.QueueAppender();\n+\t\tLevel oldLevel = logger.getLevel();\n+\t\tList<Appender> allAppenders = LoggingTester.appenderHierarchy(logger);\n+\t\tLoggingTester.SourceFilter filter = new LoggingTester.SourceFilter(logger);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMDUwMQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449420501", "bodyText": "LoggingTester.LogEntry => LogEntry", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:24:48Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/logging/LoggingTester.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.logging;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.log4j.Appender;\n+import org.apache.log4j.AppenderSkeleton;\n+import org.apache.log4j.Category;\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.apache.log4j.spi.Filter;\n+import org.apache.log4j.spi.LoggingEvent;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+import org.junit.Assert;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.common.primitives.Longs;\n+\n+/**\n+ * @deprecated Use org.eclipse.xtext.testing.logging.LoggingTester instead\n+ */\n+@Deprecated\n+public class LoggingTester {\n+\tpublic static class LogCapture {\n+\t\tprivate final List<LoggingTester.LogEntry> logEntries;\n+\n+\t\tpublic void assertNoLogEntries() {\n+\t\t\tassertNumberOfLogEntries(0);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(Level level, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, level, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number) {\n+\t\t\tassertNumberOfLogEntries(number, new String[] {});\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(number, null, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, Level level, String... messageParts) {\n+\t\t\tIterable<LoggingTester.LogEntry> passed = Iterables.filter(logEntries, (LoggingTester.LogEntry log) -> {\n+\t\t\t\treturn (level == null || Objects.equal(log.level, level)) && \n+\t\t\t\t\tIterableExtensions.forall(messageParts == null ? null : Arrays.asList(messageParts), (String it) -> log.message.contains(it));\n+\t\t\t});\n+\t\t\tif (Iterables.size(passed) != number) {\n+\t\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\t\tif (number == 0) {\n+\t\t\t\t\tbuilder.append(\"Expected no log entries\");\n+\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t} else {\n+\t\t\t\t\tif (number == 1) {\n+\t\t\t\t\t\tbuilder.append(\"Expected a log entry\");\n+\t\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tbuilder.append(\"Expected \");\n+\t\t\t\t\t\tbuilder.append(number);\n+\t\t\t\t\t\tbuilder.append(\" log entries\");\n+\t\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (level != null) {\n+\t\t\t\t\tbuilder.append(\"with \");\n+\t\t\t\t\tbuilder.append(level);\n+\t\t\t\t\tbuilder.append(\" level\");\n+\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(\"containing the phrases \");\n+\t\t\t\tbuilder.append(IterableExtensions.join(messageParts == null ? null : Arrays.asList(messageParts), \", \", (String it) -> \"\\\"\" + it + \"\\\"\"));\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tbuilder.append(\"but got\");\n+\t\t\t\tbuilder.newLine();\n+\t\t\t\tbuilder.append(logEntries);\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tAssert.fail(builder.toString());\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic LogCapture(List<LoggingTester.LogEntry> logEntries) {\n+\t\t\tthis.logEntries = logEntries;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((logEntries == null) ? 0 : logEntries.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogCapture other = (LogCapture) obj;\n+\t\t\tif (logEntries == null) {\n+\t\t\t\tif (other.logEntries != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!logEntries.equals(other.logEntries))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"logEntries\", logEntries);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic List<LoggingTester.LogEntry> getLogEntries() {\n+\t\t\treturn logEntries;\n+\t\t}\n+\t}\n+\n+\tpublic static class LogEntry {\n+\t\tprivate final String message;\n+\n+\t\tprivate final String source;\n+\n+\t\tprivate final long timeStamp;\n+\n+\t\tprivate final Level level;\n+\n+\t\tpublic LogEntry(String message, String source, long timeStamp, Level level) {\n+\t\t\tthis.message = message;\n+\t\t\tthis.source = source;\n+\t\t\tthis.timeStamp = timeStamp;\n+\t\t\tthis.level = level;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((level == null) ? 0 : level.hashCode());\n+\t\t\tresult = prime * result + ((message == null) ? 0 : message.hashCode());\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\tresult = prime * result + (int) (timeStamp ^ (timeStamp >>> 32));\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogEntry other = (LogEntry) obj;\n+\t\t\tif (level == null) {\n+\t\t\t\tif (other.level != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!level.equals(other.level))\n+\t\t\t\treturn false;\n+\t\t\tif (message == null) {\n+\t\t\t\tif (other.message != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!message.equals(other.message))\n+\t\t\t\treturn false;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\tif (timeStamp != other.timeStamp)\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"message\", message);\n+\t\t\tb.add(\"source\", source);\n+\t\t\tb.add(\"timeStamp\", timeStamp);\n+\t\t\tb.add(\"level\", level);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getMessage() {\n+\t\t\treturn message;\n+\t\t}\n+\n+\t\tpublic String getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\n+\t\tpublic long getTimeStamp() {\n+\t\t\treturn timeStamp;\n+\t\t}\n+\n+\t\tpublic Level getLevel() {\n+\t\t\treturn level;\n+\t\t}\n+\t}\n+\n+\tprivate static class QueueAppender extends AppenderSkeleton {\n+\t\tprivate final Queue<LoggingTester.LogEntry> events = new ConcurrentLinkedQueue<LoggingTester.LogEntry>();\n+\n+\t\t@Override\n+\t\tpublic boolean requiresLayout() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() {\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void append(LoggingEvent event) {\n+\t\t\tLoggingTester.LogEntry entry = new LoggingTester.LogEntry(event.getRenderedMessage(), event.getLoggerName(),\n+\t\t\t\t\tevent.getTimeStamp(), event.getLevel());\n+\t\t\tevents.add(entry);\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic Queue<LoggingTester.LogEntry> getEvents() {\n+\t\t\treturn events;\n+\t\t}\n+\t}\n+\n+\tprivate static class SourceFilter extends Filter {\n+\t\tprivate final Logger source;\n+\n+\t\t@Override\n+\t\tpublic int decide(LoggingEvent event) {\n+\t\t\tif (Objects.equal(event.getLoggerName(), source.getName())) {\n+\t\t\t\treturn Filter.DENY;\n+\t\t\t} else {\n+\t\t\t\treturn Filter.NEUTRAL;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic SourceFilter(Logger source) {\n+\t\t\tthis.source = source;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tSourceFilter other = (SourceFilter) obj;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn new ToStringBuilder(this).addAllFields().toString();\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic Logger getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\t}\n+\n+\tpublic static LoggingTester.LogCapture captureLogging(Level level, Class<?> source, Runnable action) {\n+\t\tLogger logger = Logger.getLogger(source);\n+\t\tLoggingTester.QueueAppender appender = new LoggingTester.QueueAppender();\n+\t\tLevel oldLevel = logger.getLevel();\n+\t\tList<Appender> allAppenders = LoggingTester.appenderHierarchy(logger);\n+\t\tLoggingTester.SourceFilter filter = new LoggingTester.SourceFilter(logger);\n+\t\ttry {\n+\t\t\tfor (Appender it : allAppenders) {\n+\t\t\t\tit.addFilter(filter);\n+\t\t\t}\n+\t\t\tlogger.addAppender(appender);\n+\t\t\tlogger.setLevel(level);\n+\t\t\taction.run();\n+\t\t\tList<LoggingTester.LogEntry> events = IterableExtensions.<LoggingTester.LogEntry> sortWith(", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMTEwMQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449421101", "bodyText": "LoggingTester.LogEntry  => LogEntry", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:26:09Z", "path": "org.eclipse.xtext.junit4/src/org/eclipse/xtext/junit4/logging/LoggingTester.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.junit4.logging;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.apache.log4j.Appender;\n+import org.apache.log4j.AppenderSkeleton;\n+import org.apache.log4j.Category;\n+import org.apache.log4j.Level;\n+import org.apache.log4j.Logger;\n+import org.apache.log4j.spi.Filter;\n+import org.apache.log4j.spi.LoggingEvent;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+import org.junit.Assert;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Iterables;\n+import com.google.common.primitives.Longs;\n+\n+/**\n+ * @deprecated Use org.eclipse.xtext.testing.logging.LoggingTester instead\n+ */\n+@Deprecated\n+public class LoggingTester {\n+\tpublic static class LogCapture {\n+\t\tprivate final List<LoggingTester.LogEntry> logEntries;\n+\n+\t\tpublic void assertNoLogEntries() {\n+\t\t\tassertNumberOfLogEntries(0);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertLogEntry(Level level, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(1, level, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number) {\n+\t\t\tassertNumberOfLogEntries(number, new String[] {});\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, String... messageParts) {\n+\t\t\tassertNumberOfLogEntries(number, null, messageParts);\n+\t\t}\n+\n+\t\tpublic void assertNumberOfLogEntries(int number, Level level, String... messageParts) {\n+\t\t\tIterable<LoggingTester.LogEntry> passed = Iterables.filter(logEntries, (LoggingTester.LogEntry log) -> {\n+\t\t\t\treturn (level == null || Objects.equal(log.level, level)) && \n+\t\t\t\t\tIterableExtensions.forall(messageParts == null ? null : Arrays.asList(messageParts), (String it) -> log.message.contains(it));\n+\t\t\t});\n+\t\t\tif (Iterables.size(passed) != number) {\n+\t\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\t\tif (number == 0) {\n+\t\t\t\t\tbuilder.append(\"Expected no log entries\");\n+\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t} else {\n+\t\t\t\t\tif (number == 1) {\n+\t\t\t\t\t\tbuilder.append(\"Expected a log entry\");\n+\t\t\t\t\t\tbuilder.newLine();\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tbuilder.append(\"Expected \");\n+\t\t\t\t\t\tbuilder.append(number);\n+\t\t\t\t\t\tbuilder.append(\" log entries\");\n+\t\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (level != null) {\n+\t\t\t\t\tbuilder.append(\"with \");\n+\t\t\t\t\tbuilder.append(level);\n+\t\t\t\t\tbuilder.append(\" level\");\n+\t\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\t}\n+\t\t\t\tbuilder.append(\"containing the phrases \");\n+\t\t\t\tbuilder.append(IterableExtensions.join(messageParts == null ? null : Arrays.asList(messageParts), \", \", (String it) -> \"\\\"\" + it + \"\\\"\"));\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tbuilder.append(\"but got\");\n+\t\t\t\tbuilder.newLine();\n+\t\t\t\tbuilder.append(logEntries);\n+\t\t\t\tbuilder.newLineIfNotEmpty();\n+\t\t\t\tAssert.fail(builder.toString());\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic LogCapture(List<LoggingTester.LogEntry> logEntries) {\n+\t\t\tthis.logEntries = logEntries;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((logEntries == null) ? 0 : logEntries.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogCapture other = (LogCapture) obj;\n+\t\t\tif (logEntries == null) {\n+\t\t\t\tif (other.logEntries != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!logEntries.equals(other.logEntries))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"logEntries\", logEntries);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic List<LoggingTester.LogEntry> getLogEntries() {\n+\t\t\treturn logEntries;\n+\t\t}\n+\t}\n+\n+\tpublic static class LogEntry {\n+\t\tprivate final String message;\n+\n+\t\tprivate final String source;\n+\n+\t\tprivate final long timeStamp;\n+\n+\t\tprivate final Level level;\n+\n+\t\tpublic LogEntry(String message, String source, long timeStamp, Level level) {\n+\t\t\tthis.message = message;\n+\t\t\tthis.source = source;\n+\t\t\tthis.timeStamp = timeStamp;\n+\t\t\tthis.level = level;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((level == null) ? 0 : level.hashCode());\n+\t\t\tresult = prime * result + ((message == null) ? 0 : message.hashCode());\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\tresult = prime * result + (int) (timeStamp ^ (timeStamp >>> 32));\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tLogEntry other = (LogEntry) obj;\n+\t\t\tif (level == null) {\n+\t\t\t\tif (other.level != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!level.equals(other.level))\n+\t\t\t\treturn false;\n+\t\t\tif (message == null) {\n+\t\t\t\tif (other.message != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!message.equals(other.message))\n+\t\t\t\treturn false;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\tif (timeStamp != other.timeStamp)\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\t\tb.add(\"message\", message);\n+\t\t\tb.add(\"source\", source);\n+\t\t\tb.add(\"timeStamp\", timeStamp);\n+\t\t\tb.add(\"level\", level);\n+\t\t\treturn b.toString();\n+\t\t}\n+\n+\t\tpublic String getMessage() {\n+\t\t\treturn message;\n+\t\t}\n+\n+\t\tpublic String getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\n+\t\tpublic long getTimeStamp() {\n+\t\t\treturn timeStamp;\n+\t\t}\n+\n+\t\tpublic Level getLevel() {\n+\t\t\treturn level;\n+\t\t}\n+\t}\n+\n+\tprivate static class QueueAppender extends AppenderSkeleton {\n+\t\tprivate final Queue<LoggingTester.LogEntry> events = new ConcurrentLinkedQueue<LoggingTester.LogEntry>();\n+\n+\t\t@Override\n+\t\tpublic boolean requiresLayout() {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() {\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected void append(LoggingEvent event) {\n+\t\t\tLoggingTester.LogEntry entry = new LoggingTester.LogEntry(event.getRenderedMessage(), event.getLoggerName(),\n+\t\t\t\t\tevent.getTimeStamp(), event.getLevel());\n+\t\t\tevents.add(entry);\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic Queue<LoggingTester.LogEntry> getEvents() {\n+\t\t\treturn events;\n+\t\t}\n+\t}\n+\n+\tprivate static class SourceFilter extends Filter {\n+\t\tprivate final Logger source;\n+\n+\t\t@Override\n+\t\tpublic int decide(LoggingEvent event) {\n+\t\t\tif (Objects.equal(event.getLoggerName(), source.getName())) {\n+\t\t\t\treturn Filter.DENY;\n+\t\t\t} else {\n+\t\t\t\treturn Filter.NEUTRAL;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic SourceFilter(Logger source) {\n+\t\t\tthis.source = source;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((source == null) ? 0 : source.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tSourceFilter other = (SourceFilter) obj;\n+\t\t\tif (source == null) {\n+\t\t\t\tif (other.source != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!source.equals(other.source))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn new ToStringBuilder(this).addAllFields().toString();\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tpublic Logger getSource() {\n+\t\t\treturn source;\n+\t\t}\n+\t}\n+\n+\tpublic static LoggingTester.LogCapture captureLogging(Level level, Class<?> source, Runnable action) {\n+\t\tLogger logger = Logger.getLogger(source);\n+\t\tLoggingTester.QueueAppender appender = new LoggingTester.QueueAppender();\n+\t\tLevel oldLevel = logger.getLevel();\n+\t\tList<Appender> allAppenders = LoggingTester.appenderHierarchy(logger);\n+\t\tLoggingTester.SourceFilter filter = new LoggingTester.SourceFilter(logger);\n+\t\ttry {\n+\t\t\tfor (Appender it : allAppenders) {\n+\t\t\t\tit.addFilter(filter);\n+\t\t\t}\n+\t\t\tlogger.addAppender(appender);\n+\t\t\tlogger.setLevel(level);\n+\t\t\taction.run();\n+\t\t\tList<LoggingTester.LogEntry> events = IterableExtensions.<LoggingTester.LogEntry> sortWith(\n+\t\t\t\t\tIterableExtensions.<LoggingTester.LogEntry> toList(appender.events), LoggingTester.TEMPORAL_ORDER);\n+\t\t\treturn new LoggingTester.LogCapture(events);\n+\t\t} finally {\n+\t\t\tlogger.removeAppender(appender);\n+\t\t\tfor (Appender it : allAppenders) {\n+\t\t\t\tLoggingTester.removeFilter(it, filter);\n+\t\t\t}\n+\t\t\tlogger.setLevel(oldLevel);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate static List<Appender> appenderHierarchy(Logger logger) {\n+\t\tList<Appender> appenders = new ArrayList<>();\n+\t\tfor (Category current = logger; current != null; current = current.getParent())\n+\t\t\tappenders.addAll(Collections.list(current.getAllAppenders()));\n+\t\treturn appenders;\n+\t}\n+\n+\tprivate static void removeFilter(Appender appender, Filter filter) {\n+\t\tif (Objects.equal(appender.getFilter(), filter)) {\n+\t\t\tappender.clearFilters();\n+\t\t\tappender.addFilter(filter.getNext());\n+\t\t} else {\n+\t\t\tfor (Filter current = appender.getFilter(); (current != null); current = current.getNext()) {\n+\t\t\t\tif (Objects.equal(current.getNext(), filter)) {\n+\t\t\t\t\tcurrent.setNext(filter.getNext());\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static final Comparator<LoggingTester.LogEntry> TEMPORAL_ORDER = (LoggingTester.LogEntry $0, LoggingTester.LogEntry $1) -> {", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMjI1Nw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449422257", "bodyText": "This looks as a resource leak to me. Please check if we need to close the stream.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:28:49Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjYwMg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449666602", "bodyText": "dont want to refactor deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMjI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMjcwMw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449422703", "bodyText": "throw new RuntimeException", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:29:47Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjY0Ng==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449666646", "bodyText": "dont want to refactor deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMjcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMjgwMQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449422801", "bodyText": "throw new RuntimeException", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:29:59Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\" + String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjY3Mw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449666673", "bodyText": "dont want to refactor deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMjgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMjk0OA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449422948", "bodyText": "Please check if open stream is ok.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:30:19Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\" + String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjY2Ng==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449666666", "bodyText": "dont want to refactor deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMjk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMzUwNQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449423505", "bodyText": "throw new RuntimeException", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:31:33Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\" + String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tString className = path.substring(0, path.length() - 6).replace(\"/\", \".\");\n+\t\t\t\t\tbyte[] bytes = classMap.get(className);\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjY5Nw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449666697", "bodyText": "dont want to refactor deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:29:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyMzkwNQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449423905", "bodyText": "InMemoryJavaCompiler.ByteClassLoader => ByteClassLoader", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:32:33Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\" + String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tString className = path.substring(0, path.length() - 6).replace(\"/\", \".\");\n+\t\t\t\t\tbyte[] bytes = classMap.get(className);\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new InMemoryJavaCompiler.ByteClassLoader(classMap, parentClassLoader);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNDExNg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449424116", "bodyText": "InMemoryJavaCompiler.ClassLoaderBasedNameEnvironment => ClassLoaderBasedNameEnvironment", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:33:06Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\" + String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tString className = path.substring(0, path.length() - 6).replace(\"/\", \".\");\n+\t\t\t\t\tbyte[] bytes = classMap.get(className);\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new InMemoryJavaCompiler.ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new InMemoryJavaCompiler.ClassLoaderBasedNameEnvironment(parent);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNDUwOQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449424509", "bodyText": "// these fields have been introduces in JDT 3.7\nComment is lost and probably relevant.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:34:05Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\" + String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tString className = path.substring(0, path.length() - 6).replace(\"/\", \".\");\n+\t\t\t\t\tbyte[] bytes = classMap.get(className);\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new InMemoryJavaCompiler.ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new InMemoryJavaCompiler.ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setSourceLevel(toClassFmt(javaVersion));\n+\t\tthis.setComplianceLevel(toClassFmt(javaVersion));\n+\t\tthis.compilerOptions.targetJDK = toClassFmt(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new InMemoryJavaCompiler.ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\tprivate long toClassFmt(JavaVersion version) {\n+\t\treturn version.toJdtClassFileConstant();\n+\t}\n+\n+\t/**\n+\t * sets the source level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setSourceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.sourceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\tCompilerOptions.class.getField(\"originalSourceLevel\").setLong(compilerOptions, jdkVersion);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNDYxNg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449424616", "bodyText": "// these fields have been introduces in JDT 3.7\nComment is lost and probably relevant.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:34:18Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\" + String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tString className = path.substring(0, path.length() - 6).replace(\"/\", \".\");\n+\t\t\t\t\tbyte[] bytes = classMap.get(className);\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new InMemoryJavaCompiler.ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new InMemoryJavaCompiler.ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setSourceLevel(toClassFmt(javaVersion));\n+\t\tthis.setComplianceLevel(toClassFmt(javaVersion));\n+\t\tthis.compilerOptions.targetJDK = toClassFmt(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new InMemoryJavaCompiler.ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\tprivate long toClassFmt(JavaVersion version) {\n+\t\treturn version.toJdtClassFileConstant();\n+\t}\n+\n+\t/**\n+\t * sets the source level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setSourceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.sourceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\tCompilerOptions.class.getField(\"originalSourceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * sets the compliance level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setComplianceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.complianceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\tCompilerOptions.class.getField(\"originalComplianceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNDg2Mg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449424862", "bodyText": "InMemoryJavaCompiler.Result => Result", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:34:54Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.InMemoryJavaCompiler instead\n+ */\n+@SuppressWarnings(\"restriction\")\n+@Deprecated\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\" + String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tString className = path.substring(0, path.length() - 6).replace(\"/\", \".\");\n+\t\t\t\t\tbyte[] bytes = classMap.get(className);\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new InMemoryJavaCompiler.ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new InMemoryJavaCompiler.ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setSourceLevel(toClassFmt(javaVersion));\n+\t\tthis.setComplianceLevel(toClassFmt(javaVersion));\n+\t\tthis.compilerOptions.targetJDK = toClassFmt(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new InMemoryJavaCompiler.ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\tprivate long toClassFmt(JavaVersion version) {\n+\t\treturn version.toJdtClassFileConstant();\n+\t}\n+\n+\t/**\n+\t * sets the source level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setSourceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.sourceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\tCompilerOptions.class.getField(\"originalSourceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * sets the compliance level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setComplianceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.complianceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\tCompilerOptions.class.getField(\"originalComplianceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tpublic InMemoryJavaCompiler.Result compile(JavaSource... sources) {", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNjE0Mg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449426142", "bodyText": "InMemoryJavaCompiler.Result => Result", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:37:51Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.OnTheFlyJavaCompiler2 instead\n+ */\n+@Deprecated\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t}\n+\n+\tpublic Class<?> compileToClass( String classname,  String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNjY5MQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449426691", "bodyText": "This is just an error string ... maybe just use ordinary string concatenation!?", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:39:05Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.OnTheFlyJavaCompiler2 instead\n+ */\n+@Deprecated\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t}\n+\n+\tpublic Class<?> compileToClass( String classname,  String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzI0OQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449667249", "bodyText": "dont want spend to much time refactoring deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNjY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNjc2OQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449426769", "bodyText": "This is just an error string ... maybe just use ordinary string concatenation!?", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:39:17Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.OnTheFlyJavaCompiler2 instead\n+ */\n+@Deprecated\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t}\n+\n+\tpublic Class<?> compileToClass( String classname,  String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n\")\n+\t\t\t\t\t\t.join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(code);\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzI2OA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449667268", "bodyText": "dont want spend to much time refactoring deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNjc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNjkwMQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449426901", "bodyText": "throw new RuntimeException", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:39:35Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.OnTheFlyJavaCompiler2 instead\n+ */\n+@Deprecated\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t}\n+\n+\tpublic Class<?> compileToClass( String classname,  String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n\")\n+\t\t\t\t\t\t.join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(code);\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Couldn\\'t load \\'\");\n+\t\t\t\trichString.append(classname);\n+\t\t\t\trichString.append(\"\\' \");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"source :\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(code, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"PROBLEMS : \");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(richString.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzI4NA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449667284", "bodyText": "dont want spend to much time refactoring deprecated code", "author": "cdietrich", "createdAt": "2020-07-03T17:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNjkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNzU1Mg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449427552", "bodyText": "Just an error text, use ordinary string concatenation!?", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:41:05Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.OnTheFlyJavaCompiler2 instead\n+ */\n+@Deprecated\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t}\n+\n+\tpublic Class<?> compileToClass( String classname,  String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n\")\n+\t\t\t\t\t\t.join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(code);\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Couldn\\'t load \\'\");\n+\t\t\t\trichString.append(classname);\n+\t\t\t\trichString.append(\"\\' \");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"source :\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(code, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"PROBLEMS : \");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(richString.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate String toJavaFile(String string) {\n+\t\treturn string.replace(\".\", \"/\") + \".java\";\n+\t}\n+\n+\tpublic Map<String, Class<?>> compileToClasses(Map<String, String> sources) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler\n+\t\t\t\t.compile(((JavaSource[]) Conversions.unwrapArray(\n+\t\t\t\t\t\tIterables.transform(sources.entrySet(),\n+\t\t\t\t\t\t\t\t(Map.Entry<String, String> it) -> new JavaSource(toJavaFile(it.getKey()), it.getValue())),\n+\t\t\t\t\t\tJavaSource.class)));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyOTYyOQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449429629", "bodyText": "did not want to change any semantics on a deprecated class", "author": "cdietrich", "createdAt": "2020-07-03T07:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNzU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNzc1Mw==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449427753", "bodyText": "throw new RuntimeException", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:41:31Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.OnTheFlyJavaCompiler2 instead\n+ */\n+@Deprecated\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t}\n+\n+\tpublic Class<?> compileToClass( String classname,  String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n\")\n+\t\t\t\t\t\t.join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(code);\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Couldn\\'t load \\'\");\n+\t\t\t\trichString.append(classname);\n+\t\t\t\trichString.append(\"\\' \");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"source :\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(code, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"PROBLEMS : \");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(richString.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate String toJavaFile(String string) {\n+\t\treturn string.replace(\".\", \"/\") + \".java\";\n+\t}\n+\n+\tpublic Map<String, Class<?>> compileToClasses(Map<String, String> sources) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler\n+\t\t\t\t.compile(((JavaSource[]) Conversions.unwrapArray(\n+\t\t\t\t\t\tIterables.transform(sources.entrySet(),\n+\t\t\t\t\t\t\t\t(Map.Entry<String, String> it) -> new JavaSource(toJavaFile(it.getKey()), it.getValue())),\n+\t\t\t\t\t\tJavaSource.class)));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\n+\t\t\t\t\t\tJoiner.on(\"\\n\").join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"=========\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n=========\\n\").join(sources.values()));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"=========\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\tClassLoader classLoader = result.getClassLoader();\n+\t\t\treturn IterableExtensions.toMap(Iterables.transform(sources.keySet(), (String it) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\treturn classLoader.loadClass(it);\n+\t\t\t\t} catch (ClassNotFoundException e) {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyOTY4OQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449429689", "bodyText": "did not want to change any semantics on a deprecated class", "author": "cdietrich", "createdAt": "2020-07-03T07:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNzc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNzg5OA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449427898", "bodyText": "throw new RuntimeException", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:41:49Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.OnTheFlyJavaCompiler2 instead\n+ */\n+@Deprecated\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t}\n+\n+\tpublic Class<?> compileToClass( String classname,  String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n\")\n+\t\t\t\t\t\t.join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(code);\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Couldn\\'t load \\'\");\n+\t\t\t\trichString.append(classname);\n+\t\t\t\trichString.append(\"\\' \");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"source :\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(code, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"PROBLEMS : \");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(richString.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate String toJavaFile(String string) {\n+\t\treturn string.replace(\".\", \"/\") + \".java\";\n+\t}\n+\n+\tpublic Map<String, Class<?>> compileToClasses(Map<String, String> sources) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler\n+\t\t\t\t.compile(((JavaSource[]) Conversions.unwrapArray(\n+\t\t\t\t\t\tIterables.transform(sources.entrySet(),\n+\t\t\t\t\t\t\t\t(Map.Entry<String, String> it) -> new JavaSource(toJavaFile(it.getKey()), it.getValue())),\n+\t\t\t\t\t\tJavaSource.class)));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\n+\t\t\t\t\t\tJoiner.on(\"\\n\").join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"=========\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n=========\\n\").join(sources.values()));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"=========\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\tClassLoader classLoader = result.getClassLoader();\n+\t\t\treturn IterableExtensions.toMap(Iterables.transform(sources.keySet(), (String it) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\treturn classLoader.loadClass(it);\n+\t\t\t\t} catch (ClassNotFoundException e) {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t\t}\n+\t\t\t}), Class::getName);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(e.getMessage());\n+\t\t\t\trichString.append(\" \");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"source :\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(sources, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"PROBLEMS : \");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\tString _join_2 = Joiner.on(\"\\n\").join(result.getCompilationProblems());\n+\t\t\t\trichString.append(_join_2, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(richString.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyOTc0Mg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449429742", "bodyText": "did not want to change any semantics on a deprecated class", "author": "cdietrich", "createdAt": "2020-07-03T07:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNzg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNzk5NQ==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449427995", "bodyText": "Use ordinary string concatnation.", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:42:02Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.OnTheFlyJavaCompiler2 instead\n+ */\n+@Deprecated\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t}\n+\n+\tpublic Class<?> compileToClass( String classname,  String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n\")\n+\t\t\t\t\t\t.join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(code);\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Couldn\\'t load \\'\");\n+\t\t\t\trichString.append(classname);\n+\t\t\t\trichString.append(\"\\' \");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"source :\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(code, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"PROBLEMS : \");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(richString.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate String toJavaFile(String string) {\n+\t\treturn string.replace(\".\", \"/\") + \".java\";\n+\t}\n+\n+\tpublic Map<String, Class<?>> compileToClasses(Map<String, String> sources) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler\n+\t\t\t\t.compile(((JavaSource[]) Conversions.unwrapArray(\n+\t\t\t\t\t\tIterables.transform(sources.entrySet(),\n+\t\t\t\t\t\t\t\t(Map.Entry<String, String> it) -> new JavaSource(toJavaFile(it.getKey()), it.getValue())),\n+\t\t\t\t\t\tJavaSource.class)));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\n+\t\t\t\t\t\tJoiner.on(\"\\n\").join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"=========\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n=========\\n\").join(sources.values()));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"=========\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\tClassLoader classLoader = result.getClassLoader();\n+\t\t\treturn IterableExtensions.toMap(Iterables.transform(sources.keySet(), (String it) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\treturn classLoader.loadClass(it);\n+\t\t\t\t} catch (ClassNotFoundException e) {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t\t}\n+\t\t\t}), Class::getName);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyOTc4OA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449429788", "bodyText": "did not want to change any semantics on a deprecated class", "author": "cdietrich", "createdAt": "2020-07-03T07:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyNzk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyODQxMA==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449428410", "bodyText": "throw new RuntimeException", "author": "ArneDeutsch", "createdAt": "2020-07-03T07:42:54Z", "path": "org.eclipse.xtext.xbase.junit/src/org/eclipse/xtext/xbase/compiler/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.compiler;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ * @deprecated Use org.eclipse.xtext.xbase.testing.OnTheFlyJavaCompiler2 instead\n+ */\n+@Deprecated\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t}\n+\n+\tpublic Class<?> compileToClass( String classname,  String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n\")\n+\t\t\t\t\t\t.join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(code);\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Couldn\\'t load \\'\");\n+\t\t\t\trichString.append(classname);\n+\t\t\t\trichString.append(\"\\' \");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"source :\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(code, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"PROBLEMS : \");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(richString.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate String toJavaFile(String string) {\n+\t\treturn string.replace(\".\", \"/\") + \".java\";\n+\t}\n+\n+\tpublic Map<String, Class<?>> compileToClasses(Map<String, String> sources) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler\n+\t\t\t\t.compile(((JavaSource[]) Conversions.unwrapArray(\n+\t\t\t\t\t\tIterables.transform(sources.entrySet(),\n+\t\t\t\t\t\t\t\t(Map.Entry<String, String> it) -> new JavaSource(toJavaFile(it.getKey()), it.getValue())),\n+\t\t\t\t\t\tJavaSource.class)));\n+\t\ttry {\n+\t\t\tif (IterableExtensions.exists(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(\"Java code compiled with errors:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\n+\t\t\t\t\t\tJoiner.on(\"\\n\").join(IterableExtensions.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"Code was:\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"=========\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(Joiner.on(\"\\n=========\\n\").join(sources.values()));\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"=========\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\tthrow new IllegalArgumentException(richString.toString());\n+\t\t\t}\n+\t\t\tClassLoader classLoader = result.getClassLoader();\n+\t\t\treturn IterableExtensions.toMap(Iterables.transform(sources.keySet(), (String it) -> {\n+\t\t\t\ttry {\n+\t\t\t\t\treturn classLoader.loadClass(it);\n+\t\t\t\t} catch (ClassNotFoundException e) {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t\t}\n+\t\t\t}), Class::getName);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\t\trichString.append(e.getMessage());\n+\t\t\t\trichString.append(\" \");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.append(\"source :\");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\trichString.append(sources, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"PROBLEMS : \");\n+\t\t\t\trichString.newLine();\n+\t\t\t\trichString.append(\"\\t\");\n+\t\t\t\tString _join_2 = Joiner.on(\"\\n\").join(result.getCompilationProblems());\n+\t\t\t\trichString.append(_join_2, \"\\t\");\n+\t\t\t\trichString.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(richString.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic <RT extends Object> Function0<RT> createFunction(String expression, Class<RT> returnType) {\n+\t\ttry {\n+\t\t\tStringConcatenation richString = new StringConcatenation();\n+\t\t\trichString.append(\"public class __Generated implements org.eclipse.xtext.xbase.lib.Functions.Function0<\");\n+\t\t\trichString.append(returnType.getName());\n+\t\t\trichString.append(\"> {\");\n+\t\t\trichString.newLineIfNotEmpty();\n+\t\t\trichString.append(\"\\t\");\n+\t\t\trichString.append(\"public \");\n+\t\t\trichString.append(returnType.getName(), \"\\t\");\n+\t\t\trichString.append(\" apply() {\");\n+\t\t\trichString.newLineIfNotEmpty();\n+\t\t\trichString.append(\"\\t\\t\");\n+\t\t\trichString.append(expression, \"\\t\\t\");\n+\t\t\trichString.newLineIfNotEmpty();\n+\t\t\trichString.append(\"\\t\");\n+\t\t\trichString.append(\"}\");\n+\t\t\trichString.newLine();\n+\t\t\trichString.append(\"}\");\n+\t\t\trichString.newLine();\n+\t\t\tClass<?> clazz = compileToClass(\"__Generated\", richString.toString());\n+\t\t\treturn (Function0<RT>) clazz.getDeclaredConstructor().newInstance();\n+\t\t} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n+\t\t\t\t| NoSuchMethodException | SecurityException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);", "originalCommit": "a5117e8ecf7bdabe3c18a24e39122635266d8dfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyOTgyNg==", "url": "https://github.com/eclipse/xtext-eclipse/pull/1483#discussion_r449429826", "bodyText": "did not want to change any semantics on a deprecated class", "author": "cdietrich", "createdAt": "2020-07-03T07:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQyODQxMA=="}], "type": "inlineReview"}, {"oid": "6c9858a658e8717b07cab00605b11ebd252aec08", "url": "https://github.com/eclipse/xtext-eclipse/commit/6c9858a658e8717b07cab00605b11ebd252aec08", "message": "[eclipse/xtext#1777] converted xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-03T17:32:44Z", "type": "forcePushed"}, {"oid": "6489989bb2583d7e9514d3fb5621f2b670ed1da6", "url": "https://github.com/eclipse/xtext-eclipse/commit/6489989bb2583d7e9514d3fb5621f2b670ed1da6", "message": "[eclipse/xtext#1777] converted xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-07T07:09:28Z", "type": "commit"}, {"oid": "6489989bb2583d7e9514d3fb5621f2b670ed1da6", "url": "https://github.com/eclipse/xtext-eclipse/commit/6489989bb2583d7e9514d3fb5621f2b670ed1da6", "message": "[eclipse/xtext#1777] converted xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-07T07:09:28Z", "type": "forcePushed"}]}