{"pr_number": 887, "pr_title": "HIVE-22746", "pr_createdAt": "2020-01-23T17:40:33Z", "pr_url": "https://github.com/apache/hive/pull/887", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwODQ1Mg==", "url": "https://github.com/apache/hive/pull/887#discussion_r370708452", "bodyText": "ExprNodeDescUtils.isStringType is only redirecting to TypeCheckProcFactory.isStringType, therefore it can be removed, and it's callers may call TypeCheckProcFactory.isStringType directly.", "author": "miklosgergely", "createdAt": "2020-01-24T15:58:11Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/plan/ExprNodeDescUtils.java", "diffHunk": "@@ -1001,17 +1002,10 @@ public static boolean isSame(List<ExprNodeDesc> first, List<ExprNodeDesc> second\n   // Given an expression this method figures out if the type for the expression belongs to string group\n   // e.g. (String, Char, Varchar etc)\n   public static boolean isStringType(ExprNodeDesc expr) {\n-    TypeInfo typeInfo = expr.getTypeInfo();\n-    if (typeInfo.getCategory() == ObjectInspector.Category.PRIMITIVE) {\n-      PrimitiveObjectInspector.PrimitiveCategory primitiveCategory = ((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory();\n-      if (PrimitiveObjectInspectorUtils.getPrimitiveGrouping(primitiveCategory) ==\n-          PrimitiveObjectInspectorUtils.PrimitiveGrouping.STRING_GROUP) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    return TypeCheckProcFactory.isStringType(expr.getTypeInfo());", "originalCommit": "5db719f9dd0297bb6488f1d55be686d6eb71ac98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NTgzMQ==", "url": "https://github.com/apache/hive/pull/887#discussion_r370945831", "bodyText": "It was not called anymore, I have just removed it.", "author": "jcamachor", "createdAt": "2020-01-25T17:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcwODQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNDkyNQ==", "url": "https://github.com/apache/hive/pull/887#discussion_r370714925", "bodyText": "If createDecimalConstantExpr throws a NumberFormatException then the function won't try to parse the value as Bigint and Int, so I think it should be surrounded with try/catch.", "author": "miklosgergely", "createdAt": "2020-01-24T16:11:04Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/type/ExprFactory.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.parse.type;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneId;\n+import java.util.List;\n+import org.apache.hadoop.hive.ql.exec.ColumnInfo;\n+import org.apache.hadoop.hive.ql.exec.UDFArgumentException;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.CalciteSubquerySemanticException;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.plan.SubqueryType;\n+import org.apache.hadoop.hive.ql.udf.generic.GenericUDF;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hive.common.util.DateUtils;\n+\n+/**\n+ * Generic expressions factory. Currently, the only implementation produces\n+ * Hive {@link ExprNodeDesc}.\n+ */\n+public abstract class ExprFactory<T> {\n+\n+  static final BigDecimal NANOS_PER_SEC_BD =\n+      new BigDecimal(DateUtils.NANOS_PER_SEC);\n+\n+  /**\n+   * Returns whether the input is an instance of the expression class.\n+   */\n+  protected abstract boolean isExprInstance(Object o);\n+\n+  /**\n+   * Generates an expression from the input column. This may not necessarily\n+   * be a column expression, e.g., if the column is a constant.\n+   */\n+  protected abstract T toExpr(ColumnInfo colInfo);\n+\n+  /* FIELD REFERENCES */\n+  /**\n+   * Returns whether the input object is a column reference expression.\n+   */\n+  protected abstract boolean isColumnRefExpr(Object o);\n+\n+  /**\n+   * Creates column expression.\n+   */\n+  protected abstract T createColumnRefExpr(ColumnInfo colInfo);\n+\n+  /**\n+   * Returns column name referenced by a column expression.\n+   */\n+  protected abstract String getColumnName(T expr);\n+\n+  /* CONSTANT EXPRESSIONS */\n+  /**\n+   * Returns whether the input expression is a constant expression.\n+   */\n+  protected abstract boolean isConstantExpr(Object o);\n+\n+  /**\n+   * Returns whether all input expressions are constant expressions.\n+   */\n+  protected boolean isAllConstants(List<T> exprs) {\n+    for (T expr : exprs) {\n+      if (!isConstantExpr(expr)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Returns whether the input expression is a struct of\n+   * constant expressions (all of them).\n+   */\n+  protected abstract boolean isConstantStruct(T expr);\n+\n+  /**\n+   * Creates a null constant expression with void type.\n+   */\n+  protected abstract T createNullConstantExpr();\n+\n+  /**\n+   * Creates a boolean constant expression from input value.\n+   */\n+  protected abstract T createBooleanConstantExpr(String value);\n+\n+  /**\n+   * Creates a bigint constant expression from input value.\n+   */\n+  protected abstract T createBigintConstantExpr(String value);\n+\n+  /**\n+   * Creates a int constant expression from input value.\n+   */\n+  protected abstract T createIntConstantExpr(String value);\n+\n+  /**\n+   * Creates a smallint constant expression from input value.\n+   */\n+  protected abstract T createSmallintConstantExpr(String value);\n+\n+  /**\n+   * Creates a tinyint constant expression from input value.\n+   */\n+  protected abstract T createTinyintConstantExpr(String value);\n+\n+  /**\n+   * Creates a float constant expression from input value.\n+   */\n+  protected abstract T createFloatConstantExpr(String value);\n+\n+  /**\n+   * Creates a double constant expression from input value.\n+   */\n+  protected abstract T createDoubleConstantExpr(String value);\n+\n+  /**\n+   * Creates a decimal constant expression from input value.\n+   * If the constant created from the input value is null, we return:\n+   * 1) a constant expression containing null value if allowNullValueConstantExpr is true, or\n+   * 2) null if allowNullValueConstantExpr is false.\n+   */\n+  protected abstract T createDecimalConstantExpr(String value, boolean allowNullValueConstantExpr);\n+\n+  /**\n+   * Creates a string constant expression from input value.\n+   */\n+  protected abstract T createStringConstantExpr(String value);\n+\n+  /**\n+   * Creates a date constant expression from input value.\n+   */\n+  protected abstract T createDateConstantExpr(String value);\n+\n+  /**\n+   * Creates a timestamp constant expression from input value.\n+   */\n+  protected abstract T createTimestampConstantExpr(String value);\n+\n+  /**\n+   * Creates a timestamp with local time zone constant expression from input value.\n+   * ZoneId is the local time zone.\n+   */\n+  protected abstract T createTimestampLocalTimeZoneConstantExpr(String value, ZoneId zoneId);\n+\n+  /**\n+   * Creates a interval year-month constant expression from input value.\n+   */\n+  protected abstract T createIntervalYearMonthConstantExpr(String value);\n+\n+  /**\n+   * Creates a interval day-time constant expression from input value.\n+   */\n+  protected abstract T createIntervalDayTimeConstantExpr(String value);\n+\n+  /**\n+   * Creates a interval year constant expression from input value.\n+   */\n+  protected abstract T createIntervalYearConstantExpr(String value);\n+\n+  /**\n+   * Creates a interval month constant expression from input value.\n+   */\n+  protected abstract T createIntervalMonthConstantExpr(String value);\n+\n+  /**\n+   * Creates a interval day constant expression from input value.\n+   */\n+  protected abstract T createIntervalDayConstantExpr(String value);\n+\n+  /**\n+   * Creates a interval hour constant expression from input value.\n+   */\n+  protected abstract T createIntervalHourConstantExpr(String value);\n+\n+  /**\n+   * Creates a interval minute constant expression from input value.\n+   */\n+  protected abstract T createIntervalMinuteConstantExpr(String value);\n+\n+  /**\n+   * Creates a interval second constant expression from input value.\n+   */\n+  protected abstract T createIntervalSecondConstantExpr(String value);\n+\n+  /**\n+   * Default generator for constant expression when type cannot be inferred\n+   * from input query.\n+   */\n+  protected T createConstantExpr(String value) {\n+    // The expression can be any one of Double, Long and Integer. We\n+    // try to parse the expression in that order to ensure that the\n+    // most specific type is used for conversion.\n+    T result = null;\n+    T result2 = null;\n+    try {\n+      result = createDoubleConstantExpr(value);\n+      if (value != null && !value.toLowerCase().contains(\"e\")) {\n+        result2 = createDecimalConstantExpr(value, false);", "originalCommit": "5db719f9dd0297bb6488f1d55be686d6eb71ac98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjA1MQ==", "url": "https://github.com/apache/hive/pull/887#discussion_r370946051", "bodyText": "What you describe above is the correct behavior: this code is already in Hive in TypeCheckProcFactory.\nIf an exception is thrown for decimal, we consider the constant to be a double. If an exception is not thrown for decimal, we try to parse as bigint and int. If any of those succeed, we will use those. But if none of them do, we will use the decimal.\nIf we want to refactor this crazy logic, I would rather create a new JIRA for that instead of doing it in this JIRA.", "author": "jcamachor", "createdAt": "2020-01-25T17:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNDkyNQ=="}], "type": "inlineReview"}, {"oid": "f7eb8b6650a5d6fb98eb01c3ad3793deeee8e2c5", "url": "https://github.com/apache/hive/commit/f7eb8b6650a5d6fb98eb01c3ad3793deeee8e2c5", "message": "HIVE-22746: Make TypeCheckProcFactory generic (Jesus Camacho Rodriguez, reviewed by Vineet Garg, Miklos Gergely)\n\nClose apache/hive#887", "committedDate": "2020-01-27T16:54:04Z", "type": "commit"}, {"oid": "f7eb8b6650a5d6fb98eb01c3ad3793deeee8e2c5", "url": "https://github.com/apache/hive/commit/f7eb8b6650a5d6fb98eb01c3ad3793deeee8e2c5", "message": "HIVE-22746: Make TypeCheckProcFactory generic (Jesus Camacho Rodriguez, reviewed by Vineet Garg, Miklos Gergely)\n\nClose apache/hive#887", "committedDate": "2020-01-27T16:54:04Z", "type": "forcePushed"}]}