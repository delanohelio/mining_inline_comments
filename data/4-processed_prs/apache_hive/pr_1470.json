{"pr_number": 1470, "pr_title": "HIVE-24120 Plugin for external DatabaseProduct in standalone HMS", "pr_createdAt": "2020-09-04T13:35:35Z", "pr_url": "https://github.com/apache/hive/pull/1470", "timeline": [{"oid": "b3cce87efafe053bfce0bd141b3bc07337df6d3d", "url": "https://github.com/apache/hive/commit/b3cce87efafe053bfce0bd141b3bc07337df6d3d", "message": "new configs", "committedDate": "2020-09-01T14:10:21Z", "type": "commit"}, {"oid": "8e8a05ac44d12861b7cfdcbb0426e0ca16b28afb", "url": "https://github.com/apache/hive/commit/8e8a05ac44d12861b7cfdcbb0426e0ca16b28afb", "message": "refactor DatabaseProduct", "committedDate": "2020-09-02T14:23:17Z", "type": "commit"}, {"oid": "d309193379edca9369a4d407de8d865541659308", "url": "https://github.com/apache/hive/commit/d309193379edca9369a4d407de8d865541659308", "message": "cleanup", "committedDate": "2020-09-02T15:23:16Z", "type": "commit"}, {"oid": "d1506264af89c51a9b8f029e06f0e13550d56fe0", "url": "https://github.com/apache/hive/commit/d1506264af89c51a9b8f029e06f0e13550d56fe0", "message": "changes for EXTERNAL product", "committedDate": "2020-09-02T15:55:50Z", "type": "commit"}, {"oid": "a6ec00ee04acbbac8452fa770b5c2d2376f74ea6", "url": "https://github.com/apache/hive/commit/a6ec00ee04acbbac8452fa770b5c2d2376f74ea6", "message": "rename ProductId as DbType", "committedDate": "2020-09-02T16:03:55Z", "type": "commit"}, {"oid": "4e20de878e3447df95a608da5f723c73d40ca72a", "url": "https://github.com/apache/hive/commit/4e20de878e3447df95a608da5f723c73d40ca72a", "message": "account for EXTERNAL in SQL generator", "committedDate": "2020-09-02T16:26:45Z", "type": "commit"}, {"oid": "5b37739038473f2f980ac312e969e16ef1c32e60", "url": "https://github.com/apache/hive/commit/5b37739038473f2f980ac312e969e16ef1c32e60", "message": "Add overridable methods to class DatabaseProduct", "committedDate": "2020-09-03T15:58:14Z", "type": "commit"}, {"oid": "c6abd2cd96a86655449a452033922abdbe134fe4", "url": "https://github.com/apache/hive/commit/c6abd2cd96a86655449a452033922abdbe134fe4", "message": "Use new methods in DatabaseProduct consistently", "committedDate": "2020-09-03T16:34:30Z", "type": "commit"}, {"oid": "e0d3ba72e39f986027425cce3cde6ac431376a2b", "url": "https://github.com/apache/hive/commit/e0d3ba72e39f986027425cce3cde6ac431376a2b", "message": "add method to get database properties", "committedDate": "2020-09-03T18:02:09Z", "type": "commit"}, {"oid": "57388e2d3a6ed8802c2b8cb0bcc94532c87d0b78", "url": "https://github.com/apache/hive/commit/57388e2d3a6ed8802c2b8cb0bcc94532c87d0b78", "message": "Address TODO and cleanup", "committedDate": "2020-09-04T03:34:32Z", "type": "commit"}, {"oid": "2b8c0ba8aeeb427489e0921a39b65fde86cfbfda", "url": "https://github.com/apache/hive/commit/2b8c0ba8aeeb427489e0921a39b65fde86cfbfda", "message": "remove conf field", "committedDate": "2020-09-04T12:55:40Z", "type": "commit"}, {"oid": "c7b10a68adc98a702362d36096a574fc7f67cffc", "url": "https://github.com/apache/hive/commit/c7b10a68adc98a702362d36096a574fc7f67cffc", "message": "update references to Derby and MySQL in hcatalog", "committedDate": "2020-09-04T15:32:03Z", "type": "commit"}, {"oid": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92", "url": "https://github.com/apache/hive/commit/4bfb30c5f7a80bbc5f6d5323075ed15359afcc92", "message": "Simplify instantiation logic and accoung for concurrency", "committedDate": "2020-09-04T18:48:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAwMDQ0NQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r489000445", "bodyText": "nit, can you fix the formatting here?", "author": "vihangk1", "createdAt": "2020-09-15T21:51:15Z", "path": "standalone-metastore/metastore-common/src/main/java/org/apache/hadoop/hive/metastore/conf/MetastoreConf.java", "diffHunk": "@@ -1337,6 +1337,13 @@ public static ConfVars getMetaConf(String name) {\n     HIVE_TXN_STATS_ENABLED(\"hive.txn.stats.enabled\", \"hive.txn.stats.enabled\", true,\n         \"Whether Hive supports transactional stats (accurate stats for transactional tables)\"),\n \n+    // External RDBMS support\n+    USE_CUSTOM_RDBMS(\"metastore.use.custom.database.product\",\n+            \"hive.metastore.use.custom.database.product\", false,\n+            \"Use an external RDBMS for the metastore\"),\n+    CUSTOM_RDBMS_CLASSNAME(\"metastore.custom.database.product.classname\", \"hive.metastore.custom.database.product.classname\", \"none\",\n+          \"Hook for external RDBMS. This class will be instantiated only when metastore.use.custom.database.product is set to true.\"),", "originalCommit": "b3cce87efafe053bfce0bd141b3bc07337df6d3d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAyNDc0Ng==", "url": "https://github.com/apache/hive/pull/1470#discussion_r489024746", "bodyText": "I think instead of this getting initialized in the static block, it would be better to pass the configuration object from the HiveMetastore.java in a constructor", "author": "vihangk1", "createdAt": "2020-09-15T22:21:12Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();", "originalCommit": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA5ODA3OQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r491098079", "bodyText": "I'm adding the constructor, and the associated signature for method determineDatabaseProduct with the extra conf parameter. However, in places where determineDatabaseProduct is invoked, I don't see how to get a hold of the the HiveMetastore instance. Could you pls provide some pointer?", "author": "gatorblue", "createdAt": "2020-09-18T17:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAyNDc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ1ODIwNw==", "url": "https://github.com/apache/hive/pull/1470#discussion_r491458207", "bodyText": "While adding a unit test, I realized that passing the conf object was useful for testing. I guess this may be what you had in mind.", "author": "gatorblue", "createdAt": "2020-09-19T14:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAyNDc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAyNzQzNw==", "url": "https://github.com/apache/hive/pull/1470#discussion_r489027437", "bodyText": "Its getting a bit confusing with the usage of external, other, custom. Can this be avoided? If not, we should document it somewhere in this class.", "author": "vihangk1", "createdAt": "2020-09-15T22:24:42Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();\n+    // Check if we are using an external database product\n+    boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+    if (isExternal) {\n+      // The DatabaseProduct will be created by instantiating an external class via\n+      // reflection. The external class can override any method in the current class\n+      String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+      \n+      if (className != null) {\n+        try {\n+          theDatabaseProduct = (DatabaseProduct)\n+              ReflectionUtils.newInstance(Class.forName(className), conf);\n+\n+          theDatabaseProduct.dbType = DbType.EXTERNAL;\n+        }catch (Exception e) {\n+          LOG.warn(\"Unable to instantiate custom database product. Reverting to default\", e);\n+        }\n+      }\n+      else {\n+        LOG.warn(\"metastore.use.custom.database.product was set, \" +\n+                 \"but metastore.custom.database.product.classname was not. Reverting to default\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for singleton class\n+   * @param id\n+   */\n+  private DatabaseProduct() {}\n+  \n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String OTHER_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n+  public static DatabaseProduct determineDatabaseProduct(String productName) {\n+    DbType dbt;\n+\n     if (productName == null) {\n-      return OTHER;\n+      productName = OTHER_NAME;\n     }\n+\n     productName = productName.toLowerCase();\n-    if (productName.contains(\"derby\")) {\n-      return DERBY;\n-    } else if (productName.contains(\"microsoft sql server\")) {\n-      return SQLSERVER;\n-    } else if (productName.contains(\"mysql\")) {\n-      return MYSQL;\n-    } else if (productName.contains(\"oracle\")) {\n-      return ORACLE;\n-    } else if (productName.contains(\"postgresql\")) {\n-      return POSTGRES;\n+\n+    if (productName.contains(DERBY_NAME)) {\n+      dbt = DbType.DERBY;\n+    } else if (productName.contains(SQL_SERVER_NAME)) {\n+      dbt = DbType.SQLSERVER;\n+    } else if (productName.contains(MYSQL_NAME)) {\n+      dbt = DbType.MYSQL;\n+    } else if (productName.contains(ORACLE_NAME)) {\n+      dbt = DbType.ORACLE;\n+    } else if (productName.contains(POSTGRESQL_NAME)) {\n+      dbt = DbType.POSTGRES;\n     } else {\n-      return OTHER;\n+      dbt = DbType.OTHER;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+      if (theDatabaseProduct == null) {\n+        theDatabaseProduct = new DatabaseProduct();\n+      }\n+  \n+      theDatabaseProduct.dbType = dbt;\n+    }\n+    return theDatabaseProduct;\n+  }\n+\n+  public final boolean isDERBY() {\n+    return dbType == DbType.DERBY;\n+  }\n+\n+  public final boolean isMYSQL() {\n+    return dbType == DbType.MYSQL;\n   }\n \n-  public static boolean isDeadlock(DatabaseProduct dbProduct, SQLException e) {\n+  public final boolean isORACLE() {\n+    return dbType == DbType.ORACLE;\n+  }\n+\n+  public final boolean isSQLSERVER() {\n+    return dbType == DbType.SQLSERVER;\n+  }\n+\n+  public final boolean isPOSTGRES() {\n+    return dbType == DbType.POSTGRES;\n+  }\n+\n+  public final boolean isEXTERNAL() {\n+    return dbType == DbType.EXTERNAL;", "originalCommit": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTExMjE5MQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r491112191", "bodyText": "Yeah. From what I see in the codebase, OTHER seems to really mean UNDEFINED. I've changed the constant name accordingly. I believe this addresses the possible confusion. Let me know otherwise.", "author": "gatorblue", "createdAt": "2020-09-18T18:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAyNzQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAyOTU4OQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r489029589", "bodyText": "why not add a happy path check on line 100 which returns theDatabaseProduct if it is not null.", "author": "vihangk1", "createdAt": "2020-09-15T22:27:38Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();\n+    // Check if we are using an external database product\n+    boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+    if (isExternal) {\n+      // The DatabaseProduct will be created by instantiating an external class via\n+      // reflection. The external class can override any method in the current class\n+      String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+      \n+      if (className != null) {\n+        try {\n+          theDatabaseProduct = (DatabaseProduct)\n+              ReflectionUtils.newInstance(Class.forName(className), conf);\n+\n+          theDatabaseProduct.dbType = DbType.EXTERNAL;\n+        }catch (Exception e) {\n+          LOG.warn(\"Unable to instantiate custom database product. Reverting to default\", e);\n+        }\n+      }\n+      else {\n+        LOG.warn(\"metastore.use.custom.database.product was set, \" +\n+                 \"but metastore.custom.database.product.classname was not. Reverting to default\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for singleton class\n+   * @param id\n+   */\n+  private DatabaseProduct() {}\n+  \n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String OTHER_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n+  public static DatabaseProduct determineDatabaseProduct(String productName) {\n+    DbType dbt;\n+\n     if (productName == null) {\n-      return OTHER;\n+      productName = OTHER_NAME;\n     }\n+\n     productName = productName.toLowerCase();\n-    if (productName.contains(\"derby\")) {\n-      return DERBY;\n-    } else if (productName.contains(\"microsoft sql server\")) {\n-      return SQLSERVER;\n-    } else if (productName.contains(\"mysql\")) {\n-      return MYSQL;\n-    } else if (productName.contains(\"oracle\")) {\n-      return ORACLE;\n-    } else if (productName.contains(\"postgresql\")) {\n-      return POSTGRES;\n+\n+    if (productName.contains(DERBY_NAME)) {\n+      dbt = DbType.DERBY;\n+    } else if (productName.contains(SQL_SERVER_NAME)) {\n+      dbt = DbType.SQLSERVER;\n+    } else if (productName.contains(MYSQL_NAME)) {\n+      dbt = DbType.MYSQL;\n+    } else if (productName.contains(ORACLE_NAME)) {\n+      dbt = DbType.ORACLE;\n+    } else if (productName.contains(POSTGRESQL_NAME)) {\n+      dbt = DbType.POSTGRES;\n     } else {\n-      return OTHER;\n+      dbt = DbType.OTHER;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {", "originalCommit": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAzMDgxNg==", "url": "https://github.com/apache/hive/pull/1470#discussion_r489030816", "bodyText": "Can we refactor these lines (108-119) into a separate private method which can be used like below at line 100?\nif (theDatabaseProduct != null) {\nPreconditions.checkState(this.dbType == getDbType(productName));\nreturn theDatabaseProduct;\n}", "author": "vihangk1", "createdAt": "2020-09-15T22:29:12Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();\n+    // Check if we are using an external database product\n+    boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+    if (isExternal) {\n+      // The DatabaseProduct will be created by instantiating an external class via\n+      // reflection. The external class can override any method in the current class\n+      String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+      \n+      if (className != null) {\n+        try {\n+          theDatabaseProduct = (DatabaseProduct)\n+              ReflectionUtils.newInstance(Class.forName(className), conf);\n+\n+          theDatabaseProduct.dbType = DbType.EXTERNAL;\n+        }catch (Exception e) {\n+          LOG.warn(\"Unable to instantiate custom database product. Reverting to default\", e);\n+        }\n+      }\n+      else {\n+        LOG.warn(\"metastore.use.custom.database.product was set, \" +\n+                 \"but metastore.custom.database.product.classname was not. Reverting to default\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for singleton class\n+   * @param id\n+   */\n+  private DatabaseProduct() {}\n+  \n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String OTHER_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n+  public static DatabaseProduct determineDatabaseProduct(String productName) {\n+    DbType dbt;\n+\n     if (productName == null) {\n-      return OTHER;\n+      productName = OTHER_NAME;\n     }\n+\n     productName = productName.toLowerCase();\n-    if (productName.contains(\"derby\")) {\n-      return DERBY;\n-    } else if (productName.contains(\"microsoft sql server\")) {\n-      return SQLSERVER;\n-    } else if (productName.contains(\"mysql\")) {\n-      return MYSQL;\n-    } else if (productName.contains(\"oracle\")) {\n-      return ORACLE;\n-    } else if (productName.contains(\"postgresql\")) {\n-      return POSTGRES;\n+\n+    if (productName.contains(DERBY_NAME)) {", "originalCommit": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAzMTQ3NQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r489031475", "bodyText": "Curious to know why we would need this? If we don't do this may be we can make theDatabaseProduct as a final variable.", "author": "vihangk1", "createdAt": "2020-09-15T22:30:05Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,646 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, EXTERNAL, OTHER};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  static {\n+    final Configuration conf = MetastoreConf.newMetastoreConf();\n+    // Check if we are using an external database product\n+    boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+    if (isExternal) {\n+      // The DatabaseProduct will be created by instantiating an external class via\n+      // reflection. The external class can override any method in the current class\n+      String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+      \n+      if (className != null) {\n+        try {\n+          theDatabaseProduct = (DatabaseProduct)\n+              ReflectionUtils.newInstance(Class.forName(className), conf);\n+\n+          theDatabaseProduct.dbType = DbType.EXTERNAL;\n+        }catch (Exception e) {\n+          LOG.warn(\"Unable to instantiate custom database product. Reverting to default\", e);\n+        }\n+      }\n+      else {\n+        LOG.warn(\"metastore.use.custom.database.product was set, \" +\n+                 \"but metastore.custom.database.product.classname was not. Reverting to default\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Private constructor for singleton class\n+   * @param id\n+   */\n+  private DatabaseProduct() {}\n+  \n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String OTHER_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n+  public static DatabaseProduct determineDatabaseProduct(String productName) {\n+    DbType dbt;\n+\n     if (productName == null) {\n-      return OTHER;\n+      productName = OTHER_NAME;\n     }\n+\n     productName = productName.toLowerCase();\n-    if (productName.contains(\"derby\")) {\n-      return DERBY;\n-    } else if (productName.contains(\"microsoft sql server\")) {\n-      return SQLSERVER;\n-    } else if (productName.contains(\"mysql\")) {\n-      return MYSQL;\n-    } else if (productName.contains(\"oracle\")) {\n-      return ORACLE;\n-    } else if (productName.contains(\"postgresql\")) {\n-      return POSTGRES;\n+\n+    if (productName.contains(DERBY_NAME)) {\n+      dbt = DbType.DERBY;\n+    } else if (productName.contains(SQL_SERVER_NAME)) {\n+      dbt = DbType.SQLSERVER;\n+    } else if (productName.contains(MYSQL_NAME)) {\n+      dbt = DbType.MYSQL;\n+    } else if (productName.contains(ORACLE_NAME)) {\n+      dbt = DbType.ORACLE;\n+    } else if (productName.contains(POSTGRESQL_NAME)) {\n+      dbt = DbType.POSTGRES;\n     } else {\n-      return OTHER;\n+      dbt = DbType.OTHER;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+      if (theDatabaseProduct == null) {\n+        theDatabaseProduct = new DatabaseProduct();\n+      }\n+  \n+      theDatabaseProduct.dbType = dbt;\n+    }\n+    return theDatabaseProduct;\n+  }\n+\n+  public final boolean isDERBY() {\n+    return dbType == DbType.DERBY;\n+  }\n+\n+  public final boolean isMYSQL() {\n+    return dbType == DbType.MYSQL;\n   }\n \n-  public static boolean isDeadlock(DatabaseProduct dbProduct, SQLException e) {\n+  public final boolean isORACLE() {\n+    return dbType == DbType.ORACLE;\n+  }\n+\n+  public final boolean isSQLSERVER() {\n+    return dbType == DbType.SQLSERVER;\n+  }\n+\n+  public final boolean isPOSTGRES() {\n+    return dbType == DbType.POSTGRES;\n+  }\n+\n+  public final boolean isEXTERNAL() {\n+    return dbType == DbType.EXTERNAL;\n+  }\n+\n+  public final boolean isOTHER() {\n+    return dbType == DbType.OTHER;\n+  }\n+\n+  public boolean isDeadlock(SQLException e) {\n     return e instanceof SQLTransactionRollbackException\n-        || ((dbProduct == MYSQL || dbProduct == POSTGRES || dbProduct == SQLSERVER)\n+        || ((isMYSQL() || isPOSTGRES() || isSQLSERVER() || isEXTERNAL())\n             && \"40001\".equals(e.getSQLState()))\n-        || (dbProduct == POSTGRES && \"40P01\".equals(e.getSQLState()))\n-        || (dbProduct == ORACLE && (e.getMessage() != null && (e.getMessage().contains(\"deadlock detected\")\n+        || (isPOSTGRES() && \"40P01\".equals(e.getSQLState()))\n+        || (isORACLE() && (e.getMessage() != null && (e.getMessage().contains(\"deadlock detected\")\n             || e.getMessage().contains(\"can't serialize access for this transaction\"))));\n   }\n \n   /**\n    * Whether the RDBMS has restrictions on IN list size (explicit, or poor perf-based).\n    */\n-  public static boolean needsInBatching(DatabaseProduct dbType) {\n-    return dbType == ORACLE || dbType == SQLSERVER;\n+  protected boolean needsInBatching() {\n+    return isORACLE() || isSQLSERVER();\n   }\n \n   /**\n    * Whether the RDBMS has a bug in join and filter operation order described in DERBY-6358.\n    */\n-  public static boolean hasJoinOperationOrderBug(DatabaseProduct dbType) {\n-    return dbType == DERBY || dbType == ORACLE || dbType == POSTGRES;\n+  protected boolean hasJoinOperationOrderBug() {\n+    return isDERBY() || isORACLE() || isPOSTGRES();\n   }\n \n-  public static String getHiveSchemaPostfix(DatabaseProduct dbType) {\n+  public String getHiveSchemaPostfix() {\n     switch (dbType) {\n     case SQLSERVER:\n       return \"mssql\";\n     case DERBY:\n     case MYSQL:\n     case POSTGRES:\n     case ORACLE:\n+    case EXTERNAL:\n       return dbType.name().toLowerCase();\n     case OTHER:\n     default:\n       return null;\n     }\n   }\n+\n+  public static void reset() {", "originalCommit": "4bfb30c5f7a80bbc5f6d5323075ed15359afcc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMjM4OA==", "url": "https://github.com/apache/hive/pull/1470#discussion_r491132388", "bodyText": ":-) ... It's so that we don't fall into the assertion you suggested right above (i.e. \"Preconditions.checkState(this.dbType == getDbType(productName));\").\nThere is a test in the Hive test suite that creates multiple instances of DatabaseProduct for different databases, which fails unless the instance is reset.\nI had added the same assertion you suggested when I originally wrote the code, but then removed it when I got bitten by the test. I was on the fence of whether the assertion was useful or not, so I removed it. I now put it back, along with the calls to reset() in the test.", "author": "gatorblue", "createdAt": "2020-09-18T18:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAzMTQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MTM3Mg==", "url": "https://github.com/apache/hive/pull/1470#discussion_r499871372", "bodyText": "Thanks for the context. In such a case I think it would be good to annotate this method as @VisibleForTesting", "author": "vihangk1", "createdAt": "2020-10-05T21:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAzMTQ3NQ=="}], "type": "inlineReview"}, {"oid": "14a2f1bd15dd8377f00a55a49528c3ee2c3b1457", "url": "https://github.com/apache/hive/commit/14a2f1bd15dd8377f00a55a49528c3ee2c3b1457", "message": "Address review comments", "committedDate": "2020-09-19T13:31:02Z", "type": "commit"}, {"oid": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "url": "https://github.com/apache/hive/commit/6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "message": "Add unit test", "committedDate": "2020-09-19T14:33:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NzU4NQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r499867585", "bodyText": "Its interesting that I don't see \"hive.metastore.db.type\" configuration in MetastoreConf which I think is an unrelated bug. It would be great if you could add more details here. May be say \"Use a external RDBMS which not in the list of natively supported databases eg. Derby, Mysql, Oracle, Postgres, MSSQL as defined by hive.metastore.db.type. If this configuration is true the metastore.custom.database.product.classname must be set to a valid classname.\"", "author": "vihangk1", "createdAt": "2020-10-05T20:56:25Z", "path": "standalone-metastore/metastore-common/src/main/java/org/apache/hadoop/hive/metastore/conf/MetastoreConf.java", "diffHunk": "@@ -1337,6 +1337,15 @@ public static ConfVars getMetaConf(String name) {\n     HIVE_TXN_STATS_ENABLED(\"hive.txn.stats.enabled\", \"hive.txn.stats.enabled\", true,\n         \"Whether Hive supports transactional stats (accurate stats for transactional tables)\"),\n \n+    // External RDBMS support\n+    USE_CUSTOM_RDBMS(\"metastore.use.custom.database.product\",\n+            \"hive.metastore.use.custom.database.product\", false,\n+            \"Use an external RDBMS for the metastore\"),", "originalCommit": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMTM3NQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r502711375", "bodyText": "Sorry, may be should have been clearer. I meant adding the text \"Use an external RDBMS which is not in the list of natively supported databases (e.g. Derby, Mysql, Oracle, Postgres, MSSQL), as defined by hive.metastore.db.type. If this configuration is true, the metastore.custom.database.product.classname must be set to a valid class name\" as the fourth argument in the USE_CUSTOM_RDBMS. IIRC this description is used to generate the template for default hive-site.xml so that the description is present in the xml file itself.", "author": "vihangk1", "createdAt": "2020-10-09T23:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NzU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2OTEyNw==", "url": "https://github.com/apache/hive/pull/1470#discussion_r499869127", "bodyText": "The Overriding DbType: is bit confusing. Why is that log useful?", "author": "vihangk1", "createdAt": "2020-10-05T20:59:12Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));", "originalCommit": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNDI3Nw==", "url": "https://github.com/apache/hive/pull/1470#discussion_r499904277", "bodyText": "Yeah, I put this for my own unit testing. Removed it now.", "author": "gatorblue", "createdAt": "2020-10-05T22:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2OTEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2OTY5Nw==", "url": "https://github.com/apache/hive/pull/1470#discussion_r499869697", "bodyText": "nit, the else could go in the same line as 113 as per the coding conventions.", "author": "vihangk1", "createdAt": "2020-10-05T21:00:15Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));\n+              dbt = DbType.CUSTOM;\n+            }catch (Exception e) {\n+              LOG.warn(\"Caught exception instantiating custom database product. Reverting to \" + dbt, e);\n+            }\n+          }\n+          else {", "originalCommit": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MDA5Mw==", "url": "https://github.com/apache/hive/pull/1470#discussion_r499870093", "bodyText": "I believe its better to throw an exception here with the appropriate message.", "author": "vihangk1", "createdAt": "2020-10-05T21:01:02Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));\n+              dbt = DbType.CUSTOM;\n+            }catch (Exception e) {\n+              LOG.warn(\"Caught exception instantiating custom database product. Reverting to \" + dbt, e);\n+            }\n+          }\n+          else {\n+            LOG.warn(\"Unexpected: metastore.use.custom.database.product was set, \" +", "originalCommit": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MDQ3NQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r499870475", "bodyText": "Is there a good reason to catch the exception and reverting the dbt? Should'nt we throw a MetaException so that HMS doesn't start if the configuration is invalid.", "author": "vihangk1", "createdAt": "2020-10-05T21:01:52Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));\n+              dbt = DbType.CUSTOM;\n+            }catch (Exception e) {\n+              LOG.warn(\"Caught exception instantiating custom database product. Reverting to \" + dbt, e);", "originalCommit": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4OTY0MQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r502689641", "bodyText": "I changed the code to throw a RuntimeException instead. This method is called in a few places where it's not clear what to do with a regular Exception. Hope this makes sense.", "author": "gatorblue", "createdAt": "2020-10-09T22:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3MDQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3Mzk5OQ==", "url": "https://github.com/apache/hive/pull/1470#discussion_r499873999", "bodyText": "It looks like when this line is executed the dbType is null. Do you need to initialize a default value of dbType = UNDEFINED?", "author": "vihangk1", "createdAt": "2020-10-05T21:09:17Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/DatabaseProduct.java", "diffHunk": "@@ -20,71 +20,666 @@\n \n import java.sql.SQLException;\n import java.sql.SQLTransactionRollbackException;\n+import java.sql.Timestamp;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n-/** Database product infered via JDBC. */\n-public enum DatabaseProduct {\n-  DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, OTHER;\n+import org.apache.hadoop.conf.Configurable;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hive.metastore.api.MetaException;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf;\n+import org.apache.hadoop.hive.metastore.conf.MetastoreConf.ConfVars;\n+import org.apache.hadoop.util.ReflectionUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import com.google.common.base.Preconditions;\n+\n+/** Database product inferred via JDBC. Encapsulates all SQL logic associated with\n+ * the database product.\n+ * This class is a singleton, which is instantiated the first time\n+ * method determineDatabaseProduct is invoked.\n+ * Tests that need to create multiple instances can use the reset method\n+ * */\n+public class DatabaseProduct implements Configurable {\n+  static final private Logger LOG = LoggerFactory.getLogger(DatabaseProduct.class.getName());\n+\n+  private static enum DbType {DERBY, MYSQL, POSTGRES, ORACLE, SQLSERVER, CUSTOM, UNDEFINED};\n+  public DbType dbType;\n+  \n+  // Singleton instance\n+  private static DatabaseProduct theDatabaseProduct;\n+\n+  Configuration myConf;\n+  /**\n+   * Protected constructor for singleton class\n+   * @param id\n+   */\n+  protected DatabaseProduct() {}\n+\n+  public static final String DERBY_NAME = \"derby\";\n+  public static final String SQL_SERVER_NAME = \"microsoft sql server\";\n+  public static final String MYSQL_NAME = \"mysql\";\n+  public static final String POSTGRESQL_NAME = \"postgresql\";\n+  public static final String ORACLE_NAME = \"oracle\";\n+  public static final String UNDEFINED_NAME = \"other\";\n+  \n   /**\n    * Determine the database product type\n    * @param productName string to defer database connection\n    * @return database product type\n    */\n-  public static DatabaseProduct determineDatabaseProduct(String productName) throws SQLException {\n-    if (productName == null) {\n-      return OTHER;\n+  public static DatabaseProduct determineDatabaseProduct(String productName, Configuration c) {\n+    DbType dbt;\n+\n+    if (theDatabaseProduct != null) {\n+      Preconditions.checkState(theDatabaseProduct.dbType == getDbType(productName));\n+      return theDatabaseProduct;\n     }\n+\n+    // This method may be invoked by concurrent connections\n+    synchronized (DatabaseProduct.class) {\n+\n+      if (productName == null) {\n+        productName = UNDEFINED_NAME;\n+      }\n+\n+      dbt = getDbType(productName);\n+\n+      // Check for null again in case of race condition\n+      if (theDatabaseProduct == null) {\n+        final Configuration conf = c!= null ? c : MetastoreConf.newMetastoreConf();\n+        // Check if we are using an external database product\n+        boolean isExternal = MetastoreConf.getBoolVar(conf, ConfVars.USE_CUSTOM_RDBMS);\n+\n+        if (isExternal) {\n+          // The DatabaseProduct will be created by instantiating an external class via\n+          // reflection. The external class can override any method in the current class\n+          String className = MetastoreConf.getVar(conf, ConfVars.CUSTOM_RDBMS_CLASSNAME);\n+          \n+          if (className != null) {\n+            try {\n+              theDatabaseProduct = (DatabaseProduct)\n+                  ReflectionUtils.newInstance(Class.forName(className), conf);\n+  \n+              LOG.info(String.format(\"Using custom RDBMS %s. Overriding DbType: %s\", className, dbt));\n+              dbt = DbType.CUSTOM;\n+            }catch (Exception e) {\n+              LOG.warn(\"Caught exception instantiating custom database product. Reverting to \" + dbt, e);\n+            }\n+          }\n+          else {\n+            LOG.warn(\"Unexpected: metastore.use.custom.database.product was set, \" +\n+                     \"but metastore.custom.database.product.classname was not. Reverting to \" + dbt);\n+          }\n+        }\n+\n+        if (theDatabaseProduct == null) {\n+          theDatabaseProduct = new DatabaseProduct();", "originalCommit": "6d5a9424e55074a9625b76c1bffc1a201b3b1b8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY5MTg5Nw==", "url": "https://github.com/apache/hive/pull/1470#discussion_r502691897", "bodyText": "The initialization happens at line 91. I don't see how we can get here without initialization.\nLMK if I'm missing something.", "author": "gatorblue", "createdAt": "2020-10-09T22:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3Mzk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1NzY0Nw==", "url": "https://github.com/apache/hive/pull/1470#discussion_r504957647", "bodyText": "line 91 is initializing a local variable dbt. I see that theDatabaseProducte.dbType = dbt is executed outside synchronized block later below. We should probably move it in the synchronized block.", "author": "vihangk1", "createdAt": "2020-10-14T20:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3Mzk5OQ=="}], "type": "inlineReview"}, {"oid": "d02aa1dc0835ca1875da64660f3b6389f65656c1", "url": "https://github.com/apache/hive/commit/d02aa1dc0835ca1875da64660f3b6389f65656c1", "message": "Address more review comments", "committedDate": "2020-10-09T22:23:48Z", "type": "commit"}, {"oid": "27e9feb20cbd734a4cfdcab4653caa5935e879a8", "url": "https://github.com/apache/hive/commit/27e9feb20cbd734a4cfdcab4653caa5935e879a8", "message": "Vihang's changes", "committedDate": "2020-10-14T21:47:24Z", "type": "commit"}, {"oid": "3a65c6cf9cb552e7c34bfb449a419abfde0a58b6", "url": "https://github.com/apache/hive/commit/3a65c6cf9cb552e7c34bfb449a419abfde0a58b6", "message": "Cleanup conf in unit test", "committedDate": "2020-10-15T12:21:54Z", "type": "commit"}]}