{"pr_number": 1315, "pr_title": "[HIVE-23951] Support parameterized queries in WHERE/HAVING clause", "pr_createdAt": "2020-07-25T00:16:25Z", "pr_url": "https://github.com/apache/hive/pull/1315", "timeline": [{"oid": "42cfe01b3862d3440494970a51f37a70b13351da", "url": "https://github.com/apache/hive/commit/42cfe01b3862d3440494970a51f37a70b13351da", "message": "Support for prepare/execute statements", "committedDate": "2020-07-27T20:06:43Z", "type": "forcePushed"}, {"oid": "23795aae907faff6c1523a3ba98f610571420de2", "url": "https://github.com/apache/hive/commit/23795aae907faff6c1523a3ba98f610571420de2", "message": "Support for prepare/execute statements", "committedDate": "2020-07-29T17:29:03Z", "type": "commit"}, {"oid": "23795aae907faff6c1523a3ba98f610571420de2", "url": "https://github.com/apache/hive/commit/23795aae907faff6c1523a3ba98f610571420de2", "message": "Support for prepare/execute statements", "committedDate": "2020-07-29T17:29:03Z", "type": "forcePushed"}, {"oid": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "url": "https://github.com/apache/hive/commit/8d580d27dcbe34622721ec4963400656a8cfe1f8", "message": "support for decimal type info", "committedDate": "2020-08-02T23:01:44Z", "type": "commit"}, {"oid": "b22e56df0e30cc2655a7e30a6d7d6fe8d892ae99", "url": "https://github.com/apache/hive/commit/b22e56df0e30cc2655a7e30a6d7d6fe8d892ae99", "message": "Merge remote-tracking branch 'upstream/master' into PREPARE_EXECUTE_SUPPORT", "committedDate": "2020-08-03T16:15:15Z", "type": "commit"}, {"oid": "88dab3fd22da65fa8e89f32019552383bc3fc2e0", "url": "https://github.com/apache/hive/commit/88dab3fd22da65fa8e89f32019552383bc3fc2e0", "message": "Updating tests", "committedDate": "2020-08-03T16:46:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzOTEwNg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464139106", "bodyText": "Can we add a test to TestSQL11ReservedKeyWordsNegative.java for the new keyword?", "author": "jcamachor", "createdAt": "2020-08-02T23:54:07Z", "path": "parser/src/java/org/apache/hadoop/hive/ql/parse/HiveLexerParent.g", "diffHunk": "@@ -78,6 +78,7 @@ KW_SORT: 'SORT';\n KW_UNION: 'UNION';\n KW_EXCEPT: 'EXCEPT';\n KW_LOAD: 'LOAD';\n+KW_PREPARE: 'PREPARE';", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MDAzMA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464140030", "bodyText": "This is what we were talking offline about allowing expressions. Just leaving a note so we do not forget to create the follow-up JIRA.", "author": "jcamachor", "createdAt": "2020-08-03T00:01:55Z", "path": "parser/src/java/org/apache/hadoop/hive/ql/parse/PrepareStatementParser.g", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+   Licensed to the Apache Software Foundation (ASF) under one or more \n+   contributor license agreements.  See the NOTICE file distributed with \n+   this work for additional information regarding copyright ownership.\n+   The ASF licenses this file to You under the Apache License, Version 2.0\n+   (the \"License\"); you may not use this file except in compliance with \n+   the License.  You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+parser grammar PrepareStatementParser;\n+\n+options\n+{\n+output=AST;\n+ASTLabelType=ASTNode;\n+backtrack=false;\n+k=3;\n+}\n+\n+@members {\n+  @Override\n+  public Object recoverFromMismatchedSet(IntStream input,\n+      RecognitionException re, BitSet follow) throws RecognitionException {\n+    throw re;\n+  }\n+  @Override\n+  public void displayRecognitionError(String[] tokenNames,\n+      RecognitionException e) {\n+    gParent.errors.add(new ParseError(gParent, e, tokenNames));\n+  }\n+}\n+\n+@rulecatch {\n+catch (RecognitionException e) {\n+  throw e;\n+}\n+}\n+\n+//----------------------- Rules for parsing Prepare statement-----------------------------\n+prepareStatement\n+@init { gParent.pushMsg(\"prepare statement \", state); }\n+@after { gParent.popMsg(state); }\n+    : KW_PREPARE identifier KW_FROM queryStatementExpression\n+    -> ^(TOK_PREPARE queryStatementExpression identifier)\n+    ;\n+\n+executeStatement\n+@init { gParent.pushMsg(\"execute statement \", state); }\n+@after { gParent.popMsg(state); }\n+    : KW_EXECUTE identifier KW_USING executeParamList\n+    -> ^(TOK_EXECUTE executeParamList identifier)\n+    ;\n+\n+executeParamList\n+@init { gParent.pushMsg(\"execute param list\", state); }\n+@after { gParent.popMsg(state); }\n+    : constant (COMMA constant)*", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1Nzg2OQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466057869", "bodyText": "Is there a JIRA?", "author": "jcamachor", "createdAt": "2020-08-05T23:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MDAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2MTg3Mw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466561873", "bodyText": "https://issues.apache.org/jira/browse/HIVE-24002", "author": "vineetgarg02", "createdAt": "2020-08-06T17:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MDA3MQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464140071", "bodyText": "nit. required", "author": "jcamachor", "createdAt": "2020-08-03T00:02:26Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/Compiler.java", "diffHunk": "@@ -338,12 +339,22 @@ private QueryPlan createPlan(BaseSemanticAnalyzer sem) {\n     plan.setOptimizedCBOPlan(context.getCalcitePlan());\n     plan.setOptimizedQueryString(context.getOptimizedSql());\n \n+    // this is require so that later driver can skip executing prepare queries", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4NjA5MQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464186091", "bodyText": "TODO ?", "author": "jcamachor", "createdAt": "2020-08-03T04:17:46Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/Driver.java", "diffHunk": "@@ -433,6 +433,12 @@ private void runInternal(String command, boolean alreadyCompiled) throws Command\n \n     driverState.lock();\n     try {\n+      if (driverContext != null && driverContext.getPlan() != null\n+          && driverContext.getPlan().getIsPrepareQuery()\n+          && !driverContext.getPlan().isExplain()) {\n+        //TODO: LOG", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4NjQ5OQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464186499", "bodyText": "nit. isPrepareQuery -> prepareQuery. Please change setters and getters accordingly below, e.g., getIsPrepareQuery -> isPrepareQuery.", "author": "jcamachor", "createdAt": "2020-08-03T04:19:31Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/QueryPlan.java", "diffHunk": "@@ -121,6 +121,8 @@\n   private final DDLDescWithWriteId acidDdlDesc;\n   private Boolean autoCommitValue;\n \n+  private Boolean isPrepareQuery;", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4ODcyMw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464188723", "bodyText": "nit. typo: kyro", "author": "jcamachor", "createdAt": "2020-08-03T04:30:42Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kyro serialization/de-serialization.", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MDAyOQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464190029", "bodyText": "You can use type.getPrimitiveCategory so you do not have to care about this. Also you will be able to use a switch statement instead of if...else", "author": "jcamachor", "createdAt": "2020-08-03T04:37:21Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kyro serialization/de-serialization.\n+   */\n+  private <T> T makeCopy(final Object task, Class<T> objClass) {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    SerializationUtilities.serializePlan(task, baos);\n+\n+    return SerializationUtilities.deserializePlan(\n+        new ByteArrayInputStream(baos.toByteArray()), objClass);\n+  }\n+\n+  /**\n+   * Given a {@link BaseSemanticAnalyzer} (cached) this method make copies of all tasks\n+   * (including {@link FetchTask}) and update the existing {@link ExecuteStatementAnalyzer}\n+   */\n+  private void createTaskCopy(final BaseSemanticAnalyzer cachedPlan) {\n+    PlanCopy planCopy = new PlanCopy(cachedPlan.getFetchTask(), cachedPlan.getAllRootTasks());\n+    planCopy = makeCopy(planCopy, planCopy.getClass());\n+    this.setFetchTask(planCopy.getFetchTask());\n+    this.rootTasks = planCopy.getTasks();\n+  }\n+\n+  private String getParamLiteralValue(Map<Integer, ASTNode> paramMap, int paramIndex) {\n+    assert(paramMap.containsKey(paramIndex));\n+    ASTNode node = paramMap.get(paramIndex);\n+\n+    if (node.getType() == HiveParser.StringLiteral) {\n+      // remove quotes\n+      return BaseSemanticAnalyzer.unescapeSQLString(node.getText());\n+\n+    } else {\n+      return node.getText();\n+    }\n+  }\n+\n+  /**\n+   * This method creates a constant expression to replace the given dynamic expression.\n+   * @param dynamicExpr Expression node representing Dynamic expression\n+   * @param typeInfo Type info used to create constant expression from ASTNode\n+   * @param parameterMap Integer to AST node map\n+   */\n+  private ExprNodeConstantDesc getConstant(ExprDynamicParamDesc dynamicExpr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> parameterMap) {\n+    assert(parameterMap.containsKey(dynamicExpr.getIndex()));\n+\n+    String value = getParamLiteralValue(parameterMap, dynamicExpr.getIndex());\n+\n+    ExprNodeDescExprFactory factory = new ExprNodeDescExprFactory();\n+\n+    if (typeInfo.equals(TypeInfoFactory.booleanTypeInfo)) {\n+      return factory.createBooleanConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intTypeInfo)) {\n+      return factory.createIntConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.longTypeInfo)) {\n+      return factory.createBigintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.stringTypeInfo)) {\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.charTypeInfo)\n+        // CHAR and VARCHAR typeinfo could differ due to different length, therefore an extra", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MjQ0Mg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464192442", "bodyText": "This method should probably rely on ExprNodeTypeCheck.genExprNode to avoid having two different parsing / interpretation logic.\nA possible idea is to do something like it is done for default constraint values. You could rely on same logic to generate the expr node:\n    TypeCheckCtx typeCheckCtx = new TypeCheckCtx(null);\n    ExprNodeDesc defaultValExpr = ExprNodeTypeCheck.genExprNode(node, typeCheckCtx).get(node);\n\nThen verify type is matching. I think that will provide more reliable logic. What do you think?\nMy take is that it's better to be too strict wrt type rather than generating wrong / different results.", "author": "jcamachor", "createdAt": "2020-08-03T04:49:12Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kyro serialization/de-serialization.\n+   */\n+  private <T> T makeCopy(final Object task, Class<T> objClass) {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    SerializationUtilities.serializePlan(task, baos);\n+\n+    return SerializationUtilities.deserializePlan(\n+        new ByteArrayInputStream(baos.toByteArray()), objClass);\n+  }\n+\n+  /**\n+   * Given a {@link BaseSemanticAnalyzer} (cached) this method make copies of all tasks\n+   * (including {@link FetchTask}) and update the existing {@link ExecuteStatementAnalyzer}\n+   */\n+  private void createTaskCopy(final BaseSemanticAnalyzer cachedPlan) {\n+    PlanCopy planCopy = new PlanCopy(cachedPlan.getFetchTask(), cachedPlan.getAllRootTasks());\n+    planCopy = makeCopy(planCopy, planCopy.getClass());\n+    this.setFetchTask(planCopy.getFetchTask());\n+    this.rootTasks = planCopy.getTasks();\n+  }\n+\n+  private String getParamLiteralValue(Map<Integer, ASTNode> paramMap, int paramIndex) {\n+    assert(paramMap.containsKey(paramIndex));\n+    ASTNode node = paramMap.get(paramIndex);\n+\n+    if (node.getType() == HiveParser.StringLiteral) {\n+      // remove quotes\n+      return BaseSemanticAnalyzer.unescapeSQLString(node.getText());\n+\n+    } else {\n+      return node.getText();\n+    }\n+  }\n+\n+  /**\n+   * This method creates a constant expression to replace the given dynamic expression.\n+   * @param dynamicExpr Expression node representing Dynamic expression\n+   * @param typeInfo Type info used to create constant expression from ASTNode\n+   * @param parameterMap Integer to AST node map\n+   */\n+  private ExprNodeConstantDesc getConstant(ExprDynamicParamDesc dynamicExpr, TypeInfo typeInfo,", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5ODM1OQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464698359", "bodyText": "You are right, I will update the code.", "author": "vineetgarg02", "createdAt": "2020-08-03T22:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MjQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MjcwOA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464192708", "bodyText": "typo. retreives", "author": "jcamachor", "createdAt": "2020-08-03T04:50:33Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5NDQ4NA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464194484", "bodyText": "I think it would be better to create a CachedPlan class rather than caching the complete SemanticAnalyzer.\nIn addition, doesn't QueryPlan have all the information you need? If it has most of it, couldn't you extend it?", "author": "jcamachor", "createdAt": "2020-08-03T04:58:16Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kyro serialization/de-serialization.\n+   */\n+  private <T> T makeCopy(final Object task, Class<T> objClass) {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    SerializationUtilities.serializePlan(task, baos);\n+\n+    return SerializationUtilities.deserializePlan(\n+        new ByteArrayInputStream(baos.toByteArray()), objClass);\n+  }\n+\n+  /**\n+   * Given a {@link BaseSemanticAnalyzer} (cached) this method make copies of all tasks\n+   * (including {@link FetchTask}) and update the existing {@link ExecuteStatementAnalyzer}\n+   */\n+  private void createTaskCopy(final BaseSemanticAnalyzer cachedPlan) {", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2MjM3Mg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r465362372", "bodyText": "Are you suggesting to cache QueryPlan? I went that route before but it created issues with EXPLAIN PLAN. QueryPlan keeps set of tasks so it was hard to create an explain task and then hook it with existing cached tasks for explain plan to work. Caching semantic analyzer helped make the whole implementation simple.\nI guess creating CachedPlan and caching only the information required (tasks, config, inputs, outputs etc) will help reduce memory footprints. Are there other concerns/issues wrt caching the whole semantic analyzer object?\nIf not do you mind if I make this change in a follow-up?", "author": "vineetgarg02", "createdAt": "2020-08-04T22:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5NDQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0MzA3MA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r465443070", "bodyText": "Yes, I thought about QueryPlan since I assumed it would have all the information that is needed. It seems more natural to cache the plan rather than the analyzer.\nOne concern that came to mind is precisely what you mentioned, memory footprint of the analyzer and the implications of caching it, with all the additional information that we extract during analysis and will be mostly useless for our purpose.\nIt is fine defer to follow-up.", "author": "jcamachor", "createdAt": "2020-08-05T02:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5NDQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2MzQzMA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466563430", "bodyText": "Follow-up: https://issues.apache.org/jira/browse/HIVE-24005", "author": "vineetgarg02", "createdAt": "2020-08-06T17:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5NDQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5NTQwMg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464195402", "bodyText": "I think we talked about this offline. Do we support specifying binary constants in the query? If we do not, should we just throw some exception?", "author": "jcamachor", "createdAt": "2020-08-03T05:02:29Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kyro serialization/de-serialization.\n+   */\n+  private <T> T makeCopy(final Object task, Class<T> objClass) {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    SerializationUtilities.serializePlan(task, baos);\n+\n+    return SerializationUtilities.deserializePlan(\n+        new ByteArrayInputStream(baos.toByteArray()), objClass);\n+  }\n+\n+  /**\n+   * Given a {@link BaseSemanticAnalyzer} (cached) this method make copies of all tasks\n+   * (including {@link FetchTask}) and update the existing {@link ExecuteStatementAnalyzer}\n+   */\n+  private void createTaskCopy(final BaseSemanticAnalyzer cachedPlan) {\n+    PlanCopy planCopy = new PlanCopy(cachedPlan.getFetchTask(), cachedPlan.getAllRootTasks());\n+    planCopy = makeCopy(planCopy, planCopy.getClass());\n+    this.setFetchTask(planCopy.getFetchTask());\n+    this.rootTasks = planCopy.getTasks();\n+  }\n+\n+  private String getParamLiteralValue(Map<Integer, ASTNode> paramMap, int paramIndex) {\n+    assert(paramMap.containsKey(paramIndex));\n+    ASTNode node = paramMap.get(paramIndex);\n+\n+    if (node.getType() == HiveParser.StringLiteral) {\n+      // remove quotes\n+      return BaseSemanticAnalyzer.unescapeSQLString(node.getText());\n+\n+    } else {\n+      return node.getText();\n+    }\n+  }\n+\n+  /**\n+   * This method creates a constant expression to replace the given dynamic expression.\n+   * @param dynamicExpr Expression node representing Dynamic expression\n+   * @param typeInfo Type info used to create constant expression from ASTNode\n+   * @param parameterMap Integer to AST node map\n+   */\n+  private ExprNodeConstantDesc getConstant(ExprDynamicParamDesc dynamicExpr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> parameterMap) {\n+    assert(parameterMap.containsKey(dynamicExpr.getIndex()));\n+\n+    String value = getParamLiteralValue(parameterMap, dynamicExpr.getIndex());\n+\n+    ExprNodeDescExprFactory factory = new ExprNodeDescExprFactory();\n+\n+    if (typeInfo.equals(TypeInfoFactory.booleanTypeInfo)) {\n+      return factory.createBooleanConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intTypeInfo)) {\n+      return factory.createIntConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.longTypeInfo)) {\n+      return factory.createBigintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.stringTypeInfo)) {\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.charTypeInfo)\n+        // CHAR and VARCHAR typeinfo could differ due to different length, therefore an extra\n+        // check is used (based on instanceof) to determine if it is char/varchar types\n+        || typeInfo instanceof CharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.varcharTypeInfo)\n+        || typeInfo instanceof VarcharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.floatTypeInfo)) {\n+      return factory.createFloatConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.doubleTypeInfo)) {\n+      return factory.createDoubleConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.byteTypeInfo)) {\n+      return factory.createTinyintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.shortTypeInfo)) {\n+      return factory.createSmallintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.dateTypeInfo)) {\n+      return factory.createDateConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.timestampTypeInfo)) {\n+      return factory.createTimestampConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalYearMonthTypeInfo)) {\n+      return factory.createIntervalYearMonthConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalDayTimeTypeInfo)) {\n+      return factory.createIntervalDayTimeConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.binaryTypeInfo)) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5NzU1Ng==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464197556", "bodyText": "I think this should not be part of this patch (only FILTER)?", "author": "jcamachor", "createdAt": "2020-08-03T05:12:38Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kyro serialization/de-serialization.\n+   */\n+  private <T> T makeCopy(final Object task, Class<T> objClass) {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    SerializationUtilities.serializePlan(task, baos);\n+\n+    return SerializationUtilities.deserializePlan(\n+        new ByteArrayInputStream(baos.toByteArray()), objClass);\n+  }\n+\n+  /**\n+   * Given a {@link BaseSemanticAnalyzer} (cached) this method make copies of all tasks\n+   * (including {@link FetchTask}) and update the existing {@link ExecuteStatementAnalyzer}\n+   */\n+  private void createTaskCopy(final BaseSemanticAnalyzer cachedPlan) {\n+    PlanCopy planCopy = new PlanCopy(cachedPlan.getFetchTask(), cachedPlan.getAllRootTasks());\n+    planCopy = makeCopy(planCopy, planCopy.getClass());\n+    this.setFetchTask(planCopy.getFetchTask());\n+    this.rootTasks = planCopy.getTasks();\n+  }\n+\n+  private String getParamLiteralValue(Map<Integer, ASTNode> paramMap, int paramIndex) {\n+    assert(paramMap.containsKey(paramIndex));\n+    ASTNode node = paramMap.get(paramIndex);\n+\n+    if (node.getType() == HiveParser.StringLiteral) {\n+      // remove quotes\n+      return BaseSemanticAnalyzer.unescapeSQLString(node.getText());\n+\n+    } else {\n+      return node.getText();\n+    }\n+  }\n+\n+  /**\n+   * This method creates a constant expression to replace the given dynamic expression.\n+   * @param dynamicExpr Expression node representing Dynamic expression\n+   * @param typeInfo Type info used to create constant expression from ASTNode\n+   * @param parameterMap Integer to AST node map\n+   */\n+  private ExprNodeConstantDesc getConstant(ExprDynamicParamDesc dynamicExpr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> parameterMap) {\n+    assert(parameterMap.containsKey(dynamicExpr.getIndex()));\n+\n+    String value = getParamLiteralValue(parameterMap, dynamicExpr.getIndex());\n+\n+    ExprNodeDescExprFactory factory = new ExprNodeDescExprFactory();\n+\n+    if (typeInfo.equals(TypeInfoFactory.booleanTypeInfo)) {\n+      return factory.createBooleanConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intTypeInfo)) {\n+      return factory.createIntConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.longTypeInfo)) {\n+      return factory.createBigintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.stringTypeInfo)) {\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.charTypeInfo)\n+        // CHAR and VARCHAR typeinfo could differ due to different length, therefore an extra\n+        // check is used (based on instanceof) to determine if it is char/varchar types\n+        || typeInfo instanceof CharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.varcharTypeInfo)\n+        || typeInfo instanceof VarcharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.floatTypeInfo)) {\n+      return factory.createFloatConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.doubleTypeInfo)) {\n+      return factory.createDoubleConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.byteTypeInfo)) {\n+      return factory.createTinyintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.shortTypeInfo)) {\n+      return factory.createSmallintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.dateTypeInfo)) {\n+      return factory.createDateConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.timestampTypeInfo)) {\n+      return factory.createTimestampConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalYearMonthTypeInfo)) {\n+      return factory.createIntervalYearMonthConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalDayTimeTypeInfo)) {\n+      return factory.createIntervalDayTimeConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.binaryTypeInfo)) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    }\n+    // we will let constant expression itself infer the type\n+    return new ExprNodeConstantDesc(parameterMap.get(dynamicExpr.getIndex()));\n+  }\n+\n+  /**\n+   * Given a list of expressions this method traverse the expression tree and replaces\n+   * all {@link ExprDynamicParamDesc} nodes with constant expression.\n+   * @param exprList\n+   * @param paramMap\n+   */\n+  private List<ExprNodeDesc> replaceDynamicParamsInExprList(List<ExprNodeDesc> exprList,\n+      Map<Integer, ASTNode> paramMap) {\n+    List<ExprNodeDesc> updatedExprList = new ArrayList<>();\n+    for (ExprNodeDesc expr:exprList) {\n+      expr = replaceDynamicParamsWithConstant(expr, expr.getTypeInfo(), paramMap);\n+      updatedExprList.add(expr);\n+    }\n+    return updatedExprList;\n+  }\n+\n+  /**\n+   * Given an expression tree root at expr and type info of the expression this method traverse\n+   * the expression tree and replaces all dynamic expression with the constant expression.\n+   * This method also does type inference for the new constant expression.\n+   * Note about type inference\n+   * Since dynamic parameter lacks type we need to figure out appropriate type to create constant\n+   * out of string value. To do this, we choose the type of first child of the parent expression\n+   * which isn't dynamic parameter\n+   */\n+  private ExprNodeDesc replaceDynamicParamsWithConstant(ExprNodeDesc expr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> paramMap) {\n+    if (expr.getChildren() == null || expr.getChildren().isEmpty()) {\n+      if (expr instanceof ExprDynamicParamDesc) {\n+        return getConstant((ExprDynamicParamDesc)expr, typeInfo, paramMap);\n+      }\n+      return expr;\n+    }\n+\n+    for(ExprNodeDesc child:expr.getChildren()) {\n+      // we need typeinfo\n+      if(child instanceof ExprDynamicParamDesc) {\n+        continue;\n+      } else if( child.getTypeInfo() != TypeInfoFactory.voidTypeInfo\n+          && !child.getTypeInfo().getTypeName().equals(\n+          TypeInfoFactory.voidTypeInfo.getTypeName())){\n+        typeInfo = child.getTypeInfo();\n+        break;\n+      }\n+    }\n+    assert(typeInfo != null);\n+\n+    List<ExprNodeDesc> exprList = new ArrayList<>();\n+    for(ExprNodeDesc child: expr.getChildren()) {\n+      if(child instanceof ExprDynamicParamDesc) {\n+        child = getConstant((ExprDynamicParamDesc)child, typeInfo, paramMap);\n+      } else {\n+        child = replaceDynamicParamsWithConstant(child, typeInfo, paramMap);\n+      }\n+      exprList.add(child);\n+    }\n+    expr.getChildren().clear();\n+    expr.getChildren().addAll(exprList);\n+    return expr;\n+  }\n+\n+  /**\n+   * Given map of index and ASTNode this traverse all operators within all tasks\n+   * including Fetch Task and all root tasks to find and replace all dynamic expressions\n+   */\n+  private void bindDynamicParams(Map<Integer, ASTNode> parameterMap) throws SemanticException{\n+    assert(!parameterMap.isEmpty());\n+\n+    Set<Operator<?>> operators = new HashSet<>();\n+    if (this.getFetchTask() != null) {\n+      operators.addAll(OperatorUtils.getAllFetchOperators(this.getFetchTask()));\n+    }\n+    List<Task<?>> allTasks = this.getRootTasks();\n+    List<TezTask> rootTasks = Utilities.getTezTasks(this.getRootTasks());\n+    for(Task task:allTasks) {\n+      List<BaseWork> baseWorks = new ArrayList<>();\n+      if (task instanceof ExplainTask) {\n+        ExplainTask explainTask = (ExplainTask) task;\n+        for (Task explainRootTask : explainTask.getWork().getRootTasks()) {\n+          if (explainRootTask instanceof TezTask) {\n+            TezTask explainTezTask = (TezTask) explainRootTask;\n+            baseWorks.addAll(explainTezTask.getWork().getAllWork());\n+          }\n+        }\n+      } else if (task instanceof TezTask) {\n+        baseWorks = ((TezTask) task).getWork().getAllWork();\n+      }\n+      for (BaseWork baseWork : baseWorks) {\n+        operators.addAll(baseWork.getAllOperators());\n+      }\n+    }\n+\n+    for (Operator<?> op : operators) {\n+      switch(op.getType()) {\n+      case FILTER:\n+        FilterOperator filterOp = (FilterOperator)op;\n+        ExprNodeDesc predicate = filterOp.getConf().getPredicate();\n+        filterOp.getConf().setPredicate(\n+            replaceDynamicParamsWithConstant(predicate, TypeInfoFactory.booleanTypeInfo, parameterMap));\n+        break;\n+      case SELECT:", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5ODMwOQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464198309", "bodyText": "Preconditions instead of assert?", "author": "jcamachor", "createdAt": "2020-08-03T05:16:04Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kyro serialization/de-serialization.\n+   */\n+  private <T> T makeCopy(final Object task, Class<T> objClass) {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    SerializationUtilities.serializePlan(task, baos);\n+\n+    return SerializationUtilities.deserializePlan(\n+        new ByteArrayInputStream(baos.toByteArray()), objClass);\n+  }\n+\n+  /**\n+   * Given a {@link BaseSemanticAnalyzer} (cached) this method make copies of all tasks\n+   * (including {@link FetchTask}) and update the existing {@link ExecuteStatementAnalyzer}\n+   */\n+  private void createTaskCopy(final BaseSemanticAnalyzer cachedPlan) {\n+    PlanCopy planCopy = new PlanCopy(cachedPlan.getFetchTask(), cachedPlan.getAllRootTasks());\n+    planCopy = makeCopy(planCopy, planCopy.getClass());\n+    this.setFetchTask(planCopy.getFetchTask());\n+    this.rootTasks = planCopy.getTasks();\n+  }\n+\n+  private String getParamLiteralValue(Map<Integer, ASTNode> paramMap, int paramIndex) {\n+    assert(paramMap.containsKey(paramIndex));\n+    ASTNode node = paramMap.get(paramIndex);\n+\n+    if (node.getType() == HiveParser.StringLiteral) {\n+      // remove quotes\n+      return BaseSemanticAnalyzer.unescapeSQLString(node.getText());\n+\n+    } else {\n+      return node.getText();\n+    }\n+  }\n+\n+  /**\n+   * This method creates a constant expression to replace the given dynamic expression.\n+   * @param dynamicExpr Expression node representing Dynamic expression\n+   * @param typeInfo Type info used to create constant expression from ASTNode\n+   * @param parameterMap Integer to AST node map\n+   */\n+  private ExprNodeConstantDesc getConstant(ExprDynamicParamDesc dynamicExpr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> parameterMap) {\n+    assert(parameterMap.containsKey(dynamicExpr.getIndex()));\n+\n+    String value = getParamLiteralValue(parameterMap, dynamicExpr.getIndex());\n+\n+    ExprNodeDescExprFactory factory = new ExprNodeDescExprFactory();\n+\n+    if (typeInfo.equals(TypeInfoFactory.booleanTypeInfo)) {\n+      return factory.createBooleanConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intTypeInfo)) {\n+      return factory.createIntConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.longTypeInfo)) {\n+      return factory.createBigintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.stringTypeInfo)) {\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.charTypeInfo)\n+        // CHAR and VARCHAR typeinfo could differ due to different length, therefore an extra\n+        // check is used (based on instanceof) to determine if it is char/varchar types\n+        || typeInfo instanceof CharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.varcharTypeInfo)\n+        || typeInfo instanceof VarcharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.floatTypeInfo)) {\n+      return factory.createFloatConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.doubleTypeInfo)) {\n+      return factory.createDoubleConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.byteTypeInfo)) {\n+      return factory.createTinyintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.shortTypeInfo)) {\n+      return factory.createSmallintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.dateTypeInfo)) {\n+      return factory.createDateConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.timestampTypeInfo)) {\n+      return factory.createTimestampConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalYearMonthTypeInfo)) {\n+      return factory.createIntervalYearMonthConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalDayTimeTypeInfo)) {\n+      return factory.createIntervalDayTimeConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.binaryTypeInfo)) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    }\n+    // we will let constant expression itself infer the type\n+    return new ExprNodeConstantDesc(parameterMap.get(dynamicExpr.getIndex()));\n+  }\n+\n+  /**\n+   * Given a list of expressions this method traverse the expression tree and replaces\n+   * all {@link ExprDynamicParamDesc} nodes with constant expression.\n+   * @param exprList\n+   * @param paramMap\n+   */\n+  private List<ExprNodeDesc> replaceDynamicParamsInExprList(List<ExprNodeDesc> exprList,\n+      Map<Integer, ASTNode> paramMap) {\n+    List<ExprNodeDesc> updatedExprList = new ArrayList<>();\n+    for (ExprNodeDesc expr:exprList) {\n+      expr = replaceDynamicParamsWithConstant(expr, expr.getTypeInfo(), paramMap);\n+      updatedExprList.add(expr);\n+    }\n+    return updatedExprList;\n+  }\n+\n+  /**\n+   * Given an expression tree root at expr and type info of the expression this method traverse\n+   * the expression tree and replaces all dynamic expression with the constant expression.\n+   * This method also does type inference for the new constant expression.\n+   * Note about type inference\n+   * Since dynamic parameter lacks type we need to figure out appropriate type to create constant\n+   * out of string value. To do this, we choose the type of first child of the parent expression\n+   * which isn't dynamic parameter\n+   */\n+  private ExprNodeDesc replaceDynamicParamsWithConstant(ExprNodeDesc expr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> paramMap) {\n+    if (expr.getChildren() == null || expr.getChildren().isEmpty()) {\n+      if (expr instanceof ExprDynamicParamDesc) {\n+        return getConstant((ExprDynamicParamDesc)expr, typeInfo, paramMap);\n+      }\n+      return expr;\n+    }\n+\n+    for(ExprNodeDesc child:expr.getChildren()) {\n+      // we need typeinfo\n+      if(child instanceof ExprDynamicParamDesc) {\n+        continue;\n+      } else if( child.getTypeInfo() != TypeInfoFactory.voidTypeInfo\n+          && !child.getTypeInfo().getTypeName().equals(\n+          TypeInfoFactory.voidTypeInfo.getTypeName())){\n+        typeInfo = child.getTypeInfo();\n+        break;\n+      }\n+    }\n+    assert(typeInfo != null);", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5OTY2OA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464199668", "bodyText": "Isn't child.getTypeInfo() != TypeInfoFactory.voidTypeInfo sufficient?", "author": "jcamachor", "createdAt": "2020-08-03T05:22:28Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kyro serialization/de-serialization.\n+   */\n+  private <T> T makeCopy(final Object task, Class<T> objClass) {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    SerializationUtilities.serializePlan(task, baos);\n+\n+    return SerializationUtilities.deserializePlan(\n+        new ByteArrayInputStream(baos.toByteArray()), objClass);\n+  }\n+\n+  /**\n+   * Given a {@link BaseSemanticAnalyzer} (cached) this method make copies of all tasks\n+   * (including {@link FetchTask}) and update the existing {@link ExecuteStatementAnalyzer}\n+   */\n+  private void createTaskCopy(final BaseSemanticAnalyzer cachedPlan) {\n+    PlanCopy planCopy = new PlanCopy(cachedPlan.getFetchTask(), cachedPlan.getAllRootTasks());\n+    planCopy = makeCopy(planCopy, planCopy.getClass());\n+    this.setFetchTask(planCopy.getFetchTask());\n+    this.rootTasks = planCopy.getTasks();\n+  }\n+\n+  private String getParamLiteralValue(Map<Integer, ASTNode> paramMap, int paramIndex) {\n+    assert(paramMap.containsKey(paramIndex));\n+    ASTNode node = paramMap.get(paramIndex);\n+\n+    if (node.getType() == HiveParser.StringLiteral) {\n+      // remove quotes\n+      return BaseSemanticAnalyzer.unescapeSQLString(node.getText());\n+\n+    } else {\n+      return node.getText();\n+    }\n+  }\n+\n+  /**\n+   * This method creates a constant expression to replace the given dynamic expression.\n+   * @param dynamicExpr Expression node representing Dynamic expression\n+   * @param typeInfo Type info used to create constant expression from ASTNode\n+   * @param parameterMap Integer to AST node map\n+   */\n+  private ExprNodeConstantDesc getConstant(ExprDynamicParamDesc dynamicExpr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> parameterMap) {\n+    assert(parameterMap.containsKey(dynamicExpr.getIndex()));\n+\n+    String value = getParamLiteralValue(parameterMap, dynamicExpr.getIndex());\n+\n+    ExprNodeDescExprFactory factory = new ExprNodeDescExprFactory();\n+\n+    if (typeInfo.equals(TypeInfoFactory.booleanTypeInfo)) {\n+      return factory.createBooleanConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intTypeInfo)) {\n+      return factory.createIntConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.longTypeInfo)) {\n+      return factory.createBigintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.stringTypeInfo)) {\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.charTypeInfo)\n+        // CHAR and VARCHAR typeinfo could differ due to different length, therefore an extra\n+        // check is used (based on instanceof) to determine if it is char/varchar types\n+        || typeInfo instanceof CharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.varcharTypeInfo)\n+        || typeInfo instanceof VarcharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.floatTypeInfo)) {\n+      return factory.createFloatConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.doubleTypeInfo)) {\n+      return factory.createDoubleConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.byteTypeInfo)) {\n+      return factory.createTinyintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.shortTypeInfo)) {\n+      return factory.createSmallintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.dateTypeInfo)) {\n+      return factory.createDateConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.timestampTypeInfo)) {\n+      return factory.createTimestampConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalYearMonthTypeInfo)) {\n+      return factory.createIntervalYearMonthConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalDayTimeTypeInfo)) {\n+      return factory.createIntervalDayTimeConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.binaryTypeInfo)) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    }\n+    // we will let constant expression itself infer the type\n+    return new ExprNodeConstantDesc(parameterMap.get(dynamicExpr.getIndex()));\n+  }\n+\n+  /**\n+   * Given a list of expressions this method traverse the expression tree and replaces\n+   * all {@link ExprDynamicParamDesc} nodes with constant expression.\n+   * @param exprList\n+   * @param paramMap\n+   */\n+  private List<ExprNodeDesc> replaceDynamicParamsInExprList(List<ExprNodeDesc> exprList,\n+      Map<Integer, ASTNode> paramMap) {\n+    List<ExprNodeDesc> updatedExprList = new ArrayList<>();\n+    for (ExprNodeDesc expr:exprList) {\n+      expr = replaceDynamicParamsWithConstant(expr, expr.getTypeInfo(), paramMap);\n+      updatedExprList.add(expr);\n+    }\n+    return updatedExprList;\n+  }\n+\n+  /**\n+   * Given an expression tree root at expr and type info of the expression this method traverse\n+   * the expression tree and replaces all dynamic expression with the constant expression.\n+   * This method also does type inference for the new constant expression.\n+   * Note about type inference\n+   * Since dynamic parameter lacks type we need to figure out appropriate type to create constant\n+   * out of string value. To do this, we choose the type of first child of the parent expression\n+   * which isn't dynamic parameter\n+   */\n+  private ExprNodeDesc replaceDynamicParamsWithConstant(ExprNodeDesc expr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> paramMap) {\n+    if (expr.getChildren() == null || expr.getChildren().isEmpty()) {\n+      if (expr instanceof ExprDynamicParamDesc) {\n+        return getConstant((ExprDynamicParamDesc)expr, typeInfo, paramMap);\n+      }\n+      return expr;\n+    }\n+\n+    for(ExprNodeDesc child:expr.getChildren()) {\n+      // we need typeinfo\n+      if(child instanceof ExprDynamicParamDesc) {\n+        continue;\n+      } else if( child.getTypeInfo() != TypeInfoFactory.voidTypeInfo", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwMTE4Nw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464701187", "bodyText": "Yes I think so, I don't recall why I added comparison with the name as well. I will update the code to remove it.", "author": "vineetgarg02", "createdAt": "2020-08-03T22:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5OTY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwMDQwMw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464200403", "bodyText": "Could this possibly be simplified to child = replaceDynamicParamsWithConstant(child, typeInfo, paramMap); instead of having two code paths in the loop?", "author": "jcamachor", "createdAt": "2020-08-03T05:25:51Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SelectOperator;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSelectOperator;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.BaseSemanticAnalyzer;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeDescExprFactory;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.CharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.VarcharTypeInfo;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retreives cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kyro serialization/de-serialization.\n+   */\n+  private <T> T makeCopy(final Object task, Class<T> objClass) {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    SerializationUtilities.serializePlan(task, baos);\n+\n+    return SerializationUtilities.deserializePlan(\n+        new ByteArrayInputStream(baos.toByteArray()), objClass);\n+  }\n+\n+  /**\n+   * Given a {@link BaseSemanticAnalyzer} (cached) this method make copies of all tasks\n+   * (including {@link FetchTask}) and update the existing {@link ExecuteStatementAnalyzer}\n+   */\n+  private void createTaskCopy(final BaseSemanticAnalyzer cachedPlan) {\n+    PlanCopy planCopy = new PlanCopy(cachedPlan.getFetchTask(), cachedPlan.getAllRootTasks());\n+    planCopy = makeCopy(planCopy, planCopy.getClass());\n+    this.setFetchTask(planCopy.getFetchTask());\n+    this.rootTasks = planCopy.getTasks();\n+  }\n+\n+  private String getParamLiteralValue(Map<Integer, ASTNode> paramMap, int paramIndex) {\n+    assert(paramMap.containsKey(paramIndex));\n+    ASTNode node = paramMap.get(paramIndex);\n+\n+    if (node.getType() == HiveParser.StringLiteral) {\n+      // remove quotes\n+      return BaseSemanticAnalyzer.unescapeSQLString(node.getText());\n+\n+    } else {\n+      return node.getText();\n+    }\n+  }\n+\n+  /**\n+   * This method creates a constant expression to replace the given dynamic expression.\n+   * @param dynamicExpr Expression node representing Dynamic expression\n+   * @param typeInfo Type info used to create constant expression from ASTNode\n+   * @param parameterMap Integer to AST node map\n+   */\n+  private ExprNodeConstantDesc getConstant(ExprDynamicParamDesc dynamicExpr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> parameterMap) {\n+    assert(parameterMap.containsKey(dynamicExpr.getIndex()));\n+\n+    String value = getParamLiteralValue(parameterMap, dynamicExpr.getIndex());\n+\n+    ExprNodeDescExprFactory factory = new ExprNodeDescExprFactory();\n+\n+    if (typeInfo.equals(TypeInfoFactory.booleanTypeInfo)) {\n+      return factory.createBooleanConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intTypeInfo)) {\n+      return factory.createIntConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.longTypeInfo)) {\n+      return factory.createBigintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.stringTypeInfo)) {\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.charTypeInfo)\n+        // CHAR and VARCHAR typeinfo could differ due to different length, therefore an extra\n+        // check is used (based on instanceof) to determine if it is char/varchar types\n+        || typeInfo instanceof CharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.varcharTypeInfo)\n+        || typeInfo instanceof VarcharTypeInfo) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.floatTypeInfo)) {\n+      return factory.createFloatConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.doubleTypeInfo)) {\n+      return factory.createDoubleConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.byteTypeInfo)) {\n+      return factory.createTinyintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.shortTypeInfo)) {\n+      return factory.createSmallintConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.dateTypeInfo)) {\n+      return factory.createDateConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.timestampTypeInfo)) {\n+      return factory.createTimestampConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalYearMonthTypeInfo)) {\n+      return factory.createIntervalYearMonthConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.intervalDayTimeTypeInfo)) {\n+      return factory.createIntervalDayTimeConstantExpr(value);\n+    } else if (typeInfo.equals(TypeInfoFactory.binaryTypeInfo)) {\n+      //TODO: is it okay to create string\n+      return factory.createStringConstantExpr(value);\n+    }\n+    // we will let constant expression itself infer the type\n+    return new ExprNodeConstantDesc(parameterMap.get(dynamicExpr.getIndex()));\n+  }\n+\n+  /**\n+   * Given a list of expressions this method traverse the expression tree and replaces\n+   * all {@link ExprDynamicParamDesc} nodes with constant expression.\n+   * @param exprList\n+   * @param paramMap\n+   */\n+  private List<ExprNodeDesc> replaceDynamicParamsInExprList(List<ExprNodeDesc> exprList,\n+      Map<Integer, ASTNode> paramMap) {\n+    List<ExprNodeDesc> updatedExprList = new ArrayList<>();\n+    for (ExprNodeDesc expr:exprList) {\n+      expr = replaceDynamicParamsWithConstant(expr, expr.getTypeInfo(), paramMap);\n+      updatedExprList.add(expr);\n+    }\n+    return updatedExprList;\n+  }\n+\n+  /**\n+   * Given an expression tree root at expr and type info of the expression this method traverse\n+   * the expression tree and replaces all dynamic expression with the constant expression.\n+   * This method also does type inference for the new constant expression.\n+   * Note about type inference\n+   * Since dynamic parameter lacks type we need to figure out appropriate type to create constant\n+   * out of string value. To do this, we choose the type of first child of the parent expression\n+   * which isn't dynamic parameter\n+   */\n+  private ExprNodeDesc replaceDynamicParamsWithConstant(ExprNodeDesc expr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> paramMap) {\n+    if (expr.getChildren() == null || expr.getChildren().isEmpty()) {\n+      if (expr instanceof ExprDynamicParamDesc) {\n+        return getConstant((ExprDynamicParamDesc)expr, typeInfo, paramMap);\n+      }\n+      return expr;\n+    }\n+\n+    for(ExprNodeDesc child:expr.getChildren()) {\n+      // we need typeinfo\n+      if(child instanceof ExprDynamicParamDesc) {\n+        continue;\n+      } else if( child.getTypeInfo() != TypeInfoFactory.voidTypeInfo\n+          && !child.getTypeInfo().getTypeName().equals(\n+          TypeInfoFactory.voidTypeInfo.getTypeName())){\n+        typeInfo = child.getTypeInfo();\n+        break;\n+      }\n+    }\n+    assert(typeInfo != null);\n+\n+    List<ExprNodeDesc> exprList = new ArrayList<>();\n+    for(ExprNodeDesc child: expr.getChildren()) {\n+      if(child instanceof ExprDynamicParamDesc) {", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwOTE3MA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464209170", "bodyText": "If we rely on ExprNodeTypeCheck.genExprNode, this visibility does not need to change (it makes sense to limit the scope of these methods).", "author": "jcamachor", "createdAt": "2020-08-03T06:02:03Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/type/ExprFactory.java", "diffHunk": "@@ -112,40 +112,45 @@ protected boolean isAllConstants(List<T> exprs) {\n    */\n   protected abstract T createNullConstantExpr();\n \n+  /**\n+   * Creates a dynamic parameter expression with void type.\n+   */\n+  protected abstract T createDynamicParamExpr(int index);\n+\n   /**\n    * Creates a boolean constant expression from input value.\n    */\n-  protected abstract T createBooleanConstantExpr(String value);\n+  public abstract T createBooleanConstantExpr(String value);", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwOTc2Mg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464209762", "bodyText": "We should probably add four queries that read alltypesorc: each query with all possible types in the filter expression using one of the following comparisons: =, <, IN, and BETWEEN. That would provide quite exhaustive testing.", "author": "jcamachor", "createdAt": "2020-08-03T06:04:12Z", "path": "ql/src/test/queries/clientpositive/prepare_plan.q", "diffHunk": "@@ -0,0 +1,112 @@\n+--! qt:dataset:src", "originalCommit": "23795aae907faff6c1523a3ba98f610571420de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzNTg0NQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464535845", "bodyText": "This analyzer should probably not be in table/drop folder?", "author": "jcamachor", "createdAt": "2020-08-03T16:50:52Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzNTk4Nw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464535987", "bodyText": "This analyzer should probably not be in table/drop folder?", "author": "jcamachor", "createdAt": "2020-08-03T16:51:09Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/PrepareStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzNjkxMQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464536911", "bodyText": "Could we have a single map that stores all necessary information in a single object value, rather than a map for the prepare plans and a map for the config?", "author": "jcamachor", "createdAt": "2020-08-03T16:52:51Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/table/drop/PrepareStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.ddl.table.drop;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.parse.ASTNode;\n+import org.apache.hadoop.hive.ql.parse.CalcitePlanner;\n+import org.apache.hadoop.hive.ql.parse.HiveParser;\n+import org.apache.hadoop.hive.ql.parse.SemanticException;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+\n+/**\n+ * Analyzer for Prepare queries. This analyzer generates plan for the parameterized query\n+ * and save it in cache\n+ */\n+@DDLType(types = HiveParser.TOK_PREPARE)\n+public class PrepareStatementAnalyzer extends CalcitePlanner {\n+\n+  public PrepareStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * This method saves the current {@link PrepareStatementAnalyzer} object as well as\n+   * the config used to compile the plan.\n+   * @param root\n+   * @throws SemanticException\n+   */\n+  private void savePlan(String queryName) throws SemanticException{\n+    SessionState ss = SessionState.get();\n+    assert(ss != null);\n+\n+    if (ss.getPreparePlans().containsKey(queryName)) {\n+      throw new SemanticException(\"Prepare query: \" + queryName + \" already exists.\");\n+    }\n+    ss.getPreparePlans().put(queryName, this);", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyMTgzMQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464721831", "bodyText": "Yes, will update the code.", "author": "vineetgarg02", "createdAt": "2020-08-03T23:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzNjkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NTYxNQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464555615", "bodyText": "We should probably move this method to TaskUtils or Utilities rather than being used directly from AnnotateRunTimeStatsOptimizer.", "author": "jcamachor", "createdAt": "2020-08-03T17:28:06Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/OperatorUtils.java", "diffHunk": "@@ -49,6 +50,8 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Multimap;\n \n+import static org.apache.hadoop.hive.ql.optimizer.physical.AnnotateRunTimeStatsOptimizer.getAllOperatorsForSimpleFetch;", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyMjAxMQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464722011", "bodyText": "You mean move getAllOperatorsForSimpleFetch from AnnotateRunTimeStatsOptimizer?", "author": "vineetgarg02", "createdAt": "2020-08-03T23:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyOTg1NQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464729855", "bodyText": "Yes, I meant getAllOperatorsForSimpleFetch, since it seems it used beyond the scope of AnnotateRunTimeStatsOptimizer?", "author": "jcamachor", "createdAt": "2020-08-04T00:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NTYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MDQxMQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464570411", "bodyText": "Is this correct? Could we leave a comment stating why the call to processGByExpr is needed?", "author": "jcamachor", "createdAt": "2020-08-03T17:51:33Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/type/TypeCheckProcFactory.java", "diffHunk": "@@ -283,6 +283,33 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n \n   }\n \n+  /**\n+   * Processor for processing Dynamic expression.\n+   */\n+  public class DynamicParameterProcessor implements SemanticNodeProcessor {\n+\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+        Object... nodeOutputs) throws SemanticException {\n+      TypeCheckCtx ctx = (TypeCheckCtx) procCtx;\n+      if (ctx.getError() != null) {\n+        return null;\n+      }\n+\n+      T desc = processGByExpr(nd, procCtx);", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyMjA5Ng==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464722096", "bodyText": "No I believe this is not required. I will remove it.", "author": "vineetgarg02", "createdAt": "2020-08-03T23:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MDQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MjA3Nw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464572077", "bodyText": "I am wondering whether we need to add SELECT privilege here or it will be taken care of since we are relying on query execution logic? Could we investigate this in follow-up (probably it is important to avoid anyone bypassing authorization)?", "author": "jcamachor", "createdAt": "2020-08-03T17:54:48Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/plan/HiveOperation.java", "diffHunk": "@@ -205,7 +205,9 @@\n   DROP_MAPPING(\"DROP MAPPING\", HiveParser.TOK_DROP_MAPPING, null, null, false, false),\n   CREATE_SCHEDULED_QUERY(\"CREATE SCHEDULED QUERY\", HiveParser.TOK_CREATE_SCHEDULED_QUERY, null, null),\n   ALTER_SCHEDULED_QUERY(\"ALTER SCHEDULED QUERY\", HiveParser.TOK_ALTER_SCHEDULED_QUERY, null, null),\n-  DROP_SCHEDULED_QUERY(\"DROP SCHEDULED QUERY\", HiveParser.TOK_DROP_SCHEDULED_QUERY, null, null)\n+  DROP_SCHEDULED_QUERY(\"DROP SCHEDULED QUERY\", HiveParser.TOK_DROP_SCHEDULED_QUERY, null, null),\n+  PREPARE(\"PREPARE QUERY\", HiveParser.TOK_PREPARE, null, null),\n+  EXECUTE(\"EXECUTE QUERY\", HiveParser.TOK_EXECUTE, null, null)", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyMjMwOA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464722308", "bodyText": "IIRC I had to make this change for explain plan to work. Let me re-investigate, I will get back.", "author": "vineetgarg02", "createdAt": "2020-08-03T23:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MjA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2Nzg4Mg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466567882", "bodyText": "Follow-up: https://issues.apache.org/jira/browse/HIVE-24007", "author": "vineetgarg02", "createdAt": "2020-08-06T17:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MjA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MjU5OQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464572599", "bodyText": "typo. colecting\nWhat will happen in this case? Could we add a few lines explaining the behavior?", "author": "jcamachor", "createdAt": "2020-08-03T17:55:50Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/stats/StatsUtils.java", "diffHunk": "@@ -1619,6 +1620,9 @@ public static ColStatistics getColStatisticsFromExpression(HiveConf conf, Statis\n       colName = enfd.getFieldName();\n       colType = enfd.getTypeString();\n       countDistincts = numRows;\n+    } else if (end instanceof ExprDynamicParamDesc) {\n+      //skip colecting stats for parameters", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxNDYzMg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464714632", "bodyText": "This method tries to figure out column statistics involved in the given expression. I guess the stats are used by parent callers to do various estimation like map join, aggregate min/max. For dynamic expression stats are returned as null. I think it makes more sense to do what buildColStatForConstant is doing and return an estimation instead of null. I will update the code.", "author": "vineetgarg02", "createdAt": "2020-08-03T23:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MjU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1Njc1Mg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r465356752", "bodyText": "Nevermind, colstats require column name and type name, since both are missing for dynamic param expression it is not possible to create col stats object, i will update the comment as you suggested.", "author": "vineetgarg02", "createdAt": "2020-08-04T22:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3MjU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3NDkxMQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464574911", "bodyText": "Follow-up JIRA?", "author": "jcamachor", "createdAt": "2020-08-03T18:00:21Z", "path": "ql/src/test/queries/clientpositive/prepare_plan.q", "diffHunk": "@@ -0,0 +1,113 @@\n+--! qt:dataset:src\n+--! qt:dataset:alltypesorc\n+\n+set hive.explain.user=false;\n+set hive.vectorized.execution.enabled=false;\n+\n+explain extended prepare pcount from select count(*) from src where key > ?;\n+prepare pcount from select count(*) from src where key > ?;\n+execute pcount using 200;\n+\n+-- single param\n+explain extended prepare p1 from select * from src where key > ? order by key limit 10;\n+prepare p1 from select * from src where key > ? order by key limit 10;\n+\n+execute p1 using 200;\n+\n+-- same query, different param\n+execute p1 using 0;\n+\n+-- same query, negative param\n+--TODO: fails (constant in grammar do not support negatives)\n+-- execute p1 using -1;", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzNDQ3Nw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466534477", "bodyText": "https://issues.apache.org/jira/browse/HIVE-24002", "author": "vineetgarg02", "createdAt": "2020-08-06T16:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3NDkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMzA5NA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464613094", "bodyText": "Should we show the execute statement instead? Or at least both? Otherwise it is difficult to know what is being executed (can be deferred to follow-up).", "author": "jcamachor", "createdAt": "2020-08-03T19:18:56Z", "path": "ql/src/test/results/clientpositive/llap/prepare_plan.q.out", "diffHunk": "@@ -0,0 +1,1575 @@\n+PREHOOK: query: explain extended prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain extended prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+OPTIMIZED SQL: SELECT COUNT(*) AS `$f0`\n+FROM `default`.`src`\n+WHERE `key` > CAST(? AS STRING)\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  GatherStats: false\n+                  Filter Operator\n+                    isSamplingPred: false\n+                    predicate: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          bucketingVersion: 2\n+                          null sort order: \n+                          numBuckets: -1\n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          tag: -1\n+                          value expressions: _col0 (type: bigint)\n+                          auto parallelism: false\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+            Path -> Alias:\n+#### A masked pattern was here ####\n+            Path -> Partition:\n+#### A masked pattern was here ####\n+                Partition\n+                  base file name: src\n+                  input format: org.apache.hadoop.mapred.TextInputFormat\n+                  output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                  properties:\n+                    bucket_count -1\n+                    bucketing_version 2\n+                    column.name.delimiter ,\n+                    columns key,value\n+                    columns.types string:string\n+#### A masked pattern was here ####\n+                    name default.src\n+                    serialization.format 1\n+                    serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                \n+                    input format: org.apache.hadoop.mapred.TextInputFormat\n+                    output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                    properties:\n+                      bucketing_version 2\n+                      column.name.delimiter ,\n+                      columns key,value\n+                      columns.comments 'default','default'\n+                      columns.types string:string\n+#### A masked pattern was here ####\n+                      name default.src\n+                      serialization.format 1\n+                      serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    name: default.src\n+                  name: default.src\n+            Truncated Path -> Alias:\n+              /src [src]\n+        Reducer 2 \n+            Execution mode: llap\n+            Needs Tagging: false\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  bucketingVersion: 2\n+                  compressed: false\n+                  GlobalTableId: 0\n+#### A masked pattern was here ####\n+                  NumFilesPerFileSink: 1\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+#### A masked pattern was here ####\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      properties:\n+                        bucketing_version -1\n+                        columns _col0\n+                        columns.types bigint\n+                        escape.delim \\\n+                        hive.serialization.extend.additional.nesting.levels true\n+                        serialization.escape.crlf true\n+                        serialization.format 1\n+                        serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  TotalFiles: 1\n+                  GatherStats: false\n+                  MultiFileSpray: false\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+378\n+PREHOOK: query: explain extended prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain extended prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+OPTIMIZED SQL: SELECT `key`, `value`\n+FROM `default`.`src`\n+WHERE `key` > CAST(? AS STRING)\n+ORDER BY `key`\n+LIMIT 10\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 89000 Basic stats: COMPLETE Column stats: COMPLETE\n+                  GatherStats: false\n+                  Filter Operator\n+                    isSamplingPred: false\n+                    predicate: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Top N Key Operator\n+                      sort order: +\n+                      keys: key (type: string)\n+                      null sort order: z\n+                      Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                      top n: 10\n+                      Select Operator\n+                        expressions: key (type: string), value (type: string)\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          bucketingVersion: 2\n+                          key expressions: _col0 (type: string)\n+                          null sort order: z\n+                          numBuckets: -1\n+                          sort order: +\n+                          Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                          tag: -1\n+                          value expressions: _col1 (type: string)\n+                          auto parallelism: false\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+            Path -> Alias:\n+#### A masked pattern was here ####\n+            Path -> Partition:\n+#### A masked pattern was here ####\n+                Partition\n+                  base file name: src\n+                  input format: org.apache.hadoop.mapred.TextInputFormat\n+                  output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                  properties:\n+                    bucket_count -1\n+                    bucketing_version 2\n+                    column.name.delimiter ,\n+                    columns key,value\n+                    columns.types string:string\n+#### A masked pattern was here ####\n+                    name default.src\n+                    serialization.format 1\n+                    serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                \n+                    input format: org.apache.hadoop.mapred.TextInputFormat\n+                    output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                    properties:\n+                      bucketing_version 2\n+                      column.name.delimiter ,\n+                      columns key,value\n+                      columns.comments 'default','default'\n+                      columns.types string:string\n+#### A masked pattern was here ####\n+                      name default.src\n+                      serialization.format 1\n+                      serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    name: default.src\n+                  name: default.src\n+            Truncated Path -> Alias:\n+              /src [src]\n+        Reducer 2 \n+            Execution mode: llap\n+            Needs Tagging: false\n+            Reduce Operator Tree:\n+              Select Operator\n+                expressions: KEY.reducesinkkey0 (type: string), VALUE._col0 (type: string)\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                Limit\n+                  Number of rows: 10\n+                  Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    bucketingVersion: 2\n+                    compressed: false\n+                    GlobalTableId: 0\n+#### A masked pattern was here ####\n+                    NumFilesPerFileSink: 1\n+                    Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+#### A masked pattern was here ####\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        properties:\n+                          bucketing_version -1\n+                          columns _col0,_col1\n+                          columns.types string:string\n+                          escape.delim \\\n+                          hive.serialization.extend.additional.nesting.levels true\n+                          serialization.escape.crlf true\n+                          serialization.format 1\n+                          serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    TotalFiles: 1\n+                    GatherStats: false\n+                    MultiFileSpray: false\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: 10\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+201\tval_201\n+202\tval_202\n+203\tval_203\n+203\tval_203\n+205\tval_205\n+205\tval_205\n+207\tval_207\n+207\tval_207\n+208\tval_208\n+208\tval_208\n+PREHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+10\tval_10\n+100\tval_100\n+100\tval_100\n+103\tval_103\n+103\tval_103\n+104\tval_104\n+104\tval_104\n+105\tval_105\n+11\tval_11\n+111\tval_111\n+PREHOOK: query: explain\n+    prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((cint <= Dynamic Parameter  index: 1) and (cbigint <= Dynamic Parameter  index: 2) and (cfloat <> Dynamic Parameter  index: 3)) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 183480 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((cint <= Dynamic Parameter  index: 1) and (cbigint <= Dynamic Parameter  index: 2) and (cfloat <> Dynamic Parameter  index: 3)) (type: boolean)\n+                    Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint)\n+                      outputColumnNames: ctinyint\n+                      Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: avg(ctinyint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9040293\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: struct<count:bigint,sum:double,input:tinyint>)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: avg(VALUE._col0)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 131 Data size: 1444 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: double)\n+                  outputColumnNames: _col1\n+                  Statistics: Num rows: 131 Data size: 1048 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (_col1 < Dynamic Parameter  index: 4) (type: boolean)\n+                    Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: _col1 (type: double)\n+                      outputColumnNames: _col0\n+                      Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                      File Output Operator\n+                        compressed: false\n+                        Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                        table:\n+                            input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                            output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                            serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((cint <= 100) and (cbigint <= 5000000L) and (cfloat <> 0.023)) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 183480 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((cint <= 100) and (cbigint <= 5000000L) and (cfloat <> 0.023)) (type: boolean)\n+                    Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint)\n+                      outputColumnNames: ctinyint\n+                      Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: avg(ctinyint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9040293\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: struct<count:bigint,sum:double,input:tinyint>)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: avg(VALUE._col0)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 131 Data size: 1444 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: double)\n+                  outputColumnNames: _col1\n+                  Statistics: Num rows: 131 Data size: 1048 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (_col1 < 0.0D) (type: boolean)\n+                    Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: _col1 (type: double)\n+                      outputColumnNames: _col0\n+                      Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                      File Output Operator\n+                        compressed: false\n+                        Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                        table:\n+                            input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                            output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                            serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+-51.0\n+PREHOOK: query: explain\n+    prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint = ?  and csmallint != ? group by cint\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint = ?  and csmallint != ? group by cint\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((ctinyint = UDFToByte(Dynamic Parameter  index: 1)) and (csmallint <> UDFToShort(Dynamic Parameter  index: 2))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 110092 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((ctinyint = UDFToByte(Dynamic Parameter  index: 1)) and (csmallint <> UDFToShort(Dynamic Parameter  index: 2))) (type: boolean)\n+                    Statistics: Num rows: 6144 Data size: 55048 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: cint (type: int)\n+                      outputColumnNames: cint\n+                      Statistics: Num rows: 6144 Data size: 55048 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        keys: cint (type: int)\n+                        minReductionHashAggr: 0.49983722\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: int)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: int)\n+                          Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                keys: KEY._col0 (type: int)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: bigint)\n+                  outputColumnNames: _col0\n+                  Statistics: Num rows: 3072 Data size: 24576 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 3072 Data size: 24576 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((ctinyint <= UDFToByte(3Y)) and (csmallint <> UDFToShort(10S))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 110092 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((ctinyint <= UDFToByte(3Y)) and (csmallint <> UDFToShort(10S))) (type: boolean)\n+                    Statistics: Num rows: 4096 Data size: 36708 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: cint (type: int)\n+                      outputColumnNames: cint\n+                      Statistics: Num rows: 4096 Data size: 36708 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        keys: cint (type: int)\n+                        minReductionHashAggr: 0.49975586\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: int)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: int)\n+                          Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                keys: KEY._col0 (type: int)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: bigint)\n+                  outputColumnNames: _col0\n+                  Statistics: Num rows: 2048 Data size: 16384 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 2048 Data size: 16384 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+553\n+547\n+523\n+1665\n+PREHOOK: query: create table tcharvchar(c char(10), v varchar(50)) stored as orc\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: create table tcharvchar(c char(10), v varchar(50)) stored as orc\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@tcharvchar\n+PREHOOK: query: insert into tcharvchar values ('c1', 'v10'), ('c2', 'v100')\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: insert into tcharvchar values ('c1', 'v10'), ('c2', 'v100')\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tcharvchar\n+POSTHOOK: Lineage: tcharvchar.c SCRIPT []\n+POSTHOOK: Lineage: tcharvchar.v SCRIPT []\n+PREHOOK: query: explain prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tcharvchar\n+                  filterExpr: ((c = CAST( Dynamic Parameter  index: 1 AS CHAR(10))) and (v <> CAST( Dynamic Parameter  index: 2 AS varchar(50)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( Dynamic Parameter  index: 1 AS CHAR(10))) and (v <> CAST( Dynamic Parameter  index: 2 AS varchar(50)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tcharvchar\n+                  filterExpr: ((c = CAST( 'c1' AS CHAR(10))) and (v <> CAST( 'v1' AS varchar(50)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( 'c1' AS CHAR(10))) and (v <> CAST( 'v1' AS varchar(50)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+1\n+PREHOOK: query: drop table tcharvchar\n+PREHOOK: type: DROPTABLE\n+PREHOOK: Input: default@tcharvchar\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: drop table tcharvchar\n+POSTHOOK: type: DROPTABLE\n+POSTHOOK: Input: default@tcharvchar\n+POSTHOOK: Output: default@tcharvchar\n+PREHOOK: query: create table tdatets(t timestamp, d date, dc decimal(10,2)) stored as orc\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: create table tdatets(t timestamp, d date, dc decimal(10,2)) stored as orc\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@tdatets\n+PREHOOK: query: insert into tdatets values ( cast('2011-01-01 00:00:00' as timestamp), cast('1919-11-01' as date), 5.00)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: insert into tdatets values ( cast('2011-01-01 00:00:00' as timestamp), cast('1919-11-01' as date), 5.00)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tdatets\n+POSTHOOK: Lineage: tdatets.d SCRIPT []\n+POSTHOOK: Lineage: tdatets.dc SCRIPT []\n+POSTHOOK: Lineage: tdatets.t SCRIPT []\n+PREHOOK: query: insert into tdatets values ( cast('2010-01-01 04:00:00' as timestamp), cast('1918-11-01' as date), 4.00)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: insert into tdatets values ( cast('2010-01-01 04:00:00' as timestamp), cast('1918-11-01' as date), 4.00)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tdatets\n+POSTHOOK: Lineage: tdatets.d SCRIPT []\n+POSTHOOK: Lineage: tdatets.dc SCRIPT []\n+POSTHOOK: Lineage: tdatets.t SCRIPT []\n+PREHOOK: query: explain\n+    prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tdatets\n+                  filterExpr: ((t <> CAST( Dynamic Parameter  index: 1 AS TIMESTAMP)) and (d <> CAST( Dynamic Parameter  index: 2 AS DATE)) and (dc > CAST( Dynamic Parameter  index: 3 AS decimal(10,2)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 416 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((t <> CAST( Dynamic Parameter  index: 1 AS TIMESTAMP)) and (d <> CAST( Dynamic Parameter  index: 2 AS DATE)) and (dc > CAST( Dynamic Parameter  index: 3 AS decimal(10,2)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tdatets\n+                  filterExpr: ((t <> CAST( TIMESTAMP'2012-01-01 00:01:01' AS TIMESTAMP)) and (d <> CAST( DATE'2020-01-01' AS DATE)) and (dc > CAST( 1 AS decimal(10,2)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 416 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((t <> CAST( TIMESTAMP'2012-01-01 00:01:01' AS TIMESTAMP)) and (d <> CAST( DATE'2020-01-01' AS DATE)) and (dc > CAST( 1 AS decimal(10,2)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+2\n+PREHOOK: query: drop table tdatets\n+PREHOOK: type: DROPTABLE\n+PREHOOK: Input: default@tdatets\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: drop table tdatets\n+POSTHOOK: type: DROPTABLE\n+POSTHOOK: Input: default@tdatets\n+POSTHOOK: Output: default@tdatets\n+PREHOOK: query: explain prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: (cint > UDFToInteger(((Dynamic Parameter  index: 1 + Dynamic Parameter  index: 2) + Dynamic Parameter  index: 3))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 146784 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (cint > UDFToInteger(((Dynamic Parameter  index: 1 + Dynamic Parameter  index: 2) + Dynamic Parameter  index: 3))) (type: boolean)\n+                    Statistics: Num rows: 4096 Data size: 48944 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint), cbigint (type: bigint)\n+                      outputColumnNames: ctinyint, cbigint\n+                      Statistics: Num rows: 4096 Data size: 48944 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: min(ctinyint), max(cbigint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9680176\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1, _col2\n+                        Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: tinyint), _col2 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: min(VALUE._col0), max(VALUE._col1)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1, _col2\n+                Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: tinyint), _col2 (type: bigint)\n+                  outputColumnNames: _col0, _col1\n+                  Statistics: Num rows: 131 Data size: 1572 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 131 Data size: 1572 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+-64\tNULL\n+-62\tNULL\n+-58\tNULL\n+-57\tNULL\n+-54\tNULL\n+-50\tNULL\n+-44\tNULL\n+-42\tNULL\n+-39\tNULL\n+-38\tNULL\n+-37\tNULL\n+-36\tNULL\n+-35\tNULL\n+-31\tNULL\n+-29\tNULL\n+-27\tNULL\n+-26\tNULL\n+-24\tNULL\n+-23\tNULL\n+-22\tNULL\n+-18\tNULL\n+-17\tNULL\n+-16\tNULL\n+-14\tNULL\n+-12\tNULL\n+-11\tNULL\n+-10\tNULL\n+-9\tNULL\n+-8\tNULL\n+-6\tNULL\n+-5\tNULL\n+-4\tNULL\n+-3\tNULL\n+-2\tNULL\n+0\tNULL\n+1\tNULL\n+2\tNULL\n+5\tNULL\n+7\tNULL\n+8\t2141237419\n+11\t2145498388\n+13\tNULL\n+17\tNULL\n+19\tNULL\n+21\tNULL\n+22\tNULL\n+25\tNULL\n+26\tNULL\n+28\tNULL\n+29\tNULL\n+32\tNULL\n+33\tNULL\n+36\tNULL\n+43\tNULL\n+44\tNULL\n+45\tNULL\n+47\tNULL\n+50\tNULL\n+51\tNULL\n+53\tNULL\n+54\tNULL\n+55\tNULL\n+56\tNULL\n+57\tNULL\n+58\tNULL\n+59\tNULL\n+60\tNULL\n+61\tNULL\n+-63\tNULL\n+-61\tNULL\n+-60\tNULL\n+-59\tNULL\n+-56\tNULL\n+-55\tNULL\n+-53\tNULL\n+-52\tNULL\n+-51\t2140002067\n+-49\tNULL\n+-48\tNULL\n+-47\tNULL\n+-46\tNULL\n+-45\tNULL\n+-43\tNULL\n+-41\tNULL\n+-40\tNULL\n+-34\tNULL\n+-33\tNULL\n+-32\tNULL\n+-30\tNULL\n+-28\tNULL\n+-25\tNULL\n+-21\tNULL\n+-20\tNULL\n+-19\tNULL\n+-15\tNULL\n+-13\tNULL\n+-7\tNULL\n+-1\tNULL\n+3\tNULL\n+4\tNULL\n+6\tNULL\n+9\tNULL\n+10\tNULL\n+12\tNULL\n+14\tNULL\n+15\tNULL\n+16\tNULL\n+18\tNULL\n+20\tNULL\n+23\tNULL\n+24\tNULL\n+27\tNULL\n+30\tNULL\n+31\tNULL\n+34\tNULL\n+35\tNULL\n+37\tNULL\n+38\tNULL\n+39\tNULL\n+40\tNULL\n+41\tNULL\n+42\tNULL\n+46\tNULL\n+48\tNULL\n+49\tNULL\n+52\tNULL\n+62\tNULL\n+NULL\t1864027286\n+PREHOOK: query: explain prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > concat(CAST( Dynamic Parameter  index: 1 AS STRING), Dynamic Parameter  index: 2)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (key > concat(CAST( Dynamic Parameter  index: 1 AS STRING), Dynamic Parameter  index: 2)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > concat(CAST( '1' AS STRING), '20')) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (key > concat(CAST( '1' AS STRING), '20')) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+474\n+PREHOOK: query: create table daysales (customer int) partitioned by (dt string)\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@daysales\n+POSTHOOK: query: create table daysales (customer int) partitioned by (dt string)\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@daysales\n+PREHOOK: query: insert into daysales partition(dt='2001-01-01') values(1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@daysales@dt=2001-01-01\n+POSTHOOK: query: insert into daysales partition(dt='2001-01-01') values(1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@daysales@dt=2001-01-01\n+POSTHOOK: Lineage: daysales PARTITION(dt=2001-01-01).customer SCRIPT []\n+PREHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: Lineage: daysales PARTITION(dt=2001-01-03).customer SCRIPT []\n+PREHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: Lineage: daysales PARTITION(dt=2001-01-03).customer SCRIPT []\n+PREHOOK: query: explain prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01\n+PREHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@daysales\n+POSTHOOK: Input: default@daysales@dt=2001-01-01\n+POSTHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: daysales\n+                  filterExpr: ((dt = CAST( Dynamic Parameter  index: 1 AS STRING)) and (customer = UDFToInteger(Dynamic Parameter  index: 2))) (type: boolean)\n+                  Statistics: Num rows: 3 Data size: 564 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((dt = CAST( Dynamic Parameter  index: 1 AS STRING)) and (customer = UDFToInteger(Dynamic Parameter  index: 2))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01\n+PREHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@daysales\n+POSTHOOK: Input: default@daysales@dt=2001-01-01\n+POSTHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: daysales\n+                  filterExpr: ((dt = CAST( '2001-01-01' AS STRING)) and (customer = UDFToInteger(1))) (type: boolean)\n+                  Statistics: Num rows: 3 Data size: 564 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((dt = CAST( '2001-01-01' AS STRING)) and (customer = UDFToInteger(1))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01\n+PREHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@daysales\n+POSTHOOK: Input: default@daysales@dt=2001-01-01\n+POSTHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+1\n+PREHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMzYwMA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464713600", "bodyText": "Yes it needs a bit of investigation to figure out how to make it work. I will create follow-up.", "author": "vineetgarg02", "createdAt": "2020-08-03T23:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMzA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2ODk2NA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466568964", "bodyText": "follow-up: https://issues.apache.org/jira/browse/HIVE-24008", "author": "vineetgarg02", "createdAt": "2020-08-06T17:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMzU5Nw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464613597", "bodyText": "From the PREHOOK, it seems partitioning pruning is not done, i.e., this query has a filter on the partition column but both partitions are shown in the hook. Is this remaining work? Should we create a follow-up?", "author": "jcamachor", "createdAt": "2020-08-03T19:20:01Z", "path": "ql/src/test/results/clientpositive/llap/prepare_plan.q.out", "diffHunk": "@@ -0,0 +1,1575 @@\n+PREHOOK: query: explain extended prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain extended prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+OPTIMIZED SQL: SELECT COUNT(*) AS `$f0`\n+FROM `default`.`src`\n+WHERE `key` > CAST(? AS STRING)\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  GatherStats: false\n+                  Filter Operator\n+                    isSamplingPred: false\n+                    predicate: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          bucketingVersion: 2\n+                          null sort order: \n+                          numBuckets: -1\n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          tag: -1\n+                          value expressions: _col0 (type: bigint)\n+                          auto parallelism: false\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+            Path -> Alias:\n+#### A masked pattern was here ####\n+            Path -> Partition:\n+#### A masked pattern was here ####\n+                Partition\n+                  base file name: src\n+                  input format: org.apache.hadoop.mapred.TextInputFormat\n+                  output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                  properties:\n+                    bucket_count -1\n+                    bucketing_version 2\n+                    column.name.delimiter ,\n+                    columns key,value\n+                    columns.types string:string\n+#### A masked pattern was here ####\n+                    name default.src\n+                    serialization.format 1\n+                    serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                \n+                    input format: org.apache.hadoop.mapred.TextInputFormat\n+                    output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                    properties:\n+                      bucketing_version 2\n+                      column.name.delimiter ,\n+                      columns key,value\n+                      columns.comments 'default','default'\n+                      columns.types string:string\n+#### A masked pattern was here ####\n+                      name default.src\n+                      serialization.format 1\n+                      serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    name: default.src\n+                  name: default.src\n+            Truncated Path -> Alias:\n+              /src [src]\n+        Reducer 2 \n+            Execution mode: llap\n+            Needs Tagging: false\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  bucketingVersion: 2\n+                  compressed: false\n+                  GlobalTableId: 0\n+#### A masked pattern was here ####\n+                  NumFilesPerFileSink: 1\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+#### A masked pattern was here ####\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      properties:\n+                        bucketing_version -1\n+                        columns _col0\n+                        columns.types bigint\n+                        escape.delim \\\n+                        hive.serialization.extend.additional.nesting.levels true\n+                        serialization.escape.crlf true\n+                        serialization.format 1\n+                        serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  TotalFiles: 1\n+                  GatherStats: false\n+                  MultiFileSpray: false\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+378\n+PREHOOK: query: explain extended prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain extended prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+OPTIMIZED SQL: SELECT `key`, `value`\n+FROM `default`.`src`\n+WHERE `key` > CAST(? AS STRING)\n+ORDER BY `key`\n+LIMIT 10\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 89000 Basic stats: COMPLETE Column stats: COMPLETE\n+                  GatherStats: false\n+                  Filter Operator\n+                    isSamplingPred: false\n+                    predicate: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Top N Key Operator\n+                      sort order: +\n+                      keys: key (type: string)\n+                      null sort order: z\n+                      Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                      top n: 10\n+                      Select Operator\n+                        expressions: key (type: string), value (type: string)\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          bucketingVersion: 2\n+                          key expressions: _col0 (type: string)\n+                          null sort order: z\n+                          numBuckets: -1\n+                          sort order: +\n+                          Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                          tag: -1\n+                          value expressions: _col1 (type: string)\n+                          auto parallelism: false\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+            Path -> Alias:\n+#### A masked pattern was here ####\n+            Path -> Partition:\n+#### A masked pattern was here ####\n+                Partition\n+                  base file name: src\n+                  input format: org.apache.hadoop.mapred.TextInputFormat\n+                  output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                  properties:\n+                    bucket_count -1\n+                    bucketing_version 2\n+                    column.name.delimiter ,\n+                    columns key,value\n+                    columns.types string:string\n+#### A masked pattern was here ####\n+                    name default.src\n+                    serialization.format 1\n+                    serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                \n+                    input format: org.apache.hadoop.mapred.TextInputFormat\n+                    output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                    properties:\n+                      bucketing_version 2\n+                      column.name.delimiter ,\n+                      columns key,value\n+                      columns.comments 'default','default'\n+                      columns.types string:string\n+#### A masked pattern was here ####\n+                      name default.src\n+                      serialization.format 1\n+                      serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    name: default.src\n+                  name: default.src\n+            Truncated Path -> Alias:\n+              /src [src]\n+        Reducer 2 \n+            Execution mode: llap\n+            Needs Tagging: false\n+            Reduce Operator Tree:\n+              Select Operator\n+                expressions: KEY.reducesinkkey0 (type: string), VALUE._col0 (type: string)\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                Limit\n+                  Number of rows: 10\n+                  Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    bucketingVersion: 2\n+                    compressed: false\n+                    GlobalTableId: 0\n+#### A masked pattern was here ####\n+                    NumFilesPerFileSink: 1\n+                    Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+#### A masked pattern was here ####\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        properties:\n+                          bucketing_version -1\n+                          columns _col0,_col1\n+                          columns.types string:string\n+                          escape.delim \\\n+                          hive.serialization.extend.additional.nesting.levels true\n+                          serialization.escape.crlf true\n+                          serialization.format 1\n+                          serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    TotalFiles: 1\n+                    GatherStats: false\n+                    MultiFileSpray: false\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: 10\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+201\tval_201\n+202\tval_202\n+203\tval_203\n+203\tval_203\n+205\tval_205\n+205\tval_205\n+207\tval_207\n+207\tval_207\n+208\tval_208\n+208\tval_208\n+PREHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+10\tval_10\n+100\tval_100\n+100\tval_100\n+103\tval_103\n+103\tval_103\n+104\tval_104\n+104\tval_104\n+105\tval_105\n+11\tval_11\n+111\tval_111\n+PREHOOK: query: explain\n+    prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((cint <= Dynamic Parameter  index: 1) and (cbigint <= Dynamic Parameter  index: 2) and (cfloat <> Dynamic Parameter  index: 3)) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 183480 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((cint <= Dynamic Parameter  index: 1) and (cbigint <= Dynamic Parameter  index: 2) and (cfloat <> Dynamic Parameter  index: 3)) (type: boolean)\n+                    Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint)\n+                      outputColumnNames: ctinyint\n+                      Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: avg(ctinyint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9040293\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: struct<count:bigint,sum:double,input:tinyint>)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: avg(VALUE._col0)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 131 Data size: 1444 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: double)\n+                  outputColumnNames: _col1\n+                  Statistics: Num rows: 131 Data size: 1048 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (_col1 < Dynamic Parameter  index: 4) (type: boolean)\n+                    Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: _col1 (type: double)\n+                      outputColumnNames: _col0\n+                      Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                      File Output Operator\n+                        compressed: false\n+                        Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                        table:\n+                            input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                            output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                            serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((cint <= 100) and (cbigint <= 5000000L) and (cfloat <> 0.023)) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 183480 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((cint <= 100) and (cbigint <= 5000000L) and (cfloat <> 0.023)) (type: boolean)\n+                    Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint)\n+                      outputColumnNames: ctinyint\n+                      Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: avg(ctinyint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9040293\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: struct<count:bigint,sum:double,input:tinyint>)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: avg(VALUE._col0)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 131 Data size: 1444 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: double)\n+                  outputColumnNames: _col1\n+                  Statistics: Num rows: 131 Data size: 1048 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (_col1 < 0.0D) (type: boolean)\n+                    Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: _col1 (type: double)\n+                      outputColumnNames: _col0\n+                      Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                      File Output Operator\n+                        compressed: false\n+                        Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                        table:\n+                            input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                            output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                            serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+-51.0\n+PREHOOK: query: explain\n+    prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint = ?  and csmallint != ? group by cint\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint = ?  and csmallint != ? group by cint\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((ctinyint = UDFToByte(Dynamic Parameter  index: 1)) and (csmallint <> UDFToShort(Dynamic Parameter  index: 2))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 110092 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((ctinyint = UDFToByte(Dynamic Parameter  index: 1)) and (csmallint <> UDFToShort(Dynamic Parameter  index: 2))) (type: boolean)\n+                    Statistics: Num rows: 6144 Data size: 55048 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: cint (type: int)\n+                      outputColumnNames: cint\n+                      Statistics: Num rows: 6144 Data size: 55048 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        keys: cint (type: int)\n+                        minReductionHashAggr: 0.49983722\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: int)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: int)\n+                          Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                keys: KEY._col0 (type: int)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: bigint)\n+                  outputColumnNames: _col0\n+                  Statistics: Num rows: 3072 Data size: 24576 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 3072 Data size: 24576 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((ctinyint <= UDFToByte(3Y)) and (csmallint <> UDFToShort(10S))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 110092 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((ctinyint <= UDFToByte(3Y)) and (csmallint <> UDFToShort(10S))) (type: boolean)\n+                    Statistics: Num rows: 4096 Data size: 36708 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: cint (type: int)\n+                      outputColumnNames: cint\n+                      Statistics: Num rows: 4096 Data size: 36708 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        keys: cint (type: int)\n+                        minReductionHashAggr: 0.49975586\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: int)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: int)\n+                          Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                keys: KEY._col0 (type: int)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: bigint)\n+                  outputColumnNames: _col0\n+                  Statistics: Num rows: 2048 Data size: 16384 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 2048 Data size: 16384 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+553\n+547\n+523\n+1665\n+PREHOOK: query: create table tcharvchar(c char(10), v varchar(50)) stored as orc\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: create table tcharvchar(c char(10), v varchar(50)) stored as orc\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@tcharvchar\n+PREHOOK: query: insert into tcharvchar values ('c1', 'v10'), ('c2', 'v100')\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: insert into tcharvchar values ('c1', 'v10'), ('c2', 'v100')\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tcharvchar\n+POSTHOOK: Lineage: tcharvchar.c SCRIPT []\n+POSTHOOK: Lineage: tcharvchar.v SCRIPT []\n+PREHOOK: query: explain prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tcharvchar\n+                  filterExpr: ((c = CAST( Dynamic Parameter  index: 1 AS CHAR(10))) and (v <> CAST( Dynamic Parameter  index: 2 AS varchar(50)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( Dynamic Parameter  index: 1 AS CHAR(10))) and (v <> CAST( Dynamic Parameter  index: 2 AS varchar(50)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tcharvchar\n+                  filterExpr: ((c = CAST( 'c1' AS CHAR(10))) and (v <> CAST( 'v1' AS varchar(50)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( 'c1' AS CHAR(10))) and (v <> CAST( 'v1' AS varchar(50)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+1\n+PREHOOK: query: drop table tcharvchar\n+PREHOOK: type: DROPTABLE\n+PREHOOK: Input: default@tcharvchar\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: drop table tcharvchar\n+POSTHOOK: type: DROPTABLE\n+POSTHOOK: Input: default@tcharvchar\n+POSTHOOK: Output: default@tcharvchar\n+PREHOOK: query: create table tdatets(t timestamp, d date, dc decimal(10,2)) stored as orc\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: create table tdatets(t timestamp, d date, dc decimal(10,2)) stored as orc\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@tdatets\n+PREHOOK: query: insert into tdatets values ( cast('2011-01-01 00:00:00' as timestamp), cast('1919-11-01' as date), 5.00)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: insert into tdatets values ( cast('2011-01-01 00:00:00' as timestamp), cast('1919-11-01' as date), 5.00)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tdatets\n+POSTHOOK: Lineage: tdatets.d SCRIPT []\n+POSTHOOK: Lineage: tdatets.dc SCRIPT []\n+POSTHOOK: Lineage: tdatets.t SCRIPT []\n+PREHOOK: query: insert into tdatets values ( cast('2010-01-01 04:00:00' as timestamp), cast('1918-11-01' as date), 4.00)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: insert into tdatets values ( cast('2010-01-01 04:00:00' as timestamp), cast('1918-11-01' as date), 4.00)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tdatets\n+POSTHOOK: Lineage: tdatets.d SCRIPT []\n+POSTHOOK: Lineage: tdatets.dc SCRIPT []\n+POSTHOOK: Lineage: tdatets.t SCRIPT []\n+PREHOOK: query: explain\n+    prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tdatets\n+                  filterExpr: ((t <> CAST( Dynamic Parameter  index: 1 AS TIMESTAMP)) and (d <> CAST( Dynamic Parameter  index: 2 AS DATE)) and (dc > CAST( Dynamic Parameter  index: 3 AS decimal(10,2)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 416 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((t <> CAST( Dynamic Parameter  index: 1 AS TIMESTAMP)) and (d <> CAST( Dynamic Parameter  index: 2 AS DATE)) and (dc > CAST( Dynamic Parameter  index: 3 AS decimal(10,2)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tdatets\n+                  filterExpr: ((t <> CAST( TIMESTAMP'2012-01-01 00:01:01' AS TIMESTAMP)) and (d <> CAST( DATE'2020-01-01' AS DATE)) and (dc > CAST( 1 AS decimal(10,2)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 416 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((t <> CAST( TIMESTAMP'2012-01-01 00:01:01' AS TIMESTAMP)) and (d <> CAST( DATE'2020-01-01' AS DATE)) and (dc > CAST( 1 AS decimal(10,2)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+2\n+PREHOOK: query: drop table tdatets\n+PREHOOK: type: DROPTABLE\n+PREHOOK: Input: default@tdatets\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: drop table tdatets\n+POSTHOOK: type: DROPTABLE\n+POSTHOOK: Input: default@tdatets\n+POSTHOOK: Output: default@tdatets\n+PREHOOK: query: explain prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: (cint > UDFToInteger(((Dynamic Parameter  index: 1 + Dynamic Parameter  index: 2) + Dynamic Parameter  index: 3))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 146784 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (cint > UDFToInteger(((Dynamic Parameter  index: 1 + Dynamic Parameter  index: 2) + Dynamic Parameter  index: 3))) (type: boolean)\n+                    Statistics: Num rows: 4096 Data size: 48944 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint), cbigint (type: bigint)\n+                      outputColumnNames: ctinyint, cbigint\n+                      Statistics: Num rows: 4096 Data size: 48944 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: min(ctinyint), max(cbigint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9680176\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1, _col2\n+                        Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: tinyint), _col2 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: min(VALUE._col0), max(VALUE._col1)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1, _col2\n+                Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: tinyint), _col2 (type: bigint)\n+                  outputColumnNames: _col0, _col1\n+                  Statistics: Num rows: 131 Data size: 1572 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 131 Data size: 1572 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+-64\tNULL\n+-62\tNULL\n+-58\tNULL\n+-57\tNULL\n+-54\tNULL\n+-50\tNULL\n+-44\tNULL\n+-42\tNULL\n+-39\tNULL\n+-38\tNULL\n+-37\tNULL\n+-36\tNULL\n+-35\tNULL\n+-31\tNULL\n+-29\tNULL\n+-27\tNULL\n+-26\tNULL\n+-24\tNULL\n+-23\tNULL\n+-22\tNULL\n+-18\tNULL\n+-17\tNULL\n+-16\tNULL\n+-14\tNULL\n+-12\tNULL\n+-11\tNULL\n+-10\tNULL\n+-9\tNULL\n+-8\tNULL\n+-6\tNULL\n+-5\tNULL\n+-4\tNULL\n+-3\tNULL\n+-2\tNULL\n+0\tNULL\n+1\tNULL\n+2\tNULL\n+5\tNULL\n+7\tNULL\n+8\t2141237419\n+11\t2145498388\n+13\tNULL\n+17\tNULL\n+19\tNULL\n+21\tNULL\n+22\tNULL\n+25\tNULL\n+26\tNULL\n+28\tNULL\n+29\tNULL\n+32\tNULL\n+33\tNULL\n+36\tNULL\n+43\tNULL\n+44\tNULL\n+45\tNULL\n+47\tNULL\n+50\tNULL\n+51\tNULL\n+53\tNULL\n+54\tNULL\n+55\tNULL\n+56\tNULL\n+57\tNULL\n+58\tNULL\n+59\tNULL\n+60\tNULL\n+61\tNULL\n+-63\tNULL\n+-61\tNULL\n+-60\tNULL\n+-59\tNULL\n+-56\tNULL\n+-55\tNULL\n+-53\tNULL\n+-52\tNULL\n+-51\t2140002067\n+-49\tNULL\n+-48\tNULL\n+-47\tNULL\n+-46\tNULL\n+-45\tNULL\n+-43\tNULL\n+-41\tNULL\n+-40\tNULL\n+-34\tNULL\n+-33\tNULL\n+-32\tNULL\n+-30\tNULL\n+-28\tNULL\n+-25\tNULL\n+-21\tNULL\n+-20\tNULL\n+-19\tNULL\n+-15\tNULL\n+-13\tNULL\n+-7\tNULL\n+-1\tNULL\n+3\tNULL\n+4\tNULL\n+6\tNULL\n+9\tNULL\n+10\tNULL\n+12\tNULL\n+14\tNULL\n+15\tNULL\n+16\tNULL\n+18\tNULL\n+20\tNULL\n+23\tNULL\n+24\tNULL\n+27\tNULL\n+30\tNULL\n+31\tNULL\n+34\tNULL\n+35\tNULL\n+37\tNULL\n+38\tNULL\n+39\tNULL\n+40\tNULL\n+41\tNULL\n+42\tNULL\n+46\tNULL\n+48\tNULL\n+49\tNULL\n+52\tNULL\n+62\tNULL\n+NULL\t1864027286\n+PREHOOK: query: explain prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > concat(CAST( Dynamic Parameter  index: 1 AS STRING), Dynamic Parameter  index: 2)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (key > concat(CAST( Dynamic Parameter  index: 1 AS STRING), Dynamic Parameter  index: 2)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > concat(CAST( '1' AS STRING), '20')) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (key > concat(CAST( '1' AS STRING), '20')) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+474\n+PREHOOK: query: create table daysales (customer int) partitioned by (dt string)\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@daysales\n+POSTHOOK: query: create table daysales (customer int) partitioned by (dt string)\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@daysales\n+PREHOOK: query: insert into daysales partition(dt='2001-01-01') values(1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@daysales@dt=2001-01-01\n+POSTHOOK: query: insert into daysales partition(dt='2001-01-01') values(1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@daysales@dt=2001-01-01\n+POSTHOOK: Lineage: daysales PARTITION(dt=2001-01-01).customer SCRIPT []\n+PREHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: Lineage: daysales PARTITION(dt=2001-01-03).customer SCRIPT []\n+PREHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: Lineage: daysales PARTITION(dt=2001-01-03).customer SCRIPT []\n+PREHOOK: query: explain prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01\n+PREHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@daysales\n+POSTHOOK: Input: default@daysales@dt=2001-01-01\n+POSTHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: daysales\n+                  filterExpr: ((dt = CAST( Dynamic Parameter  index: 1 AS STRING)) and (customer = UDFToInteger(Dynamic Parameter  index: 2))) (type: boolean)\n+                  Statistics: Num rows: 3 Data size: 564 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((dt = CAST( Dynamic Parameter  index: 1 AS STRING)) and (customer = UDFToInteger(Dynamic Parameter  index: 2))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01\n+PREHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@daysales\n+POSTHOOK: Input: default@daysales@dt=2001-01-01\n+POSTHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: daysales\n+                  filterExpr: ((dt = CAST( '2001-01-01' AS STRING)) and (customer = UDFToInteger(1))) (type: boolean)\n+                  Statistics: Num rows: 3 Data size: 564 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((dt = CAST( '2001-01-01' AS STRING)) and (customer = UDFToInteger(1))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMDI5MQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464710291", "bodyText": "Yes partition pruning and other physical optimizations (especially stats based) don't work. This requires some work to support running these transformations/optimizations on the plan/tasks after binding parameters. I will create a follow-up.", "author": "vineetgarg02", "createdAt": "2020-08-03T23:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMzU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MDg4Mg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466570882", "bodyText": "Follow-up: https://issues.apache.org/jira/browse/HIVE-24009", "author": "vineetgarg02", "createdAt": "2020-08-06T17:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMzU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxNDAwOA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464614008", "bodyText": "Add order by to get consistent order.", "author": "jcamachor", "createdAt": "2020-08-03T19:20:56Z", "path": "ql/src/test/results/clientpositive/llap/prepare_plan.q.out", "diffHunk": "@@ -0,0 +1,1575 @@\n+PREHOOK: query: explain extended prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain extended prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+OPTIMIZED SQL: SELECT COUNT(*) AS `$f0`\n+FROM `default`.`src`\n+WHERE `key` > CAST(? AS STRING)\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  GatherStats: false\n+                  Filter Operator\n+                    isSamplingPred: false\n+                    predicate: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          bucketingVersion: 2\n+                          null sort order: \n+                          numBuckets: -1\n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          tag: -1\n+                          value expressions: _col0 (type: bigint)\n+                          auto parallelism: false\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+            Path -> Alias:\n+#### A masked pattern was here ####\n+            Path -> Partition:\n+#### A masked pattern was here ####\n+                Partition\n+                  base file name: src\n+                  input format: org.apache.hadoop.mapred.TextInputFormat\n+                  output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                  properties:\n+                    bucket_count -1\n+                    bucketing_version 2\n+                    column.name.delimiter ,\n+                    columns key,value\n+                    columns.types string:string\n+#### A masked pattern was here ####\n+                    name default.src\n+                    serialization.format 1\n+                    serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                \n+                    input format: org.apache.hadoop.mapred.TextInputFormat\n+                    output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                    properties:\n+                      bucketing_version 2\n+                      column.name.delimiter ,\n+                      columns key,value\n+                      columns.comments 'default','default'\n+                      columns.types string:string\n+#### A masked pattern was here ####\n+                      name default.src\n+                      serialization.format 1\n+                      serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    name: default.src\n+                  name: default.src\n+            Truncated Path -> Alias:\n+              /src [src]\n+        Reducer 2 \n+            Execution mode: llap\n+            Needs Tagging: false\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  bucketingVersion: 2\n+                  compressed: false\n+                  GlobalTableId: 0\n+#### A masked pattern was here ####\n+                  NumFilesPerFileSink: 1\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+#### A masked pattern was here ####\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      properties:\n+                        bucketing_version -1\n+                        columns _col0\n+                        columns.types bigint\n+                        escape.delim \\\n+                        hive.serialization.extend.additional.nesting.levels true\n+                        serialization.escape.crlf true\n+                        serialization.format 1\n+                        serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  TotalFiles: 1\n+                  GatherStats: false\n+                  MultiFileSpray: false\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+378\n+PREHOOK: query: explain extended prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain extended prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+OPTIMIZED SQL: SELECT `key`, `value`\n+FROM `default`.`src`\n+WHERE `key` > CAST(? AS STRING)\n+ORDER BY `key`\n+LIMIT 10\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 89000 Basic stats: COMPLETE Column stats: COMPLETE\n+                  GatherStats: false\n+                  Filter Operator\n+                    isSamplingPred: false\n+                    predicate: (key > CAST( Dynamic Parameter  index: 1 AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Top N Key Operator\n+                      sort order: +\n+                      keys: key (type: string)\n+                      null sort order: z\n+                      Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                      top n: 10\n+                      Select Operator\n+                        expressions: key (type: string), value (type: string)\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          bucketingVersion: 2\n+                          key expressions: _col0 (type: string)\n+                          null sort order: z\n+                          numBuckets: -1\n+                          sort order: +\n+                          Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                          tag: -1\n+                          value expressions: _col1 (type: string)\n+                          auto parallelism: false\n+            Execution mode: llap\n+            LLAP IO: no inputs\n+            Path -> Alias:\n+#### A masked pattern was here ####\n+            Path -> Partition:\n+#### A masked pattern was here ####\n+                Partition\n+                  base file name: src\n+                  input format: org.apache.hadoop.mapred.TextInputFormat\n+                  output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                  properties:\n+                    bucket_count -1\n+                    bucketing_version 2\n+                    column.name.delimiter ,\n+                    columns key,value\n+                    columns.types string:string\n+#### A masked pattern was here ####\n+                    name default.src\n+                    serialization.format 1\n+                    serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                \n+                    input format: org.apache.hadoop.mapred.TextInputFormat\n+                    output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                    properties:\n+                      bucketing_version 2\n+                      column.name.delimiter ,\n+                      columns key,value\n+                      columns.comments 'default','default'\n+                      columns.types string:string\n+#### A masked pattern was here ####\n+                      name default.src\n+                      serialization.format 1\n+                      serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    name: default.src\n+                  name: default.src\n+            Truncated Path -> Alias:\n+              /src [src]\n+        Reducer 2 \n+            Execution mode: llap\n+            Needs Tagging: false\n+            Reduce Operator Tree:\n+              Select Operator\n+                expressions: KEY.reducesinkkey0 (type: string), VALUE._col0 (type: string)\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                Limit\n+                  Number of rows: 10\n+                  Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    bucketingVersion: 2\n+                    compressed: false\n+                    GlobalTableId: 0\n+#### A masked pattern was here ####\n+                    NumFilesPerFileSink: 1\n+                    Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+#### A masked pattern was here ####\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        properties:\n+                          bucketing_version -1\n+                          columns _col0,_col1\n+                          columns.types string:string\n+                          escape.delim \\\n+                          hive.serialization.extend.additional.nesting.levels true\n+                          serialization.escape.crlf true\n+                          serialization.format 1\n+                          serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    TotalFiles: 1\n+                    GatherStats: false\n+                    MultiFileSpray: false\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: 10\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+201\tval_201\n+202\tval_202\n+203\tval_203\n+203\tval_203\n+205\tval_205\n+205\tval_205\n+207\tval_207\n+207\tval_207\n+208\tval_208\n+208\tval_208\n+PREHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+10\tval_10\n+100\tval_100\n+100\tval_100\n+103\tval_103\n+103\tval_103\n+104\tval_104\n+104\tval_104\n+105\tval_105\n+11\tval_11\n+111\tval_111\n+PREHOOK: query: explain\n+    prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((cint <= Dynamic Parameter  index: 1) and (cbigint <= Dynamic Parameter  index: 2) and (cfloat <> Dynamic Parameter  index: 3)) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 183480 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((cint <= Dynamic Parameter  index: 1) and (cbigint <= Dynamic Parameter  index: 2) and (cfloat <> Dynamic Parameter  index: 3)) (type: boolean)\n+                    Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint)\n+                      outputColumnNames: ctinyint\n+                      Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: avg(ctinyint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9040293\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: struct<count:bigint,sum:double,input:tinyint>)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: avg(VALUE._col0)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 131 Data size: 1444 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: double)\n+                  outputColumnNames: _col1\n+                  Statistics: Num rows: 131 Data size: 1048 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (_col1 < Dynamic Parameter  index: 4) (type: boolean)\n+                    Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: _col1 (type: double)\n+                      outputColumnNames: _col0\n+                      Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                      File Output Operator\n+                        compressed: false\n+                        Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                        table:\n+                            input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                            output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                            serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((cint <= 100) and (cbigint <= 5000000L) and (cfloat <> 0.023)) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 183480 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((cint <= 100) and (cbigint <= 5000000L) and (cfloat <> 0.023)) (type: boolean)\n+                    Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint)\n+                      outputColumnNames: ctinyint\n+                      Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: avg(ctinyint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9040293\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: struct<count:bigint,sum:double,input:tinyint>)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: avg(VALUE._col0)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 131 Data size: 1444 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: double)\n+                  outputColumnNames: _col1\n+                  Statistics: Num rows: 131 Data size: 1048 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (_col1 < 0.0D) (type: boolean)\n+                    Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: _col1 (type: double)\n+                      outputColumnNames: _col0\n+                      Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                      File Output Operator\n+                        compressed: false\n+                        Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                        table:\n+                            input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                            output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                            serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+-51.0\n+PREHOOK: query: explain\n+    prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint = ?  and csmallint != ? group by cint\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint = ?  and csmallint != ? group by cint\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((ctinyint = UDFToByte(Dynamic Parameter  index: 1)) and (csmallint <> UDFToShort(Dynamic Parameter  index: 2))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 110092 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((ctinyint = UDFToByte(Dynamic Parameter  index: 1)) and (csmallint <> UDFToShort(Dynamic Parameter  index: 2))) (type: boolean)\n+                    Statistics: Num rows: 6144 Data size: 55048 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: cint (type: int)\n+                      outputColumnNames: cint\n+                      Statistics: Num rows: 6144 Data size: 55048 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        keys: cint (type: int)\n+                        minReductionHashAggr: 0.49983722\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: int)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: int)\n+                          Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                keys: KEY._col0 (type: int)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: bigint)\n+                  outputColumnNames: _col0\n+                  Statistics: Num rows: 3072 Data size: 24576 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 3072 Data size: 24576 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((ctinyint <= UDFToByte(3Y)) and (csmallint <> UDFToShort(10S))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 110092 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((ctinyint <= UDFToByte(3Y)) and (csmallint <> UDFToShort(10S))) (type: boolean)\n+                    Statistics: Num rows: 4096 Data size: 36708 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: cint (type: int)\n+                      outputColumnNames: cint\n+                      Statistics: Num rows: 4096 Data size: 36708 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        keys: cint (type: int)\n+                        minReductionHashAggr: 0.49975586\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: int)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: int)\n+                          Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                keys: KEY._col0 (type: int)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: bigint)\n+                  outputColumnNames: _col0\n+                  Statistics: Num rows: 2048 Data size: 16384 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 2048 Data size: 16384 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+553\n+547\n+523\n+1665\n+PREHOOK: query: create table tcharvchar(c char(10), v varchar(50)) stored as orc\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: create table tcharvchar(c char(10), v varchar(50)) stored as orc\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@tcharvchar\n+PREHOOK: query: insert into tcharvchar values ('c1', 'v10'), ('c2', 'v100')\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: insert into tcharvchar values ('c1', 'v10'), ('c2', 'v100')\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tcharvchar\n+POSTHOOK: Lineage: tcharvchar.c SCRIPT []\n+POSTHOOK: Lineage: tcharvchar.v SCRIPT []\n+PREHOOK: query: explain prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tcharvchar\n+                  filterExpr: ((c = CAST( Dynamic Parameter  index: 1 AS CHAR(10))) and (v <> CAST( Dynamic Parameter  index: 2 AS varchar(50)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( Dynamic Parameter  index: 1 AS CHAR(10))) and (v <> CAST( Dynamic Parameter  index: 2 AS varchar(50)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tcharvchar\n+                  filterExpr: ((c = CAST( 'c1' AS CHAR(10))) and (v <> CAST( 'v1' AS varchar(50)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( 'c1' AS CHAR(10))) and (v <> CAST( 'v1' AS varchar(50)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+1\n+PREHOOK: query: drop table tcharvchar\n+PREHOOK: type: DROPTABLE\n+PREHOOK: Input: default@tcharvchar\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: drop table tcharvchar\n+POSTHOOK: type: DROPTABLE\n+POSTHOOK: Input: default@tcharvchar\n+POSTHOOK: Output: default@tcharvchar\n+PREHOOK: query: create table tdatets(t timestamp, d date, dc decimal(10,2)) stored as orc\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: create table tdatets(t timestamp, d date, dc decimal(10,2)) stored as orc\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@tdatets\n+PREHOOK: query: insert into tdatets values ( cast('2011-01-01 00:00:00' as timestamp), cast('1919-11-01' as date), 5.00)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: insert into tdatets values ( cast('2011-01-01 00:00:00' as timestamp), cast('1919-11-01' as date), 5.00)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tdatets\n+POSTHOOK: Lineage: tdatets.d SCRIPT []\n+POSTHOOK: Lineage: tdatets.dc SCRIPT []\n+POSTHOOK: Lineage: tdatets.t SCRIPT []\n+PREHOOK: query: insert into tdatets values ( cast('2010-01-01 04:00:00' as timestamp), cast('1918-11-01' as date), 4.00)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: insert into tdatets values ( cast('2010-01-01 04:00:00' as timestamp), cast('1918-11-01' as date), 4.00)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tdatets\n+POSTHOOK: Lineage: tdatets.d SCRIPT []\n+POSTHOOK: Lineage: tdatets.dc SCRIPT []\n+POSTHOOK: Lineage: tdatets.t SCRIPT []\n+PREHOOK: query: explain\n+    prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tdatets\n+                  filterExpr: ((t <> CAST( Dynamic Parameter  index: 1 AS TIMESTAMP)) and (d <> CAST( Dynamic Parameter  index: 2 AS DATE)) and (dc > CAST( Dynamic Parameter  index: 3 AS decimal(10,2)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 416 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((t <> CAST( Dynamic Parameter  index: 1 AS TIMESTAMP)) and (d <> CAST( Dynamic Parameter  index: 2 AS DATE)) and (dc > CAST( Dynamic Parameter  index: 3 AS decimal(10,2)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tdatets\n+                  filterExpr: ((t <> CAST( TIMESTAMP'2012-01-01 00:01:01' AS TIMESTAMP)) and (d <> CAST( DATE'2020-01-01' AS DATE)) and (dc > CAST( 1 AS decimal(10,2)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 416 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((t <> CAST( TIMESTAMP'2012-01-01 00:01:01' AS TIMESTAMP)) and (d <> CAST( DATE'2020-01-01' AS DATE)) and (dc > CAST( 1 AS decimal(10,2)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+2\n+PREHOOK: query: drop table tdatets\n+PREHOOK: type: DROPTABLE\n+PREHOOK: Input: default@tdatets\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: drop table tdatets\n+POSTHOOK: type: DROPTABLE\n+POSTHOOK: Input: default@tdatets\n+POSTHOOK: Output: default@tdatets\n+PREHOOK: query: explain prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: (cint > UDFToInteger(((Dynamic Parameter  index: 1 + Dynamic Parameter  index: 2) + Dynamic Parameter  index: 3))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 146784 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (cint > UDFToInteger(((Dynamic Parameter  index: 1 + Dynamic Parameter  index: 2) + Dynamic Parameter  index: 3))) (type: boolean)\n+                    Statistics: Num rows: 4096 Data size: 48944 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint), cbigint (type: bigint)\n+                      outputColumnNames: ctinyint, cbigint\n+                      Statistics: Num rows: 4096 Data size: 48944 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: min(ctinyint), max(cbigint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9680176\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1, _col2\n+                        Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: tinyint), _col2 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: min(VALUE._col0), max(VALUE._col1)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1, _col2\n+                Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: tinyint), _col2 (type: bigint)\n+                  outputColumnNames: _col0, _col1\n+                  Statistics: Num rows: 131 Data size: 1572 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 131 Data size: 1572 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+-64\tNULL", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxNTA1MQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464615051", "bodyText": "nit. outdated comment?", "author": "jcamachor", "createdAt": "2020-08-03T19:23:13Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/plan/ExprDynamicParamDesc.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.plan;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.hadoop.hive.common.StringInternUtils;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.objectinspector.ConstantObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;\n+import org.apache.hadoop.hive.serde2.typeinfo.BaseCharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.StructTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoUtils;\n+\n+/**\n+ * A constant expression.", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxOTIxNA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464619214", "bodyText": "I was thinking we could use something more compact for the string representation in the plan -> \":\" + index. What do you think?", "author": "jcamachor", "createdAt": "2020-08-03T19:32:24Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/plan/ExprDynamicParamDesc.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.plan;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.hadoop.hive.common.StringInternUtils;\n+import org.apache.hadoop.hive.serde.serdeConstants;\n+import org.apache.hadoop.hive.serde2.objectinspector.ConstantObjectInspector;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category;\n+import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorUtils;\n+import org.apache.hadoop.hive.serde2.typeinfo.BaseCharTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.StructTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoUtils;\n+\n+/**\n+ * A constant expression.\n+ */\n+public class ExprDynamicParamDesc extends ExprNodeDesc implements Serializable {\n+  private static final long serialVersionUID = 1L;\n+  final protected transient static char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n+\n+  private int index;\n+  private Object value;\n+\n+  public ExprDynamicParamDesc() {\n+  }\n+\n+  public ExprDynamicParamDesc(TypeInfo typeInfo, int index, Object value) {\n+    super(typeInfo);\n+    this.index =  index;\n+    this.value = value;\n+  }\n+\n+  public Object getValue() {\n+    return value;\n+  }\n+\n+  public int getIndex() {\n+    return index;\n+  }\n+\n+\n+  @Override\n+  public String toString() {\n+    return \"Dynamic Parameter \" + \" index: \" + index;", "originalCommit": "8d580d27dcbe34622721ec4963400656a8cfe1f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwOTE3Nw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464709177", "bodyText": "\"Dynamic Parameter\" makes it clear that the expression in an explain plan is dynamic expression. Just showing index will make it hard to read.\nWhat is the benefit of making it more compact?", "author": "vineetgarg02", "createdAt": "2020-08-03T23:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxOTIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjc1NA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r464712754", "bodyText": "I just think that using \":\" + index, \"$\" + index, or any other simpler variants, will make the plans more readable rather than having the dynamic parameter index: idx interleaved in the middle of complex expressions. What do other RDBMSs show, e.g., Postgres or MySQL?\nMaybe we could have different variants for user vs normal explain plans.", "author": "jcamachor", "createdAt": "2020-08-03T23:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxOTIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0OTY3OQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r465349679", "bodyText": "Ok let me update it to $<idx for now. I am not sure what other databases use. I will try to figure out.", "author": "vineetgarg02", "createdAt": "2020-08-04T21:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxOTIxNA=="}], "type": "inlineReview"}, {"oid": "e312d161533d83c8cb226ff7e6586b78102b7c6c", "url": "https://github.com/apache/hive/commit/e312d161533d83c8cb226ff7e6586b78102b7c6c", "message": "addressing review comments", "committedDate": "2020-08-04T22:19:58Z", "type": "commit"}, {"oid": "dd42f72215137c84ed5ffb45791d61492e9a7824", "url": "https://github.com/apache/hive/commit/dd42f72215137c84ed5ffb45791d61492e9a7824", "message": "Merge remote-tracking branch 'upstream/master' into PREPARE_EXECUTE_SUPPORT", "committedDate": "2020-08-04T22:20:29Z", "type": "commit"}, {"oid": "41d17e05c6dbacc283379a3b893661678bf1eb4e", "url": "https://github.com/apache/hive/commit/41d17e05c6dbacc283379a3b893661678bf1eb4e", "message": "fixing test issue", "committedDate": "2020-08-05T16:21:24Z", "type": "commit"}, {"oid": "a2b2eb0a70a794228b866d19a8b4d781d6e8f370", "url": "https://github.com/apache/hive/commit/a2b2eb0a70a794228b866d19a8b4d781d6e8f370", "message": "Test fixes", "committedDate": "2020-08-05T16:52:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTE4Nw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466085187", "bodyText": "getIsPrepareQuery -> isPrepareQuery", "author": "jcamachor", "createdAt": "2020-08-06T01:00:51Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/Compiler.java", "diffHunk": "@@ -338,12 +339,22 @@ private QueryPlan createPlan(BaseSemanticAnalyzer sem) {\n     plan.setOptimizedCBOPlan(context.getCalcitePlan());\n     plan.setOptimizedQueryString(context.getOptimizedSql());\n \n+    // this is required so that later driver can skip executing prepare queries\n+    if (sem.getIsPrepareQuery()) {", "originalCommit": "a2b2eb0a70a794228b866d19a8b4d781d6e8f370", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTUzNw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466085537", "bodyText": "It seems this should be a boolean given the return type of the methods getter/setter.", "author": "jcamachor", "createdAt": "2020-08-06T01:02:26Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/QueryPlan.java", "diffHunk": "@@ -121,6 +121,8 @@\n   private final DDLDescWithWriteId acidDdlDesc;\n   private Boolean autoCommitValue;\n \n+  private Boolean prepareQuery;", "originalCommit": "a2b2eb0a70a794228b866d19a8b4d781d6e8f370", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NjAxOA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466086018", "bodyText": "Code commented out.", "author": "jcamachor", "createdAt": "2020-08-06T01:04:24Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/ExecuteStatementAnalyzer.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.parse;\n+\n+import org.apache.hadoop.hive.ql.QueryState;\n+import org.apache.hadoop.hive.ql.ddl.DDLSemanticAnalyzerFactory.DDLType;\n+import org.apache.hadoop.hive.ql.exec.ExplainTask;\n+import org.apache.hadoop.hive.ql.exec.FetchTask;\n+import org.apache.hadoop.hive.ql.exec.FilterOperator;\n+import org.apache.hadoop.hive.ql.exec.Operator;\n+import org.apache.hadoop.hive.ql.exec.OperatorUtils;\n+import org.apache.hadoop.hive.ql.exec.SerializationUtilities;\n+import org.apache.hadoop.hive.ql.exec.Task;\n+import org.apache.hadoop.hive.ql.exec.Utilities;\n+import org.apache.hadoop.hive.ql.exec.tez.TezTask;\n+import org.apache.hadoop.hive.ql.parse.type.ExprNodeTypeCheck;\n+import org.apache.hadoop.hive.ql.parse.type.TypeCheckCtx;\n+import org.apache.hadoop.hive.ql.plan.BaseWork;\n+import org.apache.hadoop.hive.ql.plan.ExprDynamicParamDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeConstantDesc;\n+import org.apache.hadoop.hive.ql.plan.ExprNodeDesc;\n+import org.apache.hadoop.hive.ql.session.SessionState;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\n+import org.apache.parquet.Preconditions;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Analyzer for Execute statement.\n+ * This analyzer\n+ *  retrieves cached {@link BaseSemanticAnalyzer},\n+ *  makes copy of all tasks by serializing/deserializing it,\n+ *  bind dynamic parameters inside cached {@link BaseSemanticAnalyzer} using values provided\n+ */\n+@DDLType(types = HiveParser.TOK_EXECUTE)\n+public class ExecuteStatementAnalyzer extends BaseSemanticAnalyzer {\n+\n+  public ExecuteStatementAnalyzer(QueryState queryState) throws SemanticException {\n+    super(queryState);\n+  }\n+\n+  /**\n+   * This class encapsulate all {@link Task} required to be copied.\n+   * This is required because {@link FetchTask} list of {@link Task} may hold reference to same\n+   * objects (e.g. list of result files) and are required to be serialized/de-serialized together.\n+   */\n+  private class PlanCopy {\n+    FetchTask fetchTask;\n+    List<Task<?>> tasks;\n+\n+    PlanCopy(FetchTask fetchTask, List<Task<?>> tasks) {\n+      this.fetchTask = fetchTask;\n+      this.tasks = tasks;\n+    }\n+\n+    FetchTask getFetchTask() {\n+      return fetchTask;\n+    }\n+\n+    List<Task<?>> getTasks()  {\n+      return tasks;\n+    }\n+  }\n+\n+  private String getQueryName(ASTNode root) {\n+    ASTNode queryNameAST = (ASTNode)(root.getChild(1));\n+    return queryNameAST.getText();\n+  }\n+\n+  /**\n+   * Utility method to create copy of provided object using kryo serialization/de-serialization.\n+   */\n+  private <T> T makeCopy(final Object task, Class<T> objClass) {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    SerializationUtilities.serializePlan(task, baos);\n+\n+    return SerializationUtilities.deserializePlan(\n+        new ByteArrayInputStream(baos.toByteArray()), objClass);\n+  }\n+\n+  /**\n+   * Given a {@link BaseSemanticAnalyzer} (cached) this method make copies of all tasks\n+   * (including {@link FetchTask}) and update the existing {@link ExecuteStatementAnalyzer}\n+   */\n+  private void createTaskCopy(final BaseSemanticAnalyzer cachedPlan) {\n+    PlanCopy planCopy = new PlanCopy(cachedPlan.getFetchTask(), cachedPlan.getAllRootTasks());\n+    planCopy = makeCopy(planCopy, planCopy.getClass());\n+    this.setFetchTask(planCopy.getFetchTask());\n+    this.rootTasks = planCopy.getTasks();\n+  }\n+\n+  private String getParamLiteralValue(Map<Integer, ASTNode> paramMap, int paramIndex) {\n+    Preconditions.checkArgument(paramMap.containsKey(paramIndex), \"Index not found.\");\n+    ASTNode node = paramMap.get(paramIndex);\n+\n+    if (node.getType() == HiveParser.StringLiteral) {\n+      // remove quotes\n+      return BaseSemanticAnalyzer.unescapeSQLString(node.getText());\n+\n+    } else {\n+      return node.getText();\n+    }\n+  }\n+\n+\n+  /**\n+   * This method creates a constant expression to replace the given dynamic expression.\n+   * @param dynamicExpr Expression node representing Dynamic expression\n+   * @param typeInfo Type info used to create constant expression from ASTNode\n+   * @param parameterMap Integer to AST node map\n+   */\n+  private ExprNodeConstantDesc getConstant(ExprDynamicParamDesc dynamicExpr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> parameterMap) throws SemanticException {\n+    Preconditions.checkArgument(parameterMap.containsKey(dynamicExpr.getIndex()),\n+        \"Paramter index not found\");\n+\n+    ASTNode paramNode = parameterMap.get(dynamicExpr.getIndex());\n+\n+    TypeCheckCtx typeCheckCtx = new TypeCheckCtx(null);\n+    ExprNodeDesc node = ExprNodeTypeCheck.genExprNode(paramNode, typeCheckCtx).get(paramNode);\n+    Preconditions.checkArgument(node instanceof ExprNodeConstantDesc,\n+        \"Invalid expression created\");\n+    return (ExprNodeConstantDesc)node;\n+  }\n+\n+  /**\n+   * Given a list of expressions this method traverse the expression tree and replaces\n+   * all {@link ExprDynamicParamDesc} nodes with constant expression.\n+   * @param exprList\n+   * @param paramMap\n+   */\n+  private List<ExprNodeDesc> replaceDynamicParamsInExprList(List<ExprNodeDesc> exprList,\n+      Map<Integer, ASTNode> paramMap) throws SemanticException{\n+    List<ExprNodeDesc> updatedExprList = new ArrayList<>();\n+    for (ExprNodeDesc expr:exprList) {\n+      expr = replaceDynamicParamsWithConstant(expr, expr.getTypeInfo(), paramMap);\n+      updatedExprList.add(expr);\n+    }\n+    return updatedExprList;\n+  }\n+\n+  /**\n+   * Given an expression tree root at expr and type info of the expression this method traverse\n+   * the expression tree and replaces all dynamic expression with the constant expression.\n+   * This method also does type inference for the new constant expression.\n+   * Note about type inference\n+   * Since dynamic parameter lacks type we need to figure out appropriate type to create constant\n+   * out of string value. To do this, we choose the type of first child of the parent expression\n+   * which isn't dynamic parameter\n+   */\n+  private ExprNodeDesc replaceDynamicParamsWithConstant(ExprNodeDesc expr, TypeInfo typeInfo,\n+      Map<Integer, ASTNode> paramMap) throws SemanticException{\n+    if (expr.getChildren() == null || expr.getChildren().isEmpty()) {\n+      if (expr instanceof ExprDynamicParamDesc) {\n+        return getConstant((ExprDynamicParamDesc)expr, typeInfo, paramMap);\n+      }\n+      return expr;\n+    }\n+\n+    for(ExprNodeDesc child:expr.getChildren()) {\n+      // we need typeinfo\n+      if(child instanceof ExprDynamicParamDesc) {\n+        continue;\n+      } else if( child.getTypeInfo() != TypeInfoFactory.voidTypeInfo) {\n+        typeInfo = child.getTypeInfo();\n+        break;\n+      }\n+    }\n+    Preconditions.checkArgument(typeInfo != null, \"TypeInfo is null\");\n+\n+    List<ExprNodeDesc> exprList = new ArrayList<>();\n+    for(ExprNodeDesc child: expr.getChildren()) {\n+      //if(child instanceof ExprDynamicParamDesc) {", "originalCommit": "a2b2eb0a70a794228b866d19a8b4d781d6e8f370", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4Njc1MQ==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466086751", "bodyText": "JIRA?", "author": "jcamachor", "createdAt": "2020-08-06T01:07:15Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/stats/StatsUtils.java", "diffHunk": "@@ -1619,6 +1620,12 @@ public static ColStatistics getColStatisticsFromExpression(HiveConf conf, Statis\n       colName = enfd.getFieldName();\n       colType = enfd.getTypeString();\n       countDistincts = numRows;\n+    } else if (end instanceof ExprDynamicParamDesc) {\n+      //skip collecting stats for parameters", "originalCommit": "a2b2eb0a70a794228b866d19a8b4d781d6e8f370", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzMzU4Mw==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466533583", "bodyText": "https://issues.apache.org/jira/browse/HIVE-24003", "author": "vineetgarg02", "createdAt": "2020-08-06T16:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4Njc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NzQ5MA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466087490", "bodyText": "Why did these types change? Seems unrelated to this patch. Was it an existing bug?", "author": "jcamachor", "createdAt": "2020-08-06T01:10:02Z", "path": "ql/src/test/results/clientpositive/llap/udf_greatest.q.out", "diffHunk": "@@ -63,7 +63,7 @@ STAGE PLANS:\n           alias: src\n           Row Limit Per Split: 1\n           Select Operator\n-            expressions: 'c' (type: string), 'a' (type: string), 'AaA' (type: string), 'AAA' (type: string), '13' (type: string), '2' (type: string), '03' (type: string), '1' (type: string), null (type: double), null (type: double), null (type: double), null (type: double), null (type: double), null (type: double)", "originalCommit": "a2b2eb0a70a794228b866d19a8b4d781d6e8f370", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzMzM2Ng==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466533366", "bodyText": "There is a small change in the patch which updates the type inference rule for void/null. Prior to the change the expressions were being inferred as Double in this case. With the change it is appropriately inferred as String (since rest of the expressions within this UDF (GREATEST('a', 'b', null )) is interpreted as string.", "author": "vineetgarg02", "createdAt": "2020-08-06T16:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NzQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4ODA1Mg==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466088052", "bodyText": "Did you verify whether these results match the non-parameterized version of the query?", "author": "jcamachor", "createdAt": "2020-08-06T01:12:05Z", "path": "ql/src/test/results/clientpositive/llap/prepare_plan.q.out", "diffHunk": "@@ -0,0 +1,2512 @@\n+PREHOOK: query: explain extended prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain extended prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+OPTIMIZED SQL: SELECT COUNT(*) AS `$f0`\n+FROM `default`.`src`\n+WHERE `key` > CAST(? AS STRING)\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( $1 AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  GatherStats: false\n+                  Filter Operator\n+                    isSamplingPred: false\n+                    predicate: (key > CAST( $1 AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          bucketingVersion: 2\n+                          null sort order: \n+                          numBuckets: -1\n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          tag: -1\n+                          value expressions: _col0 (type: bigint)\n+                          auto parallelism: false\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+            Path -> Alias:\n+#### A masked pattern was here ####\n+            Path -> Partition:\n+#### A masked pattern was here ####\n+                Partition\n+                  base file name: src\n+                  input format: org.apache.hadoop.mapred.TextInputFormat\n+                  output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                  properties:\n+                    bucket_count -1\n+                    bucketing_version 2\n+                    column.name.delimiter ,\n+                    columns key,value\n+                    columns.types string:string\n+#### A masked pattern was here ####\n+                    name default.src\n+                    serialization.format 1\n+                    serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                \n+                    input format: org.apache.hadoop.mapred.TextInputFormat\n+                    output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat\n+                    properties:\n+                      bucketing_version 2\n+                      column.name.delimiter ,\n+                      columns key,value\n+                      columns.comments 'default','default'\n+                      columns.types string:string\n+#### A masked pattern was here ####\n+                      name default.src\n+                      serialization.format 1\n+                      serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                    name: default.src\n+                  name: default.src\n+            Truncated Path -> Alias:\n+              /src [src]\n+        Reducer 2 \n+            Execution mode: llap\n+            Needs Tagging: false\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  bucketingVersion: 2\n+                  compressed: false\n+                  GlobalTableId: 0\n+#### A masked pattern was here ####\n+                  NumFilesPerFileSink: 1\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+#### A masked pattern was here ####\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      properties:\n+                        bucketing_version -1\n+                        columns _col0\n+                        columns.types bigint\n+                        escape.delim \\\n+                        hive.serialization.extend.additional.nesting.levels true\n+                        serialization.escape.crlf true\n+                        serialization.format 1\n+                        serialization.lib org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+                  TotalFiles: 1\n+                  GatherStats: false\n+                  MultiFileSpray: false\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( '200' AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (key > CAST( '200' AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+378\n+PREHOOK: query: prepare pcount from select count(*) from src where key > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcount from select count(*) from src where key > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+497\n+PREHOOK: query: explain prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( $1 AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 89000 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (key > CAST( $1 AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Top N Key Operator\n+                      sort order: +\n+                      keys: key (type: string)\n+                      null sort order: z\n+                      Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                      top n: 10\n+                      Select Operator\n+                        expressions: key (type: string), value (type: string)\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: string)\n+                          null sort order: z\n+                          sort order: +\n+                          Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: string)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Select Operator\n+                expressions: KEY.reducesinkkey0 (type: string), VALUE._col0 (type: string)\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                Limit\n+                  Number of rows: 10\n+                  Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: 10\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > CAST( '100' AS STRING)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 89000 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (key > CAST( '100' AS STRING)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Top N Key Operator\n+                      sort order: +\n+                      keys: key (type: string)\n+                      null sort order: z\n+                      Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                      top n: 10\n+                      Select Operator\n+                        expressions: key (type: string), value (type: string)\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: string)\n+                          null sort order: z\n+                          sort order: +\n+                          Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: string)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Select Operator\n+                expressions: KEY.reducesinkkey0 (type: string), VALUE._col0 (type: string)\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 166 Data size: 29548 Basic stats: COMPLETE Column stats: COMPLETE\n+                Limit\n+                  Number of rows: 10\n+                  Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 10 Data size: 1780 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: 10\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p1 from select * from src where key > ? order by key limit 10\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+103\tval_103\n+103\tval_103\n+104\tval_104\n+104\tval_104\n+105\tval_105\n+11\tval_11\n+111\tval_111\n+113\tval_113\n+113\tval_113\n+114\tval_114\n+PREHOOK: query: explain\n+    prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((cint <= $1) and (cbigint <= $2) and (cfloat <> $3)) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 183480 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((cint <= $1) and (cbigint <= $2) and (cfloat <> $3)) (type: boolean)\n+                    Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint)\n+                      outputColumnNames: ctinyint\n+                      Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: avg(ctinyint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9040293\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: struct<count:bigint,sum:double,input:tinyint>)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: avg(VALUE._col0)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 131 Data size: 1444 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: double)\n+                  outputColumnNames: _col1\n+                  Statistics: Num rows: 131 Data size: 1048 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (_col1 < $4) (type: boolean)\n+                    Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: _col1 (type: double)\n+                      outputColumnNames: _col0\n+                      Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                      File Output Operator\n+                        compressed: false\n+                        Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                        table:\n+                            input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                            output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                            serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((cint <= 100) and (cbigint <= 5000000) and (cfloat <> 0.023)) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 183480 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((cint <= 100) and (cbigint <= 5000000) and (cfloat <> 0.023)) (type: boolean)\n+                    Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint)\n+                      outputColumnNames: ctinyint\n+                      Statistics: Num rows: 1365 Data size: 20400 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: avg(ctinyint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9040293\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 10352 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: struct<count:bigint,sum:double,input:tinyint>)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: avg(VALUE._col0)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 131 Data size: 1444 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: double)\n+                  outputColumnNames: _col1\n+                  Statistics: Num rows: 131 Data size: 1048 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (_col1 < 0) (type: boolean)\n+                    Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: _col1 (type: double)\n+                      outputColumnNames: _col0\n+                      Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                      File Output Operator\n+                        compressed: false\n+                        Statistics: Num rows: 43 Data size: 344 Basic stats: COMPLETE Column stats: COMPLETE\n+                        table:\n+                            input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                            output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                            serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pint\n+    from select avg(ctinyint) as ag from alltypesorc where cint <= ?  and cbigint <= ? and cfloat != ? group by ctinyint having ag < ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+-51.0\n+PREHOOK: query: explain\n+    prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint = ?  and csmallint != ? group by cint\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint = ?  and csmallint != ? group by cint\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((ctinyint = UDFToByte($1)) and (csmallint <> UDFToShort($2))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 110092 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((ctinyint = UDFToByte($1)) and (csmallint <> UDFToShort($2))) (type: boolean)\n+                    Statistics: Num rows: 6144 Data size: 55048 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: cint (type: int)\n+                      outputColumnNames: cint\n+                      Statistics: Num rows: 6144 Data size: 55048 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        keys: cint (type: int)\n+                        minReductionHashAggr: 0.49983722\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: int)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: int)\n+                          Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                keys: KEY._col0 (type: int)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 3072 Data size: 33752 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: bigint)\n+                  outputColumnNames: _col0\n+                  Statistics: Num rows: 3072 Data size: 24576 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 3072 Data size: 24576 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: ((ctinyint <= UDFToByte(3)) and (csmallint <> UDFToShort(10))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 110092 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((ctinyint <= UDFToByte(3)) and (csmallint <> UDFToShort(10))) (type: boolean)\n+                    Statistics: Num rows: 4096 Data size: 36708 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: cint (type: int)\n+                      outputColumnNames: cint\n+                      Statistics: Num rows: 4096 Data size: 36708 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        keys: cint (type: int)\n+                        minReductionHashAggr: 0.49975586\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1\n+                        Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: int)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: int)\n+                          Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                keys: KEY._col0 (type: int)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1\n+                Statistics: Num rows: 2048 Data size: 22504 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: bigint)\n+                  outputColumnNames: _col0\n+                  Statistics: Num rows: 2048 Data size: 16384 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 2048 Data size: 16384 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare psint\n+    from select count(*) as ag from alltypesorc where ctinyint <= ?  and csmallint != ? group by cint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+553\n+547\n+523\n+1665\n+PREHOOK: query: create table tcharvchar(c char(10), v varchar(50)) stored as orc\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: create table tcharvchar(c char(10), v varchar(50)) stored as orc\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@tcharvchar\n+PREHOOK: query: insert into tcharvchar values ('c1', 'v10'), ('c2', 'v100')\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: insert into tcharvchar values ('c1', 'v10'), ('c2', 'v100')\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tcharvchar\n+POSTHOOK: Lineage: tcharvchar.c SCRIPT []\n+POSTHOOK: Lineage: tcharvchar.v SCRIPT []\n+PREHOOK: query: explain prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tcharvchar\n+                  filterExpr: ((c = CAST( $1 AS CHAR(10))) and (v <> CAST( $2 AS varchar(50)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( $1 AS CHAR(10))) and (v <> CAST( $2 AS varchar(50)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tcharvchar\n+                  filterExpr: ((c = CAST( 'c1' AS CHAR(10))) and (v <> CAST( 'v1' AS varchar(50)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 348 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( 'c1' AS CHAR(10))) and (v <> CAST( 'v1' AS varchar(50)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 174 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pcharv  from select count(*) from tcharvchar where c = ? and v != ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tcharvchar\n+#### A masked pattern was here ####\n+1\n+PREHOOK: query: drop table tcharvchar\n+PREHOOK: type: DROPTABLE\n+PREHOOK: Input: default@tcharvchar\n+PREHOOK: Output: default@tcharvchar\n+POSTHOOK: query: drop table tcharvchar\n+POSTHOOK: type: DROPTABLE\n+POSTHOOK: Input: default@tcharvchar\n+POSTHOOK: Output: default@tcharvchar\n+PREHOOK: query: create table tdatets(t timestamp, d date, dc decimal(10,2)) stored as orc\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: create table tdatets(t timestamp, d date, dc decimal(10,2)) stored as orc\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@tdatets\n+PREHOOK: query: insert into tdatets values ( cast('2011-01-01 00:00:00' as timestamp), cast('1919-11-01' as date), 5.00)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: insert into tdatets values ( cast('2011-01-01 00:00:00' as timestamp), cast('1919-11-01' as date), 5.00)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tdatets\n+POSTHOOK: Lineage: tdatets.d SCRIPT []\n+POSTHOOK: Lineage: tdatets.dc SCRIPT []\n+POSTHOOK: Lineage: tdatets.t SCRIPT []\n+PREHOOK: query: insert into tdatets values ( cast('2010-01-01 04:00:00' as timestamp), cast('1918-11-01' as date), 4.00)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: insert into tdatets values ( cast('2010-01-01 04:00:00' as timestamp), cast('1918-11-01' as date), 4.00)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@tdatets\n+POSTHOOK: Lineage: tdatets.d SCRIPT []\n+POSTHOOK: Lineage: tdatets.dc SCRIPT []\n+POSTHOOK: Lineage: tdatets.t SCRIPT []\n+PREHOOK: query: explain\n+    prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain\n+    prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tdatets\n+                  filterExpr: ((t <> CAST( $1 AS TIMESTAMP)) and (d <> CAST( $2 AS DATE)) and (dc > CAST( $3 AS decimal(10,2)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 416 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((t <> CAST( $1 AS TIMESTAMP)) and (d <> CAST( $2 AS DATE)) and (dc > CAST( $3 AS decimal(10,2)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: tdatets\n+                  filterExpr: ((t <> CAST( '2012-01-01 00:01:01' AS TIMESTAMP)) and (d <> CAST( '2020-01-01' AS DATE)) and (dc > CAST( 1 AS decimal(10,2)))) (type: boolean)\n+                  Statistics: Num rows: 2 Data size: 416 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((t <> CAST( '2012-01-01 00:01:01' AS TIMESTAMP)) and (d <> CAST( '2020-01-01' AS DATE)) and (dc > CAST( 1 AS decimal(10,2)))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 208 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare ptsd from select count(*) from tdatets where t != ? and d != ? and dc > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@tdatets\n+#### A masked pattern was here ####\n+2\n+PREHOOK: query: drop table tdatets\n+PREHOOK: type: DROPTABLE\n+PREHOOK: Input: default@tdatets\n+PREHOOK: Output: default@tdatets\n+POSTHOOK: query: drop table tdatets\n+POSTHOOK: type: DROPTABLE\n+POSTHOOK: Input: default@tdatets\n+POSTHOOK: Output: default@tdatets\n+PREHOOK: query: explain prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypesorc\n+                  filterExpr: (cint > UDFToInteger((($1 + $2) + $3))) (type: boolean)\n+                  Statistics: Num rows: 12288 Data size: 146784 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (cint > UDFToInteger((($1 + $2) + $3))) (type: boolean)\n+                    Statistics: Num rows: 4096 Data size: 48944 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      expressions: ctinyint (type: tinyint), cbigint (type: bigint)\n+                      outputColumnNames: ctinyint, cbigint\n+                      Statistics: Num rows: 4096 Data size: 48944 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: min(ctinyint), max(cbigint)\n+                        keys: ctinyint (type: tinyint)\n+                        minReductionHashAggr: 0.9680176\n+                        mode: hash\n+                        outputColumnNames: _col0, _col1, _col2\n+                        Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          key expressions: _col0 (type: tinyint)\n+                          null sort order: z\n+                          sort order: +\n+                          Map-reduce partition columns: _col0 (type: tinyint)\n+                          Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col1 (type: tinyint), _col2 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: min(VALUE._col0), max(VALUE._col1)\n+                keys: KEY._col0 (type: tinyint)\n+                mode: mergepartial\n+                outputColumnNames: _col0, _col1, _col2\n+                Statistics: Num rows: 131 Data size: 1968 Basic stats: COMPLETE Column stats: COMPLETE\n+                Select Operator\n+                  expressions: _col1 (type: tinyint), _col2 (type: bigint)\n+                  outputColumnNames: _col0, _col1\n+                  Statistics: Num rows: 131 Data size: 1572 Basic stats: COMPLETE Column stats: COMPLETE\n+                  File Output Operator\n+                    compressed: false\n+                    Statistics: Num rows: 131 Data size: 1572 Basic stats: COMPLETE Column stats: COMPLETE\n+                    table:\n+                        input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                        output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare p2 from select min(ctinyint), max(cbigint) from alltypesorc where cint > (? + ? + ?) group by ctinyint\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypesorc\n+#### A masked pattern was here ####\n+-64\tNULL\n+-62\tNULL\n+-58\tNULL\n+-57\tNULL\n+-54\tNULL\n+-50\tNULL\n+-44\tNULL\n+-42\tNULL\n+-39\tNULL\n+-38\tNULL\n+-37\tNULL\n+-36\tNULL\n+-35\tNULL\n+-31\tNULL\n+-29\tNULL\n+-27\tNULL\n+-26\tNULL\n+-24\tNULL\n+-23\tNULL\n+-22\tNULL\n+-18\tNULL\n+-17\tNULL\n+-16\tNULL\n+-14\tNULL\n+-12\tNULL\n+-11\tNULL\n+-10\tNULL\n+-9\tNULL\n+-8\tNULL\n+-6\tNULL\n+-5\tNULL\n+-4\tNULL\n+-3\tNULL\n+-2\tNULL\n+0\tNULL\n+1\tNULL\n+2\tNULL\n+5\tNULL\n+7\tNULL\n+8\t2141237419\n+11\t2145498388\n+13\tNULL\n+17\tNULL\n+19\tNULL\n+21\tNULL\n+22\tNULL\n+25\tNULL\n+26\tNULL\n+28\tNULL\n+29\tNULL\n+32\tNULL\n+33\tNULL\n+36\tNULL\n+43\tNULL\n+44\tNULL\n+45\tNULL\n+47\tNULL\n+50\tNULL\n+51\tNULL\n+53\tNULL\n+54\tNULL\n+55\tNULL\n+56\tNULL\n+57\tNULL\n+58\tNULL\n+59\tNULL\n+60\tNULL\n+61\tNULL\n+-63\tNULL\n+-61\tNULL\n+-60\tNULL\n+-59\tNULL\n+-56\tNULL\n+-55\tNULL\n+-53\tNULL\n+-52\tNULL\n+-51\t2140002067\n+-49\tNULL\n+-48\tNULL\n+-47\tNULL\n+-46\tNULL\n+-45\tNULL\n+-43\tNULL\n+-41\tNULL\n+-40\tNULL\n+-34\tNULL\n+-33\tNULL\n+-32\tNULL\n+-30\tNULL\n+-28\tNULL\n+-25\tNULL\n+-21\tNULL\n+-20\tNULL\n+-19\tNULL\n+-15\tNULL\n+-13\tNULL\n+-7\tNULL\n+-1\tNULL\n+3\tNULL\n+4\tNULL\n+6\tNULL\n+9\tNULL\n+10\tNULL\n+12\tNULL\n+14\tNULL\n+15\tNULL\n+16\tNULL\n+18\tNULL\n+20\tNULL\n+23\tNULL\n+24\tNULL\n+27\tNULL\n+30\tNULL\n+31\tNULL\n+34\tNULL\n+35\tNULL\n+37\tNULL\n+38\tNULL\n+39\tNULL\n+40\tNULL\n+41\tNULL\n+42\tNULL\n+46\tNULL\n+48\tNULL\n+49\tNULL\n+52\tNULL\n+62\tNULL\n+NULL\t1864027286\n+PREHOOK: query: explain prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > concat(CAST( $1 AS STRING), $2)) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (key > concat(CAST( $1 AS STRING), $2)) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: src\n+                  filterExpr: (key > concat(CAST( '1' AS STRING), '20')) (type: boolean)\n+                  Statistics: Num rows: 500 Data size: 43500 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (key > concat(CAST( '1' AS STRING), '20')) (type: boolean)\n+                    Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 166 Data size: 14442 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@src\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pconcat\n+    from select count(*) from src where key > concat(?, ?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@src\n+#### A masked pattern was here ####\n+474\n+PREHOOK: query: create table daysales (customer int) partitioned by (dt string)\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@daysales\n+POSTHOOK: query: create table daysales (customer int) partitioned by (dt string)\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@daysales\n+PREHOOK: query: insert into daysales partition(dt='2001-01-01') values(1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@daysales@dt=2001-01-01\n+POSTHOOK: query: insert into daysales partition(dt='2001-01-01') values(1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@daysales@dt=2001-01-01\n+POSTHOOK: Lineage: daysales PARTITION(dt=2001-01-01).customer SCRIPT []\n+PREHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: Lineage: daysales PARTITION(dt=2001-01-03).customer SCRIPT []\n+PREHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: query: insert into daysales partition(dt='2001-01-03') values(1)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@daysales@dt=2001-01-03\n+POSTHOOK: Lineage: daysales PARTITION(dt=2001-01-03).customer SCRIPT []\n+PREHOOK: query: explain prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01\n+PREHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@daysales\n+POSTHOOK: Input: default@daysales@dt=2001-01-01\n+POSTHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: daysales\n+                  filterExpr: ((dt = CAST( $1 AS STRING)) and (customer = UDFToInteger($2))) (type: boolean)\n+                  Statistics: Num rows: 3 Data size: 564 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((dt = CAST( $1 AS STRING)) and (customer = UDFToInteger($2))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01\n+PREHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@daysales\n+POSTHOOK: Input: default@daysales@dt=2001-01-01\n+POSTHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: daysales\n+                  filterExpr: ((dt = CAST( '2001-01-01' AS STRING)) and (customer = UDFToInteger(1))) (type: boolean)\n+                  Statistics: Num rows: 3 Data size: 564 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((dt = CAST( '2001-01-01' AS STRING)) and (customer = UDFToInteger(1))) (type: boolean)\n+                    Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 1 Data size: 188 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.0\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01\n+PREHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@daysales\n+POSTHOOK: Input: default@daysales@dt=2001-01-01\n+POSTHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+1\n+PREHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@daysales\n+PREHOOK: Input: default@daysales@dt=2001-01-01\n+PREHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pPart1 from select count(*) from daysales where dt=? and customer=?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@daysales\n+POSTHOOK: Input: default@daysales@dt=2001-01-01\n+POSTHOOK: Input: default@daysales@dt=2001-01-03\n+#### A masked pattern was here ####\n+2\n+PREHOOK: query: create table testParam(c char(5), v varchar(10), d decimal(10,3), dt date) stored as textfile\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@testParam\n+POSTHOOK: query: create table testParam(c char(5), v varchar(10), d decimal(10,3), dt date) stored as textfile\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@testParam\n+PREHOOK: query: insert into testParam values ('ch1', 'var1', 1000.34,'1947-12-12' )\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@testparam\n+POSTHOOK: query: insert into testParam values ('ch1', 'var1', 1000.34,'1947-12-12' )\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@testparam\n+POSTHOOK: Lineage: testparam.c SCRIPT []\n+POSTHOOK: Lineage: testparam.d SCRIPT []\n+POSTHOOK: Lineage: testparam.dt SCRIPT []\n+POSTHOOK: Lineage: testparam.v SCRIPT []\n+PREHOOK: query: insert into testParam values ('ch2', 'var2', 2000.00,'1967-02-02')\n+PREHOOK: type: QUERY\n+PREHOOK: Input: _dummy_database@_dummy_table\n+PREHOOK: Output: default@testparam\n+POSTHOOK: query: insert into testParam values ('ch2', 'var2', 2000.00,'1967-02-02')\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: _dummy_database@_dummy_table\n+POSTHOOK: Output: default@testparam\n+POSTHOOK: Lineage: testparam.c SCRIPT []\n+POSTHOOK: Lineage: testparam.d SCRIPT []\n+POSTHOOK: Lineage: testparam.dt SCRIPT []\n+POSTHOOK: Lineage: testparam.v SCRIPT []\n+PREHOOK: query: CREATE TABLE alltypes(\n+    c char(5),\n+    v varchar(10),\n+    d decimal(10,3),\n+    dt date,\n+    bl boolean,\n+    ctinyint TINYINT,\n+    csmallint SMALLINT,\n+    cint INT,\n+    cbigint BIGINT,\n+    cfloat FLOAT,\n+    cdouble DOUBLE,\n+    cstring1 STRING,\n+    ctimestamp1 TIMESTAMP)\n+    stored as textfile\n+PREHOOK: type: CREATETABLE\n+PREHOOK: Output: database:default\n+PREHOOK: Output: default@alltypes\n+POSTHOOK: query: CREATE TABLE alltypes(\n+    c char(5),\n+    v varchar(10),\n+    d decimal(10,3),\n+    dt date,\n+    bl boolean,\n+    ctinyint TINYINT,\n+    csmallint SMALLINT,\n+    cint INT,\n+    cbigint BIGINT,\n+    cfloat FLOAT,\n+    cdouble DOUBLE,\n+    cstring1 STRING,\n+    ctimestamp1 TIMESTAMP)\n+    stored as textfile\n+POSTHOOK: type: CREATETABLE\n+POSTHOOK: Output: database:default\n+POSTHOOK: Output: default@alltypes\n+Warning: Shuffle Join MERGEJOIN[18][tables = [$hdt$_0, $hdt$_1]] in Stage 'Reducer 2' is a cross product\n+PREHOOK: query: insert into alltypes select c,v,d,dt,cboolean1,ctinyint,csmallint,cint,cbigint,cfloat,cdouble,cstring1,ctimestamp1\n+    from testParam join alltypesorc where ctinyint is not null\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypesorc\n+PREHOOK: Input: default@testparam\n+PREHOOK: Output: default@alltypes\n+POSTHOOK: query: insert into alltypes select c,v,d,dt,cboolean1,ctinyint,csmallint,cint,cbigint,cfloat,cdouble,cstring1,ctimestamp1\n+    from testParam join alltypesorc where ctinyint is not null\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypesorc\n+POSTHOOK: Input: default@testparam\n+POSTHOOK: Output: default@alltypes\n+POSTHOOK: Lineage: alltypes.bl SIMPLE [(alltypesorc)alltypesorc.FieldSchema(name:cboolean1, type:boolean, comment:null), ]\n+POSTHOOK: Lineage: alltypes.c SIMPLE [(testparam)testparam.FieldSchema(name:c, type:char(5), comment:null), ]\n+POSTHOOK: Lineage: alltypes.cbigint SIMPLE [(alltypesorc)alltypesorc.FieldSchema(name:cbigint, type:bigint, comment:null), ]\n+POSTHOOK: Lineage: alltypes.cdouble SIMPLE [(alltypesorc)alltypesorc.FieldSchema(name:cdouble, type:double, comment:null), ]\n+POSTHOOK: Lineage: alltypes.cfloat SIMPLE [(alltypesorc)alltypesorc.FieldSchema(name:cfloat, type:float, comment:null), ]\n+POSTHOOK: Lineage: alltypes.cint SIMPLE [(alltypesorc)alltypesorc.FieldSchema(name:cint, type:int, comment:null), ]\n+POSTHOOK: Lineage: alltypes.csmallint SIMPLE [(alltypesorc)alltypesorc.FieldSchema(name:csmallint, type:smallint, comment:null), ]\n+POSTHOOK: Lineage: alltypes.cstring1 SIMPLE [(alltypesorc)alltypesorc.FieldSchema(name:cstring1, type:string, comment:null), ]\n+POSTHOOK: Lineage: alltypes.ctimestamp1 SIMPLE [(alltypesorc)alltypesorc.FieldSchema(name:ctimestamp1, type:timestamp, comment:null), ]\n+POSTHOOK: Lineage: alltypes.ctinyint SIMPLE [(alltypesorc)alltypesorc.FieldSchema(name:ctinyint, type:tinyint, comment:null), ]\n+POSTHOOK: Lineage: alltypes.d SIMPLE [(testparam)testparam.FieldSchema(name:d, type:decimal(10,3), comment:null), ]\n+POSTHOOK: Lineage: alltypes.dt SIMPLE [(testparam)testparam.FieldSchema(name:dt, type:date, comment:null), ]\n+POSTHOOK: Lineage: alltypes.v SIMPLE [(testparam)testparam.FieldSchema(name:v, type:varchar(10), comment:null), ]\n+PREHOOK: query: explain prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+ OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+ OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: ((c > CAST( $1 AS CHAR(5))) or (v > CAST( $2 AS varchar(10))) or (d > CAST( $3 AS decimal(10,3))) or (dt > CAST( $4 AS DATE)) or (ctinyint > UDFToByte($5)) or (csmallint > UDFToShort($6)) or (cint > UDFToInteger($7)) or (cfloat > UDFToFloat($8)) or (cdouble > UDFToDouble($9)) or (cstring1 > CAST( $10 AS STRING)) or (ctimestamp1 > CAST( $11 AS TIMESTAMP)) or (cbigint > UDFToLong($12))) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c > CAST( $1 AS CHAR(5))) or (v > CAST( $2 AS varchar(10))) or (d > CAST( $3 AS decimal(10,3))) or (dt > CAST( $4 AS DATE)) or (ctinyint > UDFToByte($5)) or (csmallint > UDFToShort($6)) or (cint > UDFToInteger($7)) or (cfloat > UDFToFloat($8)) or (cdouble > UDFToDouble($9)) or (cstring1 > CAST( $10 AS STRING)) or (ctimestamp1 > CAST( $11 AS TIMESTAMP)) or (cbigint > UDFToLong($12))) (type: boolean)\n+                    Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+                                 OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+                                 OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: ((c > CAST( 'a' AS CHAR(5))) or (v > CAST( 'v' AS varchar(10))) or (d > CAST( 1000 AS decimal(10,3))) or (dt > CAST( '1954-12-12' AS DATE)) or (ctinyint > UDFToByte(0)) or (csmallint > UDFToShort(7476)) or (cint > UDFToInteger(528534766)) or (cfloat > UDFToFloat(24)) or (cdouble > UDFToDouble(5780.3)) or (cstring1 > CAST( 'cvLH6Eat2yFsyy' AS STRING)) or (ctimestamp1 > CAST( '1968-12-31 15:59:46.674' AS TIMESTAMP)) or (cbigint > UDFToLong(0))) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c > CAST( 'a' AS CHAR(5))) or (v > CAST( 'v' AS varchar(10))) or (d > CAST( 1000 AS decimal(10,3))) or (dt > CAST( '1954-12-12' AS DATE)) or (ctinyint > UDFToByte(0)) or (csmallint > UDFToShort(7476)) or (cint > UDFToInteger(528534766)) or (cfloat > UDFToFloat(24)) or (cdouble > UDFToDouble(5780.3)) or (cstring1 > CAST( 'cvLH6Eat2yFsyy' AS STRING)) or (ctimestamp1 > CAST( '1968-12-31 15:59:46.674' AS TIMESTAMP)) or (cbigint > UDFToLong(0))) (type: boolean)\n+                    Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+                                 OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+                                 OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+18346\n+PREHOOK: query: explain prepare palltypesLess from\n+select count(*) from alltypes where c < ? OR v < ? OR d < ? OR dt < ? OR ctinyint < ? OR csmallint < ? OR cint < ?\n+                                 OR cfloat < ? OR cdouble < ? OR cstring1 < ? OR ctimestamp1 < ? OR cbigint < ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare palltypesLess from\n+select count(*) from alltypes where c < ? OR v < ? OR d < ? OR dt < ? OR ctinyint < ? OR csmallint < ? OR cint < ?\n+                                 OR cfloat < ? OR cdouble < ? OR cstring1 < ? OR ctimestamp1 < ? OR cbigint < ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: ((c < CAST( $1 AS CHAR(5))) or (v < CAST( $2 AS varchar(10))) or (d < CAST( $3 AS decimal(10,3))) or (dt < CAST( $4 AS DATE)) or (ctinyint < UDFToByte($5)) or (csmallint < UDFToShort($6)) or (cint < UDFToInteger($7)) or (cfloat < UDFToFloat($8)) or (cdouble < UDFToDouble($9)) or (cstring1 < CAST( $10 AS STRING)) or (ctimestamp1 < CAST( $11 AS TIMESTAMP)) or (cbigint < UDFToLong($12))) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c < CAST( $1 AS CHAR(5))) or (v < CAST( $2 AS varchar(10))) or (d < CAST( $3 AS decimal(10,3))) or (dt < CAST( $4 AS DATE)) or (ctinyint < UDFToByte($5)) or (csmallint < UDFToShort($6)) or (cint < UDFToInteger($7)) or (cfloat < UDFToFloat($8)) or (cdouble < UDFToDouble($9)) or (cstring1 < CAST( $10 AS STRING)) or (ctimestamp1 < CAST( $11 AS TIMESTAMP)) or (cbigint < UDFToLong($12))) (type: boolean)\n+                    Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+                                 OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+                                 OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: ((c > CAST( 'd' AS CHAR(5))) or (v > CAST( 'z' AS varchar(10))) or (d > CAST( 10000 AS decimal(10,3))) or (dt > CAST( '1995-12-12' AS DATE)) or (ctinyint > UDFToByte(0)) or (csmallint > UDFToShort(7476)) or (cint > UDFToInteger(528534766)) or (cfloat > UDFToFloat(24)) or (cdouble > UDFToDouble(5780.3)) or (cstring1 > CAST( 'cvLH6Eat2yFsyy' AS STRING)) or (ctimestamp1 > CAST( '1968-12-31 15:59:46.674' AS TIMESTAMP)) or (cbigint > UDFToLong(0))) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c > CAST( 'd' AS CHAR(5))) or (v > CAST( 'z' AS varchar(10))) or (d > CAST( 10000 AS decimal(10,3))) or (dt > CAST( '1995-12-12' AS DATE)) or (ctinyint > UDFToByte(0)) or (csmallint > UDFToShort(7476)) or (cint > UDFToInteger(528534766)) or (cfloat > UDFToFloat(24)) or (cdouble > UDFToDouble(5780.3)) or (cstring1 > CAST( 'cvLH6Eat2yFsyy' AS STRING)) or (ctimestamp1 > CAST( '1968-12-31 15:59:46.674' AS TIMESTAMP)) or (cbigint > UDFToLong(0))) (type: boolean)\n+                    Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+                                 OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare palltypesGreater from\n+select count(*) from alltypes where c > ? OR v > ? OR d > ? OR dt > ? OR ctinyint > ? OR csmallint > ? OR cint > ?\n+                                 OR cfloat > ? OR cdouble > ? OR cstring1 > ? OR ctimestamp1 > ? OR cbigint > ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+18336\n+PREHOOK: query: explain prepare pequal from\n+select count(*) from alltypes where c = ? OR v = ? OR d = ? OR dt = ? OR ctinyint = ? OR csmallint = ? OR cint = ?\n+                                 OR cfloat = ? OR cdouble = ? OR cstring1 = ? OR ctimestamp1 = ? OR cbigint = ?\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pequal from\n+select count(*) from alltypes where c = ? OR v = ? OR d = ? OR dt = ? OR ctinyint = ? OR csmallint = ? OR cint = ?\n+                                 OR cfloat = ? OR cdouble = ? OR cstring1 = ? OR ctimestamp1 = ? OR cbigint = ?\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: ((c = CAST( $1 AS CHAR(5))) or (v = CAST( $2 AS varchar(10))) or (d = CAST( $3 AS decimal(10,3))) or (dt = CAST( $4 AS DATE)) or (ctinyint = UDFToByte($5)) or (csmallint = UDFToShort($6)) or (cint = UDFToInteger($7)) or (cfloat = UDFToFloat($8)) or (cdouble = UDFToDouble($9)) or (cstring1 = CAST( $10 AS STRING)) or (ctimestamp1 = CAST( $11 AS TIMESTAMP)) or (cbigint = UDFToLong($12))) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( $1 AS CHAR(5))) or (v = CAST( $2 AS varchar(10))) or (d = CAST( $3 AS decimal(10,3))) or (dt = CAST( $4 AS DATE)) or (ctinyint = UDFToByte($5)) or (csmallint = UDFToShort($6)) or (cint = UDFToInteger($7)) or (cfloat = UDFToFloat($8)) or (cdouble = UDFToDouble($9)) or (cstring1 = CAST( $10 AS STRING)) or (ctimestamp1 = CAST( $11 AS TIMESTAMP)) or (cbigint = UDFToLong($12))) (type: boolean)\n+                    Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pequal from\n+select count(*) from alltypes where c = ? OR v = ? OR d = ? OR dt = ? OR ctinyint = ? OR csmallint = ? OR cint = ?\n+                                 OR cfloat = ? OR cdouble = ? OR cstring1 = ? OR ctimestamp1 = ? OR cbigint = ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pequal from\n+select count(*) from alltypes where c = ? OR v = ? OR d = ? OR dt = ? OR ctinyint = ? OR csmallint = ? OR cint = ?\n+                                 OR cfloat = ? OR cdouble = ? OR cstring1 = ? OR ctimestamp1 = ? OR cbigint = ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: ((c = CAST( 'ch1' AS CHAR(5))) or (v = CAST( 'var1' AS varchar(10))) or (d = CAST( 1000.34 AS decimal(10,3))) or (dt = CAST( '1947-12-12' AS DATE)) or (ctinyint = UDFToByte(11)) or (csmallint = UDFToShort(0)) or (cint = UDFToInteger(529436599)) or (cfloat = UDFToFloat(1)) or (cdouble = UDFToDouble(1.4)) or (cstring1 = CAST( 'xTlDv24JYv4s' AS STRING)) or (ctimestamp1 = CAST( '1969-12-31 16:00:02.351' AS TIMESTAMP)) or (cbigint = UDFToLong(133))) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c = CAST( 'ch1' AS CHAR(5))) or (v = CAST( 'var1' AS varchar(10))) or (d = CAST( 1000.34 AS decimal(10,3))) or (dt = CAST( '1947-12-12' AS DATE)) or (ctinyint = UDFToByte(11)) or (csmallint = UDFToShort(0)) or (cint = UDFToInteger(529436599)) or (cfloat = UDFToFloat(1)) or (cdouble = UDFToDouble(1.4)) or (cstring1 = CAST( 'xTlDv24JYv4s' AS STRING)) or (ctimestamp1 = CAST( '1969-12-31 16:00:02.351' AS TIMESTAMP)) or (cbigint = UDFToLong(133))) (type: boolean)\n+                    Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pequal from\n+select count(*) from alltypes where c = ? OR v = ? OR d = ? OR dt = ? OR ctinyint = ? OR csmallint = ? OR cint = ?\n+                                 OR cfloat = ? OR cdouble = ? OR cstring1 = ? OR ctimestamp1 = ? OR cbigint = ?\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pequal from\n+select count(*) from alltypes where c = ? OR v = ? OR d = ? OR dt = ? OR ctinyint = ? OR csmallint = ? OR cint = ?\n+                                 OR cfloat = ? OR cdouble = ? OR cstring1 = ? OR ctimestamp1 = ? OR cbigint = ?\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+10300\n+PREHOOK: query: explain prepare pin from\n+select count(*) from alltypes where c IN(?,?) AND  v IN(?, ?) AND d IN (?,?) AND dt IN (?) OR ctinyint IN (?) AND csmallint IN(?,?,?) AND cint IN(?,?,?)\n+    AND cfloat IN(?,?) AND cdouble IN(?,?,?) OR cstring1 IN (?,?,?)  AND ctimestamp1 IN (?) OR cbigint IN (?)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pin from\n+select count(*) from alltypes where c IN(?,?) AND  v IN(?, ?) AND d IN (?,?) AND dt IN (?) OR ctinyint IN (?) AND csmallint IN(?,?,?) AND cint IN(?,?,?)\n+    AND cfloat IN(?,?) AND cdouble IN(?,?,?) OR cstring1 IN (?,?,?)  AND ctimestamp1 IN (?) OR cbigint IN (?)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: (((c) IN (CAST( $1 AS CHAR(5)), CAST( $2 AS CHAR(5))) and (v) IN (CAST( $3 AS varchar(10)), CAST( $4 AS varchar(10))) and (d) IN (CAST( $5 AS decimal(10,3)), CAST( $6 AS decimal(10,3))) and (dt = CAST( $7 AS DATE))) or ((ctinyint = UDFToByte($8)) and (csmallint) IN (UDFToShort($9), UDFToShort($10), UDFToShort($11)) and (cint) IN (UDFToInteger($12), UDFToInteger($13), UDFToInteger($14)) and (cfloat) IN (UDFToFloat($15), UDFToFloat($16)) and (cdouble) IN (UDFToDouble($17), UDFToDouble($18), UDFToDouble($19))) or ((cstring1) IN (CAST( $20 AS STRING), CAST( $21 AS STRING), CAST( $22 AS STRING)) and (ctimestamp1 = CAST( $23 AS TIMESTAMP))) or (cbigint = UDFToLong($24))) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (((c) IN (CAST( $1 AS CHAR(5)), CAST( $2 AS CHAR(5))) and (v) IN (CAST( $3 AS varchar(10)), CAST( $4 AS varchar(10))) and (d) IN (CAST( $5 AS decimal(10,3)), CAST( $6 AS decimal(10,3))) and (dt = CAST( $7 AS DATE))) or ((ctinyint = UDFToByte($8)) and (csmallint) IN (UDFToShort($9), UDFToShort($10), UDFToShort($11)) and (cint) IN (UDFToInteger($12), UDFToInteger($13), UDFToInteger($14)) and (cfloat) IN (UDFToFloat($15), UDFToFloat($16)) and (cdouble) IN (UDFToDouble($17), UDFToDouble($18), UDFToDouble($19))) or ((cstring1) IN (CAST( $20 AS STRING), CAST( $21 AS STRING), CAST( $22 AS STRING)) and (ctimestamp1 = CAST( $23 AS TIMESTAMP))) or (cbigint = UDFToLong($24))) (type: boolean)\n+                    Statistics: Num rows: 15478 Data size: 7247775 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 15478 Data size: 7247775 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pin from\n+select count(*) from alltypes where c IN(?,?) AND  v IN(?, ?) AND d IN (?,?) AND dt IN (?) OR ctinyint IN (?) AND csmallint IN(?,?,?) AND cint IN(?,?,?)\n+    AND cfloat IN(?,?) AND cdouble IN(?,?,?) OR cstring1 IN (?,?,?)  AND ctimestamp1 IN (?) OR cbigint IN (?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pin from\n+select count(*) from alltypes where c IN(?,?) AND  v IN(?, ?) AND d IN (?,?) AND dt IN (?) OR ctinyint IN (?) AND csmallint IN(?,?,?) AND cint IN(?,?,?)\n+    AND cfloat IN(?,?) AND cdouble IN(?,?,?) OR cstring1 IN (?,?,?)  AND ctimestamp1 IN (?) OR cbigint IN (?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: (((c) IN (CAST( 'ch1' AS CHAR(5)), CAST( 'ch2' AS CHAR(5))) and (v) IN (CAST( 'var1' AS varchar(10)), CAST( 'var2' AS varchar(10))) and (d) IN (CAST( 1000.34 AS decimal(10,3)), CAST( 2000 AS decimal(10,3))) and (dt = CAST( '1947-12-12' AS DATE))) or ((ctinyint = UDFToByte(11)) and (csmallint) IN (UDFToShort(15601), UDFToShort(0), UDFToShort(1)) and (cint) IN (UDFToInteger(788564623), UDFToInteger(78856), UDFToInteger(23)) and (cfloat) IN (UDFToFloat(1), UDFToFloat(18)) and (cdouble) IN (UDFToDouble(0), UDFToDouble(15601), UDFToDouble(23.1))) or ((cstring1) IN (CAST( 'xTlDv24JYv4s' AS STRING), CAST( 'str1' AS STRING), CAST( 'stre' AS STRING)) and (ctimestamp1 = CAST( '1969-12-31 16:00:02.351' AS TIMESTAMP))) or (cbigint = UDFToLong(133))) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: (((c) IN (CAST( 'ch1' AS CHAR(5)), CAST( 'ch2' AS CHAR(5))) and (v) IN (CAST( 'var1' AS varchar(10)), CAST( 'var2' AS varchar(10))) and (d) IN (CAST( 1000.34 AS decimal(10,3)), CAST( 2000 AS decimal(10,3))) and (dt = CAST( '1947-12-12' AS DATE))) or ((ctinyint = UDFToByte(11)) and (csmallint) IN (UDFToShort(15601), UDFToShort(0), UDFToShort(1)) and (cint) IN (UDFToInteger(788564623), UDFToInteger(78856), UDFToInteger(23)) and (cfloat) IN (UDFToFloat(1), UDFToFloat(18)) and (cdouble) IN (UDFToDouble(0), UDFToDouble(15601), UDFToDouble(23.1))) or ((cstring1) IN (CAST( 'xTlDv24JYv4s' AS STRING), CAST( 'str1' AS STRING), CAST( 'stre' AS STRING)) and (ctimestamp1 = CAST( '1969-12-31 16:00:02.351' AS TIMESTAMP))) or (cbigint = UDFToLong(133))) (type: boolean)\n+                    Statistics: Num rows: 15478 Data size: 7247775 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 15478 Data size: 7247775 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pin from\n+select count(*) from alltypes where c IN(?,?) AND  v IN(?, ?) AND d IN (?,?) AND dt IN (?) OR ctinyint IN (?) AND csmallint IN(?,?,?) AND cint IN(?,?,?)\n+    AND cfloat IN(?,?) AND cdouble IN(?,?,?) OR cstring1 IN (?,?,?)  AND ctimestamp1 IN (?) OR cbigint IN (?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pin from\n+select count(*) from alltypes where c IN(?,?) AND  v IN(?, ?) AND d IN (?,?) AND dt IN (?) OR ctinyint IN (?) AND csmallint IN(?,?,?) AND cint IN(?,?,?)\n+    AND cfloat IN(?,?) AND cdouble IN(?,?,?) OR cstring1 IN (?,?,?)  AND ctimestamp1 IN (?) OR cbigint IN (?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+9174\n+PREHOOK: query: explain prepare pbetween from\n+    select count(*) from alltypes where (c BETWEEN ? AND ?) AND (v BETWEEN ? AND ?) AND (d BETWEEN ? AND ?) AND (dt BETWEEN ? AND ?) OR (ctinyint BETWEEN ? AND ?) AND (csmallint BETWEEN ? AND ?) AND (cint BETWEEN ? AND ?)\n+    AND (cfloat BETWEEN ? AND ?) AND (cdouble BETWEEN ? AND ?) OR (cstring1 BETWEEN ? AND ?)  AND (ctimestamp1 BETWEEN ? AND ?) OR (cbigint BETWEEN ? AND ?)\n+PREHOOK: type: QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: explain prepare pbetween from\n+    select count(*) from alltypes where (c BETWEEN ? AND ?) AND (v BETWEEN ? AND ?) AND (d BETWEEN ? AND ?) AND (dt BETWEEN ? AND ?) OR (ctinyint BETWEEN ? AND ?) AND (csmallint BETWEEN ? AND ?) AND (cint BETWEEN ? AND ?)\n+    AND (cfloat BETWEEN ? AND ?) AND (cdouble BETWEEN ? AND ?) OR (cstring1 BETWEEN ? AND ?)  AND (ctimestamp1 BETWEEN ? AND ?) OR (cbigint BETWEEN ? AND ?)\n+POSTHOOK: type: QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 depends on stages: Stage-1\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: ((c BETWEEN CAST( $1 AS CHAR(5)) AND CAST( $2 AS CHAR(5)) and v BETWEEN CAST( $3 AS varchar(10)) AND CAST( $4 AS varchar(10)) and d BETWEEN CAST( $5 AS decimal(10,3)) AND CAST( $6 AS decimal(10,3)) and dt BETWEEN CAST( $7 AS DATE) AND CAST( $8 AS DATE)) or (ctinyint BETWEEN UDFToByte($9) AND UDFToByte($10) and csmallint BETWEEN UDFToShort($11) AND UDFToShort($12) and cint BETWEEN UDFToInteger($13) AND UDFToInteger($14) and cfloat BETWEEN UDFToFloat($15) AND UDFToFloat($16) and cdouble BETWEEN UDFToDouble($17) AND UDFToDouble($18)) or (cstring1 BETWEEN CAST( $19 AS STRING) AND CAST( $20 AS STRING) and ctimestamp1 BETWEEN CAST( $21 AS TIMESTAMP) AND CAST( $22 AS TIMESTAMP)) or cbigint BETWEEN UDFToLong($23) AND UDFToLong($24)) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c BETWEEN CAST( $1 AS CHAR(5)) AND CAST( $2 AS CHAR(5)) and v BETWEEN CAST( $3 AS varchar(10)) AND CAST( $4 AS varchar(10)) and d BETWEEN CAST( $5 AS decimal(10,3)) AND CAST( $6 AS decimal(10,3)) and dt BETWEEN CAST( $7 AS DATE) AND CAST( $8 AS DATE)) or (ctinyint BETWEEN UDFToByte($9) AND UDFToByte($10) and csmallint BETWEEN UDFToShort($11) AND UDFToShort($12) and cint BETWEEN UDFToInteger($13) AND UDFToInteger($14) and cfloat BETWEEN UDFToFloat($15) AND UDFToFloat($16) and cdouble BETWEEN UDFToDouble($17) AND UDFToDouble($18)) or (cstring1 BETWEEN CAST( $19 AS STRING) AND CAST( $20 AS STRING) and ctimestamp1 BETWEEN CAST( $21 AS TIMESTAMP) AND CAST( $22 AS TIMESTAMP)) or cbigint BETWEEN UDFToLong($23) AND UDFToLong($24)) (type: boolean)\n+                    Statistics: Num rows: 2266 Data size: 1061232 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 2266 Data size: 1061232 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pbetween from\n+select count(*) from alltypes where (c BETWEEN ? AND ?) AND (v BETWEEN ? AND ?) AND (d BETWEEN ? AND ?) AND (dt BETWEEN ? AND ?) OR (ctinyint BETWEEN ? AND ?) AND (csmallint BETWEEN ? AND ?) AND (cint BETWEEN ? AND ?)\n+    AND (cfloat BETWEEN ? AND ?) AND (cdouble BETWEEN ? AND ?) OR (cstring1 BETWEEN ? AND ?)  AND (ctimestamp1 BETWEEN ? AND ?) OR (cbigint BETWEEN ? AND ?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pbetween from\n+select count(*) from alltypes where (c BETWEEN ? AND ?) AND (v BETWEEN ? AND ?) AND (d BETWEEN ? AND ?) AND (dt BETWEEN ? AND ?) OR (ctinyint BETWEEN ? AND ?) AND (csmallint BETWEEN ? AND ?) AND (cint BETWEEN ? AND ?)\n+    AND (cfloat BETWEEN ? AND ?) AND (cdouble BETWEEN ? AND ?) OR (cstring1 BETWEEN ? AND ?)  AND (ctimestamp1 BETWEEN ? AND ?) OR (cbigint BETWEEN ? AND ?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+STAGE DEPENDENCIES:\n+  Stage-1 is a root stage\n+  Stage-0 is a root stage\n+\n+STAGE PLANS:\n+  Stage: Stage-1\n+    Tez\n+#### A masked pattern was here ####\n+      Edges:\n+        Reducer 2 <- Map 1 (CUSTOM_SIMPLE_EDGE)\n+#### A masked pattern was here ####\n+      Vertices:\n+        Map 1 \n+            Map Operator Tree:\n+                TableScan\n+                  alias: alltypes\n+                  filterExpr: ((c BETWEEN CAST( 'ch1' AS CHAR(5)) AND CAST( 'ch2' AS CHAR(5)) and v BETWEEN CAST( 'var1' AS varchar(10)) AND CAST( 'var2' AS varchar(10)) and d BETWEEN CAST( 1000.34 AS decimal(10,3)) AND CAST( 2000 AS decimal(10,3)) and dt BETWEEN CAST( '1947-12-12' AS DATE) AND CAST( '1968-12-31' AS DATE)) or (ctinyint BETWEEN UDFToByte(11) AND UDFToByte(1000) and csmallint BETWEEN UDFToShort(15601) AND UDFToShort(1) and cint BETWEEN UDFToInteger(788564623) AND UDFToInteger(23) and cfloat BETWEEN UDFToFloat(1) AND UDFToFloat(18) and cdouble BETWEEN UDFToDouble(0) AND UDFToDouble(15601)) or (cstring1 BETWEEN CAST( 'xTlDv24JYv4s' AS STRING) AND CAST( 'str1' AS STRING) and ctimestamp1 BETWEEN CAST( '1969-12-31 16:00:02.351' AS TIMESTAMP) AND CAST( '2020-12-31 16:00:01' AS TIMESTAMP)) or cbigint BETWEEN UDFToLong(0) AND UDFToLong(133)) (type: boolean)\n+                  Statistics: Num rows: 18346 Data size: 8590681 Basic stats: COMPLETE Column stats: COMPLETE\n+                  Filter Operator\n+                    predicate: ((c BETWEEN CAST( 'ch1' AS CHAR(5)) AND CAST( 'ch2' AS CHAR(5)) and v BETWEEN CAST( 'var1' AS varchar(10)) AND CAST( 'var2' AS varchar(10)) and d BETWEEN CAST( 1000.34 AS decimal(10,3)) AND CAST( 2000 AS decimal(10,3)) and dt BETWEEN CAST( '1947-12-12' AS DATE) AND CAST( '1968-12-31' AS DATE)) or (ctinyint BETWEEN UDFToByte(11) AND UDFToByte(1000) and csmallint BETWEEN UDFToShort(15601) AND UDFToShort(1) and cint BETWEEN UDFToInteger(788564623) AND UDFToInteger(23) and cfloat BETWEEN UDFToFloat(1) AND UDFToFloat(18) and cdouble BETWEEN UDFToDouble(0) AND UDFToDouble(15601)) or (cstring1 BETWEEN CAST( 'xTlDv24JYv4s' AS STRING) AND CAST( 'str1' AS STRING) and ctimestamp1 BETWEEN CAST( '1969-12-31 16:00:02.351' AS TIMESTAMP) AND CAST( '2020-12-31 16:00:01' AS TIMESTAMP)) or cbigint BETWEEN UDFToLong(0) AND UDFToLong(133)) (type: boolean)\n+                    Statistics: Num rows: 2266 Data size: 1061232 Basic stats: COMPLETE Column stats: COMPLETE\n+                    Select Operator\n+                      Statistics: Num rows: 2266 Data size: 1061232 Basic stats: COMPLETE Column stats: COMPLETE\n+                      Group By Operator\n+                        aggregations: count()\n+                        minReductionHashAggr: 0.99\n+                        mode: hash\n+                        outputColumnNames: _col0\n+                        Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                        Reduce Output Operator\n+                          null sort order: \n+                          sort order: \n+                          Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                          value expressions: _col0 (type: bigint)\n+            Execution mode: llap\n+            LLAP IO: all inputs\n+        Reducer 2 \n+            Execution mode: llap\n+            Reduce Operator Tree:\n+              Group By Operator\n+                aggregations: count(VALUE._col0)\n+                mode: mergepartial\n+                outputColumnNames: _col0\n+                Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                File Output Operator\n+                  compressed: false\n+                  Statistics: Num rows: 1 Data size: 8 Basic stats: COMPLETE Column stats: COMPLETE\n+                  table:\n+                      input format: org.apache.hadoop.mapred.SequenceFileInputFormat\n+                      output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat\n+                      serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\n+\n+  Stage: Stage-0\n+    Fetch Operator\n+      limit: -1\n+      Processor Tree:\n+        ListSink\n+\n+PREHOOK: query: prepare pbetween from\n+select count(*) from alltypes where (c BETWEEN ? AND ?) AND (v BETWEEN ? AND ?) AND (d BETWEEN ? AND ?) AND (dt BETWEEN ? AND ?) OR (ctinyint BETWEEN ? AND ?) AND (csmallint BETWEEN ? AND ?) AND (cint BETWEEN ? AND ?)\n+    AND (cfloat BETWEEN ? AND ?) AND (cdouble BETWEEN ? AND ?) OR (cstring1 BETWEEN ? AND ?)  AND (ctimestamp1 BETWEEN ? AND ?) OR (cbigint BETWEEN ? AND ?)\n+PREHOOK: type: EXECUTE QUERY\n+PREHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+POSTHOOK: query: prepare pbetween from\n+select count(*) from alltypes where (c BETWEEN ? AND ?) AND (v BETWEEN ? AND ?) AND (d BETWEEN ? AND ?) AND (dt BETWEEN ? AND ?) OR (ctinyint BETWEEN ? AND ?) AND (csmallint BETWEEN ? AND ?) AND (cint BETWEEN ? AND ?)\n+    AND (cfloat BETWEEN ? AND ?) AND (cdouble BETWEEN ? AND ?) OR (cstring1 BETWEEN ? AND ?)  AND (ctimestamp1 BETWEEN ? AND ?) OR (cbigint BETWEEN ? AND ?)\n+POSTHOOK: type: EXECUTE QUERY\n+POSTHOOK: Input: default@alltypes\n+#### A masked pattern was here ####\n+18346", "originalCommit": "a2b2eb0a70a794228b866d19a8b4d781d6e8f370", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzMTk3NA==", "url": "https://github.com/apache/hive/pull/1315#discussion_r466531974", "bodyText": "Yes these results are verified with non-execute query", "author": "vineetgarg02", "createdAt": "2020-08-06T16:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4ODA1Mg=="}], "type": "inlineReview"}, {"oid": "2a4327dad0a9f9221684c319d8e0dec448897377", "url": "https://github.com/apache/hive/commit/2a4327dad0a9f9221684c319d8e0dec448897377", "message": "review comments + test update", "committedDate": "2020-08-06T17:12:58Z", "type": "commit"}]}