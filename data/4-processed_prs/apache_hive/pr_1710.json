{"pr_number": 1710, "pr_title": "HIVE-24432: Delete Notification Events in Batches", "pr_createdAt": "2020-11-25T20:55:00Z", "pr_url": "https://github.com/apache/hive/pull/1710", "timeline": [{"oid": "edfda1a5ac9389a8e1328235763cd2c441856fd5", "url": "https://github.com/apache/hive/commit/edfda1a5ac9389a8e1328235763cd2c441856fd5", "message": "HIVE-24432: Delete Notification Events in Batches", "committedDate": "2020-11-25T20:54:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MDc2Mg==", "url": "https://github.com/apache/hive/pull/1710#discussion_r539040762", "bodyText": "Is the comparison required? events will always be in ascending order of event id", "author": "aasha", "createdAt": "2020-12-09T06:23:30Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/ObjectStore.java", "diffHunk": "@@ -10800,53 +10801,89 @@ public void addNotificationEvent(NotificationEvent entry) throws MetaException {\n \n   @Override\n   public void cleanNotificationEvents(int olderThan) {\n-    boolean commited = false;\n-    Query query = null;\n+    final int eventBatchSize = MetastoreConf.getIntVar(conf, MetastoreConf.ConfVars.EVENT_CLEAN_MAX_EVENTS);\n+\n+    final long ageSec = olderThan;\n+    final Instant now = Instant.now();\n+\n+    final int tooOld = Math.toIntExact(now.getEpochSecond() - ageSec);\n+\n+    final Optional<Integer> batchSize = (eventBatchSize > 0) ? Optional.of(eventBatchSize) : Optional.empty();\n+\n+    final long start = System.nanoTime();\n+    int deleteCount = doCleanNotificationEvents(tooOld, batchSize);\n+\n+    if (deleteCount == 0) {\n+      LOG.info(\"No Notification events found to be cleaned with eventTime < {}\", tooOld);\n+    } else {\n+      int batchCount = 0;\n+      do {\n+        batchCount = doCleanNotificationEvents(tooOld, batchSize);\n+        deleteCount += batchCount;\n+      } while (batchCount > 0);\n+    }\n+\n+    final long finish = System.nanoTime();\n+\n+    LOG.info(\"Deleted {} notification events older than epoch:{} in {}ms\", deleteCount, tooOld,\n+        TimeUnit.NANOSECONDS.toMillis(finish - start));\n+  }\n+\n+  private int doCleanNotificationEvents(final int ageSec, final Optional<Integer> batchSize) {\n+    final Transaction tx = pm.currentTransaction();\n+    int eventsCount = 0;\n+\n     try {\n-      openTransaction();\n-      long tmp = System.currentTimeMillis() / 1000 - olderThan;\n-      int tooOld = (tmp > Integer.MAX_VALUE) ? 0 : (int) tmp;\n-      query = pm.newQuery(MNotificationLog.class, \"eventTime < tooOld\");\n-      query.declareParameters(\"java.lang.Integer tooOld\");\n+      tx.begin();\n \n-      int max_events = MetastoreConf.getIntVar(conf, MetastoreConf.ConfVars.EVENT_CLEAN_MAX_EVENTS);\n-      max_events = max_events > 0 ? max_events : Integer.MAX_VALUE;\n-      query.setRange(0, max_events);\n-      query.setOrdering(\"eventId ascending\");\n+      try (Query query = pm.newQuery(MNotificationLog.class, \"eventTime < tooOld\")) {\n+        query.declareParameters(\"java.lang.Integer tooOld\");\n+        query.setOrdering(\"eventId ascending\");\n+        if (batchSize.isPresent()) {\n+          query.setRange(0, batchSize.get());\n+        }\n \n-      List<MNotificationLog> toBeRemoved = (List) query.execute(tooOld);\n-      int iteration = 0;\n-      int eventCount = 0;\n-      long minEventId = 0;\n-      long minEventTime = 0;\n-      long maxEventId = 0;\n-      long maxEventTime = 0;\n-      while (CollectionUtils.isNotEmpty(toBeRemoved)) {\n-        int listSize = toBeRemoved.size();\n-        if (iteration == 0) {\n-          MNotificationLog firstNotification = toBeRemoved.get(0);\n-          minEventId = firstNotification.getEventId();\n-          minEventTime = firstNotification.getEventTime();\n+        List<MNotificationLog> events = (List) query.execute(ageSec);\n+        if (CollectionUtils.isNotEmpty(events)) {\n+          eventsCount = events.size();\n+\n+          if (LOG.isDebugEnabled()) {\n+            int minEventTime, maxEventTime;\n+            long minEventId, maxEventId;\n+            Iterator<MNotificationLog> iter = events.iterator();\n+            MNotificationLog firstNotification = iter.next();\n+\n+            minEventTime = maxEventTime = firstNotification.getEventTime();\n+            minEventId = maxEventId = firstNotification.getEventId();\n+\n+            while (iter.hasNext()) {\n+              MNotificationLog notification = iter.next();", "originalCommit": "edfda1a5ac9389a8e1328235763cd2c441856fd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk4MTczOQ==", "url": "https://github.com/apache/hive/pull/1710#discussion_r540981739", "bodyText": "Hey, so this goes back to the discussion I had over here... PR #1728\nThere is really no guarantee that the eventTime is always increasing.  So, the ID is always increasing, but if the min/max eventTime are to be discovered for each batch, then it needs to iterate.  I'm happy to remove the logging and remove the iteration, but that was already in place and I didn't want to remove.\nEdit: This is an out-of-band process that doesn't block anything else, so a few extra CPU cycles isn't the end of the world.", "author": "belugabehr", "createdAt": "2020-12-11T14:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MDc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk4NDkzOQ==", "url": "https://github.com/apache/hive/pull/1710#discussion_r540984939", "bodyText": "If you are speaking about the eventId portion only, then yes, one could look at the first and last item.  Since the list needs to be iterated anyway, might as well just keep it simple and consistent with regards to how min/max is determined.", "author": "belugabehr", "createdAt": "2020-12-11T14:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MDc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0OTY5OA==", "url": "https://github.com/apache/hive/pull/1710#discussion_r541149698", "bodyText": "@aasha I updated existing unit tests to enforce small batch sizes (size = 1) so that when it deletes records, it does so in batches of 1.", "author": "belugabehr", "createdAt": "2020-12-11T18:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MDc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzMDk4Nw==", "url": "https://github.com/apache/hive/pull/1710#discussion_r539130987", "bodyText": "The same improvement done in cleanNotificationEvents can be applied to cleanWriteNotificationEvents also.", "author": "aasha", "createdAt": "2020-12-09T09:09:11Z", "path": "standalone-metastore/metastore-server/src/main/java/org/apache/hadoop/hive/metastore/ObjectStore.java", "diffHunk": "@@ -10800,53 +10801,89 @@ public void addNotificationEvent(NotificationEvent entry) throws MetaException {\n \n   @Override\n   public void cleanNotificationEvents(int olderThan) {", "originalCommit": "edfda1a5ac9389a8e1328235763cd2c441856fd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk4MDAxMw==", "url": "https://github.com/apache/hive/pull/1710#discussion_r540980013", "bodyText": "Will do in separate JIRA after this new code gets some usage.", "author": "belugabehr", "createdAt": "2020-12-11T14:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzMDk4Nw=="}], "type": "inlineReview"}, {"oid": "108a7c1d8f3776c1735d6b8615bb7ea8cee4bc1f", "url": "https://github.com/apache/hive/commit/108a7c1d8f3776c1735d6b8615bb7ea8cee4bc1f", "message": "Update test to exercise batching code. Make TTL LTE operation", "committedDate": "2020-12-11T14:48:51Z", "type": "commit"}]}