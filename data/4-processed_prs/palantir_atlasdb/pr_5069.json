{"pr_number": 5069, "pr_title": "Leader Election Metrics 1b: Estimate Leader Election Duration", "pr_createdAt": "2020-10-21T23:01:29Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5069", "timeline": [{"oid": "b793264682bb075a7c5a779d5dc334a4302fad95", "url": "https://github.com/palantir/atlasdb/commit/b793264682bb075a7c5a779d5dc334a4302fad95", "message": "Transfer changes from other branches", "committedDate": "2020-10-21T09:27:36Z", "type": "commit"}, {"oid": "ee6bb046be4501552fe35f873a4fade024c877b8", "url": "https://github.com/palantir/atlasdb/commit/ee6bb046be4501552fe35f873a4fade024c877b8", "message": "Pull in the right things", "committedDate": "2020-10-21T14:12:34Z", "type": "commit"}, {"oid": "7d4669f0c72d8fb4a0fad8bc0afb94d414faa88b", "url": "https://github.com/palantir/atlasdb/commit/7d4669f0c72d8fb4a0fad8bc0afb94d414faa88b", "message": "Merge branch 'develop' into le/client-i", "committedDate": "2020-10-21T15:12:01Z", "type": "commit"}, {"oid": "48a3db4d3a5b0bd5f05a87b9d0856c55a8d09738", "url": "https://github.com/palantir/atlasdb/commit/48a3db4d3a5b0bd5f05a87b9d0856c55a8d09738", "message": "rename", "committedDate": "2020-10-21T15:25:12Z", "type": "commit"}, {"oid": "d1f7fa37374952504467f157c810a015c2a507d3", "url": "https://github.com/palantir/atlasdb/commit/d1f7fa37374952504467f157c810a015c2a507d3", "message": "Implementation and some tests", "committedDate": "2020-10-21T22:53:36Z", "type": "commit"}, {"oid": "3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "url": "https://github.com/palantir/atlasdb/commit/3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "message": "Should fix tests", "committedDate": "2020-10-22T08:39:58Z", "type": "commit"}, {"oid": "1c33135c2cf946bed86c415df29eab145cf3fcf5", "url": "https://github.com/palantir/atlasdb/commit/1c33135c2cf946bed86c415df29eab145cf3fcf5", "message": "Make tests great again", "committedDate": "2020-10-22T09:37:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNjU5NQ==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510016595", "bodyText": "IMO this is pretty hard to take in. My understanding of it is as follows:\n\nLower and upper bound are referring to the temporal bounds of when A is the leader (I don't think that's really mentioned explicitly, and it's not obvious just from the text here).\nLower bound is the first successful response from leader A;\nUpper bound is the last successful request to leader A.\n\nWhile what you've said is true for a single request/response pair, it's quite unintuitive reasoning on that scale.", "author": "Jolyon-S", "createdAt": "2020-10-22T09:29:56Z", "path": "lock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java", "diffHunk": "@@ -122,6 +140,129 @@ public ConjureStartTransactionsResponse startTransactions(ConjureStartTransactio\n         return election && (currentLeader != null);\n     }\n \n+    /**\n+     * Estimating the duration of leader election:\n+     *\n+     * If a request is sent out at time T_1, and a response arrives at time T_2 with the id of leader A, we can\n+     * deduce three things:\n+     *   1. A could not have lost leadership before T_1 if it was the leader before it (upper bound)\n+     *   2. A must have gained leadership before T_2 (lower bound)\n+     *   3. A was the leader at least in some point in the interval [T_1, T_2]\n+     * Although from just one request, the lower bound is greater than the upper bound, after multiple responses that\n+     * is generally not going to be the case anymore.", "originalCommit": "3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA2Njc5Ng==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510066796", "bodyText": "It's literally said in 1 and 2:\nA could not have lost leadership before T_1\nA must have gained leadership before T_2\nBut yeah, maybe upper bound is confusing as it is not an upper bound on A's leadership, it's the best underapproximation of the leadership end time we can make with known information. Same for the lower bound, it's the best overaproximation of the leadership start time that we can make with known information. That is however, quite wordy...", "author": "gmaretic", "createdAt": "2020-10-22T10:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNjU5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDEyNDg0Ng==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510124846", "bodyText": "Yes, I can read that, but reasoning over a single request/response pair doesn't really make a lot of sense mentally (at least, not to me), even if what you have written is correct. The other thing is that you didn't really say what the bound if of - it could refer to bounding when the time when A was the leader, or refer to the moment when A lost leadership. It might sound obvious, but in my opinion it is best to be as explicit as possible here so that someone without all context can read this with minimal frustration.", "author": "Jolyon-S", "createdAt": "2020-10-22T12:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxNjU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAyMDYwNA==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510020604", "bodyText": "I think this is right, but was also pretty hard to reason through - I had to write it out as above to verify that this works.\nWe're definitely going to want some solid ETE tests here to make sure that this is right. Fortunately, the cost of failure here is just dodgy metrics, so an ETE test in a separate PR is fine, but we'll still want to verify this logic.", "author": "Jolyon-S", "createdAt": "2020-10-22T09:36:00Z", "path": "lock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java", "diffHunk": "@@ -122,6 +140,129 @@ public ConjureStartTransactionsResponse startTransactions(ConjureStartTransactio\n         return election && (currentLeader != null);\n     }\n \n+    /**\n+     * Estimating the duration of leader election:\n+     *\n+     * If a request is sent out at time T_1, and a response arrives at time T_2 with the id of leader A, we can\n+     * deduce three things:\n+     *   1. A could not have lost leadership before T_1 if it was the leader before it (upper bound)\n+     *   2. A must have gained leadership before T_2 (lower bound)\n+     *   3. A was the leader at least in some point in the interval [T_1, T_2]\n+     * Although from just one request, the lower bound is greater than the upper bound, after multiple responses that\n+     * is generally not going to be the case anymore.\n+     *\n+     * Ordering leaderships:\n+     * Let L_A and U_A be the lower and upper bound, respectively, of leader A, and let L_B and U_B be the respective\n+     * bounds of leader B. We distinguish 3 cases:\n+     *   1. (L_A < U_A && L_B < U_B): for both leaders there is an interval of guaranteed leadership, which by\n+     *   definitions cannot overlap. It is therefore trivial to order leadership of A and B.\n+     *   2. (w.l.o.g. L_A < U_A && L_B >= U_B):\n+     *      a) if U_B > U_A, A was the leader before B\n+     *      b) if L_B < L_A, B was the leader before A\n+     *      c) otherwise, we cannot determine the ordering\n+     *   3. (L_A >= U_A && L_B >= U_B):\n+     *      a) if U_B > L_A, A was the leader before B\n+     *      b) if U_A > L_B, B was the leader before A\n+     *      c) otherwise, we cannot determine the ordering", "originalCommit": "3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA2NzAzNQ==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510067035", "bodyText": "That's not how mathematical proofs work", "author": "gmaretic", "createdAt": "2020-10-22T10:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAyMDYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDEyMzczMw==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510123733", "bodyText": "I know, but it would be nice to verify that your code actually works as intended here (unless you want to write a proof that your code is the same here too?)", "author": "Jolyon-S", "createdAt": "2020-10-22T12:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAyMDYwNA=="}], "type": "inlineReview"}, {"oid": "cf458d26cce07fe45302d80a57a03d86bf06fd4c", "url": "https://github.com/palantir/atlasdb/commit/cf458d26cce07fe45302d80a57a03d86bf06fd4c", "message": "Merge with develop", "committedDate": "2020-10-22T14:52:48Z", "type": "commit"}, {"oid": "a3793e6f2fcf9257237d623e0b05b1f6be3f73a6", "url": "https://github.com/palantir/atlasdb/commit/a3793e6f2fcf9257237d623e0b05b1f6be3f73a6", "message": "Bleh", "committedDate": "2020-10-22T16:09:08Z", "type": "commit"}, {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "url": "https://github.com/palantir/atlasdb/commit/133bfa79b08a664ddabf141187edbaa8066ccb3c", "message": "Cleanup, more tests", "committedDate": "2020-10-23T09:51:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4MjM4Ng==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510782386", "bodyText": "Can you just pair this check with the isEmpty one? e.g.\nif (sortedLongTermLeaders.isEmpty() || sortedLongTermLeaders.size()` == 1) {", "author": "Jolyon-S", "createdAt": "2020-10-23T10:15:18Z", "path": "lock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java", "diffHunk": "@@ -122,6 +144,120 @@ public ConjureStartTransactionsResponse startTransactions(ConjureStartTransactio\n         return election && (currentLeader != null);\n     }\n \n+    /**\n+     * Estimating the duration of leader election:\n+     *\n+     * If a request is sent out at time T_1, and a response arrives at time T_2 with the id of leader A, we can\n+     * deduce three things:\n+     *   1. A could not have lost leadership before T_1 if it was the leader before it (upper bound)\n+     *   2. A must have gained leadership before T_2 (lower bound)\n+     *   3. A was the leader at least in some point in the interval [T_1, T_2]\n+     * T_1 is the upper bound in the sense that if we know that A was the leader before T_1, we know for certain it was\n+     * still the leader until T_1. Similarly, T_2 is the lower bound in the sense that if A was not the leader at any\n+     * point after T_2, it was certainly the leader at T_2. This is slightly counter-intuitive with just a single\n+     * request, since T_1 < T_2, but as soon as another response is received such that T_1' > T_2, we can determine an\n+     * interval [T_2, T_1'] when A was definitely the leader. Let us denote this interval by [L_A, U_A] and call A a\n+     * long term leader.\n+     *\n+     * Last leader election:\n+     * Given that the lower and upper bound for a leader are updated with each response from that leader, it is\n+     * unlikely that any leader is not going to be a long term leader except in the initial moments after leadership\n+     * has been acquired. We will therefore observe the last two leaderships where the older leader A has had enough\n+     * data points so that L_A < U_A, while the newer leader B is allowed to not have become a long term leader yet.\n+     *\n+     * Ordering leaderships:\n+     * Let A be a long term leader and let B another leader. We distinguish 2 cases:\n+     *   1. (B is a long term leader): for both leaders there is an interval of guaranteed leadership, which by\n+     *   definition cannot overlap. It is therefore trivial to order leadership of A and B.\n+     *   2. (B is not a long term leader yet, i.e., L_B >= U_B):\n+     *      a) if U_B > U_A, A was the leader before B\n+     *      b) if L_B < L_A, B was the leader before A\n+     *      c) otherwise, we cannot determine the ordering\n+     *\n+     * Calculating the estimate:\n+     * Let A be a long term leader let L be the minimal lower bound of all leaders that became leaders after A as\n+     * described in 1) and 2b). The estimated (over-approximated) duration of the leadership election is then\n+     * given by the duration between U_A and L, since L is the latest possible moment at which another leader was\n+     * elected while U_A is the earliest moment at which A could have lost leadership. This method will always return\n+     * the duration of the most recent such interval.\n+     */\n+    public Optional<Duration> calculateLastLeaderElectionDuration() {\n+        Map<UUID, Instant> lowerBounds = ImmutableMap.copyOf(leadershipLowerBound.entrySet());\n+        Map<UUID, Instant> upperBounds = ImmutableMap.copyOf(leadershipUpperBound.entrySet());\n+\n+        Set<UUID> leaders = leadersWithBothBounds(lowerBounds, upperBounds);\n+        List<UUID> sortedLongTermLeaders = orderedLongTermLeaders(lowerBounds, upperBounds, leaders);\n+        clearOldLongTermLeaders(sortedLongTermLeaders);\n+\n+        if (sortedLongTermLeaders.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        UUID lastLongTermLeader = sortedLongTermLeaders.get(sortedLongTermLeaders.size() - 1);\n+\n+        Optional<Duration> result = durationToNextLeader(lowerBounds, upperBounds, leaders, lastLongTermLeader);\n+        if (result.isPresent()) {\n+            return result;\n+        }\n+\n+        if (sortedLongTermLeaders.size() == 1) {", "originalCommit": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NDcxOQ==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510784719", "bodyText": "hm - given that the second call returns at 6L, why is the expected duration not 6L -> 15L? I realise that I'm probably misunderstanding your massive and lengthy explanation above, but when laid out this way, it just seems weird", "author": "Jolyon-S", "createdAt": "2020-10-23T10:19:24Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));", "originalCommit": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwNDMzMQ==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510904331", "bodyText": "I think the theory here is that we want to have an upper bound, and what could have happened is\nT = 3, A makes request\nT = 3 + epsilon, the leadership check on timelock passes, and timelock starts running the actual code that was protected by a leader election service\nT = 3 + epsilon + mu, current timelock loses leadership / election begins\nT = 6, the response finally comes back (note: this looks spooky but is allowed)\nIn general, if you have a request running 3 to 6 and this is the last request you know about that had a leader A, you know that the election didn't begin before 3, but you don't know that the election hadn't begun at any point after 3.", "author": "jeremyk-91", "createdAt": "2020-10-23T14:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NDcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkzMjY2MA==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510932660", "bodyText": "When you put it that way, it's obvious - the upper bound here being the last successfully sent request. Thanks!", "author": "Jolyon-S", "createdAt": "2020-10-23T14:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NTc5Mw==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510785793", "bodyText": "start of B is after that last A call, so you should make the ASCII overlap", "author": "Jolyon-S", "createdAt": "2020-10-23T10:21:23Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                     [ B ]\n+     *           <=============>", "originalCommit": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NjUyMA==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510786520", "bodyText": "21 is the start of the second B call, so presumably this arrow should represent that?", "author": "Jolyon-S", "createdAt": "2020-10-23T10:22:52Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                     [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(6L, 10L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 15L, LEADER_1),\n+                ImmutableSingleCall.of(14L, 21L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(6L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithTwoLongTermLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *                         [ C ]\n+     *             <===============>", "originalCommit": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4NjY3OQ==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510786679", "bodyText": "nit: LongTerm?", "author": "Jolyon-S", "createdAt": "2020-10-23T10:23:09Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                     [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(6L, 10L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 15L, LEADER_1),\n+                ImmutableSingleCall.of(14L, 21L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(6L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithTwoLongTermLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *                         [ C ]\n+     *             <===============>\n+     */\n+    @Test\n+    public void detectFreshLeaderElectionWithTwoLongTurnLeaders() {", "originalCommit": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc4ODExMQ==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510788111", "bodyText": "I think the arrow is one short", "author": "Jolyon-S", "createdAt": "2020-10-23T10:25:42Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                     [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(6L, 10L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 15L, LEADER_1),\n+                ImmutableSingleCall.of(14L, 21L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(6L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithTwoLongTermLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *                         [ C ]\n+     *             <===============>\n+     */\n+    @Test\n+    public void detectFreshLeaderElectionWithTwoLongTurnLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2),\n+                ImmutableSingleCall.of(36L, 45L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(21L), Instant.ofEpochMilli(45L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *                [ B ]\n+     *             [    A    ]\n+     *             <======>\n+     */\n+    @Test\n+    public void updateOldLeaderUpperBoundWithNewRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(15L, 21L, LEADER_2),\n+                ImmutableSingleCall.of(10L, 28L, LEADER_1));\n+        assertExpectedDuration(Instant.ofEpochMilli(10L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ C ]\n+     *                         [ C ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectFirstLeaderElectionFromLongTermLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_3),\n+                ImmutableSingleCall.of(36L, 45L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [       B       ]\n+     *                [ C ]\n+     *                      [ C ]\n+     *       <===========>", "originalCommit": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5e99024ebe65fc2047460d8afec49fe56b96121b", "url": "https://github.com/palantir/atlasdb/commit/5e99024ebe65fc2047460d8afec49fe56b96121b", "message": "CR comments", "committedDate": "2020-10-23T11:10:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwMTg2OA==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510901868", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Let A be a long term leader let L be the minimal lower bound of all leaders that became leaders after A as\n          \n          \n            \n                 * Let A be a long term leader and let L be the minimal lower bound of all leaders that became leaders after A as", "author": "jeremyk-91", "createdAt": "2020-10-23T13:56:24Z", "path": "lock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java", "diffHunk": "@@ -122,6 +144,116 @@ public ConjureStartTransactionsResponse startTransactions(ConjureStartTransactio\n         return election && (currentLeader != null);\n     }\n \n+    /**\n+     * Estimating the duration of leader election:\n+     *\n+     * If a request is sent out at time T_1, and a response arrives at time T_2 with the id of leader A, we can\n+     * deduce three things:\n+     *   1. A could not have lost leadership before T_1 if it was the leader before it (upper bound)\n+     *   2. A must have gained leadership before T_2 (lower bound)\n+     *   3. A was the leader at least in some point in the interval [T_1, T_2]\n+     * T_1 is the upper bound in the sense that if we know that A was the leader before T_1, we know for certain it was\n+     * still the leader until T_1. Similarly, T_2 is the lower bound in the sense that if A was not the leader at any\n+     * point after T_2, it was certainly the leader at T_2. This is slightly counter-intuitive with just a single\n+     * request, since T_1 < T_2, but as soon as another response is received such that T_1' > T_2, we can determine an\n+     * interval [T_2, T_1'] when A was definitely the leader. Let us denote this interval by [L_A, U_A] and call A a\n+     * long term leader.\n+     *\n+     * Last leader election:\n+     * Given that the lower and upper bound for a leader are updated with each response from that leader, it is\n+     * unlikely that any leader is not going to be a long term leader except in the initial moments after leadership\n+     * has been acquired. We will therefore observe the last two leaderships where the older leader A has had enough\n+     * data points so that L_A < U_A, while the newer leader B is allowed to not have become a long term leader yet.\n+     *\n+     * Ordering leaderships:\n+     * Let A be a long term leader and let B another leader. We distinguish 2 cases:\n+     *   1. (B is a long term leader): for both leaders there is an interval of guaranteed leadership, which by\n+     *   definition cannot overlap. It is therefore trivial to order leadership of A and B.\n+     *   2. (B is not a long term leader yet, i.e., L_B >= U_B):\n+     *      a) if U_B > U_A, A was the leader before B\n+     *      b) if L_B < L_A, B was the leader before A\n+     *      c) otherwise, we cannot determine the ordering\n+     *\n+     * Calculating the estimate:\n+     * Let A be a long term leader let L be the minimal lower bound of all leaders that became leaders after A as", "originalCommit": "5e99024ebe65fc2047460d8afec49fe56b96121b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkwNTYzMw==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510905633", "bodyText": "this is clever. Thanks a lot for the ASCII art, really helps convey what's going on", "author": "jeremyk-91", "createdAt": "2020-10-23T14:01:56Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                  [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(6L, 10L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 15L, LEADER_1),\n+                ImmutableSingleCall.of(14L, 21L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(6L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithTwoLongTermLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ B ]\n+     *                         [ C ]\n+     *                   <=========>\n+     */\n+    @Test\n+    public void detectFreshLeaderElectionWithTwoLongTurnLeaders() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_2),\n+                ImmutableSingleCall.of(36L, 45L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(21L), Instant.ofEpochMilli(45L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *                [ B ]\n+     *             [    A    ]\n+     *             <======>\n+     */\n+    @Test\n+    public void updateOldLeaderUpperBoundWithNewRequests() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(15L, 21L, LEADER_2),\n+                ImmutableSingleCall.of(10L, 28L, LEADER_1));\n+        assertExpectedDuration(Instant.ofEpochMilli(10L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *                   [ C ]\n+     *                         [ C ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectFirstLeaderElectionFromLongTermLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_3),\n+                ImmutableSingleCall.of(36L, 45L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [       B       ]\n+     *                [ C ]\n+     *                      [ C ]\n+     *       <============>\n+     */\n+    @Test\n+    public void detectFirstLeaderElectionFromLongTermLeaderWithSlowRequest() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 45L, LEADER_2),\n+                ImmutableSingleCall.of(15L, 21L, LEADER_3),\n+                ImmutableSingleCall.of(28L, 36L, LEADER_3));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(21L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [        B       ]\n+     *          [ C ]\n+     *                 [ C ]\n+     */\n+    @Test\n+    public void doNotCalculateLeadershipBeforeFirstLongTermLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 36L, LEADER_2),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_3),\n+                ImmutableSingleCall.of(21L, 28L, LEADER_3));\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isEmpty();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [        A       ]\n+     *          [ C ]\n+     *                 [ C ]\n+     *       <======>", "originalCommit": "5e99024ebe65fc2047460d8afec49fe56b96121b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkxMDc3OA==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510910778", "bodyText": "This should end at the end of B, surely", "author": "jeremyk-91", "createdAt": "2020-10-23T14:09:48Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                  [ B ]\n+     *           <=============>", "originalCommit": "5e99024ebe65fc2047460d8afec49fe56b96121b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkxMTQ2MA==", "url": "https://github.com/palantir/atlasdb/pull/5069#discussion_r510911460", "bodyText": "Could we have one for overlapping but non-consuming?\ni.e.\n[         A         ]\n               [         A        ]\n                          [         B     ]\n               <==========================>", "author": "jeremyk-91", "createdAt": "2020-10-23T14:10:44Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -101,4 +115,207 @@ public void leaderIsInitialisedForAllMethods() {\n         verify(mockedRegistry).timer(any());\n         verify(mockedTimer).update(anyLong(), any());\n     }\n+\n+    @Test\n+    public void noLeaderElectionDurationBeforeLeaderElection() {\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.startTransactions(startTransactionsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+\n+        timelockService.getCommitTimestamps(commitTimestampsRequest);\n+        assertThat(timelockService.calculateLastLeaderElectionDuration()).isNotPresent();\n+    }\n+\n+    /**\n+     * [ A ]\n+     *       [ A ]\n+     *             [ B ]\n+     *       <=========>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeader() {\n+        executeCalls(\n+                ImmutableSingleCall.of(0L, 1L, LEADER_1),\n+                ImmutableSingleCall.of(3L, 6L, LEADER_1),\n+                ImmutableSingleCall.of(10L, 15L, LEADER_2));\n+        assertExpectedDuration(Instant.ofEpochMilli(3L), Instant.ofEpochMilli(15L));\n+    }\n+\n+    /**\n+     * [ A ]\n+     *           [ A ]\n+     *       [     A     ]\n+     *                  [ B ]\n+     *           <=============>\n+     */\n+    @Test\n+    public void detectLeaderElectionWithFreshLeaderOverlappingRequests() {", "originalCommit": "5e99024ebe65fc2047460d8afec49fe56b96121b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2a83f1aed3773999d3ec69d4aba13e829bcd9c0b", "url": "https://github.com/palantir/atlasdb/commit/2a83f1aed3773999d3ec69d4aba13e829bcd9c0b", "message": "CR fixes", "committedDate": "2020-10-23T15:27:13Z", "type": "commit"}]}