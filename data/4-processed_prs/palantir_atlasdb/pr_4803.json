{"pr_number": 4803, "pr_title": "[PDS-120786, PaxosLog] Avoid Overhead From Repeatedly Taking Locks And Starting New Connections", "pr_createdAt": "2020-05-26T20:11:24Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4803", "timeline": [{"oid": "7236068cf0e85849efff7702f2568d0ff286fd15", "url": "https://github.com/palantir/atlasdb/commit/7236068cf0e85849efff7702f2568d0ff286fd15", "message": "Use a single shared connection to SQLite to avoid unnecessary overheads", "committedDate": "2020-05-26T15:16:45Z", "type": "commit"}, {"oid": "57dd9eb85ca816e22bf249f99946645f5bad1803", "url": "https://github.com/palantir/atlasdb/commit/57dd9eb85ca816e22bf249f99946645f5bad1803", "message": "SqliteConns", "committedDate": "2020-05-26T16:10:14Z", "type": "commit"}, {"oid": "dc65f91cc4f6500beeaebe330ee5ac2c30d084ce", "url": "https://github.com/palantir/atlasdb/commit/dc65f91cc4f6500beeaebe330ee5ac2c30d084ce", "message": "Evil evil proxy", "committedDate": "2020-05-26T16:10:20Z", "type": "commit"}, {"oid": "be786af50424a2f622f280cb368ef782274ef303", "url": "https://github.com/palantir/atlasdb/commit/be786af50424a2f622f280cb368ef782274ef303", "message": "Add unit tests for proxy and fix checkstyle", "committedDate": "2020-05-26T17:03:05Z", "type": "commit"}, {"oid": "4ba7a1268e4cebcab7a597b143c84ef53756e485", "url": "https://github.com/palantir/atlasdb/commit/4ba7a1268e4cebcab7a597b143c84ef53756e485", "message": "Add generated changelog entries", "committedDate": "2020-05-26T17:03:05Z", "type": "commit"}, {"oid": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c", "url": "https://github.com/palantir/atlasdb/commit/bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c", "message": "Overhaul", "committedDate": "2020-05-27T10:10:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431013244", "bodyText": "can we have this be more than 1? Say 16?", "author": "j-baker", "createdAt": "2020-05-27T10:22:26Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());\n+\n         SQLiteConnectionPoolDataSource dataSource = new SQLiteConnectionPoolDataSource();\n         dataSource.setUrl(target);\n         dataSource.setConfig(config);\n \n-        return () -> {\n-            try {\n-                return dataSource.getConnection();\n-            } catch (SQLException e) {\n-                throw new RuntimeException(e);\n-            }\n-        };\n+        HikariConfig hikariConfig = new HikariConfig();\n+        hikariConfig.setDataSource(dataSource);\n+        hikariConfig.setMaximumPoolSize(1);", "originalCommit": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzM1Nw==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431013357", "bodyText": "Like 1 just seems wrong.", "author": "j-baker", "createdAt": "2020-05-27T10:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzg1MQ==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431013851", "bodyText": "(and maybe remove the locking mode exclusive pragma if that breaks things)", "author": "j-baker", "createdAt": "2020-05-27T10:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNzM1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431017356", "bodyText": "Like, just to be clear here: 1 means that you'll only have one query in flight to SQLite at a time (depending on how sqlite is implemented), which seems strictly worse than shared locking, if that is used.", "author": "j-baker", "createdAt": "2020-05-27T10:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyMTk1OA==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431021958", "bodyText": "That's a good point, having more than 1 connection and removing exclusive locking means we can do parallel reads", "author": "gmaretic", "createdAt": "2020-05-27T10:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NjcxMA==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431056710", "bodyText": "Yeah, in hindsight our tests probably overindexed on writes (which might be fair given that migration specifically has been causing us pain).", "author": "jeremyk-91", "createdAt": "2020-05-27T11:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzk5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431013993", "bodyText": "don't you want EXTRA here?", "author": "j-baker", "createdAt": "2020-05-27T10:23:49Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());", "originalCommit": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxODI1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431018256", "bodyText": "The enum didn't exist in the java driver. I've set it to the string, not sure there's a better solution.", "author": "jeremyk-91", "createdAt": "2020-05-27T10:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNDg0Mw==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431014843", "bodyText": "this seems like a code smell. Why can't the datasource be injected?", "author": "j-baker", "createdAt": "2020-05-27T10:25:15Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()", "originalCommit": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NzE1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431057156", "bodyText": "Ah, yes this makes sense. We should have been more aggressive about refactoring the structures we hackily built to get the benchmarks green.", "author": "jeremyk-91", "createdAt": "2020-05-27T11:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNDg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNDk4NA==", "url": "https://github.com/palantir/atlasdb/pull/4803#discussion_r431014984", "bodyText": "This is much better \ud83c\udf89", "author": "gmaretic", "createdAt": "2020-05-27T10:25:30Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqliteConnections.java", "diffHunk": "@@ -18,46 +18,54 @@\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.sql.Connection;\n-import java.sql.SQLException;\n-import java.util.function.Supplier;\n+\n+import javax.sql.DataSource;\n \n import org.apache.commons.io.FileUtils;\n import org.sqlite.SQLiteConfig;\n import org.sqlite.javax.SQLiteConnectionPoolDataSource;\n \n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n import com.palantir.logsafe.SafeArg;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+import com.zaxxer.hikari.HikariConfig;\n+import com.zaxxer.hikari.HikariDataSource;\n \n /**\n  * This class is responsible for creating Sqlite connections to an instance.\n  * There should be one instance per timelock.\n  */\n public final class SqliteConnections {\n     private static final String DEFAULT_SQLITE_DATABASE_NAME = \"sqliteData.db\";\n+    private static final LoadingCache<Path, DataSource> DATA_SOURCE_LOADING_CACHE = Caffeine.newBuilder()\n+            .build(SqliteConnections::buildDataSource);\n \n     private SqliteConnections() {\n         // no\n     }\n \n-    public static Supplier<Connection> createDefaultNamedSqliteDatabaseAtPath(Path path) {\n+    public static DataSource getOrCreateDefaultDataSource(Path path) {\n+        return DATA_SOURCE_LOADING_CACHE.get(path);\n+    }\n+\n+    private static DataSource buildDataSource(Path path) {\n         createDirectoryIfNotExists(path);\n         String target = String.format(\"jdbc:sqlite:%s\", path.resolve(DEFAULT_SQLITE_DATABASE_NAME).toString());\n \n         SQLiteConfig config = new SQLiteConfig();\n         config.setPragma(SQLiteConfig.Pragma.JOURNAL_MODE, SQLiteConfig.JournalMode.WAL.getValue());\n-        config.setBusyTimeout(5000);\n+        config.setPragma(SQLiteConfig.Pragma.LOCKING_MODE, SQLiteConfig.LockingMode.EXCLUSIVE.getValue());\n+        config.setPragma(SQLiteConfig.Pragma.SYNCHRONOUS, SQLiteConfig.SynchronousMode.FULL.getValue());\n+\n         SQLiteConnectionPoolDataSource dataSource = new SQLiteConnectionPoolDataSource();\n         dataSource.setUrl(target);\n         dataSource.setConfig(config);\n \n-        return () -> {\n-            try {\n-                return dataSource.getConnection();\n-            } catch (SQLException e) {\n-                throw new RuntimeException(e);\n-            }\n-        };\n+        HikariConfig hikariConfig = new HikariConfig();\n+        hikariConfig.setDataSource(dataSource);\n+        hikariConfig.setMaximumPoolSize(1);\n+        return new HikariDataSource(hikariConfig);", "originalCommit": "bdfd9fbbcb51424e6508bdba1cf0c97856a5f82c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9f86608a448869b51ddd38783c15051cca50bacb", "url": "https://github.com/palantir/atlasdb/commit/9f86608a448869b51ddd38783c15051cca50bacb", "message": "Address CR", "committedDate": "2020-05-27T12:07:29Z", "type": "commit"}]}