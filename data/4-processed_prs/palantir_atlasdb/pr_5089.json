{"pr_number": 5089, "pr_title": "[TimeLock Corruption Detection] | Integration tests", "pr_createdAt": "2020-10-28T11:11:50Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5089", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5OTY0OA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513499648", "bodyText": "nit: final class?", "author": "Jolyon-S", "createdAt": "2020-10-28T14:41:26Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5OTkwOA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513499908", "bodyText": "nit: test name is hard to parse", "author": "Jolyon-S", "createdAt": "2020-10-28T14:41:45Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNTY0NQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513505645", "bodyText": "prefer Multimap", "author": "Jolyon-S", "createdAt": "2020-10-28T14:48:32Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogSeqInLaterBatches() {\n+        writeLogsOnLocalAndRemote(1, 1000);\n+        induceGreaterAcceptedValueCorruption(599);\n+\n+        // No signs of corruption in the first batch\n+        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNjI4NA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513506284", "bodyText": "minor nit: assertViolationsDetected", "author": "Jolyon-S", "createdAt": "2020-10-28T14:49:15Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public class CorruptionDetectionIntegrationTest extends TimeLockCorruptionTestSetup {\n+\n+    @Test\n+    public void detectCorruptionForLogAtSeqAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        writeLogsOnLocalAndRemote(1, 500);\n+        induceGreaterAcceptedValueCorruption(499);\n+        assertDetectedViolations(ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED));", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwOTc1OQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513509759", "bodyText": "also, split into two methods: some violations (and maybe can be specific), or no violation.", "author": "Jolyon-S", "createdAt": "2020-10-28T14:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNjI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxMzIzNw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513513237", "bodyText": "chatted offline - I personally don't like this structure of using abstract classes; would prefer if this was a final class that you call methods on directly.", "author": "Jolyon-S", "createdAt": "2020-10-28T14:57:12Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNDUzNA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513514534", "bodyText": "please remove this", "author": "Jolyon-S", "createdAt": "2020-10-28T14:58:47Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNDkwMQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r513514901", "bodyText": "IntelliJ is your friend; these probably? don't have to be protected", "author": "Jolyon-S", "createdAt": "2020-10-28T14:59:11Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.SetMultimap;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class TimeLockCorruptionTestSetup {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    protected static final NamespaceAndUseCase NAMESPACE_AND_USE_CASE =\n+            ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE);\n+\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+\n+    protected StateLogComponents localStateLogComponents;\n+    protected List<StateLogComponents> remoteStateLogComponents;\n+    protected PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        localStateLogComponents = createLogComponentsForServer(localDataSource);\n+        remoteStateLogComponents = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n+                localStateLogComponents.dataSource(),\n+                remoteStateLogComponents.stream()\n+                        .map(StateLogComponents::serverHistoryProvider)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    protected List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    // utils\n+    protected Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    protected StateLogComponents createLogComponentsForServer(\n+            DataSource dataSource, NamespaceAndUseCase namespaceAndUseCase) {\n+\n+        Client client = namespaceAndUseCase.namespace();\n+        String paxosUseCase = namespaceAndUseCase.useCase();\n+\n+        PaxosStateLog<PaxosValue> learnerLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        LearnerUseCase.createLearnerUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        PaxosStateLog<PaxosAcceptorState> acceptorLog = SqlitePaxosStateLog.create(\n+                ImmutableNamespaceAndUseCase.of(\n+                        client,\n+                        AcceptorUseCase.createAcceptorUseCase(paxosUseCase).value()),\n+                dataSource);\n+\n+        LocalHistoryLoader history = LocalHistoryLoader.create(SqlitePaxosStateLogHistory.create(dataSource));\n+        TimeLockPaxosHistoryProvider serverHistoryProvider = TimeLockPaxosHistoryProviderResource.jersey(history);\n+        return StateLogComponents.builder()\n+                .dataSource(dataSource)\n+                .learnerLog(learnerLog)\n+                .acceptorLog(acceptorLog)\n+                .history(history)\n+                .serverHistoryProvider(serverHistoryProvider)\n+                .build();\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(localStateLogComponents, corruptSeq);\n+    }\n+\n+    protected void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                ImmutableList.<StateLogComponents>builder()\n+                        .add(localStateLogComponents)\n+                        .addAll(remoteStateLogComponents)\n+                        .build(),\n+                startingLogSeq,\n+                latestLogSequence);\n+    }\n+\n+    protected void writeLogsOnLocalAndRemote(\n+            List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    protected SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        return HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll).violatingStatusesToNamespaceAndUseCase();\n+    }\n+\n+    protected void assertDetectedViolations(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertDetectedViolations(detectedViolations, ImmutableSet.of(NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    protected void assertDetectedViolations(", "originalCommit": "aa636be9a4844829b9d5aaad25c61428d1c701d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5NjM1OA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515096358", "bodyText": "nit: can we call this TimelockCorruptionTestConstants or similar? I know it is in the test project, but I'm wary of such a generic name here", "author": "Jolyon-S", "createdAt": "2020-10-30T13:28:49Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/Constants.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock;\n+\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+\n+public class Constants {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5ODY3NQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515098675", "bodyText": "the javadoc is a note, of sorts. I'd recommend refactoring this line as follows:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n          \n          \n            \n             * All tests only induce and detect ACCEPTED_VALUE_GREATER_THAN_LEARNED corruption.", "author": "Jolyon-S", "createdAt": "2020-10-30T13:32:25Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA5OTA3NA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515099074", "bodyText": "nit: no need to hyphenate here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n          \n          \n            \n                    // We write logs in range [1, 500]. The first range of sequences for corruption detection = [0, 499] since", "author": "Jolyon-S", "createdAt": "2020-10-30T13:33:07Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMTk3Mg==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515101972", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n          \n          \n            \n                private static NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {", "author": "Jolyon-S", "createdAt": "2020-10-30T13:36:37Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjE4Mw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515102183", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {\n          \n          \n            \n                private NamespaceAndUseCase namespaceAndUseCaseForIndex(int index) {", "author": "Jolyon-S", "createdAt": "2020-10-30T13:36:56Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        List<StateLogComponents> components = helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase);\n+        helper.induceGreaterAcceptedValueCorruption(components.get(0), 499);\n+    }\n+\n+    private NamespaceAndUseCase namespaceAndUseCaseForIndex(Integer ind) {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjI5Nw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515102297", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void corruptSeries(Integer namespaceAndUseCaseIndex) {\n          \n          \n            \n                private void corruptSeries(int namespaceAndUseCaseIndex) {", "author": "Jolyon-S", "createdAt": "2020-10-30T13:37:09Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n+        NamespaceAndUseCase namespaceAndUseCase = namespaceAndUseCaseForIndex(namespaceAndUseCaseIndex);\n+        helper.writeLogsOnLocalAndRemote(\n+                helper.createStatLogComponentsForNamespaceAndUseCase(namespaceAndUseCase), 1, 500);\n+    }\n+\n+    private void corruptSeries(Integer namespaceAndUseCaseIndex) {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwMjM5OQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515102399", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {\n          \n          \n            \n                private void createSeriesWithPaxosLogs(int namespaceAndUseCaseIndex) {", "author": "Jolyon-S", "createdAt": "2020-10-30T13:37:17Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/CorruptionDetectionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * This class performs integration tests by inducing and detecting corruption in one or more series.\n+ * Note - All tests only induce and detect one type of corruption check violation -> ACCEPTED_VALUE_GREATER_THAN_LEARNED\n+ */\n+public final class CorruptionDetectionIntegrationTest {\n+    @Rule\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n+\n+    @Test\n+    public void detectCorruptionForLogAtBatchEnd() {\n+        // We write logs in range - [1, 500]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1.\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 500);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(499);\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogInLaterBatches() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(599);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForLogAtStartOfSecondBatch() {\n+        // We write logs in range - [1, 1000]. The first range of sequences for corruption detection = [0, 499] since\n+        // this range is computed from INITIAL_PROGRESS = -1, which makes range of the second batch = [500, 999].\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 1000);\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(500);\n+\n+        // No signs of corruption in the first batch\n+        helper.assertNoCorruptionViolations();\n+\n+        // Detects signs of corruption in the second batch\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void resetsLastVerifiedOnceGreatestKnownSeqInMemoryIsVerified() {\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 400);\n+\n+        // No signs of corruption\n+        helper.assertNoCorruptionViolations();\n+\n+        helper.induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(250);\n+        // Detects signs of corruption in the now corrupt first batch of logs\n+        helper.assertAcceptedValueGreaterThanLearnedValue();\n+    }\n+\n+    @Test\n+    public void detectCorruptionForMultipleCorruptSeries() {\n+        // We create 7 series and write logs to each of these in the range [1, 500]. We then corrupt series 6 & 7.\n+        IntStream.rangeClosed(1, 7).boxed().forEach(this::createSeriesWithPaxosLogs);\n+        IntStream.rangeClosed(6, 7).boxed().forEach(this::corruptSeries);\n+\n+        helper.assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(namespaceAndUseCaseForIndex(6), namespaceAndUseCaseForIndex(7)));\n+    }\n+\n+    private void createSeriesWithPaxosLogs(Integer namespaceAndUseCaseIndex) {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTA0Mw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515105043", "bodyText": "nit: remove empty line\n\n  \n    \n      \n        Suggested change", "author": "Jolyon-S", "createdAt": "2020-10-30T13:41:14Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertNoCorruptionViolations() {\n+        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n+    }\n+\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetectedForNamespaceAndUseCases(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTkxOA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515105918", "bodyText": "With this method, either 1 or 0 detected violations are passed, which I'm not a fan of at all. I'd prefer if you separate out to two methods: one that takes a single violation and confirms it is there, and a second where the logic is essentially:\nassertThat(getViolationsToNamespaceToUseCaseMultimap()).isEmpty();", "author": "Jolyon-S", "createdAt": "2020-10-30T13:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNTA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNjIzOQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515106239", "bodyText": "you can inline this variable - the method call is actually shorter than the variable!", "author": "Jolyon-S", "createdAt": "2020-10-30T13:43:16Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n+    }\n+\n+    StateLogComponents getDefaultLocalServer() {\n+        return timeLockCorruptionTestSetup.getDefaultLocalServer();\n+    }\n+\n+    List<StateLogComponents> getDefaultRemoteServerList() {\n+        return timeLockCorruptionTestSetup.getDefaultRemoteServerList();\n+    }\n+\n+    void induceGreaterAcceptedValueCorruptionOnDefaultLocalServer(int corruptSeq) {\n+        induceGreaterAcceptedValueCorruption(timeLockCorruptionTestSetup.getDefaultLocalServer(), corruptSeq);\n+    }\n+\n+    void induceGreaterAcceptedValueCorruption(StateLogComponents server, int corruptSeq) {\n+        PaxosSerializationTestUtils.writeAcceptorStateForLogAndRound(\n+                server.acceptorLog(),\n+                corruptSeq,\n+                Optional.of(PaxosSerializationTestUtils.createPaxosValueForRoundAndData(corruptSeq, corruptSeq + 1)));\n+    }\n+\n+    List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n+        return timeLockCorruptionTestSetup.getPaxosLogHistoryProvider().getHistory();\n+    }\n+\n+    void assertNoCorruptionViolations() {\n+        assertViolationsDetectedForNamespaceAndUseCases(ImmutableSet.of(), ImmutableSet.of());\n+    }\n+\n+    void assertAcceptedValueGreaterThanLearnedValue() {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                ImmutableSet.of(CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED),\n+                ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetected(Set<CorruptionCheckViolation> detectedViolations) {\n+        assertViolationsDetectedForNamespaceAndUseCases(\n+                detectedViolations, ImmutableSet.of(Constants.DEFAULT_NAMESPACE_AND_USE_CASE));\n+    }\n+\n+    void assertViolationsDetectedForNamespaceAndUseCases(\n+            Set<CorruptionCheckViolation> detectedViolations,\n+            Set<NamespaceAndUseCase> namespaceAndUseCasesWithViolation) {\n+\n+        Multimap<CorruptionCheckViolation, NamespaceAndUseCase> violationsToNamespaceToUseCaseMultimap =\n+                getViolationsToNamespaceToUseCaseMultimap();\n+\n+        assertThat(violationsToNamespaceToUseCaseMultimap.keySet()).hasSameElementsAs(detectedViolations);\n+        assertThat(violationsToNamespaceToUseCaseMultimap.values())\n+                .hasSameElementsAs(namespaceAndUseCasesWithViolation);\n+    }\n+\n+    private Multimap<CorruptionCheckViolation, NamespaceAndUseCase> getViolationsToNamespaceToUseCaseMultimap() {\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = getHistory();", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzEzOA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515107138", "bodyText": "IntelliJ tells me that there are a number of methods that can be private - please make them private, then re-order so that they are after the non-private ones.\nAlso, there are definitely some methods that can be static - for example writeLogsOnServer. Please make static the methods that can be.", "author": "Jolyon-S", "createdAt": "2020-10-30T13:44:41Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwNDUxNQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515904515", "bodyText": "Made the methods package-private.\nDone.", "author": "sudiksha27", "createdAt": "2020-11-02T11:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwNzMwMw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515107303", "bodyText": "We discussed - remove stream()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));\n          \n          \n            \n                    servers.forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));", "author": "Jolyon-S", "createdAt": "2020-10-30T13:44:58Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);\n+    }\n+\n+    void writeLogsOnDefaultLocalAndRemote(int startingLogSeq, int latestLogSequence) {\n+        writeLogsOnLocalAndRemote(\n+                timeLockCorruptionTestSetup.getDefaultServerList(), startingLogSeq, latestLogSequence);\n+    }\n+\n+    Set<PaxosValue> writeLogsOnServer(StateLogComponents server, int start, int end) {\n+        return PaxosSerializationTestUtils.writeToLogs(server.acceptorLog(), server.learnerLog(), start, end);\n+    }\n+\n+    void writeLogsOnLocalAndRemote(List<StateLogComponents> servers, int startingLogSeq, int latestLogSequence) {\n+        servers.stream().forEach(server -> writeLogsOnServer(server, startingLogSeq, latestLogSequence));", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODA3NQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515108075", "bodyText": "Interesting - if we get an exception on startup, we don't want to do anything? I'd have thought we'd do:\nthrow new RuntimeException(throwable, \"failed on startup\");", "author": "Jolyon-S", "createdAt": "2020-10-30T13:46:03Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODc5NA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515108794", "bodyText": "Same as elsewhere: this and other methods don't need to be public.", "author": "Jolyon-S", "createdAt": "2020-10-30T13:47:08Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op\n+                        }\n+                    }\n+\n+                    @Override\n+                    protected void after() {\n+                        // no op\n+                    }\n+                })\n+                .apply(base, description);\n+    }\n+\n+    private void setup() throws Throwable {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        defaultLocalServer = createLogComponentsForServer(localDataSource);\n+        defaultRemoteServerList = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = paxosLogHistoryProvider();\n+    }\n+\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n+        return new PaxosLogHistoryProvider(\n+                localDataSource,\n+                defaultRemoteServerList.stream()\n+                        .map(StateLogComponents::dataSource)\n+                        .map(this::getHistoryProviderResource)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1OTI4Mw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515159283", "bodyText": "also: StatLog?", "author": "jeremyk-91", "createdAt": "2020-10-30T14:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwODc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTA2OQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515109069", "bodyText": "nit: static?", "author": "Jolyon-S", "createdAt": "2020-10-30T13:47:39Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionTestSetup.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.immutables.value.Value;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionTestSetup implements TestRule {\n+    private TemporaryFolder tempFolder = new TemporaryFolder();\n+    private DataSource localDataSource;\n+    private DataSource remoteDataSource1;\n+    private DataSource remoteDataSource2;\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    private StateLogComponents defaultLocalServer;\n+    private List<StateLogComponents> defaultRemoteServerList;\n+\n+    @Override\n+    public Statement apply(Statement base, Description description) {\n+        return RuleChain.outerRule(tempFolder)\n+                .around(new ExternalResource() {\n+                    @Override\n+                    protected void before() {\n+                        try {\n+                            setup();\n+                        } catch (Throwable throwable) {\n+                            // no op\n+                        }\n+                    }\n+\n+                    @Override\n+                    protected void after() {\n+                        // no op\n+                    }\n+                })\n+                .apply(base, description);\n+    }\n+\n+    private void setup() throws Throwable {\n+        localDataSource = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile1\").toPath());\n+        remoteDataSource1 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile2\").toPath());\n+        remoteDataSource2 = SqliteConnections.getPooledDataSource(\n+                tempFolder.newFolder(\"randomFile3\").toPath());\n+\n+        defaultLocalServer = createLogComponentsForServer(localDataSource);\n+        defaultRemoteServerList = ImmutableList.of(\n+                createLogComponentsForServer(remoteDataSource1), createLogComponentsForServer(remoteDataSource2));\n+        paxosLogHistoryProvider = paxosLogHistoryProvider();\n+    }\n+\n+    private PaxosLogHistoryProvider paxosLogHistoryProvider() {\n+        return new PaxosLogHistoryProvider(\n+                localDataSource,\n+                defaultRemoteServerList.stream()\n+                        .map(StateLogComponents::dataSource)\n+                        .map(this::getHistoryProviderResource)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    public List<StateLogComponents> createStatLogComponentsForNamespaceAndUseCase(\n+            NamespaceAndUseCase namespaceAndUseCase) {\n+        return ImmutableList.of(\n+                createLogComponentsForServer(localDataSource, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource1, namespaceAndUseCase),\n+                createLogComponentsForServer(remoteDataSource2, namespaceAndUseCase));\n+    }\n+\n+    public List<StateLogComponents> getDefaultServerList() {\n+        return ImmutableList.<StateLogComponents>builder()\n+                .add(defaultLocalServer)\n+                .addAll(defaultRemoteServerList)\n+                .build();\n+    }\n+\n+    public PaxosLogHistoryProvider getPaxosLogHistoryProvider() {\n+        return paxosLogHistoryProvider;\n+    }\n+\n+    public StateLogComponents getDefaultLocalServer() {\n+        return defaultLocalServer;\n+    }\n+\n+    public List<StateLogComponents> getDefaultRemoteServerList() {\n+        return defaultRemoteServerList;\n+    }\n+\n+    private StateLogComponents createLogComponentsForServer(DataSource dataSource) {\n+        return createLogComponentsForServer(dataSource, Constants.DEFAULT_NAMESPACE_AND_USE_CASE);\n+    }\n+\n+    private StateLogComponents createLogComponentsForServer(", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTE3Nw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515109177", "bodyText": "there are others in this class too", "author": "Jolyon-S", "createdAt": "2020-10-30T13:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEwOTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1OTM1Nw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515159357", "bodyText": "name - add 'inclusive'", "author": "sudiksha27", "createdAt": "2020-10-30T14:55:52Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.Constants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    Set<PaxosValue> writeLogsOnDefaultLocalServer(int start, int end) {\n+        return writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), start, end);", "originalCommit": "47870d0774ae2f77ad9a96d2d4eadf4e21b44f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkwMTcxNQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515901715", "bodyText": "It is only used in one place but I think this signature makes sense.", "author": "sudiksha27", "createdAt": "2020-11-02T11:13:50Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.TimelockCorruptionTestConstants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {\n+    private TimeLockCorruptionTestSetup timeLockCorruptionTestSetup = new TimeLockCorruptionTestSetup();\n+\n+    void writeLogsOnDefaultLocalServer(int startInclusive, int endInclusive) {\n+        writeLogsOnServer(timeLockCorruptionTestSetup.getDefaultLocalServer(), startInclusive, endInclusive);", "originalCommit": "57c98a19528671d72189cb240ffd3fb9cd2e9de1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTUxMg==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515915512", "bodyText": "As far as I can tell, every test uses the params 1, 10. Perhaps you should mix this up a bit? Can these numbers be large (e.g. 10k)? Might help to catch any funny errors to have at least one test with large numbers - if that makes sense in prod.", "author": "Jolyon-S", "createdAt": "2020-11-02T11:41:21Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java", "diffHunk": "@@ -18,178 +18,72 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n-import com.google.common.collect.SetMultimap;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.paxos.PaxosAcceptorState;\n-import com.palantir.paxos.PaxosStateLog;\n-import com.palantir.paxos.PaxosValue;\n-import com.palantir.paxos.SqliteConnections;\n-import com.palantir.paxos.SqlitePaxosStateLog;\n-import com.palantir.timelock.history.LocalHistoryLoader;\n-import com.palantir.timelock.history.PaxosLogHistoryProvider;\n-import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n-import com.palantir.timelock.history.models.AcceptorUseCase;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n-import java.io.IOException;\n import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import javax.sql.DataSource;\n-import org.immutables.value.Value;\n-import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.TemporaryFolder;\n \n-public class HistoryAnalyzerTest {\n+public final class HistoryAnalyzerTest {\n     @Rule\n-    public TemporaryFolder tempFolder = new TemporaryFolder();\n-\n-    private static final Client CLIENT = Client.of(\"client\");\n-    private static final String USE_CASE = \"useCase\";\n-    private static final String USE_CASE_LEARNER =\n-            LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n-    private static final String USE_CASE_ACCEPTOR =\n-            AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n-\n-    private StateLogComponents localStateLogComponents;\n-    private List<StateLogComponents> remoteStateLogComponents;\n-    PaxosLogHistoryProvider paxosLogHistoryProvider;\n-\n-    @Before\n-    public void setup() throws IOException {\n-        localStateLogComponents = createLogComponentsForServer(\"randomFile1\");\n-        remoteStateLogComponents = ImmutableList.of(\n-                createLogComponentsForServer(\"randomFile2\"), createLogComponentsForServer(\"randomFile3\"));\n-        paxosLogHistoryProvider = new PaxosLogHistoryProvider(\n-                localStateLogComponents.dataSource(),\n-                remoteStateLogComponents.stream()\n-                        .map(StateLogComponents::serverHistoryProvider)\n-                        .collect(Collectors.toList()));\n-    }\n+    public TimeLockCorruptionDetectionHelper helper = new TimeLockCorruptionDetectionHelper();\n \n     @Test\n     public void correctlyPassesIfThereIsNotCorruption() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n-        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 10));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n \n         assertThat(HistoryAnalyzer.corruptionCheckViolationLevelForNamespaceAndUseCase(\n                         Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n \n-        assertThat(HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase()\n-                        .isEmpty())\n-                .isTrue();\n+        helper.assertNoCorruptionViolations();\n     }\n \n     @Test\n     public void detectCorruptionIfDifferentValuesAreLearnedInSameRound() {\n         PaxosSerializationTestUtils.writePaxosValue(\n-                localStateLogComponents.learnerLog(),\n+                helper.getDefaultLocalServer().learnerLog(),\n                 1,\n                 PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 1));\n-        remoteStateLogComponents.forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n-                server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n-\n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        helper.getDefaultRemoteServerList()\n+                .forEach(server -> PaxosSerializationTestUtils.writePaxosValue(\n+                        server.learnerLog(), 1, PaxosSerializationTestUtils.createPaxosValueForRoundAndData(1, 5)));\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.DIVERGED_LEARNERS);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.DIVERGED_LEARNERS);\n+        helper.assertViolationDetected(CorruptionCheckViolation.DIVERGED_LEARNERS);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotAcceptedByQuorum() {\n-        writeLogsOnServer(localStateLogComponents, 1, 10);\n+        helper.writeLogsOnDefaultLocalServer(1, 10);\n \n-        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = paxosLogHistoryProvider.getHistory();\n+        List<CompletePaxosHistoryForNamespaceAndUseCase> historyForAll = helper.getHistory();\n         assertThat(HistoryAnalyzer.divergedLearners(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.NONE);\n         assertThat(HistoryAnalyzer.learnedValueWithoutQuorum(Iterables.getOnlyElement(historyForAll)))\n                 .isEqualTo(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n \n-        SetMultimap<CorruptionCheckViolation, NamespaceAndUseCase> setMultimap =\n-                HistoryAnalyzer.corruptionHealthReportForHistory(historyForAll)\n-                        .violatingStatusesToNamespaceAndUseCase();\n-        assertThat(setMultimap.keySet()).containsExactly(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n+        helper.assertViolationDetected(CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM);\n     }\n \n     @Test\n     public void detectCorruptionIfLearnedValueIsNotTheGreatestAcceptedValue() {\n-        writeLogsOnServer(localStateLogComponents, 1, 5);\n-        remoteStateLogComponents.forEach(server -> writeLogsOnServer(server, 1, 5));\n+        helper.writeLogsOnDefaultLocalAndRemote(1, 10);", "originalCommit": "43c3a14899679cf2d29c838fad2a3dd01ca51529", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0MjU0OQ==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515942549", "bodyText": "First part is done. For the second part I can add a (stress?) test in CorruptionDetectionIntegrationTest.", "author": "sudiksha27", "createdAt": "2020-11-02T12:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNjA0MA==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515916040", "bodyText": "nit: reorder the methods so that public is at the top, private at the bottom (and if it makes sense to group static methods, feel free to do that too).", "author": "Jolyon-S", "createdAt": "2020-11-02T11:42:19Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/TimeLockCorruptionDetectionHelper.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Multimap;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.TimelockCorruptionTestConstants;\n+import com.palantir.timelock.corruption.detection.TimeLockCorruptionTestSetup.StateLogComponents;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class TimeLockCorruptionDetectionHelper implements TestRule {", "originalCommit": "43c3a14899679cf2d29c838fad2a3dd01ca51529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNjU4Mw==", "url": "https://github.com/palantir/atlasdb/pull/5089#discussion_r515916583", "bodyText": "nit: In other tests, you statically imported this. Either do the same here, or remove the static imports elsewhere.", "author": "Jolyon-S", "createdAt": "2020-11-02T11:43:25Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueries.java", "diffHunk": "@@ -16,20 +16,16 @@\n \n package com.palantir.timelock.history.utils;\n \n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.TimelockCorruptionTestConstants;\n import com.palantir.timelock.history.HistoryQuery;\n import com.palantir.timelock.history.HistoryQuerySequenceBounds;\n \n public class HistoryQueries {\n-    public static final Client DEFAULT_CLIENT = Client.of(\"client\");\n-    public static final String DEFAULT_USE_CASE = \"useCase\";\n-    public static final NamespaceAndUseCase DEFAULT_NAMESPACE_AND_USE_CASE =\n-            ImmutableNamespaceAndUseCase.of(DEFAULT_CLIENT, DEFAULT_USE_CASE);\n \n     public static HistoryQuery unboundedHistoryQuerySinceSeq(long seqLowerBound) {\n-        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n+        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n+                TimelockCorruptionTestConstants.DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);", "originalCommit": "43c3a14899679cf2d29c838fad2a3dd01ca51529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "006d25f1dbdaedf262567163d35ae825be4be542", "url": "https://github.com/palantir/atlasdb/commit/006d25f1dbdaedf262567163d35ae825be4be542", "message": "Basic tests", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "1367a6893b144b8531ef08442e73c1263d7cc176", "url": "https://github.com/palantir/atlasdb/commit/1367a6893b144b8531ef08442e73c1263d7cc176", "message": "Integration tests", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "0d91aab12ed0bbae121a1c61a4d7ce146eab0db8", "url": "https://github.com/palantir/atlasdb/commit/0d91aab12ed0bbae121a1c61a4d7ce146eab0db8", "message": "Minor | Modify java doc", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "e33480aede204f39ca097e96c3008dcfbcadcfc8", "url": "https://github.com/palantir/atlasdb/commit/e33480aede204f39ca097e96c3008dcfbcadcfc8", "message": "Fix build + spotless", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "d6640eab25595c27a2a30597f371629342223768", "url": "https://github.com/palantir/atlasdb/commit/d6640eab25595c27a2a30597f371629342223768", "message": "WIP", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "67dbd02bb499a4ea0649e81ba3640d65df882458", "url": "https://github.com/palantir/atlasdb/commit/67dbd02bb499a4ea0649e81ba3640d65df882458", "message": "Experimental", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "439dbf8391f3c2a7291c7ad83ace39a0da432e80", "url": "https://github.com/palantir/atlasdb/commit/439dbf8391f3c2a7291c7ad83ace39a0da432e80", "message": "Address comments", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "d883b794d2150a79989b76c4cda9bd9dbd2ecd65", "url": "https://github.com/palantir/atlasdb/commit/d883b794d2150a79989b76c4cda9bd9dbd2ecd65", "message": "Cleanup", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "url": "https://github.com/palantir/atlasdb/commit/3c11e99902a74fa8b3dfcc7a4144c57f3f7a23e6", "message": "Lets write clean code", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "21a1acd5e84c211f30877a7064485062039d0d3f", "url": "https://github.com/palantir/atlasdb/commit/21a1acd5e84c211f30877a7064485062039d0d3f", "message": "Fix access modifiers", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "bb339d2c6bc6d3c1d83f806f01c386e6ba7399dd", "url": "https://github.com/palantir/atlasdb/commit/bb339d2c6bc6d3c1d83f806f01c386e6ba7399dd", "message": "Do no push wrong changes", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "1765bdaa5ac4d040e297ec993e9ab6f795c74eae", "url": "https://github.com/palantir/atlasdb/commit/1765bdaa5ac4d040e297ec993e9ab6f795c74eae", "message": "Make util methods static", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "3a58088437769c0ee4ca1378f5b1da5274dbd96c", "url": "https://github.com/palantir/atlasdb/commit/3a58088437769c0ee4ca1378f5b1da5274dbd96c", "message": "Cleanup", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "url": "https://github.com/palantir/atlasdb/commit/84cfdc115b2317a6c62c7dae6eb0f2cb35567be2", "message": "Address nits", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "677d85042c39a424a7317848bf90bd00152535ab", "url": "https://github.com/palantir/atlasdb/commit/677d85042c39a424a7317848bf90bd00152535ab", "message": "Stress test", "committedDate": "2020-11-03T12:31:54Z", "type": "commit"}, {"oid": "677d85042c39a424a7317848bf90bd00152535ab", "url": "https://github.com/palantir/atlasdb/commit/677d85042c39a424a7317848bf90bd00152535ab", "message": "Stress test", "committedDate": "2020-11-03T12:31:54Z", "type": "forcePushed"}]}