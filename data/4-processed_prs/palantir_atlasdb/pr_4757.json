{"pr_number": 4757, "pr_title": "Implement better TM closing", "pr_createdAt": "2020-05-06T15:47:15Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4757", "timeline": [{"oid": "2eb5961e781d079df809339f354c55489ea8032e", "url": "https://github.com/palantir/atlasdb/commit/2eb5961e781d079df809339f354c55489ea8032e", "message": "Implement better TM closing", "committedDate": "2020-05-06T15:43:35Z", "type": "commit"}, {"oid": "dcf8e5238739640e355953fa60edc53eb5153b8e", "url": "https://github.com/palantir/atlasdb/commit/dcf8e5238739640e355953fa60edc53eb5153b8e", "message": "Add generated changelog entries", "committedDate": "2020-05-06T15:43:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5MDAxMg==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r420990012", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "jeremyk-91", "createdAt": "2020-05-06T18:06:51Z", "path": "atlasdb-commons/src/main/java/com/palantir/util/SafeShutdownRunner.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.util;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+\n+public class SafeShutdownRunner implements AutoCloseable {\n+    private final ExecutorService executor = PTExecutors\n+            .newFixedThreadPool(5, new NamedThreadFactory(\"safe-shutdown-runner\", true));\n+    private final List<Throwable> failures = new ArrayList<>();\n+    private final Duration timeoutDuration;\n+\n+    public SafeShutdownRunner(Duration timeoutDuration) {\n+        this.timeoutDuration = timeoutDuration;\n+    }\n+\n+    public void shutdownSafely(Runnable shutdownCallback) {\n+        Future<?> future = executor.submit(shutdownCallback);\n+        try {\n+            future.get(timeoutDuration.toMillis(), TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            failures.add(e);\n+        } catch (ExecutionException e) {\n+            failures.add(e.getCause());\n+        } catch (TimeoutException e) {\n+            future.cancel(true);\n+            failures.add(e);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        executor.shutdown();\n+        if (!failures.isEmpty()) {\n+            RuntimeException closeFailed = new SafeRuntimeException(\n+                    \"Close failed. Please inspect the code and fix the failures\");\n+            failures.forEach(closeFailed::addSuppressed);\n+            throw closeFailed;\n+        }\n+    }\n+}", "originalCommit": "dcf8e5238739640e355953fa60edc53eb5153b8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5MDQxNQ==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r420990415", "bodyText": "Can we have a message assert on this? I think the point here is that the exception thrown by the runner close isn't the exception that happened inside the shutdown operation", "author": "jeremyk-91", "createdAt": "2020-05-06T18:07:29Z", "path": "atlasdb-commons/src/test/java/com/palantir/util/SafeShutdownRunnerTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.util;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Stream;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+public class SafeShutdownRunnerTest {\n+    private static final RuntimeException EXCEPTION = new RuntimeException(\"test\");\n+\n+    private Runnable mockRunnable = mock(Runnable.class);\n+    private Runnable throwingRunnable = mock(Runnable.class);\n+    private Runnable verySlowUninterruptibleRunnable = mock(Runnable.class);\n+\n+    @Before\n+    public void setupMocks() {\n+        doAnswer(invocation -> {\n+            Uninterruptibles.sleepUninterruptibly(10_000, TimeUnit.MILLISECONDS);\n+            return null;\n+        }).when(verySlowUninterruptibleRunnable).run();\n+        doThrow(EXCEPTION).when(throwingRunnable).run();\n+    }\n+\n+    @Test\n+    public void runnerRunsOneTask() {\n+        SafeShutdownRunner runner = new SafeShutdownRunner(Duration.ofSeconds(1));\n+\n+        runner.shutdownSafely(mockRunnable);\n+\n+        verify(mockRunnable, times(1)).run();\n+        assertThatCode(runner::close).doesNotThrowAnyException();\n+    }\n+\n+    @Test\n+    public void exceptionsAreSuppressedAndReportedWhenClosing() {\n+        SafeShutdownRunner runner = new SafeShutdownRunner(Duration.ofSeconds(1));\n+\n+        assertThatCode(() -> runner.shutdownSafely(throwingRunnable)).doesNotThrowAnyException();\n+        assertThatThrownBy(runner::close)\n+                .isInstanceOf(RuntimeException.class)", "originalCommit": "dcf8e5238739640e355953fa60edc53eb5153b8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODE4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421088187", "bodyText": "That is implied by having the exception that happened inside the shutdown operation be the suppressed exception, although I guess you could self reference if you really wanted to make me sad. I can change to this being an instance of SRE, which will disambiguate", "author": "gmaretic", "createdAt": "2020-05-06T20:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5MDQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNDcxNA==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421004714", "bodyText": "I guess this is fine. A service with tons of TransactionManagers could end up having a bunch of stuck threads though, especially if things are re-opened and closed (though if things hang uninterruptibly I guess there isn't much we can do).\nNote: This does not actually create the threads until needed so most of the time you only create one thread even though we're making a fixed thread pool of 5", "author": "jeremyk-91", "createdAt": "2020-05-06T18:31:27Z", "path": "atlasdb-commons/src/main/java/com/palantir/util/SafeShutdownRunner.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.util;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.palantir.common.concurrent.NamedThreadFactory;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+\n+public class SafeShutdownRunner implements AutoCloseable {\n+    private final ExecutorService executor = PTExecutors\n+            .newFixedThreadPool(5, new NamedThreadFactory(\"safe-shutdown-runner\", true));", "originalCommit": "dcf8e5238739640e355953fa60edc53eb5153b8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NDU0NQ==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421044545", "bodyText": "I would almost say we want cached here? we want to close whatever we can.", "author": "jkozlowski", "createdAt": "2020-05-06T19:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0OTgzNw==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421049837", "bodyText": "And we should make internal ski product notify us when it gets an exception from here so we can investigate.", "author": "jkozlowski", "createdAt": "2020-05-06T19:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MzM4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421053387", "bodyText": "Ah, you're right that if we run, e.g.\n<thing that takes 30 seconds>\n<fast task>\n<thing that hangs>\n\nthen this keeps around 2 threads for no reason. Cached is probably fine in that the number of threads is at worst bounded by number of callbacks. If we wanted to have a hard limit we could also do a ThreadPoolExecutor with core 0 and max 5 - I think either is fine", "author": "jeremyk-91", "createdAt": "2020-05-06T19:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NjkyOQ==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421086929", "bodyText": "Agreed, cached is probably fine here", "author": "gmaretic", "createdAt": "2020-05-06T20:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNDcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEyMzM2NQ==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421123365", "bodyText": "Also, it's bounded by number of bad tasks, which I suspect is 1. Either way is fine", "author": "jkozlowski", "createdAt": "2020-05-06T22:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNDcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNzE4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421007189", "bodyText": "Interesting. I guess it never gets executed, and we drop out after the time limit.", "author": "jeremyk-91", "createdAt": "2020-05-06T18:35:27Z", "path": "atlasdb-commons/src/test/java/com/palantir/util/SafeShutdownRunnerTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.util;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Stream;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+\n+public class SafeShutdownRunnerTest {\n+    private static final RuntimeException EXCEPTION = new RuntimeException(\"test\");\n+\n+    private Runnable mockRunnable = mock(Runnable.class);\n+    private Runnable throwingRunnable = mock(Runnable.class);\n+    private Runnable verySlowUninterruptibleRunnable = mock(Runnable.class);\n+\n+    @Before\n+    public void setupMocks() {\n+        doAnswer(invocation -> {\n+            Uninterruptibles.sleepUninterruptibly(10_000, TimeUnit.MILLISECONDS);\n+            return null;\n+        }).when(verySlowUninterruptibleRunnable).run();\n+        doThrow(EXCEPTION).when(throwingRunnable).run();\n+    }\n+\n+    @Test\n+    public void runnerRunsOneTask() {\n+        SafeShutdownRunner runner = new SafeShutdownRunner(Duration.ofSeconds(1));\n+\n+        runner.shutdownSafely(mockRunnable);\n+\n+        verify(mockRunnable, times(1)).run();\n+        assertThatCode(runner::close).doesNotThrowAnyException();\n+    }\n+\n+    @Test\n+    public void exceptionsAreSuppressedAndReportedWhenClosing() {\n+        SafeShutdownRunner runner = new SafeShutdownRunner(Duration.ofSeconds(1));\n+\n+        assertThatCode(() -> runner.shutdownSafely(throwingRunnable)).doesNotThrowAnyException();\n+        assertThatThrownBy(runner::close)\n+                .isInstanceOf(RuntimeException.class)\n+                .hasSuppressedException(EXCEPTION);\n+    }\n+\n+    @Test\n+    public void slowTasksTimeOutWithoutThrowing() {\n+        SafeShutdownRunner runner = new SafeShutdownRunner(Duration.ofMillis(50));\n+\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+\n+        verify(verySlowUninterruptibleRunnable, times(2)).run();\n+\n+        closeAndAssertNumberOfTimeouts(runner, 2);\n+    }\n+\n+    @Test\n+    public void otherTasksStillRunAfterSlowTasksThatTimeOut() {\n+        SafeShutdownRunner runner = new SafeShutdownRunner(Duration.ofMillis(50));\n+\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+        runner.shutdownSafely(mockRunnable);\n+\n+        verify(verySlowUninterruptibleRunnable, times(2)).run();\n+        verify(mockRunnable, times(1)).run();\n+\n+        closeAndAssertNumberOfTimeouts(runner, 2);\n+    }\n+\n+    @Test\n+    public void neverRunsRemainingTasksIfExecutorFillsUpWithUninteruptibleTasks() {\n+        SafeShutdownRunner runner = new SafeShutdownRunner(Duration.ofMillis(50));\n+\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+        runner.shutdownSafely(verySlowUninterruptibleRunnable);\n+        runner.shutdownSafely(mockRunnable);\n+\n+        verify(verySlowUninterruptibleRunnable, times(5)).run();\n+        verify(mockRunnable, never()).run();\n+\n+        closeAndAssertNumberOfTimeouts(runner, 7);", "originalCommit": "dcf8e5238739640e355953fa60edc53eb5153b8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4ODc3Mw==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421088773", "bodyText": "Once all the threads are stuck in uninterruptible tasks, everything gets put on the queue and never gets to run as we time out waiting to pick it up from the queue", "author": "gmaretic", "createdAt": "2020-05-06T21:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNzE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA5MTAwMw==", "url": "https://github.com/palantir/atlasdb/pull/4757#discussion_r421091003", "bodyText": "This is no longer applicable with the cached thread pool", "author": "gmaretic", "createdAt": "2020-05-06T21:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNzE4OQ=="}], "type": "inlineReview"}, {"oid": "9a08bb49ca5e44b48c44dfea085d828b4eeed85b", "url": "https://github.com/palantir/atlasdb/commit/9a08bb49ca5e44b48c44dfea085d828b4eeed85b", "message": "Address CR:", "committedDate": "2020-05-06T21:04:13Z", "type": "commit"}, {"oid": "f0aa3248528807ead7da1bccb98a1a0e993b9df7", "url": "https://github.com/palantir/atlasdb/commit/f0aa3248528807ead7da1bccb98a1a0e993b9df7", "message": "Merge branch 'tm/better-close' of github.com:palantir/atlasdb into tm/better-close", "committedDate": "2020-05-07T08:51:01Z", "type": "commit"}]}