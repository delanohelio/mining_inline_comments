{"pr_number": 4811, "pr_title": "Lock watches wiring and exposing API for PreCommitCondition.", "pr_createdAt": "2020-05-28T15:24:12Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4811", "timeline": [{"oid": "10b728e20ccc494f27d5e7deabc1e1c6ef4a4d80", "url": "https://github.com/palantir/atlasdb/commit/10b728e20ccc494f27d5e7deabc1e1c6ef4a4d80", "message": "Full impl, just some small things remaining.", "committedDate": "2020-05-28T15:23:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NDM5NA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r431944394", "bodyText": "we've found extending txn manager to be a bit of a folly in the past. Would much appreciate if this method were not an interface method, or were otherwise on TransactionManager. At a minimum, it means you get to pick if SchemaAwareTransactionManager should implement LockWatchTransactionManager facepalm", "author": "j-baker", "createdAt": "2020-05-28T15:53:56Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchTransactionManager.java", "diffHunk": "@@ -16,20 +16,13 @@\n \n package com.palantir.atlasdb.keyvalue.api.watch;\n \n+import java.util.List;\n import java.util.Optional;\n-import java.util.Set;\n \n+import com.palantir.atlasdb.transaction.api.TransactionManager;\n import com.palantir.lock.watch.IdentifiedVersion;\n-import com.palantir.lock.watch.TransactionsLockWatchEvents;\n \n-public interface InternalLockWatchManager extends LockWatchManager {\n-    /**\n-     * Returns a condensed view of new lock watch events since lastKnownVersion for a set of transactions identified by\n-     * their start timestamps.\n-     *\n-     * @param startTimestamps  a set of start timestamps identifying transactions\n-     * @param lastKnownVersion exclusive start version to get events from\n-     */\n-    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n-            Optional<IdentifiedVersion> lastKnownVersion);\n+public interface LockWatchTransactionManager extends TransactionManager {", "originalCommit": "10b728e20ccc494f27d5e7deabc1e1c6ef4a4d80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNDYwMQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r432114601", "bodyText": "Removed", "author": "jkozlowski", "createdAt": "2020-05-28T20:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NDM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NTg3MA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r431945870", "bodyText": "yeah, this change can't happen - breaks too much binary backcompat internally", "author": "j-baker", "createdAt": "2020-05-28T15:56:01Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -331,6 +333,12 @@ public static TransactionManager createInMemory(Set<Schema> schemas) {\n     @JsonIgnore\n     @Value.Derived\n     public TransactionManager serializable() {\n+        return lockWatch();\n+    }\n+\n+    @JsonIgnore\n+    @Value.Derived\n+    public LockWatchTransactionManager lockWatch() {", "originalCommit": "10b728e20ccc494f27d5e7deabc1e1c6ef4a4d80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNDcwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r432114705", "bodyText": "Removed", "author": "jkozlowski", "createdAt": "2020-05-28T20:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NTg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1NjYzMw==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r431956633", "bodyText": "you only need the start timestamp from the txn here. You might want to pass that to the precommit condition explicitly as a new (default) method.", "author": "j-baker", "createdAt": "2020-05-28T16:12:01Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/watch/WatchPreCommitCondition.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl.watch;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.palantir.atlasdb.keyvalue.api.watch.WatchCommitCondition;\n+import com.palantir.atlasdb.transaction.api.PreCommitCondition;\n+import com.palantir.atlasdb.transaction.api.Transaction;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class WatchPreCommitCondition implements PreCommitCondition {\n+\n+    private final LockWatchEventCache cache;\n+    private final WatchCommitCondition watchCommitCondition;\n+    private AtomicReference<Transaction> txn = new AtomicReference<>(null);\n+\n+    public WatchPreCommitCondition(LockWatchEventCache cache, WatchCommitCondition watchCommitCondition) {\n+        this.cache = cache;\n+        this.watchCommitCondition = watchCommitCondition;\n+    }\n+\n+    void initialize(Transaction newTxn) {\n+        Preconditions.checkState(txn.compareAndSet(null, newTxn), \"Already initialized\");\n+    }\n+\n+    @Override\n+    public void throwIfConditionInvalid(long timestamp) {", "originalCommit": "10b728e20ccc494f27d5e7deabc1e1c6ef4a4d80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1OTMyNA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r431959324", "bodyText": "like, seems reasonable that we'd have method that initializes with the start timestamp... but fine with this for now.", "author": "j-baker", "createdAt": "2020-05-28T16:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1NjYzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNDg0OA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r432114848", "bodyText": "Added default method to initialize with startTs.", "author": "jkozlowski", "createdAt": "2020-05-28T20:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1NjYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2MDQ3MQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r431960471", "bodyText": "can we just get rid of the 'CommitUpdate' type? Like, to me there should be no difference between the commit update and the start update.", "author": "j-baker", "createdAt": "2020-05-28T16:17:01Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/watch/WatchPreCommitCondition.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl.watch;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.palantir.atlasdb.keyvalue.api.watch.WatchCommitCondition;\n+import com.palantir.atlasdb.transaction.api.PreCommitCondition;\n+import com.palantir.atlasdb.transaction.api.Transaction;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.logsafe.Preconditions;\n+\n+final class WatchPreCommitCondition implements PreCommitCondition {\n+\n+    private final LockWatchEventCache cache;\n+    private final WatchCommitCondition watchCommitCondition;\n+    private AtomicReference<Transaction> txn = new AtomicReference<>(null);\n+\n+    public WatchPreCommitCondition(LockWatchEventCache cache, WatchCommitCondition watchCommitCondition) {\n+        this.cache = cache;\n+        this.watchCommitCondition = watchCommitCondition;\n+    }\n+\n+    void initialize(Transaction newTxn) {\n+        Preconditions.checkState(txn.compareAndSet(null, newTxn), \"Already initialized\");\n+    }\n+\n+    @Override\n+    public void throwIfConditionInvalid(long timestamp) {\n+        if (timestamp != getTransaction().getTimestamp()) {\n+            CommitUpdate commitUpdate = cache.getCommitUpdate(getTransaction().getTimestamp());", "originalCommit": "10b728e20ccc494f27d5e7deabc1e1c6ef4a4d80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNTMzNQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r432115335", "bodyText": "I think this was added for ease of use: it gives you the descriptors that had any events, so the cache dedupes everything for you. Could just return raw events if you want.", "author": "jkozlowski", "createdAt": "2020-05-28T20:50:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2MDQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2MDg3Nw==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r431960877", "bodyText": "kill?", "author": "j-baker", "createdAt": "2020-05-28T16:17:34Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/watch/WatchPrecommitCondition.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package com.palantir.atlasdb.transaction.impl.watch;\n+\n+public class WatchPrecommitCondition {", "originalCommit": "10b728e20ccc494f27d5e7deabc1e1c6ef4a4d80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNTM5MA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r432115390", "bodyText": "Gone", "author": "jkozlowski", "createdAt": "2020-05-28T20:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2MDg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2MTU5NA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r431961594", "bodyText": "think this should not exist, rather, this should be implemented at the level of the precommit condition.", "author": "j-baker", "createdAt": "2020-05-28T16:18:37Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/CommitUpdate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Set;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.lock.LockDescriptor;\n+\n+public interface CommitUpdate {", "originalCommit": "10b728e20ccc494f27d5e7deabc1e1c6ef4a4d80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNTU3NQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r432115575", "bodyText": "As per previous comment, can remove if you want.", "author": "jkozlowski", "createdAt": "2020-05-28T20:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2MTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2ODEwOA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r431968108", "bodyText": "this API is a bit goofy. The point of a PrecommitCondition is that you should just be able to pass it in, it should be entirely pluggable.\nHere, the reason you need the extra method is because you need to get the start timestamp of the transactions that have been passed in.\nThis would be much easier if we just passed the precommit condition the start timestamp at some point (and it's a default method, so no breaks).", "author": "j-baker", "createdAt": "2020-05-28T16:28:34Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/watch/LockWatchTransactionManagerImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl.watch;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.Streams;\n+import com.palantir.atlasdb.keyvalue.api.watch.ImmutableStartTransactionsResponse;\n+import com.palantir.atlasdb.keyvalue.api.watch.LockWatchTransactionManager;\n+import com.palantir.atlasdb.keyvalue.api.watch.StartTransactionRequest;\n+import com.palantir.atlasdb.keyvalue.api.watch.StartTransactionsResponse;\n+import com.palantir.atlasdb.transaction.api.AutoDelegate_TransactionManager;\n+import com.palantir.atlasdb.transaction.api.OpenTransaction;\n+import com.palantir.atlasdb.transaction.api.PreCommitCondition;\n+import com.palantir.atlasdb.transaction.api.Transaction;\n+import com.palantir.atlasdb.transaction.api.TransactionFailedRetriableException;\n+import com.palantir.atlasdb.transaction.api.TransactionManager;\n+import com.palantir.atlasdb.transaction.api.TransactionTask;\n+import com.palantir.atlasdb.transaction.impl.ForwardingTransaction;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+\n+public class LockWatchTransactionManagerImpl implements AutoDelegate_TransactionManager, LockWatchTransactionManager {\n+\n+    private final TransactionManager transactionManager;\n+    private final LockWatchEventCache lockWatchEventCache;\n+\n+    public LockWatchTransactionManagerImpl(\n+            TransactionManager transactionManager,\n+            LockWatchEventCache lockWatchEventCache) {\n+        this.transactionManager = transactionManager;\n+        this.lockWatchEventCache = lockWatchEventCache;\n+    }\n+\n+    @Override\n+    public TransactionManager delegate() {\n+        return transactionManager;\n+    }\n+\n+    @Override\n+    public StartTransactionsResponse startTransactions(Optional<IdentifiedVersion> lastKnownVersion,\n+            List<StartTransactionRequest> requests) {\n+        List<CombinedCondition> amendedConditions = requests.stream().map(\n+                request -> new CombinedCondition(request.preCommitCondition(),\n+                        new WatchPreCommitCondition(lockWatchEventCache, request.watchCommitCondition())))", "originalCommit": "10b728e20ccc494f27d5e7deabc1e1c6ef4a4d80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3MDc4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r431970781", "bodyText": "like, the rough minimal thing i'm advocating for here is that I should be able to write a\ninterface CacheLocator extends PrecommitCondition {}\n\ninterface CacheFactory {\n    Cache getCache(CacheLocator initializedLocator, Transaction transactionForFallbacks);\n    CacheLocator newLocator();\n}\n\nand then use it like:\n\nCacheLocator locator = cacheFactory.newLocator();\ntxnManager.runWithConditionWithRetry(locator, txn -> {\n    Cache cache = cacheFactory.getCache(locator, txn);\n});\nOf course, the consumer doesn't use this API, but in Atlas it should read like this.", "author": "j-baker", "createdAt": "2020-05-28T16:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2ODEwOA=="}], "type": "inlineReview"}, {"oid": "4f2962c2136f4010f9aafaeff37299ac58207f55", "url": "https://github.com/palantir/atlasdb/commit/4f2962c2136f4010f9aafaeff37299ac58207f55", "message": "Save.", "committedDate": "2020-05-28T20:35:47Z", "type": "commit"}, {"oid": "16a46ec1f407cd8fc7de7341e639d4c84554e6d1", "url": "https://github.com/palantir/atlasdb/commit/16a46ec1f407cd8fc7de7341e639d4c84554e6d1", "message": "Cleanup", "committedDate": "2020-05-28T20:48:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNjA2OA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r432116068", "bodyText": "I think I can just make this have a thread that calls this on timelock once every few seconds and not bother with being clever.", "author": "jkozlowski", "createdAt": "2020-05-28T20:51:46Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/watch/LockWatchManagerImpl.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl.watch;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.palantir.atlasdb.keyvalue.api.watch.LockWatchManager;\n+import com.palantir.atlasdb.timelock.api.LockWatchRequest;\n+import com.palantir.lock.client.NamespacedConjureLockWatchingService;\n+import com.palantir.lock.watch.LockWatchReferences;\n+\n+public final class LockWatchManagerImpl implements LockWatchManager {\n+\n+    private final Set<LockWatchReferences.LockWatchReference> lockWatchReferences = new HashSet<>();\n+    private final NamespacedConjureLockWatchingService lockWatchingService;\n+\n+    public LockWatchManagerImpl(NamespacedConjureLockWatchingService lockWatchingService) {\n+        this.lockWatchingService = lockWatchingService;\n+    }\n+\n+    @Override\n+    public synchronized void registerWatches(Set<LockWatchReferences.LockWatchReference> newLockwatches) {\n+        lockWatchReferences.addAll(newLockwatches);\n+    }\n+\n+    public synchronized void reregisterWatches() {", "originalCommit": "16a46ec1f407cd8fc7de7341e639d4c84554e6d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyMzQ2MA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r432123460", "bodyText": "Gonna do it", "author": "jkozlowski", "createdAt": "2020-05-28T21:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExNjA2OA=="}], "type": "inlineReview"}, {"oid": "b28ab98e06a56c0a4ac742575b5e73a0ad85a191", "url": "https://github.com/palantir/atlasdb/commit/b28ab98e06a56c0a4ac742575b5e73a0ad85a191", "message": "Reregister periodically.", "committedDate": "2020-05-28T21:08:48Z", "type": "commit"}, {"oid": "de3186d9af498d384b333e7d6c6c86b6bc446137", "url": "https://github.com/palantir/atlasdb/commit/de3186d9af498d384b333e7d6c6c86b6bc446137", "message": "Aaaand make into abstract class, why not.", "committedDate": "2020-05-28T21:32:24Z", "type": "commit"}, {"oid": "ea6b0fff7f66ead2323fd61aa288aeccdf204c4f", "url": "https://github.com/palantir/atlasdb/commit/ea6b0fff7f66ead2323fd61aa288aeccdf204c4f", "message": "Cleanup", "committedDate": "2020-05-28T21:37:28Z", "type": "commit"}, {"oid": "b5135c86035c5c30b89fe8312ba4920155873c4f", "url": "https://github.com/palantir/atlasdb/commit/b5135c86035c5c30b89fe8312ba4920155873c4f", "message": "CLeanup", "committedDate": "2020-05-28T22:34:28Z", "type": "commit"}, {"oid": "37c8b97fabbc64c9821e0591a7e57ed32c240d9d", "url": "https://github.com/palantir/atlasdb/commit/37c8b97fabbc64c9821e0591a7e57ed32c240d9d", "message": "Fix test", "committedDate": "2020-05-28T22:54:23Z", "type": "commit"}, {"oid": "c00ad6e853950ce6f3daa63307c180b9f0c64e81", "url": "https://github.com/palantir/atlasdb/commit/c00ad6e853950ce6f3daa63307c180b9f0c64e81", "message": "Merge branch 'develop' into lockwatchmanager", "committedDate": "2020-05-28T23:06:51Z", "type": "commit"}, {"oid": "111b460c8e1f19445ce61431ea4c367e74c5cf78", "url": "https://github.com/palantir/atlasdb/commit/111b460c8e1f19445ce61431ea4c367e74c5cf78", "message": "Cleanup", "committedDate": "2020-05-29T12:00:49Z", "type": "commit"}, {"oid": "8556ceea6467eae7d43732627676a684f34f8f47", "url": "https://github.com/palantir/atlasdb/commit/8556ceea6467eae7d43732627676a684f34f8f47", "message": "Remove the initialize method for now.\nI can do it myself without awkwardness here.", "committedDate": "2020-05-29T13:19:19Z", "type": "commit"}, {"oid": "62b1dee5532a36664b382ec91809a609c5a5e269", "url": "https://github.com/palantir/atlasdb/commit/62b1dee5532a36664b382ec91809a609c5a5e269", "message": "Tests for Commit batching.", "committedDate": "2020-05-29T15:38:15Z", "type": "commit"}, {"oid": "fec920760689dbc3844f49b19bdc0e5f0e30af10", "url": "https://github.com/palantir/atlasdb/commit/fec920760689dbc3844f49b19bdc0e5f0e30af10", "message": "Checkstyle", "committedDate": "2020-05-29T19:48:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3MTkyNg==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433371926", "bodyText": "Do we need protection from exceptions in remoteTimelockServiceAdapter.close()?", "author": "jeremyk-91", "createdAt": "2020-06-01T17:13:47Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -1101,8 +1100,12 @@ private static LockAndTimestampServices getLockAndTimestampServices(\n                 .timestamp(new TimelockTimestampServiceAdapter(remoteTimelockServiceAdapter))\n                 .timestampManagement(timestampManagementService)\n                 .timelock(remoteTimelockServiceAdapter)\n-                .lockWatcher(lockWatcher)\n-                .close(remoteTimelockServiceAdapter::close)\n+                .lockWatcher(lockWatchManager)\n+                .eventCache(lockWatchEventCache)\n+                .close(() -> {\n+                    remoteTimelockServiceAdapter.close();\n+                    lockWatchManager.close();", "originalCommit": "fec920760689dbc3844f49b19bdc0e5f0e30af10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2Njc2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433466763", "bodyText": "I thought about that, but not many places in the codebase really do this very well, and in general this is a little bit all over the place. e.g. see TransactionManagers#withRefreshingLockService does the exact same thing.\nI fixed it now, but I think this whole class needs a bit of a cleanup wrt. resource handling potentially.", "author": "jkozlowski", "createdAt": "2020-06-01T20:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3MTkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3ODc1MA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433378750", "bodyText": "nit: typo in arg name (newLockWatches?)", "author": "jeremyk-91", "createdAt": "2020-06-01T17:26:30Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchManagerImpl.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.timelock.api.LockWatchRequest;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.lock.client.NamespacedConjureLockWatchingService;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+public final class LockWatchManagerImpl extends LockWatchManager implements AutoCloseable {\n+\n+    private static final Logger log = LoggerFactory.getLogger(LockWatchManagerImpl.class);\n+\n+    private final Set<LockWatchReferences.LockWatchReference> lockWatchReferences = new HashSet<>();\n+    private final LockWatchEventCache lockWatchEventCache;\n+    private final NamespacedConjureLockWatchingService lockWatchingService;\n+    private final ScheduledExecutorService executorService = PTExecutors.newSingleThreadScheduledExecutor();\n+    private final ScheduledFuture<?> refreshTask;\n+\n+    public LockWatchManagerImpl(LockWatchEventCache lockWatchEventCache,\n+            NamespacedConjureLockWatchingService lockWatchingService) {\n+        this.lockWatchEventCache = lockWatchEventCache;\n+        this.lockWatchingService = lockWatchingService;\n+        refreshTask = executorService.scheduleWithFixedDelay(this::reregisterWatches, 0, 5,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    CommitUpdate getCommitUpdate(long startTs) {\n+        return lockWatchEventCache.getCommitUpdate(startTs);\n+    }\n+\n+    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> version) {\n+        return lockWatchEventCache.getEventsForTransactions(startTimestamps, version);\n+    }\n+\n+    @Override\n+    public void close() {\n+        refreshTask.cancel(false);\n+        executorService.shutdown();\n+    }\n+\n+    @Override\n+    public synchronized void registerWatches(Set<LockWatchReferences.LockWatchReference> newLockwatches) {", "originalCommit": "fec920760689dbc3844f49b19bdc0e5f0e30af10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2Njk3OQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433466979", "bodyText": "Fixed", "author": "jkozlowski", "createdAt": "2020-06-01T20:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3ODc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3OTM4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433379387", "bodyText": "interesting - I suppose it doesn't matter massively, but was there a reason we went for this as opposed to a concurrent set? Since we only add it should be eventually consistent in either case", "author": "jeremyk-91", "createdAt": "2020-06-01T17:27:40Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/api/watch/LockWatchManagerImpl.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.api.watch;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.atlasdb.timelock.api.LockWatchRequest;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.lock.client.NamespacedConjureLockWatchingService;\n+import com.palantir.lock.watch.CommitUpdate;\n+import com.palantir.lock.watch.IdentifiedVersion;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.TransactionsLockWatchEvents;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+public final class LockWatchManagerImpl extends LockWatchManager implements AutoCloseable {\n+\n+    private static final Logger log = LoggerFactory.getLogger(LockWatchManagerImpl.class);\n+\n+    private final Set<LockWatchReferences.LockWatchReference> lockWatchReferences = new HashSet<>();\n+    private final LockWatchEventCache lockWatchEventCache;\n+    private final NamespacedConjureLockWatchingService lockWatchingService;\n+    private final ScheduledExecutorService executorService = PTExecutors.newSingleThreadScheduledExecutor();\n+    private final ScheduledFuture<?> refreshTask;\n+\n+    public LockWatchManagerImpl(LockWatchEventCache lockWatchEventCache,\n+            NamespacedConjureLockWatchingService lockWatchingService) {\n+        this.lockWatchEventCache = lockWatchEventCache;\n+        this.lockWatchingService = lockWatchingService;\n+        refreshTask = executorService.scheduleWithFixedDelay(this::reregisterWatches, 0, 5,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    CommitUpdate getCommitUpdate(long startTs) {\n+        return lockWatchEventCache.getCommitUpdate(startTs);\n+    }\n+\n+    TransactionsLockWatchEvents getEventsForTransactions(Set<Long> startTimestamps,\n+            Optional<IdentifiedVersion> version) {\n+        return lockWatchEventCache.getEventsForTransactions(startTimestamps, version);\n+    }\n+\n+    @Override\n+    public void close() {\n+        refreshTask.cancel(false);\n+        executorService.shutdown();\n+    }\n+\n+    @Override\n+    public synchronized void registerWatches(Set<LockWatchReferences.LockWatchReference> newLockwatches) {\n+        lockWatchReferences.addAll(newLockwatches);\n+    }\n+\n+    private synchronized void reregisterWatches() {", "originalCommit": "fec920760689dbc3844f49b19bdc0e5f0e30af10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2OTU2OQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433469569", "bodyText": "ah yes, good catch. I didn't consider that this will block calls where we add it, while we're calling timelock.", "author": "jkozlowski", "createdAt": "2020-06-01T20:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3OTM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MjYzMQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433382631", "bodyText": "non-actionable: I guess this is already there so it doesn't really matter, but collecting to a list here is kind of unnecessary", "author": "jeremyk-91", "createdAt": "2020-06-01T17:33:39Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -164,38 +161,35 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n             throws E, TransactionFailedRetriableException {\n         checkOpen();\n         try {\n-            List<StartTransactionRequest> request = ImmutableList.of(ImmutableStartTransactionRequest.builder()\n-                            .preCommitCondition(condition)\n-                            .build());\n-\n             OpenTransaction openTransaction =\n-                    runTimed(() -> Iterables.getOnlyElement(startTransactions(request).getTransactions()), \"setupTask\");\n+                    runTimed(() -> Iterables.getOnlyElement(startTransactions(ImmutableList.of(condition))),\n+                            \"setupTask\");\n             return openTransaction.finish(transaction -> task.execute(transaction, condition));\n         } finally {\n             condition.cleanup();\n         }\n     }\n \n     @Override\n-    public StartTransactionsResponse startTransactions(List<StartTransactionRequest> requests) {\n-        if (requests.isEmpty()) {\n-            return new DefaultStartTransactionsResponse(ImmutableList.of());\n+    public List<OpenTransaction> startTransactions(List<? extends PreCommitCondition> conditions) {\n+        if (conditions.isEmpty()) {\n+            return ImmutableList.of();\n         }\n \n         List<StartIdentifiedAtlasDbTransactionResponse> responses =\n-                timelockService.startIdentifiedAtlasDbTransactionBatch(requests.size());\n-        Preconditions.checkState(requests.size() == responses.size(), \"Different number of responses and conditions\");\n+                timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n+        Preconditions.checkState(conditions.size() == responses.size(), \"Different number of responses and conditions\");\n         try {\n             long immutableTs = Collections.max(responses.stream()\n                     .map(response -> response.immutableTimestamp().getImmutableTimestamp())\n                     .collect(Collectors.toList()));", "originalCommit": "fec920760689dbc3844f49b19bdc0e5f0e30af10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3MDUzNg==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433470536", "bodyText": "Fixed", "author": "jkozlowski", "createdAt": "2020-06-01T20:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MjYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NDU2Mg==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433384562", "bodyText": "We're probably going to need to declare a product dependency in the manifest on the first version of timelock-server when getCommitTimestamps was introduced (I doubt that is 0.144.0).", "author": "jeremyk-91", "createdAt": "2020-06-01T17:37:23Z", "path": "lock-api/src/main/java/com/palantir/lock/client/NamespacedConjureTimelockService.java", "diffHunk": "@@ -49,6 +51,10 @@ public ConjureGetFreshTimestampsResponse getFreshTimestamps(ConjureGetFreshTimes\n         return conjureTimelockService.getFreshTimestamps(AUTH_HEADER, namespace, request);\n     }\n \n+    public GetCommitTimestampsResponse getCommitTimestamps(GetCommitTimestampsRequest request) {\n+        return conjureTimelockService.getCommitTimestamps(AUTH_HEADER, namespace, request);\n+    }", "originalCommit": "fec920760689dbc3844f49b19bdc0e5f0e30af10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMDA2Nw==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433700067", "bodyText": "Found it! good catch", "author": "jkozlowski", "createdAt": "2020-06-02T08:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NDU2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMDMyMg==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433700322", "bodyText": "I got the version as earliest that had this commit: 69610e0", "author": "jkozlowski", "createdAt": "2020-06-02T08:16:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NDU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NzA2MA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433387060", "bodyText": "Could we have some docs to explain exactly what this is? I'm tempted to name this PossibleTransactionUpdate or MaybeUncommittedTransactionUpdate but it does feel like it will make stuff unreadable so wouldn't mind just documenting.\ne.g. This is a record of a transaction that successfully retrieved a commit timestamp, along with the lock token it acquired for its writes. Users MUST NOT assume that this transaction has successfully committed - it may or may not have.", "author": "jeremyk-91", "createdAt": "2020-06-01T17:42:02Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/TransactionUpdate.java", "diffHunk": "@@ -14,11 +14,15 @@\n  * limitations under the License.\n  */\n \n-package com.palantir.atlasdb.transaction.api;\n+package com.palantir.lock.watch;\n \n import org.immutables.value.Value;\n \n+import com.palantir.lock.v2.LockToken;\n+\n @Value.Immutable\n-public interface StartTransactionRequest {\n-    PreCommitCondition preCommitCondition();\n+public interface TransactionUpdate {", "originalCommit": "fec920760689dbc3844f49b19bdc0e5f0e30af10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MjY1NA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433692654", "bodyText": "Really, this is just an internal type for the cache to hold onto (and Jolyon might adjust to fit whatever he needs). But I'm happy to add the docs in the meantime.", "author": "jkozlowski", "createdAt": "2020-06-02T08:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NzA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxODEyNQ==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433418125", "bodyText": "non-actionable: This is a little tricky, but makes sense (the cache updates itself so in the next batch you only ask for the updates from that point onwards).", "author": "jeremyk-91", "createdAt": "2020-06-01T18:40:51Z", "path": "lock-api/src/main/java/com/palantir/lock/client/CommitTimestampGetter.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+\n+import org.immutables.value.Value;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.BatchElement;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.futures.AtlasFutures;\n+import com.palantir.atlasdb.timelock.api.GetCommitTimestampsResponse;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.ImmutableTransactionUpdate;\n+import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.lock.watch.TransactionUpdate;\n+\n+final class CommitTimestampGetter implements AutoCloseable {\n+    private final DisruptorAutobatcher<Request, Long> autobatcher;\n+\n+    private CommitTimestampGetter(DisruptorAutobatcher<Request, Long> autobatcher) {\n+        this.autobatcher = autobatcher;\n+    }\n+\n+    public static CommitTimestampGetter create(LockLeaseService leaseService, LockWatchEventCache cache) {\n+        DisruptorAutobatcher<Request, Long> autobatcher = Autobatchers\n+                .independent(consumer(leaseService, cache))\n+                .safeLoggablePurpose(\"get-commit-timestamp\")\n+                .build();\n+        return new CommitTimestampGetter(autobatcher);\n+    }\n+\n+    public long getCommitTimestamp(long startTs, LockToken commitLocksToken) {\n+        return AtlasFutures.getUnchecked(autobatcher.apply(ImmutableRequest.builder()\n+                .startTs(startTs)\n+                .commitLocksToken(commitLocksToken)\n+                .build()));\n+    }\n+\n+    @VisibleForTesting\n+    static Consumer<List<BatchElement<Request, Long>>> consumer(LockLeaseService leaseService,\n+            LockWatchEventCache cache) {\n+        return batch -> {\n+            int count = batch.size();\n+            List<Long> commitTimestamps = new ArrayList<>();\n+            while (commitTimestamps.size() < count) {\n+                GetCommitTimestampsResponse response = leaseService.getCommitTimestamps(cache.lastKnownVersion(),\n+                        count - commitTimestamps.size());\n+                commitTimestamps.addAll(process(batch.subList(commitTimestamps.size(), count), response, cache));\n+            }\n+\n+            for (int i = 0; i < count; i++) {\n+                batch.get(i).result().set(commitTimestamps.get(i));\n+            }", "originalCommit": "fec920760689dbc3844f49b19bdc0e5f0e30af10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5NDgwNA==", "url": "https://github.com/palantir/atlasdb/pull/4811#discussion_r433694804", "bodyText": "Yeah, this stitching is annoying, but I believe it's correct.", "author": "jkozlowski", "createdAt": "2020-06-02T08:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxODEyNQ=="}], "type": "inlineReview"}, {"oid": "30cd07920263744e1584a20ffbb724a6c5ff65cd", "url": "https://github.com/palantir/atlasdb/commit/30cd07920263744e1584a20ffbb724a6c5ff65cd", "message": "Closing multiple things.", "committedDate": "2020-06-01T20:18:39Z", "type": "commit"}, {"oid": "408419bde327e341a5ec9d18c063118dfc9d7e2e", "url": "https://github.com/palantir/atlasdb/commit/408419bde327e341a5ec9d18c063118dfc9d7e2e", "message": "Fixup.", "committedDate": "2020-06-01T20:19:55Z", "type": "commit"}, {"oid": "30614bd5f09c812e16c5c8887e2fee32e4fc55a8", "url": "https://github.com/palantir/atlasdb/commit/30614bd5f09c812e16c5c8887e2fee32e4fc55a8", "message": "Fixup", "committedDate": "2020-06-01T20:23:09Z", "type": "commit"}, {"oid": "815809a937c7aac725b607184c668793a3874352", "url": "https://github.com/palantir/atlasdb/commit/815809a937c7aac725b607184c668793a3874352", "message": "Remove collection.", "committedDate": "2020-06-01T20:26:48Z", "type": "commit"}, {"oid": "2d9b4c55365db5f45823f547df5963f736b49f0c", "url": "https://github.com/palantir/atlasdb/commit/2d9b4c55365db5f45823f547df5963f736b49f0c", "message": "DOcs and product dependency.", "committedDate": "2020-06-02T08:15:45Z", "type": "commit"}, {"oid": "79f09b68065748727c25ceea65cdf47c839f7b0b", "url": "https://github.com/palantir/atlasdb/commit/79f09b68065748727c25ceea65cdf47c839f7b0b", "message": "Revert product dependency bump.", "committedDate": "2020-06-02T09:05:49Z", "type": "commit"}, {"oid": "a71acdf83313f096170108d97b9b90e978d3b095", "url": "https://github.com/palantir/atlasdb/commit/a71acdf83313f096170108d97b9b90e978d3b095", "message": "Align versions.", "committedDate": "2020-06-02T09:11:17Z", "type": "commit"}, {"oid": "39baf3845be7e1df18d8ccbfd07e299b91de30a4", "url": "https://github.com/palantir/atlasdb/commit/39baf3845be7e1df18d8ccbfd07e299b91de30a4", "message": "Remove declaration from lock-api.", "committedDate": "2020-06-02T09:18:02Z", "type": "commit"}]}