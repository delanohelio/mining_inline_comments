{"pr_number": 4692, "pr_title": "[Timelock Partitioning] Test Switching Between SL and Batched SL", "pr_createdAt": "2020-04-01T14:14:13Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4692", "timeline": [{"oid": "d968284b491f772b95a18b83effe2578777ad84b", "url": "https://github.com/palantir/atlasdb/commit/d968284b491f772b95a18b83effe2578777ad84b", "message": "Add tests for migrating between single leader and batched single leader", "committedDate": "2020-04-01T14:04:49Z", "type": "commit"}, {"oid": "701a376e3057f915a8b253bd5e8b104ed5d8b2ad", "url": "https://github.com/palantir/atlasdb/commit/701a376e3057f915a8b253bd5e8b104ed5d8b2ad", "message": "Checkstyle", "committedDate": "2020-04-01T14:17:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2Mjg1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4692#discussion_r401662853", "bodyText": "Eh... not really a fan of this, but I guess the alternative is adding another mode to install config, and we want this to be runtime configurable. I wouldn't block on this, though maybe we should add a TODO to consider going via runtime configuration once this becomes available.", "author": "jeremyk-91", "createdAt": "2020-04-01T14:33:22Z", "path": "timelock-server/src/testCommon/java/com/palantir/atlasdb/timelock/TestableTimelockServer.java", "diffHunk": "@@ -77,9 +81,24 @@ void start() {\n         serverHolder.start();\n     }\n \n+    void startUsingBatchedSingleLeader() {\n+        switchToBatched = true;\n+    }\n+\n+    void stopUsingBatchedSingleLeader() {\n+        switchToBatched = false;\n+    }", "originalCommit": "701a376e3057f915a8b253bd5e8b104ed5d8b2ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIzNjgzMw==", "url": "https://github.com/palantir/atlasdb/pull/4692#discussion_r402236833", "bodyText": "That's reasonable, yup", "author": "gmaretic", "createdAt": "2020-04-02T11:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2Mjg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgzMjE1MA==", "url": "https://github.com/palantir/atlasdb/pull/4692#discussion_r401832150", "bodyText": "\u2764\ufe0f", "author": "jeremyk-91", "createdAt": "2020-04-01T18:45:03Z", "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/SingleLeaderMultiNodePaxosTimeLockIntegrationTest.java", "diffHunk": "@@ -84,4 +98,61 @@ public void noConflictIfLeaderAndNonLeadersSeparatelyInitializeClient() {\n         long ts2 = namespace.getFreshTimestamp();\n         assertThat(ts1).isLessThan(ts2);\n     }\n+\n+    @Test\n+    public void migrationToBatchedSingleLeaderHasConsistentSequenceNumbers() {\n+        NamespacedClients client = cluster.clientForRandomNamespace().throughWireMockProxy();\n+        cluster.waitUntilAllServersOnlineAndReadyToServeNamespaces(ImmutableList.of(client.namespace()));\n+\n+        List<Long> sequenceNumbers = new ArrayList<>();\n+\n+        for (TestableTimelockServer server : cluster.servers()) {\n+            server.startUsingBatchedSingleLeader();\n+            cluster.failoverToNewLeader(client.namespace());\n+            long sequenceForBatchedEndpoint = getSequenceForServerUsingBatchedEndpoint(server);\n+            long sequenceForOldEndpoint = getSequenceForServerUsingOldEndpoint(server);\n+            assertThat(sequenceForBatchedEndpoint).isLessThanOrEqualTo(sequenceForOldEndpoint);\n+            sequenceNumbers.add(sequenceForBatchedEndpoint);\n+        }\n+\n+        assertThat(sequenceNumbers).isSorted();\n+        assertThat(ImmutableSet.copyOf(sequenceNumbers)).hasSameSizeAs(sequenceNumbers);\n+    }\n+\n+    @Test\n+    public void reverseMigrationFromBatchedSingleLeaderHasConsistentSequenceNumbers() {\n+        NamespacedClients client = cluster.clientForRandomNamespace().throughWireMockProxy();\n+        cluster.waitUntilAllServersOnlineAndReadyToServeNamespaces(ImmutableList.of(client.namespace()));\n+        cluster.servers().forEach(TestableTimelockServer::startUsingBatchedSingleLeader);\n+        List<Long> sequenceNumbers = new ArrayList<>();\n+\n+        for (TestableTimelockServer server : cluster.servers()) {\n+            server.stopUsingBatchedSingleLeader();\n+            cluster.failoverToNewLeader(client.namespace());\n+            long sequenceForBatchedEndpoint = getSequenceForServerUsingBatchedEndpoint(server);\n+            long sequenceForOldEndpoint = getSequenceForServerUsingOldEndpoint(server);\n+            assertThat(sequenceForBatchedEndpoint).isLessThanOrEqualTo(sequenceForOldEndpoint);\n+            sequenceNumbers.add(sequenceForBatchedEndpoint);\n+        }\n+\n+        assertThat(sequenceNumbers).isSorted();\n+        assertThat(ImmutableSet.copyOf(sequenceNumbers)).hasSameSizeAs(sequenceNumbers);", "originalCommit": "701a376e3057f915a8b253bd5e8b104ed5d8b2ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}