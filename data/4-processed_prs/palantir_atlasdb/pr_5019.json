{"pr_number": 5019, "pr_title": "Revert revert dvkvs invalidator", "pr_createdAt": "2020-10-08T10:27:18Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5019", "timeline": [{"oid": "9de7a03f14d8b2b10768d90005f5b7c307019046", "url": "https://github.com/palantir/atlasdb/commit/9de7a03f14d8b2b10768d90005f5b7c307019046", "message": "Revert \"Revert 5010 (#5016)\"\n\nThis reverts commit 54b18788bff7a48d05a0a4ab3f828875d45defd9.", "committedDate": "2020-10-07T14:59:20Z", "type": "commit"}, {"oid": "3a8be9180ebf0f93b8de880e733c1771e2e63ef6", "url": "https://github.com/palantir/atlasdb/commit/3a8be9180ebf0f93b8de880e733c1771e2e63ef6", "message": "Remove fail fast | remove incorrect hasColumns check", "committedDate": "2020-10-08T10:24:00Z", "type": "commit"}, {"oid": "eb908bcfbb00fa4011b5dce4e663ef4fd5dbc134", "url": "https://github.com/palantir/atlasdb/commit/eb908bcfbb00fa4011b5dce4e663ef4fd5dbc134", "message": "Checkstyle", "committedDate": "2020-10-12T12:22:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI2MzI2NQ==", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r503263265", "bodyText": "Check on the RC if this works with Oracle", "author": "sudiksha27", "createdAt": "2020-10-12T12:32:37Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.DatabaseMetaData;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.CreateTimestampTableQueries;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.PhysicalBoundStoreDatabaseUtils;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+    private final String tablePrefix;\n+\n+    public InvalidationRunner(ConnectionManager connManager, TableReference timestampTable, String tablePrefixString) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+        this.tablePrefix = tablePrefixString;\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    public void createTimestampTable(Connection conn) throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                conn,\n+                ConnectionDbTypes::getDbType,\n+                CreateTimestampTableQueries.getCreateTableQueriesForLegacyStore(prefixedTimestampTableName()));\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    private Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,\n+            TableStatus tableStatus) throws SQLException {\n+        long lastAllocated;\n+\n+        if (tableStatus == TableStatus.NO_DATA) {\n+            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        } else {\n+            lastAllocated = limits.upperLimit().get().value();\n+        }\n+\n+        poisonTable(connection);\n+        return lastAllocated;\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                poisonOracleTable(connection, statement);\n+            } else {\n+                poisonPostgresTable(connection, statement);\n+            }\n+        }\n+    }\n+\n+    private void poisonOracleTable(Connection connection, Statement statement) throws SQLException {\n+        try {\n+            statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN %s TO %s\",\n+                    prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+        } catch (SQLException e) {\n+            if (!PhysicalBoundStoreDatabaseUtils.oracleColumnDoesNotExistError(e)) {\n+                throw e;\n+            }\n+            // Do not need to commit transaction here as Oracle doesn't throw an exception when a\n+            // query fails on a connection within a transaction.\n+        }\n+    }\n+\n+    private void poisonPostgresTable(Connection connection, Statement statement) throws SQLException {\n+        try {\n+            statement.execute(String.format(\"ALTER TABLE %s RENAME %s TO %s\",\n+                    prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+        } catch (SQLException e) {\n+            if (!PhysicalBoundStoreDatabaseUtils.postgresColumnDoesNotExistError(e)) {\n+                throw e;\n+            } else {\n+                connection.commit();\n+            }\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        DatabaseMetaData metaData = connection.getMetaData();\n+        ResultSet res = metaData.getTables(null, null, prefixedTimestampTableName(), null);\n+\n+        Preconditions.checkState(res.next(), \"We are in the process of invalidating the \"\n+                + \"InDbTimestampBoundStore but the data table does not exist. \"\n+                + \"We should never reach here. Please contact support.\");\n+", "originalCommit": "eb908bcfbb00fa4011b5dce4e663ef4fd5dbc134", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa75b4a608e6998a86f9e184eabee7d55d29fe3d", "url": "https://github.com/palantir/atlasdb/commit/fa75b4a608e6998a86f9e184eabee7d55d29fe3d", "message": "Rollback, don't commit", "committedDate": "2020-10-12T13:33:34Z", "type": "commit"}, {"oid": "0e7554a396f9b1911107046bc597f072f0006862", "url": "https://github.com/palantir/atlasdb/commit/0e7554a396f9b1911107046bc597f072f0006862", "message": "Add generated changelog entries", "committedDate": "2020-10-12T13:33:34Z", "type": "commit"}, {"oid": "fa3ca3331e3f78760ea24a2e2770f237f92c891b", "url": "https://github.com/palantir/atlasdb/commit/fa3ca3331e3f78760ea24a2e2770f237f92c891b", "message": "Autorelease 0.249.1-rc1", "committedDate": "2020-10-12T13:38:17Z", "type": "commit"}, {"oid": "452a96d3af2fc26c1523c3e01c3f23d68b50177a", "url": "https://github.com/palantir/atlasdb/commit/452a96d3af2fc26c1523c3e01c3f23d68b50177a", "message": "No metaData check works with Oracle", "committedDate": "2020-10-13T12:52:21Z", "type": "commit"}, {"oid": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa", "url": "https://github.com/palantir/atlasdb/commit/b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa", "message": "Oh Oracle", "committedDate": "2020-10-13T13:28:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzNzk1OA==", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r504037958", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    long lastAllocated;\n          \n          \n            \n            \n          \n          \n            \n                    if (tableStatus == TableStatus.NO_DATA) {\n          \n          \n            \n                        lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        lastAllocated = limits.upperLimit().get().value();\n          \n          \n            \n                    }\n          \n          \n            \n                    long lastAllocated = tableStatus == TableStatus.NO_DATA\n          \n          \n            \n                            ? AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP\n          \n          \n            \n                            : limits.upperLimit().get().value();", "author": "jeremyk-91", "createdAt": "2020-10-13T15:17:37Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.CreateTimestampTableQueries;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.PhysicalBoundStoreDatabaseUtils;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+    private final String tablePrefix;\n+\n+    public InvalidationRunner(ConnectionManager connManager, TableReference timestampTable, String tablePrefixString) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+        this.tablePrefix = tablePrefixString;\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    public void createTimestampTable(Connection conn) throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                conn,\n+                ConnectionDbTypes::getDbType,\n+                CreateTimestampTableQueries.getCreateTableQueriesForLegacyStore(prefixedTimestampTableName()));\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    private Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,\n+            TableStatus tableStatus) throws SQLException {\n+        long lastAllocated;\n+\n+        if (tableStatus == TableStatus.NO_DATA) {\n+            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        } else {\n+            lastAllocated = limits.upperLimit().get().value();\n+        }", "originalCommit": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAzOTQ2OA==", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r504039468", "bodyText": "nit: enums are usually compared with == as opposed to Objects::equals", "author": "jeremyk-91", "createdAt": "2020-10-13T15:19:37Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.CreateTimestampTableQueries;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.PhysicalBoundStoreDatabaseUtils;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+    private final String tablePrefix;\n+\n+    public InvalidationRunner(ConnectionManager connManager, TableReference timestampTable, String tablePrefixString) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+        this.tablePrefix = tablePrefixString;\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    public void createTimestampTable(Connection conn) throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                conn,\n+                ConnectionDbTypes::getDbType,\n+                CreateTimestampTableQueries.getCreateTableQueriesForLegacyStore(prefixedTimestampTableName()));\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    private Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,\n+            TableStatus tableStatus) throws SQLException {\n+        long lastAllocated;\n+\n+        if (tableStatus == TableStatus.NO_DATA) {\n+            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        } else {\n+            lastAllocated = limits.upperLimit().get().value();\n+        }\n+\n+        poisonTable(connection);\n+        return lastAllocated;\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {", "originalCommit": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0MDY4Nw==", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r504040687", "bodyText": "nit: I don't think the comment is needed? Seems self-explanatory", "author": "jeremyk-91", "createdAt": "2020-10-13T15:21:05Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/InvalidationRunner.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs;\n+\n+import java.sql.Connection;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Optional;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.immutables.value.Value;\n+\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.ConnectionDbTypes;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.CreateTimestampTableQueries;\n+import com.palantir.atlasdb.keyvalue.dbkvs.timestamp.PhysicalBoundStoreDatabaseUtils;\n+import com.palantir.atlasdb.spi.AtlasDbFactory;\n+import com.palantir.common.base.Throwables;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+import com.palantir.nexus.db.DBType;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+import com.palantir.nexus.db.pool.RetriableTransactions;\n+\n+public class InvalidationRunner {\n+    private static final String LAST_ALLOCATED = \"last_allocated\";\n+    private static final String LEGACY_LAST_ALLOCATED = \"legacy_last_allocated\";\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+    private final String tablePrefix;\n+\n+    public InvalidationRunner(ConnectionManager connManager, TableReference timestampTable, String tablePrefixString) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+        this.tablePrefix = tablePrefixString;\n+    }\n+\n+    public void createTableIfDoesNotExist() {\n+        try (Connection conn = connManager.getConnection()) {\n+            createTimestampTable(conn);\n+        } catch (SQLException error) {\n+            throw PalantirSqlException.create(error);\n+        }\n+    }\n+\n+    public void createTimestampTable(Connection conn) throws SQLException {\n+        PhysicalBoundStoreDatabaseUtils.createTimestampTable(\n+                conn,\n+                ConnectionDbTypes::getDbType,\n+                CreateTimestampTableQueries.getCreateTableQueriesForLegacyStore(prefixedTimestampTableName()));\n+    }\n+\n+    public long ensureInDbStoreIsPoisonedAndGetLastAllocatedTimestamp() {\n+        RetriableTransactions.TransactionResult<Long> result = RetriableTransactions.run(connManager,\n+                connection -> {\n+                    Limits limits = getLimits(connection);\n+                    TableStatus tableStatus = checkTableStatus(limits);\n+\n+                    if (tableStatus == TableStatus.POISONED) {\n+                        return limits.legacyUpperLimit().get().value();\n+                    }\n+                    return poisonStoreAndGetLastAllocatedTimestamp(connection, limits, tableStatus);\n+                });\n+\n+        switch (result.getStatus()) {\n+            case SUCCESSFUL:\n+                return result.getResultValue();\n+            case UNKNOWN:\n+            case FAILED:\n+                Throwable error = result.getError();\n+                if (error instanceof SQLException) {\n+                    throw PalantirSqlException.create((SQLException) error);\n+                }\n+                throw Throwables.rewrapAndThrowUncheckedException(error);\n+            default:\n+                throw new SafeIllegalStateException(\"Unrecognized transaction status.\",\n+                        SafeArg.of(\"status\", result.getStatus()));\n+        }\n+    }\n+\n+    private Long poisonStoreAndGetLastAllocatedTimestamp(Connection connection, Limits limits,\n+            TableStatus tableStatus) throws SQLException {\n+        long lastAllocated;\n+\n+        if (tableStatus == TableStatus.NO_DATA) {\n+            lastAllocated = AtlasDbFactory.NO_OP_FAST_FORWARD_TIMESTAMP;\n+        } else {\n+            lastAllocated = limits.upperLimit().get().value();\n+        }\n+\n+        poisonTable(connection);\n+        return lastAllocated;\n+    }\n+\n+    private void poisonTable(Connection connection) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            if (ConnectionDbTypes.getDbType(connection).equals(DBType.ORACLE)) {\n+                poisonOracleTable(connection, statement);\n+            } else {\n+                poisonPostgresTable(connection, statement);\n+            }\n+        }\n+    }\n+\n+    private void poisonOracleTable(Connection connection, Statement statement) throws SQLException {\n+        try {\n+            statement.execute(String.format(\"ALTER TABLE %s RENAME COLUMN %s TO %s\",\n+                    prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+        } catch (SQLException e) {\n+            if (!PhysicalBoundStoreDatabaseUtils.oracleDuplicateColumnError(e)) {\n+                throw e;\n+            }\n+            connection.rollback();\n+        }\n+    }\n+\n+    private void poisonPostgresTable(Connection connection, Statement statement) throws SQLException {\n+        try {\n+            statement.execute(String.format(\"ALTER TABLE %s RENAME %s TO %s\",\n+                    prefixedTimestampTableName(), LAST_ALLOCATED, LEGACY_LAST_ALLOCATED));\n+        } catch (SQLException e) {\n+            if (!PhysicalBoundStoreDatabaseUtils.postgresColumnDoesNotExistError(e)) {\n+                throw e;\n+            }\n+            connection.rollback();\n+        }\n+    }\n+\n+    private Limits getLimits(Connection connection) throws SQLException {\n+        String sql = String.format(\"SELECT * FROM %s FOR UPDATE\", prefixedTimestampTableName());\n+        QueryRunner run = new QueryRunner();\n+        return run.query(connection, sql, rs -> {\n+            if (rs.next()) {\n+                return ImmutableLimits.builder()\n+                        .upperLimit(getColumnStatusFromResultSet(rs, LAST_ALLOCATED))\n+                        .legacyUpperLimit(getColumnStatusFromResultSet(rs, LEGACY_LAST_ALLOCATED))\n+                        .build();\n+            } else {\n+                return ImmutableLimits.builder().build();\n+            }\n+        });\n+    }\n+\n+    private Optional<ColumnStatus> getColumnStatusFromResultSet(ResultSet rs, String colName) throws SQLException {\n+        try {\n+            return ColumnStatus.columnStatusWithValue(rs.getLong(colName));\n+        } catch (SQLException e) {\n+            if (PhysicalBoundStoreDatabaseUtils.oracleInvalidColumnError(e)\n+                    || PhysicalBoundStoreDatabaseUtils.postgresColumnDoesNotExistError(e)) {\n+                return Optional.empty();\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private TableStatus checkTableStatus(Limits limits) {\n+        TableStatus status = getTableStatus(limits);\n+\n+        Preconditions.checkState(status != TableStatus.BOTH_COLUMNS,\n+                \"We detected the table has been poisoned but last_allocated column still exists.\"\n+                        + \"This is unexpected. Please contact support.\");\n+        return status;\n+    }\n+\n+    private TableStatus getTableStatus(Limits limits) {\n+        boolean upperLimitExists = limits.upperLimit().isPresent();\n+        boolean legacyUpperLimitExists = limits.legacyUpperLimit().isPresent();\n+\n+        if (upperLimitExists) {\n+            return legacyUpperLimitExists ? TableStatus.BOTH_COLUMNS : TableStatus.HEALTHY;\n+        }\n+        return legacyUpperLimitExists ? TableStatus.POISONED : TableStatus.NO_DATA; // no data in table", "originalCommit": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0MTg0MQ==", "url": "https://github.com/palantir/atlasdb/pull/5019#discussion_r504041841", "bodyText": "nit: These boolean methods usually have verbs indicating they are predicates e.g. isTableAlreadyExistsError(...)", "author": "jeremyk-91", "createdAt": "2020-10-13T15:22:33Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/PhysicalBoundStoreDatabaseUtils.java", "diffHunk": "@@ -63,17 +63,27 @@ private static void createTimestampTableIgnoringAlreadyExistsError(\n         }\n     }\n \n+    public static boolean tableAlreadyExistsError(SQLException exception) {", "originalCommit": "b9a3aef44f4c72a14f787bc8bc9c9446e8d255aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "276417ad00920d823a8130db7744ab4b842e8c7f", "url": "https://github.com/palantir/atlasdb/commit/276417ad00920d823a8130db7744ab4b842e8c7f", "message": "Address comments", "committedDate": "2020-10-13T15:44:08Z", "type": "commit"}]}