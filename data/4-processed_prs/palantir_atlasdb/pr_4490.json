{"pr_number": 4490, "pr_title": "Batched off-heap timestamp cache implementation", "pr_createdAt": "2020-01-07T15:59:19Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4490", "timeline": [{"oid": "0c81599960bf4a510431450704a868b4021d8ac2", "url": "https://github.com/palantir/atlasdb/commit/0c81599960bf4a510431450704a868b4021d8ac2", "message": "Multiput and multiget.", "committedDate": "2020-01-07T13:12:25Z", "type": "commit"}, {"oid": "f226f48b4a04797b82113da2f4d9fb92b81f4a5c", "url": "https://github.com/palantir/atlasdb/commit/f226f48b4a04797b82113da2f4d9fb92b81f4a5c", "message": "Batching timestamp cache.", "committedDate": "2020-01-07T15:00:35Z", "type": "commit"}, {"oid": "d3a33c8af992ee3c9097777f68d3216f77b6ce43", "url": "https://github.com/palantir/atlasdb/commit/d3a33c8af992ee3c9097777f68d3216f77b6ce43", "message": "Changes.", "committedDate": "2020-01-07T15:22:13Z", "type": "commit"}, {"oid": "429d45db40adaf6a5acbd8effba96e5954f96e8d", "url": "https://github.com/palantir/atlasdb/commit/429d45db40adaf6a5acbd8effba96e5954f96e8d", "message": "Added a clear.", "committedDate": "2020-01-07T15:29:18Z", "type": "commit"}, {"oid": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "url": "https://github.com/palantir/atlasdb/commit/87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "message": "Add multi tests.", "committedDate": "2020-01-07T15:51:51Z", "type": "commit"}, {"oid": "ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "url": "https://github.com/palantir/atlasdb/commit/ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "message": "Small refactor.", "committedDate": "2020-01-07T16:21:51Z", "type": "forcePushed"}, {"oid": "4546457e9bc9068359f771d9ecce8902590300ae", "url": "https://github.com/palantir/atlasdb/commit/4546457e9bc9068359f771d9ecce8902590300ae", "message": "Small refactor.", "committedDate": "2020-01-07T16:39:36Z", "type": "commit"}, {"oid": "4546457e9bc9068359f771d9ecce8902590300ae", "url": "https://github.com/palantir/atlasdb/commit/4546457e9bc9068359f771d9ecce8902590300ae", "message": "Small refactor.", "committedDate": "2020-01-07T16:39:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjExOA==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363826118", "bodyText": "It's probably enough to just return Map<Long, Long>", "author": "jeremyk-91", "createdAt": "2020-01-07T16:13:44Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java", "diffHunk": "@@ -68,6 +78,39 @@ public Long get(StoreNamespace storeNamespace, @Nonnull Long startTs) {\n         return startTs + (Long) ValueType.VAR_LONG.convertToJava(value, 0);\n     }\n \n+    @Override\n+    public Set<Map.Entry<Long, Long>> multiGet(StoreNamespace storeNamespace, List<Long> keys) {", "originalCommit": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1Mzk4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363853989", "bodyText": "Changed.", "author": "OStevan", "createdAt": "2020-01-07T17:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjU4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363826581", "bodyText": "We could refactor this to a separate check?", "author": "jeremyk-91", "createdAt": "2020-01-07T16:14:42Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java", "diffHunk": "@@ -68,6 +78,39 @@ public Long get(StoreNamespace storeNamespace, @Nonnull Long startTs) {\n         return startTs + (Long) ValueType.VAR_LONG.convertToJava(value, 0);\n     }\n \n+    @Override\n+    public Set<Map.Entry<Long, Long>> multiGet(StoreNamespace storeNamespace, List<Long> keys) {\n+        Preconditions.checkArgument(\n+                availableColumnFamilies.containsKey(storeNamespace.uniqueName()),\n+                \"Store namespace does not exist\");", "originalCommit": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjY5MQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852691", "bodyText": "Refactored.", "author": "OStevan", "createdAt": "2020-01-07T17:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjg0Mg==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363826842", "bodyText": "as above, it may be easier to pass in Map<Long, Long>", "author": "jeremyk-91", "createdAt": "2020-01-07T16:15:14Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java", "diffHunk": "@@ -80,6 +123,13 @@ public void put(StoreNamespace storeNamespace, @Nonnull Long startTs, @Nonnull L\n         putEntry(availableColumnFamilies.get(storeNamespace.uniqueName()), key, value);\n     }\n \n+    @Override\n+    public void multiPut(StoreNamespace storeNamespace, Set<Map.Entry<Long, Long>> toWrite) {\n+        for (Map.Entry<Long, Long> entry : toWrite) {", "originalCommit": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1Mjc0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852741", "bodyText": "Changed.", "author": "OStevan", "createdAt": "2020-01-07T17:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgzMDA4NA==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363830084", "bodyText": "nit: could we name this with what the autobatcher actually does? i.e. cellPutter or something like that", "author": "jeremyk-91", "createdAt": "2020-01-07T16:21:42Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;", "originalCommit": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MzU4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363843589", "bodyText": "similar with concurrentHashMap - maybe inflightRequests", "author": "jeremyk-91", "createdAt": "2020-01-07T16:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgzMDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjM3Mw==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852373", "bodyText": "Refactored.", "author": "OStevan", "createdAt": "2020-01-07T17:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgzMDA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MTI4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363841287", "bodyText": "How does this case arise? Might be worth a comment: it's not obvious how this happens", "author": "jeremyk-91", "createdAt": "2020-01-07T16:44:09Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {\n+        StoreNamespace proposal = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+        return ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(proposal)\n+                .build();\n+    }\n+\n+    private static class WriteBatcher\n+            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+        OffHeapTimestampCache offHeapTimestampCache;\n+\n+        WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n+            this.offHeapTimestampCache = offHeapTimestampCache;\n+        }\n+\n+        @Override\n+        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+            if (offHeapTimestampCache.cacheDescriptor.get().currentSize().get() >= offHeapTimestampCache.maxSize) {\n+                offHeapTimestampCache.clear();\n+            }\n+            CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n+            try {\n+                Map<Long, Long> response = offHeapTimestampCache.persistentTimestampStore.multiGet(\n+                        cacheDescriptor.storeNamespace(),\n+                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n+\n+                Set<Map.Entry<Long, Long>> toWrite = Sets.difference(request, response.entrySet());\n+                offHeapTimestampCache.persistentTimestampStore.multiPut(\n+                        cacheDescriptor.storeNamespace(),\n+                        toWrite);\n+\n+                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+            } catch (SafeIllegalArgumentException exception) {\n+                log.warn(\"Clear called concurrently, writing failed\");", "originalCommit": "4546457e9bc9068359f771d9ecce8902590300ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NDgzNA==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363844834", "bodyText": "Probably worth defensively logging what the exception is", "author": "jeremyk-91", "createdAt": "2020-01-07T16:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MTI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjYwMg==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852602", "bodyText": "Added a comment and logging the exception.", "author": "OStevan", "createdAt": "2020-01-07T17:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MTI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NTc0NA==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363845744", "bodyText": "possible race condition here in that concurrentHashMap may have extra entries cleared, but this is OK as this is only used to skip reads for values that are about to be written", "author": "jeremyk-91", "createdAt": "2020-01-07T16:53:03Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {\n+        StoreNamespace proposal = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+        return ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(proposal)\n+                .build();\n+    }\n+\n+    private static class WriteBatcher\n+            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+        OffHeapTimestampCache offHeapTimestampCache;\n+\n+        WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n+            this.offHeapTimestampCache = offHeapTimestampCache;\n+        }\n+\n+        @Override\n+        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+            if (offHeapTimestampCache.cacheDescriptor.get().currentSize().get() >= offHeapTimestampCache.maxSize) {\n+                offHeapTimestampCache.clear();\n+            }\n+            CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n+            try {\n+                Map<Long, Long> response = offHeapTimestampCache.persistentTimestampStore.multiGet(\n+                        cacheDescriptor.storeNamespace(),\n+                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n+\n+                Set<Map.Entry<Long, Long>> toWrite = Sets.difference(request, response.entrySet());\n+                offHeapTimestampCache.persistentTimestampStore.multiPut(\n+                        cacheDescriptor.storeNamespace(),\n+                        toWrite);\n+\n+                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+            } catch (SafeIllegalArgumentException exception) {\n+                log.warn(\"Clear called concurrently, writing failed\");\n+            } finally {\n+                offHeapTimestampCache.concurrentHashMap.clear();", "originalCommit": "4546457e9bc9068359f771d9ecce8902590300ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NjQzNw==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363846437", "bodyText": "nit: would suggest renaming, maybe to createNamespaceAndConstructCacheProposal since this has side effects", "author": "jeremyk-91", "createdAt": "2020-01-07T16:54:23Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {", "originalCommit": "4546457e9bc9068359f771d9ecce8902590300ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjQ0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852441", "bodyText": "Renamed.", "author": "OStevan", "createdAt": "2020-01-07T17:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NjQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0ODExNQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363848115", "bodyText": "nit: cacheNukedWhenSizeLimitExceeded", "author": "jeremyk-91", "createdAt": "2020-01-07T16:57:44Z", "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/cache/OffHeapTimestampCacheIntegrationTests.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.rocksdb.RocksDbPersistentTimestampStore;\n+\n+public final class OffHeapTimestampCacheIntegrationTests {\n+    @ClassRule\n+    public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+    private static final int CACHE_SIZE = 2;\n+\n+    private TimestampCache offHeapTimestampCache;\n+    private PersistentTimestampStore persistentTimestampStore;\n+\n+    @Before\n+    public void before() throws RocksDBException, IOException {\n+        RocksDB rocksDb = RocksDB.open(TEMPORARY_FOLDER.newFolder().getAbsolutePath());\n+\n+        persistentTimestampStore = new RocksDbPersistentTimestampStore(rocksDb);\n+\n+        offHeapTimestampCache = OffHeapTimestampCache.create(persistentTimestampStore, CACHE_SIZE);\n+    }\n+\n+    @After\n+    public void after() throws Exception {\n+        persistentTimestampStore.close();\n+    }\n+\n+    @Test\n+    public void cachedEntry() {\n+        offHeapTimestampCache.putAlreadyCommittedTransaction(1L, 3L);\n+\n+        assertThat(offHeapTimestampCache.getCommitTimestampIfPresent(1L)).isEqualTo(3L);\n+    }\n+\n+    @Test\n+    public void nonCachedEntry() {\n+        assertThat(offHeapTimestampCache.getCommitTimestampIfPresent(1L)).isNull();\n+    }\n+\n+    @Test\n+    public void cacheNuked() {", "originalCommit": "4546457e9bc9068359f771d9ecce8902590300ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjgyNw==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852827", "bodyText": "Renamed.", "author": "OStevan", "createdAt": "2020-01-07T17:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0ODExNQ=="}], "type": "inlineReview"}, {"oid": "251fc3cd16fca086c086b40bee40159a907273a3", "url": "https://github.com/palantir/atlasdb/commit/251fc3cd16fca086c086b40bee40159a907273a3", "message": "Comments.", "committedDate": "2020-01-07T17:09:22Z", "type": "commit"}, {"oid": "eece8a5d58d4ee46407e7ba904e418ecdeed92a1", "url": "https://github.com/palantir/atlasdb/commit/eece8a5d58d4ee46407e7ba904e418ecdeed92a1", "message": "Renamed a wrong change.", "committedDate": "2020-01-07T17:15:02Z", "type": "commit"}]}