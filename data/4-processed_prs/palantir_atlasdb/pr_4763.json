{"pr_number": 4763, "pr_title": "[Dialogue] Part 3: AtlasDbDialogueServiceProvider", "pr_createdAt": "2020-05-11T20:08:58Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4763", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMDIwMg==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423330202", "bodyText": "Is this new? In our initial testing I think we used the concurrency limiters without running into problems. In dialogue we've tried to allow them to ramp up more more quickly than CJR. There's definitely a bit of risk as we continue to tune the rate limiters, but it could help us avoid knocking over lock with too many handshakes.", "author": "carterkozak", "createdAt": "2020-05-11T21:27:40Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProvider.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.AuxiliaryRemotingParameters;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.factory.timelock.ImmutableShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.ShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.TimeoutSensitiveConjureTimelockService;\n+import com.palantir.atlasdb.http.AtlasDbHttpProtocolVersion;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.http.v2.DialogueClientOptions;\n+import com.palantir.atlasdb.http.v2.FastFailoverProxy;\n+import com.palantir.atlasdb.http.v2.ImmutableRemoteServiceConfiguration;\n+import com.palantir.atlasdb.http.v2.RemoteServiceConfiguration;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockServiceBlocking;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.client.config.ClientConfiguration;\n+import com.palantir.conjure.java.client.config.NodeSelectionStrategy;\n+import com.palantir.dialogue.Channel;\n+import com.palantir.dialogue.ConjureRuntime;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.lock.client.DialogueAdaptingConjureTimelockService;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.refreshable.Refreshable;\n+\n+/**\n+ * Provides a mechanism for accessing services that use Dialogue for communication. A service is defined as a cluster of\n+ * zero or more nodes, where contacting any of the nodes is legitimate (subject to redirects via 308s and 503s). If\n+ * working with heterogeneous nodes and/or broadcast is important (e.g. for Paxos Acceptor use cases), you should be\n+ * VERY careful when using this class.\n+ *\n+ * Proxies must be resilient to servers repeatedly returning 308s that are large in number, but persist for only a short\n+ * duration. Furthermore, proxies should include in their {@link com.palantir.conjure.java.api.config.service.UserAgent}\n+ * information to allow client services to identify the protocol they are using to talk, via\n+ * {@link AtlasDbHttpProtocolVersion}.\n+ */\n+public final class AtlasDbDialogueServiceProvider {\n+    private static final String TIMELOCK_SHORT_TIMEOUT = \"timelock-short-timeout\";\n+    private static final String TIMELOCK_LONG_TIMEOUT = \"timelock-long-timeout\";\n+    private final DialogueClients.ReloadingFactory dialogueClientFactory;\n+\n+    private AtlasDbDialogueServiceProvider(DialogueClients.ReloadingFactory dialogueClientFactory) {\n+        this.dialogueClientFactory = dialogueClientFactory;\n+    }\n+\n+    public static AtlasDbDialogueServiceProvider create(\n+            Refreshable<ServerListConfig> timeLockServerListConfig,\n+            DialogueClients.ReloadingFactory baseFactory,\n+            UserAgent userAgent) {\n+        UserAgent versionedAgent = userAgent.addAgent(AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT_AGENT);\n+        Refreshable<Map<String, RemoteServiceConfiguration>> timeLockRemoteConfigurations = timeLockServerListConfig\n+                .map(serverListConfig -> ImmutableMap.of(\n+                        TIMELOCK_SHORT_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, false),\n+                        TIMELOCK_LONG_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, true)));\n+        DialogueClients.ReloadingFactory reloadingFactory\n+                = decorateForFailoverServices(baseFactory, timeLockRemoteConfigurations).withUserAgent(versionedAgent);\n+\n+        return new AtlasDbDialogueServiceProvider(reloadingFactory);\n+    }\n+\n+    ConjureTimelockService getConjureTimelockService() {\n+        Preconditions.checkState(isDialogue(ConjureTimelockServiceBlocking.class),\n+                \"Dialogue service provider attempted to provide a non-Dialogue class.\"\n+                        + \" This is an AtlasDB bug.\");\n+        ConjureTimelockServiceBlocking longTimeoutService\n+                = dialogueClientFactory.get(ConjureTimelockServiceBlocking.class, TIMELOCK_LONG_TIMEOUT);\n+        ConjureTimelockServiceBlocking shortTimeoutService\n+                = dialogueClientFactory.get(ConjureTimelockServiceBlocking.class, TIMELOCK_SHORT_TIMEOUT);\n+\n+        ShortAndLongTimeoutServices<ConjureTimelockService> shortAndLongTimeoutServices\n+                = ImmutableShortAndLongTimeoutServices.<ConjureTimelockServiceBlocking>builder()\n+                .longTimeout(longTimeoutService)\n+                .shortTimeout(shortTimeoutService)\n+                .build()\n+                .map(proxy -> FastFailoverProxy.newProxyInstance(ConjureTimelockServiceBlocking.class, () -> proxy))\n+                .map(DialogueAdaptingConjureTimelockService::new);\n+\n+        return new TimeoutSensitiveConjureTimelockService(shortAndLongTimeoutServices);\n+    }\n+\n+    private static RemoteServiceConfiguration createRemoteServiceConfiguration(\n+            UserAgent userAgent, ServerListConfig serverListConfig, boolean shouldUseExtendedTimeout) {\n+        return ImmutableRemoteServiceConfiguration.builder()\n+                .remotingParameters(getFailoverRemotingParameters(shouldUseExtendedTimeout, userAgent))\n+                .serverList(serverListConfig)\n+                .build();\n+    }\n+\n+    private static AuxiliaryRemotingParameters getFailoverRemotingParameters(\n+            boolean shouldSupportBlockingOperations, UserAgent userAgent) {\n+        return AuxiliaryRemotingParameters.builder()\n+                .shouldLimitPayload(true)\n+                .shouldRetry(true)\n+                .shouldUseExtendedTimeout(shouldSupportBlockingOperations)\n+                .userAgent(userAgent)\n+                .build();\n+    }\n+\n+    private static boolean isDialogue(Class<?> serviceInterface) {\n+        return getStaticOfMethod(serviceInterface).isPresent();\n+    }\n+\n+    private static Optional<Method> getStaticOfMethod(Class<?> dialogueInterface) {\n+        try {\n+            return Optional.ofNullable(dialogueInterface.getMethod(\"of\", Channel.class, ConjureRuntime.class));\n+        } catch (NoSuchMethodException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static DialogueClients.ReloadingFactory decorateForFailoverServices(\n+            DialogueClients.ReloadingFactory baseFactory,\n+            Refreshable<Map<String, RemoteServiceConfiguration>> serviceToRemoteConfiguration) {\n+        return baseFactory.reloading(serviceToRemoteConfiguration.map(\n+                DialogueClientOptions::toServicesConfigBlock))\n+                .withNodeSelectionStrategy(NodeSelectionStrategy.PIN_UNTIL_ERROR_WITHOUT_RESHUFFLE)\n+                .withClientQoS(ClientConfiguration.ClientQoS.DANGEROUS_DISABLE_SYMPATHETIC_CLIENT_QOS);", "originalCommit": "b09d1e85daba1098f8753578fa807c38a0cfe7f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3OTUwNw==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423579507", "bodyText": "This was used in CJR-land as well, so it isn't new - I just ported it over. We should try reinstating the limiters at some point if the Dialogue ones are more aggressive, though I'd like to get the migration through first.", "author": "jeremyk-91", "createdAt": "2020-05-12T09:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMDIwMg=="}], "type": "inlineReview"}, {"oid": "af5cd6ae5902a601a3703554fbfdea0f9acbb96b", "url": "https://github.com/palantir/atlasdb/commit/af5cd6ae5902a601a3703554fbfdea0f9acbb96b", "message": "Add generated changelog entries", "committedDate": "2020-05-12T11:18:25Z", "type": "commit"}, {"oid": "04332f04a13fc1b4b6ebddd3f68c17ac5df26af7", "url": "https://github.com/palantir/atlasdb/commit/04332f04a13fc1b4b6ebddd3f68c17ac5df26af7", "message": "ADDSP impl", "committedDate": "2020-05-12T11:18:28Z", "type": "commit"}, {"oid": "1604d72e86a6b7ad69cddc8eaaa7d2eb759a8a63", "url": "https://github.com/palantir/atlasdb/commit/1604d72e86a6b7ad69cddc8eaaa7d2eb759a8a63", "message": "DACTS not in this PR", "committedDate": "2020-05-12T11:18:45Z", "type": "commit"}, {"oid": "c3d8501e284b8eae588705c4bc52a7802ec65d99", "url": "https://github.com/palantir/atlasdb/commit/c3d8501e284b8eae588705c4bc52a7802ec65d99", "message": "Revert \"don't put ADDSP in this commit\"\n\nThis reverts commit 0b20b83e8fc021971d4f979b8d4d5da4eb403296.", "committedDate": "2020-05-12T11:19:50Z", "type": "commit"}, {"oid": "b3f79733909fc8bfa7d1b49753ece1270fac2128", "url": "https://github.com/palantir/atlasdb/commit/b3f79733909fc8bfa7d1b49753ece1270fac2128", "message": "Revert \"DACTS not in this PR\"\n\nThis reverts commit e746ac95672c2192281777b4b502e880f07005e0.", "committedDate": "2020-05-12T11:19:50Z", "type": "commit"}, {"oid": "3d16e8e828f03d9159d91a875518abe7338d9511", "url": "https://github.com/palantir/atlasdb/commit/3d16e8e828f03d9159d91a875518abe7338d9511", "message": "sp test", "committedDate": "2020-05-12T11:19:50Z", "type": "commit"}, {"oid": "6f2b6b43f6989396b49bdda4c03a29d922ce7df6", "url": "https://github.com/palantir/atlasdb/commit/6f2b6b43f6989396b49bdda4c03a29d922ce7df6", "message": "Fix test", "committedDate": "2020-05-12T11:19:50Z", "type": "commit"}, {"oid": "14f02f5db8bfd3504ece84456088195fa675752d", "url": "https://github.com/palantir/atlasdb/commit/14f02f5db8bfd3504ece84456088195fa675752d", "message": "Dialogue 1.40.1 and combine once-failing tests because they now pass", "committedDate": "2020-05-12T11:19:50Z", "type": "commit"}, {"oid": "3138d21cd4ee7b8e4aeca611850666c82a4d1845", "url": "https://github.com/palantir/atlasdb/commit/3138d21cd4ee7b8e4aeca611850666c82a4d1845", "message": "bleh", "committedDate": "2020-05-12T11:19:50Z", "type": "commit"}, {"oid": "3138d21cd4ee7b8e4aeca611850666c82a4d1845", "url": "https://github.com/palantir/atlasdb/commit/3138d21cd4ee7b8e4aeca611850666c82a4d1845", "message": "bleh", "committedDate": "2020-05-12T11:19:50Z", "type": "forcePushed"}, {"oid": "7433e7d635ddabac8cae7d21fbd4daebf16fe76c", "url": "https://github.com/palantir/atlasdb/commit/7433e7d635ddabac8cae7d21fbd4daebf16fe76c", "message": "borked changelog", "committedDate": "2020-05-12T11:21:10Z", "type": "commit"}, {"oid": "5f1448a7ed45143d32944ca359462b7da66ef8ad", "url": "https://github.com/palantir/atlasdb/commit/5f1448a7ed45143d32944ca359462b7da66ef8ad", "message": "debug", "committedDate": "2020-05-12T12:54:47Z", "type": "commit"}, {"oid": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "url": "https://github.com/palantir/atlasdb/commit/a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "message": "5 seconds instead of 10 to avoid flakes", "committedDate": "2020-05-12T13:02:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3MzA0OA==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423773048", "bodyText": "Lets make this 13+ so that the response makes sense", "author": "gmaretic", "createdAt": "2020-05-12T14:20:41Z", "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProviderTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+import static com.github.tomakehurst.wiremock.client.WireMock.post;\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.atlasdb.config.ImmutableServerListConfig;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsResponse;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.api.config.service.ServicesConfigBlock;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.refreshable.Refreshable;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class AtlasDbDialogueServiceProviderTest {\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private static final String CLIENT = \"tom\";\n+    private static final String TIMESTAMP_PATH = \"/tl/ts/\" + CLIENT;\n+    private static final MappingBuilder TIMESTAMP_MAPPING = post(urlEqualTo(TIMESTAMP_PATH));\n+    private static final DialogueClients.ReloadingFactory DIALOGUE_BASE_FACTORY\n+            = DialogueClients.create(Refreshable.only(ServicesConfigBlock.builder().build()));\n+    private static final UserAgent USER_USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"jeremy\", \"77.79.12\"));\n+\n+    private int serverPort;\n+    private ConjureTimelockService conjureTimelockService;\n+\n+    @Rule\n+    public WireMockRule server = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        setupServerToGiveOutTimestamps();\n+\n+        serverPort = server.port();\n+        ServerListConfig serverListConfig = ImmutableServerListConfig.builder()\n+                .addServers(getUriForPort(serverPort))\n+                .sslConfiguration(SSL_CONFIGURATION)\n+                .build();\n+\n+        AtlasDbDialogueServiceProvider provider = AtlasDbDialogueServiceProvider.create(\n+                Refreshable.only(serverListConfig),\n+                DIALOGUE_BASE_FACTORY,\n+                USER_USER_AGENT);\n+        conjureTimelockService = provider.getConjureTimelockService();\n+    }\n+\n+\n+    @Test\n+    public void canMakeRequestsThroughDialogue() {\n+        ConjureGetFreshTimestampsResponse response = makeTimestampsRequest();\n+        assertThat(response.getInclusiveLower()).isEqualTo(58);\n+        assertThat(response.getInclusiveUpper()).isEqualTo(70);\n+    }\n+\n+    @Test\n+    public void requestsAreIdentifiedWithTheUserProvidedUserAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().name())));\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().version())));\n+    }\n+\n+    @Test\n+    public void atlasDbHttpClientVersionProvidedAsAnInformationalAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(\n+                        String.format(\"%s/%s\",\n+                                AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT,\n+                                AtlasDbRemotingConstants.CURRENT_CLIENT_PROTOCOL_VERSION.getProtocolVersionString()))));\n+    }\n+\n+    @Test\n+    public void resilientToRepeatedRedirects() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(308)\n+                .withHeader(\"Location\", getUriForPort(serverPort))));\n+\n+        Instant start = Instant.now();\n+        ExecutorService ex = PTExecutors.newSingleThreadExecutor(true);\n+        ex.submit(this::scheduleServerRecoveryAfterFiveSeconds);\n+\n+        assertThatCode(this::makeTimestampsRequest).doesNotThrowAnyException();\n+        assertThat(Instant.now())\n+                .as(\"should recover in a second after things are good again\")\n+                .isBefore(start.plus(Duration.ofSeconds(11)));\n+        ex.shutdown();\n+    }\n+\n+    private void scheduleServerRecoveryAfterFiveSeconds() {\n+        Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);\n+        setupServerToGiveOutTimestamps();\n+    }\n+\n+    private void setupServerToGiveOutTimestamps() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(200)\n+                .withHeader(\"Content-Type\", \"application/json\")\n+                .withBody(\"{\\\"inclusiveLower\\\": 58, \\\"inclusiveUpper\\\": 70}\")));\n+    }\n+\n+    private ConjureGetFreshTimestampsResponse makeTimestampsRequest() {\n+        return conjureTimelockService.getFreshTimestamps(\n+                AuthHeader.valueOf(\"Bearer unused\"), CLIENT, ConjureGetFreshTimestampsRequest.of(10));", "originalCommit": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzMzM0Nw==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423833347", "bodyText": "Yep, makes sense. (Good call on 13+, and not precisely 13, as well!)", "author": "jeremyk-91", "createdAt": "2020-05-12T15:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3MzA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3Nzk0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423777941", "bodyText": "Magic header strings are not the best, also for user agents", "author": "gmaretic", "createdAt": "2020-05-12T14:26:28Z", "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProviderTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+import static com.github.tomakehurst.wiremock.client.WireMock.post;\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.atlasdb.config.ImmutableServerListConfig;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsResponse;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.api.config.service.ServicesConfigBlock;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.refreshable.Refreshable;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class AtlasDbDialogueServiceProviderTest {\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private static final String CLIENT = \"tom\";\n+    private static final String TIMESTAMP_PATH = \"/tl/ts/\" + CLIENT;\n+    private static final MappingBuilder TIMESTAMP_MAPPING = post(urlEqualTo(TIMESTAMP_PATH));\n+    private static final DialogueClients.ReloadingFactory DIALOGUE_BASE_FACTORY\n+            = DialogueClients.create(Refreshable.only(ServicesConfigBlock.builder().build()));\n+    private static final UserAgent USER_USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"jeremy\", \"77.79.12\"));\n+\n+    private int serverPort;\n+    private ConjureTimelockService conjureTimelockService;\n+\n+    @Rule\n+    public WireMockRule server = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        setupServerToGiveOutTimestamps();\n+\n+        serverPort = server.port();\n+        ServerListConfig serverListConfig = ImmutableServerListConfig.builder()\n+                .addServers(getUriForPort(serverPort))\n+                .sslConfiguration(SSL_CONFIGURATION)\n+                .build();\n+\n+        AtlasDbDialogueServiceProvider provider = AtlasDbDialogueServiceProvider.create(\n+                Refreshable.only(serverListConfig),\n+                DIALOGUE_BASE_FACTORY,\n+                USER_USER_AGENT);\n+        conjureTimelockService = provider.getConjureTimelockService();\n+    }\n+\n+\n+    @Test\n+    public void canMakeRequestsThroughDialogue() {\n+        ConjureGetFreshTimestampsResponse response = makeTimestampsRequest();\n+        assertThat(response.getInclusiveLower()).isEqualTo(58);\n+        assertThat(response.getInclusiveUpper()).isEqualTo(70);\n+    }\n+\n+    @Test\n+    public void requestsAreIdentifiedWithTheUserProvidedUserAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().name())));\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().version())));\n+    }\n+\n+    @Test\n+    public void atlasDbHttpClientVersionProvidedAsAnInformationalAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(\n+                        String.format(\"%s/%s\",\n+                                AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT,\n+                                AtlasDbRemotingConstants.CURRENT_CLIENT_PROTOCOL_VERSION.getProtocolVersionString()))));\n+    }\n+\n+    @Test\n+    public void resilientToRepeatedRedirects() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(308)\n+                .withHeader(\"Location\", getUriForPort(serverPort))));", "originalCommit": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNzMxMw==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423837313", "bodyText": "Yep, updated to use HttpHeaders.", "author": "jeremyk-91", "createdAt": "2020-05-12T15:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3Nzk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3OTI2Mg==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423779262", "bodyText": "Add a test for respecting long timeout on locks", "author": "gmaretic", "createdAt": "2020-05-12T14:28:14Z", "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProviderTest.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+import static com.github.tomakehurst.wiremock.client.WireMock.post;\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;\n+\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import com.github.tomakehurst.wiremock.client.MappingBuilder;\n+import com.github.tomakehurst.wiremock.client.WireMock;\n+import com.github.tomakehurst.wiremock.core.WireMockConfiguration;\n+import com.github.tomakehurst.wiremock.junit.WireMockRule;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.atlasdb.config.ImmutableServerListConfig;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureGetFreshTimestampsResponse;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.api.config.service.ServicesConfigBlock;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.api.config.ssl.SslConfiguration;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.refreshable.Refreshable;\n+import com.palantir.tokens.auth.AuthHeader;\n+\n+public class AtlasDbDialogueServiceProviderTest {\n+    private static final SslConfiguration SSL_CONFIGURATION\n+            = SslConfiguration.of(Paths.get(\"var/security/trustStore.jks\"));\n+\n+    private static final String CLIENT = \"tom\";\n+    private static final String TIMESTAMP_PATH = \"/tl/ts/\" + CLIENT;\n+    private static final MappingBuilder TIMESTAMP_MAPPING = post(urlEqualTo(TIMESTAMP_PATH));\n+    private static final DialogueClients.ReloadingFactory DIALOGUE_BASE_FACTORY\n+            = DialogueClients.create(Refreshable.only(ServicesConfigBlock.builder().build()));\n+    private static final UserAgent USER_USER_AGENT = UserAgent.of(UserAgent.Agent.of(\"jeremy\", \"77.79.12\"));\n+\n+    private int serverPort;\n+    private ConjureTimelockService conjureTimelockService;\n+\n+    @Rule\n+    public WireMockRule server = new WireMockRule(WireMockConfiguration.wireMockConfig().dynamicPort());\n+\n+    @Before\n+    public void setup() {\n+        setupServerToGiveOutTimestamps();\n+\n+        serverPort = server.port();\n+        ServerListConfig serverListConfig = ImmutableServerListConfig.builder()\n+                .addServers(getUriForPort(serverPort))\n+                .sslConfiguration(SSL_CONFIGURATION)\n+                .build();\n+\n+        AtlasDbDialogueServiceProvider provider = AtlasDbDialogueServiceProvider.create(\n+                Refreshable.only(serverListConfig),\n+                DIALOGUE_BASE_FACTORY,\n+                USER_USER_AGENT);\n+        conjureTimelockService = provider.getConjureTimelockService();\n+    }\n+\n+\n+    @Test\n+    public void canMakeRequestsThroughDialogue() {\n+        ConjureGetFreshTimestampsResponse response = makeTimestampsRequest();\n+        assertThat(response.getInclusiveLower()).isEqualTo(58);\n+        assertThat(response.getInclusiveUpper()).isEqualTo(70);\n+    }\n+\n+    @Test\n+    public void requestsAreIdentifiedWithTheUserProvidedUserAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().name())));\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(USER_USER_AGENT.primary().version())));\n+    }\n+\n+    @Test\n+    public void atlasDbHttpClientVersionProvidedAsAnInformationalAgent() {\n+        makeTimestampsRequest();\n+\n+        server.verify(postRequestedFor(urlMatching(TIMESTAMP_PATH))\n+                .withHeader(\"User-Agent\", WireMock.containing(\n+                        String.format(\"%s/%s\",\n+                                AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT,\n+                                AtlasDbRemotingConstants.CURRENT_CLIENT_PROTOCOL_VERSION.getProtocolVersionString()))));\n+    }\n+\n+    @Test\n+    public void resilientToRepeatedRedirects() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(308)\n+                .withHeader(\"Location\", getUriForPort(serverPort))));\n+\n+        Instant start = Instant.now();\n+        ExecutorService ex = PTExecutors.newSingleThreadExecutor(true);\n+        ex.submit(this::scheduleServerRecoveryAfterFiveSeconds);\n+\n+        assertThatCode(this::makeTimestampsRequest).doesNotThrowAnyException();\n+        assertThat(Instant.now())\n+                .as(\"should recover in a second after things are good again\")\n+                .isBefore(start.plus(Duration.ofSeconds(11)));\n+        ex.shutdown();\n+    }\n+\n+    private void scheduleServerRecoveryAfterFiveSeconds() {\n+        Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);\n+        setupServerToGiveOutTimestamps();\n+    }\n+\n+    private void setupServerToGiveOutTimestamps() {\n+        server.stubFor(TIMESTAMP_MAPPING.willReturn(aResponse()\n+                .withStatus(200)\n+                .withHeader(\"Content-Type\", \"application/json\")\n+                .withBody(\"{\\\"inclusiveLower\\\": 58, \\\"inclusiveUpper\\\": 70}\")));\n+    }\n+\n+    private ConjureGetFreshTimestampsResponse makeTimestampsRequest() {\n+        return conjureTimelockService.getFreshTimestamps(\n+                AuthHeader.valueOf(\"Bearer unused\"), CLIENT, ConjureGetFreshTimestampsRequest.of(10));\n+    }\n+\n+    private static String getUriForPort(int port) {\n+        return String.format(\"http://%s:%s\", WireMockConfiguration.DEFAULT_BIND_ADDRESS, port);\n+    }\n+}", "originalCommit": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2ODU2Ng==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423868566", "bodyText": "Makes sense, added one.", "author": "jeremyk-91", "createdAt": "2020-05-12T16:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3OTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3OTg0Mg==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423779842", "bodyText": "Nice \ud83d\udd2a", "author": "gmaretic", "createdAt": "2020-05-12T14:28:56Z", "path": "atlasdb-conjure/src/main/java/com/palantir/atlasdb/http/v2/FastFailoverProxy.java", "diffHunk": "@@ -98,19 +100,23 @@ private ResultOrThrowable isRetriable(Throwable throwable) {\n         }\n         InvocationTargetException exception = (InvocationTargetException) throwable;\n         Throwable cause = exception.getCause();\n-        if (!(cause instanceof RetryableException) || !isCausedByRetryOther((RetryableException) cause)) {\n+        if (!isCausedByRetryOther(cause)) {\n+            log.info(\"not caused by retry other!\", throwable);", "originalCommit": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2OTE0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423869141", "bodyText": "\ud83c\udf63\nRemoved!", "author": "jeremyk-91", "createdAt": "2020-05-12T16:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc3OTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc4MDc1Nw==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423780757", "bodyText": "This makes me sad but not actionable", "author": "gmaretic", "createdAt": "2020-05-12T14:30:05Z", "path": "atlasdb-conjure/src/main/java/com/palantir/atlasdb/http/v2/FastFailoverProxy.java", "diffHunk": "@@ -98,19 +100,23 @@ private ResultOrThrowable isRetriable(Throwable throwable) {\n         }\n         InvocationTargetException exception = (InvocationTargetException) throwable;\n         Throwable cause = exception.getCause();\n-        if (!(cause instanceof RetryableException) || !isCausedByRetryOther((RetryableException) cause)) {\n+        if (!isCausedByRetryOther(cause)) {\n+            log.info(\"not caused by retry other!\", throwable);\n             return ResultOrThrowable.failure(cause);\n         }\n         return ResultOrThrowable.success(null);\n     }\n \n     @VisibleForTesting\n-    static boolean isCausedByRetryOther(RetryableException ex) {\n-        Throwable cause = ex;\n+    static boolean isCausedByRetryOther(Throwable throwable) {\n+        Throwable cause = throwable;\n         while (cause != null) {\n             if (cause instanceof QosException.RetryOther) {\n                 return true;\n             }\n+            if (cause instanceof UnknownRemoteException && ((UnknownRemoteException) cause).getStatus() == 308) {", "originalCommit": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc4NDEwNw==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423784107", "bodyText": "let's be consistent in naming :D", "author": "gmaretic", "createdAt": "2020-05-12T14:34:21Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProvider.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.AuxiliaryRemotingParameters;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.factory.timelock.ImmutableShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.ShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.TimeoutSensitiveConjureTimelockService;\n+import com.palantir.atlasdb.http.AtlasDbHttpProtocolVersion;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.http.v2.DialogueClientOptions;\n+import com.palantir.atlasdb.http.v2.FastFailoverProxy;\n+import com.palantir.atlasdb.http.v2.ImmutableRemoteServiceConfiguration;\n+import com.palantir.atlasdb.http.v2.RemoteServiceConfiguration;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockServiceBlocking;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.client.config.ClientConfiguration;\n+import com.palantir.conjure.java.client.config.NodeSelectionStrategy;\n+import com.palantir.dialogue.Channel;\n+import com.palantir.dialogue.ConjureRuntime;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.lock.client.DialogueAdaptingConjureTimelockService;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.refreshable.Refreshable;\n+\n+/**\n+ * Provides a mechanism for accessing services that use Dialogue for communication. A service is defined as a cluster of\n+ * zero or more nodes, where contacting any of the nodes is legitimate (subject to redirects via 308s and 503s). If\n+ * working with heterogeneous nodes and/or broadcast is important (e.g. for Paxos Acceptor use cases), you should be\n+ * VERY careful when using this class.\n+ *\n+ * Proxies must be resilient to servers repeatedly returning 308s that are large in number, but persist for only a short\n+ * duration. Furthermore, proxies should include in their {@link com.palantir.conjure.java.api.config.service.UserAgent}\n+ * information to allow client services to identify the protocol they are using to talk, via\n+ * {@link AtlasDbHttpProtocolVersion}.\n+ */\n+public final class AtlasDbDialogueServiceProvider {\n+    private static final String TIMELOCK_SHORT_TIMEOUT = \"timelock-short-timeout\";\n+    private static final String TIMELOCK_LONG_TIMEOUT = \"timelock-long-timeout\";\n+    private final DialogueClients.ReloadingFactory dialogueClientFactory;\n+\n+    private AtlasDbDialogueServiceProvider(DialogueClients.ReloadingFactory dialogueClientFactory) {\n+        this.dialogueClientFactory = dialogueClientFactory;\n+    }\n+\n+    public static AtlasDbDialogueServiceProvider create(\n+            Refreshable<ServerListConfig> timeLockServerListConfig,\n+            DialogueClients.ReloadingFactory baseFactory,\n+            UserAgent userAgent) {\n+        UserAgent versionedAgent = userAgent.addAgent(AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT_AGENT);\n+        Refreshable<Map<String, RemoteServiceConfiguration>> timeLockRemoteConfigurations = timeLockServerListConfig\n+                .map(serverListConfig -> ImmutableMap.of(\n+                        TIMELOCK_SHORT_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, false),\n+                        TIMELOCK_LONG_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, true)));\n+        DialogueClients.ReloadingFactory reloadingFactory\n+                = decorateForFailoverServices(baseFactory, timeLockRemoteConfigurations).withUserAgent(versionedAgent);\n+\n+        return new AtlasDbDialogueServiceProvider(reloadingFactory);\n+    }\n+\n+    ConjureTimelockService getConjureTimelockService() {\n+        Preconditions.checkState(isDialogue(ConjureTimelockServiceBlocking.class),\n+                \"Dialogue service provider attempted to provide a non-Dialogue class.\"\n+                        + \" This is an AtlasDB bug.\");\n+        ConjureTimelockServiceBlocking longTimeoutService\n+                = dialogueClientFactory.get(ConjureTimelockServiceBlocking.class, TIMELOCK_LONG_TIMEOUT);\n+        ConjureTimelockServiceBlocking shortTimeoutService\n+                = dialogueClientFactory.get(ConjureTimelockServiceBlocking.class, TIMELOCK_SHORT_TIMEOUT);\n+\n+        ShortAndLongTimeoutServices<ConjureTimelockService> shortAndLongTimeoutServices\n+                = ImmutableShortAndLongTimeoutServices.<ConjureTimelockServiceBlocking>builder()\n+                .longTimeout(longTimeoutService)\n+                .shortTimeout(shortTimeoutService)\n+                .build()\n+                .map(proxy -> FastFailoverProxy.newProxyInstance(ConjureTimelockServiceBlocking.class, () -> proxy))\n+                .map(DialogueAdaptingConjureTimelockService::new);\n+\n+        return new TimeoutSensitiveConjureTimelockService(shortAndLongTimeoutServices);\n+    }\n+\n+    private static RemoteServiceConfiguration createRemoteServiceConfiguration(\n+            UserAgent userAgent, ServerListConfig serverListConfig, boolean shouldUseExtendedTimeout) {\n+        return ImmutableRemoteServiceConfiguration.builder()\n+                .remotingParameters(getFailoverRemotingParameters(shouldUseExtendedTimeout, userAgent))\n+                .serverList(serverListConfig)\n+                .build();\n+    }\n+\n+    private static AuxiliaryRemotingParameters getFailoverRemotingParameters(\n+            boolean shouldSupportBlockingOperations, UserAgent userAgent) {", "originalCommit": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc4NzU1NQ==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423787555", "bodyText": "Let's kill this check because it's really hacky and currently not needed (and let's keep it that way)", "author": "gmaretic", "createdAt": "2020-05-12T14:38:53Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProvider.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.AuxiliaryRemotingParameters;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.factory.timelock.ImmutableShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.ShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.TimeoutSensitiveConjureTimelockService;\n+import com.palantir.atlasdb.http.AtlasDbHttpProtocolVersion;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.http.v2.DialogueClientOptions;\n+import com.palantir.atlasdb.http.v2.FastFailoverProxy;\n+import com.palantir.atlasdb.http.v2.ImmutableRemoteServiceConfiguration;\n+import com.palantir.atlasdb.http.v2.RemoteServiceConfiguration;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockServiceBlocking;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.client.config.ClientConfiguration;\n+import com.palantir.conjure.java.client.config.NodeSelectionStrategy;\n+import com.palantir.dialogue.Channel;\n+import com.palantir.dialogue.ConjureRuntime;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.lock.client.DialogueAdaptingConjureTimelockService;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.refreshable.Refreshable;\n+\n+/**\n+ * Provides a mechanism for accessing services that use Dialogue for communication. A service is defined as a cluster of\n+ * zero or more nodes, where contacting any of the nodes is legitimate (subject to redirects via 308s and 503s). If\n+ * working with heterogeneous nodes and/or broadcast is important (e.g. for Paxos Acceptor use cases), you should be\n+ * VERY careful when using this class.\n+ *\n+ * Proxies must be resilient to servers repeatedly returning 308s that are large in number, but persist for only a short\n+ * duration. Furthermore, proxies should include in their {@link com.palantir.conjure.java.api.config.service.UserAgent}\n+ * information to allow client services to identify the protocol they are using to talk, via\n+ * {@link AtlasDbHttpProtocolVersion}.\n+ */\n+public final class AtlasDbDialogueServiceProvider {\n+    private static final String TIMELOCK_SHORT_TIMEOUT = \"timelock-short-timeout\";\n+    private static final String TIMELOCK_LONG_TIMEOUT = \"timelock-long-timeout\";\n+    private final DialogueClients.ReloadingFactory dialogueClientFactory;\n+\n+    private AtlasDbDialogueServiceProvider(DialogueClients.ReloadingFactory dialogueClientFactory) {\n+        this.dialogueClientFactory = dialogueClientFactory;\n+    }\n+\n+    public static AtlasDbDialogueServiceProvider create(\n+            Refreshable<ServerListConfig> timeLockServerListConfig,\n+            DialogueClients.ReloadingFactory baseFactory,\n+            UserAgent userAgent) {\n+        UserAgent versionedAgent = userAgent.addAgent(AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT_AGENT);\n+        Refreshable<Map<String, RemoteServiceConfiguration>> timeLockRemoteConfigurations = timeLockServerListConfig\n+                .map(serverListConfig -> ImmutableMap.of(\n+                        TIMELOCK_SHORT_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, false),\n+                        TIMELOCK_LONG_TIMEOUT,\n+                        createRemoteServiceConfiguration(versionedAgent, serverListConfig, true)));\n+        DialogueClients.ReloadingFactory reloadingFactory\n+                = decorateForFailoverServices(baseFactory, timeLockRemoteConfigurations).withUserAgent(versionedAgent);\n+\n+        return new AtlasDbDialogueServiceProvider(reloadingFactory);\n+    }\n+\n+    ConjureTimelockService getConjureTimelockService() {\n+        Preconditions.checkState(isDialogue(ConjureTimelockServiceBlocking.class),", "originalCommit": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3MDMxOQ==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423870319", "bodyText": "Yep, this was needed for the other design / in general designs that allow users to pass in Class<T> but if we're controlling it it should be fine.", "author": "jeremyk-91", "createdAt": "2020-05-12T16:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc4NzU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5MTc2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423791763", "bodyText": "Extract a constant function or a method so it's a bit more visible how this works", "author": "gmaretic", "createdAt": "2020-05-12T14:44:20Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/AtlasDbDialogueServiceProvider.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.factory;\n+\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.palantir.atlasdb.config.AuxiliaryRemotingParameters;\n+import com.palantir.atlasdb.config.ServerListConfig;\n+import com.palantir.atlasdb.factory.timelock.ImmutableShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.ShortAndLongTimeoutServices;\n+import com.palantir.atlasdb.factory.timelock.TimeoutSensitiveConjureTimelockService;\n+import com.palantir.atlasdb.http.AtlasDbHttpProtocolVersion;\n+import com.palantir.atlasdb.http.AtlasDbRemotingConstants;\n+import com.palantir.atlasdb.http.v2.DialogueClientOptions;\n+import com.palantir.atlasdb.http.v2.FastFailoverProxy;\n+import com.palantir.atlasdb.http.v2.ImmutableRemoteServiceConfiguration;\n+import com.palantir.atlasdb.http.v2.RemoteServiceConfiguration;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockService;\n+import com.palantir.atlasdb.timelock.api.ConjureTimelockServiceBlocking;\n+import com.palantir.conjure.java.api.config.service.UserAgent;\n+import com.palantir.conjure.java.client.config.ClientConfiguration;\n+import com.palantir.conjure.java.client.config.NodeSelectionStrategy;\n+import com.palantir.dialogue.Channel;\n+import com.palantir.dialogue.ConjureRuntime;\n+import com.palantir.dialogue.clients.DialogueClients;\n+import com.palantir.lock.client.DialogueAdaptingConjureTimelockService;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.refreshable.Refreshable;\n+\n+/**\n+ * Provides a mechanism for accessing services that use Dialogue for communication. A service is defined as a cluster of\n+ * zero or more nodes, where contacting any of the nodes is legitimate (subject to redirects via 308s and 503s). If\n+ * working with heterogeneous nodes and/or broadcast is important (e.g. for Paxos Acceptor use cases), you should be\n+ * VERY careful when using this class.\n+ *\n+ * Proxies must be resilient to servers repeatedly returning 308s that are large in number, but persist for only a short\n+ * duration. Furthermore, proxies should include in their {@link com.palantir.conjure.java.api.config.service.UserAgent}\n+ * information to allow client services to identify the protocol they are using to talk, via\n+ * {@link AtlasDbHttpProtocolVersion}.\n+ */\n+public final class AtlasDbDialogueServiceProvider {\n+    private static final String TIMELOCK_SHORT_TIMEOUT = \"timelock-short-timeout\";\n+    private static final String TIMELOCK_LONG_TIMEOUT = \"timelock-long-timeout\";\n+    private final DialogueClients.ReloadingFactory dialogueClientFactory;\n+\n+    private AtlasDbDialogueServiceProvider(DialogueClients.ReloadingFactory dialogueClientFactory) {\n+        this.dialogueClientFactory = dialogueClientFactory;\n+    }\n+\n+    public static AtlasDbDialogueServiceProvider create(\n+            Refreshable<ServerListConfig> timeLockServerListConfig,\n+            DialogueClients.ReloadingFactory baseFactory,\n+            UserAgent userAgent) {\n+        UserAgent versionedAgent = userAgent.addAgent(AtlasDbRemotingConstants.ATLASDB_HTTP_CLIENT_AGENT);\n+        Refreshable<Map<String, RemoteServiceConfiguration>> timeLockRemoteConfigurations = timeLockServerListConfig\n+                .map(serverListConfig -> ImmutableMap.of(", "originalCommit": "a0dfc8dc68fa3cee7b66cfdfa1bb2af27f428fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3MDkxMw==", "url": "https://github.com/palantir/atlasdb/pull/4763#discussion_r423870913", "bodyText": "Yep, extracted out getServiceConfigurations() that does this", "author": "jeremyk-91", "createdAt": "2020-05-12T16:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc5MTc2Mw=="}], "type": "inlineReview"}, {"oid": "31894f7f715115a8dd1421ac9305416956e5c6a5", "url": "https://github.com/palantir/atlasdb/commit/31894f7f715115a8dd1421ac9305416956e5c6a5", "message": "oops", "committedDate": "2020-05-12T14:46:31Z", "type": "commit"}, {"oid": "2142613da2b5b1aac113a3451360392aa6d90bd4", "url": "https://github.com/palantir/atlasdb/commit/2142613da2b5b1aac113a3451360392aa6d90bd4", "message": "CR feedback", "committedDate": "2020-05-12T16:30:38Z", "type": "commit"}, {"oid": "f45f1aa5e2f12f14e41ee4422979349a0b81c51f", "url": "https://github.com/palantir/atlasdb/commit/f45f1aa5e2f12f14e41ee4422979349a0b81c51f", "message": "test", "committedDate": "2020-05-12T16:49:05Z", "type": "commit"}]}