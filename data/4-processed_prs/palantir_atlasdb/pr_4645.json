{"pr_number": 4645, "pr_title": "[PDS-113120] Block Enforcing (Client-Side) Lock Service", "pr_createdAt": "2020-03-11T12:30:52Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4645", "timeline": [{"oid": "f73796daf3d70de6f568893a2260b363074e0ce2", "url": "https://github.com/palantir/atlasdb/commit/f73796daf3d70de6f568893a2260b363074e0ce2", "message": "Failing test", "committedDate": "2020-03-10T20:26:19Z", "type": "commit"}, {"oid": "6fe325bfc485617097e6c57ad9dad7c9a9bcabf4", "url": "https://github.com/palantir/atlasdb/commit/6fe325bfc485617097e6c57ad9dad7c9a9bcabf4", "message": "ASLS", "committedDate": "2020-03-10T21:28:17Z", "type": "commit"}, {"oid": "433aa13bc52bf14572b213930c4c33a0331bc5fe", "url": "https://github.com/palantir/atlasdb/commit/433aa13bc52bf14572b213930c4c33a0331bc5fe", "message": "simplify multinode test", "committedDate": "2020-03-10T21:28:23Z", "type": "commit"}, {"oid": "480e6ae566de5933e26f04a54367a558a5aea628", "url": "https://github.com/palantir/atlasdb/commit/480e6ae566de5933e26f04a54367a558a5aea628", "message": "Wait for locks", "committedDate": "2020-03-10T22:08:47Z", "type": "commit"}, {"oid": "689082f5788493cb9c4549965939f9420c906d22", "url": "https://github.com/palantir/atlasdb/commit/689082f5788493cb9c4549965939f9420c906d22", "message": "Patch", "committedDate": "2020-03-11T11:16:45Z", "type": "commit"}, {"oid": "712d2673ab4e2da0193ca23bed1c6d2a2aabad82", "url": "https://github.com/palantir/atlasdb/commit/712d2673ab4e2da0193ca23bed1c6d2a2aabad82", "message": "Refactor", "committedDate": "2020-03-11T12:19:03Z", "type": "commit"}, {"oid": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "url": "https://github.com/palantir/atlasdb/commit/616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "message": "Test", "committedDate": "2020-03-11T12:19:10Z", "type": "commit"}, {"oid": "9b10d7d671fdca3d522c4ceee0f2333ff16a09e4", "url": "https://github.com/palantir/atlasdb/commit/9b10d7d671fdca3d522c4ceee0f2333ff16a09e4", "message": "Add generated changelog entries", "committedDate": "2020-03-11T12:19:10Z", "type": "commit"}, {"oid": "1082550b641dcbf62db9c80b14480c879e4fac42", "url": "https://github.com/palantir/atlasdb/commit/1082550b641dcbf62db9c80b14480c879e4fac42", "message": "Cleanup", "committedDate": "2020-03-11T13:15:19Z", "type": "commit"}, {"oid": "51200b2a3194a1e260ba12e2e7a53bb2387182c7", "url": "https://github.com/palantir/atlasdb/commit/51200b2a3194a1e260ba12e2e7a53bb2387182c7", "message": "Merge branch 'jkong/compensating-lock-requests' of github.com:palantir/atlasdb into jkong/compensating-lock-requests", "committedDate": "2020-03-11T13:17:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzOTg4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390939887", "bodyText": "retrying unsuccessful responses?? is it possible to make this less general?", "author": "felixdesouza", "createdAt": "2020-03-11T12:36:55Z", "path": "lock-api/src/main/java/com/palantir/lock/client/RemoteTimeoutRetryer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+class RemoteTimeoutRetryer {\n+    private final Clock clock;\n+\n+    @VisibleForTesting\n+    RemoteTimeoutRetryer(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    static RemoteTimeoutRetryer createDefault() {\n+        return new RemoteTimeoutRetryer(Clock.systemUTC());\n+    }\n+\n+    <S, T> T attemptUntilTimeLimitOrException(\n+            S request,\n+            Function<S, Duration> durationExtractor,\n+            BiFunction<S, Duration, S> durationLimiter,\n+            Function<S, T> query,\n+            Predicate<T> successfulResponseEvaluator,\n+            T defaultResponse) {\n+        Instant now = clock.instant();\n+        Instant deadline = now.plus(durationExtractor.apply(request));\n+\n+        while (now.isBefore(deadline)) {\n+            Duration remainingTime = Duration.between(now, deadline);\n+            S durationLimitedInput = durationLimiter.apply(request, remainingTime);\n+\n+            try {\n+                T response = query.apply(durationLimitedInput);\n+                if (successfulResponseEvaluator.test(response)) {", "originalCommit": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzExMA==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390947110", "bodyText": "so I've reread, and I think I understand, it's only because you've clamped the deadline, and that an unsuccessful response is still actually potentially successful/not a failure.\nThis class isn't and shouldn't be general imo, short of locks I'm struggling to see where else it applies.", "author": "felixdesouza", "createdAt": "2020-03-11T12:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzOTg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1NzA0OA==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391157048", "bodyText": "I've moved this into an inner class: as discussed offline the predicate should really be definitiveResponse or something along those lines if we wanted it to be fully precise.", "author": "jeremyk-91", "createdAt": "2020-03-11T17:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDkzOTg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MDYxMw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390940613", "bodyText": "nit: move the comment to this part here", "author": "felixdesouza", "createdAt": "2020-03-11T12:38:20Z", "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -193,4 +197,29 @@ public void canCreateNewClientsDynamically() {\n         }\n     }\n \n+    @Test\n+    public void lockRequestCanBlockForTheFullTimeout() {\n+        // Test proxy timeout is 12.5 seconds, so 15 seconds suffices.\n+        LockToken token = client.lock(LockRequest.of(LOCKS, DEFAULT_LOCK_TIMEOUT_MS)).getToken();\n+\n+        try {\n+            LockResponse response = client.lock(LockRequest.of(LOCKS, 15_000));", "originalCommit": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MDY2Ng==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390940666", "bodyText": "same as below", "author": "felixdesouza", "createdAt": "2020-03-11T12:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MDYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MjUxNw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390942517", "bodyText": "just pass in req.getAcquireTimeoutMs()?", "author": "felixdesouza", "createdAt": "2020-03-11T12:42:02Z", "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+\n+import com.palantir.atlasdb.timelock.api.ConjureLockResponse;\n+import com.palantir.atlasdb.timelock.api.SuccessfulLockResponse;\n+import com.palantir.atlasdb.timelock.api.UnsuccessfulLockResponse;\n+import com.palantir.lock.v2.ImmutableLockRequest;\n+import com.palantir.lock.v2.ImmutableWaitForLocksRequest;\n+import com.palantir.lock.v2.LockRequest;\n+import com.palantir.lock.v2.LockResponse;\n+import com.palantir.lock.v2.WaitForLocksRequest;\n+import com.palantir.lock.v2.WaitForLocksResponse;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+\n+/**\n+ * Ensures that clients actually attempt to acquire the lock for the full duration they claim they will block for,\n+ * unless they run into an exception that is unlikely to actually be a timeout. This is done to account for the reality\n+ * of bounded timeouts beneath us (e.g. in terms of the networking layer) when communicating with remote services.\n+ *\n+ * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n+ */\n+class BlockEnforcingLockService {\n+    private final NamespacedConjureTimelockService namespacedConjureTimelockService;\n+    private final RemoteTimeoutRetryer timeoutRetryer;\n+\n+    private BlockEnforcingLockService(NamespacedConjureTimelockService namespacedConjureTimelockService,\n+            RemoteTimeoutRetryer timeoutRetryer) {\n+        this.namespacedConjureTimelockService = namespacedConjureTimelockService;\n+        this.timeoutRetryer = timeoutRetryer;\n+    }\n+\n+    static BlockEnforcingLockService create(NamespacedConjureTimelockService namespacedConjureTimelockService) {\n+        return new BlockEnforcingLockService(namespacedConjureTimelockService, RemoteTimeoutRetryer.createDefault());\n+    }\n+\n+    LockResponse lock(LockRequest request) {\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                request,\n+                req -> Duration.ofMillis(req.getAcquireTimeoutMs()),", "originalCommit": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1Nzg4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391157887", "bodyText": "I think I still want to keep the Duration as an input, just because we have a BiFunction<S, Duration, S> and I'm not really keen on having both duration and a millis-thing in the same API. I've changed this to not pass in an extractor though.", "author": "jeremyk-91", "createdAt": "2020-03-11T17:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MjUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU0NjE2Nw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391546167", "bodyText": "yeah, I assumed that anyway, strongly typed params \ud83d\udcaa", "author": "felixdesouza", "createdAt": "2020-03-12T11:03:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0MjUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzgyOQ==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390947829", "bodyText": "if keeping this general, shouldn't this technically be applied on the previous durationLimitedInput instead of on the original request?", "author": "felixdesouza", "createdAt": "2020-03-11T12:52:01Z", "path": "lock-api/src/main/java/com/palantir/lock/client/RemoteTimeoutRetryer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+class RemoteTimeoutRetryer {\n+    private final Clock clock;\n+\n+    @VisibleForTesting\n+    RemoteTimeoutRetryer(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    static RemoteTimeoutRetryer createDefault() {\n+        return new RemoteTimeoutRetryer(Clock.systemUTC());\n+    }\n+\n+    <S, T> T attemptUntilTimeLimitOrException(\n+            S request,\n+            Function<S, Duration> durationExtractor,\n+            BiFunction<S, Duration, S> durationLimiter,\n+            Function<S, T> query,\n+            Predicate<T> successfulResponseEvaluator,\n+            T defaultResponse) {\n+        Instant now = clock.instant();\n+        Instant deadline = now.plus(durationExtractor.apply(request));\n+\n+        while (now.isBefore(deadline)) {\n+            Duration remainingTime = Duration.between(now, deadline);\n+            S durationLimitedInput = durationLimiter.apply(request, remainingTime);", "originalCommit": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1ODExMw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391158113", "bodyText": "Changed to iteratively supply inputs (though no longer keeping it general).", "author": "jeremyk-91", "createdAt": "2020-03-11T17:54:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0NzgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0OTQzOA==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390949438", "bodyText": "default is misleading here, if anything it should be timedOutResponse or something that communicates that we failed in the way we expected etc. Either that or we save the response if the successfulResultEvaluator fails and then return that.\nEither way, making this about locks instead of being general would go a long way imo.", "author": "felixdesouza", "createdAt": "2020-03-11T12:55:05Z", "path": "lock-api/src/main/java/com/palantir/lock/client/RemoteTimeoutRetryer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+class RemoteTimeoutRetryer {\n+    private final Clock clock;\n+\n+    @VisibleForTesting\n+    RemoteTimeoutRetryer(Clock clock) {\n+        this.clock = clock;\n+    }\n+\n+    static RemoteTimeoutRetryer createDefault() {\n+        return new RemoteTimeoutRetryer(Clock.systemUTC());\n+    }\n+\n+    <S, T> T attemptUntilTimeLimitOrException(\n+            S request,\n+            Function<S, Duration> durationExtractor,\n+            BiFunction<S, Duration, S> durationLimiter,\n+            Function<S, T> query,\n+            Predicate<T> successfulResponseEvaluator,\n+            T defaultResponse) {", "originalCommit": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1ODM1MA==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391158350", "bodyText": "Discussed offline: We now save the response if the evaluator fails and return that.", "author": "jeremyk-91", "createdAt": "2020-03-11T17:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk0OTQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MDYxNw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390950617", "bodyText": "why times(3) here? seems pretty non-obvious", "author": "felixdesouza", "createdAt": "2020-03-11T12:57:14Z", "path": "lock-api/src/test/java/com/palantir/lock/client/RemoteTimeoutRetryerTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+@SuppressWarnings(\"unchecked\") // Mocks with generic types\n+public class RemoteTimeoutRetryerTest {\n+    private static final int DEFAULT_VALUE = -1;\n+    private static final int QUERY_VALUE = 3;\n+    private static final int FORTY_TWO = 42;\n+    private static final Exception TIMEOUT_EXCEPTION = new RuntimeException(new SocketTimeoutException(\"timeout\"));\n+    private static final Exception RUNTIME_EXCEPTION = new RuntimeException();\n+\n+    private final Clock clock = mock(Clock.class);\n+    private final RemoteTimeoutRetryer retryer = new RemoteTimeoutRetryer(clock);\n+    private final Function<IntAndDuration, Integer> query = mock(Function.class);\n+\n+    @Test\n+    public void returnsRequestImmediatelyIfSuccessful() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(FORTY_TWO);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(FORTY_TWO);\n+\n+        verify(query).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void returnsDefaultIfAlwaysFailing() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(DEFAULT_VALUE);\n+\n+        verify(query, times(3)).apply(any(IntAndDuration.class));", "originalCommit": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE4NzQxNQ==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391187415", "bodyText": "The request is 10 ms, and the clock advances in steps of 4 ms, so ceil(10/4) = 3.", "author": "jeremyk-91", "createdAt": "2020-03-11T18:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MDYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MzE1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390953156", "bodyText": "this is a bit weird, I think if you have to have this, have something along the lines of:\nList<Duration> durations = captor.getAllValues().stream().map(IntAndDuration::duration).collect(toList());\nassertThat(durations)\n  .as(\"duration is decreasing\")\n  .isSortedAccordingTo(Comparator.reverseOrder())", "author": "felixdesouza", "createdAt": "2020-03-11T13:02:06Z", "path": "lock-api/src/test/java/com/palantir/lock/client/RemoteTimeoutRetryerTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+@SuppressWarnings(\"unchecked\") // Mocks with generic types\n+public class RemoteTimeoutRetryerTest {\n+    private static final int DEFAULT_VALUE = -1;\n+    private static final int QUERY_VALUE = 3;\n+    private static final int FORTY_TWO = 42;\n+    private static final Exception TIMEOUT_EXCEPTION = new RuntimeException(new SocketTimeoutException(\"timeout\"));\n+    private static final Exception RUNTIME_EXCEPTION = new RuntimeException();\n+\n+    private final Clock clock = mock(Clock.class);\n+    private final RemoteTimeoutRetryer retryer = new RemoteTimeoutRetryer(clock);\n+    private final Function<IntAndDuration, Integer> query = mock(Function.class);\n+\n+    @Test\n+    public void returnsRequestImmediatelyIfSuccessful() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(FORTY_TWO);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(FORTY_TWO);\n+\n+        verify(query).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void returnsDefaultIfAlwaysFailing() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(DEFAULT_VALUE);\n+\n+        verify(query, times(3)).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void blockingDurationsDecreaseAsTimePasses() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        retryForTenMillisAcceptingOnlyFortyTwo();\n+\n+        ArgumentCaptor<IntAndDuration> captor = ArgumentCaptor.forClass(IntAndDuration.class);\n+        verify(query, times(3)).apply(captor.capture());\n+        assertThat(captor.getAllValues()).containsExactly(", "originalCommit": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE5NDcyMQ==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391194721", "bodyText": "I probably should rename the test. Not entirely happy with that assertion: 10, 9, 8 (or for that matter 10, 10, 10) would pass when they shouldn't.", "author": "jeremyk-91", "createdAt": "2020-03-11T18:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MzE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU0NjQ0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391546441", "bodyText": "that's fair", "author": "felixdesouza", "createdAt": "2020-03-12T11:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk1MzE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2MjA0MA==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390962040", "bodyText": "the tests here are weird because there is nothing tying together a request timing out and the actual time, one is handled by the setupDefaultClock and the other is just if the query returns a correct response, as such it makes this example a bti contrived and hard to follow.\nIf anything, I'd probably have a method which was like: returnResponseAfterDuration(T response, Duration duration). That sets up the clock and also the query mock.\nprivate static BoolAndDuration successfulAfter(Duration duration) { ... }\nprivate static BoolAndDuration failedAfter(Duration duration) { ... }\nprivate static void setupStuff(BoolAndDuration... durations) {\n  // create arrays of the flag and stick it into the query mock\n  // create arrays of the duration and stick it into the clock mock\n}\n\npublic void test() {\n  setupStuff(\n    failedAfter(Duration.ofMillis(4)), \n    successfullAfter(Duration.ofMillis(5));\n\n  bool result = retryForTenMillisWaitingForSuccess();\n  ...\n}\nI'd probably go further and get rid of ints and just do this purely on booleans.", "author": "felixdesouza", "createdAt": "2020-03-11T13:17:48Z", "path": "lock-api/src/test/java/com/palantir/lock/client/RemoteTimeoutRetryerTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+@SuppressWarnings(\"unchecked\") // Mocks with generic types\n+public class RemoteTimeoutRetryerTest {\n+    private static final int DEFAULT_VALUE = -1;\n+    private static final int QUERY_VALUE = 3;\n+    private static final int FORTY_TWO = 42;\n+    private static final Exception TIMEOUT_EXCEPTION = new RuntimeException(new SocketTimeoutException(\"timeout\"));\n+    private static final Exception RUNTIME_EXCEPTION = new RuntimeException();\n+\n+    private final Clock clock = mock(Clock.class);\n+    private final RemoteTimeoutRetryer retryer = new RemoteTimeoutRetryer(clock);\n+    private final Function<IntAndDuration, Integer> query = mock(Function.class);\n+\n+    @Test\n+    public void returnsRequestImmediatelyIfSuccessful() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(FORTY_TWO);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(FORTY_TWO);\n+\n+        verify(query).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void returnsDefaultIfAlwaysFailing() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        int result = retryForTenMillisAcceptingOnlyFortyTwo();\n+        assertThat(result).isEqualTo(DEFAULT_VALUE);\n+\n+        verify(query, times(3)).apply(any(IntAndDuration.class));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void blockingDurationsDecreaseAsTimePasses() {\n+        setupDefaultClock();\n+        when(query.apply(any())).thenReturn(5);\n+\n+        retryForTenMillisAcceptingOnlyFortyTwo();\n+\n+        ArgumentCaptor<IntAndDuration> captor = ArgumentCaptor.forClass(IntAndDuration.class);\n+        verify(query, times(3)).apply(captor.capture());\n+        assertThat(captor.getAllValues()).containsExactly(\n+                ImmutableIntAndDuration.of(QUERY_VALUE, Duration.ofMillis(10)),\n+                ImmutableIntAndDuration.of(QUERY_VALUE, Duration.ofMillis(6)),\n+                ImmutableIntAndDuration.of(QUERY_VALUE, Duration.ofMillis(2)));\n+        verifyNoMoreInteractions(query);\n+    }\n+\n+    @Test\n+    public void recoversFromFailureIfWeBecomeSuccessful() {\n+        setupDefaultClock();", "originalCommit": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMTQ0Ng==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391211446", "bodyText": "The BDD style thing could work. I think this is somewhat more complicated than what you've written above though: there are 4 cases, not 2 (retryable and non-retryable exceptions) so we can't just use arrays and thenReturn, there'll be some tricky conversions involved.", "author": "jeremyk-91", "createdAt": "2020-03-11T19:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2MjA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2NDkwOA==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390964908", "bodyText": "bit obscure, is there a way we can refer to ClientOptions.NON_BLOCKING_READ_TIMEOUT.plus(Duration.ofSeconds(1)) as the lock timeout here?", "author": "felixdesouza", "createdAt": "2020-03-11T13:22:21Z", "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/MultiNodePaxosTimeLockServerIntegrationTest.java", "diffHunk": "@@ -193,4 +197,29 @@ public void canCreateNewClientsDynamically() {\n         }\n     }\n \n+    @Test\n+    public void lockRequestCanBlockForTheFullTimeout() {\n+        // Test proxy timeout is 12.5 seconds, so 15 seconds suffices.\n+        LockToken token = client.lock(LockRequest.of(LOCKS, DEFAULT_LOCK_TIMEOUT_MS)).getToken();\n+\n+        try {\n+            LockResponse response = client.lock(LockRequest.of(LOCKS, 15_000));\n+            assertThat(response.wasSuccessful()).isFalse();\n+        } finally {\n+            client.unlock(token);\n+        }\n+    }\n+\n+    @Test\n+    public void waitForLocksRequestCanBlockForTheFullTimeout() {\n+        // Test proxy timeout is 12.5 seconds, so 15 seconds suffices.", "originalCommit": "616bc764419bb0ef9bd2fee8ee6486ca8b54952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2NTQ5Ng==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r390965496", "bodyText": "as an aside, whilst trying to find that option, it's unclear to me why we have clientQoS enabled as a default, why is that?", "author": "felixdesouza", "createdAt": "2020-03-11T13:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2NDkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE3MTI1MA==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r391171250", "bodyText": "Yep, I'm OK with making that public.\nClientQoS: I don't know as well, other than that the normal default for that in most uses outside of Atlas should be enabled.", "author": "jeremyk-91", "createdAt": "2020-03-11T18:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk2NDkwOA=="}], "type": "inlineReview"}, {"oid": "13c83228caaeb542fbd58a8af9d7ca6115553bff", "url": "https://github.com/palantir/atlasdb/commit/13c83228caaeb542fbd58a8af9d7ca6115553bff", "message": "update tests", "committedDate": "2020-03-11T20:06:53Z", "type": "commit"}, {"oid": "f922840ffd3192badbf10c817bf068e5cd8885fb", "url": "https://github.com/palantir/atlasdb/commit/f922840ffd3192badbf10c817bf068e5cd8885fb", "message": "cs", "committedDate": "2020-03-11T20:19:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NzY0Ng==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392147646", "bodyText": "waitForLocks should not need to be handled here", "author": "j-baker", "createdAt": "2020-03-13T10:33:05Z", "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Ints;\n+import com.palantir.atlasdb.timelock.api.ConjureLockRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureLockResponse;\n+import com.palantir.atlasdb.timelock.api.SuccessfulLockResponse;\n+import com.palantir.atlasdb.timelock.api.UnsuccessfulLockResponse;\n+import com.palantir.lock.v2.LockRequest;\n+import com.palantir.lock.v2.LockResponse;\n+import com.palantir.lock.v2.WaitForLocksRequest;\n+import com.palantir.lock.v2.WaitForLocksResponse;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+\n+/**\n+ * Ensures that clients actually attempt to acquire the lock for the full duration they claim they will block for,\n+ * unless they run into an exception that is unlikely to actually be a timeout. This is done to account for the reality\n+ * of bounded timeouts beneath us (e.g. in terms of the networking layer) when communicating with remote services.\n+ *\n+ * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n+ */\n+final class BlockEnforcingLockService {\n+    private final NamespacedConjureTimelockService namespacedConjureTimelockService;\n+    private final RemoteTimeoutRetryer timeoutRetryer;\n+\n+    private BlockEnforcingLockService(NamespacedConjureTimelockService namespacedConjureTimelockService,\n+            RemoteTimeoutRetryer timeoutRetryer) {\n+        this.namespacedConjureTimelockService = namespacedConjureTimelockService;\n+        this.timeoutRetryer = timeoutRetryer;\n+    }\n+\n+    static BlockEnforcingLockService create(NamespacedConjureTimelockService namespacedConjureTimelockService) {\n+        return new BlockEnforcingLockService(namespacedConjureTimelockService, RemoteTimeoutRetryer.createDefault());\n+    }\n+\n+    LockResponse lock(LockRequest request) {\n+        // The addition of a UUID takes place only at the Conjure level, so we must retry the same request.\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleLockRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    WaitForLocksResponse waitForLocks(WaitForLocksRequest request) {", "originalCommit": "f922840ffd3192badbf10c817bf068e5cd8885fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0Nzg2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392147863", "bodyText": "actually, ignore, this is still better...", "author": "j-baker", "createdAt": "2020-03-13T10:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NzY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0ODE0Nw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392148147", "bodyText": "can we Ints.checkedCast this? This is only likely to be a long if we have a bug.", "author": "j-baker", "createdAt": "2020-03-13T10:34:02Z", "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Ints;\n+import com.palantir.atlasdb.timelock.api.ConjureLockRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureLockResponse;\n+import com.palantir.atlasdb.timelock.api.SuccessfulLockResponse;\n+import com.palantir.atlasdb.timelock.api.UnsuccessfulLockResponse;\n+import com.palantir.lock.v2.LockRequest;\n+import com.palantir.lock.v2.LockResponse;\n+import com.palantir.lock.v2.WaitForLocksRequest;\n+import com.palantir.lock.v2.WaitForLocksResponse;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+\n+/**\n+ * Ensures that clients actually attempt to acquire the lock for the full duration they claim they will block for,\n+ * unless they run into an exception that is unlikely to actually be a timeout. This is done to account for the reality\n+ * of bounded timeouts beneath us (e.g. in terms of the networking layer) when communicating with remote services.\n+ *\n+ * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n+ */\n+final class BlockEnforcingLockService {\n+    private final NamespacedConjureTimelockService namespacedConjureTimelockService;\n+    private final RemoteTimeoutRetryer timeoutRetryer;\n+\n+    private BlockEnforcingLockService(NamespacedConjureTimelockService namespacedConjureTimelockService,\n+            RemoteTimeoutRetryer timeoutRetryer) {\n+        this.namespacedConjureTimelockService = namespacedConjureTimelockService;\n+        this.timeoutRetryer = timeoutRetryer;\n+    }\n+\n+    static BlockEnforcingLockService create(NamespacedConjureTimelockService namespacedConjureTimelockService) {\n+        return new BlockEnforcingLockService(namespacedConjureTimelockService, RemoteTimeoutRetryer.createDefault());\n+    }\n+\n+    LockResponse lock(LockRequest request) {\n+        // The addition of a UUID takes place only at the Conjure level, so we must retry the same request.\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleLockRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    WaitForLocksResponse waitForLocks(WaitForLocksRequest request) {\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleWaitForLocksRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    private static ConjureLockRequest clampLockRequestToDeadline(ConjureLockRequest request, Duration remainingTime) {\n+        return ConjureLockRequest.builder()\n+                .from(request)\n+                .acquireTimeoutMs(Ints.saturatedCast(remainingTime.toMillis()))", "originalCommit": "f922840ffd3192badbf10c817bf068e5cd8885fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzMzgxNg==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392333816", "bodyText": "Sure, yeah, agree checkedCast is more appropriate.", "author": "jeremyk-91", "createdAt": "2020-03-13T16:24:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0ODE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0OTA3MQ==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392149071", "bodyText": "can this be a RuntimeException? Should not see any checked exceptions", "author": "j-baker", "createdAt": "2020-03-13T10:36:05Z", "path": "lock-api/src/main/java/com/palantir/lock/client/BlockEnforcingLockService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.client;\n+\n+import java.net.SocketTimeoutException;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Ints;\n+import com.palantir.atlasdb.timelock.api.ConjureLockRequest;\n+import com.palantir.atlasdb.timelock.api.ConjureLockResponse;\n+import com.palantir.atlasdb.timelock.api.SuccessfulLockResponse;\n+import com.palantir.atlasdb.timelock.api.UnsuccessfulLockResponse;\n+import com.palantir.lock.v2.LockRequest;\n+import com.palantir.lock.v2.LockResponse;\n+import com.palantir.lock.v2.WaitForLocksRequest;\n+import com.palantir.lock.v2.WaitForLocksResponse;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.exceptions.SafeIllegalStateException;\n+\n+/**\n+ * Ensures that clients actually attempt to acquire the lock for the full duration they claim they will block for,\n+ * unless they run into an exception that is unlikely to actually be a timeout. This is done to account for the reality\n+ * of bounded timeouts beneath us (e.g. in terms of the networking layer) when communicating with remote services.\n+ *\n+ * Fairness is admittedly compromised, but this is a closer approximation than the previous behaviour.\n+ */\n+final class BlockEnforcingLockService {\n+    private final NamespacedConjureTimelockService namespacedConjureTimelockService;\n+    private final RemoteTimeoutRetryer timeoutRetryer;\n+\n+    private BlockEnforcingLockService(NamespacedConjureTimelockService namespacedConjureTimelockService,\n+            RemoteTimeoutRetryer timeoutRetryer) {\n+        this.namespacedConjureTimelockService = namespacedConjureTimelockService;\n+        this.timeoutRetryer = timeoutRetryer;\n+    }\n+\n+    static BlockEnforcingLockService create(NamespacedConjureTimelockService namespacedConjureTimelockService) {\n+        return new BlockEnforcingLockService(namespacedConjureTimelockService, RemoteTimeoutRetryer.createDefault());\n+    }\n+\n+    LockResponse lock(LockRequest request) {\n+        // The addition of a UUID takes place only at the Conjure level, so we must retry the same request.\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleLockRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    WaitForLocksResponse waitForLocks(WaitForLocksRequest request) {\n+        return timeoutRetryer.attemptUntilTimeLimitOrException(\n+                ConjureLockRequests.toConjure(request),\n+                Duration.ofMillis(request.getAcquireTimeoutMs()),\n+                BlockEnforcingLockService::clampLockRequestToDeadline,\n+                this::performSingleWaitForLocksRequest,\n+                response -> !response.wasSuccessful());\n+    }\n+\n+    private static ConjureLockRequest clampLockRequestToDeadline(ConjureLockRequest request, Duration remainingTime) {\n+        return ConjureLockRequest.builder()\n+                .from(request)\n+                .acquireTimeoutMs(Ints.saturatedCast(remainingTime.toMillis()))\n+                .build();\n+    }\n+\n+    private LockResponse performSingleLockRequest(ConjureLockRequest request) {\n+        return namespacedConjureTimelockService\n+                .lock(request)\n+                .accept(ToLeasedLockResponse.INSTANCE);\n+    }\n+\n+    private WaitForLocksResponse performSingleWaitForLocksRequest(ConjureLockRequest request) {\n+        return ConjureLockRequests.fromConjure(namespacedConjureTimelockService.waitForLocks(request));\n+    }\n+\n+    private enum ToLeasedLockResponse implements ConjureLockResponse.Visitor<LockResponse> {\n+        INSTANCE;\n+\n+        @Override\n+        public LockResponse visitSuccessful(SuccessfulLockResponse value) {\n+            return LockResponse.successful(LeasedLockToken.of(value.getLockToken(), value.getLease()));\n+        }\n+\n+        @Override\n+        public LockResponse visitUnsuccessful(UnsuccessfulLockResponse value) {\n+            return LockResponse.timedOut();\n+        }\n+\n+        @Override\n+        public LockResponse visitUnknown(String unknownType) {\n+            throw new SafeIllegalStateException(\"Unknown response type\", SafeArg.of(\"type\", unknownType));\n+        }\n+    }\n+\n+    static class RemoteTimeoutRetryer {\n+        private final Clock clock;\n+\n+        @VisibleForTesting\n+        RemoteTimeoutRetryer(Clock clock) {\n+            this.clock = clock;\n+        }\n+\n+        static BlockEnforcingLockService.RemoteTimeoutRetryer createDefault() {\n+            return new BlockEnforcingLockService.RemoteTimeoutRetryer(Clock.systemUTC());\n+        }\n+\n+        <S, T> T attemptUntilTimeLimitOrException(\n+                S request,\n+                Duration duration,\n+                BiFunction<S, Duration, S> durationLimiter,\n+                Function<S, T> query,\n+                Predicate<T> isTimedOutResponse) {\n+            Instant now = clock.instant();\n+            Instant deadline = now.plus(duration);\n+            S currentRequest = request;\n+            T currentResponse = null;\n+\n+            while (now.isBefore(deadline)) {\n+                Duration remainingTime = Duration.between(now, deadline);\n+                currentRequest = durationLimiter.apply(currentRequest, remainingTime);\n+\n+                try {\n+                    currentResponse = query.apply(currentRequest);\n+                    if (!isTimedOutResponse.test(currentResponse)) {\n+                        return currentResponse;\n+                    }\n+                } catch (Exception e) {", "originalCommit": "f922840ffd3192badbf10c817bf068e5cd8885fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNTAxMw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392335013", "bodyText": "Yep, good point. Changed", "author": "jeremyk-91", "createdAt": "2020-03-13T16:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0OTA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0OTU3Mw==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392149573", "bodyText": "is the line above also broken?", "author": "j-baker", "createdAt": "2020-03-13T10:37:08Z", "path": "lock-api/src/main/java/com/palantir/lock/client/ConjureLockRequests.java", "diffHunk": "@@ -47,7 +47,7 @@ public static ConjureLockRequest toConjure(WaitForLocksRequest request) {\n         return ConjureLockRequest.builder()\n                 .lockDescriptors(toConjure(request.getLockDescriptors()))\n                 .clientDescription(request.getClientDescription())\n-                .requestId(UUID.randomUUID())\n+                .requestId(request.getRequestId())", "originalCommit": "f922840ffd3192badbf10c817bf068e5cd8885fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0OTc2MQ==", "url": "https://github.com/palantir/atlasdb/pull/4645#discussion_r392149761", "bodyText": "answer - no", "author": "j-baker", "createdAt": "2020-03-13T10:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0OTU3Mw=="}], "type": "inlineReview"}, {"oid": "46d7cb4d52fe404761e243f0a862594c6bba085d", "url": "https://github.com/palantir/atlasdb/commit/46d7cb4d52fe404761e243f0a862594c6bba085d", "message": "James PR comments", "committedDate": "2020-03-13T16:26:44Z", "type": "commit"}, {"oid": "783524d87c7d8f7c76fd88d565dc46dc760e49ea", "url": "https://github.com/palantir/atlasdb/commit/783524d87c7d8f7c76fd88d565dc46dc760e49ea", "message": "one ete", "committedDate": "2020-03-13T19:39:32Z", "type": "commit"}]}