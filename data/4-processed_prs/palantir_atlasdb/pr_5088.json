{"pr_number": 5088, "pr_title": "[LE] Server Side Metrics Accumulator For Leadership Duration", "pr_createdAt": "2020-10-27T23:24:21Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5088", "timeline": [{"oid": "b793264682bb075a7c5a779d5dc334a4302fad95", "url": "https://github.com/palantir/atlasdb/commit/b793264682bb075a7c5a779d5dc334a4302fad95", "message": "Transfer changes from other branches", "committedDate": "2020-10-21T09:27:36Z", "type": "commit"}, {"oid": "ee6bb046be4501552fe35f873a4fade024c877b8", "url": "https://github.com/palantir/atlasdb/commit/ee6bb046be4501552fe35f873a4fade024c877b8", "message": "Pull in the right things", "committedDate": "2020-10-21T14:12:34Z", "type": "commit"}, {"oid": "7d4669f0c72d8fb4a0fad8bc0afb94d414faa88b", "url": "https://github.com/palantir/atlasdb/commit/7d4669f0c72d8fb4a0fad8bc0afb94d414faa88b", "message": "Merge branch 'develop' into le/client-i", "committedDate": "2020-10-21T15:12:01Z", "type": "commit"}, {"oid": "48a3db4d3a5b0bd5f05a87b9d0856c55a8d09738", "url": "https://github.com/palantir/atlasdb/commit/48a3db4d3a5b0bd5f05a87b9d0856c55a8d09738", "message": "rename", "committedDate": "2020-10-21T15:25:12Z", "type": "commit"}, {"oid": "d1f7fa37374952504467f157c810a015c2a507d3", "url": "https://github.com/palantir/atlasdb/commit/d1f7fa37374952504467f157c810a015c2a507d3", "message": "Implementation and some tests", "committedDate": "2020-10-21T22:53:36Z", "type": "commit"}, {"oid": "3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "url": "https://github.com/palantir/atlasdb/commit/3a6c460b2eed97fe8352e46c0ce68694e7cafedb", "message": "Should fix tests", "committedDate": "2020-10-22T08:39:58Z", "type": "commit"}, {"oid": "1c33135c2cf946bed86c415df29eab145cf3fcf5", "url": "https://github.com/palantir/atlasdb/commit/1c33135c2cf946bed86c415df29eab145cf3fcf5", "message": "Make tests great again", "committedDate": "2020-10-22T09:37:12Z", "type": "commit"}, {"oid": "cf458d26cce07fe45302d80a57a03d86bf06fd4c", "url": "https://github.com/palantir/atlasdb/commit/cf458d26cce07fe45302d80a57a03d86bf06fd4c", "message": "Merge with develop", "committedDate": "2020-10-22T14:52:48Z", "type": "commit"}, {"oid": "a3793e6f2fcf9257237d623e0b05b1f6be3f73a6", "url": "https://github.com/palantir/atlasdb/commit/a3793e6f2fcf9257237d623e0b05b1f6be3f73a6", "message": "Bleh", "committedDate": "2020-10-22T16:09:08Z", "type": "commit"}, {"oid": "edb7750726df1240901dc1bc41fb9ce7aaf967c1", "url": "https://github.com/palantir/atlasdb/commit/edb7750726df1240901dc1bc41fb9ce7aaf967c1", "message": "Pull out only necessary files", "committedDate": "2020-10-23T09:28:16Z", "type": "commit"}, {"oid": "a93f810c495937bdee87ac041fb00c6fe09bba50", "url": "https://github.com/palantir/atlasdb/commit/a93f810c495937bdee87ac041fb00c6fe09bba50", "message": "address aggressive autoformat", "committedDate": "2020-10-23T09:35:22Z", "type": "commit"}, {"oid": "4a75c069358bbef81d993781a8238a9829fcddad", "url": "https://github.com/palantir/atlasdb/commit/4a75c069358bbef81d993781a8238a9829fcddad", "message": "current value metric", "committedDate": "2020-10-23T09:39:07Z", "type": "commit"}, {"oid": "133bfa79b08a664ddabf141187edbaa8066ccb3c", "url": "https://github.com/palantir/atlasdb/commit/133bfa79b08a664ddabf141187edbaa8066ccb3c", "message": "Cleanup, more tests", "committedDate": "2020-10-23T09:51:07Z", "type": "commit"}, {"oid": "0c19da98f9fef5e3b8da5441f0b262b768a32e97", "url": "https://github.com/palantir/atlasdb/commit/0c19da98f9fef5e3b8da5441f0b262b768a32e97", "message": "add testing to LERTST", "committedDate": "2020-10-23T09:59:50Z", "type": "commit"}, {"oid": "a5f6339842ff2cff883413a576c51676803474ec", "url": "https://github.com/palantir/atlasdb/commit/a5f6339842ff2cff883413a576c51676803474ec", "message": "Merge branch 'le/client-ii' into le/server-ia\n\n# Conflicts:\n#\tlock-api/src/main/java/com/palantir/lock/client/LeaderElectionReportingTimelockService.java\n#\tlock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "committedDate": "2020-10-23T12:58:04Z", "type": "commit"}, {"oid": "ddf2f72859208dc58405c3192d447bb6bf87f3e4", "url": "https://github.com/palantir/atlasdb/commit/ddf2f72859208dc58405c3192d447bb6bf87f3e4", "message": "comments", "committedDate": "2020-10-23T13:10:07Z", "type": "commit"}, {"oid": "debe1230b0cf305c036e6ecfea76e42e283b4939", "url": "https://github.com/palantir/atlasdb/commit/debe1230b0cf305c036e6ecfea76e42e283b4939", "message": "Merge conflicts, modify duration estimate", "committedDate": "2020-10-26T13:59:52Z", "type": "commit"}, {"oid": "7a587b993b87e7378825d961ef1e2718247c7ef0", "url": "https://github.com/palantir/atlasdb/commit/7a587b993b87e7378825d961ef1e2718247c7ef0", "message": "WIP", "committedDate": "2020-10-26T17:45:24Z", "type": "commit"}, {"oid": "984f58e38d5499715907393574e1cc1c2a9ff004", "url": "https://github.com/palantir/atlasdb/commit/984f58e38d5499715907393574e1cc1c2a9ff004", "message": "Working implementation with tests", "committedDate": "2020-10-26T23:29:11Z", "type": "commit"}, {"oid": "dfae539a07399fbd9ff5ccd9abb23facbc00126e", "url": "https://github.com/palantir/atlasdb/commit/dfae539a07399fbd9ff5ccd9abb23facbc00126e", "message": "Wire, fix test", "committedDate": "2020-10-27T23:21:51Z", "type": "commit"}, {"oid": "3d57b2093e574a3f0a14820f4864c14b1fca6956", "url": "https://github.com/palantir/atlasdb/commit/3d57b2093e574a3f0a14820f4864c14b1fca6956", "message": "Merge with develop", "committedDate": "2020-11-02T15:24:37Z", "type": "commit"}, {"oid": "ae11a448e24690d135fcca45e706864e0cd27d0e", "url": "https://github.com/palantir/atlasdb/commit/ae11a448e24690d135fcca45e706864e0cd27d0e", "message": "WAT", "committedDate": "2020-11-02T15:51:55Z", "type": "commit"}, {"oid": "d1becc89efa3706116afba5e787462308a48d90b", "url": "https://github.com/palantir/atlasdb/commit/d1becc89efa3706116afba5e787462308a48d90b", "message": "Some cleanup", "committedDate": "2020-11-02T16:27:38Z", "type": "commit"}, {"oid": "46df1f5a2bd4e1372914cd634554cef3f71efc34", "url": "https://github.com/palantir/atlasdb/commit/46df1f5a2bd4e1372914cd634554cef3f71efc34", "message": "Bleh", "committedDate": "2020-11-02T17:12:30Z", "type": "commit"}, {"oid": "a0197b482cfbfd3c67221c61f1166b0b58279047", "url": "https://github.com/palantir/atlasdb/commit/a0197b482cfbfd3c67221c61f1166b0b58279047", "message": "Merge branch 'develop' into le/duration", "committedDate": "2020-11-03T10:05:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU1MzIzOA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516553238", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void assertExpectedDurationAndLeaders(Instant instant, Instant instant2, UUID old, UUID next) {\n          \n          \n            \n                private void assertExpectedDurationAndLeaders(Instant instant, Instant instant2, UUID oldLeader, UUID newLeader) {", "author": "Jolyon-S", "createdAt": "2020-11-03T10:11:07Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -352,10 +354,13 @@ public void statisticsCausesMetricRegistryToBeReset() {\n         verifyNoMoreInteractions(mockedTimer);\n     }\n \n-    private void assertExpectedDuration(Instant instant, Instant instant2) {\n-        Optional<Duration> estimatedDuration = timelockService.calculateLastLeaderElectionDuration();\n-        assertThat(estimatedDuration).isPresent();\n-        assertThat(estimatedDuration.get()).isEqualTo(Duration.between(instant, instant2));\n+    private void assertExpectedDurationAndLeaders(Instant instant, Instant instant2, UUID old, UUID next) {", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU1NDk4Nw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516554987", "bodyText": "nit: can we extract a constant for this number? Possibly above too although for some reason I don't mind as much for the reservoir.", "author": "Jolyon-S", "createdAt": "2020-11-03T10:13:44Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionMetricAggregator.java", "diffHunk": "@@ -16,39 +16,41 @@\n \n package com.palantir.atlasdb.timelock.adjudicate;\n \n-import com.palantir.atlasdb.util.CurrentValueMetric;\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n import com.palantir.atlasdb.util.MetricsManager;\n import com.palantir.atlasdb.util.SlidingWindowWeightedMeanGauge;\n-import com.palantir.conjure.java.lib.SafeLong;\n import com.palantir.timelock.feedback.LeaderElectionStatistics;\n+import java.util.concurrent.TimeUnit;\n \n public final class LeaderElectionMetricAggregator {\n     private final SlidingWindowWeightedMeanGauge weightedGaugeP99;\n     private final SlidingWindowWeightedMeanGauge weightedGaugeP95;\n     private final SlidingWindowWeightedMeanGauge weightedGaugeMean;\n-    private final CurrentValueMetric<Long> leaderElectionEstimate;\n+    private final LeaderElectionDurationAccumulator leaderElectionDurationAccumulator;\n \n     public LeaderElectionMetricAggregator(MetricsManager metricsManager) {\n         weightedGaugeP99 = SlidingWindowWeightedMeanGauge.create();\n         weightedGaugeP95 = SlidingWindowWeightedMeanGauge.create();\n         weightedGaugeMean = SlidingWindowWeightedMeanGauge.create();\n-        leaderElectionEstimate = new CurrentValueMetric<>();\n         metricsManager.registerMetric(\n                 LeaderElectionMetricAggregator.class, \"leaderElectionImpactMean\", weightedGaugeMean);\n         metricsManager.registerMetric(\n                 LeaderElectionMetricAggregator.class, \"leaderElectionImpactP95\", weightedGaugeP95);\n         metricsManager.registerMetric(\n                 LeaderElectionMetricAggregator.class, \"leaderElectionImpactP99\", weightedGaugeP99);\n-        metricsManager.registerMetric(\n-                LeaderElectionMetricAggregator.class, \"leaderElectionEstimate\", leaderElectionEstimate);\n+        Histogram leaderElectionHistogram = metricsManager.registerOrGetHistogram(\n+                LeaderElectionMetricAggregator.class,\n+                \"leaderElectionDurationEstimate\",\n+                () -> new Histogram(new SlidingTimeWindowArrayReservoir(5, TimeUnit.MINUTES)));\n+        leaderElectionDurationAccumulator = new LeaderElectionDurationAccumulator(leaderElectionHistogram::update, 10);", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU1NjI5MA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516556290", "bodyText": "nit: rename to something informative, like metricsConsumer or updateConsumer etc.", "author": "Jolyon-S", "createdAt": "2020-11-03T10:15:46Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2MDQzMQ==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516560431", "bodyText": "I'm not a fan of using of here, given that they have the same type - this is one of the places where I would strongly prefer a builder despite there being only two params.", "author": "Jolyon-S", "createdAt": "2020-11-03T10:22:41Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2MjY3Mw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516562673", "bodyText": "I think this is cleaner (with proper indentation, of course)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (alreadyReportedLeaderElections.contains(leadersContext)) {\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n                    currentlySoaking.compute(\n          \n          \n            \n                            leadersContext,\n          \n          \n            \n                            (context, previous) -> increaseConfidence(\n          \n          \n            \n                                    context, previous, duration.getDuration().longValue()));\n          \n          \n            \n                    if (!alreadyReportedLeaderElections.contains(leadersContext)) {\n          \n          \n            \n                               currentlySoaking.compute(\n          \n          \n            \n                                        leadersContext,\n          \n          \n            \n                                       (context, previous) -> increaseConfidence(\n          \n          \n            \n                                        context, previous, duration.getDuration().longValue()));\n          \n          \n            \n                    }", "author": "Jolyon-S", "createdAt": "2020-11-03T10:26:18Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2MzI0NA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516563244", "bodyText": "nit: can you add a newline between these if statements? they feel very crowded", "author": "Jolyon-S", "createdAt": "2020-11-03T10:27:16Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NDA5Nw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516564097", "bodyText": "nit: would it be cleaner to add a method on SoakingDuration where you just pass a duration and it creates it with 1 set?", "author": "Jolyon-S", "createdAt": "2020-11-03T10:28:46Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NDIwMw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516564203", "bodyText": "nit: inline?", "author": "Jolyon-S", "createdAt": "2020-11-03T10:28:57Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);\n+        }\n+        long accumulatedDuration = accumulatedSoakingDuration.value();", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NDg1Mw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516564853", "bodyText": "I feel like you should increase the count and duration together", "author": "Jolyon-S", "createdAt": "2020-11-03T10:29:49Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);\n+        }\n+        long accumulatedDuration = accumulatedSoakingDuration.value();\n+        if (accumulatedDuration > duration) {\n+            accumulatedSoakingDuration.setValue(duration);\n+        }\n+        int currentCount = accumulatedSoakingDuration.count() + 1;\n+        if (currentCount >= updatesToAchieveConfidence) {\n+            alreadyReportedLeaderElections.add(context);\n+            consumer.accept(accumulatedSoakingDuration.value());\n+            return null;\n+        }\n+        accumulatedSoakingDuration.setCount(currentCount);", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyOTMyOA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516729328", "bodyText": "See later comment: do we really have to use modifiables?", "author": "jeremyk-91", "createdAt": "2020-11-03T14:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NDg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4MzgwNA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516783804", "bodyText": "Agreed - removed use of modifiables.", "author": "Jolyon-S", "createdAt": "2020-11-03T16:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NDg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzM2MA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516567360", "bodyText": "I think it would be best if the range of values for each pair (other than the repeated ones) should be non-intersecting - i.e. for leader (2,3) you should set the min to say 200 to make 100% certain that you aren't getting a spurious result.", "author": "Jolyon-S", "createdAt": "2020-11-03T10:33:58Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.lib.SafeLong;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczMTI2Nw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516731267", "bodyText": "It would be clearer, yes. I think it is fine as written under the assumption each election is only done once: only L1->L3 could have generated the 7, which means only L1 -> L2 could have generated the 10 (L1 -> L3 already used) and so on.", "author": "jeremyk-91", "createdAt": "2020-11-03T14:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc2NzAxNg==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516767016", "bodyText": "Only L1->L3 should have generated the 7, but if you have a min of 5 and 10 requests, then there exists a request of time 7 there, even if they should report 5. By separating this, you guarantee that it is coming from the right place.", "author": "Jolyon-S", "createdAt": "2020-11-03T15:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3Njg0NA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516776844", "bodyText": "discussed offline: subject to the one-from-one-election assumption, that should be fine as if, e.g. the [7,11] range gave a 10 instead, there's no way for the [10,14] or [15,19] ranges to push a 7. Though let's just discard the need for that assumption and use disjoint ranges.", "author": "jeremyk-91", "createdAt": "2020-11-03T15:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzUyMw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516567523", "bodyText": "The comment above is especially important here, IMO.", "author": "Jolyon-S", "createdAt": "2020-11-03T10:34:13Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.lib.SafeLong;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 10);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 5, 7);\n+\n+        verify(mockConsumer).accept(10L);\n+        verify(mockConsumer).accept(15L);\n+        verify(mockConsumer).accept(7L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingNoPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 300, 1));", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczMjE2NQ==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516732165", "bodyText": "I think it's still technically okay (assuming each election generates one thing) because the 1L could only have come from the first call and so on, though it is probably clearer in terms of readability to have non-overlapping ranges.", "author": "jeremyk-91", "createdAt": "2020-11-03T15:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU2NzUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYwNjYzOQ==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516606639", "bodyText": "nit: Maybe a style preference. I'd prefer just getting it and then asserting on the present value.", "author": "jeremyk-91", "createdAt": "2020-11-03T11:44:16Z", "path": "lock-api/src/test/java/com/palantir/lock/client/LeaderElectionReportingTimelockServiceTest.java", "diffHunk": "@@ -352,10 +354,13 @@ public void statisticsCausesMetricRegistryToBeReset() {\n         verifyNoMoreInteractions(mockedTimer);\n     }\n \n-    private void assertExpectedDuration(Instant instant, Instant instant2) {\n-        Optional<Duration> estimatedDuration = timelockService.calculateLastLeaderElectionDuration();\n-        assertThat(estimatedDuration).isPresent();\n-        assertThat(estimatedDuration.get()).isEqualTo(Duration.between(instant, instant2));\n+    private void assertExpectedDurationAndLeaders(Instant instant, Instant instant2, UUID old, UUID next) {\n+        Optional<LeaderElectionDuration> estimate = timelockService.calculateLastLeaderElectionDuration();\n+        assertThat(estimate).isPresent();\n+        assertThat(estimate.get().getDuration())\n+                .isEqualTo(SafeLong.of(Duration.between(instant, instant2).toNanos()));\n+        assertThat(estimate.get().getOldLeader()).isEqualTo(old);\n+        assertThat(estimate.get().getNewLeader()).isEqualTo(next);", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyNTQzNw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516725437", "bodyText": "Can we either specify the units or have this be the Java duration type? I realise this is a change from the original review, but find this a bit awkward to read", "author": "jeremyk-91", "createdAt": "2020-11-03T14:51:53Z", "path": "timelock-api/src/main/conjure/timelock-feedback.yml", "diffHunk": "@@ -17,13 +17,18 @@ types:\n           p99: double\n           oneMin: double\n           errorRate: optional<double>\n+      LeaderElectionDuration:\n+        fields:\n+          oldLeader: uuid\n+          newLeader: uuid\n+          duration: safelong", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4NTcyOQ==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516785729", "bodyText": "agreed - done", "author": "Jolyon-S", "createdAt": "2020-11-03T16:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyNTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyODU0NQ==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516728545", "bodyText": "Hmm... this is fine, but is it that bad to have this be immutable and just have compute do an allocation? If I'm parsing this correctly it happens only updatesToAchieveConfidence times per election", "author": "jeremyk-91", "createdAt": "2020-11-03T14:56:02Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);\n+        }\n+        long accumulatedDuration = accumulatedSoakingDuration.value();\n+        if (accumulatedDuration > duration) {\n+            accumulatedSoakingDuration.setValue(duration);\n+        }\n+        int currentCount = accumulatedSoakingDuration.count() + 1;\n+        if (currentCount >= updatesToAchieveConfidence) {\n+            alreadyReportedLeaderElections.add(context);\n+            consumer.accept(accumulatedSoakingDuration.value());\n+            return null;\n+        }\n+        accumulatedSoakingDuration.setCount(currentCount);\n+        return accumulatedSoakingDuration;\n+    }\n+\n+    @Value.Immutable\n+    interface LeadersContext {\n+        @Parameter\n+        UUID previous();\n+\n+        @Parameter\n+        UUID next();\n+\n+        static LeadersContext of(UUID previous, UUID next) {\n+            return ImmutableLeadersContext.of(previous, next);\n+        }\n+    }\n+\n+    @Value.Modifiable\n+    interface SoakingDuration {", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4NjE3Mw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516786173", "bodyText": "updatesToAchieveConfidence * clients per election, but still fine to be Immutable IMO", "author": "Jolyon-S", "createdAt": "2020-11-03T16:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyODU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5Njc1Mg==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516796752", "bodyText": "Ah, okay. Not the best then, but it's at most a few thousand small objects so probably fine", "author": "jeremyk-91", "createdAt": "2020-11-03T16:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyODU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcyOTE2Mw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516729163", "bodyText": "sampleMinimum or something like that?", "author": "jeremyk-91", "createdAt": "2020-11-03T14:56:51Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();\n+    private Map<LeadersContext, ModifiableSoakingDuration> currentlySoaking = new ConcurrentHashMap<>();\n+\n+    private final LongConsumer consumer;\n+    private final int updatesToAchieveConfidence;\n+\n+    /**\n+     * This class accumulates {@link LeaderElectionDuration}s by tracking the shortest duration observed for each pair\n+     * of leader ids until updatesToAchieveConfidence have been received for that pair. Once that occurs, the\n+     * final duration is consumed by the consumer, and further updates for the leader id pair are ignored.\n+     *\n+     * @param updatesToAchieveConfidence required number of updates to before the results are reported, must be\n+     *                                   greater than 1\n+     */\n+    public LeaderElectionDurationAccumulator(LongConsumer consumer, int updatesToAchieveConfidence) {\n+        this.consumer = consumer;\n+        this.updatesToAchieveConfidence = updatesToAchieveConfidence;\n+        Preconditions.checkArgument(\n+                updatesToAchieveConfidence > 1,\n+                \"Number of required updates must be greater than 1.\",\n+                SafeArg.of(\"updatesToAchieveConfidence\", updatesToAchieveConfidence));\n+    }\n+\n+    public void add(LeaderElectionDuration duration) {\n+        LeadersContext leadersContext = LeadersContext.of(duration.getOldLeader(), duration.getNewLeader());\n+        if (alreadyReportedLeaderElections.contains(leadersContext)) {\n+            return;\n+        }\n+        currentlySoaking.compute(\n+                leadersContext,\n+                (context, previous) -> increaseConfidence(\n+                        context, previous, duration.getDuration().longValue()));\n+    }\n+\n+    private ModifiableSoakingDuration increaseConfidence(\n+            LeadersContext context, ModifiableSoakingDuration accumulatedSoakingDuration, long duration) {\n+        if (alreadyReportedLeaderElections.contains(context)) {\n+            return null;\n+        }\n+        if (accumulatedSoakingDuration == null) {\n+            return ModifiableSoakingDuration.create(duration, 1);\n+        }\n+        long accumulatedDuration = accumulatedSoakingDuration.value();\n+        if (accumulatedDuration > duration) {\n+            accumulatedSoakingDuration.setValue(duration);\n+        }\n+        int currentCount = accumulatedSoakingDuration.count() + 1;\n+        if (currentCount >= updatesToAchieveConfidence) {\n+            alreadyReportedLeaderElections.add(context);\n+            consumer.accept(accumulatedSoakingDuration.value());\n+            return null;\n+        }\n+        accumulatedSoakingDuration.setCount(currentCount);\n+        return accumulatedSoakingDuration;\n+    }\n+\n+    @Value.Immutable\n+    interface LeadersContext {\n+        @Parameter\n+        UUID previous();\n+\n+        @Parameter\n+        UUID next();\n+\n+        static LeadersContext of(UUID previous, UUID next) {\n+            return ImmutableLeadersContext.of(previous, next);\n+        }\n+    }\n+\n+    @Value.Modifiable\n+    interface SoakingDuration {\n+        @Parameter\n+        long value();", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczMzc0MA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516733740", "bodyText": "I'm possibly confused: how do we guarantee zero is processed in the first five\nAh, this test has an accumulator with 5000. What you have is fine, don't really like that it relies on 5000 being 50 * 100 (maybe introduce some local variables so that it's obvious?) / if you change line 129 to 60 the test breaks, so maybe we could change that slightly", "author": "jeremyk-91", "createdAt": "2020-11-03T15:03:07Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.conjure.java.lib.SafeLong;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 10);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 5, 7);\n+\n+        verify(mockConsumer).accept(10L);\n+        verify(mockConsumer).accept(15L);\n+        verify(mockConsumer).accept(7L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingNoPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 300, 1));\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 300, 17));\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 300, 76));\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(1L);\n+        verify(mockConsumer).accept(17L);\n+        verify(mockConsumer).accept(76L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingWithPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_2, 300, 1));\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_2, LEADER_3, 300, 17));\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_3, 300, 76));\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(1L);\n+        verify(mockConsumer).accept(17L);\n+        verify(mockConsumer).accept(76L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testManyUpdatesForSameLeaders() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(50);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5_000);\n+        List<Integer> durationBuckets =\n+                IntStream.range(0, 100).map(x -> x * 100).boxed().collect(Collectors.toList());\n+        Collections.shuffle(durationBuckets);\n+\n+        durationBuckets.forEach(duration ->\n+                executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_2, 50, duration)));\n+\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(0L);", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc4ODE3Mw==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516788173", "bodyText": "Factored out two variables here, should make it clearer.", "author": "Jolyon-S", "createdAt": "2020-11-03T16:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczMzc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczNzcyNQ==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516737725", "bodyText": "Looks like this grows unbounded. Is this a problem / should we consider using some kind of cache with an ExpiryAfterWrite/Access?", "author": "jeremyk-91", "createdAt": "2020-11-03T15:08:34Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.LongConsumer;\n+import org.immutables.value.Value;\n+import org.immutables.value.Value.Parameter;\n+\n+public class LeaderElectionDurationAccumulator {\n+    private Set<LeadersContext> alreadyReportedLeaderElections = ConcurrentHashMap.newKeySet();", "originalCommit": "a0197b482cfbfd3c67221c61f1166b0b58279047", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5MDE2OA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516790168", "bodyText": "Let's say that you have 50 clients, so each leader election you store 50 * 2 UUIDs, which are 16 bytes IIRC. So that's 160 bytes per leader election. You'd need say >6500 leader elections to occur in the lifetime of this accumulator before you'd have 1MB of space allocated.\nI'm not by any means against making this an expiry cache, but probably won't be necessary.", "author": "Jolyon-S", "createdAt": "2020-11-03T16:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczNzcyNQ=="}], "type": "inlineReview"}, {"oid": "0160de64915fe31d135bbdaeeed7fe747b794e70", "url": "https://github.com/palantir/atlasdb/commit/0160de64915fe31d135bbdaeeed7fe747b794e70", "message": "action comments", "committedDate": "2020-11-03T16:20:17Z", "type": "commit"}, {"oid": "08c65ac46226324bf4fa2b708c428ecd8fea5e28", "url": "https://github.com/palantir/atlasdb/commit/08c65ac46226324bf4fa2b708c428ecd8fea5e28", "message": "resolve merge conflict", "committedDate": "2020-11-03T16:22:55Z", "type": "commit"}, {"oid": "ca5fa29189dde7664593bd4578da060bf71aa38f", "url": "https://github.com/palantir/atlasdb/commit/ca5fa29189dde7664593bd4578da060bf71aa38f", "message": "revert spooky diff", "committedDate": "2020-11-03T16:23:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5ODkxMA==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516798910", "bodyText": "nit: I realise it's the same as the original test, though really the second multiplicand seems like it shouldn't be tied to numBuckets but requestsPerBucket (and I guess if you want a bit of additional space that's fine).", "author": "jeremyk-91", "createdAt": "2020-11-03T16:31:06Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/adjudicate/LeaderElectionDurationAccumulatorTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.adjudicate;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import com.palantir.common.concurrent.PTExecutors;\n+import com.palantir.timelock.feedback.LeaderElectionDuration;\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.LongConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import org.junit.Test;\n+\n+public class LeaderElectionDurationAccumulatorTest {\n+    private static final UUID LEADER_1 = UUID.randomUUID();\n+    private static final UUID LEADER_2 = UUID.randomUUID();\n+    private static final UUID LEADER_3 = UUID.randomUUID();\n+\n+    private LongConsumer mockConsumer = mock(LongConsumer.class);\n+    private LeaderElectionDurationAccumulator accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 5);\n+\n+    @Test\n+    public void nothingConsumedWithFewUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 4, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 4, 5);\n+\n+        verifyNoInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeAfterFiveUpdatesWithMinDuration() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+\n+        verify(mockConsumer).accept(1L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnlyOnceUsingMinFromFirstFiveUpdates() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 15);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 10, 1);\n+\n+        verify(mockConsumer).accept(15L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    public void consumeOnceForEachLeaderPair() {\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 10);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 5, 25);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 5, 1);\n+        leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 5, 37);\n+\n+        verify(mockConsumer).accept(10L);\n+        verify(mockConsumer).accept(25L);\n+        verify(mockConsumer).accept(37L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingNoPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_2, 300, 1));\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_2, LEADER_3, 300, 1017));\n+        executorService.submit(() -> leaderElectionResultsWithDurationInRandomOrder(LEADER_1, LEADER_3, 300, 2076));\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(1L);\n+        verify(mockConsumer).accept(1017L);\n+        verify(mockConsumer).accept(2076L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testInterleavingWithPause() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(3);\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, 300);\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_2, 300, 1));\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_2, LEADER_3, 300, 1017));\n+        executorService.submit(() -> leaderElectionResultsWithPause(LEADER_1, LEADER_3, 300, 2076));\n+        executorService.shutdown();\n+        executorService.awaitTermination(1, TimeUnit.MINUTES);\n+\n+        verify(mockConsumer).accept(1L);\n+        verify(mockConsumer).accept(1017L);\n+        verify(mockConsumer).accept(2076L);\n+        verifyNoMoreInteractions(mockConsumer);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"ExecutorSubmitRunnableFutureIgnored\")\n+    public void testManyUpdatesForSameLeaders() throws InterruptedException {\n+        ExecutorService executorService = PTExecutors.newFixedThreadPool(50);\n+        int numBuckets = 100;\n+        int requestsPerBucket = 50;\n+        accumulator = new LeaderElectionDurationAccumulator(mockConsumer, numBuckets * requestsPerBucket);\n+        List<Integer> durationBuckets =\n+                IntStream.range(0, numBuckets).map(x -> x * numBuckets).boxed().collect(Collectors.toList());", "originalCommit": "ca5fa29189dde7664593bd4578da060bf71aa38f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzNDEwNQ==", "url": "https://github.com/palantir/atlasdb/pull/5088#discussion_r516834105", "bodyText": "Yes, I actually realised this when I wrote this. I suppose this is wrong if requestsPerBucket > numBuckets (which we could do), but I was thinking of having additional space (i.e. making sure to test with space). I think I'll just make this requestsPerBucket though, as it makes the logic easier.", "author": "Jolyon-S", "createdAt": "2020-11-03T17:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc5ODkxMA=="}], "type": "inlineReview"}, {"oid": "b01d63ced907d3a4a7444da336b1f711fabe9256", "url": "https://github.com/palantir/atlasdb/commit/b01d63ced907d3a4a7444da336b1f711fabe9256", "message": "fix test bug", "committedDate": "2020-11-03T17:26:10Z", "type": "commit"}]}