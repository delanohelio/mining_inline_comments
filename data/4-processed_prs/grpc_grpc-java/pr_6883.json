{"pr_number": 6883, "pr_title": "rls: lb policy config object & ChildPolicyReportingHelper", "pr_createdAt": "2020-04-01T00:46:16Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6883", "timeline": [{"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7", "url": "https://github.com/grpc/grpc-java/commit/c45c46caab0e671cffe5a4c85185a0d91e4ebcc7", "message": "rls: lb policy config object", "committedDate": "2020-04-01T00:45:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwOTQwMQ==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r408309401", "bodyText": "I don't see its entries are used in this class and I don't see any getter of it. How is this map going to be used?", "author": "dapengzhang0", "createdAt": "2020-04-14T17:26:13Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();", "originalCommit": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NDcyNA==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410394724", "bodyText": "oops, yes this is no longer used (moved to PendingCacheEntry which contains BackoffPolicy so we don't need to maintain a map). removed.", "author": "creamsoup", "createdAt": "2020-04-17T18:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwOTQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODAzOA==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r408318038", "bodyText": "Can helper be final? Is there a case it could change?", "author": "dapengzhang0", "createdAt": "2020-04-14T17:40:17Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String childPolicyConfigTargetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          childPolicyConfigTargetFieldName != null && !childPolicyConfigTargetFieldName.isEmpty(),\n+          \"childPolicyConfigTargetFieldName cannot be empty or null\");\n+      this.childPolicyConfigTargetFieldName = childPolicyConfigTargetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(\n+          effectiveChildPolicy.size() == 1,\n+          \"childPolicy should have exactly one loadbalancing policy\");\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(childPolicyConfigTargetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    void addPendingRequest(RouteLookupRequest request, BackoffPolicy backoffPolicy) {\n+      checkNotNull(request, \"request\");\n+      checkNotNull(backoffPolicy, \"backoffPolicy\");\n+      BackoffPolicy existing = pendingRequests.put(request, backoffPolicy);\n+      checkState(\n+          existing == null,\n+          \"This is a bug, there should be at most one outstanding pending request\");\n+    }\n+\n+    void removePendingRequest(RouteLookupRequest request) {\n+      BackoffPolicy policy = pendingRequests.remove(request);\n+      checkState(policy != null, \"This is a bug, untracked pending request found\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(childPolicyConfigTargetFieldName, that.childPolicyConfigTargetFieldName)\n+          && Objects.equals(pendingRequests, that.pendingRequests);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return\n+          Objects\n+              .hash(\n+                  effectiveRawChildPolicy,\n+                  effectiveLbProvider,\n+                  childPolicyConfigTargetFieldName,\n+                  pendingRequests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", childPolicyConfigTargetFieldName)\n+          .add(\"pendingRequests\", pendingRequests)\n+          .toString();\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper implements Closeable {\n+\n+    @VisibleForTesting\n+    static final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final String target;\n+    @Nullable\n+    private ChildLoadBalancingPolicy childPolicy;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+    private Helper helper;", "originalCommit": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3NTk4Nw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410375987", "bodyText": "the helper won't be changed once it is set. if we want to make it final, the caller may need to create a delegating helper (this will be next PR depends on this change) even if it will use the cached version.", "author": "creamsoup", "createdAt": "2020-04-17T17:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyMTExMg==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r408321112", "bodyText": "Can this be final? Is there a case it could change?", "author": "dapengzhang0", "createdAt": "2020-04-14T17:45:12Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String childPolicyConfigTargetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          childPolicyConfigTargetFieldName != null && !childPolicyConfigTargetFieldName.isEmpty(),\n+          \"childPolicyConfigTargetFieldName cannot be empty or null\");\n+      this.childPolicyConfigTargetFieldName = childPolicyConfigTargetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(\n+          effectiveChildPolicy.size() == 1,\n+          \"childPolicy should have exactly one loadbalancing policy\");\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(childPolicyConfigTargetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    void addPendingRequest(RouteLookupRequest request, BackoffPolicy backoffPolicy) {\n+      checkNotNull(request, \"request\");\n+      checkNotNull(backoffPolicy, \"backoffPolicy\");\n+      BackoffPolicy existing = pendingRequests.put(request, backoffPolicy);\n+      checkState(\n+          existing == null,\n+          \"This is a bug, there should be at most one outstanding pending request\");\n+    }\n+\n+    void removePendingRequest(RouteLookupRequest request) {\n+      BackoffPolicy policy = pendingRequests.remove(request);\n+      checkState(policy != null, \"This is a bug, untracked pending request found\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(childPolicyConfigTargetFieldName, that.childPolicyConfigTargetFieldName)\n+          && Objects.equals(pendingRequests, that.pendingRequests);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return\n+          Objects\n+              .hash(\n+                  effectiveRawChildPolicy,\n+                  effectiveLbProvider,\n+                  childPolicyConfigTargetFieldName,\n+                  pendingRequests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", childPolicyConfigTargetFieldName)\n+          .add(\"pendingRequests\", pendingRequests)\n+          .toString();\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper implements Closeable {\n+\n+    @VisibleForTesting\n+    static final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final String target;\n+    @Nullable\n+    private ChildLoadBalancingPolicy childPolicy;", "originalCommit": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NTgwMQ==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410385801", "bodyText": "same as helper, it is used like final but it will be set after the caller find out that it is a brand new ChildPolicyWrapper. unlike helper it doesn't create extra object. do you think it is better to pass helper and childPolicy to the factory method to make it final?", "author": "creamsoup", "createdAt": "2020-04-17T18:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyMTExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNjUzMg==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410526532", "bodyText": "Yes, it would be definitely better to make it final unless there is restriction such as the helper and childPolicy are unknown when it has to be instantiated. Would that be difficult?", "author": "dapengzhang0", "createdAt": "2020-04-18T00:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyMTExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3MzI2Mw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411573263", "bodyText": "i had to bring in the other helper due to circular dependency if it just accept helper in actual lb impl. PTAL", "author": "creamsoup", "createdAt": "2020-04-20T17:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyMTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNDQxOQ==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410404419", "bodyText": "This map is shared for the whole JVM for all channels to totally different servers. This worries me.  Also the map needs synchronization.", "author": "dapengzhang0", "createdAt": "2020-04-17T18:40:57Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String childPolicyConfigTargetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          childPolicyConfigTargetFieldName != null && !childPolicyConfigTargetFieldName.isEmpty(),\n+          \"childPolicyConfigTargetFieldName cannot be empty or null\");\n+      this.childPolicyConfigTargetFieldName = childPolicyConfigTargetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(\n+          effectiveChildPolicy.size() == 1,\n+          \"childPolicy should have exactly one loadbalancing policy\");\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(childPolicyConfigTargetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    void addPendingRequest(RouteLookupRequest request, BackoffPolicy backoffPolicy) {\n+      checkNotNull(request, \"request\");\n+      checkNotNull(backoffPolicy, \"backoffPolicy\");\n+      BackoffPolicy existing = pendingRequests.put(request, backoffPolicy);\n+      checkState(\n+          existing == null,\n+          \"This is a bug, there should be at most one outstanding pending request\");\n+    }\n+\n+    void removePendingRequest(RouteLookupRequest request) {\n+      BackoffPolicy policy = pendingRequests.remove(request);\n+      checkState(policy != null, \"This is a bug, untracked pending request found\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(childPolicyConfigTargetFieldName, that.childPolicyConfigTargetFieldName)\n+          && Objects.equals(pendingRequests, that.pendingRequests);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return\n+          Objects\n+              .hash(\n+                  effectiveRawChildPolicy,\n+                  effectiveLbProvider,\n+                  childPolicyConfigTargetFieldName,\n+                  pendingRequests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", childPolicyConfigTargetFieldName)\n+          .add(\"pendingRequests\", pendingRequests)\n+          .toString();\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper implements Closeable {\n+\n+    @VisibleForTesting\n+    static final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =", "originalCommit": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwODc3MQ==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410508771", "bodyText": "yes target can be same. good catch. i refactored out this factory part. it is not globally shared, i didn't add any synchronization. future implementation always call it with lock if this can justify it.", "author": "creamsoup", "createdAt": "2020-04-17T23:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNDQxOQ=="}], "type": "inlineReview"}, {"oid": "e921201ca04cda85979dd0fa0b0dfb478a3a4eae", "url": "https://github.com/grpc/grpc-java/commit/e921201ca04cda85979dd0fa0b0dfb478a3a4eae", "message": "remove pending, rename some variables", "committedDate": "2020-04-17T20:21:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTc5NA==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410471794", "bodyText": "Seems you can just implement LrsLoadBalancerProvider.parseLoadBalancingPolicyConfig() by merging master.  Return ConfigOrError instead of throw.", "author": "dapengzhang0", "createdAt": "2020-04-17T21:10:45Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(", "originalCommit": "e921201ca04cda85979dd0fa0b0dfb478a3a4eae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwODYzOQ==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410508639", "bodyText": "discussed offline, the RlsLbProvider.parseLoadBalancingPolicyConfig() has more logic than just parsing ChildLoadBalancingPolicy. to imply the parsing can be fail, it will throw checked exception.", "author": "creamsoup", "createdAt": "2020-04-17T23:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTc5NA=="}], "type": "inlineReview"}, {"oid": "e4b4a9a655f02e092524df8c5dcf1207d99ec2f7", "url": "https://github.com/grpc/grpc-java/commit/e4b4a9a655f02e092524df8c5dcf1207d99ec2f7", "message": "use checked exception in create", "committedDate": "2020-04-17T23:08:10Z", "type": "commit"}, {"oid": "e278b51935d34805c661a6469b30e6f2fff6fefe", "url": "https://github.com/grpc/grpc-java/commit/e278b51935d34805c661a6469b30e6f2fff6fefe", "message": "Merge branch 'master' into rls_objects", "committedDate": "2020-04-18T00:21:24Z", "type": "commit"}, {"oid": "5c9f7462b2f026de9b7a90ffe524556263a08f4c", "url": "https://github.com/grpc/grpc-java/commit/5c9f7462b2f026de9b7a90ffe524556263a08f4c", "message": "Merge remote-tracking branch 'upstream/master' into rls_objects", "committedDate": "2020-04-18T00:21:31Z", "type": "commit"}, {"oid": "937c8bb0f876813c07ce75ef5d14717d90e6c52e", "url": "https://github.com/grpc/grpc-java/commit/937c8bb0f876813c07ce75ef5d14717d90e6c52e", "message": "move factory method out of ChildPolicyWrapper", "committedDate": "2020-04-18T00:26:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNzAxMQ==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410527011", "bodyText": "Maybe you can turn off writableStackTrace.", "author": "dapengzhang0", "createdAt": "2020-04-18T00:47:23Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -344,4 +348,14 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  /** Exception thrown when attempting to parse child policy encountered parsing issue. */\n+  public static final class InvalidChildPolicyConfigException extends Exception {\n+\n+    private static final long serialVersionUID = 0L;\n+\n+    public InvalidChildPolicyConfigException(String message) {\n+      super(message);", "originalCommit": "e4b4a9a655f02e092524df8c5dcf1207d99ec2f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA0MjgyMw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411042823", "bodyText": "done.", "author": "creamsoup", "createdAt": "2020-04-20T01:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNzAxMQ=="}], "type": "inlineReview"}, {"oid": "e1a50f36daf6410adb94bdfb36224265696407fa", "url": "https://github.com/grpc/grpc-java/commit/e1a50f36daf6410adb94bdfb36224265696407fa", "message": "make exception stackless", "committedDate": "2020-04-20T01:50:30Z", "type": "commit"}, {"oid": "527cd1198e09f7c85b524e266120ce574f040843", "url": "https://github.com/grpc/grpc-java/commit/527cd1198e09f7c85b524e266120ce574f040843", "message": "move helper creation to factory", "committedDate": "2020-04-20T17:54:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDQyNw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411720427", "bodyText": "What's the expected usecase here? getObject() once and returnObject() twice()?", "author": "dapengzhang0", "createdAt": "2020-04-20T21:58:43Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.ChildPolicyReportingHelper.ChildLbStatusListener;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName, List<Map<String, ?>> childPolicies)\n+        throws InvalidChildPolicyConfigException {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        if (childPolicy.size() != 1) {\n+          throw\n+              new InvalidChildPolicyConfigException(\n+                  \"childPolicy should have exactly one loadbalancing policy\");\n+        }\n+        String policyName = childPolicy.keySet().iterator().next();\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      if (effectiveChildPolicy == null) {\n+        throw\n+            new InvalidChildPolicyConfigException(\n+                String.format(\"no valid childPolicy found, policy tried: %s\", policyTried));\n+      }\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(targetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(targetFieldName, that.targetFieldName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(effectiveRawChildPolicy, effectiveLbProvider, targetFieldName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", targetFieldName)\n+          .toString();\n+    }\n+  }\n+\n+  /** Factory for {@link ChildPolicyWrapper}. */\n+  static final class RefCountedChildPolicyWrapperFactory {\n+    @VisibleForTesting\n+    final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final ChildLoadBalancerHelperProvider childLbHelperProvider;\n+    @Nullable\n+    private final ChildLbStatusListener childLbStatusListener;\n+\n+    public RefCountedChildPolicyWrapperFactory(\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable ChildLbStatusListener childLbStatusListener) {\n+      this.childLbHelperProvider = checkNotNull(childLbHelperProvider, \"childLbHelperProvider\");\n+      this.childLbStatusListener = childLbStatusListener;\n+    }\n+\n+    ChildPolicyWrapper createOrGet(String target) {\n+      // TODO(creamsoup) check if the target is valid or not\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      if (existing != null) {\n+        return existing.getObject();\n+      }\n+      ChildPolicyWrapper childPolicyWrapper =\n+          new ChildPolicyWrapper(target, childLbHelperProvider, childLbStatusListener);\n+      RefCountedChildPolicyWrapper wrapper = RefCountedChildPolicyWrapper.of(childPolicyWrapper);\n+      childPolicyMap.put(target, wrapper);\n+      return childPolicyWrapper;\n+    }\n+\n+    void release(ChildPolicyWrapper childPolicyWrapper) {\n+      checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+      String target = childPolicyWrapper.getTarget();\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      checkState(existing != null, \"Cannot access already released object\");\n+      if (existing.returnObject(childPolicyWrapper) == null) {\n+        childPolicyMap.remove(target);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper {\n+\n+    private final String target;\n+    private final ChildPolicyReportingHelper helper;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+\n+    public ChildPolicyWrapper(\n+        String target,\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable  ChildLbStatusListener childLbStatusListener) {\n+      this.target = target;\n+      this.helper =\n+          new ChildPolicyReportingHelper(childLbHelperProvider, this, childLbStatusListener);\n+    }\n+\n+    String getTarget() {\n+      return target;\n+    }\n+\n+    void setPicker(SubchannelPicker picker) {\n+      this.picker = checkNotNull(picker, \"picker\");\n+    }\n+\n+    SubchannelPicker getPicker() {\n+      return picker;\n+    }\n+\n+    ChildPolicyReportingHelper getHelper() {\n+      return helper;\n+    }\n+\n+    void setConnectivityStateInfo(ConnectivityStateInfo connectivityStateInfo) {\n+      this.connectivityStateInfo = connectivityStateInfo;\n+    }\n+\n+    ConnectivityStateInfo getConnectivityStateInfo() {\n+      return connectivityStateInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildPolicyWrapper that = (ChildPolicyWrapper) o;\n+      return Objects.equals(target, that.target)\n+          && Objects.equals(helper, that.helper)\n+          && Objects.equals(connectivityStateInfo, that.connectivityStateInfo)\n+          && Objects.equals(picker, that.picker);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(target, helper, connectivityStateInfo, picker);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"target\", target)\n+          .add(\"helper\", helper)\n+          .add(\"connectivityStateInfo\", connectivityStateInfo)\n+          .add(\"picker\", picker)\n+          .toString();\n+    }\n+  }\n+\n+  private static final class RefCountedChildPolicyWrapper\n+      implements ObjectPool<ChildPolicyWrapper> {\n+\n+    private final AtomicLong refCnt = new AtomicLong(1);\n+    @Nullable\n+    private ChildPolicyWrapper childPolicyWrapper;\n+\n+    private RefCountedChildPolicyWrapper(ChildPolicyWrapper childPolicyWrapper) {\n+      this.childPolicyWrapper = checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+    }\n+\n+    @Override\n+    public ChildPolicyWrapper getObject() {\n+      long curr = refCnt.getAndIncrement();\n+      if (curr <= 0) {\n+        throw new IllegalStateException(\"ChildPolicyWrapper is already released\");\n+      }\n+      return childPolicyWrapper;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ChildPolicyWrapper returnObject(Object object) {\n+      checkState(\n+          childPolicyWrapper == object,\n+          \"returned object doesn't match the pooled childPolicyWrapper\");\n+      long newCnt = refCnt.decrementAndGet();\n+      if (newCnt == 0) {", "originalCommit": "527cd1198e09f7c85b524e266120ce574f040843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NTIzOQ==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411745239", "bodyText": "this handles when the object is just released, free up the reference.", "author": "creamsoup", "createdAt": "2020-04-20T22:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MDI2Ng==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411750266", "bodyText": "If you call x times getObject(), you need call x+1 times of returnObject() to get here, is that the contract?", "author": "dapengzhang0", "createdAt": "2020-04-20T23:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MTY2MA==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411751660", "bodyText": "create itself is counted as getObject() since the object is passed in.", "author": "creamsoup", "createdAt": "2020-04-20T23:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MzI5Ng==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411753296", "bodyText": "create itself is counted as getObject()\n\nBut you can not use the object unless you call getObject() explicitly.  The API contract looks strange.  If you just need to use the object once, you have to explicitly call  getObject() once, and you need returnObject() twice to get here.", "author": "dapengzhang0", "createdAt": "2020-04-20T23:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2Mjc0NA==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411762744", "bodyText": "why it cannot use the object before getObject()? anyways, okay it depends on what is the focus. focused more on the \"RefCounted\" it makes more sense to have it as 1, if you focused more on \"ObjectPool\" part starting with 0 makes more sense. refCount = 0 is released state (ref counted bytebuf starts with 1 for example), but for the sake of consistency i can follow the other convention, also it implements ObjectPool makes me leaning toward that.", "author": "creamsoup", "createdAt": "2020-04-20T23:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2ODEzNw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411768137", "bodyText": "I see, it is used directly for the first time without calling getObject()\nRefCountedChildPolicyWrapper wrapper = RefCountedChildPolicyWrapper.of(childPolicyWrapper);\nchildPolicyMap.put(target, wrapper);\nreturn childPolicyWrapper;", "author": "dapengzhang0", "createdAt": "2020-04-20T23:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDUxMw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411720513", "bodyText": "This circular dependency looks weird, because ChildPolicyWrapper is consumed by new ChildPolicyReportingHelper() before instantiation is complete.\nThe two classes are tightly coupled. Making ChildPolicyReportingHelper an inner (non-static) class of ChildPolicyWrapper might be more natural.", "author": "dapengzhang0", "createdAt": "2020-04-20T21:58:51Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.ChildPolicyReportingHelper.ChildLbStatusListener;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName, List<Map<String, ?>> childPolicies)\n+        throws InvalidChildPolicyConfigException {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        if (childPolicy.size() != 1) {\n+          throw\n+              new InvalidChildPolicyConfigException(\n+                  \"childPolicy should have exactly one loadbalancing policy\");\n+        }\n+        String policyName = childPolicy.keySet().iterator().next();\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      if (effectiveChildPolicy == null) {\n+        throw\n+            new InvalidChildPolicyConfigException(\n+                String.format(\"no valid childPolicy found, policy tried: %s\", policyTried));\n+      }\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(targetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(targetFieldName, that.targetFieldName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(effectiveRawChildPolicy, effectiveLbProvider, targetFieldName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", targetFieldName)\n+          .toString();\n+    }\n+  }\n+\n+  /** Factory for {@link ChildPolicyWrapper}. */\n+  static final class RefCountedChildPolicyWrapperFactory {\n+    @VisibleForTesting\n+    final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final ChildLoadBalancerHelperProvider childLbHelperProvider;\n+    @Nullable\n+    private final ChildLbStatusListener childLbStatusListener;\n+\n+    public RefCountedChildPolicyWrapperFactory(\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable ChildLbStatusListener childLbStatusListener) {\n+      this.childLbHelperProvider = checkNotNull(childLbHelperProvider, \"childLbHelperProvider\");\n+      this.childLbStatusListener = childLbStatusListener;\n+    }\n+\n+    ChildPolicyWrapper createOrGet(String target) {\n+      // TODO(creamsoup) check if the target is valid or not\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      if (existing != null) {\n+        return existing.getObject();\n+      }\n+      ChildPolicyWrapper childPolicyWrapper =\n+          new ChildPolicyWrapper(target, childLbHelperProvider, childLbStatusListener);\n+      RefCountedChildPolicyWrapper wrapper = RefCountedChildPolicyWrapper.of(childPolicyWrapper);\n+      childPolicyMap.put(target, wrapper);\n+      return childPolicyWrapper;\n+    }\n+\n+    void release(ChildPolicyWrapper childPolicyWrapper) {\n+      checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+      String target = childPolicyWrapper.getTarget();\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      checkState(existing != null, \"Cannot access already released object\");\n+      if (existing.returnObject(childPolicyWrapper) == null) {\n+        childPolicyMap.remove(target);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper {\n+\n+    private final String target;\n+    private final ChildPolicyReportingHelper helper;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+\n+    public ChildPolicyWrapper(\n+        String target,\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable  ChildLbStatusListener childLbStatusListener) {\n+      this.target = target;\n+      this.helper =\n+          new ChildPolicyReportingHelper(childLbHelperProvider, this, childLbStatusListener);", "originalCommit": "527cd1198e09f7c85b524e266120ce574f040843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NTA1Mw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411745053", "bodyText": "yes i was wondering same thing.", "author": "creamsoup", "createdAt": "2020-04-20T22:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDc1Mw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411720753", "bodyText": "Not used?", "author": "dapengzhang0", "createdAt": "2020-04-20T21:59:25Z", "path": "rls/src/main/java/io/grpc/rls/internal/ChildPolicyReportingHelper.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.LbPolicyConfiguration.ChildPolicyWrapper;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.ForwardingSubchannel;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A delegating {@link io.grpc.LoadBalancer.Helper} maintains status of {@link ChildPolicyWrapper}\n+ * when {@link Subchannel} status changed. This helper is used between child policy and parent\n+ * load-balancer where each picker in child policy is governed by a governing picker (RlsPicker).\n+ * The governing picker will be reported back to the parent load-balancer.\n+ */\n+final class ChildPolicyReportingHelper extends ForwardingLoadBalancerHelper {\n+\n+  private final ChildLoadBalancerHelper delegate;\n+  private final ChildPolicyWrapper childPolicyWrapper;\n+  @Nullable\n+  private final ChildLbStatusListener listener;\n+\n+  ChildPolicyReportingHelper(", "originalCommit": "527cd1198e09f7c85b524e266120ce574f040843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczOTM3Mg==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411739372", "bodyText": "not used yet. this will be used by fallback channel.", "author": "creamsoup", "createdAt": "2020-04-20T22:40:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDc1Mw=="}], "type": "inlineReview"}, {"oid": "988839c19922127432e00466f8c391d5347f9b56", "url": "https://github.com/grpc/grpc-java/commit/988839c19922127432e00466f8c391d5347f9b56", "message": "make helper inner class", "committedDate": "2020-04-20T23:00:15Z", "type": "commit"}, {"oid": "cd6e862613e19424fc5f02597ae5d7e2acefa4c1", "url": "https://github.com/grpc/grpc-java/commit/cd6e862613e19424fc5f02597ae5d7e2acefa4c1", "message": "add check already released", "committedDate": "2020-04-20T23:11:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDA5MA==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411754090", "bodyText": "There is extra space.", "author": "dapengzhang0", "createdAt": "2020-04-20T23:16:03Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.LbPolicyConfiguration.ChildPolicyWrapper.ChildLbStatusListener;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.ForwardingSubchannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName, List<Map<String, ?>> childPolicies)\n+        throws InvalidChildPolicyConfigException {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        if (childPolicy.size() != 1) {\n+          throw\n+              new InvalidChildPolicyConfigException(\n+                  \"childPolicy should have exactly one loadbalancing policy\");\n+        }\n+        String policyName = childPolicy.keySet().iterator().next();\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      if (effectiveChildPolicy == null) {\n+        throw\n+            new InvalidChildPolicyConfigException(\n+                String.format(\"no valid childPolicy found, policy tried: %s\", policyTried));\n+      }\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(targetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(targetFieldName, that.targetFieldName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(effectiveRawChildPolicy, effectiveLbProvider, targetFieldName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", targetFieldName)\n+          .toString();\n+    }\n+  }\n+\n+  /** Factory for {@link ChildPolicyWrapper}. */\n+  static final class RefCountedChildPolicyWrapperFactory {\n+    @VisibleForTesting\n+    final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final ChildLoadBalancerHelperProvider childLbHelperProvider;\n+    @Nullable\n+    private final ChildLbStatusListener childLbStatusListener;\n+\n+    public RefCountedChildPolicyWrapperFactory(\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable ChildLbStatusListener childLbStatusListener) {\n+      this.childLbHelperProvider = checkNotNull(childLbHelperProvider, \"childLbHelperProvider\");\n+      this.childLbStatusListener = childLbStatusListener;\n+    }\n+\n+    ChildPolicyWrapper createOrGet(String target) {\n+      // TODO(creamsoup) check if the target is valid or not\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      if (existing != null) {\n+        return existing.getObject();\n+      }\n+      ChildPolicyWrapper childPolicyWrapper =\n+          new ChildPolicyWrapper(target, childLbHelperProvider, childLbStatusListener);\n+      RefCountedChildPolicyWrapper wrapper = RefCountedChildPolicyWrapper.of(childPolicyWrapper);\n+      childPolicyMap.put(target, wrapper);\n+      return childPolicyWrapper;\n+    }\n+\n+    void release(ChildPolicyWrapper childPolicyWrapper) {\n+      checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+      String target = childPolicyWrapper.getTarget();\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      checkState(existing != null, \"Cannot access already released object\");\n+      if (existing.returnObject(childPolicyWrapper) == null) {\n+        childPolicyMap.remove(target);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper {\n+\n+    private final String target;\n+    private final ChildPolicyReportingHelper helper;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+\n+    public ChildPolicyWrapper(\n+        String target,\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable  ChildLbStatusListener childLbStatusListener) {", "originalCommit": "cd6e862613e19424fc5f02597ae5d7e2acefa4c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2NzU1Nw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411767557", "bodyText": "good catch!", "author": "creamsoup", "createdAt": "2020-04-20T23:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDMwNA==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411754304", "bodyText": "nit: The listener interface is nested too deep. Can be one level up.", "author": "dapengzhang0", "createdAt": "2020-04-20T23:16:37Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.LbPolicyConfiguration.ChildPolicyWrapper.ChildLbStatusListener;", "originalCommit": "cd6e862613e19424fc5f02597ae5d7e2acefa4c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2ODgyOQ==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411768829", "bodyText": "done.", "author": "creamsoup", "createdAt": "2020-04-20T23:50:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NjE4Nw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411756187", "bodyText": "This API should always return null.\nhttps://github.com/grpc/grpc-java/blob/v1.28.1/core/src/main/java/io/grpc/internal/ObjectPool.java#L32-L36", "author": "dapengzhang0", "createdAt": "2020-04-20T23:21:54Z", "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.LbPolicyConfiguration.ChildPolicyWrapper.ChildLbStatusListener;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.ForwardingSubchannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName, List<Map<String, ?>> childPolicies)\n+        throws InvalidChildPolicyConfigException {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        if (childPolicy.size() != 1) {\n+          throw\n+              new InvalidChildPolicyConfigException(\n+                  \"childPolicy should have exactly one loadbalancing policy\");\n+        }\n+        String policyName = childPolicy.keySet().iterator().next();\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      if (effectiveChildPolicy == null) {\n+        throw\n+            new InvalidChildPolicyConfigException(\n+                String.format(\"no valid childPolicy found, policy tried: %s\", policyTried));\n+      }\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(targetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(targetFieldName, that.targetFieldName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(effectiveRawChildPolicy, effectiveLbProvider, targetFieldName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", targetFieldName)\n+          .toString();\n+    }\n+  }\n+\n+  /** Factory for {@link ChildPolicyWrapper}. */\n+  static final class RefCountedChildPolicyWrapperFactory {\n+    @VisibleForTesting\n+    final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final ChildLoadBalancerHelperProvider childLbHelperProvider;\n+    @Nullable\n+    private final ChildLbStatusListener childLbStatusListener;\n+\n+    public RefCountedChildPolicyWrapperFactory(\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable ChildLbStatusListener childLbStatusListener) {\n+      this.childLbHelperProvider = checkNotNull(childLbHelperProvider, \"childLbHelperProvider\");\n+      this.childLbStatusListener = childLbStatusListener;\n+    }\n+\n+    ChildPolicyWrapper createOrGet(String target) {\n+      // TODO(creamsoup) check if the target is valid or not\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      if (existing != null) {\n+        return existing.getObject();\n+      }\n+      ChildPolicyWrapper childPolicyWrapper =\n+          new ChildPolicyWrapper(target, childLbHelperProvider, childLbStatusListener);\n+      RefCountedChildPolicyWrapper wrapper = RefCountedChildPolicyWrapper.of(childPolicyWrapper);\n+      childPolicyMap.put(target, wrapper);\n+      return childPolicyWrapper;\n+    }\n+\n+    void release(ChildPolicyWrapper childPolicyWrapper) {\n+      checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+      String target = childPolicyWrapper.getTarget();\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      checkState(existing != null, \"Cannot access already released object\");\n+      if (existing.returnObject(childPolicyWrapper) == null) {\n+        childPolicyMap.remove(target);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper {\n+\n+    private final String target;\n+    private final ChildPolicyReportingHelper helper;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+\n+    public ChildPolicyWrapper(\n+        String target,\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable  ChildLbStatusListener childLbStatusListener) {\n+      this.target = target;\n+      this.helper =\n+          new ChildPolicyReportingHelper(childLbHelperProvider, childLbStatusListener);\n+    }\n+\n+    String getTarget() {\n+      return target;\n+    }\n+\n+    void setPicker(SubchannelPicker picker) {\n+      this.picker = checkNotNull(picker, \"picker\");\n+    }\n+\n+    SubchannelPicker getPicker() {\n+      return picker;\n+    }\n+\n+    ChildPolicyReportingHelper getHelper() {\n+      return helper;\n+    }\n+\n+    void setConnectivityStateInfo(ConnectivityStateInfo connectivityStateInfo) {\n+      this.connectivityStateInfo = connectivityStateInfo;\n+    }\n+\n+    ConnectivityStateInfo getConnectivityStateInfo() {\n+      return connectivityStateInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildPolicyWrapper that = (ChildPolicyWrapper) o;\n+      return Objects.equals(target, that.target)\n+          && Objects.equals(helper, that.helper)\n+          && Objects.equals(connectivityStateInfo, that.connectivityStateInfo)\n+          && Objects.equals(picker, that.picker);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(target, helper, connectivityStateInfo, picker);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"target\", target)\n+          .add(\"helper\", helper)\n+          .add(\"connectivityStateInfo\", connectivityStateInfo)\n+          .add(\"picker\", picker)\n+          .toString();\n+    }\n+\n+    /**\n+     * A delegating {@link io.grpc.LoadBalancer.Helper} maintains status of {@link\n+     * ChildPolicyWrapper} when {@link Subchannel} status changed. This helper is used between child\n+     * policy and parent load-balancer where each picker in child policy is governed by a governing\n+     * picker (RlsPicker). The governing picker will be reported back to the parent load-balancer.\n+     */\n+    final class ChildPolicyReportingHelper extends ForwardingLoadBalancerHelper {\n+\n+      private final ChildLoadBalancerHelper delegate;\n+      @Nullable\n+      private final ChildLbStatusListener listener;\n+\n+      ChildPolicyReportingHelper(ChildLoadBalancerHelperProvider childHelperProvider) {\n+        this(childHelperProvider, null);\n+      }\n+\n+      ChildPolicyReportingHelper(\n+          ChildLoadBalancerHelperProvider childHelperProvider,\n+          @Nullable ChildLbStatusListener listener) {\n+        checkNotNull(childHelperProvider, \"childHelperProvider\");\n+        this.delegate = childHelperProvider.forTarget(getTarget());\n+        this.listener = listener;\n+      }\n+\n+      @Override\n+      protected Helper delegate() {\n+        return delegate;\n+      }\n+\n+      @Override\n+      public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+        setPicker(newPicker);\n+        super.updateBalancingState(newState, newPicker);\n+        if (listener != null) {\n+          listener.onStatusChanged(newState);\n+        }\n+      }\n+\n+      @Override\n+      public Subchannel createSubchannel(CreateSubchannelArgs args) {\n+        final Subchannel subchannel = super.createSubchannel(args);\n+        return new ForwardingSubchannel() {\n+          @Override\n+          protected Subchannel delegate() {\n+            return subchannel;\n+          }\n+\n+          @Override\n+          public void start(final SubchannelStateListener listener) {\n+            super.start(new SubchannelStateListener() {\n+              @Override\n+              public void onSubchannelState(ConnectivityStateInfo newState) {\n+                setConnectivityStateInfo(newState);\n+                listener.onSubchannelState(newState);\n+              }\n+            });\n+          }\n+        };\n+      }\n+    }\n+\n+    /** Listener for child lb status change events. */\n+    interface ChildLbStatusListener {\n+\n+      /** Notifies when child lb status changes. */\n+      void onStatusChanged(ConnectivityState newState);\n+    }\n+  }\n+\n+  private static final class RefCountedChildPolicyWrapper\n+      implements ObjectPool<ChildPolicyWrapper> {\n+\n+    private final AtomicLong refCnt = new AtomicLong(1);\n+    @Nullable\n+    private ChildPolicyWrapper childPolicyWrapper;\n+\n+    private RefCountedChildPolicyWrapper(ChildPolicyWrapper childPolicyWrapper) {\n+      this.childPolicyWrapper = checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+    }\n+\n+    @Override\n+    public ChildPolicyWrapper getObject() {\n+      long curr = refCnt.getAndIncrement();\n+      if (curr <= 0) {\n+        throw new IllegalStateException(\"ChildPolicyWrapper is already released\");\n+      }\n+      return childPolicyWrapper;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ChildPolicyWrapper returnObject(Object object) {\n+      checkState(\n+          childPolicyWrapper != null,\n+          \"cannot return already released ChildPolicyWrapper, this is possibly a bug.\");\n+      checkState(\n+          childPolicyWrapper == object,\n+          \"returned object doesn't match the pooled childPolicyWrapper\");\n+      long newCnt = refCnt.decrementAndGet();\n+      if (newCnt == 0) {\n+        childPolicyWrapper = null;\n+      }\n+      return childPolicyWrapper;", "originalCommit": "cd6e862613e19424fc5f02597ae5d7e2acefa4c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3MTUyMA==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411771520", "bodyText": "Might need introduce something like isReleased()", "author": "dapengzhang0", "createdAt": "2020-04-20T23:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NjE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NjQ5Mw==", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411776493", "bodyText": "tried to avoid additional check, but this sounds better.", "author": "creamsoup", "createdAt": "2020-04-21T00:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NjE4Nw=="}], "type": "inlineReview"}, {"oid": "a2b4040d78dfaa64869e23f84d8332104812a985", "url": "https://github.com/grpc/grpc-java/commit/a2b4040d78dfaa64869e23f84d8332104812a985", "message": "ref count start from 0", "committedDate": "2020-04-20T23:52:26Z", "type": "commit"}, {"oid": "9d31b8b0ac9551c4d0d45d4571c881b0eab22d08", "url": "https://github.com/grpc/grpc-java/commit/9d31b8b0ac9551c4d0d45d4571c881b0eab22d08", "message": "remove space, move listener up", "committedDate": "2020-04-20T23:56:55Z", "type": "commit"}, {"oid": "e170906d94f7c5a23d9a67421458e0c7163e1794", "url": "https://github.com/grpc/grpc-java/commit/e170906d94f7c5a23d9a67421458e0c7163e1794", "message": "make objectpool non static, make returnObject returns null", "committedDate": "2020-04-21T00:06:15Z", "type": "commit"}, {"oid": "09363bcf45674856772d344fe429ff77a0272d0b", "url": "https://github.com/grpc/grpc-java/commit/09363bcf45674856772d344fe429ff77a0272d0b", "message": "Revert \"make objectpool non static, make returnObject returns null\"\n\nThis reverts commit e170906d94f7c5a23d9a67421458e0c7163e1794.", "committedDate": "2020-04-21T00:14:39Z", "type": "commit"}, {"oid": "6f52bc3b751bd3da53b85de7172f0f04bb0f376e", "url": "https://github.com/grpc/grpc-java/commit/6f52bc3b751bd3da53b85de7172f0f04bb0f376e", "message": "add isReleased to pool", "committedDate": "2020-04-21T00:18:04Z", "type": "commit"}]}