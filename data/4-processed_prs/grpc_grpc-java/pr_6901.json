{"pr_number": 6901, "pr_title": "xds: eliminate downstreamTlsContext from XdsServerBuilder", "pr_createdAt": "2020-04-05T18:29:33Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6901", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0Njc2Mw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404246763", "bodyText": "can you make it branched? it is hard to tell what is modified.", "author": "creamsoup", "createdAt": "2020-04-06T17:00:03Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMwNDgwMQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404304801", "bodyText": "What is \"branched\" ?\nI agree it is hard - git knows the file has moved but can't show the diff in this UI", "author": "sanjaypujare", "createdAt": "2020-04-06T18:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0Njc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NTI2Ng==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404365266", "bodyText": "i thought git can track renamed file. i am not sure it is github or file modified too much?", "author": "creamsoup", "createdAt": "2020-04-06T20:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0Njc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzNDU5Ng==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404934596", "bodyText": "still waiting for the \"branched\" explanation..", "author": "sanjaypujare", "createdAt": "2020-04-07T16:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0Njc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE3MTMwOQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405171309", "bodyText": "For some reason I cannot comment on your other comment: at the time of first checkin git knows the file has been moved as it shows this:\ngit status\nOn branch xds-server-test\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\trenamed:    xds/src/test/java/io/grpc/xds/internal/sds/XdsSdsClientServerTest.java -> xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java\n...\n\nBut if you do a git log for that commit it shows delete and add of 2 different files:\nxds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java                          | 224 +++++++++++++++++++++++++++++++++++++++++++++\nxds/src/test/java/io/grpc/xds/internal/sds/XdsSdsClientServerTest.java             | 193 --------------------------------------\n\nUnless you have an idea how to fix it, I am going to resolve this comment", "author": "sanjaypujare", "createdAt": "2020-04-07T23:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0Njc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE3MzE0OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405173149", "bodyText": "don't worry about it. i reviewed the file anyways.", "author": "creamsoup", "createdAt": "2020-04-07T23:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0Njc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1Mjc5Mw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404252793", "bodyText": "seems like wrong indentation", "author": "creamsoup", "createdAt": "2020-04-06T17:09:26Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/SdsProtocolNegotiatorsTest.java", "diffHunk": "@@ -217,7 +231,7 @@ public void serverSdsHandler_addLast() throws IOException {\n   @Test\n   public void serverSdsHandler_nullTlsContext_expectPlaintext() throws IOException {\n     SdsProtocolNegotiators.HandlerPickerHandler handlerPickerHandler =\n-            new SdsProtocolNegotiators.HandlerPickerHandler(grpcHandler, null, null);\n+            new SdsProtocolNegotiators.HandlerPickerHandler(grpcHandler, null);", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1MzUwNQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404253505", "bodyText": "this is getting disorganized, can you make a utility class including other public methods used in multiple tests?", "author": "creamsoup", "createdAt": "2020-04-06T17:10:39Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/SecretVolumeSslContextProviderTest.java", "diffHunk": "@@ -43,11 +43,11 @@\n @RunWith(JUnit4.class)\n public class SecretVolumeSslContextProviderTest {\n \n-  private static final String SERVER_1_PEM_FILE = \"server1.pem\";\n-  private static final String SERVER_1_KEY_FILE = \"server1.key\";\n-  private static final String CLIENT_PEM_FILE = \"client.pem\";\n-  private static final String CLIENT_KEY_FILE = \"client.key\";\n-  private static final String CA_PEM_FILE = \"ca.pem\";\n+  public static final String SERVER_1_PEM_FILE = \"server1.pem\";", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMwNTU0OA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404305548", "bodyText": "I agree there are too many places defining the same thing. If I do that in this PR it will pull in too many files in this PR. See my comments elsewhere.", "author": "sanjaypujare", "createdAt": "2020-04-06T18:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1MzUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2NTU5OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404465599", "bodyText": "Assuming you are okay with adding other changes to this PR I will move this stuff to the utility class.", "author": "sanjaypujare", "createdAt": "2020-04-07T00:23:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1MzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1NzcyMg==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404257722", "bodyText": "@Nullable to params?", "author": "creamsoup", "createdAt": "2020-04-06T17:17:24Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/SecretVolumeSslContextProviderTest.java", "diffHunk": "@@ -430,6 +434,19 @@ static DownstreamTlsContext buildDownstreamTlsContextFromFilenames(\n    */\n   public static UpstreamTlsContext buildUpstreamTlsContextFromFilenames(\n       String privateKey, String certChain, String trustCa) {\n+    try {\n+      if (certChain != null) {", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1ODUzMA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404258530", "bodyText": "passNull? what is null?", "author": "creamsoup", "createdAt": "2020-04-06T17:18:41Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/SdsProtocolNegotiatorsTest.java", "diffHunk": "@@ -261,8 +275,7 @@ public void clientSdsProtocolNegotiatorNewHandler_fireProtocolNegotiationEvent()\n   @Test\n   public void serverSdsProtocolNegotiator_passNulls_expectPlaintext() {", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4NzkwNg==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404487906", "bodyText": "renamed to say \"nullSyncContext\"", "author": "sanjaypujare", "createdAt": "2020-04-07T01:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1ODUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1OTU3Ng==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404259576", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"Setting myListener from ConfigUpdate listener :{0}\",\n          \n          \n            \n                        \"Setting myListener from ConfigUpdate listener: {0}\",", "author": "creamsoup", "createdAt": "2020-04-06T17:20:27Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -106,29 +107,28 @@ public static XdsClientWrapperForServerSds newInstance(\n     this.port = port;\n     this.xdsClient = xdsClient;\n     this.timeService = timeService;\n-    xdsClient.watchListenerData(\n-        port,\n-        new XdsClient.ListenerWatcher() {\n-          @Override\n-          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n-            logger.log(\n-                Level.INFO,\n-                \"Setting myListener from ConfigUpdate listener :{0}\",\n-                update.getListener().toString());\n-            curListener = update.getListener();\n-          }\n+    this.listenerWatcher = new XdsClient.ListenerWatcher() {\n+      @Override\n+      public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+        logger.log(\n+            Level.INFO,\n+            \"Setting myListener from ConfigUpdate listener :{0}\",", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1OTY2MQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404259661", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n          \n          \n            \n                    logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds: {0}\", error);", "author": "creamsoup", "createdAt": "2020-04-06T17:20:36Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -106,29 +107,28 @@ public static XdsClientWrapperForServerSds newInstance(\n     this.port = port;\n     this.xdsClient = xdsClient;\n     this.timeService = timeService;\n-    xdsClient.watchListenerData(\n-        port,\n-        new XdsClient.ListenerWatcher() {\n-          @Override\n-          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n-            logger.log(\n-                Level.INFO,\n-                \"Setting myListener from ConfigUpdate listener :{0}\",\n-                update.getListener().toString());\n-            curListener = update.getListener();\n-          }\n+    this.listenerWatcher = new XdsClient.ListenerWatcher() {\n+      @Override\n+      public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+        logger.log(\n+            Level.INFO,\n+            \"Setting myListener from ConfigUpdate listener :{0}\",\n+            update.getListener().toString());\n+        curListener = update.getListener();\n+      }\n \n-          @Override\n-          public void onError(Status error) {\n-            // In order to distinguish between IO error and resource not found, set curListener\n-            // to null in case of NOT_FOUND\n-            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n-              curListener = null;\n-            }\n-            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n-            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n-          }\n-        });\n+      @Override\n+      public void onError(Status error) {\n+        // In order to distinguish between IO error and resource not found, set curListener\n+        // to null in case of NOT_FOUND\n+        if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+          curListener = null;\n+        }\n+        // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+        logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2MDA4Ng==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404260086", "bodyText": "this looks like it can be 1 line.", "author": "creamsoup", "createdAt": "2020-04-06T17:21:19Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/XdsServerBuilder.java", "diffHunk": "@@ -174,7 +161,7 @@ void panic(final Throwable t) {\n           });\n     InternalProtocolNegotiator.ProtocolNegotiator serverProtocolNegotiator =\n         SdsProtocolNegotiators.serverProtocolNegotiator(\n-            this.downstreamTlsContext, port, syncContext);\n+            port, syncContext);", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMwNjI2Ng==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404306266", "bodyText": "formatted by my IDE :-) but will make the change", "author": "sanjaypujare", "createdAt": "2020-04-06T18:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2MDA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2MjcxMQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404262711", "bodyText": "why passing port if it can be from instance variable?", "author": "creamsoup", "createdAt": "2020-04-06T17:25:30Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            null, null, SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+  }\n+\n+  /** mTLS - client auth enabled. */\n+  @Test\n+  public void mtlsClientServer_withClientAuthentication() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    mtlsCommonTest(upstreamTlsContext);\n+  }\n+\n+  /** mTLS - client auth enabled then update server certs to untrusted. */\n+  @Test\n+  public void mtlsClientServer_changeServerContext_expectException() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    XdsClient.ListenerWatcher listenerWatcher = mtlsCommonTest(upstreamTlsContext);\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            BAD_SERVER_KEY_FILE,\n+            BAD_SERVER_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    createListenerUpdate(server.getPort(), downstreamTlsContext, listenerWatcher);\n+    try {\n+      buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+      fail(\"exception expected\");\n+    } catch (StatusRuntimeException sre) {\n+      assertThat(sre).hasCauseThat().isInstanceOf(SSLHandshakeException.class);\n+      assertThat(sre).hasCauseThat().hasMessageThat().isEqualTo(\"General OpenSslEngine problem\");\n+    }\n+  }\n+\n+  private XdsClient.ListenerWatcher mtlsCommonTest(UpstreamTlsContext upstreamTlsContext)\n+      throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+\n+    XdsClient.ListenerWatcher listenerWatcher = getXdsServer(downstreamTlsContext);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+    return listenerWatcher;\n+  }\n+\n+  private XdsClient.ListenerWatcher getXdsServer(DownstreamTlsContext downstreamTlsContext)\n+      throws IOException {\n+    int port = findFreePort();\n+    XdsServerBuilder builder =\n+        XdsServerBuilder.forPort(port).addService(new SimpleServiceImpl());\n+    final XdsClientWrapperForServerSds xdsClientWrapperForServerSds =\n+        createXdsClientWrapperForServerSds(port, downstreamTlsContext);\n+    SdsProtocolNegotiators.ServerSdsProtocolNegotiator serverSdsProtocolNegotiator =\n+        new SdsProtocolNegotiators.ServerSdsProtocolNegotiator(xdsClientWrapperForServerSds);\n+    server = cleanupRule.register(builder.buildServer(serverSdsProtocolNegotiator)).start();\n+    return xdsClientWrapperForServerSds.getListenerWatcher();\n+  }\n+\n+  /** Creates XdsClientWrapperForServerSds: also used by other classes. */\n+  public static XdsClientWrapperForServerSds createXdsClientWrapperForServerSds(\n+      int port, DownstreamTlsContext downstreamTlsContext) {\n+    XdsClient mockXdsClient = mock(XdsClient.class);\n+    XdsClientWrapperForServerSds xdsClientWrapperForServerSds =\n+        new XdsClientWrapperForServerSds(port, mockXdsClient, null);\n+    createListenerUpdate(port, downstreamTlsContext,\n+        xdsClientWrapperForServerSds.getListenerWatcher());\n+    return xdsClientWrapperForServerSds;\n+  }\n+\n+  private static int findFreePort() throws IOException {\n+    try (ServerSocket socket = new ServerSocket(0)) {\n+      socket.setReuseAddress(true);\n+      return socket.getLocalPort();\n+    }\n+  }\n+\n+  private static void createListenerUpdate(\n+      int port, DownstreamTlsContext tlsContext, XdsClient.ListenerWatcher registeredWatcher) {\n+    EnvoyServerProtoData.Listener listener =\n+        buildListener(\"listener1\", \"0.0.0.0\", port, tlsContext);\n+    XdsClient.ListenerUpdate listenerUpdate =\n+        XdsClient.ListenerUpdate.newBuilder().setListener(listener).build();\n+    registeredWatcher.onListenerChanged(listenerUpdate);\n+  }\n+\n+  static EnvoyServerProtoData.Listener buildListener(\n+      String name,\n+      String address,\n+      int port,\n+      DownstreamTlsContext tlsContext) {\n+    EnvoyServerProtoData.FilterChainMatch filterChainMatch =\n+        buildFilterChainMatch(port, address);\n+    EnvoyServerProtoData.FilterChain filterChain1 =\n+        new EnvoyServerProtoData.FilterChain(filterChainMatch, tlsContext);\n+    EnvoyServerProtoData.Listener listener =\n+        new EnvoyServerProtoData.Listener(name, address, Arrays.asList(filterChain1));\n+    return listener;\n+  }\n+\n+  private void buildClientAndTest(\n+      UpstreamTlsContext upstreamTlsContext,\n+      String overrideAuthority,\n+      String requestMessage,\n+      int serverPort) {", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2Mjg5Nw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404262897", "bodyText": "for this test, this param is meaningless.", "author": "creamsoup", "createdAt": "2020-04-06T17:25:48Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            null, null, SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+  }\n+\n+  /** mTLS - client auth enabled. */\n+  @Test\n+  public void mtlsClientServer_withClientAuthentication() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    mtlsCommonTest(upstreamTlsContext);\n+  }\n+\n+  /** mTLS - client auth enabled then update server certs to untrusted. */\n+  @Test\n+  public void mtlsClientServer_changeServerContext_expectException() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    XdsClient.ListenerWatcher listenerWatcher = mtlsCommonTest(upstreamTlsContext);\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            BAD_SERVER_KEY_FILE,\n+            BAD_SERVER_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    createListenerUpdate(server.getPort(), downstreamTlsContext, listenerWatcher);\n+    try {\n+      buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+      fail(\"exception expected\");\n+    } catch (StatusRuntimeException sre) {\n+      assertThat(sre).hasCauseThat().isInstanceOf(SSLHandshakeException.class);\n+      assertThat(sre).hasCauseThat().hasMessageThat().isEqualTo(\"General OpenSslEngine problem\");\n+    }\n+  }\n+\n+  private XdsClient.ListenerWatcher mtlsCommonTest(UpstreamTlsContext upstreamTlsContext)\n+      throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+\n+    XdsClient.ListenerWatcher listenerWatcher = getXdsServer(downstreamTlsContext);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+    return listenerWatcher;\n+  }\n+\n+  private XdsClient.ListenerWatcher getXdsServer(DownstreamTlsContext downstreamTlsContext)\n+      throws IOException {\n+    int port = findFreePort();\n+    XdsServerBuilder builder =\n+        XdsServerBuilder.forPort(port).addService(new SimpleServiceImpl());\n+    final XdsClientWrapperForServerSds xdsClientWrapperForServerSds =\n+        createXdsClientWrapperForServerSds(port, downstreamTlsContext);\n+    SdsProtocolNegotiators.ServerSdsProtocolNegotiator serverSdsProtocolNegotiator =\n+        new SdsProtocolNegotiators.ServerSdsProtocolNegotiator(xdsClientWrapperForServerSds);\n+    server = cleanupRule.register(builder.buildServer(serverSdsProtocolNegotiator)).start();\n+    return xdsClientWrapperForServerSds.getListenerWatcher();\n+  }\n+\n+  /** Creates XdsClientWrapperForServerSds: also used by other classes. */\n+  public static XdsClientWrapperForServerSds createXdsClientWrapperForServerSds(\n+      int port, DownstreamTlsContext downstreamTlsContext) {\n+    XdsClient mockXdsClient = mock(XdsClient.class);\n+    XdsClientWrapperForServerSds xdsClientWrapperForServerSds =\n+        new XdsClientWrapperForServerSds(port, mockXdsClient, null);\n+    createListenerUpdate(port, downstreamTlsContext,\n+        xdsClientWrapperForServerSds.getListenerWatcher());\n+    return xdsClientWrapperForServerSds;\n+  }\n+\n+  private static int findFreePort() throws IOException {\n+    try (ServerSocket socket = new ServerSocket(0)) {\n+      socket.setReuseAddress(true);\n+      return socket.getLocalPort();\n+    }\n+  }\n+\n+  private static void createListenerUpdate(\n+      int port, DownstreamTlsContext tlsContext, XdsClient.ListenerWatcher registeredWatcher) {\n+    EnvoyServerProtoData.Listener listener =\n+        buildListener(\"listener1\", \"0.0.0.0\", port, tlsContext);\n+    XdsClient.ListenerUpdate listenerUpdate =\n+        XdsClient.ListenerUpdate.newBuilder().setListener(listener).build();\n+    registeredWatcher.onListenerChanged(listenerUpdate);\n+  }\n+\n+  static EnvoyServerProtoData.Listener buildListener(\n+      String name,\n+      String address,\n+      int port,\n+      DownstreamTlsContext tlsContext) {\n+    EnvoyServerProtoData.FilterChainMatch filterChainMatch =\n+        buildFilterChainMatch(port, address);\n+    EnvoyServerProtoData.FilterChain filterChain1 =\n+        new EnvoyServerProtoData.FilterChain(filterChainMatch, tlsContext);\n+    EnvoyServerProtoData.Listener listener =\n+        new EnvoyServerProtoData.Listener(name, address, Arrays.asList(filterChain1));\n+    return listener;\n+  }\n+\n+  private void buildClientAndTest(\n+      UpstreamTlsContext upstreamTlsContext,\n+      String overrideAuthority,\n+      String requestMessage,", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NDc4OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404264789", "bodyText": "why get server is not assigned?", "author": "creamsoup", "createdAt": "2020-04-06T17:28:45Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI2MjQ2Ng==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405262466", "bodyText": "because I don't need it. I will assign it to unused to address this comment", "author": "sanjaypujare", "createdAt": "2020-04-08T05:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NDc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NTI5Mg==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404265292", "bodyText": "this instance variable can be local variable.", "author": "creamsoup", "createdAt": "2020-04-06T17:29:30Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI2MTYyNw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405261627", "bodyText": "No, unless I declare a POJO just to return and use 2 values: the Server and listenerWatcher, since a function cannot return 2 values. Look at the flow in mtlsClientServer_changeServerContext_expectException calling performMtlsTestAndGetListenerWatcher and buildClientAndTest", "author": "sanjaypujare", "createdAt": "2020-04-08T05:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NTI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzNDA1NQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r406334055", "bodyText": "i would say the flow is wrong. it is using server as global variable to pass it around.", "author": "creamsoup", "createdAt": "2020-04-09T16:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NTI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NjI3NQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404266275", "bodyText": "can you split into 2 methods?", "author": "creamsoup", "createdAt": "2020-04-06T17:30:57Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NjIzNg==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404576236", "bodyText": "If they always go together, I prefer to keep it as one method.", "author": "sanjaypujare", "createdAt": "2020-04-07T06:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NjI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzODk1NA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405138954", "bodyText": "what i am worried is go/unit-test-practices#assertions-examples\nmost of the test looks like the bad example in that link.", "author": "creamsoup", "createdAt": "2020-04-07T22:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NjI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NjczOA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404266738", "bodyText": "is this testing test utility method?", "author": "creamsoup", "createdAt": "2020-04-06T17:31:41Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            null, null, SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+  }\n+\n+  /** mTLS - client auth enabled. */\n+  @Test\n+  public void mtlsClientServer_withClientAuthentication() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    mtlsCommonTest(upstreamTlsContext);", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMwNzk0Mw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404307943", "bodyText": "No, this is testing a complete mTLS scenario but used more than once to test the listener update scenario - hence the util function mtlsCommonTest", "author": "sanjaypujare", "createdAt": "2020-04-06T18:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NjczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2NzM4Nw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404267387", "bodyText": "ListenerWatcher is not XdsServer, is it?", "author": "creamsoup", "createdAt": "2020-04-06T17:32:47Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            null, null, SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+  }\n+\n+  /** mTLS - client auth enabled. */\n+  @Test\n+  public void mtlsClientServer_withClientAuthentication() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    mtlsCommonTest(upstreamTlsContext);\n+  }\n+\n+  /** mTLS - client auth enabled then update server certs to untrusted. */\n+  @Test\n+  public void mtlsClientServer_changeServerContext_expectException() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    XdsClient.ListenerWatcher listenerWatcher = mtlsCommonTest(upstreamTlsContext);\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            BAD_SERVER_KEY_FILE,\n+            BAD_SERVER_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    createListenerUpdate(server.getPort(), downstreamTlsContext, listenerWatcher);\n+    try {\n+      buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+      fail(\"exception expected\");\n+    } catch (StatusRuntimeException sre) {\n+      assertThat(sre).hasCauseThat().isInstanceOf(SSLHandshakeException.class);\n+      assertThat(sre).hasCauseThat().hasMessageThat().isEqualTo(\"General OpenSslEngine problem\");\n+    }\n+  }\n+\n+  private XdsClient.ListenerWatcher mtlsCommonTest(UpstreamTlsContext upstreamTlsContext)\n+      throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+\n+    XdsClient.ListenerWatcher listenerWatcher = getXdsServer(downstreamTlsContext);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+    return listenerWatcher;\n+  }\n+\n+  private XdsClient.ListenerWatcher getXdsServer(DownstreamTlsContext downstreamTlsContext)", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2ODQ5NQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404268495", "bodyText": "the method name doesn't match to what it actually does. it makes the reader very confusing.", "author": "creamsoup", "createdAt": "2020-04-06T17:34:39Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            null, null, SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+  }\n+\n+  /** mTLS - client auth enabled. */\n+  @Test\n+  public void mtlsClientServer_withClientAuthentication() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    mtlsCommonTest(upstreamTlsContext);\n+  }\n+\n+  /** mTLS - client auth enabled then update server certs to untrusted. */\n+  @Test\n+  public void mtlsClientServer_changeServerContext_expectException() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    XdsClient.ListenerWatcher listenerWatcher = mtlsCommonTest(upstreamTlsContext);\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            BAD_SERVER_KEY_FILE,\n+            BAD_SERVER_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    createListenerUpdate(server.getPort(), downstreamTlsContext, listenerWatcher);\n+    try {\n+      buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+      fail(\"exception expected\");\n+    } catch (StatusRuntimeException sre) {\n+      assertThat(sre).hasCauseThat().isInstanceOf(SSLHandshakeException.class);\n+      assertThat(sre).hasCauseThat().hasMessageThat().isEqualTo(\"General OpenSslEngine problem\");\n+    }\n+  }\n+\n+  private XdsClient.ListenerWatcher mtlsCommonTest(UpstreamTlsContext upstreamTlsContext)\n+      throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+\n+    XdsClient.ListenerWatcher listenerWatcher = getXdsServer(downstreamTlsContext);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+    return listenerWatcher;\n+  }\n+\n+  private XdsClient.ListenerWatcher getXdsServer(DownstreamTlsContext downstreamTlsContext)\n+      throws IOException {\n+    int port = findFreePort();\n+    XdsServerBuilder builder =\n+        XdsServerBuilder.forPort(port).addService(new SimpleServiceImpl());\n+    final XdsClientWrapperForServerSds xdsClientWrapperForServerSds =\n+        createXdsClientWrapperForServerSds(port, downstreamTlsContext);\n+    SdsProtocolNegotiators.ServerSdsProtocolNegotiator serverSdsProtocolNegotiator =\n+        new SdsProtocolNegotiators.ServerSdsProtocolNegotiator(xdsClientWrapperForServerSds);\n+    server = cleanupRule.register(builder.buildServer(serverSdsProtocolNegotiator)).start();\n+    return xdsClientWrapperForServerSds.getListenerWatcher();\n+  }\n+\n+  /** Creates XdsClientWrapperForServerSds: also used by other classes. */\n+  public static XdsClientWrapperForServerSds createXdsClientWrapperForServerSds(\n+      int port, DownstreamTlsContext downstreamTlsContext) {\n+    XdsClient mockXdsClient = mock(XdsClient.class);\n+    XdsClientWrapperForServerSds xdsClientWrapperForServerSds =\n+        new XdsClientWrapperForServerSds(port, mockXdsClient, null);\n+    createListenerUpdate(port, downstreamTlsContext,\n+        xdsClientWrapperForServerSds.getListenerWatcher());\n+    return xdsClientWrapperForServerSds;\n+  }\n+\n+  private static int findFreePort() throws IOException {\n+    try (ServerSocket socket = new ServerSocket(0)) {\n+      socket.setReuseAddress(true);\n+      return socket.getLocalPort();\n+    }\n+  }\n+\n+  private static void createListenerUpdate(", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTU4Nw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404269587", "bodyText": "this doesn't verify any security, it just verifies it is broken or not. is there way to verify?", "author": "creamsoup", "createdAt": "2020-04-06T17:36:29Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            null, null, SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+  }\n+\n+  /** mTLS - client auth enabled. */\n+  @Test\n+  public void mtlsClientServer_withClientAuthentication() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    mtlsCommonTest(upstreamTlsContext);\n+  }\n+\n+  /** mTLS - client auth enabled then update server certs to untrusted. */\n+  @Test\n+  public void mtlsClientServer_changeServerContext_expectException() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    XdsClient.ListenerWatcher listenerWatcher = mtlsCommonTest(upstreamTlsContext);\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            BAD_SERVER_KEY_FILE,\n+            BAD_SERVER_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    createListenerUpdate(server.getPort(), downstreamTlsContext, listenerWatcher);\n+    try {\n+      buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+      fail(\"exception expected\");\n+    } catch (StatusRuntimeException sre) {\n+      assertThat(sre).hasCauseThat().isInstanceOf(SSLHandshakeException.class);\n+      assertThat(sre).hasCauseThat().hasMessageThat().isEqualTo(\"General OpenSslEngine problem\");\n+    }\n+  }\n+\n+  private XdsClient.ListenerWatcher mtlsCommonTest(UpstreamTlsContext upstreamTlsContext)\n+      throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+\n+    XdsClient.ListenerWatcher listenerWatcher = getXdsServer(downstreamTlsContext);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+    return listenerWatcher;\n+  }\n+\n+  private XdsClient.ListenerWatcher getXdsServer(DownstreamTlsContext downstreamTlsContext)\n+      throws IOException {\n+    int port = findFreePort();\n+    XdsServerBuilder builder =\n+        XdsServerBuilder.forPort(port).addService(new SimpleServiceImpl());\n+    final XdsClientWrapperForServerSds xdsClientWrapperForServerSds =\n+        createXdsClientWrapperForServerSds(port, downstreamTlsContext);\n+    SdsProtocolNegotiators.ServerSdsProtocolNegotiator serverSdsProtocolNegotiator =\n+        new SdsProtocolNegotiators.ServerSdsProtocolNegotiator(xdsClientWrapperForServerSds);\n+    server = cleanupRule.register(builder.buildServer(serverSdsProtocolNegotiator)).start();\n+    return xdsClientWrapperForServerSds.getListenerWatcher();\n+  }\n+\n+  /** Creates XdsClientWrapperForServerSds: also used by other classes. */\n+  public static XdsClientWrapperForServerSds createXdsClientWrapperForServerSds(\n+      int port, DownstreamTlsContext downstreamTlsContext) {\n+    XdsClient mockXdsClient = mock(XdsClient.class);\n+    XdsClientWrapperForServerSds xdsClientWrapperForServerSds =\n+        new XdsClientWrapperForServerSds(port, mockXdsClient, null);\n+    createListenerUpdate(port, downstreamTlsContext,\n+        xdsClientWrapperForServerSds.getListenerWatcher());\n+    return xdsClientWrapperForServerSds;\n+  }\n+\n+  private static int findFreePort() throws IOException {\n+    try (ServerSocket socket = new ServerSocket(0)) {\n+      socket.setReuseAddress(true);\n+      return socket.getLocalPort();\n+    }\n+  }\n+\n+  private static void createListenerUpdate(\n+      int port, DownstreamTlsContext tlsContext, XdsClient.ListenerWatcher registeredWatcher) {\n+    EnvoyServerProtoData.Listener listener =\n+        buildListener(\"listener1\", \"0.0.0.0\", port, tlsContext);\n+    XdsClient.ListenerUpdate listenerUpdate =\n+        XdsClient.ListenerUpdate.newBuilder().setListener(listener).build();\n+    registeredWatcher.onListenerChanged(listenerUpdate);\n+  }\n+\n+  static EnvoyServerProtoData.Listener buildListener(\n+      String name,\n+      String address,\n+      int port,\n+      DownstreamTlsContext tlsContext) {\n+    EnvoyServerProtoData.FilterChainMatch filterChainMatch =\n+        buildFilterChainMatch(port, address);\n+    EnvoyServerProtoData.FilterChain filterChain1 =\n+        new EnvoyServerProtoData.FilterChain(filterChainMatch, tlsContext);\n+    EnvoyServerProtoData.Listener listener =\n+        new EnvoyServerProtoData.Listener(name, address, Arrays.asList(filterChain1));\n+    return listener;\n+  }\n+\n+  private void buildClientAndTest(\n+      UpstreamTlsContext upstreamTlsContext,\n+      String overrideAuthority,\n+      String requestMessage,\n+      int serverPort) {\n+\n+    XdsChannelBuilder builder =\n+        XdsChannelBuilder.forTarget(\"localhost:\" + serverPort).tlsContext(upstreamTlsContext);\n+    if (overrideAuthority != null) {\n+      builder = builder.overrideAuthority(overrideAuthority);\n+    }\n+    SimpleServiceGrpc.SimpleServiceBlockingStub blockingStub =\n+        SimpleServiceGrpc.newBlockingStub(cleanupRule.register(builder.build()));\n+    String resp = unaryRpc(requestMessage, blockingStub);\n+    assertThat(resp).isEqualTo(\"Hello \" + requestMessage);", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMDQ5NQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404310495", "bodyText": "The intent is not to verify the actual TLS handshake but that an RPC was successful after an xDS/SDS managed mTLS channel was set up: so it is more of an E2E test without actually setting up xDS or even SDS server. So this part of the test hasn't changed", "author": "sanjaypujare", "createdAt": "2020-04-06T18:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NDc4MA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404374780", "bodyText": "maybe not the right comment for this PR. but, I am still not sure what it is really testing. it is only testing the tls context is not breaking communication.  this is one of the most important test for sds unless we have E2E test.", "author": "creamsoup", "createdAt": "2020-04-06T20:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NzYxOQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404577619", "bodyText": "BTW, security is verified by using a \"bad\" cert which is part of mtlsClientServer_changeServerContext_expectException. That also tests updating the server context. There are other tests to verify that SslHandler was invoked (in SdsNegotiatorsTest).", "author": "sanjaypujare", "createdAt": "2020-04-07T06:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MzY3OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404273679", "bodyText": "why test returns something unrelated?", "author": "creamsoup", "createdAt": "2020-04-06T17:43:09Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            null, null, SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+  }\n+\n+  /** mTLS - client auth enabled. */\n+  @Test\n+  public void mtlsClientServer_withClientAuthentication() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    mtlsCommonTest(upstreamTlsContext);\n+  }\n+\n+  /** mTLS - client auth enabled then update server certs to untrusted. */\n+  @Test\n+  public void mtlsClientServer_changeServerContext_expectException() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    XdsClient.ListenerWatcher listenerWatcher = mtlsCommonTest(upstreamTlsContext);\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            BAD_SERVER_KEY_FILE,\n+            BAD_SERVER_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    createListenerUpdate(server.getPort(), downstreamTlsContext, listenerWatcher);\n+    try {\n+      buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+      fail(\"exception expected\");\n+    } catch (StatusRuntimeException sre) {\n+      assertThat(sre).hasCauseThat().isInstanceOf(SSLHandshakeException.class);\n+      assertThat(sre).hasCauseThat().hasMessageThat().isEqualTo(\"General OpenSslEngine problem\");\n+    }\n+  }\n+\n+  private XdsClient.ListenerWatcher mtlsCommonTest(UpstreamTlsContext upstreamTlsContext)", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMTA5MQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404311091", "bodyText": "because it is used in mtlsClientServer_changeServerContext_expectException. I can change it from a return value to a class instance variable or rename it to address this comment", "author": "sanjaypujare", "createdAt": "2020-04-06T18:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MzY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyOTI2OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404929269", "bodyText": "renamed the method which also addresses the other comment about method name", "author": "sanjaypujare", "createdAt": "2020-04-07T16:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MzY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3Mzk1MA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404273950", "bodyText": "it is hard to expect the behavior of this test, can you change to better name?", "author": "creamsoup", "createdAt": "2020-04-06T17:43:36Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            null, null, SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+  }\n+\n+  /** mTLS - client auth enabled. */\n+  @Test\n+  public void mtlsClientServer_withClientAuthentication() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    mtlsCommonTest(upstreamTlsContext);\n+  }\n+\n+  /** mTLS - client auth enabled then update server certs to untrusted. */\n+  @Test\n+  public void mtlsClientServer_changeServerContext_expectException() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    XdsClient.ListenerWatcher listenerWatcher = mtlsCommonTest(upstreamTlsContext);\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            BAD_SERVER_KEY_FILE,\n+            BAD_SERVER_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    createListenerUpdate(server.getPort(), downstreamTlsContext, listenerWatcher);\n+    try {\n+      buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+      fail(\"exception expected\");\n+    } catch (StatusRuntimeException sre) {\n+      assertThat(sre).hasCauseThat().isInstanceOf(SSLHandshakeException.class);\n+      assertThat(sre).hasCauseThat().hasMessageThat().isEqualTo(\"General OpenSslEngine problem\");\n+    }\n+  }\n+\n+  private XdsClient.ListenerWatcher mtlsCommonTest(UpstreamTlsContext upstreamTlsContext)", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODcyMw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404588723", "bodyText": "This is a plain mTLS test that is similar to mtlsClientServer_withClientAuthentication. For code reuse with mtlsClientServer_changeServerContext_expectException I made this a common method called from both and I think mtlsCommonTest is a concise and appropriate name. mtls implies \"withClientAuthentication\" so not sure what else to add.", "author": "sanjaypujare", "createdAt": "2020-04-07T07:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3Mzk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNzE4OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404927189", "bodyText": "If you have a suggestion let me know", "author": "sanjaypujare", "createdAt": "2020-04-07T16:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3Mzk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NDkzNw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404274937", "bodyText": "should probably moved to util class.", "author": "creamsoup", "createdAt": "2020-04-06T17:45:05Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  /** Bad/untrusted server certs. */\n+  private static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+  private static final String BAD_SERVER_KEY_FILE = \"badserver.key\";\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            null, null, SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+  }\n+\n+  /** mTLS - client auth enabled. */\n+  @Test\n+  public void mtlsClientServer_withClientAuthentication() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    mtlsCommonTest(upstreamTlsContext);\n+  }\n+\n+  /** mTLS - client auth enabled then update server certs to untrusted. */\n+  @Test\n+  public void mtlsClientServer_changeServerContext_expectException() throws IOException {\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.CLIENT_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.CLIENT_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    XdsClient.ListenerWatcher listenerWatcher = mtlsCommonTest(upstreamTlsContext);\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            BAD_SERVER_KEY_FILE,\n+            BAD_SERVER_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+    createListenerUpdate(server.getPort(), downstreamTlsContext, listenerWatcher);\n+    try {\n+      buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+      fail(\"exception expected\");\n+    } catch (StatusRuntimeException sre) {\n+      assertThat(sre).hasCauseThat().isInstanceOf(SSLHandshakeException.class);\n+      assertThat(sre).hasCauseThat().hasMessageThat().isEqualTo(\"General OpenSslEngine problem\");\n+    }\n+  }\n+\n+  private XdsClient.ListenerWatcher mtlsCommonTest(UpstreamTlsContext upstreamTlsContext)\n+      throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            SecretVolumeSslContextProviderTest.SERVER_1_KEY_FILE,\n+            SecretVolumeSslContextProviderTest.SERVER_1_PEM_FILE,\n+            SecretVolumeSslContextProviderTest.CA_PEM_FILE);\n+\n+    XdsClient.ListenerWatcher listenerWatcher = getXdsServer(downstreamTlsContext);\n+    buildClientAndTest(upstreamTlsContext, \"foo.test.google.fr\", \"buddy\", server.getPort());\n+    return listenerWatcher;\n+  }\n+\n+  private XdsClient.ListenerWatcher getXdsServer(DownstreamTlsContext downstreamTlsContext)\n+      throws IOException {\n+    int port = findFreePort();\n+    XdsServerBuilder builder =\n+        XdsServerBuilder.forPort(port).addService(new SimpleServiceImpl());\n+    final XdsClientWrapperForServerSds xdsClientWrapperForServerSds =\n+        createXdsClientWrapperForServerSds(port, downstreamTlsContext);\n+    SdsProtocolNegotiators.ServerSdsProtocolNegotiator serverSdsProtocolNegotiator =\n+        new SdsProtocolNegotiators.ServerSdsProtocolNegotiator(xdsClientWrapperForServerSds);\n+    server = cleanupRule.register(builder.buildServer(serverSdsProtocolNegotiator)).start();\n+    return xdsClientWrapperForServerSds.getListenerWatcher();\n+  }\n+\n+  /** Creates XdsClientWrapperForServerSds: also used by other classes. */\n+  public static XdsClientWrapperForServerSds createXdsClientWrapperForServerSds(", "originalCommit": "6fc54631c0397dfe8e0ccae80c2eddfab9ea345b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMTY3MQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404311671", "bodyText": "ok", "author": "sanjaypujare", "createdAt": "2020-04-06T18:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NDkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNjU4NA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404926584", "bodyText": "Moved to XdsClientWrapperForServerSdsTest since it cannot be in CommonTlsContextTestsUtil due to different package and I didn't see the need to create a  new util class here just for this", "author": "sanjaypujare", "createdAt": "2020-04-07T16:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NDkzNw=="}], "type": "inlineReview"}, {"oid": "0f03cd9778114bc1940757704cd0c8b63bbbb599", "url": "https://github.com/grpc/grpc-java/commit/0f03cd9778114bc1940757704cd0c8b63bbbb599", "message": "address review comments\n\nUpdate xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java\n\nCo-Authored-By: Jihun Cho <jihuncho@google.com>\n\nUpdate xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java\n\nCo-Authored-By: Jihun Cho <jihuncho@google.com>", "committedDate": "2020-04-07T16:09:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNjQzNA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404516434", "bodyText": "nit: toString can be omitted.", "author": "creamsoup", "createdAt": "2020-04-07T03:37:55Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -106,29 +107,28 @@ public static XdsClientWrapperForServerSds newInstance(\n     this.port = port;\n     this.xdsClient = xdsClient;\n     this.timeService = timeService;\n-    xdsClient.watchListenerData(\n-        port,\n-        new XdsClient.ListenerWatcher() {\n-          @Override\n-          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n-            logger.log(\n-                Level.INFO,\n-                \"Setting myListener from ConfigUpdate listener :{0}\",\n-                update.getListener().toString());\n-            curListener = update.getListener();\n-          }\n+    this.listenerWatcher = new XdsClient.ListenerWatcher() {\n+      @Override\n+      public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+        logger.log(\n+            Level.INFO,\n+            \"Setting myListener from ConfigUpdate listener :{0}\",\n+            update.getListener().toString());", "originalCommit": "51d4514f1b77a155e2cae413deb88bae63ea08cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNjk1NA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404516954", "bodyText": "parameter is marked as nullable?", "author": "creamsoup", "createdAt": "2020-04-07T03:39:58Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -263,18 +259,14 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)\n   @VisibleForTesting\n   public static final class ServerSdsProtocolNegotiator implements ProtocolNegotiator {\n \n-    @Nullable private final DownstreamTlsContext downstreamTlsContext;\n     @Nullable private final XdsClientWrapperForServerSds xdsClientWrapperForServerSds;\n \n     /** Constructor. */\n     @VisibleForTesting\n     public ServerSdsProtocolNegotiator(\n-        @Nullable DownstreamTlsContext downstreamTlsContext,\n         @Nullable XdsClientWrapperForServerSds xdsClientWrapperForServerSds) {\n-      checkArgument(downstreamTlsContext != null || xdsClientWrapperForServerSds != null,\n-          \"both downstreamTlsContext and xdsClientWrapperForServerSds cannot be null\");\n-      this.downstreamTlsContext = downstreamTlsContext;\n-      this.xdsClientWrapperForServerSds = xdsClientWrapperForServerSds;\n+      this.xdsClientWrapperForServerSds =\n+          checkNotNull(xdsClientWrapperForServerSds, \"xdsClientWrapperForServerSds\");", "originalCommit": "51d4514f1b77a155e2cae413deb88bae63ea08cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNzcyOQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404517729", "bodyText": "can be merged to 1 line.", "author": "creamsoup", "createdAt": "2020-04-07T03:43:31Z", "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -295,7 +287,7 @@ public AsciiString scheme() {\n \n     @Override\n     public ChannelHandler newHandler(GrpcHttp2ConnectionHandler grpcHandler) {\n-      return new HandlerPickerHandler(grpcHandler, downstreamTlsContext,\n+      return new HandlerPickerHandler(grpcHandler,", "originalCommit": "51d4514f1b77a155e2cae413deb88bae63ea08cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2MzA1MA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r404963050", "bodyText": "this can be copied or in util class.", "author": "creamsoup", "createdAt": "2020-04-07T16:53:18Z", "path": "xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTest.java", "diffHunk": "@@ -139,6 +140,26 @@\n   private XdsClientWrapperForServerSds xdsClientWrapperForServerSds;\n   private final DownstreamTlsContext[] tlsContexts = new DownstreamTlsContext[3];\n \n+  /** Creates XdsClientWrapperForServerSds: also used by other classes. */\n+  public static XdsClientWrapperForServerSds createXdsClientWrapperForServerSds(", "originalCommit": "0f03cd9778114bc1940757704cd0c8b63bbbb599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg0MTk3Mw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405841973", "bodyText": "For now I am leaving it here as the \"container\" for XdsClientWrapperForServerSds related util methods instead of creating a new util class in this package.", "author": "sanjaypujare", "createdAt": "2020-04-08T22:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2MzA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTY3NQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405141675", "bodyText": "this method should be in the util class too", "author": "creamsoup", "createdAt": "2020-04-07T22:06:37Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(", "originalCommit": "0f03cd9778114bc1940757704cd0c8b63bbbb599", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0MTg2Nw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405141867", "bodyText": "same here. the method should be in the util class.", "author": "creamsoup", "createdAt": "2020-04-07T22:07:02Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            CommonTlsContextTestsUtil.SERVER_1_KEY_FILE,\n+            CommonTlsContextTestsUtil.SERVER_1_PEM_FILE,\n+            null);\n+\n+    getXdsServer(downstreamTlsContext);\n+\n+    // for TLS, client only needs trustCa\n+    UpstreamTlsContext upstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(", "originalCommit": "0f03cd9778114bc1940757704cd0c8b63bbbb599", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405143940", "bodyText": "can you use? /* paramName= */, like i mentioned before this is actually checked by linter which is less error prone. applies to other places.", "author": "creamsoup", "createdAt": "2020-04-07T22:12:06Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/SdsProtocolNegotiatorsTest.java", "diffHunk": "@@ -259,10 +271,9 @@ public void clientSdsProtocolNegotiatorNewHandler_fireProtocolNegotiationEvent()\n   }\n \n   @Test\n-  public void serverSdsProtocolNegotiator_passNulls_expectPlaintext() {\n+  public void serverSdsProtocolNegotiator_nullSyncContext_expectPlaintext() {\n     InternalProtocolNegotiator.ProtocolNegotiator protocolNegotiator =\n-        SdsProtocolNegotiators.serverProtocolNegotiator(null, 7000,\n-            null);\n+        SdsProtocolNegotiators.serverProtocolNegotiator(7000, null);", "originalCommit": "0f03cd9778114bc1940757704cd0c8b63bbbb599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1MTIzNQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405151235", "bodyText": "I was talking to @ejona86 some time ago and he said for test code this is completely unnecessary (IIRC). It will be good to have consensus", "author": "sanjaypujare", "createdAt": "2020-04-07T22:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2MjkwMQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405162901", "bodyText": "I don't think we have an exception for this for test code, but I also don't see any failure in the build so I don't think lint complains about this.\nLooking at ErrorProne these are the checks I could find that are impacted by argument comments (none of them apply):\nhttps://errorprone.info/bugpattern/ArgumentSelectionDefectChecker\nhttps://errorprone.info/bugpattern/BooleanParameter\nhttps://errorprone.info/bugpattern/ParameterComment\nhttps://errorprone.info/bugpattern/ParameterName\nIt isn't at all clear to me why syncContext would be null, and why that would imply plain-text. That seems super-strange to me. The port also seems unnecessary since the negotiator will have access to that information from io.netty.channel.Channel.localAddress().\nI don't think we have a rule that you are required to put the parameter names, but you should put the parameter names when it could be confusing otherwise. In this case the null is really important to the test, but there's also only one null. The previous version is more confusing. In any case for a test, instead of having the comment I would be more prone to doing:\nSynchronizationContext syncContext = null; // or syncContext = null; if it is a class field\nSdsProtocolNegotiators.serverProtocolNegotiator(7000, syncContext);\n\nBut really, I'd hope we can drop the 7000 and always specify a syncContext.", "author": "ejona86", "createdAt": "2020-04-07T23:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NDI0OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405164249", "bodyText": "Hmm... I guess the 7000 is specified here since there will be a single watch for the entire server. This is a problem though, because that is not normal initialization for a protocol negotiator; this approach won't be available in a ServerCredentials API. There may need to be more hole-punching to allow it.", "author": "ejona86", "createdAt": "2020-04-07T23:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM0NzU2NQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405347565", "bodyText": "Yes the port is provided for setting the LDS watch for the server (not sure what you mean by \"entire server\"). ServerCredentials is attached to a server and a server is attached to a creds (since you can't reuse creds?) In that case you can get the server port from the creds, right?", "author": "sanjaypujare", "createdAt": "2020-04-08T08:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM1MjI2NA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405352264", "bodyText": "syncContext can never be null since it is created by the server builder before invoking the SdsProtocolNegotiator.  So the test is a bit misleading but is there to simulate XdsClientImpl throwing exception (because syncContext is null).", "author": "sanjaypujare", "createdAt": "2020-04-08T08:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2Nzc3Ng==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405667776", "bodyText": "added the param comments after doing a quick search", "author": "sanjaypujare", "createdAt": "2020-04-08T16:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MDM2OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405670369", "bodyText": "The user will create any ServerCredentials before they are passed to the ServerBuilder, so passing in port like this simply won't work. And yes, the user could use the same server credentials with multiple servers. It also looks like you are having \"creation imply starting\", as the credential appears to start the watch when it is created. The user will create the credential well before the port is even determined, so that is also not going to work. These things are important to call out because they mean additional plumbing would be required.\nThis test is horrible. Abusing syncContext in that way would deserve a big comment or some sort of pointer to something weird going on. Naming it something like \"serverSdsProtocolNegotiator_xdsClientCreationThrows_expectPlaintext\" would be a good starter. But that is even wrong. syncContext is a red herring because the only catch in SdsProtocolNegotiators is for IOException. That means it wouldn't catch NullPointerException and it also wouldn't catch NoSuchElementException. So at the very least I've determined the exception handling is broken (XdsClientWrapperForServerSds should probably not be throwing a RuntimeException based on bad input from a user). The reason the test passes is because it triggers \"java.io.IOException: Environment variable GRPC_XDS_BOOTSTRAP not defined.\".\nWhat is clearly missing is calling serverProtocolNegotiator() and it returning an actual ServerSdsProtocolNegotiator. That said, even ServerSdsProtocolNegotiator should have a protocol of http as the xds server may not return security information. (Actually, it seems it should delegate to a fallback protocol negotiator, e.g., serverPlaintext(), so the protocol wouldn't end up changing.)", "author": "ejona86", "createdAt": "2020-04-08T16:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4OTM5OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405689399", "bodyText": "The user will create the credential well before the port is even determined, so that is also not going to work. These things are important to call out because they mean additional plumbing would be required.\n\nBut the port is determined or known when the server is built (XdsServerBuilder.build) and that is when the watch is set: although I agree it could be delayed until start. Doing that will require me to reintroduce XdsServer I had in a previous PR for the shutdown case.  Can be done in a separate PR.\n\nBut that is even wrong. syncContext is a red herring because the only catch in SdsProtocolNegotiators is for IOException. That means it wouldn't catch NullPointerException and it also wouldn't catch NoSuchElementException. So at the very least I've determined the exception handling is broken (XdsClientWrapperForServerSds should probably not be throwing a RuntimeException based on bad input from a user).\n\nInteresting - I did have the broader exception earlier but made it narrower based on PR comments. Again I can fix this in a separate PR after we agree on the approach.\n\nWhat is clearly missing is calling serverProtocolNegotiator() and it returning an actual ServerSdsProtocolNegotiator.\n\nSo you think returning InternalProtocolNegotiators.serverPlaintext() is not correct for serverProtocolNegotiator() and should always be delegated to the ServerSdsProtocolNegotiator? I think that was the old approach.\n\nThat said, even ServerSdsProtocolNegotiator should have a protocol of http as the xds server may not return security information.\n\nInteresting. The ServerSdsProtocolNegotiator does the right thing based on the current state of the security information from the xDS server (whether DownstreamTlsContext is present or not) just that SCHEME is hardcoded to https. If you are saying it should always be \"http\" that should be easy to change. Changing it to \"https\" or \"http\" based on the current state is also not that hard (I think).\n\n(Actually, it seems it should delegate to a fallback protocol negotiator, e.g., serverPlaintext(), so the protocol wouldn't end up changing.)\n\nIt does delegate to serverPlaintext() at the time of creating the handler if you see HandlerPickerHandler.newHandler.", "author": "sanjaypujare", "createdAt": "2020-04-08T17:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc4NzAxOQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405787019", "bodyText": "But the port is determined or known when the server is built (XdsServerBuilder.build) and that is when the watch is set: although I agree it could be delayed until start.\n\nEven now it must be delayed until start, because that's when I/O is permitted to start. Technically, the user could create a server and never start it. Yes, I'd expect fixing this sort of thing to be done in a separate PR.\n\nInteresting - I did have the broader exception earlier but made it narrower based on PR comments. Again I can fix this in a separate PR after we agree on the approach.\n\nThe problem was with the code throwing a RuntimeException. The reviewer was right to ask for more narrow exception handling. But code randomly throwing RuntimeExceptions is asking for bugs, like failure to notice changing Exception to IOException in a catch would leave some cases unhandled. In our code, RuntimeExceptions should generally be reserved for programmer errors.\n\nSo you think returning InternalProtocolNegotiators.serverPlaintext() is not correct for serverProtocolNegotiator() and should always be delegated to the ServerSdsProtocolNegotiator? I think that was the old approach.\n\nIf the bootstrap is unavailable, returning serverPlaintext is fine. But that's \"not the end of it.\" I thought we had decided we were going to have the user specify a fallback credential in case xds has no tls configuration, so it seems some credential should still be provided to ServerSdsProtocolNegotiator as a fallback and that should behave the same from the user's perspective independent of when it happens. (i.e., the user should see the same behavior if GRPC_XDS_BOOTSTRAP is unset as if the xds server has no tls configuration)\n\nInteresting. The ServerSdsProtocolNegotiator does the right thing based on the current state of the security information from the xDS server (whether DownstreamTlsContext is present or not) just that SCHEME is hardcoded to https. If you are saying it should always be \"http\" that should be easy to change. Changing it to \"https\" or \"http\" based on the current state is also not that hard (I think).\n\nDoes it guarantee it is going to use a secure connection? If not, it should be http. So yes, it should be http.\nChanging it on-the-fly won't work, because this is called separately from an actual connection being handled and the setting can change at any point based on xds. There's no form of synchronization available to make sure that the right value is used for the right connections.\n(In truth, this value is unused on server-side today. So it doesn't really matter. Except this is security stuff. So it totally matters.)\n\nIt does delegate to serverPlaintext() at the time of creating the handler if you see HandlerPickerHandler.newHandler.\n\nIt should have a \"fallback\" protocol negotiator passed in. That will mirror the final design where the user gets to decide. Hard-coding this stuff now means that we're less likely to notice issues with the long-term design.", "author": "ejona86", "createdAt": "2020-04-08T20:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc5NjM0NA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405796344", "bodyText": "@ejona86 for all of your comments requiring code change I'll create a separate PR instead of complicating this PR (which was meant to remove DownstreamTlsContext from the XdsServerBuilder). For \"fallback\" too the XdsServerBuilder could define something like say XdsServerBuilder.fallbackProtocolNegotiator(ProtocolNegotiator protocolNegotiator) and plumb it down or the actual form once we know what channel/server credentials will look like. Again let's do it in a separate PR or at the time of XdsServerCredentials.\nI can create an issue to keep track of all items needing that separate PR.", "author": "sanjaypujare", "createdAt": "2020-04-08T20:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgxODI2OQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405818269", "bodyText": "And there is one case of NoSuchElementException that I can convert to IOException or log message and return null (in another PR).", "author": "sanjaypujare", "createdAt": "2020-04-08T21:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0Mzk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NDI4Mw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405144283", "bodyText": "should be moved to utility class if shared in many tests.", "author": "creamsoup", "createdAt": "2020-04-07T22:12:51Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/SecretVolumeSslContextProviderTest.java", "diffHunk": "@@ -419,8 +404,22 @@ static void doChecksOnSslContext(boolean server, SslContext sslContext,\n   /**\n    * Helper method to build DownstreamTlsContext for above tests. Called from other classes as well.\n    */\n-  static DownstreamTlsContext buildDownstreamTlsContextFromFilenames(\n-      String privateKey, String certChain, String trustCa) {\n+  public static DownstreamTlsContext buildDownstreamTlsContextFromFilenames(", "originalCommit": "0f03cd9778114bc1940757704cd0c8b63bbbb599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2MzYxNQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405163615", "bodyText": "For file-based credentials (as the name suggests), this can be considered as the utility class. Are you thinking of one utility class to have all these methods?", "author": "sanjaypujare", "createdAt": "2020-04-07T23:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NDI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NDM4OA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405144388", "bodyText": "same here, moved to utility class.", "author": "creamsoup", "createdAt": "2020-04-07T22:13:08Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/SecretVolumeSslContextProviderTest.java", "diffHunk": "@@ -429,7 +428,20 @@ static DownstreamTlsContext buildDownstreamTlsContextFromFilenames(\n    * Helper method to build UpstreamTlsContext for above tests. Called from other classes as well.\n    */\n   public static UpstreamTlsContext buildUpstreamTlsContextFromFilenames(", "originalCommit": "0f03cd9778114bc1940757704cd0c8b63bbbb599", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTM3NQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405145375", "bodyText": "FYI/nit: those could be static imported, because it is not vague.", "author": "creamsoup", "createdAt": "2020-04-07T22:15:35Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static org.junit.Assert.fail;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.SecretVolumeSslContextProviderTest;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private Server server;\n+\n+  @Test\n+  public void plaintextClientServer() throws IOException {\n+    getXdsServer(/* downstreamTlsContext= */ null);\n+    buildClientAndTest(\n+        /* upstreamTlsContext= */ null, /* overrideAuthority= */ null, \"buddy\", server.getPort());\n+  }\n+\n+  /** TLS channel - no mTLS. */\n+  @Test\n+  public void tlsClientServer_noClientAuthentication() throws IOException {\n+    DownstreamTlsContext downstreamTlsContext =\n+        SecretVolumeSslContextProviderTest.buildDownstreamTlsContextFromFilenames(\n+            CommonTlsContextTestsUtil.SERVER_1_KEY_FILE,", "originalCommit": "0f03cd9778114bc1940757704cd0c8b63bbbb599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1MDAyNw==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405150027", "bodyText": "Yes, I used IDE's \"Find and Replace Code Duplicates\" and \"Inline Field\" and this was the result. I'll try to do a sweep and see if I can fix all of them", "author": "sanjaypujare", "createdAt": "2020-04-07T22:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE0NTM3NQ=="}], "type": "inlineReview"}, {"oid": "be275e332c2a079fe8dc645d90cd30eaa1403e95", "url": "https://github.com/grpc/grpc-java/commit/be275e332c2a079fe8dc645d90cd30eaa1403e95", "message": "further fix based on review", "committedDate": "2020-04-08T16:45:33Z", "type": "forcePushed"}, {"oid": "87f28fb9ddd107e53fa90c07fb916271f8461e6a", "url": "https://github.com/grpc/grpc-java/commit/87f28fb9ddd107e53fa90c07fb916271f8461e6a", "message": "xds: eliminate downstreamTlsContext from XdsServerBuilder", "committedDate": "2020-04-09T16:11:08Z", "type": "commit"}, {"oid": "962a866d780df2ac353a7d61e2c7ac39603ce288", "url": "https://github.com/grpc/grpc-java/commit/962a866d780df2ac353a7d61e2c7ac39603ce288", "message": "address review comments\n\nUpdate xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java\n\nCo-Authored-By: Jihun Cho <jihuncho@google.com>\n\nUpdate xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java\n\nCo-Authored-By: Jihun Cho <jihuncho@google.com>", "committedDate": "2020-04-09T16:11:08Z", "type": "commit"}, {"oid": "73f0158e352572782d402c940a2f5e8dc6041005", "url": "https://github.com/grpc/grpc-java/commit/73f0158e352572782d402c940a2f5e8dc6041005", "message": "further fix based on review", "committedDate": "2020-04-09T16:14:42Z", "type": "commit"}, {"oid": "73f0158e352572782d402c940a2f5e8dc6041005", "url": "https://github.com/grpc/grpc-java/commit/73f0158e352572782d402c940a2f5e8dc6041005", "message": "further fix based on review", "committedDate": "2020-04-09T16:14:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczMTE2Mg==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405731162", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        CLIENT_KEY_FILE, CLIENT_PEM_FILE,\n          \n          \n            \n                        CA_PEM_FILE);\n          \n          \n            \n                        CLIENT_KEY_FILE, CLIENT_PEM_FILE, CA_PEM_FILE);", "author": "creamsoup", "createdAt": "2020-04-08T18:33:47Z", "path": "xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java", "diffHunk": "@@ -356,8 +356,9 @@ public void handleCdsConfigs_withUpstreamTlsContext()  {\n     verify(xdsClient).watchClusterData(eq(\"foo.googleapis.com\"), clusterWatcherCaptor1.capture());\n \n     UpstreamTlsContext upstreamTlsContext =\n-        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n-            CLIENT_KEY_FILE, CLIENT_PEM_FILE, CA_PEM_FILE);\n+        CommonTlsContextTestsUtil.buildUpstreamTlsContextFromFilenames(\n+            CLIENT_KEY_FILE, CLIENT_PEM_FILE,\n+            CA_PEM_FILE);", "originalCommit": "be275e332c2a079fe8dc645d90cd30eaa1403e95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczMTM1NQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r405731355", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        BAD_CLIENT_KEY_FILE,\n          \n          \n            \n                        BAD_CLIENT_PEM_FILE, CA_PEM_FILE);\n          \n          \n            \n                        BAD_CLIENT_KEY_FILE, BAD_CLIENT_PEM_FILE, CA_PEM_FILE);", "author": "creamsoup", "createdAt": "2020-04-08T18:34:06Z", "path": "xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java", "diffHunk": "@@ -415,8 +416,9 @@ public void handleCdsConfigs_withUpstreamTlsContext()  {\n     reset(mockTlsContextManager);\n     reset(helper);\n     UpstreamTlsContext upstreamTlsContext1 =\n-        SecretVolumeSslContextProviderTest.buildUpstreamTlsContextFromFilenames(\n-            BADCLIENT_KEY_FILE, BADCLIENT_PEM_FILE, CA_PEM_FILE);\n+        CommonTlsContextTestsUtil.buildUpstreamTlsContextFromFilenames(\n+            BAD_CLIENT_KEY_FILE,\n+            BAD_CLIENT_PEM_FILE, CA_PEM_FILE);", "originalCommit": "be275e332c2a079fe8dc645d90cd30eaa1403e95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzOTQ1NA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r406339454", "bodyText": "wrong indentation", "author": "creamsoup", "createdAt": "2020-04-09T16:49:13Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/ClientSslContextProviderFactoryTest.java", "diffHunk": "@@ -69,11 +68,9 @@ public void createSslContextProvider_sdsConfigForTlsCert_expectException() {\n   @Test\n   public void createSslContextProvider_sdsConfigForCertValidationContext_expectException() {\n     CommonTlsContext commonTlsContext =\n-        CommonTlsContextTestsUtil.buildCommonTlsContextFromSdsConfigForValidationContext(\n+            CommonTlsContextTestsUtil.buildCommonTlsContextFromSdsConfigForValidationContext(", "originalCommit": "73f0158e352572782d402c940a2f5e8dc6041005", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9a2e57735a85abb20e5fe79da2b9fb24e9b34860", "url": "https://github.com/grpc/grpc-java/commit/9a2e57735a85abb20e5fe79da2b9fb24e9b34860", "message": "Update xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java\n\nCo-Authored-By: Jihun Cho <jihuncho@google.com>", "committedDate": "2020-04-13T16:47:10Z", "type": "commit"}, {"oid": "30869df1a213a63f4e55be2723370a0314d2ab87", "url": "https://github.com/grpc/grpc-java/commit/30869df1a213a63f4e55be2723370a0314d2ab87", "message": "fix indentation", "committedDate": "2020-04-13T16:56:14Z", "type": "commit"}, {"oid": "ae06f95373bf4615fd64f9fa3ffb3aa5d6f73aa8", "url": "https://github.com/grpc/grpc-java/commit/ae06f95373bf4615fd64f9fa3ffb3aa5d6f73aa8", "message": "Update xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java\n\nCo-Authored-By: Jihun Cho <jihuncho@google.com>", "committedDate": "2020-04-13T17:00:17Z", "type": "commit"}, {"oid": "066719caa70b967a9710ae72eeda1852aa7ba336", "url": "https://github.com/grpc/grpc-java/commit/066719caa70b967a9710ae72eeda1852aa7ba336", "message": "used g4 fix format to get rectangular rule in", "committedDate": "2020-04-13T17:58:26Z", "type": "commit"}, {"oid": "da484ce1eb8f69fa9c122966c62165952e8b3371", "url": "https://github.com/grpc/grpc-java/commit/da484ce1eb8f69fa9c122966c62165952e8b3371", "message": "get rid of server as an instance var", "committedDate": "2020-04-13T21:16:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNjA5MQ==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r407626091", "bodyText": "nit: this is little weird. formatter does this because all the instance variables should have empty line. anyways, we can remove this", "author": "creamsoup", "createdAt": "2020-04-13T18:08:03Z", "path": "xds/src/test/java/io/grpc/xds/internal/sds/CommonTlsContextTestsUtil.java", "diffHunk": "@@ -43,6 +42,7 @@\n   public static final String CA_PEM_FILE = \"ca.pem\";\n   /** Bad/untrusted server certs. */\n   public static final String BAD_SERVER_PEM_FILE = \"badserver.pem\";\n+", "originalCommit": "066719caa70b967a9710ae72eeda1852aa7ba336", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3MTc4OA==", "url": "https://github.com/grpc/grpc-java/pull/6901#discussion_r407771788", "bodyText": "nit: you can directly assign findFreePort() in L61.", "author": "creamsoup", "createdAt": "2020-04-13T23:12:27Z", "path": "xds/src/test/java/io/grpc/xds/XdsSdsClientServerTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientWrapperForServerSdsTest.buildFilterChainMatch;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.BAD_SERVER_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.BAD_SERVER_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static org.junit.Assert.fail;\n+\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.auth.UpstreamTlsContext;\n+import io.grpc.Server;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.testing.protobuf.SimpleRequest;\n+import io.grpc.testing.protobuf.SimpleResponse;\n+import io.grpc.testing.protobuf.SimpleServiceGrpc;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import io.grpc.xds.internal.sds.SdsProtocolNegotiators;\n+import io.grpc.xds.internal.sds.XdsChannelBuilder;\n+import io.grpc.xds.internal.sds.XdsServerBuilder;\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.util.Arrays;\n+import javax.net.ssl.SSLHandshakeException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Unit tests for {@link XdsChannelBuilder} and {@link XdsServerBuilder} for plaintext/TLS/mTLS\n+ * modes.\n+ */\n+@RunWith(JUnit4.class)\n+public class XdsSdsClientServerTest {\n+\n+  @Rule public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+  private int port;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    port = findFreePort();", "originalCommit": "da484ce1eb8f69fa9c122966c62165952e8b3371", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7b91741f17a292d547367dc412129f6fe84196cc", "url": "https://github.com/grpc/grpc-java/commit/7b91741f17a292d547367dc412129f6fe84196cc", "message": "delete extra line", "committedDate": "2020-04-14T00:11:47Z", "type": "commit"}]}