{"pr_number": 7590, "pr_title": "xds: add File-watcher certificate provider", "pr_createdAt": "2020-11-04T05:30:27Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7590", "timeline": [{"oid": "d541af0f3c7c078a4b51a2f6ea4abd134469e88f", "url": "https://github.com/grpc/grpc-java/commit/d541af0f3c7c078a4b51a2f6ea4abd134469e88f", "message": "xds: add File-watcher certificate provider", "committedDate": "2020-11-04T05:28:16Z", "type": "commit"}, {"oid": "85c9667bf6368f299c1c241895b9b3126b53d447", "url": "https://github.com/grpc/grpc-java/commit/85c9667bf6368f299c1c241895b9b3126b53d447", "message": "changes dashes to underscores to conform to styleguide", "committedDate": "2020-11-05T17:40:52Z", "type": "commit"}, {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b", "url": "https://github.com/grpc/grpc-java/commit/e093fb1e7667d41f57dbe6614e6b1454b153581b", "message": "changes dashes to underscores to conform to styleguide-2", "committedDate": "2020-11-05T18:15:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMyNjc1MA==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518326750", "bodyText": "DynamicReloadingCertificateProvider is passing a directory, why this one is not?", "author": "dapengzhang0", "createdAt": "2020-11-05T19:55:07Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileTime;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for file watching cert provider. */\n+final class FileWatcherCertificateProvider extends CertificateProvider {\n+  private static final Logger logger =\n+      Logger.getLogger(FileWatcherCertificateProvider.class.getName());\n+\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final TimeProvider timeProvider;\n+  private final Path certFile;\n+  private final Path keyFile;\n+  private final Path trustFile;\n+  private final long refreshIntervalInSeconds;\n+  @VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle;\n+  private FileTime lastModifiedTimeCert;\n+  private FileTime lastModifiedTimeKey;\n+  private FileTime lastModifiedTimeRoot;\n+\n+  FileWatcherCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String certFile,", "originalCommit": "e093fb1e7667d41f57dbe6614e6b1454b153581b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM0NzEwNw==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518347107", "bodyText": "As mentioned offline this is going to eventually replace DynamicReloadingCertificateProvider since the design now calls for a generic file-watcher plugin instead of assuming a symlink based provider. So we don't assume a common directory.", "author": "sanjaypujare", "createdAt": "2020-11-05T20:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMyNjc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzMTYwNg==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518331606", "bodyText": "I wonder if we can have an intermediate class AbstractCertProvider that provides createSynchronizationContext() and generateErrorIfCurrentCertExpired() etc.", "author": "dapengzhang0", "createdAt": "2020-11-05T20:03:58Z", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileTime;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for file watching cert provider. */\n+final class FileWatcherCertificateProvider extends CertificateProvider {\n+  private static final Logger logger =\n+      Logger.getLogger(FileWatcherCertificateProvider.class.getName());\n+\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final TimeProvider timeProvider;\n+  private final Path certFile;\n+  private final Path keyFile;\n+  private final Path trustFile;\n+  private final long refreshIntervalInSeconds;\n+  @VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle;\n+  private FileTime lastModifiedTimeCert;\n+  private FileTime lastModifiedTimeKey;\n+  private FileTime lastModifiedTimeRoot;\n+\n+  FileWatcherCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String certFile,\n+      String keyFile,\n+      String trustFile,\n+      long refreshIntervalInSeconds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider) {\n+    super(watcher, notifyCertUpdates);\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.certFile = Paths.get(checkNotNull(certFile, \"certFile\"));\n+    this.keyFile = Paths.get(checkNotNull(keyFile, \"keyFile\"));\n+    this.trustFile = Paths.get(checkNotNull(trustFile, \"trustFile\"));\n+    this.refreshIntervalInSeconds = refreshIntervalInSeconds;\n+    this.syncContext = createSynchronizationContext(certFile);\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {", "originalCommit": "e093fb1e7667d41f57dbe6614e6b1454b153581b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM0NzgzMQ==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518347831", "bodyText": "Yes, that's something I considered too. I will create a TODO item and an issue to refactor this to create the intermediate class after we remove the unused providers.", "author": "sanjaypujare", "createdAt": "2020-11-05T20:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzMTYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzNTY2OA==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518335668", "bodyText": "I'm not wild about calling an essentially private attribute in tests. This does not look like a real usecase. Why calling cancel() followed by checkAndReloadCertificates()?", "author": "dapengzhang0", "createdAt": "2020-11-05T20:11:21Z", "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.scheduledHandle.cancel();", "originalCommit": "e093fb1e7667d41f57dbe6614e6b1454b153581b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1NTk5OQ==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518355999", "bodyText": "That's right, there is no use case for calling cancel() since it is not really exercised in checkAndReloadCertificates(). Will remove it", "author": "sanjaypujare", "createdAt": "2020-11-05T20:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzNTY2OA=="}], "type": "inlineReview"}, {"oid": "de5063efe524f6f7079ef220f7e6914b22ef5cc9", "url": "https://github.com/grpc/grpc-java/commit/de5063efe524f6f7079ef220f7e6914b22ef5cc9", "message": "address review comments", "committedDate": "2020-11-05T21:23:51Z", "type": "commit"}, {"oid": "60af22e1b1d105c8a733aaeb23c5dd03c165d8bd", "url": "https://github.com/grpc/grpc-java/commit/60af22e1b1d105c8a733aaeb23c5dd03c165d8bd", "message": "use Duration parsing for parsing duration with suffix", "committedDate": "2020-11-06T01:29:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNzA3Mw==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r519037073", "bodyText": "The test might take a little too long, 5s. Is it possible to make use of FakeClock for scheduler like other tests are doing?", "author": "dapengzhang0", "createdAt": "2020-11-06T22:29:38Z", "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherErrorUpdates(null, null, 0, 0, (String[]) null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(null, null, SERVER_1_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(null, SERVER_1_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(SERVER_0_PEM_FILE, SERVER_0_KEY_FILE, null, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(SERVER_0_PEM_FILE, null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);", "originalCommit": "60af22e1b1d105c8a733aaeb23c5dd03c165d8bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0ODcyNw==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r519048727", "bodyText": "The problem is the file system timestamp precision is 1 second and the test uses actual files with their time stamps which cannot be faked. Hence 1 sec delay for unequal time stamps", "author": "sanjaypujare", "createdAt": "2020-11-06T23:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNzA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MDIxNQ==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r519050215", "bodyText": "I see. Then can we separate them in multiple tests, each sleeps shorter? So if we run tests in parallel with gradle, it can save some time.", "author": "dapengzhang0", "createdAt": "2020-11-06T23:13:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNzA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUxMjQ5Mg==", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r519512492", "bodyText": "Good idea. Done.", "author": "sanjaypujare", "createdAt": "2020-11-09T01:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNzA3Mw=="}], "type": "inlineReview"}, {"oid": "0018d090cb0bfd5101bb49d33ed7b5d9ad0167b5", "url": "https://github.com/grpc/grpc-java/commit/0018d090cb0bfd5101bb49d33ed7b5d9ad0167b5", "message": "address review comments-2", "committedDate": "2020-11-09T01:41:53Z", "type": "commit"}]}