{"pr_number": 7601, "pr_title": "Add ServerCredentials", "pr_createdAt": "2020-11-07T00:39:52Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7601", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2OTUxMQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r519969511", "bodyText": "This changes the behavior, right? Instead of failing each call now we fail protocol negotiation i.e. just once at the beginning of channel creation. I am okay with that but wondering about backward compatibility for error behavior.", "author": "sanjaypujare", "createdAt": "2020-11-09T16:58:42Z", "path": "alts/src/main/java/io/grpc/alts/AltsServerBuilder.java", "diffHunk": "@@ -172,40 +154,7 @@ public AltsServerBuilder intercept(ServerInterceptor interceptor) {\n   /** {@inheritDoc} */\n   @Override\n   public Server build() {\n-    if (!CheckGcpEnvironment.isOnGcp()) {\n-      if (enableUntrustedAlts) {\n-        logger.log(\n-            Level.WARNING,\n-            \"Untrusted ALTS mode is enabled and we cannot guarantee the trustworthiness of the \"\n-                + \"ALTS handshaker service\");\n-      } else {\n-        Status status =\n-            Status.INTERNAL.withDescription(\"ALTS is only allowed to run on Google Cloud Platform\");\n-        delegate.intercept(new FailingServerInterceptor(status));\n-      }\n-    }\n-\n-    delegate.protocolNegotiator(\n-        AltsProtocolNegotiator.serverAltsProtocolNegotiator(handshakerChannelPool));\n+    delegate.protocolNegotiator(credentialsBuilder.buildProtocolNegotiator());", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3MTY1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r519971656", "bodyText": "This was the same approach taken on client-side. RPCs receive the same error with this approach. The only difference is things like name resolution still occur.", "author": "ejona86", "createdAt": "2020-11-09T17:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2OTUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk3ODg1Ng==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r519978856", "bodyText": "And I remember commenting on the client-side but forgot what the outcome was. SG.", "author": "sanjaypujare", "createdAt": "2020-11-09T17:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2OTUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk4MjY4Mw==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r519982683", "bodyText": "Hmm... Actually, this causes things to react differently on server-side, as the client won't see this and it probably won't be logged. So this is sort of broken. But the server interceptor was probably never even called earlier, as the handshake itself would fail, so it seems like it was already broken.", "author": "ejona86", "createdAt": "2020-11-09T17:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2OTUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk4MTY4NA==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r519981684", "bodyText": "Not part of this PR but would \"... default server provider.\" be more accurate?", "author": "sanjaypujare", "createdAt": "2020-11-09T17:16:07Z", "path": "api/src/main/java/io/grpc/ServerProvider.java", "diffHunk": "@@ -34,28 +33,13 @@\n  */\n @Internal\n public abstract class ServerProvider {\n-  private static final ServerProvider provider = ServiceProviders.load(\n-      ServerProvider.class,\n-      Collections.<Class<?>>emptyList(),\n-      ServerProvider.class.getClassLoader(),\n-      new PriorityAccessor<ServerProvider>() {\n-        @Override\n-        public boolean isAvailable(ServerProvider provider) {\n-          return provider.isAvailable();\n-        }\n-\n-        @Override\n-        public int getPriority(ServerProvider provider) {\n-          return provider.priority();\n-        }\n-      });\n-\n   /**\n    * Returns the ClassLoader-wide default server.", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk4NTkyMw==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r519985923", "bodyText": "Yes, although \"server\" doesn't have to mean the server class. It can simply mean something like \"netty\" here (like you'd say \"apache\" or \"nginx\"). The ServerProvider is how you'd use that server.", "author": "ejona86", "createdAt": "2020-11-09T17:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk4MTY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk4ODA3MQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r519988071", "bodyText": "If we have plans to support binding to a specific IP address, would it make sense to add another method here, like\npublic static ServerBuilder<?> newServerBuilderForPort(String listeningIpAddress, int port, ServerCredentials creds)\n\nFor now we can throw \"UnsupportedOperationException\" for any listeningIpAddress that's not IP_ANY but we at least have the API defined now. And later we can add proper support.\nI think other gRPC languages (C++, Go) do support a server binding to a specific IP address IIRC.", "author": "sanjaypujare", "createdAt": "2020-11-09T17:25:51Z", "path": "api/src/main/java/io/grpc/Grpc.java", "diffHunk": "@@ -124,4 +124,15 @@ private static String authorityFromHostAndPort(String host, int port) {\n       throw new IllegalArgumentException(\"Invalid host or port: \" + host + \" \" + port, ex);\n     }\n   }\n+\n+  /**\n+   * Static factory for creating a new ServerBuilder.\n+   *\n+   * @param port the port to listen on\n+   * @param creds the server identity\n+   */\n+  @ExperimentalApi(\"TODO\")\n+  public static ServerBuilder<?> newServerBuilderForPort(int port, ServerCredentials creds) {", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk4OTg5Ng==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r519989896", "bodyText": "What good is the API if there are no callers and no implementors? And how do you gauge fitness, that it actually solves what is necessary and can be implemented if there are no callers and no implementors? FWIW, I'm not convinced that a string would be the way to go.\nWe can just add such an API when we add the API elsewhere.", "author": "ejona86", "createdAt": "2020-11-09T17:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk4ODA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk5NjE4MQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r519996181", "bodyText": "So we have already made changes to use InetSocketAddress instead of just port. This would make it easy to expose IP address binding in external APIs. So if that is planned for a future PR that sounds good.", "author": "sanjaypujare", "createdAt": "2020-11-09T17:38:01Z", "path": "netty/src/main/java/io/grpc/netty/NettyServerProvider.java", "diffHunk": "@@ -38,5 +39,15 @@ protected int priority() {\n   protected NettyServerBuilder builderForPort(int port) {\n     return NettyServerBuilder.forPort(port);\n   }\n+\n+  @Override\n+  protected NewServerBuilderResult newServerBuilderForPort(int port, ServerCredentials creds) {\n+    ProtocolNegotiators.FromServerCredentialsResult result = ProtocolNegotiators.from(creds);\n+    if (result.error != null) {\n+      return NewServerBuilderResult.error(result.error);\n+    }\n+    return NewServerBuilderResult.serverBuilder(\n+        new NettyServerBuilder(new InetSocketAddress(port), result.negotiator));", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDcxNzk0NA==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520717944", "bodyText": "Should we also have an XdsServerProvider and be part of this registry? Without that  Grpc.newServerBuilderForPort cannot be used to build an XdsServer right?", "author": "sanjaypujare", "createdAt": "2020-11-10T16:55:40Z", "path": "api/src/main/java/io/grpc/ServerRegistry.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Registry of {@link ServerProvider}s. The {@link #getDefaultRegistry default instance} loads", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwMzg0Mw==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520803843", "bodyText": "No, we wouldn't want that. XdsServer behaves dramatically differently that other servers and the user should opt-in to its behavior. Just because you add a dependency on grpc-xds doesn't mean you should be using xDS load balancing in Channels and the xds integration in XdsServer.", "author": "ejona86", "createdAt": "2020-11-10T19:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDcxNzk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY4Mjk4NA==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r522682984", "bodyText": "ok", "author": "sanjaypujare", "createdAt": "2020-11-13T06:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDcxNzk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY5MDI5OQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r522690299", "bodyText": "ok", "author": "sanjaypujare", "createdAt": "2020-11-13T06:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDcxNzk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDcyNjc3Nw==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520726777", "bodyText": "PKCS#8 or later?", "author": "sanjaypujare", "createdAt": "2020-11-10T17:08:05Z", "path": "api/src/main/java/io/grpc/TlsServerCredentials.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import com.google.common.io.ByteStreams;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+/**\n+ * TLS credentials, providing server identity and encryption. Consumers of this credential must\n+ * verify they understand the configuration via the {@link #incomprehensible incomprehensible()}\n+ * method. Unless overridden by a {@code Feature}, server identity is provided via {@link\n+ * #getCertificateChain}, {@link #getPrivateKey}, and {@link #getPrivateKeyPassword}.\n+ */\n+@ExperimentalApi(\"TODO\")\n+public final class TlsServerCredentials extends ServerCredentials {\n+  /**\n+   * Creates an instance using provided certificate chain and private key. Generally they should be\n+   * PEM-encoded and the key is an unencrypted PKCS#8 key (file headers have \"BEGIN CERTIFICATE\" and", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwNDkyMQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520804921", "bodyText": "PKCS#8 isn't a version number. It's a set of standands and #8 is simply the 8th one. https://en.wikipedia.org/wiki/PKCS", "author": "ejona86", "createdAt": "2020-11-10T19:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDcyNjc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDczNTU4MA==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520735580", "bodyText": "Here you don't actually create/manage javax.net.ssl.KeyManager instances so keyManager is a bit misleading but is this to mirror SslContextBuilder usage?", "author": "sanjaypujare", "createdAt": "2020-11-10T17:20:30Z", "path": "api/src/main/java/io/grpc/TlsServerCredentials.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import com.google.common.io.ByteStreams;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+/**\n+ * TLS credentials, providing server identity and encryption. Consumers of this credential must\n+ * verify they understand the configuration via the {@link #incomprehensible incomprehensible()}\n+ * method. Unless overridden by a {@code Feature}, server identity is provided via {@link\n+ * #getCertificateChain}, {@link #getPrivateKey}, and {@link #getPrivateKeyPassword}.\n+ */\n+@ExperimentalApi(\"TODO\")\n+public final class TlsServerCredentials extends ServerCredentials {\n+  /**\n+   * Creates an instance using provided certificate chain and private key. Generally they should be\n+   * PEM-encoded and the key is an unencrypted PKCS#8 key (file headers have \"BEGIN CERTIFICATE\" and\n+   * \"BEGIN PRIVATE KEY\").\n+   */\n+  public static ServerCredentials create(File certChain, File privateKey) throws IOException {\n+    return newBuilder().keyManager(certChain, privateKey).build();\n+  }\n+\n+  /**\n+   * Creates an instance using provided certificate chain and private key. Generally they should be\n+   * PEM-encoded and the key is an unencrypted PKCS#8 key (file headers have \"BEGIN CERTIFICATE\" and\n+   * \"BEGIN PRIVATE KEY\").\n+   *\n+   * <p>The streams will not be automatically closed.\n+   */\n+  public static ServerCredentials create(\n+      InputStream certChain, InputStream privateKey) throws IOException {\n+    return newBuilder().keyManager(certChain, privateKey).build();\n+  }\n+\n+  private final boolean fakeFeature;\n+  private final byte[] certificateChain;\n+  private final byte[] privateKey;\n+  private final String privateKeyPassword;\n+\n+  TlsServerCredentials(Builder builder) {\n+    fakeFeature = builder.fakeFeature;\n+    certificateChain = builder.certificateChain;\n+    privateKey = builder.privateKey;\n+    privateKeyPassword = builder.privateKeyPassword;\n+  }\n+\n+  /**\n+   * The certificate chain, as a new byte array. Generally should be PEM-encoded.\n+   */\n+  public byte[] getCertificateChain() {\n+    return Arrays.copyOf(certificateChain, certificateChain.length);\n+  }\n+\n+  /**\n+   * The private key, as a new byte array. Generally should be in PKCS#8 format. If encrypted,\n+   * {@link #getPrivateKeyPassword} is the decryption key. If unencrypted, the password must be\n+   * {@code null}.\n+   */\n+  public byte[] getPrivateKey() {\n+    return Arrays.copyOf(privateKey, privateKey.length);\n+  }\n+\n+  /** Returns the password to decrypt the private key, or {@code null} if unencrypted. */\n+  public String getPrivateKeyPassword() {\n+    return privateKeyPassword;\n+  }\n+\n+  /**\n+   * Returns an empty set if this credential can be adequately understood via\n+   * the features listed, otherwise returns a hint of features that are lacking\n+   * to understand the configuration to be used for manual debugging.\n+   *\n+   * <p>An \"understood\" feature does not imply the caller is able to fully\n+   * handle the feature. It simply means the caller understands the feature\n+   * enough to use the appropriate APIs to read the configuration. The caller\n+   * may support just a subset of a feature, in which case the caller would\n+   * need to look at the configuration to determine if only the supported\n+   * subset is used.\n+   *\n+   * <p>This method may not be as simple as a set difference. There may be\n+   * multiple features that can independently satisfy a piece of configuration.\n+   * If the configuration is incomprehensible, all such features would be\n+   * returned, even though only one may be necessary.\n+   *\n+   * <p>An empty set does not imply that the credentials are fully understood.\n+   * There may be optional configuration that can be ignored if not understood.\n+   *\n+   * <p>Since {@code Feature} is an {@code enum}, {@code understoodFeatures}\n+   * should generally be an {@link java.util.EnumSet}. {@code\n+   * understoodFeatures} will not be modified.\n+   *\n+   * @param understoodFeatures the features understood by the caller\n+   * @return empty set if the caller can adequately understand the configuration\n+   */\n+  public Set<Feature> incomprehensible(Set<Feature> understoodFeatures) {\n+    Set<Feature> incomprehensible = EnumSet.noneOf(Feature.class);\n+    if (fakeFeature) {\n+      requiredFeature(understoodFeatures, incomprehensible, Feature.FAKE);\n+    }\n+    return Collections.unmodifiableSet(incomprehensible);\n+  }\n+\n+  private static void requiredFeature(\n+      Set<Feature> understoodFeatures, Set<Feature> incomprehensible, Feature feature) {\n+    if (!understoodFeatures.contains(feature)) {\n+      incomprehensible.add(feature);\n+    }\n+  }\n+\n+  /**\n+   * Features to understand TLS configuration. Additional enum values may be added in the future.\n+   */\n+  public enum Feature {\n+    /**\n+     * A feature that no consumer should understand. It should be used for unit testing to confirm\n+     * a call to {@link #incomprehensible incomprehensible()} is implemented properly.\n+     */\n+    FAKE,\n+    ;\n+  }\n+\n+  /** Creates a builder for changing default configuration. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder for {@link TlsServerCredentials}. */\n+  @ExperimentalApi(\"TODO\")\n+  public static final class Builder {\n+    private boolean fakeFeature;\n+    private byte[] certificateChain;\n+    private byte[] privateKey;\n+    private String privateKeyPassword;\n+\n+    private Builder() {}\n+\n+    /**\n+     * Requires {@link Feature#FAKE} to be understood. For use in testing consumers of this\n+     * credential.\n+     */\n+    public Builder requireFakeFeature() {\n+      fakeFeature = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Creates an instance using provided certificate chain and private key. Generally they should\n+     * be PEM-encoded and the key is an unencrypted PKCS#8 key (file headers have \"BEGIN\n+     * CERTIFICATE\" and \"BEGIN PRIVATE KEY\").\n+     */\n+    public Builder keyManager(File certChain, File privateKey) throws IOException {", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwNjkwNA==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520806904", "bodyText": "Yes, it's a mirror. It configures the key manager, at least in an abstract sense. Since there are many ways to configure keys, it seemed the best term to apply to all of them. In the future it seems quite possible there will be a method that allows specifying the KeyManager directly.\nAnd yes, this is mirroring SslContextBuilder, but it is moreso using the same logic I used when I wrote SslContextBuilder.", "author": "ejona86", "createdAt": "2020-11-10T19:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDczNTU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDczNzI1Mg==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520737252", "bodyText": "For this and the InputStream version, why not also support the privateKeyPassword param (since the Builder already supports it)", "author": "sanjaypujare", "createdAt": "2020-11-10T17:23:02Z", "path": "api/src/main/java/io/grpc/TlsServerCredentials.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import com.google.common.io.ByteStreams;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+/**\n+ * TLS credentials, providing server identity and encryption. Consumers of this credential must\n+ * verify they understand the configuration via the {@link #incomprehensible incomprehensible()}\n+ * method. Unless overridden by a {@code Feature}, server identity is provided via {@link\n+ * #getCertificateChain}, {@link #getPrivateKey}, and {@link #getPrivateKeyPassword}.\n+ */\n+@ExperimentalApi(\"TODO\")\n+public final class TlsServerCredentials extends ServerCredentials {\n+  /**\n+   * Creates an instance using provided certificate chain and private key. Generally they should be\n+   * PEM-encoded and the key is an unencrypted PKCS#8 key (file headers have \"BEGIN CERTIFICATE\" and\n+   * \"BEGIN PRIVATE KEY\").\n+   */\n+  public static ServerCredentials create(File certChain, File privateKey) throws IOException {", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwOTgzOQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520809839", "bodyText": "These are convenience functions. The Builder is supposed to be the \"all powerful\" thing. The point of these methods is to make common cases easier. These conveniences are replacing the existing useTransportSecurity() methods that we have. Note that those didn't even support passwords at all; if you wanted a password you'd have to use SslContextBuilder or similar.\nI added passwords now is because they are trivial for implementations to support, don't pollute the API much in the Builder, are quite aligned with the API being added, and avoids needing a Feature in the future. Passwords are uncommon because they are generally useless and make configuration even harder.", "author": "ejona86", "createdAt": "2020-11-10T19:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDczNzI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc0NTczMw==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520745733", "bodyText": "Why does the getter have the comment \"If unencrypted, the password must be null\" ? Shouldn't it be on the setter side?", "author": "sanjaypujare", "createdAt": "2020-11-10T17:35:26Z", "path": "api/src/main/java/io/grpc/TlsServerCredentials.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import com.google.common.io.ByteStreams;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+/**\n+ * TLS credentials, providing server identity and encryption. Consumers of this credential must\n+ * verify they understand the configuration via the {@link #incomprehensible incomprehensible()}\n+ * method. Unless overridden by a {@code Feature}, server identity is provided via {@link\n+ * #getCertificateChain}, {@link #getPrivateKey}, and {@link #getPrivateKeyPassword}.\n+ */\n+@ExperimentalApi(\"TODO\")\n+public final class TlsServerCredentials extends ServerCredentials {\n+  /**\n+   * Creates an instance using provided certificate chain and private key. Generally they should be\n+   * PEM-encoded and the key is an unencrypted PKCS#8 key (file headers have \"BEGIN CERTIFICATE\" and\n+   * \"BEGIN PRIVATE KEY\").\n+   */\n+  public static ServerCredentials create(File certChain, File privateKey) throws IOException {\n+    return newBuilder().keyManager(certChain, privateKey).build();\n+  }\n+\n+  /**\n+   * Creates an instance using provided certificate chain and private key. Generally they should be\n+   * PEM-encoded and the key is an unencrypted PKCS#8 key (file headers have \"BEGIN CERTIFICATE\" and\n+   * \"BEGIN PRIVATE KEY\").\n+   *\n+   * <p>The streams will not be automatically closed.\n+   */\n+  public static ServerCredentials create(\n+      InputStream certChain, InputStream privateKey) throws IOException {\n+    return newBuilder().keyManager(certChain, privateKey).build();\n+  }\n+\n+  private final boolean fakeFeature;\n+  private final byte[] certificateChain;\n+  private final byte[] privateKey;\n+  private final String privateKeyPassword;\n+\n+  TlsServerCredentials(Builder builder) {\n+    fakeFeature = builder.fakeFeature;\n+    certificateChain = builder.certificateChain;\n+    privateKey = builder.privateKey;\n+    privateKeyPassword = builder.privateKeyPassword;\n+  }\n+\n+  /**\n+   * The certificate chain, as a new byte array. Generally should be PEM-encoded.\n+   */\n+  public byte[] getCertificateChain() {\n+    return Arrays.copyOf(certificateChain, certificateChain.length);\n+  }\n+\n+  /**\n+   * The private key, as a new byte array. Generally should be in PKCS#8 format. If encrypted,\n+   * {@link #getPrivateKeyPassword} is the decryption key. If unencrypted, the password must be", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5MDA4NA==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r522390084", "bodyText": "Setter side already had this language. Tweaked language here to \"will be\" instead of \"must be\"", "author": "ejona86", "createdAt": "2020-11-12T20:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc0NTczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc0ODQ3MQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520748471", "bodyText": "unavilable -> unavailable", "author": "sanjaypujare", "createdAt": "2020-11-10T17:39:38Z", "path": "api/src/test/java/io/grpc/ServerRegistryTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link ServerRegistry}. */\n+@RunWith(JUnit4.class)\n+public class ServerRegistryTest {\n+  private int port = 123;\n+  private ServerCredentials creds = new ServerCredentials() {};\n+\n+  @Test\n+  public void register_unavilableProviderThrows() {", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2OTA5NQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520769095", "bodyText": "Instead of throwing an exception here, why not return a result with the error? This exception could be because of bad input arguments too.", "author": "sanjaypujare", "createdAt": "2020-11-10T18:12:11Z", "path": "netty/src/main/java/io/grpc/netty/ProtocolNegotiators.java", "diffHunk": "@@ -167,6 +175,72 @@ public FromChannelCredentialsResult withCallCredentials(CallCredentials callCred\n     }\n   }\n \n+  public static FromServerCredentialsResult from(ServerCredentials creds) {\n+    if (creds instanceof TlsServerCredentials) {\n+      TlsServerCredentials tlsCreds = (TlsServerCredentials) creds;\n+      Set<TlsServerCredentials.Feature> incomprehensible =\n+          tlsCreds.incomprehensible(understoodServerTlsFeatures);\n+      if (!incomprehensible.isEmpty()) {\n+        return FromServerCredentialsResult.error(\n+            \"TLS features not understood: \" + incomprehensible);\n+      }\n+      SslContextBuilder builder = GrpcSslContexts.forServer(\n+          new ByteArrayInputStream(tlsCreds.getCertificateChain()),\n+          new ByteArrayInputStream(tlsCreds.getPrivateKey()),\n+          tlsCreds.getPrivateKeyPassword());\n+      SslContext sslContext;\n+      try {\n+        sslContext = builder.build();\n+      } catch (SSLException ex) {\n+        throw new RuntimeException(", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxOTIzOQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520819239", "bodyText": "I wasn't wild about this as well. The problem is that all the useful information is in the Exception and its causal chain. There's no good way to combine multiple Exceptions from different sources together without suppressed exceptions.\nI was fine with throwing on bad input arguments or if the platform was messed up in some way. The main case that I think is poorly served is if the data is in a format that this server can't process but some other server can. Since only the Netty server exists, that's a theoretical discussion. I figured we'd fix it up if/when it became a problem.\nThinking more about the platform issues that might throw here, I think they would be pretty rare. So it would probably be best to make this an IllegalArgumentException.", "author": "ejona86", "createdAt": "2020-11-10T19:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2OTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5MTE5NQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r522391195", "bodyText": "Swapped to IllegalArgumentException.", "author": "ejona86", "createdAt": "2020-11-12T20:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2OTA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4NTA0Ng==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520785046", "bodyText": "The default is plaintext for this server builder. Should we have an explicit useInsecure or usePlaintext similar to other use cases? I understand there is a backward compatibility issue (and not really related to this PR).", "author": "sanjaypujare", "createdAt": "2020-11-10T18:40:17Z", "path": "netty/src/main/java/io/grpc/netty/NettyServerBuilder.java", "diffHunk": "@@ -631,23 +661,31 @@ NettyServerBuilder setTransportTracerFactory(\n \n   @Override\n   public NettyServerBuilder useTransportSecurity(File certChain, File privateKey) {", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg1MDYzMQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520850631", "bodyText": "I don't see any need to enhance the existing API. ServerCreds should replace it long-term.", "author": "ejona86", "createdAt": "2020-11-10T20:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4NTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4OTgyNg==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r520789826", "bodyText": "This is calling the create(ProtocolNegotiator negotiator) instead of  create(ProtocolNegotiator.ServerFactory negotiator) to match the NettySslContextChannelCredentials behavior. Not sure by design or...", "author": "sanjaypujare", "createdAt": "2020-11-10T18:46:18Z", "path": "netty/src/main/java/io/grpc/netty/NettySslContextServerCredentials.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.netty;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ExperimentalApi;\n+import io.grpc.ServerCredentials;\n+import io.netty.handler.ssl.SslContext;\n+\n+/** A credential that performs TLS with Netty's SslContext as configuration. */\n+@ExperimentalApi(\"There is no plan to make this API stable, given transport API instability\")\n+public final class NettySslContextServerCredentials {\n+  private NettySslContextServerCredentials() {}\n+\n+  /**\n+   * Create a credential using Netty's SslContext as configuration. It must have been configured\n+   * with {@link GrpcSslContexts}, but options could have been overridden.\n+   */\n+  public static ServerCredentials create(SslContext sslContext) {\n+    Preconditions.checkArgument(sslContext.isServer(),\n+        \"Client SSL context can not be used for server\");\n+    GrpcSslContexts.ensureAlpnAndH2Enabled(sslContext.applicationProtocolNegotiator());\n+    return NettyServerCredentials.create(ProtocolNegotiators.serverTls(sslContext));", "originalCommit": "339ee8bb09fa15f9a9317d906b0ba3978dc1c8e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5NjY0NA==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r522396644", "bodyText": "Hmm... Earlier in the process of making this PR I was trying to avoid the Factory when possible. On client-side we really need the factory for lifecycle reasons. But that's not true on server-side. But we do need the factory specifically for TLS to inject the Executor. That will probably need to be redesigned in the future though.\nSince for TLS we really do need to use the factory, I'm glad you pointed this out. I've changed the code to use the Factory consistently within io.grpc.netty and we'll just avoid the factory outside of this package (via the Internal class). XdsServerCreds should be the only thing using the Factory outside of io.grpc.netty, and that's because it may wrap a TLS credential.", "author": "ejona86", "createdAt": "2020-11-12T20:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4OTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjcyNDc5MQ==", "url": "https://github.com/grpc/grpc-java/pull/7601#discussion_r522724791", "bodyText": "Just a reminder to replace with the issue link", "author": "sanjaypujare", "createdAt": "2020-11-13T07:25:32Z", "path": "api/src/main/java/io/grpc/ChoiceServerCredentials.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Provides a list of {@link ServerCredentials}, where any one may be used. The credentials are in\n+ * preference order.\n+ */\n+@ExperimentalApi(\"TODO\")", "originalCommit": "01b991985ccef6eba8aa78a993274680de6e24a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "72f402780339754503c7d30d3cce05bb5a07cd0b", "url": "https://github.com/grpc/grpc-java/commit/72f402780339754503c7d30d3cce05bb5a07cd0b", "message": "api: Add ServerCredentials", "committedDate": "2020-11-13T16:57:51Z", "type": "commit"}, {"oid": "c8fbfb28db319128e6e8662d03cd3a85b4070044", "url": "https://github.com/grpc/grpc-java/commit/c8fbfb28db319128e6e8662d03cd3a85b4070044", "message": "netty: Add ServerCredentials", "committedDate": "2020-11-13T16:57:51Z", "type": "commit"}, {"oid": "2261227d825da930c7dae1e48c1358f1d991d5d4", "url": "https://github.com/grpc/grpc-java/commit/2261227d825da930c7dae1e48c1358f1d991d5d4", "message": "alts: Add ServerCredentials", "committedDate": "2020-11-13T16:57:51Z", "type": "commit"}, {"oid": "c0137cc5a26a0c22becac6dee85e803094571119", "url": "https://github.com/grpc/grpc-java/commit/c0137cc5a26a0c22becac6dee85e803094571119", "message": "Migrate callers to ServerCredentials", "committedDate": "2020-11-13T16:57:51Z", "type": "commit"}, {"oid": "c0137cc5a26a0c22becac6dee85e803094571119", "url": "https://github.com/grpc/grpc-java/commit/c0137cc5a26a0c22becac6dee85e803094571119", "message": "Migrate callers to ServerCredentials", "committedDate": "2020-11-13T16:57:51Z", "type": "forcePushed"}]}