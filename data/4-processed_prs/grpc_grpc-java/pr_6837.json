{"pr_number": 6837, "pr_title": "xds: generate xds-routing config from XdsNameResolver", "pr_createdAt": "2020-03-17T18:56:37Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6837", "timeline": [{"oid": "642f430d6b3d43c68e327a33a111f7c4d6a6797c", "url": "https://github.com/grpc/grpc-java/commit/642f430d6b3d43c68e327a33a111f7c4d6a6797c", "message": "xds: generate xds-routing config from XdsNameResolver", "committedDate": "2020-03-20T06:15:09Z", "type": "forcePushed"}, {"oid": "f6b779baa1f763903cfaaa89f3c6153c3234fba8", "url": "https://github.com/grpc/grpc-java/commit/f6b779baa1f763903cfaaa89f3c6153c3234fba8", "message": "xds: generate xds-routing config from XdsNameResolver", "committedDate": "2020-03-20T06:24:01Z", "type": "commit"}, {"oid": "f6b779baa1f763903cfaaa89f3c6153c3234fba8", "url": "https://github.com/grpc/grpc-java/commit/f6b779baa1f763903cfaaa89f3c6153c3234fba8", "message": "xds: generate xds-routing config from XdsNameResolver", "committedDate": "2020-03-20T06:24:01Z", "type": "forcePushed"}, {"oid": "258b47ceb7e0c99e77b66e3a389c3a1a3eb63da7", "url": "https://github.com/grpc/grpc-java/commit/258b47ceb7e0c99e77b66e3a389c3a1a3eb63da7", "message": "add a javadoc", "committedDate": "2020-03-24T00:02:48Z", "type": "commit"}, {"oid": "52a5622047bff8d065db77bff6fd6513ce6e5213", "url": "https://github.com/grpc/grpc-java/commit/52a5622047bff8d065db77bff6fd6513ce6e5213", "message": "change ConfigUpdate: only one of clusterName and routes field is used", "committedDate": "2020-03-26T22:26:34Z", "type": "commit"}, {"oid": "6593460b48619c3aff6d46c3de56ba109a029302", "url": "https://github.com/grpc/grpc-java/commit/6593460b48619c3aff6d46c3de56ba109a029302", "message": "fix cluster route", "committedDate": "2020-03-26T22:35:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0NDY4Nw==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r398744687", "bodyText": "nit: this is redundant, repeats what the code is expressing.", "author": "voidzcy", "createdAt": "2020-03-26T17:11:47Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -131,9 +137,109 @@ XdsClient createXdsClient() {\n     };\n     xdsClientPool = new RefCountedXdsClientObjectPool(xdsClientFactory);\n     xdsClient = xdsClientPool.getObject();\n-    xdsClient.watchConfigData(authority, new ConfigWatcher() {\n-      @Override\n-      public void onConfigChanged(ConfigUpdate update) {\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl(listener));\n+  }\n+\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+\n+    final Listener2 listener;\n+\n+    ConfigWatcherImpl(Listener2 listener) {\n+      this.listener = listener;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Map<String, ?> config;\n+      if (XdsClientImpl.enablePathMatching && update.getRoutes().size() != 1) {\n+        // Path matching is enabled and the config update is not a single route. Generate", "originalCommit": "258b47ceb7e0c99e77b66e3a389c3a1a3eb63da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MTM4Mg==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r398951382", "bodyText": "nit: this comment is way too verbose. Actually you do not need to say anything as most people would only care about the part for generating service config and reading code logic there makes everything clear.\nAlso, using null values as default is better, with its beauty of representing something unset. ... != null expresses stronger indication for not using its value than !... .isEmpty().", "author": "voidzcy", "createdAt": "2020-03-26T23:28:13Z", "path": "xds/src/main/java/io/grpc/xds/XdsClient.java", "diffHunk": "@@ -63,6 +63,9 @@\n    * be used to generate a service config.\n    */\n   static final class ConfigUpdate {\n+    // Either clusterName or routes is empty, and the other field must not be empty.", "originalCommit": "6593460b48619c3aff6d46c3de56ba109a029302", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MzYxMQ==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r398953611", "bodyText": "Using ^ is hard for readers. Also, I don't think the check is necessary. But if you really want it to prevent bugs, make the expression easier to read.", "author": "voidzcy", "createdAt": "2020-03-26T23:34:56Z", "path": "xds/src/main/java/io/grpc/xds/XdsClient.java", "diffHunk": "@@ -112,7 +115,11 @@ Builder addRoutes(Collection<Route> route) {\n       }\n \n       ConfigUpdate build() {\n-        Preconditions.checkState(clusterName != null, \"clusterName is not set\");\n+        Preconditions.checkState(\n+            clusterName.isEmpty() ^ routes.isEmpty(),", "originalCommit": "6593460b48619c3aff6d46c3de56ba109a029302", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NjEyMg==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r398956122", "bodyText": "Can routeAction be null? Using Optional just adds another (unnecessary) indirection.", "author": "voidzcy", "createdAt": "2020-03-26T23:42:48Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -131,23 +137,129 @@ XdsClient createXdsClient() {\n     };\n     xdsClientPool = new RefCountedXdsClientObjectPool(xdsClientFactory);\n     xdsClient = xdsClientPool.getObject();\n-    xdsClient.watchConfigData(authority, new ConfigWatcher() {\n-      @Override\n-      public void onConfigChanged(ConfigUpdate update) {\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl(listener));\n+  }\n+\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+\n+    final Listener2 listener;\n+\n+    ConfigWatcherImpl(Listener2 listener) {\n+      this.listener = listener;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Map<String, ?> config;\n+      if (update.getRoutes().size() > 1) {\n+        // Path matching is enabled and the config update is not a single route. Generate\n+        // xds-routing lb config.\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Received config update with {0} routes from xDS client {1}\",\n+            update.getRoutes().size(),\n+            xdsClient);\n+        logger.log(\n+            XdsLogLevel.DEBUG,\n+            \"Received config update from xDS client {0}: {1}\",\n+            xdsClient,\n+            update);\n+        List<Object> routes = new ArrayList<>(update.getRoutes().size());\n+        Map<String, Object> actions = new LinkedHashMap<>();\n+        Map<RouteAction, String> exitingActions = new HashMap<>();\n+        for (Route route : update.getRoutes()) {\n+          String service = \"\";\n+          String method = \"\";\n+          String prefix = route.getRouteMatch().getPrefix();\n+          String path = route.getRouteMatch().getPath();\n+          if (!prefix.isEmpty()) {\n+            service = prefix.substring(1, prefix.length() - 1);\n+          } else if (!path.isEmpty()) {\n+            int splitIndex = path.lastIndexOf('/');\n+            service = path.substring(1, splitIndex);\n+            method = path.substring(splitIndex + 1);\n+          }\n+          Map<String, String> methodName = ImmutableMap.of(\"service\", service, \"method\", method);\n+          String actionName;\n+          RouteAction routeAction = route.getRouteAction().get();", "originalCommit": "6593460b48619c3aff6d46c3de56ba109a029302", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3MDA5OA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r399070098", "bodyText": "The conditions of this if-elseif-else is verbose and unclear. Use null value of fields in ConfigUpdate to make this cleaner:\nif (update.clusterName != null) {\n   // CDS\n} else if (update.getRoutes.size() == 1) {\n   // weighted-target\n} else {\n   // xds-routing\n}", "author": "voidzcy", "createdAt": "2020-03-27T07:06:19Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -131,23 +137,129 @@ XdsClient createXdsClient() {\n     };\n     xdsClientPool = new RefCountedXdsClientObjectPool(xdsClientFactory);\n     xdsClient = xdsClientPool.getObject();\n-    xdsClient.watchConfigData(authority, new ConfigWatcher() {\n-      @Override\n-      public void onConfigChanged(ConfigUpdate update) {\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl(listener));\n+  }\n+\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+\n+    final Listener2 listener;\n+\n+    ConfigWatcherImpl(Listener2 listener) {\n+      this.listener = listener;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Map<String, ?> config;\n+      if (update.getRoutes().size() > 1) {", "originalCommit": "6593460b48619c3aff6d46c3de56ba109a029302", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MjQwMA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r399082400", "bodyText": "This whole logic of generating LB configs is complicated, given that each LB config can have recursively nested child policies. Same for config generation in EDS policy (TODO).\nPreviously generating service config with CDS LB config very simple (a raw JSON string, only ~10 lines). But now, it's bad to write all of this here (config generation in EDS policy is probably to be even more complicated). This is unreadable, with three levels of child policy nesting (maps with values of maps with values of maps). We would need to seek for a better approach:\nSimilar to how LB config is parsed (each LB config parser recursively calls child policy's own parser to parse child policy), we can implement a LB config generator for each LB policy so that each config generator generates its own config (recursively use child policy's generator to generate child policies) and put the output together.", "author": "voidzcy", "createdAt": "2020-03-27T07:41:37Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -131,23 +137,129 @@ XdsClient createXdsClient() {\n     };\n     xdsClientPool = new RefCountedXdsClientObjectPool(xdsClientFactory);\n     xdsClient = xdsClientPool.getObject();\n-    xdsClient.watchConfigData(authority, new ConfigWatcher() {\n-      @Override\n-      public void onConfigChanged(ConfigUpdate update) {\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl(listener));\n+  }\n+\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+\n+    final Listener2 listener;\n+\n+    ConfigWatcherImpl(Listener2 listener) {\n+      this.listener = listener;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Map<String, ?> config;\n+      if (update.getRoutes().size() > 1) {\n+        // Path matching is enabled and the config update is not a single route. Generate\n+        // xds-routing lb config.\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Received config update with {0} routes from xDS client {1}\",\n+            update.getRoutes().size(),\n+            xdsClient);\n+        logger.log(\n+            XdsLogLevel.DEBUG,\n+            \"Received config update from xDS client {0}: {1}\",\n+            xdsClient,\n+            update);\n+        List<Object> routes = new ArrayList<>(update.getRoutes().size());", "originalCommit": "6593460b48619c3aff6d46c3de56ba109a029302", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgzMjA3NA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401832074", "bodyText": "Reorganized code. Seems a little better.", "author": "dapengzhang0", "createdAt": "2020-04-01T18:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MjQwMA=="}], "type": "inlineReview"}, {"oid": "5efa0e6b23cf33f92c4cc75086465caeea621f1f", "url": "https://github.com/grpc/grpc-java/commit/5efa0e6b23cf33f92c4cc75086465caeea621f1f", "message": "refactor ConfigUpdate data", "committedDate": "2020-04-01T16:46:53Z", "type": "commit"}, {"oid": "6e0df959a3702f9d20c9fae984d99235f70ad2bf", "url": "https://github.com/grpc/grpc-java/commit/6e0df959a3702f9d20c9fae984d99235f70ad2bf", "message": "return nullable for getRouteAction()", "committedDate": "2020-04-01T16:52:30Z", "type": "commit"}, {"oid": "99b210d9c6d123a02b5016aa9db55cd899558762", "url": "https://github.com/grpc/grpc-java/commit/99b210d9c6d123a02b5016aa9db55cd899558762", "message": "simplify if statements", "committedDate": "2020-04-01T16:58:36Z", "type": "commit"}, {"oid": "bfb7c49c60648a44773edbb4aa04e30e6e64910c", "url": "https://github.com/grpc/grpc-java/commit/bfb7c49c60648a44773edbb4aa04e30e6e64910c", "message": "check state for ConfigUpdate builder", "committedDate": "2020-04-01T17:01:59Z", "type": "commit"}, {"oid": "6a174719194c17d33ee4cc560b031c425c58d51d", "url": "https://github.com/grpc/grpc-java/commit/6a174719194c17d33ee4cc560b031c425c58d51d", "message": "refactor onConfigChanged()", "committedDate": "2020-04-01T18:43:30Z", "type": "commit"}, {"oid": "0b86d6ca2f9dc8cb08e6c7492a6d374730edaa96", "url": "https://github.com/grpc/grpc-java/commit/0b86d6ca2f9dc8cb08e6c7492a6d374730edaa96", "message": "reuse generateCdsRawConfig", "committedDate": "2020-04-01T18:49:35Z", "type": "commit"}, {"oid": "0bb372549d2845d7013cb5c81b8628f7c9265523", "url": "https://github.com/grpc/grpc-java/commit/0bb372549d2845d7013cb5c81b8628f7c9265523", "message": "more reorganize", "committedDate": "2020-04-01T18:53:51Z", "type": "commit"}, {"oid": "079c9015ef4d874e2981b151aaf2f88b89b5d795", "url": "https://github.com/grpc/grpc-java/commit/079c9015ef4d874e2981b151aaf2f88b89b5d795", "message": "remove debug log because it is logge in service config", "committedDate": "2020-04-01T18:58:45Z", "type": "commit"}, {"oid": "079c9015ef4d874e2981b151aaf2f88b89b5d795", "url": "https://github.com/grpc/grpc-java/commit/079c9015ef4d874e2981b151aaf2f88b89b5d795", "message": "remove debug log because it is logge in service config", "committedDate": "2020-04-01T18:58:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg0NTA4NA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401845084", "bodyText": "nit: this line should be put one line above.", "author": "voidzcy", "createdAt": "2020-04-01T19:07:21Z", "path": "xds/src/main/java/io/grpc/xds/XdsClient.java", "diffHunk": "@@ -17,13 +17,15 @@\n package io.grpc.xds;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n // TODO(sanjaypujare): remove dependency on envoy data types.\n+import com.google.common.collect.Iterables;", "originalCommit": "079c9015ef4d874e2981b151aaf2f88b89b5d795", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401851804", "bodyText": "Ah... I was wondering how existing test cases in XdsClientImplTest are not affected, this is why. ConfigUpdate intends to be POJO, it's a data class. Its getter should not involve any business logic, it's just for getting a property value. This method doesn't make sense when routes contains more than one items and it should not be called in that case.\nSo I would still leaning towards ConfigUpdate containing a String and a List, with \"oneof\" semantics. XdsClient will set clusterName (String) if path matching is not enabled and leave routes (List) being null, and vice versa for path matching enabled.", "author": "voidzcy", "createdAt": "2020-04-01T19:19:29Z", "path": "xds/src/main/java/io/grpc/xds/XdsClient.java", "diffHunk": "@@ -63,19 +65,18 @@\n    * be used to generate a service config.\n    */\n   static final class ConfigUpdate {\n-    private final String clusterName;\n     private final List<Route> routes;\n \n-    private ConfigUpdate(String clusterName, List<Route> routes) {\n-      this.clusterName = clusterName;\n+    private ConfigUpdate(List<Route> routes) {\n       this.routes = routes;\n     }\n \n+    /** Gets the cluster name for the default route. */\n     String getClusterName() {\n-      return clusterName;\n+      return Iterables.getLast(routes).getRouteAction().getCluster();", "originalCommit": "079c9015ef4d874e2981b151aaf2f88b89b5d795", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxNDEzNg==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401914136", "bodyText": "I agree that getter should not involve business logic, so I removed getClusterName(). It was just  used as a helper method, mostly for making test easy. I'm not a fan of oneof with two nullalbe fields either, because it will add more awkward business logic for XdsNameResolver.  Instead, I define a helper method in the test.", "author": "dapengzhang0", "createdAt": "2020-04-01T21:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzODM1Ng==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401938356", "bodyText": "The logic for not enabling path matching is wired, as you can see in XdsClientImpl, it goes into Route in VirtualHost to populate clusterName but it puts Route into ConfigUpdate and the resolver goes into the Route to populate clusterName again.", "author": "voidzcy", "createdAt": "2020-04-01T22:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk0NTk3Mg==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401945972", "bodyText": "as you can see in XdsClientImpl, it goes into Route in VirtualHost to populate clusterName but it puts Route into ConfigUpdate and the resolver goes into the Route to populate clusterName again.\n\nThe XdsClientImple goes into Route in VirtualHost NOT to populate clusterName, it populates the whole route. (Yeah, it reads clusterName, but that's only for validation and INFO level logging.)\n    if (!enablePathMatching) {\n        EnvoyProtoData.Route defaultRoute = Iterables.getLast(routes);\n        configUpdate =\n            ConfigUpdate.newBuilder()\n                .addRoutes(ImmutableList.of(defaultRoute))\n                .build();\n        logger.log(\n            XdsLogLevel.INFO,\n            \"Found cluster name (inlined in route config): {0}\",\n            defaultRoute.getRouteAction().getCluster());\n      }", "author": "dapengzhang0", "createdAt": "2020-04-01T22:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MjUyMQ==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401952521", "bodyText": "The con of this approach is:\n\nFor path matching not enabled case, XdsNameResolver needs to dig one level deeper to get clusterName. However, for XdsNameResolver, there is no concept of path_matching_enabled.\n\nThe con of oneof approach is:\n\nThe data structure of ConfigUpdate is ugly, and it is so only for the purpose of a usecase that might be migrated away.\nXdsNameResolver need to check null for the oneof fields.\nXdsNameResolver gets clusterName differently for \"path_matching_enabled with single cluster route\" and \"path_matching_disabled\" cases. That makes oneof essentially equivalent of the path_matching_enabled flag.", "author": "dapengzhang0", "createdAt": "2020-04-01T22:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MjcyOQ==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401952729", "bodyText": "You have to populate Route message when path matching is disabled. It needs to validate\n\nwhose match field must contain a prefix field whose value is the empty\nstring and whose route field must be set.\n\nmarkdroth/proposal@2423752#diff-05ea4a5894abbc0261b006741220598cR342-R344\nThis piece of logic is deleted in your last change, you really need to. revert it back.\nEnabling/disabling patch matching runs in separate code paths, having them receiving different content of ConfigUpdate is a desired approach. IMO, using \"oneof\" semantics seems to be the desired way.", "author": "voidzcy", "createdAt": "2020-04-01T22:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1Mzk3Nw==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401953977", "bodyText": "The data structure of ConfigUpdate is ugly, and it is so only for the purpose of a usecase that might be migrated away.\n\nIt's not \"ugly\". The two code paths use different fields in ConfigUpdate, separate code uses separate data, that's elegant. When eliminating one code path, just delete the field it uses.\n\n\nXdsNameResolver need to check null for the oneof fields.\n\n\nThat's the beauty of null here. Elegant and concise meaning of something unset and do not use.", "author": "voidzcy", "createdAt": "2020-04-01T22:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1OTU2OA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401959568", "bodyText": "This piece of logic is deleted in your last change, you really need to. revert it back.\n\nI still have the logic in validateRoutes().", "author": "dapengzhang0", "createdAt": "2020-04-01T23:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2MDcyNg==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401960726", "bodyText": "I missed that one. But, still, I think using \"oneof\" for different code paths makes implementation cleaner as I mentioned above.", "author": "voidzcy", "createdAt": "2020-04-01T23:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2MjkxNA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401962914", "bodyText": "I think we don't have to over-engineer for something that's temporary: the code path split for the enable path matching flag.\nFor me the code path split only in XdsClientImpl is easiest approach.", "author": "dapengzhang0", "createdAt": "2020-04-01T23:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2OTg1Mw==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401969853", "bodyText": "Err... I don't think that's over-engineering, it's about implementation integrity and code style. Alright, I failed to convince you. I am not going to block you on this.", "author": "voidzcy", "createdAt": "2020-04-01T23:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTgwNA=="}], "type": "inlineReview"}, {"oid": "4f962c1c23d4514befcf223bfe06b75e3b9ee275", "url": "https://github.com/grpc/grpc-java/commit/4f962c1c23d4514befcf223bfe06b75e3b9ee275", "message": "fix import", "committedDate": "2020-04-01T20:52:24Z", "type": "commit"}, {"oid": "072f3a62f34ef62129d90066afa4c792208abf99", "url": "https://github.com/grpc/grpc-java/commit/072f3a62f34ef62129d90066afa4c792208abf99", "message": "remove getClusterName() from ConfigUpdate", "committedDate": "2020-04-01T21:10:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2ODU3Mg==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401968572", "bodyText": "This message would be almost unreadable, as serviceConfig is a deeply nested map. We may need a utility that coverts Map<String, ?> to String, but seems would only be useful for visualization. It's nontrivial to implement that.\nSo maybe, we have to delete this log message (or change it to DEBUG?) to avoid printing out tons of hard-to-read data.", "author": "voidzcy", "createdAt": "2020-04-01T23:29:47Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -131,62 +136,160 @@ XdsClient createXdsClient() {\n     };\n     xdsClientPool = new RefCountedXdsClientObjectPool(xdsClientFactory);\n     xdsClient = xdsClientPool.getObject();\n-    xdsClient.watchConfigData(authority, new ConfigWatcher() {\n-      @Override\n-      public void onConfigChanged(ConfigUpdate update) {\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl(listener));\n+  }\n+\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+\n+    final Listener2 listener;\n+\n+    ConfigWatcherImpl(Listener2 listener) {\n+      this.listener = listener;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Map<String, ?> rawLbConfig;\n+      if (update.getRoutes().size() > 1) {\n         logger.log(\n             XdsLogLevel.INFO,\n-            \"Received config update from xDS client {0}: cluster_name={1}\",\n-            xdsClient, update.getClusterName());\n-        String serviceConfig = \"{\\n\"\n-            + \"  \\\"loadBalancingConfig\\\": [\\n\"\n-            + \"    {\\n\"\n-            + \"      \\\"cds_experimental\\\": {\\n\"\n-            + \"        \\\"cluster\\\": \\\"\" + update.getClusterName() + \"\\\"\\n\"\n-            + \"      }\\n\"\n-            + \"    }\\n\"\n-            + \"  ]\\n\"\n-            + \"}\";\n-        Map<String, ?> config;\n-        try {\n-          config = (Map<String, ?>) JsonParser.parse(serviceConfig);\n-        } catch (IOException e) {\n-          listener.onError(\n-              Status.UNKNOWN.withDescription(\"Invalid service config\").withCause(e));\n-          return;\n+            \"Received config update with {0} routes from xDS client {1}\",\n+            update.getRoutes().size(),\n+            xdsClient);\n+        rawLbConfig = generateXdsRoutingRawConfig(update.getRoutes());\n+      } else {\n+        Route defaultRoute = Iterables.getOnlyElement(update.getRoutes());\n+        String clusterName = defaultRoute.getRouteAction().getCluster();\n+        if (!clusterName.isEmpty()) {\n+          logger.log(\n+              XdsLogLevel.INFO,\n+              \"Received config update from xDS client {0}: cluster_name={1}\",\n+              xdsClient,\n+              clusterName);\n+          rawLbConfig = generateCdsRawConfig(clusterName);\n+        } else {\n+          logger.log(\n+              XdsLogLevel.INFO,\n+              \"Received config update with one weighted cluster route from xDS client {0}\",\n+              xdsClient);\n+          List<ClusterWeight> clusterWeights = defaultRoute.getRouteAction().getWeightedCluster();\n+          rawLbConfig = generateWeightedTargetRawConfig(clusterWeights);\n         }\n-        logger.log(XdsLogLevel.INFO, \"Generated service config:\\n{0}\", serviceConfig);\n-        Attributes attrs =\n-            Attributes.newBuilder()\n-                .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n-                .build();\n-        ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(config);\n-        ResolutionResult result =\n-            ResolutionResult.newBuilder()\n-                .setAddresses(ImmutableList.<EquivalentAddressGroup>of())\n-                .setAttributes(attrs)\n-                .setServiceConfig(parsedServiceConfig)\n-                .build();\n-        listener.onResult(result);\n       }\n \n-      @Override\n-      public void onError(Status error) {\n-        // In order to distinguish between IO error and resource not found, which trigger\n-        // different handling, return an empty resolution result to channel for resource not\n-        // found.\n-        // TODO(chengyuanzhang): Returning an empty resolution result based on status code is\n-        //  a temporary solution. More design discussion needs to be done.\n-        if (error.getCode().equals(Code.NOT_FOUND)) {\n-          logger.log(\n-              XdsLogLevel.WARNING,\n-              \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n-          listener.onResult(ResolutionResult.newBuilder().build());\n-          return;\n+      Map<String, ?> serviceConfig =\n+          ImmutableMap.of(\"loadBalancingConfig\", ImmutableList.of(rawLbConfig));\n+      logger.log(XdsLogLevel.INFO, \"Generated service config:\\n{0}\", serviceConfig);", "originalCommit": "072f3a62f34ef62129d90066afa4c792208abf99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3MzMwNQ==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401973305", "bodyText": "Service config is in general a very large, as it contains not only lb config.  I think service config is important logging information and it might worth INFO level. But we need to de-dup ConfigUpdate to avoid logging spam.", "author": "dapengzhang0", "createdAt": "2020-04-01T23:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2ODU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk4MDAzOA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401980038", "bodyText": "I mean, printing out the Map<String, ?> is bad, it's unreadable when it's large. If we have utility to convert Map<String, ?> to a nicely formatted JSON string, that would be the best. But, we don't have such a utility.", "author": "voidzcy", "createdAt": "2020-04-02T00:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2ODU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk4OTc5OA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r401989798", "bodyText": "Use gson reverse parser now.", "author": "dapengzhang0", "createdAt": "2020-04-02T00:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2ODU3Mg=="}], "type": "inlineReview"}, {"oid": "12bd2946c9df06b0076feb0cb5bbd8c4727953bd", "url": "https://github.com/grpc/grpc-java/commit/12bd2946c9df06b0076feb0cb5bbd8c4727953bd", "message": "pretty print", "committedDate": "2020-04-02T00:33:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzY5Mg==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r402673692", "bodyText": "If you only have one test method that alters this configuration, then only need to reset in that test method (or not bother doing it as you are not really altering the system property). Same for XdsClientImplTest.", "author": "voidzcy", "createdAt": "2020-04-03T00:38:07Z", "path": "xds/src/test/java/io/grpc/xds/XdsNameResolverTest.java", "diffHunk": "@@ -175,6 +185,7 @@ public BootstrapInfo readBootstrap() {\n   @After\n   public void tearDown() {\n     xdsNameResolver.shutdown();\n+    XdsClientImpl.enablePathMatching = false;", "originalCommit": "12bd2946c9df06b0076feb0cb5bbd8c4727953bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI1Nw==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r402685257", "bodyText": "Reset in test method may not be executed if the test method fails unless the reset is in finally{} after surrounding the whole test with try {}.", "author": "dapengzhang0", "createdAt": "2020-04-03T01:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5ODU0MQ==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r402698541", "bodyText": "Setting it back to false is completely redundant.", "author": "voidzcy", "createdAt": "2020-04-03T02:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE2MTcxNw==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r403161717", "bodyText": "Alright. But when I remove the reset in this and the other test class, some tests just fail.", "author": "dapengzhang0", "createdAt": "2020-04-03T17:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE3MDYzNQ==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r403170635", "bodyText": "Ah, this is static, so test methods do affect each other... Alright, leave it as is.", "author": "voidzcy", "createdAt": "2020-04-03T17:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjE1NA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r402676154", "bodyText": "nit: name assertCdsChildPolicy. Ditto below.", "author": "voidzcy", "createdAt": "2020-04-03T00:46:49Z", "path": "xds/src/test/java/io/grpc/xds/XdsNameResolverTest.java", "diffHunk": "@@ -330,6 +341,181 @@ public void resolve_resourceUpdated() {\n     assertThat(rawConfigValues).containsExactly(\"cluster\", \"cluster-blade.googleapis.com\");\n   }\n \n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void resolve_resourceUpdated_multipleRoutes() {\n+    XdsClientImpl.enablePathMatching = true;\n+    xdsNameResolver.start(mockListener);\n+    assertThat(responseObservers).hasSize(1);\n+    StreamObserver<DiscoveryResponse> responseObserver = responseObservers.poll();\n+\n+    // Simulate receiving an LDS response that contains routes resolution directly in-line.\n+    List<Route> protoRoutes =\n+        ImmutableList.of(\n+            // path match, routed to cluster\n+            Route.newBuilder()\n+                .setMatch(buildPathMatch(\"fooSvc\", \"hello\"))\n+                .setRoute(buildClusterRoute(\"cluster-hello.googleapis.com\"))\n+                .build(),\n+            // prefix match, routed to cluster\n+            Route.newBuilder()\n+                .setMatch(buildPrefixMatch(\"fooSvc\"))\n+                .setRoute(buildClusterRoute(\"cluster-foo.googleapis.com\"))\n+                .build(),\n+            // path match, routed to weighted clusters\n+            Route.newBuilder()\n+                .setMatch(buildPathMatch(\"barSvc\", \"hello\"))\n+                .setRoute(buildWeightedClusterRoute(ImmutableMap.of(\n+                    \"cluster-hello.googleapis.com\", 40,  \"cluster-hello2.googleapis.com\", 60)))\n+                .build(),\n+            // prefix match, routed to weighted clusters\n+            Route.newBuilder()\n+                .setMatch(buildPrefixMatch(\"barSvc\"))\n+                .setRoute(\n+                    buildWeightedClusterRoute(\n+                        ImmutableMap.of(\n+                            \"cluster-bar.googleapis.com\", 30, \"cluster-bar2.googleapis.com\", 70)))\n+                .build(),\n+            // default, routed to cluster\n+            Route.newBuilder()\n+                .setRoute(buildClusterRoute(\"cluster-hello.googleapis.com\"))\n+                .build());\n+    HttpConnectionManager httpConnectionManager =\n+        HttpConnectionManager.newBuilder()\n+            .setRouteConfig(\n+                buildRouteConfiguration(\n+                    \"route-foo.googleapis.com\", // doesn't matter\n+                    ImmutableList.of(buildVirtualHostForRoutes(AUTHORITY, protoRoutes))))\n+            .build();\n+    List<Any> listeners =\n+        ImmutableList.of(Any.pack(buildListener(AUTHORITY, Any.pack(httpConnectionManager))));\n+    responseObserver.onNext(\n+        buildDiscoveryResponse(\"0\", listeners, XdsClientImpl.ADS_TYPE_URL_LDS,  \"0000\"));\n+\n+    ArgumentCaptor<ResolutionResult> resolutionResultCaptor = ArgumentCaptor.forClass(null);\n+    verify(mockListener).onResult(resolutionResultCaptor.capture());\n+    ResolutionResult result = resolutionResultCaptor.getValue();\n+    assertThat(result.getAddresses()).isEmpty();\n+    Map<String, ?> serviceConfig = (Map<String, ?>) result.getServiceConfig().getConfig();\n+\n+    List<Map<String, ?>> rawLbConfigs =\n+        (List<Map<String, ?>>) serviceConfig.get(\"loadBalancingConfig\");\n+    Map<String, ?> lbConfig = Iterables.getOnlyElement(rawLbConfigs);\n+    assertThat(lbConfig.keySet()).containsExactly(\"xds_routing_experimental\");\n+    Map<String, ?> rawConfigValues = (Map<String, ?>) lbConfig.get(\"xds_routing_experimental\");\n+    assertThat(rawConfigValues.keySet()).containsExactly(\"action\", \"route\");\n+    Map<String, Map<String, ?>> actions =\n+        (Map<String, Map<String, ?>>) rawConfigValues.get(\"action\");\n+    List<Map<String, ?>> routes = (List<Map<String, ?>>) rawConfigValues.get(\"route\");\n+    assertThat(routes).hasSize(5);\n+    for (Map<String, ?> route : routes) {\n+      assertThat(route.keySet()).containsExactly(\"methodName\", \"action\");\n+    }\n+    assertThat((Map<String, ?>) routes.get(0).get(\"methodName\"))\n+        .containsExactly(\"service\", \"fooSvc\", \"method\", \"hello\");\n+    String action0 = (String) routes.get(0).get(\"action\");\n+    assertThat((Map<String, ?>) routes.get(1).get(\"methodName\"))\n+        .containsExactly(\"service\", \"fooSvc\", \"method\", \"\");\n+    String action1 = (String) routes.get(1).get(\"action\");\n+    assertThat((Map<String, ?>) routes.get(2).get(\"methodName\"))\n+        .containsExactly(\"service\", \"barSvc\", \"method\", \"hello\");\n+    String action2 = (String) routes.get(2).get(\"action\");\n+    assertThat((Map<String, ?>) routes.get(3).get(\"methodName\"))\n+        .containsExactly(\"service\", \"barSvc\", \"method\", \"\");\n+    String action3 = (String) routes.get(3).get(\"action\");\n+    assertThat((Map<String, ?>) routes.get(4).get(\"methodName\"))\n+        .containsExactly(\"service\", \"\", \"method\", \"\");\n+    String action4 = (String) routes.get(4).get(\"action\");\n+    assertRouteActionIsCdsPolicy(actions.get(action0), \"cluster-hello.googleapis.com\");\n+    assertRouteActionIsCdsPolicy(actions.get(action1), \"cluster-foo.googleapis.com\");\n+    assertRouteActionIsWeightedTargetPolicy(\n+        actions.get(action2),\n+        ImmutableMap.of(\n+            \"cluster-hello.googleapis.com\", 40,  \"cluster-hello2.googleapis.com\", 60));\n+    assertRouteActionIsWeightedTargetPolicy(\n+        actions.get(action3),\n+        ImmutableMap.of(\n+            \"cluster-bar.googleapis.com\", 30, \"cluster-bar2.googleapis.com\", 70));\n+    assertThat(action4).isEqualTo(action0);\n+\n+    // Simulate receiving another LDS response that tells client to do RDS.\n+    String routeConfigName = \"route-foo.googleapis.com\";\n+    responseObserver.onNext(\n+        buildLdsResponseForRdsResource(\"1\", AUTHORITY, routeConfigName, \"0001\"));\n+\n+    // Client sent an RDS request for resource \"route-foo.googleapis.com\" (Omitted in this test).\n+\n+    // Simulate receiving an RDS response that contains the resource \"route-foo.googleapis.com\"\n+    // with a route resolution for a single weighted cluster route.\n+    Route weightedClustersDefaultRoute =\n+        Route.newBuilder()\n+            .setRoute(buildWeightedClusterRoute(\n+                ImmutableMap.of(\n+                    \"cluster-foo.googleapis.com\", 20, \"cluster-bar.googleapis.com\", 80)))\n+            .build();\n+    List<Any> routeConfigs = ImmutableList.of(\n+        Any.pack(\n+            buildRouteConfiguration(\n+                routeConfigName,\n+                ImmutableList.of(\n+                    buildVirtualHostForRoutes(\n+                        AUTHORITY, ImmutableList.of(weightedClustersDefaultRoute))))));\n+    responseObserver.onNext(\n+        buildDiscoveryResponse(\"0\", routeConfigs, XdsClientImpl.ADS_TYPE_URL_RDS, \"0000\"));\n+\n+    verify(mockListener, times(2)).onResult(resolutionResultCaptor.capture());\n+    result = resolutionResultCaptor.getValue();\n+    assertThat(result.getAddresses()).isEmpty();\n+    serviceConfig = (Map<String, ?>) result.getServiceConfig().getConfig();\n+    rawLbConfigs = (List<Map<String, ?>>) serviceConfig.get(\"loadBalancingConfig\");\n+    lbConfig = Iterables.getOnlyElement(rawLbConfigs);\n+    assertThat(lbConfig.keySet()).containsExactly(WEIGHTED_TARGET_POLICY_NAME);\n+    rawConfigValues = (Map<String, ?>) lbConfig.get(WEIGHTED_TARGET_POLICY_NAME);\n+    assertWeightedTargetConfigClusterWeights(\n+        rawConfigValues,\n+        ImmutableMap.of(\n+            \"cluster-foo.googleapis.com\", 20, \"cluster-bar.googleapis.com\", 80));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static void assertRouteActionIsCdsPolicy(Map<String, ?> action, String clusterName) {", "originalCommit": "12bd2946c9df06b0076feb0cb5bbd8c4727953bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3ODAzNg==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r402678036", "bodyText": "nit: delete this line.", "author": "voidzcy", "createdAt": "2020-04-03T00:53:42Z", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -131,62 +137,165 @@ XdsClient createXdsClient() {\n     };\n     xdsClientPool = new RefCountedXdsClientObjectPool(xdsClientFactory);\n     xdsClient = xdsClientPool.getObject();\n-    xdsClient.watchConfigData(authority, new ConfigWatcher() {\n-      @Override\n-      public void onConfigChanged(ConfigUpdate update) {\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl(listener));\n+  }\n+\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+\n+    final Listener2 listener;\n+\n+    ConfigWatcherImpl(Listener2 listener) {\n+      this.listener = listener;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Map<String, ?> rawLbConfig;\n+      if (update.getRoutes().size() > 1) {\n         logger.log(\n             XdsLogLevel.INFO,\n-            \"Received config update from xDS client {0}: cluster_name={1}\",\n-            xdsClient, update.getClusterName());\n-        String serviceConfig = \"{\\n\"\n-            + \"  \\\"loadBalancingConfig\\\": [\\n\"\n-            + \"    {\\n\"\n-            + \"      \\\"cds_experimental\\\": {\\n\"\n-            + \"        \\\"cluster\\\": \\\"\" + update.getClusterName() + \"\\\"\\n\"\n-            + \"      }\\n\"\n-            + \"    }\\n\"\n-            + \"  ]\\n\"\n-            + \"}\";\n-        Map<String, ?> config;\n-        try {\n-          config = (Map<String, ?>) JsonParser.parse(serviceConfig);\n-        } catch (IOException e) {\n-          listener.onError(\n-              Status.UNKNOWN.withDescription(\"Invalid service config\").withCause(e));\n-          return;\n+            \"Received config update with {0} routes from xDS client {1}\",\n+            update.getRoutes().size(),\n+            xdsClient);\n+        rawLbConfig = generateXdsRoutingRawConfig(update.getRoutes());\n+      } else {\n+        Route defaultRoute = Iterables.getOnlyElement(update.getRoutes());\n+        String clusterName = defaultRoute.getRouteAction().getCluster();\n+        if (!clusterName.isEmpty()) {\n+          logger.log(\n+              XdsLogLevel.INFO,\n+              \"Received config update from xDS client {0}: cluster_name={1}\",\n+              xdsClient,\n+              clusterName);\n+          rawLbConfig = generateCdsRawConfig(clusterName);\n+        } else {\n+          logger.log(\n+              XdsLogLevel.INFO,\n+              \"Received config update with one weighted cluster route from xDS client {0}\",\n+              xdsClient);\n+          List<ClusterWeight> clusterWeights = defaultRoute.getRouteAction().getWeightedCluster();\n+          rawLbConfig = generateWeightedTargetRawConfig(clusterWeights);\n         }\n-        logger.log(XdsLogLevel.INFO, \"Generated service config:\\n{0}\", serviceConfig);\n-        Attributes attrs =\n-            Attributes.newBuilder()\n-                .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n-                .build();\n-        ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(config);\n-        ResolutionResult result =\n-            ResolutionResult.newBuilder()\n-                .setAddresses(ImmutableList.<EquivalentAddressGroup>of())\n-                .setAttributes(attrs)\n-                .setServiceConfig(parsedServiceConfig)\n-                .build();\n-        listener.onResult(result);\n       }\n \n-      @Override\n-      public void onError(Status error) {\n-        // In order to distinguish between IO error and resource not found, which trigger\n-        // different handling, return an empty resolution result to channel for resource not\n-        // found.\n-        // TODO(chengyuanzhang): Returning an empty resolution result based on status code is\n-        //  a temporary solution. More design discussion needs to be done.\n-        if (error.getCode().equals(Code.NOT_FOUND)) {\n-          logger.log(\n-              XdsLogLevel.WARNING,\n-              \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n-          listener.onResult(ResolutionResult.newBuilder().build());\n-          return;\n+      Map<String, ?> serviceConfig =\n+          ImmutableMap.of(\"loadBalancingConfig\", ImmutableList.of(rawLbConfig));\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Generated service config:\\n{0}\",\n+            new Gson().toJson(serviceConfig));\n+      }\n+\n+      Attributes attrs =\n+          Attributes.newBuilder()\n+              .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+              .build();\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(serviceConfig);\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setAddresses(ImmutableList.<EquivalentAddressGroup>of())\n+              .setAttributes(attrs)\n+              .setServiceConfig(parsedServiceConfig)\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      // In order to distinguish between IO error and resource not found, which trigger\n+      // different handling, return an empty resolution result to channel for resource not\n+      // found.\n+      // TODO(chengyuanzhang): Returning an empty resolution result based on status code is\n+      //  a temporary solution. More design discussion needs to be done.\n+      if (error.getCode().equals(Code.NOT_FOUND)) {\n+        logger.log(\n+            XdsLogLevel.WARNING,\n+            \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+        listener.onResult(ResolutionResult.newBuilder().build());\n+        return;\n+      }\n+      listener.onError(Status.UNAVAILABLE.withDescription(error.getDescription()));\n+    }\n+  }\n+\n+  private static Map<String, ?> generateXdsRoutingRawConfig(List<Route> routesUpdate) {\n+    List<Object> routes = new ArrayList<>(routesUpdate.size());\n+    Map<String, Object> actions = new LinkedHashMap<>();\n+    Map<RouteAction, String> exitingActions = new HashMap<>();\n+    for (Route route : routesUpdate) {\n+      String service = \"\";\n+      String method = \"\";\n+      String prefix = route.getRouteMatch().getPrefix();\n+      String path = route.getRouteMatch().getPath();\n+      if (!prefix.isEmpty()) {\n+        service = prefix.substring(1, prefix.length() - 1);\n+      } else if (!path.isEmpty()) {\n+        int splitIndex = path.lastIndexOf('/');\n+        service = path.substring(1, splitIndex);\n+        method = path.substring(splitIndex + 1);\n+      }\n+      Map<String, String> methodName = ImmutableMap.of(\"service\", service, \"method\", method);\n+      String actionName;\n+      RouteAction routeAction = route.getRouteAction();\n+      Map<String, ?> actionPolicy;\n+      if (exitingActions.containsKey(routeAction)) {\n+        actionName = exitingActions.get(routeAction);\n+      } else {\n+        if (!routeAction.getCluster().isEmpty()) {\n+          actionName = \"cds:\" + routeAction.getCluster();\n+          actionPolicy = generateCdsRawConfig(routeAction.getCluster());\n+        } else {\n+          StringBuilder sb = new StringBuilder(\"weighted:\");\n+          List<ClusterWeight> clusterWeights = routeAction.getWeightedCluster();\n+          for (ClusterWeight clusterWeight : clusterWeights) {\n+            sb.append(clusterWeight.getName()).append('_');\n+          }\n+\n+          sb.append(routeAction.hashCode());\n+          actionName = sb.toString();\n+          if (actions.containsKey(actionName)) {\n+            // Just in case of hash collision, append exitingActions.size() to make actionName\n+            // unique. However, in case of collision, when new ConfigUpdate is received, actions\n+            // and actionNames might be associated differently from the previous update, but it\n+            // is just suboptimal and won't cause a problem.\n+            actionName = actionName + \"_\" + exitingActions.size();\n+          }\n+          actionPolicy = generateWeightedTargetRawConfig(clusterWeights);\n         }\n-        listener.onError(Status.UNAVAILABLE.withDescription(error.getDescription()));\n+        exitingActions.put(routeAction, actionName);\n+        List<?> childPolicies = ImmutableList.of(actionPolicy);\n+        actions.put(actionName, ImmutableMap.of(\"childPolicy\", childPolicies));\n       }\n-    });\n+", "originalCommit": "12bd2946c9df06b0076feb0cb5bbd8c4727953bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1ec07ca3b09022b454045a90b7f0ceeb783ef57d", "url": "https://github.com/grpc/grpc-java/commit/1ec07ca3b09022b454045a90b7f0ceeb783ef57d", "message": "remove empty line", "committedDate": "2020-04-03T16:49:19Z", "type": "commit"}, {"oid": "0d8b4ba68075e26d0665cf94e2ff529f52b7b1a5", "url": "https://github.com/grpc/grpc-java/commit/0d8b4ba68075e26d0665cf94e2ff529f52b7b1a5", "message": "rename to assertCdsPolicy()", "committedDate": "2020-04-03T17:01:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE3NTgxOA==", "url": "https://github.com/grpc/grpc-java/pull/6837#discussion_r403175818", "bodyText": "nit: same for the change above. Name this to assertWeightedTargetPolicy.", "author": "voidzcy", "createdAt": "2020-04-03T17:32:10Z", "path": "xds/src/test/java/io/grpc/xds/XdsNameResolverTest.java", "diffHunk": "@@ -330,6 +341,182 @@ public void resolve_resourceUpdated() {\n     assertThat(rawConfigValues).containsExactly(\"cluster\", \"cluster-blade.googleapis.com\");\n   }\n \n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void resolve_resourceUpdated_multipleRoutes() {\n+    XdsClientImpl.enablePathMatching = true;\n+    xdsNameResolver.start(mockListener);\n+    assertThat(responseObservers).hasSize(1);\n+    StreamObserver<DiscoveryResponse> responseObserver = responseObservers.poll();\n+\n+    // Simulate receiving an LDS response that contains routes resolution directly in-line.\n+    List<Route> protoRoutes =\n+        ImmutableList.of(\n+            // path match, routed to cluster\n+            Route.newBuilder()\n+                .setMatch(buildPathMatch(\"fooSvc\", \"hello\"))\n+                .setRoute(buildClusterRoute(\"cluster-hello.googleapis.com\"))\n+                .build(),\n+            // prefix match, routed to cluster\n+            Route.newBuilder()\n+                .setMatch(buildPrefixMatch(\"fooSvc\"))\n+                .setRoute(buildClusterRoute(\"cluster-foo.googleapis.com\"))\n+                .build(),\n+            // path match, routed to weighted clusters\n+            Route.newBuilder()\n+                .setMatch(buildPathMatch(\"barSvc\", \"hello\"))\n+                .setRoute(buildWeightedClusterRoute(ImmutableMap.of(\n+                    \"cluster-hello.googleapis.com\", 40,  \"cluster-hello2.googleapis.com\", 60)))\n+                .build(),\n+            // prefix match, routed to weighted clusters\n+            Route.newBuilder()\n+                .setMatch(buildPrefixMatch(\"barSvc\"))\n+                .setRoute(\n+                    buildWeightedClusterRoute(\n+                        ImmutableMap.of(\n+                            \"cluster-bar.googleapis.com\", 30, \"cluster-bar2.googleapis.com\", 70)))\n+                .build(),\n+            // default, routed to cluster\n+            Route.newBuilder()\n+                .setRoute(buildClusterRoute(\"cluster-hello.googleapis.com\"))\n+                .build());\n+    HttpConnectionManager httpConnectionManager =\n+        HttpConnectionManager.newBuilder()\n+            .setRouteConfig(\n+                buildRouteConfiguration(\n+                    \"route-foo.googleapis.com\", // doesn't matter\n+                    ImmutableList.of(buildVirtualHostForRoutes(AUTHORITY, protoRoutes))))\n+            .build();\n+    List<Any> listeners =\n+        ImmutableList.of(Any.pack(buildListener(AUTHORITY, Any.pack(httpConnectionManager))));\n+    responseObserver.onNext(\n+        buildDiscoveryResponse(\"0\", listeners, XdsClientImpl.ADS_TYPE_URL_LDS,  \"0000\"));\n+\n+    ArgumentCaptor<ResolutionResult> resolutionResultCaptor = ArgumentCaptor.forClass(null);\n+    verify(mockListener).onResult(resolutionResultCaptor.capture());\n+    ResolutionResult result = resolutionResultCaptor.getValue();\n+    assertThat(result.getAddresses()).isEmpty();\n+    Map<String, ?> serviceConfig = (Map<String, ?>) result.getServiceConfig().getConfig();\n+\n+    List<Map<String, ?>> rawLbConfigs =\n+        (List<Map<String, ?>>) serviceConfig.get(\"loadBalancingConfig\");\n+    Map<String, ?> lbConfig = Iterables.getOnlyElement(rawLbConfigs);\n+    assertThat(lbConfig.keySet()).containsExactly(\"xds_routing_experimental\");\n+    Map<String, ?> rawConfigValues = (Map<String, ?>) lbConfig.get(\"xds_routing_experimental\");\n+    assertThat(rawConfigValues.keySet()).containsExactly(\"action\", \"route\");\n+    Map<String, Map<String, ?>> actions =\n+        (Map<String, Map<String, ?>>) rawConfigValues.get(\"action\");\n+    List<Map<String, ?>> routes = (List<Map<String, ?>>) rawConfigValues.get(\"route\");\n+    assertThat(routes).hasSize(5);\n+    for (Map<String, ?> route : routes) {\n+      assertThat(route.keySet()).containsExactly(\"methodName\", \"action\");\n+    }\n+    assertThat((Map<String, ?>) routes.get(0).get(\"methodName\"))\n+        .containsExactly(\"service\", \"fooSvc\", \"method\", \"hello\");\n+    String action0 = (String) routes.get(0).get(\"action\");\n+    assertThat((Map<String, ?>) routes.get(1).get(\"methodName\"))\n+        .containsExactly(\"service\", \"fooSvc\", \"method\", \"\");\n+    String action1 = (String) routes.get(1).get(\"action\");\n+    assertThat((Map<String, ?>) routes.get(2).get(\"methodName\"))\n+        .containsExactly(\"service\", \"barSvc\", \"method\", \"hello\");\n+    String action2 = (String) routes.get(2).get(\"action\");\n+    assertThat((Map<String, ?>) routes.get(3).get(\"methodName\"))\n+        .containsExactly(\"service\", \"barSvc\", \"method\", \"\");\n+    String action3 = (String) routes.get(3).get(\"action\");\n+    assertThat((Map<String, ?>) routes.get(4).get(\"methodName\"))\n+        .containsExactly(\"service\", \"\", \"method\", \"\");\n+    String action4 = (String) routes.get(4).get(\"action\");\n+    assertCdsPolicy(actions.get(action0), \"cluster-hello.googleapis.com\");\n+    assertCdsPolicy(actions.get(action1), \"cluster-foo.googleapis.com\");\n+    assertRouteActionIsWeightedTargetPolicy(\n+        actions.get(action2),\n+        ImmutableMap.of(\n+            \"cluster-hello.googleapis.com\", 40,  \"cluster-hello2.googleapis.com\", 60));\n+    assertRouteActionIsWeightedTargetPolicy(\n+        actions.get(action3),\n+        ImmutableMap.of(\n+            \"cluster-bar.googleapis.com\", 30, \"cluster-bar2.googleapis.com\", 70));\n+    assertThat(action4).isEqualTo(action0);\n+\n+    // Simulate receiving another LDS response that tells client to do RDS.\n+    String routeConfigName = \"route-foo.googleapis.com\";\n+    responseObserver.onNext(\n+        buildLdsResponseForRdsResource(\"1\", AUTHORITY, routeConfigName, \"0001\"));\n+\n+    // Client sent an RDS request for resource \"route-foo.googleapis.com\" (Omitted in this test).\n+\n+    // Simulate receiving an RDS response that contains the resource \"route-foo.googleapis.com\"\n+    // with a route resolution for a single weighted cluster route.\n+    Route weightedClustersDefaultRoute =\n+        Route.newBuilder()\n+            .setRoute(buildWeightedClusterRoute(\n+                ImmutableMap.of(\n+                    \"cluster-foo.googleapis.com\", 20, \"cluster-bar.googleapis.com\", 80)))\n+            .build();\n+    List<Any> routeConfigs = ImmutableList.of(\n+        Any.pack(\n+            buildRouteConfiguration(\n+                routeConfigName,\n+                ImmutableList.of(\n+                    buildVirtualHostForRoutes(\n+                        AUTHORITY, ImmutableList.of(weightedClustersDefaultRoute))))));\n+    responseObserver.onNext(\n+        buildDiscoveryResponse(\"0\", routeConfigs, XdsClientImpl.ADS_TYPE_URL_RDS, \"0000\"));\n+\n+    verify(mockListener, times(2)).onResult(resolutionResultCaptor.capture());\n+    result = resolutionResultCaptor.getValue();\n+    assertThat(result.getAddresses()).isEmpty();\n+    serviceConfig = (Map<String, ?>) result.getServiceConfig().getConfig();\n+    rawLbConfigs = (List<Map<String, ?>>) serviceConfig.get(\"loadBalancingConfig\");\n+    lbConfig = Iterables.getOnlyElement(rawLbConfigs);\n+    assertThat(lbConfig.keySet()).containsExactly(WEIGHTED_TARGET_POLICY_NAME);\n+    rawConfigValues = (Map<String, ?>) lbConfig.get(WEIGHTED_TARGET_POLICY_NAME);\n+    assertWeightedTargetConfigClusterWeights(\n+        rawConfigValues,\n+        ImmutableMap.of(\n+            \"cluster-foo.googleapis.com\", 20, \"cluster-bar.googleapis.com\", 80));\n+  }\n+\n+  /** Asserts that the given action contains a single CDS policy with the given cluster name. */\n+  @SuppressWarnings(\"unchecked\")\n+  private static void assertCdsPolicy(Map<String, ?> action, String clusterName) {\n+    assertThat(action.keySet()).containsExactly(\"childPolicy\");\n+    Map<String, ?> lbConfig =\n+        Iterables.getOnlyElement((List<Map<String, ?>>) action.get(\"childPolicy\"));\n+    assertThat(lbConfig.keySet()).containsExactly(CDS_POLICY_NAME);\n+    Map<String, ?> rawConfigValues = (Map<String, ?>) lbConfig.get(CDS_POLICY_NAME);\n+    assertThat(rawConfigValues).containsExactly(\"cluster\", clusterName);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static void assertRouteActionIsWeightedTargetPolicy(", "originalCommit": "0d8b4ba68075e26d0665cf94e2ff529f52b7b1a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a00ff60419b484f81e2e736a7186f41fee92915d", "url": "https://github.com/grpc/grpc-java/commit/a00ff60419b484f81e2e736a7186f41fee92915d", "message": "rename to assertWeightedTargetPolicy", "committedDate": "2020-04-03T18:15:11Z", "type": "commit"}]}