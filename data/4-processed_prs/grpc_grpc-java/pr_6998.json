{"pr_number": 6998, "pr_title": "rls: add rls-exprimnetal LoadBalancer", "pr_createdAt": "2020-05-01T18:49:58Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6998", "timeline": [{"oid": "04bfc9eecc6a02b1c699771b3f6a5961386de148", "url": "https://github.com/grpc/grpc-java/commit/04bfc9eecc6a02b1c699771b3f6a5961386de148", "message": "rls: add rls-exprimnetal LoadBalancer", "committedDate": "2020-05-01T18:56:18Z", "type": "commit"}, {"oid": "d8a21435937dd6f7e60d837a30d83e1b8a58356d", "url": "https://github.com/grpc/grpc-java/commit/d8a21435937dd6f7e60d837a30d83e1b8a58356d", "message": "Merge remote-tracking branch 'upstream/master' into rls_exp_lb", "committedDate": "2020-05-01T19:09:26Z", "type": "commit"}, {"oid": "8ddd258dd98fbbed2d4c5c5f957149500336ef97", "url": "https://github.com/grpc/grpc-java/commit/8ddd258dd98fbbed2d4c5c5f957149500336ef97", "message": "update todo", "committedDate": "2020-05-01T19:15:06Z", "type": "commit"}, {"oid": "069b38de694554ddf92e9c1ea38aa2f0ca31734f", "url": "https://github.com/grpc/grpc-java/commit/069b38de694554ddf92e9c1ea38aa2f0ca31734f", "message": "add test", "committedDate": "2020-05-04T08:07:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4ODQ1Ng==", "url": "https://github.com/grpc/grpc-java/pull/6998#discussion_r419788456", "bodyText": "Is it possible that lbPolicyConfiguration  == null? If possible, is no-op the right behavior in that case?", "author": "dapengzhang0", "createdAt": "2020-05-04T23:33:40Z", "path": "rls/src/main/java/io/grpc/rls/RlsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ChannelLogger.ChannelLogLevel;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.rls.internal.AdaptiveThrottler;\n+import io.grpc.rls.internal.CachingRlsLbClient;\n+import io.grpc.rls.internal.ChildLbResolvedAddressFactory;\n+import io.grpc.rls.internal.LbPolicyConfiguration;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of {@link LoadBalancer} backed by route lookup service.\n+ */\n+final class RlsLoadBalancer extends LoadBalancer {\n+\n+  private final Helper helper;\n+  @Nullable\n+  private LbPolicyConfiguration lbPolicyConfiguration;\n+  @Nullable\n+  private CachingRlsLbClient routeLookupClient;\n+\n+  RlsLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    LbPolicyConfiguration lbPolicyConfiguration =\n+        (LbPolicyConfiguration) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (lbPolicyConfiguration != null", "originalCommit": "069b38de694554ddf92e9c1ea38aa2f0ca31734f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzU1Ng==", "url": "https://github.com/grpc/grpc-java/pull/6998#discussion_r419807556", "bodyText": "hmm i think it is possible if using no service config and default lb policy is rls. throwing NPE instead of ignoring it.", "author": "creamsoup", "createdAt": "2020-05-05T00:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4ODQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4OTI2MQ==", "url": "https://github.com/grpc/grpc-java/pull/6998#discussion_r419789261", "bodyText": "Include error.", "author": "dapengzhang0", "createdAt": "2020-05-04T23:36:21Z", "path": "rls/src/main/java/io/grpc/rls/RlsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ChannelLogger.ChannelLogLevel;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.rls.internal.AdaptiveThrottler;\n+import io.grpc.rls.internal.CachingRlsLbClient;\n+import io.grpc.rls.internal.ChildLbResolvedAddressFactory;\n+import io.grpc.rls.internal.LbPolicyConfiguration;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of {@link LoadBalancer} backed by route lookup service.\n+ */\n+final class RlsLoadBalancer extends LoadBalancer {\n+\n+  private final Helper helper;\n+  @Nullable\n+  private LbPolicyConfiguration lbPolicyConfiguration;\n+  @Nullable\n+  private CachingRlsLbClient routeLookupClient;\n+\n+  RlsLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    LbPolicyConfiguration lbPolicyConfiguration =\n+        (LbPolicyConfiguration) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (lbPolicyConfiguration != null\n+        && !lbPolicyConfiguration.equals(this.lbPolicyConfiguration)) {\n+      boolean needToConnect = this.lbPolicyConfiguration == null\n+          || !this.lbPolicyConfiguration.getRouteLookupConfig().getLookupService().equals(\n+          lbPolicyConfiguration.getRouteLookupConfig().getLookupService());\n+      if (needToConnect) {\n+        if (routeLookupClient != null) {\n+          routeLookupClient.close();\n+        }\n+        routeLookupClient = CachingRlsLbClient.newBuilder()\n+            .setHelper(helper)\n+            .setLbPolicyConfig(lbPolicyConfiguration)\n+            .setThrottler(AdaptiveThrottler.builder().build())\n+            .setResolvedAddressesFactory(\n+                new ChildLbResolvedAddressFactory(\n+                    resolvedAddresses.getAddresses(), resolvedAddresses.getAttributes()))\n+            .build();\n+      }\n+      // TODO(creamsoup) allow incremental service config update. for initial use case, it is \n+      //  not required.\n+      this.lbPolicyConfiguration = lbPolicyConfiguration;\n+      helper.getChannelLogger()\n+          .log(ChannelLogLevel.INFO, \"LbPolicyConfiguration updated to {0}\", lbPolicyConfiguration);\n+    }\n+  }\n+\n+  @Override\n+  public void requestConnection() {\n+    routeLookupClient.requestConnection();\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(final Status error) {\n+    class ErrorPicker extends SubchannelPicker {\n+      @Override\n+      public PickResult pickSubchannel(PickSubchannelArgs args) {\n+        return PickResult.withError(error);\n+      }\n+\n+      @Override\n+      public String toString() {\n+        return MoreObjects.toStringHelper(this).toString();", "originalCommit": "069b38de694554ddf92e9c1ea38aa2f0ca31734f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5MDIxMQ==", "url": "https://github.com/grpc/grpc-java/pull/6998#discussion_r419790211", "bodyText": "Probably will see lint warnings for using LinkedList rather than ArrayDequeue when import.", "author": "dapengzhang0", "createdAt": "2020-05-04T23:39:39Z", "path": "rls/src/test/java/io/grpc/rls/internal/RlsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.base.Converter;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.ChannelLogger;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.Marshaller;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.NameResolver.Factory;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.PickSubchannelArgsImpl;\n+import io.grpc.lookup.v1.RouteLookupServiceGrpc;\n+import io.grpc.rls.RlsLoadBalancerProvider;\n+import io.grpc.rls.internal.CachingRlsLbClient.RlsPicker;\n+import io.grpc.rls.internal.RlsProtoConverters.RouteLookupResponseConverter;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupResponse;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.GrpcCleanupRule;\n+import java.io.IOException;\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.net.SocketAddress;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nonnull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.AdditionalAnswers;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+@RunWith(JUnit4.class)\n+public class RlsLoadBalancerTest {\n+\n+  @Rule\n+  public final GrpcCleanupRule grpcCleanupRule = new GrpcCleanupRule();\n+  @Rule\n+  public final MockitoRule mocks = MockitoJUnit.rule();\n+\n+  private final DoNotUseDirectScheduledExecutorService fakeScheduledExecutorService =\n+      mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+  private final SynchronizationContext syncContext =\n+      new SynchronizationContext(new UncaughtExceptionHandler() {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new RuntimeException(e);\n+        }\n+      });\n+  private final Helper helper =\n+      mock(Helper.class, AdditionalAnswers.delegatesTo(new FakeHelper()));\n+  private final FakeRlsServerImpl fakeRlsServerImpl = new FakeRlsServerImpl();\n+  private final Deque<FakeSubchannel> subchannels = new LinkedList<>();", "originalCommit": "069b38de694554ddf92e9c1ea38aa2f0ca31734f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwNzY5NQ==", "url": "https://github.com/grpc/grpc-java/pull/6998#discussion_r419807695", "bodyText": "yeah, it is pretty bad they added that check. we should generally ignore it unless it is indeed right, because the warning is you are maybe doing wrong.", "author": "creamsoup", "createdAt": "2020-05-05T00:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5MDIxMQ=="}], "type": "inlineReview"}, {"oid": "5ae14a33e07277d9bee9988852b100bdd1f1bd7c", "url": "https://github.com/grpc/grpc-java/commit/5ae14a33e07277d9bee9988852b100bdd1f1bd7c", "message": "throw NPE when rls lb config is null, improve toString for ErrorPicker", "committedDate": "2020-05-05T00:45:17Z", "type": "commit"}]}