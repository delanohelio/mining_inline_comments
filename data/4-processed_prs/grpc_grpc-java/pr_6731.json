{"pr_number": 6731, "pr_title": "xds: implement WeightedTargetLoadBalancer", "pr_createdAt": "2020-02-20T00:45:39Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6731", "timeline": [{"oid": "ea1fe7f32746b6b9a613f2461f09da87f7af0ee1", "url": "https://github.com/grpc/grpc-java/commit/ea1fe7f32746b6b9a613f2461f09da87f7af0ee1", "message": "xds: implement WeightedTargetLoadBalancer", "committedDate": "2020-02-20T19:42:27Z", "type": "forcePushed"}, {"oid": "dc8da345ee361836c1697529e64bc222170d4696", "url": "https://github.com/grpc/grpc-java/commit/dc8da345ee361836c1697529e64bc222170d4696", "message": "xds: implement WeightedTargetLoadBalancer", "committedDate": "2020-02-20T21:35:33Z", "type": "forcePushed"}, {"oid": "829babcd2bf7b2c89d632d9111b9b261bd27db3d", "url": "https://github.com/grpc/grpc-java/commit/829babcd2bf7b2c89d632d9111b9b261bd27db3d", "message": "xds: implement WeightedTargetLoadBalancer", "committedDate": "2020-02-20T21:37:17Z", "type": "forcePushed"}, {"oid": "2cf623ebb58ff8fa93ef4350596f202125dbc4d9", "url": "https://github.com/grpc/grpc-java/commit/2cf623ebb58ff8fa93ef4350596f202125dbc4d9", "message": "xds: implement WeightedTargetLoadBalancer", "committedDate": "2020-02-20T23:25:27Z", "type": "commit"}, {"oid": "2cf623ebb58ff8fa93ef4350596f202125dbc4d9", "url": "https://github.com/grpc/grpc-java/commit/2cf623ebb58ff8fa93ef4350596f202125dbc4d9", "message": "xds: implement WeightedTargetLoadBalancer", "committedDate": "2020-02-20T23:25:27Z", "type": "forcePushed"}, {"oid": "94ca8f4544a99a0900893bca2fb75eaaab289bba", "url": "https://github.com/grpc/grpc-java/commit/94ca8f4544a99a0900893bca2fb75eaaab289bba", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java into weighted-target-2", "committedDate": "2020-02-26T18:28:04Z", "type": "commit"}, {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "url": "https://github.com/grpc/grpc-java/commit/40d402a0d2aed77afe16fa9cdd9cf23819c78474", "message": "use the new Logger", "committedDate": "2020-02-26T18:35:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3MDUzMg==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r385970532", "bodyText": "Why this is \"cds-lb\"? You can just use normal logger if things have not been finalized.", "author": "voidzcy", "createdAt": "2020-02-28T23:40:08Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.\n+   * The list must not be empty and must not contain duplicate lb configs.\n+   */\n+  WeightedTargetLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        checkNotNull(lbRegistry, \"lbRegistry\"),\n+        WeightedPickerFactory.RANDOM_PICKER_FACTORY);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancer(\n+      Helper helper, LoadBalancerRegistry lbRegistry, WeightedPickerFactory weightedPickerFactory) {\n+    this.helper = helper;\n+    this.lbRegistry = lbRegistry;\n+    this.weightedPickerFactory = weightedPickerFactory;\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NTUyMQ==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r385985521", "bodyText": "nit: delete one empty line.", "author": "voidzcy", "createdAt": "2020-02-29T01:06:33Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(WeightedTargetLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and WeightedTargetLoadBalancerProvider.\n+  public WeightedTargetLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return WEIGHTED_TARGET_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new WeightedTargetLoadBalancer(helper, loadBalancerRegistry());\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> targets = JsonUtil.getObject(rawConfig, \"targets\");\n+      if (targets == null || targets.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No targets provided for weighted_target LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, WeightedChildLbConfig> parsedChildConfigs = new LinkedHashMap<>();\n+      for (String name : targets.keySet()) {\n+        Map<String, ?> rawWeightedTarget = JsonUtil.getObject(targets, name);\n+        if (rawWeightedTarget == null || rawWeightedTarget.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        Double weightD = JsonUtil.getNumber(rawWeightedTarget, \"weight\");\n+        if (weightD == null || weightD < 1) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Wrong weight for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawWeightedTarget, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        int weight = weightD.intValue();\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in weighted_target Lb policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedChildConfigs.put(\n+                name,\n+                new WeightedChildLbConfig(weight, policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+      return ConfigOrError.fromConfig(new WeightedTargetConfig(parsedChildConfigs));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse weighted_target LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  /** Child lb config with weight. */\n+  static final class WeightedChildLbConfig {\n+\n+    final int weight;\n+    final String policyName;\n+    final Object config; // Parsed config.\n+\n+    @VisibleForTesting\n+    WeightedChildLbConfig(int weight, String policyName, Object config) {\n+      this.weight = weight;\n+      this.policyName = policyName;\n+      this.config = config;\n+    }\n+\n+", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MDU5Ng==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386560596", "bodyText": "For any reason this needs to be non-private? I just found all load balancer provider in xds packages seem to have the same issue.", "author": "voidzcy", "createdAt": "2020-03-02T18:11:33Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0OTQxNQ==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386749415", "bodyText": "This is like EDS_POLICY_NAME, which is used by cds lb. CDS_POLICY_NAME will be used by weighted-target-lb. WEIGHTED_TARGET_POLICY_NAME will be used by xds-routing lb. Now only XDS_POLICY_NAME won't be used by other lb.", "author": "dapengzhang0", "createdAt": "2020-03-03T01:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NDE2OQ==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r388674169", "bodyText": "I don't think usages like CdsLoadBalancer) is a good practice. LoadBalancerRegistry is used for looking up some LB policy given the policy name, the caller treats the policy name opaquely (it just blindly as the registry to give the corresponding LB provider). In CDS LB, it's the design/implementation's choice to load EDS policy. CDS policy explicitly knows what it wants and what that is. It should call new EdsLoadBalancerProvider() directly (or even EdsLoadBalancer(...) constructor). Existing way of instantiating child policy is an abuse of registry.", "author": "voidzcy", "createdAt": "2020-03-06T01:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MDc2Mg==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r389080762", "bodyText": "There are two reasons using register:\n\n\nThe EDS balancer is a plugin, the built-in implementation can be deregistered and re-registered with a custom implementation plugin with EDS_POLICY_NAME.\n\n\nIn testing, we can use a fake EDS balancer for testing CDS.", "author": "dapengzhang0", "createdAt": "2020-03-06T18:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwNDYzNQ==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r389204635", "bodyText": "If you look at the javadoc\n/**\n   * Register a provider.\n   *\n   * <p>If the provider's {@link LoadBalancerProvider#isAvailable isAvailable()} returns\n   * {@code false}, this method will throw {@link IllegalArgumentException}.\n   *\n   * <p>If more than one provider with the same {@link LoadBalancerProvider#getPolicyName policy\n   * name} are registered, the one with the highest {@link LoadBalancerProvider#getPriority\n   * priority} will be effective.  If there are more than one name-sake providers rank the highest\n   * priority, the one registered first will be effective.\n   */\n  public synchronized void register(LoadBalancerProvider provider)\nEven \"round_robin\" can be re-registered with different implementations, if multiple round robin lbs are registered, it will pick the one with highest priority.", "author": "dapengzhang0", "createdAt": "2020-03-07T00:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIwOTY5OA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r389209698", "bodyText": "Alright, I accept the current way of looking up registry for creating the downstream EDS policy.", "author": "voidzcy", "createdAt": "2020-03-07T01:00:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MDU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2Njg5NA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386566894", "bodyText": "Same as mentioned in XdsRoutingLoadbalancerProvider, do not use \"child\" as a type name.", "author": "voidzcy", "createdAt": "2020-03-02T18:24:01Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(WeightedTargetLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and WeightedTargetLoadBalancerProvider.\n+  public WeightedTargetLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return WEIGHTED_TARGET_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new WeightedTargetLoadBalancer(helper, loadBalancerRegistry());\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> targets = JsonUtil.getObject(rawConfig, \"targets\");\n+      if (targets == null || targets.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No targets provided for weighted_target LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, WeightedChildLbConfig> parsedChildConfigs = new LinkedHashMap<>();\n+      for (String name : targets.keySet()) {\n+        Map<String, ?> rawWeightedTarget = JsonUtil.getObject(targets, name);\n+        if (rawWeightedTarget == null || rawWeightedTarget.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        Double weightD = JsonUtil.getNumber(rawWeightedTarget, \"weight\");\n+        if (weightD == null || weightD < 1) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Wrong weight for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawWeightedTarget, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        int weight = weightD.intValue();\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in weighted_target Lb policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedChildConfigs.put(\n+                name,\n+                new WeightedChildLbConfig(weight, policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+      return ConfigOrError.fromConfig(new WeightedTargetConfig(parsedChildConfigs));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse weighted_target LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  /** Child lb config with weight. */\n+  static final class WeightedChildLbConfig {", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2NzU1NA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386567554", "bodyText": "nit: comment is redundant.", "author": "voidzcy", "createdAt": "2020-03-02T18:25:23Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(WeightedTargetLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and WeightedTargetLoadBalancerProvider.\n+  public WeightedTargetLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return WEIGHTED_TARGET_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new WeightedTargetLoadBalancer(helper, loadBalancerRegistry());\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> targets = JsonUtil.getObject(rawConfig, \"targets\");\n+      if (targets == null || targets.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No targets provided for weighted_target LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, WeightedChildLbConfig> parsedChildConfigs = new LinkedHashMap<>();\n+      for (String name : targets.keySet()) {\n+        Map<String, ?> rawWeightedTarget = JsonUtil.getObject(targets, name);\n+        if (rawWeightedTarget == null || rawWeightedTarget.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        Double weightD = JsonUtil.getNumber(rawWeightedTarget, \"weight\");\n+        if (weightD == null || weightD < 1) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Wrong weight for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawWeightedTarget, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        int weight = weightD.intValue();\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in weighted_target Lb policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedChildConfigs.put(\n+                name,\n+                new WeightedChildLbConfig(weight, policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+      return ConfigOrError.fromConfig(new WeightedTargetConfig(parsedChildConfigs));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse weighted_target LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  /** Child lb config with weight. */\n+  static final class WeightedChildLbConfig {\n+\n+    final int weight;\n+    final String policyName;\n+    final Object config; // Parsed config.\n+\n+    @VisibleForTesting\n+    WeightedChildLbConfig(int weight, String policyName, Object config) {\n+      this.weight = weight;\n+      this.policyName = policyName;\n+      this.config = config;\n+    }\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      WeightedChildLbConfig that = (WeightedChildLbConfig) o;\n+      return weight == that.weight\n+          && Objects.equals(policyName, that.policyName)\n+          && Objects.equals(config, that.config);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(weight, policyName, config);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"weight\", weight)\n+          .add(\"policyName\", policyName)\n+          .add(\"config\", config)\n+          .toString();\n+    }\n+  }\n+\n+  /** The lb config for WeightedTargetLoadBalancer. */\n+  static final class WeightedTargetConfig {\n+\n+    final Map<String, WeightedChildLbConfig> targets;\n+\n+    /** Constructs a deeply parsed weighted_target config with the given non-empty targets map. */", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU3MDMwOQ==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386570309", "bodyText": "Wrong comment (commenting is redundant).", "author": "voidzcy", "createdAt": "2020-03-02T18:30:19Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU4MzY2OA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386583668", "bodyText": "Although not wrong, I feel like there isn't a strong reason to make a copy.", "author": "voidzcy", "createdAt": "2020-03-02T18:55:08Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(WeightedTargetLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and WeightedTargetLoadBalancerProvider.\n+  public WeightedTargetLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return WEIGHTED_TARGET_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new WeightedTargetLoadBalancer(helper, loadBalancerRegistry());\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> targets = JsonUtil.getObject(rawConfig, \"targets\");\n+      if (targets == null || targets.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No targets provided for weighted_target LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, WeightedChildLbConfig> parsedChildConfigs = new LinkedHashMap<>();\n+      for (String name : targets.keySet()) {\n+        Map<String, ?> rawWeightedTarget = JsonUtil.getObject(targets, name);\n+        if (rawWeightedTarget == null || rawWeightedTarget.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        Double weightD = JsonUtil.getNumber(rawWeightedTarget, \"weight\");\n+        if (weightD == null || weightD < 1) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Wrong weight for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawWeightedTarget, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        int weight = weightD.intValue();\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in weighted_target Lb policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedChildConfigs.put(\n+                name,\n+                new WeightedChildLbConfig(weight, policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+      return ConfigOrError.fromConfig(new WeightedTargetConfig(parsedChildConfigs));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse weighted_target LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  /** Child lb config with weight. */\n+  static final class WeightedChildLbConfig {\n+\n+    final int weight;\n+    final String policyName;\n+    final Object config; // Parsed config.\n+\n+    @VisibleForTesting\n+    WeightedChildLbConfig(int weight, String policyName, Object config) {\n+      this.weight = weight;\n+      this.policyName = policyName;\n+      this.config = config;\n+    }\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      WeightedChildLbConfig that = (WeightedChildLbConfig) o;\n+      return weight == that.weight\n+          && Objects.equals(policyName, that.policyName)\n+          && Objects.equals(config, that.config);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(weight, policyName, config);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"weight\", weight)\n+          .add(\"policyName\", policyName)\n+          .add(\"config\", config)\n+          .toString();\n+    }\n+  }\n+\n+  /** The lb config for WeightedTargetLoadBalancer. */\n+  static final class WeightedTargetConfig {\n+\n+    final Map<String, WeightedChildLbConfig> targets;\n+\n+    /** Constructs a deeply parsed weighted_target config with the given non-empty targets map. */\n+    @VisibleForTesting\n+    WeightedTargetConfig(Map<String, WeightedChildLbConfig> targets) {\n+      this.targets = ImmutableMap.copyOf(targets);", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU4NjczOA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386586738", "bodyText": "nit: commenting is redundant. Same for above and below. Code is already clearly saying what it is doing.", "author": "voidzcy", "createdAt": "2020-03-02T19:00:29Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.\n+   * The list must not be empty and must not contain duplicate lb configs.\n+   */\n+  WeightedTargetLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        checkNotNull(lbRegistry, \"lbRegistry\"),\n+        WeightedPickerFactory.RANDOM_PICKER_FACTORY);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancer(\n+      Helper helper, LoadBalancerRegistry lbRegistry, WeightedPickerFactory weightedPickerFactory) {\n+    this.helper = helper;\n+    this.lbRegistry = lbRegistry;\n+    this.weightedPickerFactory = weightedPickerFactory;\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    Object lbConfig = resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(lbConfig, \"missing weighted_target lb config\");\n+\n+    WeightedTargetConfig weightedTargetConfig = (WeightedTargetConfig) lbConfig;\n+    Map<String, WeightedChildLbConfig> newTargets = weightedTargetConfig.targets;\n+\n+    for (String targetName : newTargets.keySet()) {\n+      WeightedChildLbConfig weightedChildLbConfig = newTargets.get(targetName);\n+      if (!targets.containsKey(targetName)) {\n+        // Create child balancers for new names.\n+        ChildHelper childHelper = new ChildHelper();\n+        GracefulSwitchLoadBalancer childBalancer = new GracefulSwitchLoadBalancer(childHelper);\n+        childBalancer.switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+        childHelpers.put(targetName, childHelper);\n+        childBalancers.put(targetName, childBalancer);\n+      } else if (!weightedChildLbConfig.policyName.equals(targets.get(targetName).policyName)) {\n+        // Policy name change for the same target is not a typical usecase, but we should support", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MDIwOA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386590208", "bodyText": "We may want to make a utility method for this, as it is used in a couple of places (for any load balancers that contain a bunch of child balancers).", "author": "voidzcy", "createdAt": "2020-03-02T19:07:09Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.\n+   * The list must not be empty and must not contain duplicate lb configs.\n+   */\n+  WeightedTargetLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        checkNotNull(lbRegistry, \"lbRegistry\"),\n+        WeightedPickerFactory.RANDOM_PICKER_FACTORY);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancer(\n+      Helper helper, LoadBalancerRegistry lbRegistry, WeightedPickerFactory weightedPickerFactory) {\n+    this.helper = helper;\n+    this.lbRegistry = lbRegistry;\n+    this.weightedPickerFactory = weightedPickerFactory;\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    Object lbConfig = resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(lbConfig, \"missing weighted_target lb config\");\n+\n+    WeightedTargetConfig weightedTargetConfig = (WeightedTargetConfig) lbConfig;\n+    Map<String, WeightedChildLbConfig> newTargets = weightedTargetConfig.targets;\n+\n+    for (String targetName : newTargets.keySet()) {\n+      WeightedChildLbConfig weightedChildLbConfig = newTargets.get(targetName);\n+      if (!targets.containsKey(targetName)) {\n+        // Create child balancers for new names.\n+        ChildHelper childHelper = new ChildHelper();\n+        GracefulSwitchLoadBalancer childBalancer = new GracefulSwitchLoadBalancer(childHelper);\n+        childBalancer.switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+        childHelpers.put(targetName, childHelper);\n+        childBalancers.put(targetName, childBalancer);\n+      } else if (!weightedChildLbConfig.policyName.equals(targets.get(targetName).policyName)) {\n+        // Policy name change for the same target is not a typical usecase, but we should support\n+        // it. Switch child policy.\n+        childBalancers.get(targetName)\n+            .switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+      }\n+    }\n+\n+    // Update new config map.\n+    targets = newTargets;\n+\n+    // Call handleResolvedAddresses() for each child balancer.\n+    for (String targetName : targets.keySet()) {\n+      childBalancers.get(targetName).handleResolvedAddresses(\n+          resolvedAddresses.toBuilder()\n+              .setLoadBalancingPolicyConfig(targets.get(targetName).config)\n+              .build());\n+    }\n+\n+    // Cleanup removed targets.\n+    // TODO(zdapeng): cache removed target for 15 minutes.\n+    for (String targetName : childBalancers.keySet()) {\n+      if (!targets.containsKey(targetName)) {\n+        childBalancers.get(targetName).shutdown();\n+      }\n+    }\n+    childBalancers.keySet().retainAll(targets.keySet());\n+    childHelpers.keySet().retainAll(targets.keySet());\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (childBalancers.isEmpty()) {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (LoadBalancer childBalancer : childBalancers.values()) {\n+      childBalancer.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (LoadBalancer childBalancer : childBalancers.values()) {\n+      childBalancer.shutdown();\n+    }\n+  }\n+\n+  private void updateBalancingState() {\n+    List<WeightedChildPicker> childPickers = new ArrayList<>();\n+\n+    ConnectivityState overallState = null;\n+    for (String name : targets.keySet()) {\n+      ChildHelper childHelper = childHelpers.get(name);\n+      ConnectivityState childState = childHelper.currentState;\n+      overallState = aggregateState(overallState, childState);\n+      if (READY == childState) {\n+        int weight = targets.get(name).weight;\n+        childPickers.add(new WeightedChildPicker(weight, childHelper.currentPicker));\n+      }\n+    }\n+\n+    SubchannelPicker picker;\n+    if (childPickers.isEmpty()) {\n+      if (overallState == TRANSIENT_FAILURE) {\n+        picker = new ErrorPicker(Status.UNAVAILABLE); // TODO: more details in status\n+      } else {\n+        picker = XdsSubchannelPickers.BUFFER_PICKER;\n+      }\n+    } else {\n+      picker = weightedPickerFactory.picker(childPickers);\n+    }\n+\n+    if (overallState != null) {\n+      helper.updateBalancingState(overallState, picker);\n+    }\n+  }\n+\n+  @Nullable\n+  private ConnectivityState aggregateState(", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NjU1MA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386746550", "bodyText": "This is related to #6650. Might do it after the design in general is clear.", "author": "dapengzhang0", "createdAt": "2020-03-03T01:15:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MDIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5Njc3MA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386596770", "bodyText": "WeightedRandomPicker sounds better.", "author": "voidzcy", "createdAt": "2020-03-02T19:19:07Z", "path": "xds/src/main/java/io/grpc/xds/RandomWeightedPicker.java", "diffHunk": "@@ -27,7 +27,7 @@\n import io.grpc.LoadBalancer.SubchannelPicker;\n import java.util.List;\n \n-final class InterLocalityPicker extends SubchannelPicker {\n+final class RandomWeightedPicker extends SubchannelPicker {", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwMzUwMg==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386603502", "bodyText": "Maybe we do not need both RandomWeightedPicker and WeightedPickerFactory (I feel like we are introducing many classes/interfaces that do not seem to be necessary).\nfinal class WeightedRamdomPicker {  // or some better class name\n   private final Random rand;\n   WeightedRamdonPicker(Random rand) {\n      this.rand = rand;\n   }\n   SubchannelPicker picker(List<WeightedChildPicker> childPickers) {  // or some better method name\n      // compute total weight for the list of child pickers, randomly choose one.\n   }\n}", "author": "voidzcy", "createdAt": "2020-03-02T19:31:09Z", "path": "xds/src/main/java/io/grpc/xds/RandomWeightedPicker.java", "diffHunk": "@@ -116,4 +116,17 @@ public String toString() {\n         .add(\"totalWeight\", totalWeight)\n         .toString();\n   }\n+\n+  /** Factory that creates a SubchannelPicker for a given list of weighted child pickers. */\n+  interface WeightedPickerFactory {", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNDU0NA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r390004544", "bodyText": "This comment is outdated.", "author": "voidzcy", "createdAt": "2020-03-09T22:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwMzUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwOTg1MA==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386609850", "bodyText": "nit: you don't need WeightedTargetLoadBalancer.this (may need to change the method name updateBalancingState()).", "author": "voidzcy", "createdAt": "2020-03-02T19:43:55Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.\n+   * The list must not be empty and must not contain duplicate lb configs.\n+   */\n+  WeightedTargetLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        checkNotNull(lbRegistry, \"lbRegistry\"),\n+        WeightedPickerFactory.RANDOM_PICKER_FACTORY);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancer(\n+      Helper helper, LoadBalancerRegistry lbRegistry, WeightedPickerFactory weightedPickerFactory) {\n+    this.helper = helper;\n+    this.lbRegistry = lbRegistry;\n+    this.weightedPickerFactory = weightedPickerFactory;\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    Object lbConfig = resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(lbConfig, \"missing weighted_target lb config\");\n+\n+    WeightedTargetConfig weightedTargetConfig = (WeightedTargetConfig) lbConfig;\n+    Map<String, WeightedChildLbConfig> newTargets = weightedTargetConfig.targets;\n+\n+    for (String targetName : newTargets.keySet()) {\n+      WeightedChildLbConfig weightedChildLbConfig = newTargets.get(targetName);\n+      if (!targets.containsKey(targetName)) {\n+        // Create child balancers for new names.\n+        ChildHelper childHelper = new ChildHelper();\n+        GracefulSwitchLoadBalancer childBalancer = new GracefulSwitchLoadBalancer(childHelper);\n+        childBalancer.switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+        childHelpers.put(targetName, childHelper);\n+        childBalancers.put(targetName, childBalancer);\n+      } else if (!weightedChildLbConfig.policyName.equals(targets.get(targetName).policyName)) {\n+        // Policy name change for the same target is not a typical usecase, but we should support\n+        // it. Switch child policy.\n+        childBalancers.get(targetName)\n+            .switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+      }\n+    }\n+\n+    // Update new config map.\n+    targets = newTargets;\n+\n+    // Call handleResolvedAddresses() for each child balancer.\n+    for (String targetName : targets.keySet()) {\n+      childBalancers.get(targetName).handleResolvedAddresses(\n+          resolvedAddresses.toBuilder()\n+              .setLoadBalancingPolicyConfig(targets.get(targetName).config)\n+              .build());\n+    }\n+\n+    // Cleanup removed targets.\n+    // TODO(zdapeng): cache removed target for 15 minutes.\n+    for (String targetName : childBalancers.keySet()) {\n+      if (!targets.containsKey(targetName)) {\n+        childBalancers.get(targetName).shutdown();\n+      }\n+    }\n+    childBalancers.keySet().retainAll(targets.keySet());\n+    childHelpers.keySet().retainAll(targets.keySet());\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (childBalancers.isEmpty()) {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (LoadBalancer childBalancer : childBalancers.values()) {\n+      childBalancer.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (LoadBalancer childBalancer : childBalancers.values()) {\n+      childBalancer.shutdown();\n+    }\n+  }\n+\n+  private void updateBalancingState() {\n+    List<WeightedChildPicker> childPickers = new ArrayList<>();\n+\n+    ConnectivityState overallState = null;\n+    for (String name : targets.keySet()) {\n+      ChildHelper childHelper = childHelpers.get(name);\n+      ConnectivityState childState = childHelper.currentState;\n+      overallState = aggregateState(overallState, childState);\n+      if (READY == childState) {\n+        int weight = targets.get(name).weight;\n+        childPickers.add(new WeightedChildPicker(weight, childHelper.currentPicker));\n+      }\n+    }\n+\n+    SubchannelPicker picker;\n+    if (childPickers.isEmpty()) {\n+      if (overallState == TRANSIENT_FAILURE) {\n+        picker = new ErrorPicker(Status.UNAVAILABLE); // TODO: more details in status\n+      } else {\n+        picker = XdsSubchannelPickers.BUFFER_PICKER;\n+      }\n+    } else {\n+      picker = weightedPickerFactory.picker(childPickers);\n+    }\n+\n+    if (overallState != null) {\n+      helper.updateBalancingState(overallState, picker);\n+    }\n+  }\n+\n+  @Nullable\n+  private ConnectivityState aggregateState(\n+      @Nullable ConnectivityState overallState, ConnectivityState childState) {\n+    if (overallState == null) {\n+      return childState;\n+    }\n+    if (overallState == READY || childState == READY) {\n+      return READY;\n+    }\n+    if (overallState == CONNECTING || childState == CONNECTING) {\n+      return CONNECTING;\n+    }\n+    if (overallState == IDLE || childState == IDLE) {\n+      return IDLE;\n+    }\n+    return overallState;\n+  }\n+\n+  private final class ChildHelper extends ForwardingLoadBalancerHelper {\n+    ConnectivityState currentState = CONNECTING;\n+    SubchannelPicker currentPicker = BUFFER_PICKER;\n+\n+    @Override\n+    public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+      currentState = newState;\n+      currentPicker = newPicker;\n+      WeightedTargetLoadBalancer.this.updateBalancingState();", "originalCommit": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5014be7307fd6605dc6f9c8988214efac86d0b32", "url": "https://github.com/grpc/grpc-java/commit/5014be7307fd6605dc6f9c8988214efac86d0b32", "message": "fix nits", "committedDate": "2020-03-03T01:21:46Z", "type": "commit"}, {"oid": "c847c313d26a65027f5a76a773a38aaf964e712d", "url": "https://github.com/grpc/grpc-java/commit/c847c313d26a65027f5a76a773a38aaf964e712d", "message": "move RANDOM_PICKER_FACTORY out of factory interface", "committedDate": "2020-03-03T18:25:13Z", "type": "commit"}, {"oid": "dfa75cb6e21119d15ff554ffb4bd008437704152", "url": "https://github.com/grpc/grpc-java/commit/dfa75cb6e21119d15ff554ffb4bd008437704152", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java into weighted-target-2", "committedDate": "2020-03-03T19:25:49Z", "type": "commit"}, {"oid": "ca6c100598a78dcd400a7d51a396e5f7870bbfaa", "url": "https://github.com/grpc/grpc-java/commit/ca6c100598a78dcd400a7d51a396e5f7870bbfaa", "message": "use refactored PolicySelection", "committedDate": "2020-03-03T19:57:17Z", "type": "commit"}, {"oid": "3c33dac834452f0b7a1fb3a5a32073334f4157ef", "url": "https://github.com/grpc/grpc-java/commit/3c33dac834452f0b7a1fb3a5a32073334f4157ef", "message": "fix build", "committedDate": "2020-03-04T18:36:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjQ0NQ==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r389216445", "bodyText": "This class structure does not help with testing at all, as in order to provide your own random number generator in test, you have to implement a fake WeightedPickerFactory instance whose picker(...) method creates a fake SubchannelPicker. So everything about picking is fake. This tests nothing.\nInstead, a better strategy is to not have this constructor at all. You implementation code should always call the constructor with injectable random number generator. In that way, your test code is  still executing the real WeightedRandomPicker but only with the random number generator being faked out.", "author": "voidzcy", "createdAt": "2020-03-07T01:55:15Z", "path": "xds/src/main/java/io/grpc/xds/WeightedRandomPicker.java", "diffHunk": "@@ -62,12 +62,12 @@ public String toString() {\n     }\n   }\n \n-  InterLocalityPicker(List<WeightedChildPicker> weightedChildPickers) {\n+  WeightedRandomPicker(List<WeightedChildPicker> weightedChildPickers) {", "originalCommit": "3c33dac834452f0b7a1fb3a5a32073334f4157ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMTYzMw==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r389921633", "bodyText": "WeightedPickerFactory does not claim to test anything that WeightedRandomPicker does. What WeightedRandomPicker does is well-tested in its own test with a fake random. Using WeightedPickerFactory in LocalityStoreTest/WeightedTargetLoadBalancerTest is to avoid re-testing WeightedRandomPicker. Passing a fake random instead of the factory toLocalityStore/WeightedTargetLoadBalancer in test, you need recalculate the relation between the weights and the fake random number, that's basically following the implementation details of WeightedRandomPicker.\nWe have argued about this a lot of times. When class A uses class B where B is well-tested with its own BTest. Then ATest will just use BFactory. BFactory does not claim to test anything of B. ATest does not claim to test any implementation detail encapsulated in B Using B's constructor arg instead of BFactory in ATest, you are retesting B again.\nNow I revised the class not to use a factory, but I'm still not going to retest the well-encapsulated and well-tested class before EdsLoadBalancer is refactored to use WeightedTargetLoadBalancer.", "author": "dapengzhang0", "createdAt": "2020-03-09T19:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMDgwOQ==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r390020809", "bodyText": "This test strategy is poor. It should be used only when the subcomponent B is heavy (i.e., small interface with large implementation). WeightedRandomPicker is completely an internal implementation of WeightedTargetLoadBalancer/LocalityStore, even though you write it as a modularized subcomponent. It's better even if WeightedRandomPicker is inlined in WeightedTargetLoadBalancer/LocalityStore. But in terms of code reuse, put it into a modularized class. Its implementation is not complex (even somewhat trivial), it's just using a random number generator to choose something in an input list. It is more like a utility. We are not keenly interested in testing the isolated behaviors of this sub-component. Instead, we are more interested in the real output of WeigtedTargetLoadBalancer/LocalityStore, which is the content of picker that eventually propagated to Channel (i.e., helper.updateBalancingState(State, Picker)).\nThe above is just my opinion. I am not going to block you on tests, as long as the class structure is obviously inappropriate. But really, existing tests test barely little real things...", "author": "voidzcy", "createdAt": "2020-03-09T23:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxODE1Mg==", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r389218152", "bodyText": "This looks bad... You should rather call constructor to create a factory or call the factory class to get the instance. At least, not something that is not the factory itself.", "author": "voidzcy", "createdAt": "2020-03-07T02:12:40Z", "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.WeightedRandomPicker.WeightedChildPicker;\n+import io.grpc.xds.WeightedRandomPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedPolicySelection> targets = ImmutableMap.of();\n+\n+  WeightedTargetLoadBalancer(Helper helper) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        WeightedRandomPicker.RANDOM_PICKER_FACTORY);", "originalCommit": "3c33dac834452f0b7a1fb3a5a32073334f4157ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c22b8239f19047b3037e2ce4321055fb64d8b0a0", "url": "https://github.com/grpc/grpc-java/commit/c22b8239f19047b3037e2ce4321055fb64d8b0a0", "message": "call factory.INSTANCE", "committedDate": "2020-03-09T17:40:25Z", "type": "commit"}, {"oid": "5a7e7325e7f7c333b5ec2fcca197d71994c37bca", "url": "https://github.com/grpc/grpc-java/commit/5a7e7325e7f7c333b5ec2fcca197d71994c37bca", "message": "revise tests", "committedDate": "2020-03-09T19:42:38Z", "type": "forcePushed"}, {"oid": "ca310f12b1ef2b2cdb3236c872f5810c5871469c", "url": "https://github.com/grpc/grpc-java/commit/ca310f12b1ef2b2cdb3236c872f5810c5871469c", "message": "revise tests", "committedDate": "2020-03-09T19:45:55Z", "type": "forcePushed"}, {"oid": "9b4ed3ded00cd4004b23d28498b1b179762b137a", "url": "https://github.com/grpc/grpc-java/commit/9b4ed3ded00cd4004b23d28498b1b179762b137a", "message": "revise tests", "committedDate": "2020-03-09T19:57:43Z", "type": "commit"}, {"oid": "9b4ed3ded00cd4004b23d28498b1b179762b137a", "url": "https://github.com/grpc/grpc-java/commit/9b4ed3ded00cd4004b23d28498b1b179762b137a", "message": "revise tests", "committedDate": "2020-03-09T19:57:43Z", "type": "forcePushed"}, {"oid": "ecc6042103b875d13142c346e79737d1ad8afc4c", "url": "https://github.com/grpc/grpc-java/commit/ecc6042103b875d13142c346e79737d1ad8afc4c", "message": "not using immutable copy", "committedDate": "2020-03-09T22:37:42Z", "type": "commit"}]}