{"pr_number": 7458, "pr_title": "xds: refactor resource subscription implementation in XdsClient", "pr_createdAt": "2020-09-25T05:17:57Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7458", "timeline": [{"oid": "972ffb2f6e86b3e4fe77f102beeccd65412f8fc6", "url": "https://github.com/grpc/grpc-java/commit/972ffb2f6e86b3e4fe77f102beeccd65412f8fc6", "message": "Create a ResourceUpdate facade to tracking all types of resources under subscription.", "committedDate": "2020-09-25T05:12:58Z", "type": "commit"}, {"oid": "465c176e0e011a1efbfb1be454957559abcc33a3", "url": "https://github.com/grpc/grpc-java/commit/465c176e0e011a1efbfb1be454957559abcc33a3", "message": "Introduce ResourceSubscriber, which encapsulates the whole tracking logic (initial subscription timeout, data cache, watchers, etc) for a single subscribed resource.", "committedDate": "2020-09-25T05:15:17Z", "type": "commit"}, {"oid": "2d4ef905430b72f809e614914e9284d345986af0", "url": "https://github.com/grpc/grpc-java/commit/2d4ef905430b72f809e614914e9284d345986af0", "message": "Fixed the way of verifying scheduled resource fetching timer in tests.", "committedDate": "2020-09-25T05:15:55Z", "type": "commit"}, {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508", "url": "https://github.com/grpc/grpc-java/commit/78aaf2b2aa348bd6b5ad36ee180f087f563f9508", "message": "Merge branch 'master' of github.com:grpc/grpc-java into refactor/encapsulate_resource_subscription_logic", "committedDate": "2020-09-28T17:02:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzMTA1Nw==", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496131057", "bodyText": "nit: Move this line inside the if block blow.", "author": "dapengzhang0", "createdAt": "2020-09-28T17:52:43Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1025,63 +891,26 @@ private void handleCdsResponse(DiscoveryResponseData cdsResponse) {\n     if (errorMessage != null) {\n       adsStream.sendNackRequest(\n           ResourceType.CDS,\n-          cdsWatchers.keySet(),\n+          cdsResourceSubscribers.keySet(),\n           cdsResponse.getVersionInfo(),\n           errorMessage);\n       return;\n     }\n-    adsStream.sendAckRequest(ResourceType.CDS, cdsWatchers.keySet(),\n+    adsStream.sendAckRequest(ResourceType.CDS, cdsResourceSubscribers.keySet(),\n         cdsResponse.getVersionInfo());\n \n-    // Update local CDS cache with data in this response.\n-    absentCdsResources.removeAll(cdsUpdates.keySet());\n-    for (Map.Entry<String, CdsUpdate> entry : clusterNamesToCdsUpdates.entrySet()) {\n-      if (!cdsUpdates.containsKey(entry.getKey())) {\n-        // Some previously existing resource no longer exists.\n-        absentCdsResources.add(entry.getKey());\n-      } else if (cdsUpdates.get(entry.getKey()).equals(entry.getValue())) {\n-        cdsUpdates.remove(entry.getKey());\n-      }\n-    }\n-    clusterNamesToCdsUpdates.keySet().removeAll(absentCdsResources);\n-    clusterNamesToCdsUpdates.putAll(cdsUpdates);\n-\n-    // Remove EDS cache entries for ClusterLoadAssignments not referenced by this CDS response.\n-    for (String clusterName : clusterNamesToEdsUpdates.keySet()) {\n-      if (!edsServices.contains(clusterName)) {\n-        absentEdsResources.add(clusterName);\n-        // Notify EDS resource removal to watchers.\n-        if (edsWatchers.containsKey(clusterName)) {\n-          Set<EdsResourceWatcher> watchers = edsWatchers.get(clusterName);\n-          for (EdsResourceWatcher watcher : watchers) {\n-            watcher.onResourceDoesNotExist(clusterName);\n-          }\n-        }\n-      }\n-    }\n-    clusterNamesToEdsUpdates.keySet().retainAll(edsServices);\n-\n-    for (String clusterName : cdsUpdates.keySet()) {\n-      if (cdsRespTimers.containsKey(clusterName)) {\n-        cdsRespTimers.get(clusterName).cancel();\n-        cdsRespTimers.remove(clusterName);\n+    for (String resource : cdsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = cdsResourceSubscribers.get(resource);\n+      if (cdsUpdates.containsKey(resource)) {\n+        subscriber.onData(cdsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n       }\n     }\n-\n-    // Notify watchers if clusters interested in present in this CDS response.\n-    for (Map.Entry<String, Set<CdsResourceWatcher>> entry : cdsWatchers.entrySet()) {\n-      String clusterName = entry.getKey();\n-      if (cdsUpdates.containsKey(entry.getKey())) {\n-        CdsUpdate cdsUpdate = cdsUpdates.get(clusterName);\n-        for (CdsResourceWatcher watcher : entry.getValue()) {\n-          watcher.onChanged(cdsUpdate);\n-        }\n-      } else if (!clusterNamesToCdsUpdates.containsKey(entry.getKey())\n-          && !cdsRespTimers.containsKey(clusterName)) {\n-        // Update for previously present resource being removed.\n-        for (CdsResourceWatcher watcher : entry.getValue()) {\n-          watcher.onResourceDoesNotExist(entry.getKey());\n-        }\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);", "originalCommit": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NTc2Ng==", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496185766", "bodyText": "Fixed.", "author": "voidzcy", "createdAt": "2020-09-28T19:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzMTA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTk1Mg==", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496145952", "bodyText": "Need override equals() for LdsUpdate and RdsUpdate.", "author": "dapengzhang0", "createdAt": "2020-09-28T18:19:56Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1333,6 +1150,131 @@ static ResourceType fromTypeUrl(String typeUrl) {\n     }\n   }\n \n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {", "originalCommit": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NTY3OA==", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496185678", "bodyText": "Fixed.", "author": "voidzcy", "createdAt": "2020-09-28T19:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMzA5Nw==", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496203097", "bodyText": "Also RdsUpdate.", "author": "dapengzhang0", "createdAt": "2020-09-28T20:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE2NzkxNw==", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496167917", "bodyText": "Is it equivalent to\nif (!absent) {\n  absent = true;\n  data = null;\n  for (ResourceWatcher watcher : watchers) {\n    watcher.onResourceDoesNotExist(resource);\n  }\n}\n?", "author": "dapengzhang0", "createdAt": "2020-09-28T19:00:13Z", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1333,6 +1150,131 @@ static ResourceType fromTypeUrl(String typeUrl) {\n     }\n   }\n \n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {\n+        for (ResourceWatcher watcher : watchers) {\n+          notifyWatcher(watcher, data);\n+        }\n+      }\n+    }\n+\n+    void onAbsent() {\n+      if (respTimer != null && respTimer.isPending()) {  // too early to conclude absence\n+        return;\n+      }\n+      boolean oldAbsent = absent;\n+      data = null;\n+      absent = true;\n+      if (!oldAbsent) {\n+        for (ResourceWatcher watcher : watchers) {\n+          watcher.onResourceDoesNotExist(resource);\n+        }\n+      }", "originalCommit": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NTU0Mg==", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496185542", "bodyText": "Yes, fixed.", "author": "voidzcy", "createdAt": "2020-09-28T19:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE2NzkxNw=="}], "type": "inlineReview"}, {"oid": "76711e165cbe3b92ac52de33ce3b40d2337126a6", "url": "https://github.com/grpc/grpc-java/commit/76711e165cbe3b92ac52de33ce3b40d2337126a6", "message": "Implement equality methods for LdsUpdate.", "committedDate": "2020-09-28T19:14:59Z", "type": "commit"}, {"oid": "aaebd947dc114e2ac4fe2400bfb93154f4853793", "url": "https://github.com/grpc/grpc-java/commit/aaebd947dc114e2ac4fe2400bfb93154f4853793", "message": "Fix minor style issues.", "committedDate": "2020-09-28T19:34:11Z", "type": "commit"}]}