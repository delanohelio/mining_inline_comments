{"pr_number": 6957, "pr_title": "rls: fake direct scheduled executor supports schedule", "pr_createdAt": "2020-04-21T19:55:17Z", "pr_url": "https://github.com/grpc/grpc-java/pull/6957", "timeline": [{"oid": "c6e4285b97bf6d28790f18dacd60b57aaa6d7e86", "url": "https://github.com/grpc/grpc-java/commit/c6e4285b97bf6d28790f18dacd60b57aaa6d7e86", "message": "rls: add invalidate(Key,Value), move out fake direct scheduled executor", "committedDate": "2020-04-21T20:01:23Z", "type": "commit"}, {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049", "url": "https://github.com/grpc/grpc-java/commit/444a471f34dd53059ea4a5be724f555b7d3b9049", "message": "check return value", "committedDate": "2020-04-21T20:03:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412594860", "bodyText": "get() will trigger LinkedHashMap's access ordering. If the existing value is not the one to be deleted, it will be re-inserted to the tail of the linked list. Maybe\nboolean replaced = delegate.replace(key, new SizedValue(0, value), null);\nif (replaced) {\n  delegate.remove(key);\n  evictionListener.onEviction(key, value, EvictionType.EXPLICIT);\n  return true;\n}\n\nEdited: it's tricky to replace a sized value.", "author": "dapengzhang0", "createdAt": "2020-04-22T01:06:16Z", "path": "rls/src/main/java/io/grpc/rls/internal/LinkedHashLruCache.java", "diffHunk": "@@ -191,6 +191,22 @@ private V invalidate(K key, EvictionType cause) {\n     }\n   }\n \n+  @Override\n+  public final boolean invalidate(K key, V value) {\n+    checkNotNull(key, \"key\");\n+    checkNotNull(value, \"value\");\n+    synchronized (lock) {\n+      SizedValue existing = delegate.get(key);", "originalCommit": "444a471f34dd53059ea4a5be724f555b7d3b9049", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMjgwNg==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412612806", "bodyText": "yes, i didn't really consider the access ordering. thanks", "author": "creamsoup", "createdAt": "2020-04-22T01:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNjI0MQ==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412616241", "bodyText": "unfortunately the replace is java8 api. doesn't seem like there is a good option for java7", "author": "creamsoup", "createdAt": "2020-04-22T02:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE0MDE0OQ==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413140149", "bodyText": "Maybe leave here a TODO with rationale on access ordering and java7 restriction.", "author": "dapengzhang0", "createdAt": "2020-04-22T16:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE0NzEwNw==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413147107", "bodyText": "i am trying to remove this method. and make the caller work around this problem.", "author": "creamsoup", "createdAt": "2020-04-22T16:48:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1MzcyMg==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413153722", "bodyText": "okay removed.", "author": "creamsoup", "createdAt": "2020-04-22T16:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMDg0OA==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412600848", "bodyText": "Seems every method of DoNotUseDirectScheduledExecutorService calls maybeInit(), why not just init these fields directly at their declaration and remove maybeInit().", "author": "dapengzhang0", "createdAt": "2020-04-22T01:24:43Z", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized = false;\n+\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());", "originalCommit": "444a471f34dd53059ea4a5be724f555b7d3b9049", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNDEwOQ==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412614109", "bodyText": "this was due to the CALLS_REAL_METHODS doesn't initialize instance variables. comment will be added.", "author": "creamsoup", "createdAt": "2020-04-22T02:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMDg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEzOTM1Mw==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413139353", "bodyText": "Maybe also add a non-constructor\nprivate DoNotUseDirectScheduledExecutorService() {\n  throw new UnsupportedOperationException(\"this class is for mock only\");\n}\n\nBtw, did you ever consider implementing FakeClock.ScheduledExecutorImpl.scheduleAtFixedRate()? Will there be any problem?", "author": "dapengzhang0", "createdAt": "2020-04-22T16:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMDg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1MDc1Nw==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413150757", "bodyText": "the only reason i didn't implement scheduleAtFixedRate is i don't need it. it can be added if we need. also supporting multiple scheduled tasks is not hard. just don't need it at this point.", "author": "creamsoup", "createdAt": "2020-04-22T16:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMDg0OA=="}], "type": "inlineReview"}, {"oid": "e333ef027cf2bc98ba09e2d98f040e5d42910464", "url": "https://github.com/grpc/grpc-java/commit/e333ef027cf2bc98ba09e2d98f040e5d42910464", "message": "add justification comment for maybeInit", "committedDate": "2020-04-22T02:19:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE0MTg1Mw==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413141853", "bodyText": "Don't set initial value here.", "author": "dapengzhang0", "createdAt": "2020-04-22T16:43:11Z", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized = false;", "originalCommit": "e333ef027cf2bc98ba09e2d98f040e5d42910464", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "612441862ad8d53fa9bac23c90352e1aa37d5080", "url": "https://github.com/grpc/grpc-java/commit/612441862ad8d53fa9bac23c90352e1aa37d5080", "message": "remove invalidate key value", "committedDate": "2020-04-22T16:58:15Z", "type": "commit"}, {"oid": "847b8e88976b9949f44f061fb40e393245b799cd", "url": "https://github.com/grpc/grpc-java/commit/847b8e88976b9949f44f061fb40e393245b799cd", "message": "prevent instantiation for fake scheduled executor", "committedDate": "2020-04-22T17:01:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2NTk2OQ==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413165969", "bodyText": "Why set running = true?", "author": "dapengzhang0", "createdAt": "2020-04-22T17:14:31Z", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private final Object lock = new Object();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      synchronized (lock) {\n+        if (!scheduledFuture.isCancelled()) {\n+          running = true;\n+          command.run();\n+          done = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public synchronized boolean cancel(boolean mayInterruptIfRunning) {\n+        if (running) {\n+          return false;\n+        }\n+        running = true;", "originalCommit": "847b8e88976b9949f44f061fb40e393245b799cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5ODc0MQ==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413198741", "bodyText": "oops probably mistake thanks.", "author": "creamsoup", "createdAt": "2020-04-22T17:59:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2NTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NDA4NQ==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413174085", "bodyText": "If you really want ThreadSafe, isCancelled() and isDone() also need synchronized.", "author": "dapengzhang0", "createdAt": "2020-04-22T17:25:53Z", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private final Object lock = new Object();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      synchronized (lock) {\n+        if (!scheduledFuture.isCancelled()) {\n+          running = true;\n+          command.run();\n+          done = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public synchronized boolean cancel(boolean mayInterruptIfRunning) {", "originalCommit": "847b8e88976b9949f44f061fb40e393245b799cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMTU0OA==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413201548", "bodyText": "yeah removing it makes sense. making it thread safe requires little more work, but it is really meant to be \"direct\".", "author": "creamsoup", "createdAt": "2020-04-22T18:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NDA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NTcyNQ==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413175725", "bodyText": "If you really want to support callers from multiple threads without caller's synchronization, other methods also need synchronized. As javadoc says implementation is not thread-safe,  so synchronized is not necessary.", "author": "dapengzhang0", "createdAt": "2020-04-22T17:28:06Z", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {", "originalCommit": "847b8e88976b9949f44f061fb40e393245b799cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMTk1NA==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413201954", "bodyText": "done.", "author": "creamsoup", "createdAt": "2020-04-22T18:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NzM0OQ==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413177349", "bodyText": "nit: final?", "author": "dapengzhang0", "createdAt": "2020-04-22T17:30:19Z", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {", "originalCommit": "847b8e88976b9949f44f061fb40e393245b799cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3ODc2Mg==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413178762", "bodyText": "nit: private?", "author": "dapengzhang0", "createdAt": "2020-04-22T17:31:36Z", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {", "originalCommit": "847b8e88976b9949f44f061fb40e393245b799cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "579ed15197c282b83d6aaed3e0479f361a0aec0f", "url": "https://github.com/grpc/grpc-java/commit/579ed15197c282b83d6aaed3e0479f361a0aec0f", "message": "remove half baked synchronizations", "committedDate": "2020-04-22T18:11:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxMDA0NA==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413210044", "bodyText": "nit: final", "author": "dapengzhang0", "createdAt": "2020-04-22T18:15:05Z", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  private void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      if (!scheduledFuture.isCancelled()) {\n+        running = true;\n+        command.run();\n+        done = true;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public boolean cancel(boolean mayInterruptIfRunning) {\n+        if (running) {\n+          return false;\n+        }\n+        cancelled = true;\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean isCancelled() {\n+        return cancelled;\n+      }\n+\n+      @Override\n+      public boolean isDone() {\n+        return done;\n+      }\n+\n+      @Override\n+      public Object get() throws InterruptedException, ExecutionException {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public Object get(long timeout, TimeUnit unit)\n+          throws InterruptedException, ExecutionException, TimeoutException {\n+        throw new UnsupportedOperationException();\n+      }\n+    }\n+  }\n+\n+  private static final class ScheduledRunnableComparator\n+      implements Comparator<ScheduledRunnable> {\n+    @Override\n+    public int compare(ScheduledRunnable o1, ScheduledRunnable o2) {\n+      return Long.compare(o1.scheduledTimeNanos, o2.scheduledTimeNanos);\n+    }\n+  }\n+\n+  class FakeTimeProvider implements TimeProvider {", "originalCommit": "579ed15197c282b83d6aaed3e0479f361a0aec0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxMDM2Mw==", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413210363", "bodyText": "nit: final", "author": "dapengzhang0", "createdAt": "2020-04-22T18:15:31Z", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {", "originalCommit": "579ed15197c282b83d6aaed3e0479f361a0aec0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "295dbacce9b22a67a47c75cc8b1d56ef736621b1", "url": "https://github.com/grpc/grpc-java/commit/295dbacce9b22a67a47c75cc8b1d56ef736621b1", "message": "add final keywords", "committedDate": "2020-04-22T18:25:49Z", "type": "commit"}]}