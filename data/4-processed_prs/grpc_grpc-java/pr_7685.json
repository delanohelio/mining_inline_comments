{"pr_number": 7685, "pr_title": "xds: implement xds_cluster_resolver LB policy", "pr_createdAt": "2020-12-01T20:54:54Z", "pr_url": "https://github.com/grpc/grpc-java/pull/7685", "timeline": [{"oid": "ea4517d5e249e02924884d5c4f64ee8d11f7cb0e", "url": "https://github.com/grpc/grpc-java/commit/ea4517d5e249e02924884d5c4f64ee8d11f7cb0e", "message": "Implement cluster_resolver LB policy provider, define the config.", "committedDate": "2020-12-01T20:50:02Z", "type": "commit"}, {"oid": "bba0c7e1eb320d37466593283b78cd71ec30be9c", "url": "https://github.com/grpc/grpc-java/commit/bba0c7e1eb320d37466593283b78cd71ec30be9c", "message": "Add provider test.", "committedDate": "2020-12-01T20:50:22Z", "type": "commit"}, {"oid": "816c859f3dffabdbc5392d9adb1da904fc719121", "url": "https://github.com/grpc/grpc-java/commit/816c859f3dffabdbc5392d9adb1da904fc719121", "message": "Implement cluster_resolver LB policy, which supports resolving a list of underlying clusters (EDS + LogicalDns).", "committedDate": "2020-12-01T20:51:18Z", "type": "commit"}, {"oid": "832d46adb19f95881132c69e99e00bc6641f24a6", "url": "https://github.com/grpc/grpc-java/commit/832d46adb19f95881132c69e99e00bc6641f24a6", "message": "Add cluster_resolver LB policy to LB service loader.", "committedDate": "2020-12-01T20:52:20Z", "type": "commit"}, {"oid": "7a4ade518a4867e75c1efb6806be05e317965847", "url": "https://github.com/grpc/grpc-java/commit/7a4ade518a4867e75c1efb6806be05e317965847", "message": "Remove VisibleForTesting annotation for WeightedTarget config constuctor.", "committedDate": "2020-12-01T20:53:45Z", "type": "commit"}, {"oid": "007eba8a0652053a3d3d76b303c70c0b136f2440", "url": "https://github.com/grpc/grpc-java/commit/007eba8a0652053a3d3d76b303c70c0b136f2440", "message": "Add tests for ClusterResolverLoadBalancer.", "committedDate": "2020-12-03T00:31:00Z", "type": "commit"}, {"oid": "4f49fc3ac0fd479397414b39a70f834a4bac7722", "url": "https://github.com/grpc/grpc-java/commit/4f49fc3ac0fd479397414b39a70f834a4bac7722", "message": "Aggregate cluster resolution state and error status for propagating to downstream or upstream.", "committedDate": "2020-12-03T00:32:23Z", "type": "commit"}, {"oid": "4f49fc3ac0fd479397414b39a70f834a4bac7722", "url": "https://github.com/grpc/grpc-java/commit/4f49fc3ac0fd479397414b39a70f834a4bac7722", "message": "Aggregate cluster resolution state and error status for propagating to downstream or upstream.", "committedDate": "2020-12-03T00:32:23Z", "type": "forcePushed"}, {"oid": "34f409ae89012be85461efac6e2d49ea2ca1167d", "url": "https://github.com/grpc/grpc-java/commit/34f409ae89012be85461efac6e2d49ea2ca1167d", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/implement_cluster_resolver_lb_policy", "committedDate": "2020-12-04T18:48:12Z", "type": "commit"}, {"oid": "785d9079aa1da177b0a6b74fc9654f29e1bf8fff", "url": "https://github.com/grpc/grpc-java/commit/785d9079aa1da177b0a6b74fc9654f29e1bf8fff", "message": "Rename DiscoveryMechanism to ResolutionMechanism to avoid ambiguity.", "committedDate": "2020-12-09T00:49:02Z", "type": "commit"}, {"oid": "afd3b6b042fa19be1764e09db5d4c30fbfba0e99", "url": "https://github.com/grpc/grpc-java/commit/afd3b6b042fa19be1764e09db5d4c30fbfba0e99", "message": "Improve style.", "committedDate": "2020-12-09T00:58:45Z", "type": "commit"}, {"oid": "fa008f80fa1ef97b869764ac223a77dce36946c2", "url": "https://github.com/grpc/grpc-java/commit/fa008f80fa1ef97b869764ac223a77dce36946c2", "message": "Avoid doing more operations than initialization in constructors.", "committedDate": "2020-12-09T19:52:12Z", "type": "commit"}, {"oid": "d9de6bf0606da5ca5756149df8724b8475b7c45d", "url": "https://github.com/grpc/grpc-java/commit/d9de6bf0606da5ca5756149df8724b8475b7c45d", "message": "Rename back to DiscoveryMechanism to be consistent across languages.", "committedDate": "2020-12-09T23:28:32Z", "type": "commit"}, {"oid": "4e531995792559b7113fae5d5349e77be821f081", "url": "https://github.com/grpc/grpc-java/commit/4e531995792559b7113fae5d5349e77be821f081", "message": "Use hardcoded locality and leaf policy name in tests.", "committedDate": "2020-12-10T19:30:18Z", "type": "commit"}, {"oid": "6af90ebf2af8bfe991f39300aa7ac753f0ee9d6f", "url": "https://github.com/grpc/grpc-java/commit/6af90ebf2af8bfe991f39300aa7ac753f0ee9d6f", "message": "Minor improvement: assert watchers are unique in tests.", "committedDate": "2020-12-10T19:50:45Z", "type": "commit"}, {"oid": "2ac59bacd39f8e07ade7bdde02c0962b37fef4c8", "url": "https://github.com/grpc/grpc-java/commit/2ac59bacd39f8e07ade7bdde02c0962b37fef4c8", "message": "Minor improvement: ensure no picker update to upstream.", "committedDate": "2020-12-10T21:26:47Z", "type": "commit"}, {"oid": "2ac59bacd39f8e07ade7bdde02c0962b37fef4c8", "url": "https://github.com/grpc/grpc-java/commit/2ac59bacd39f8e07ade7bdde02c0962b37fef4c8", "message": "Minor improvement: ensure no picker update to upstream.", "committedDate": "2020-12-10T21:26:47Z", "type": "forcePushed"}, {"oid": "5596c67633b47bfd237e714d846efa46f5ecd5a7", "url": "https://github.com/grpc/grpc-java/commit/5596c67633b47bfd237e714d846efa46f5ecd5a7", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/implement_cluster_resolver_lb_policy", "committedDate": "2020-12-15T01:20:32Z", "type": "commit"}, {"oid": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "url": "https://github.com/grpc/grpc-java/commit/69d8a852ae6977ba771dac40a2d3aff54c6ab594", "message": "Pass UpstreamTlsContext through cluster_resolver LB policy.", "committedDate": "2020-12-16T18:44:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjMzODI2Nw==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546338267", "bodyText": "s/cluster_impl/cluster_resolver", "author": "dapengzhang0", "createdAt": "2020-12-20T08:01:11Z", "path": "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the cluster_impl load balancing policy. This class should not be directly", "originalCommit": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ5MDUyMg==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546490522", "bodyText": "nit: this is too verbose. I would just use \"pick_first\" in place.", "author": "dapengzhang0", "createdAt": "2020-12-21T03:22:55Z", "path": "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver;\n+import io.grpc.NameResolver.ResolutionResult;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterImplLoadBalancerProvider.ClusterImplConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EdsResourceWatcher;\n+import io.grpc.xds.XdsClient.EdsUpdate;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cluster_resolver_experimental LB policy. This LB policy is the child LB policy\n+ * of the cds_experimental LB policy and the parent LB policy of the priority_experimental LB\n+ * policy in the xDS load balancing hierarchy. This policy resolves endpoints of non-aggregate\n+ * clusters (e.g., EDS or Logical DNS) and groups endpoints in priorities and localities to be\n+ * used in the downstream LB policies for ine-grained load balancing purposes.\n+ */\n+final class ClusterResolverLoadBalancer extends LoadBalancer {\n+\n+  private static final String LOGICAL_DNS_CLUSTER_ENDPOINT_PICKING_POLICY_OVERRIDE = \"pick_first\";", "originalCommit": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ5MTA2Ng==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546491066", "bodyText": "Use UPPER_CASE for constant?", "author": "dapengzhang0", "createdAt": "2020-12-21T03:25:24Z", "path": "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver;\n+import io.grpc.NameResolver.ResolutionResult;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterImplLoadBalancerProvider.ClusterImplConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EdsResourceWatcher;\n+import io.grpc.xds.XdsClient.EdsUpdate;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cluster_resolver_experimental LB policy. This LB policy is the child LB policy\n+ * of the cds_experimental LB policy and the parent LB policy of the priority_experimental LB\n+ * policy in the xDS load balancing hierarchy. This policy resolves endpoints of non-aggregate\n+ * clusters (e.g., EDS or Logical DNS) and groups endpoints in priorities and localities to be\n+ * used in the downstream LB policies for ine-grained load balancing purposes.\n+ */\n+final class ClusterResolverLoadBalancer extends LoadBalancer {\n+\n+  private static final String LOGICAL_DNS_CLUSTER_ENDPOINT_PICKING_POLICY_OVERRIDE = \"pick_first\";\n+  private static final Locality logicalDnsClusterLocality = new Locality(\"\", \"\", \"\");", "originalCommit": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQyNTkyNg==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r547425926", "bodyText": "Yep, Locality is actually immutable. So sure, it should be upper case. Fixed.", "author": "voidzcy", "createdAt": "2020-12-22T18:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ5MTA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ5NDEwNg==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546494106", "bodyText": "fine-grained?", "author": "dapengzhang0", "createdAt": "2020-12-21T03:40:52Z", "path": "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver;\n+import io.grpc.NameResolver.ResolutionResult;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterImplLoadBalancerProvider.ClusterImplConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EdsResourceWatcher;\n+import io.grpc.xds.XdsClient.EdsUpdate;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cluster_resolver_experimental LB policy. This LB policy is the child LB policy\n+ * of the cds_experimental LB policy and the parent LB policy of the priority_experimental LB\n+ * policy in the xDS load balancing hierarchy. This policy resolves endpoints of non-aggregate\n+ * clusters (e.g., EDS or Logical DNS) and groups endpoints in priorities and localities to be\n+ * used in the downstream LB policies for ine-grained load balancing purposes.", "originalCommit": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU2OTUyMQ==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546569521", "bodyText": "Should move this out of the for loop and ahead of state.start().", "author": "dapengzhang0", "createdAt": "2020-12-21T08:25:23Z", "path": "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver;\n+import io.grpc.NameResolver.ResolutionResult;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterImplLoadBalancerProvider.ClusterImplConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EdsResourceWatcher;\n+import io.grpc.xds.XdsClient.EdsUpdate;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cluster_resolver_experimental LB policy. This LB policy is the child LB policy\n+ * of the cds_experimental LB policy and the parent LB policy of the priority_experimental LB\n+ * policy in the xDS load balancing hierarchy. This policy resolves endpoints of non-aggregate\n+ * clusters (e.g., EDS or Logical DNS) and groups endpoints in priorities and localities to be\n+ * used in the downstream LB policies for ine-grained load balancing purposes.\n+ */\n+final class ClusterResolverLoadBalancer extends LoadBalancer {\n+\n+  private static final String LOGICAL_DNS_CLUSTER_ENDPOINT_PICKING_POLICY_OVERRIDE = \"pick_first\";\n+  private static final Locality logicalDnsClusterLocality = new Locality(\"\", \"\", \"\");\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final GracefulSwitchLoadBalancer delegate;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private ClusterResolverConfig config;\n+\n+  ClusterResolverLoadBalancer(Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(),\n+        new ExponentialBackoffPolicy.Provider());\n+  }\n+\n+  @VisibleForTesting\n+  ClusterResolverLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry,\n+      BackoffPolicy.Provider backoffPolicyProvider) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.authority = checkNotNull(checkNotNull(helper, \"helper\").getAuthority(), \"authority\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    delegate = new GracefulSwitchLoadBalancer(helper);\n+    logger = XdsLogger.withLogId(\n+        InternalLogId.allocate(\"cluster-resolver-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    ClusterResolverConfig config =\n+        (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (!Objects.equals(this.config, config)) {\n+      logger.log(XdsLogLevel.DEBUG, \"Config: {0}\", config);\n+      delegate.switchTo(new ClusterResolverLbStateFactory());\n+    }\n+    this.config = config;\n+    delegate.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    delegate.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    delegate.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class ClusterResolverLbStateFactory extends LoadBalancer.Factory {\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ClusterResolverLbState(helper);\n+    }\n+  }\n+\n+  /**\n+   * The state of a cluster_resolver LB working session. A new instance is created whenever\n+   * the cluster_resolver LB receives a new config. The old instance is replaced when the\n+   * new one is ready to handle new RPCs.\n+   */\n+  private final class ClusterResolverLbState extends LoadBalancer {\n+    private final Helper helper;\n+    private final List<String> clusters = new ArrayList<>();\n+    private final Map<String, ClusterState> clusterStates = new HashMap<>();\n+    // An aggregate cluster is thought of as a cluster that groups the endpoints of the underlying\n+    // clusters together for load balancing purposes only. Load balancing policies (both locality\n+    // level and endpoint level) are configured by the aggregate cluster and apply to all of its\n+    // underlying clusters.\n+    private PolicySelection localityPickingPolicy;\n+    private PolicySelection endpointPickingPolicy;\n+    private ResolvedAddresses resolvedAddresses;\n+    private LoadBalancer childLb;\n+\n+    ClusterResolverLbState(Helper helper) {\n+      this.helper = checkNotNull(helper, \"helper\");\n+      logger.log(XdsLogLevel.DEBUG, \"New ClusterResolverLbState\");\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      this.resolvedAddresses = resolvedAddresses;\n+      ClusterResolverConfig config =\n+          (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+      for (DiscoveryMechanism instance : config.discoveryMechanisms) {\n+        clusters.add(instance.cluster);\n+        ClusterState state;\n+        if (instance.type == DiscoveryMechanism.Type.EDS) {\n+          state =\n+              new EdsClusterState(instance.cluster, instance.edsServiceName,\n+                  instance.lrsServerName, instance.maxConcurrentRequests, instance.tlsContext);\n+          clusterStates.put(instance.cluster, state);\n+        } else {  // logical DNS\n+          state = new LogicalDnsClusterState(instance.cluster, instance.lrsServerName,\n+              instance.maxConcurrentRequests, instance.tlsContext);\n+          clusterStates.put(instance.cluster, state);\n+        }\n+        state.start();\n+        localityPickingPolicy = config.localityPickingPolicy;", "originalCommit": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4ODQ3Mg==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546588472", "bodyText": "What is alphabetically comparable?", "author": "dapengzhang0", "createdAt": "2020-12-21T09:07:41Z", "path": "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver;\n+import io.grpc.NameResolver.ResolutionResult;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterImplLoadBalancerProvider.ClusterImplConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EdsResourceWatcher;\n+import io.grpc.xds.XdsClient.EdsUpdate;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cluster_resolver_experimental LB policy. This LB policy is the child LB policy\n+ * of the cds_experimental LB policy and the parent LB policy of the priority_experimental LB\n+ * policy in the xDS load balancing hierarchy. This policy resolves endpoints of non-aggregate\n+ * clusters (e.g., EDS or Logical DNS) and groups endpoints in priorities and localities to be\n+ * used in the downstream LB policies for ine-grained load balancing purposes.\n+ */\n+final class ClusterResolverLoadBalancer extends LoadBalancer {\n+\n+  private static final String LOGICAL_DNS_CLUSTER_ENDPOINT_PICKING_POLICY_OVERRIDE = \"pick_first\";\n+  private static final Locality logicalDnsClusterLocality = new Locality(\"\", \"\", \"\");\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final GracefulSwitchLoadBalancer delegate;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private ClusterResolverConfig config;\n+\n+  ClusterResolverLoadBalancer(Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(),\n+        new ExponentialBackoffPolicy.Provider());\n+  }\n+\n+  @VisibleForTesting\n+  ClusterResolverLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry,\n+      BackoffPolicy.Provider backoffPolicyProvider) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.authority = checkNotNull(checkNotNull(helper, \"helper\").getAuthority(), \"authority\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    delegate = new GracefulSwitchLoadBalancer(helper);\n+    logger = XdsLogger.withLogId(\n+        InternalLogId.allocate(\"cluster-resolver-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    ClusterResolverConfig config =\n+        (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (!Objects.equals(this.config, config)) {\n+      logger.log(XdsLogLevel.DEBUG, \"Config: {0}\", config);\n+      delegate.switchTo(new ClusterResolverLbStateFactory());\n+    }\n+    this.config = config;\n+    delegate.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    delegate.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    delegate.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class ClusterResolverLbStateFactory extends LoadBalancer.Factory {\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ClusterResolverLbState(helper);\n+    }\n+  }\n+\n+  /**\n+   * The state of a cluster_resolver LB working session. A new instance is created whenever\n+   * the cluster_resolver LB receives a new config. The old instance is replaced when the\n+   * new one is ready to handle new RPCs.\n+   */\n+  private final class ClusterResolverLbState extends LoadBalancer {\n+    private final Helper helper;\n+    private final List<String> clusters = new ArrayList<>();\n+    private final Map<String, ClusterState> clusterStates = new HashMap<>();\n+    // An aggregate cluster is thought of as a cluster that groups the endpoints of the underlying\n+    // clusters together for load balancing purposes only. Load balancing policies (both locality\n+    // level and endpoint level) are configured by the aggregate cluster and apply to all of its\n+    // underlying clusters.\n+    private PolicySelection localityPickingPolicy;\n+    private PolicySelection endpointPickingPolicy;\n+    private ResolvedAddresses resolvedAddresses;\n+    private LoadBalancer childLb;\n+\n+    ClusterResolverLbState(Helper helper) {\n+      this.helper = checkNotNull(helper, \"helper\");\n+      logger.log(XdsLogLevel.DEBUG, \"New ClusterResolverLbState\");\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      this.resolvedAddresses = resolvedAddresses;\n+      ClusterResolverConfig config =\n+          (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+      for (DiscoveryMechanism instance : config.discoveryMechanisms) {\n+        clusters.add(instance.cluster);\n+        ClusterState state;\n+        if (instance.type == DiscoveryMechanism.Type.EDS) {\n+          state =\n+              new EdsClusterState(instance.cluster, instance.edsServiceName,\n+                  instance.lrsServerName, instance.maxConcurrentRequests, instance.tlsContext);\n+          clusterStates.put(instance.cluster, state);\n+        } else {  // logical DNS\n+          state = new LogicalDnsClusterState(instance.cluster, instance.lrsServerName,\n+              instance.maxConcurrentRequests, instance.tlsContext);\n+          clusterStates.put(instance.cluster, state);\n+        }\n+        state.start();\n+        localityPickingPolicy = config.localityPickingPolicy;\n+        endpointPickingPolicy = config.endpointPickingPolicy;\n+      }\n+    }\n+\n+    @Override\n+    public void handleNameResolutionError(Status error) {\n+      if (childLb != null) {\n+        childLb.handleNameResolutionError(error);\n+      } else {\n+        helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+      }\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      for (ClusterState state : clusterStates.values()) {\n+        state.shutdown();\n+      }\n+      if (childLb != null) {\n+        childLb.shutdown();\n+      }\n+    }\n+\n+    private void handleEndpointResourceUpdate() {\n+      List<EquivalentAddressGroup> addresses = new ArrayList<>();\n+      Map<String, PolicySelection> priorityLbPolicies = new HashMap<>();\n+      List<String> priorities = new ArrayList<>();  // totally ordered priority list\n+      boolean allResolved = true;\n+      for (String cluster : clusters) {\n+        ClusterState state = clusterStates.get(cluster);\n+        if (!state.resolved) {\n+          allResolved = false;\n+          continue;\n+        }\n+        if (state.result != null) {\n+          addresses.addAll(state.result.addresses);\n+          priorityLbPolicies.putAll(state.result.priorityLbPolicies);\n+          priorities.addAll(state.result.priorities);\n+        }\n+      }\n+      if (addresses.isEmpty()) {\n+        if (childLb != null) {\n+          childLb.shutdown();\n+          childLb = null;\n+        }\n+        if (allResolved) {\n+          Status unavailable = Status.UNAVAILABLE.withDescription(\"No endpoint available\");\n+          helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(unavailable));\n+        } else {\n+          helper.updateBalancingState(CONNECTING, BUFFER_PICKER);\n+        }\n+        return;\n+      }\n+      PriorityLbConfig childConfig =\n+          new PriorityLbConfig(Collections.unmodifiableMap(priorityLbPolicies),\n+              Collections.unmodifiableList(priorities));\n+      if (childLb == null) {\n+        childLb = lbRegistry.getProvider(PRIORITY_POLICY_NAME).newLoadBalancer(helper);\n+      }\n+      childLb.handleResolvedAddresses(\n+          resolvedAddresses.toBuilder()\n+              .setLoadBalancingPolicyConfig(childConfig)\n+              .setAddresses(Collections.unmodifiableList(addresses))\n+              .build());\n+    }\n+\n+    private void handleEndpointResolutionError() {\n+      boolean allInError = true;\n+      for (ClusterState state :  clusterStates.values()) {\n+        if (state.status.isOk()) {\n+          allInError = false;\n+        }\n+      }\n+      if (allInError) {\n+        // Propagate the error status of the last cluster. This is the best we can do.\n+        Status error = clusterStates.get(clusters.get(clusters.size() - 1)).status;\n+        if (childLb != null) {\n+          childLb.handleNameResolutionError(error);\n+        } else {\n+          helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Resolution state of an underlying cluster.\n+     */\n+    private abstract class ClusterState {\n+      // Name of the cluster to be resolved.\n+      protected final String name;\n+      // The resource name to be used for resolving endpoints via EDS.\n+      // Always null if the cluster is a logical DNS cluster.\n+      @Nullable\n+      protected final String edsServiceName;\n+      @Nullable\n+      protected final String lrsServerName;\n+      @Nullable\n+      protected final Long maxConcurrentRequests;\n+      @Nullable\n+      protected final UpstreamTlsContext tlsContext;\n+      // Resolution status, may contain most recent error encountered.\n+      protected Status status = Status.OK;\n+      // True if has received resolution result.\n+      protected boolean resolved;\n+      // Most recently resolved addresses and config, or null if resource not exists.\n+      @Nullable\n+      protected ClusterResolutionResult result;\n+      protected boolean shutdown;\n+\n+      private ClusterState(String name, @Nullable String edsServiceName,\n+          @Nullable String lrsServerName, @Nullable Long maxConcurrentRequests,\n+          @Nullable UpstreamTlsContext tlsContext) {\n+        this.name = name;\n+        this.edsServiceName = edsServiceName;\n+        this.lrsServerName = lrsServerName;\n+        this.maxConcurrentRequests = maxConcurrentRequests;\n+        this.tlsContext = tlsContext;\n+      }\n+\n+      abstract void start();\n+\n+      void shutdown() {\n+        shutdown = true;\n+      }\n+    }\n+\n+    private class EdsClusterState extends ClusterState implements EdsResourceWatcher {\n+\n+      private EdsClusterState(String name, @Nullable String edsServiceName,\n+          @Nullable String lrsServerName, @Nullable Long maxConcurrentRequests,\n+          @Nullable UpstreamTlsContext tlsContext) {\n+        super(name, edsServiceName, lrsServerName, maxConcurrentRequests, tlsContext);\n+      }\n+\n+      @Override\n+      void start() {\n+        String resourceName = edsServiceName != null ? edsServiceName : name;\n+        logger.log(XdsLogLevel.INFO, \"Start watching EDS resource {0}\", resourceName);\n+        xdsClient.watchEdsResource(resourceName, this);\n+      }\n+\n+      @Override\n+      protected void shutdown() {\n+        super.shutdown();\n+        String resourceName = edsServiceName != null ? edsServiceName : name;\n+        logger.log(XdsLogLevel.INFO, \"Stop watching EDS resource {0}\", resourceName);\n+        xdsClient.cancelEdsResourceWatch(resourceName, this);\n+      }\n+\n+      @Override\n+      public void onChanged(final EdsUpdate update) {\n+        class EndpointsUpdated implements Runnable {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            logger.log(XdsLogLevel.DEBUG, \"Received endpoint update {0}\", update);\n+            if (logger.isLoggable(XdsLogLevel.INFO)) {\n+              logger.log(XdsLogLevel.INFO, \"Cluster {0}: {1} localities, {2} drop categories\",\n+                  update.getClusterName(), update.getLocalityLbEndpointsMap().size(),\n+                  update.getDropPolicies().size());\n+            }\n+            Map<Locality, LocalityLbEndpoints> localityLbEndpoints =\n+                update.getLocalityLbEndpointsMap();\n+            List<DropOverload> dropOverloads = update.getDropPolicies();\n+            List<EquivalentAddressGroup> addresses = new ArrayList<>();\n+            Map<String, Map<Locality, Integer>> prioritizedLocalityWeights = new HashMap<>();\n+            for (Locality locality : localityLbEndpoints.keySet()) {\n+              LocalityLbEndpoints localityLbInfo = localityLbEndpoints.get(locality);\n+              int priority = localityLbInfo.getPriority();\n+              String priorityName = priorityName(name, priority);\n+              boolean discard = true;\n+              for (LbEndpoint endpoint : localityLbInfo.getEndpoints()) {\n+                if (endpoint.isHealthy()) {\n+                  discard = false;\n+                  EquivalentAddressGroup eag =\n+                      AddressFilter.setPathFilter(\n+                          endpoint.getAddress(),\n+                          Arrays.asList(priorityName, localityName(locality)));\n+                  addresses.add(eag);\n+                }\n+              }\n+              if (discard) {\n+                logger.log(XdsLogLevel.INFO,\n+                    \"Discard locality {0} with 0 healthy endpoints\", locality);\n+                continue;\n+              }\n+              if (!prioritizedLocalityWeights.containsKey(priorityName)) {\n+                prioritizedLocalityWeights.put(priorityName, new HashMap<Locality, Integer>());\n+              }\n+              prioritizedLocalityWeights.get(priorityName).put(\n+                  locality, localityLbInfo.getLocalityWeight());\n+            }\n+            if (prioritizedLocalityWeights.isEmpty()) {\n+              // Transient state, neither as a result or an error.\n+              logger.log(XdsLogLevel.INFO,\n+                  \"Cluster {0} has no usable priority/locality/endpoint\", update.getClusterName());\n+              return;\n+            }\n+            List<String> priorities = new ArrayList<>(prioritizedLocalityWeights.keySet());\n+            Collections.sort(priorities);\n+            Map<String, PolicySelection> priorityLbPolicies =\n+                generateClusterPriorityLbPolicies(name, edsServiceName, lrsServerName,\n+                    maxConcurrentRequests, tlsContext, localityPickingPolicy,\n+                    endpointPickingPolicy, lbRegistry, prioritizedLocalityWeights, dropOverloads);\n+            status = Status.OK;\n+            resolved = true;\n+            result = new ClusterResolutionResult(addresses, priorityLbPolicies, priorities);\n+            handleEndpointResourceUpdate();\n+          }\n+        }\n+\n+        syncContext.execute(new EndpointsUpdated());\n+      }\n+\n+      @Override\n+      public void onResourceDoesNotExist(final String resourceName) {\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            logger.log(XdsLogLevel.INFO, \"Resource {0} unavailable\", resourceName);\n+            status = Status.OK;\n+            resolved = true;\n+            result = null;  // resource revoked\n+            handleEndpointResourceUpdate();\n+          }\n+        });\n+      }\n+\n+      @Override\n+      public void onError(final Status error) {\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            status = error;\n+            logger.log(XdsLogLevel.WARNING, \"Received EDS error: {0}\", error);\n+            handleEndpointResolutionError();\n+          }\n+        });\n+      }\n+    }\n+\n+    private class LogicalDnsClusterState extends ClusterState {\n+      private final NameResolver resolver;\n+      @Nullable\n+      private BackoffPolicy backoffPolicy;\n+      @Nullable\n+      private ScheduledHandle scheduledRefresh;\n+\n+      private LogicalDnsClusterState(String name, @Nullable String lrsServerName,\n+          @Nullable Long maxConcurrentRequests, @Nullable UpstreamTlsContext tlsContext) {\n+        super(name, null, lrsServerName, maxConcurrentRequests, tlsContext);\n+        NameResolver.Args args = helper.getNameResolverArgs();\n+        URI uri;\n+        try {\n+          uri = new URI(authority);\n+        } catch (URISyntaxException e) {\n+          // TODO(chengyuanzhang): unlikely to happen, but maybe handle it more gracefully.\n+          throw new AssertionError(\"Bug, invalid authority: \" + authority, e);\n+        }\n+        resolver = helper.getNameResolverRegistry().asFactory().newNameResolver(uri, args);\n+      }\n+\n+      @Override\n+      void start() {\n+        resolver.start(new NameResolverListener());\n+      }\n+\n+      @Override\n+      void shutdown() {\n+        super.shutdown();\n+        resolver.shutdown();\n+        if (scheduledRefresh != null) {\n+          scheduledRefresh.cancel();\n+        }\n+      }\n+\n+      private class DelayedNameResolverRefresh implements Runnable {\n+        @Override\n+        public void run() {\n+          scheduledRefresh = null;\n+          if (!shutdown) {\n+            resolver.refresh();\n+          }\n+        }\n+      }\n+\n+      private class NameResolverListener extends NameResolver.Listener2 {\n+        @Override\n+        public void onResult(final ResolutionResult resolutionResult) {\n+          class NameResolved implements Runnable {\n+            @Override\n+            public void run() {\n+              if (shutdown) {\n+                return;\n+              }\n+              backoffPolicy = null;  // reset backoff sequence if succeeded\n+              String priorityName = priorityName(name, 0);  // value doesn't matter\n+              List<EquivalentAddressGroup> addresses = new ArrayList<>();\n+              for (EquivalentAddressGroup eag : resolutionResult.getAddresses()) {\n+                EquivalentAddressGroup annotatedAddr =\n+                    AddressFilter.setPathFilter(\n+                        eag, Arrays.asList(\n+                            priorityName, logicalDnsClusterLocality.toString()));\n+                addresses.add(annotatedAddr);\n+              }\n+              LoadBalancerProvider endpointPickingLbProvider =\n+                  lbRegistry.getProvider(LOGICAL_DNS_CLUSTER_ENDPOINT_PICKING_POLICY_OVERRIDE);\n+              PolicySelection endpointPickingPolicy =\n+                  new PolicySelection(endpointPickingLbProvider, null);\n+              PolicySelection priorityLbPolicy =\n+                  generateClusterPriorityLbPolicy(name, edsServiceName, lrsServerName,\n+                      maxConcurrentRequests, tlsContext, endpointPickingPolicy, lbRegistry,\n+                      logicalDnsClusterLocality, Collections.<DropOverload>emptyList());\n+              status = Status.OK;\n+              resolved = true;\n+              result = new ClusterResolutionResult(addresses, priorityName, priorityLbPolicy);\n+              handleEndpointResourceUpdate();\n+            }\n+          }\n+\n+          syncContext.execute(new NameResolved());\n+        }\n+\n+        @Override\n+        public void onError(final Status error) {\n+          syncContext.execute(new Runnable() {\n+            @Override\n+            public void run() {\n+              if (shutdown) {\n+                return;\n+              }\n+              status = error;\n+              // NameResolver.Listener API cannot distinguish transient errors, we should avoid\n+              // waiting for DNS addresses indefinitely.\n+              resolved = true;\n+              handleEndpointResolutionError();\n+              if (scheduledRefresh != null && scheduledRefresh.isPending()) {\n+                return;\n+              }\n+              if (backoffPolicy == null) {\n+                backoffPolicy = backoffPolicyProvider.get();\n+              }\n+              long delayNanos = backoffPolicy.nextBackoffNanos();\n+              logger.log(XdsLogLevel.DEBUG,\n+                  \"Scheduling DNS resolution backoff for {0} ns\", delayNanos);\n+              scheduledRefresh =\n+                  syncContext.schedule(\n+                      new DelayedNameResolverRefresh(), delayNanos, TimeUnit.NANOSECONDS,\n+                      timeService);\n+            }\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n+  private static class ClusterResolutionResult {\n+    // Endpoint addresses.\n+    private final List<EquivalentAddressGroup> addresses;\n+    // Load balancing policy (with config) for each priority in the cluster.\n+    private final Map<String, PolicySelection> priorityLbPolicies;\n+    // List of priority names ordered in descending priorities.\n+    private final List<String> priorities;\n+\n+    ClusterResolutionResult(List<EquivalentAddressGroup> addresses, String priority,\n+        PolicySelection priorityLbPolicy) {\n+      this(addresses, Collections.singletonMap(priority, priorityLbPolicy),\n+          Collections.singletonList(priority));\n+    }\n+\n+    ClusterResolutionResult(List<EquivalentAddressGroup> addresses,\n+        Map<String, PolicySelection> priorityLbPolicies, List<String> priorities) {\n+      this.addresses = addresses;\n+      this.priorityLbPolicies = priorityLbPolicies;\n+      this.priorities = priorities;\n+    }\n+  }\n+\n+  /**\n+   * Generates the intra-priority LB policy for a single priority with the single given locality.\n+   *\n+   * <p>priority LB -> cluster_impl LB -> (lrs LB) -> pick_first\n+   */\n+  private PolicySelection generateClusterPriorityLbPolicy(\n+      String cluster, @Nullable String edsServiceName, @Nullable String lrsServerName,\n+      @Nullable Long maxConcurrentRequests, @Nullable UpstreamTlsContext tlsContext,\n+      PolicySelection endpointPickingPolicy, LoadBalancerRegistry lbRegistry,\n+      Locality locality, List<DropOverload> dropOverloads) {\n+    PolicySelection localityLbPolicy =\n+        generateLocalityLbConfig(locality, cluster, edsServiceName, lrsServerName,\n+            endpointPickingPolicy, lbRegistry);\n+    ClusterImplConfig clusterImplConfig =\n+        new ClusterImplConfig(cluster, edsServiceName, lrsServerName, maxConcurrentRequests,\n+            dropOverloads, localityLbPolicy, tlsContext);\n+    LoadBalancerProvider clusterImplLbProvider =\n+        lbRegistry.getProvider(XdsLbPolicies.CLUSTER_IMPL_POLICY_NAME);\n+    return new PolicySelection(clusterImplLbProvider, clusterImplConfig);\n+  }\n+\n+  /**\n+   * Generates intra-priority LB policies (with config) for priorities in the cluster.\n+   *\n+   * <p>priority LB -> cluster_impl LB (one per priority) -> weighted_target LB\n+   * -> (lrs LB (one per locality)) -> round_robin\n+   */\n+  private static Map<String, PolicySelection> generateClusterPriorityLbPolicies(\n+      String cluster, @Nullable String edsServiceName, @Nullable String lrsServerName,\n+      @Nullable Long maxConcurrentRequests, @Nullable UpstreamTlsContext tlsContext,\n+      PolicySelection localityPickingPolicy, PolicySelection endpointPickingPolicy,\n+      LoadBalancerRegistry lbRegistry,\n+      Map<String, Map<Locality, Integer>> prioritizedLocalityWeights,\n+      List<DropOverload> dropOverloads) {\n+    Map<String, PolicySelection> policies = new HashMap<>();\n+    for (String priority : prioritizedLocalityWeights.keySet()) {\n+      WeightedTargetConfig localityPickingLbConfig =\n+          generateLocalityPickingLbConfig(cluster, edsServiceName, lrsServerName,\n+              endpointPickingPolicy, lbRegistry, prioritizedLocalityWeights.get(priority));\n+      PolicySelection localityPicking =\n+          new PolicySelection(localityPickingPolicy.getProvider(), localityPickingLbConfig);\n+      ClusterImplConfig clusterImplConfig =\n+          new ClusterImplConfig(cluster, edsServiceName, lrsServerName, maxConcurrentRequests,\n+              dropOverloads, localityPicking, tlsContext);\n+      LoadBalancerProvider clusterImplLbProvider =\n+          lbRegistry.getProvider(XdsLbPolicies.CLUSTER_IMPL_POLICY_NAME);\n+      PolicySelection clusterImplPolicy =\n+          new PolicySelection(clusterImplLbProvider, clusterImplConfig);\n+      policies.put(priority, clusterImplPolicy);\n+    }\n+    return policies;\n+  }\n+\n+  private static WeightedTargetConfig generateLocalityPickingLbConfig(\n+      String cluster, @Nullable String edsServiceName, @Nullable String lrsServerName,\n+      PolicySelection endpointPickingPolicy, LoadBalancerRegistry lbRegistry,\n+      Map<Locality, Integer> localityWeights) {\n+    Map<String, WeightedPolicySelection> targets = new HashMap<>();\n+    for (Locality locality : localityWeights.keySet()) {\n+      int weight = localityWeights.get(locality);\n+      PolicySelection childPolicy =\n+          generateLocalityLbConfig(locality, cluster, edsServiceName, lrsServerName,\n+              endpointPickingPolicy, lbRegistry);\n+      targets.put(localityName(locality), new WeightedPolicySelection(weight, childPolicy));\n+    }\n+    return new WeightedTargetConfig(Collections.unmodifiableMap(targets));\n+  }\n+\n+  /**\n+   * Generates intra-locality LB policy (with config) for the given locality.\n+   */\n+  private static PolicySelection generateLocalityLbConfig(\n+      Locality locality, String cluster, @Nullable String edsServiceName,\n+      @Nullable String lrsServerName, PolicySelection endpointPickingPolicy,\n+      LoadBalancerRegistry lbRegistry) {\n+    PolicySelection policy;\n+    if (lrsServerName != null) {\n+      LrsConfig childConfig =\n+          new LrsConfig(cluster, edsServiceName, lrsServerName, locality, endpointPickingPolicy);\n+      LoadBalancerProvider childPolicyProvider = lbRegistry.getProvider(LRS_POLICY_NAME);\n+      policy = new PolicySelection(childPolicyProvider, childConfig);\n+    } else {\n+      policy = endpointPickingPolicy;\n+    }\n+    return policy;\n+  }\n+\n+  /**\n+   * Generate a string that represents the priority in the LB policy config. The string is unique\n+   * across priorities in all clusters. The string is alphabetically comparable with predicate", "originalCommit": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4OTA2OA==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546589068", "bodyText": "Generates", "author": "dapengzhang0", "createdAt": "2020-12-21T09:08:57Z", "path": "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver;\n+import io.grpc.NameResolver.ResolutionResult;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterImplLoadBalancerProvider.ClusterImplConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EdsResourceWatcher;\n+import io.grpc.xds.XdsClient.EdsUpdate;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cluster_resolver_experimental LB policy. This LB policy is the child LB policy\n+ * of the cds_experimental LB policy and the parent LB policy of the priority_experimental LB\n+ * policy in the xDS load balancing hierarchy. This policy resolves endpoints of non-aggregate\n+ * clusters (e.g., EDS or Logical DNS) and groups endpoints in priorities and localities to be\n+ * used in the downstream LB policies for ine-grained load balancing purposes.\n+ */\n+final class ClusterResolverLoadBalancer extends LoadBalancer {\n+\n+  private static final String LOGICAL_DNS_CLUSTER_ENDPOINT_PICKING_POLICY_OVERRIDE = \"pick_first\";\n+  private static final Locality logicalDnsClusterLocality = new Locality(\"\", \"\", \"\");\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final GracefulSwitchLoadBalancer delegate;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private ClusterResolverConfig config;\n+\n+  ClusterResolverLoadBalancer(Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(),\n+        new ExponentialBackoffPolicy.Provider());\n+  }\n+\n+  @VisibleForTesting\n+  ClusterResolverLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry,\n+      BackoffPolicy.Provider backoffPolicyProvider) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.authority = checkNotNull(checkNotNull(helper, \"helper\").getAuthority(), \"authority\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    delegate = new GracefulSwitchLoadBalancer(helper);\n+    logger = XdsLogger.withLogId(\n+        InternalLogId.allocate(\"cluster-resolver-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    ClusterResolverConfig config =\n+        (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (!Objects.equals(this.config, config)) {\n+      logger.log(XdsLogLevel.DEBUG, \"Config: {0}\", config);\n+      delegate.switchTo(new ClusterResolverLbStateFactory());\n+    }\n+    this.config = config;\n+    delegate.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    delegate.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    delegate.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class ClusterResolverLbStateFactory extends LoadBalancer.Factory {\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ClusterResolverLbState(helper);\n+    }\n+  }\n+\n+  /**\n+   * The state of a cluster_resolver LB working session. A new instance is created whenever\n+   * the cluster_resolver LB receives a new config. The old instance is replaced when the\n+   * new one is ready to handle new RPCs.\n+   */\n+  private final class ClusterResolverLbState extends LoadBalancer {\n+    private final Helper helper;\n+    private final List<String> clusters = new ArrayList<>();\n+    private final Map<String, ClusterState> clusterStates = new HashMap<>();\n+    // An aggregate cluster is thought of as a cluster that groups the endpoints of the underlying\n+    // clusters together for load balancing purposes only. Load balancing policies (both locality\n+    // level and endpoint level) are configured by the aggregate cluster and apply to all of its\n+    // underlying clusters.\n+    private PolicySelection localityPickingPolicy;\n+    private PolicySelection endpointPickingPolicy;\n+    private ResolvedAddresses resolvedAddresses;\n+    private LoadBalancer childLb;\n+\n+    ClusterResolverLbState(Helper helper) {\n+      this.helper = checkNotNull(helper, \"helper\");\n+      logger.log(XdsLogLevel.DEBUG, \"New ClusterResolverLbState\");\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      this.resolvedAddresses = resolvedAddresses;\n+      ClusterResolverConfig config =\n+          (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+      for (DiscoveryMechanism instance : config.discoveryMechanisms) {\n+        clusters.add(instance.cluster);\n+        ClusterState state;\n+        if (instance.type == DiscoveryMechanism.Type.EDS) {\n+          state =\n+              new EdsClusterState(instance.cluster, instance.edsServiceName,\n+                  instance.lrsServerName, instance.maxConcurrentRequests, instance.tlsContext);\n+          clusterStates.put(instance.cluster, state);\n+        } else {  // logical DNS\n+          state = new LogicalDnsClusterState(instance.cluster, instance.lrsServerName,\n+              instance.maxConcurrentRequests, instance.tlsContext);\n+          clusterStates.put(instance.cluster, state);\n+        }\n+        state.start();\n+        localityPickingPolicy = config.localityPickingPolicy;\n+        endpointPickingPolicy = config.endpointPickingPolicy;\n+      }\n+    }\n+\n+    @Override\n+    public void handleNameResolutionError(Status error) {\n+      if (childLb != null) {\n+        childLb.handleNameResolutionError(error);\n+      } else {\n+        helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+      }\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      for (ClusterState state : clusterStates.values()) {\n+        state.shutdown();\n+      }\n+      if (childLb != null) {\n+        childLb.shutdown();\n+      }\n+    }\n+\n+    private void handleEndpointResourceUpdate() {\n+      List<EquivalentAddressGroup> addresses = new ArrayList<>();\n+      Map<String, PolicySelection> priorityLbPolicies = new HashMap<>();\n+      List<String> priorities = new ArrayList<>();  // totally ordered priority list\n+      boolean allResolved = true;\n+      for (String cluster : clusters) {\n+        ClusterState state = clusterStates.get(cluster);\n+        if (!state.resolved) {\n+          allResolved = false;\n+          continue;\n+        }\n+        if (state.result != null) {\n+          addresses.addAll(state.result.addresses);\n+          priorityLbPolicies.putAll(state.result.priorityLbPolicies);\n+          priorities.addAll(state.result.priorities);\n+        }\n+      }\n+      if (addresses.isEmpty()) {\n+        if (childLb != null) {\n+          childLb.shutdown();\n+          childLb = null;\n+        }\n+        if (allResolved) {\n+          Status unavailable = Status.UNAVAILABLE.withDescription(\"No endpoint available\");\n+          helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(unavailable));\n+        } else {\n+          helper.updateBalancingState(CONNECTING, BUFFER_PICKER);\n+        }\n+        return;\n+      }\n+      PriorityLbConfig childConfig =\n+          new PriorityLbConfig(Collections.unmodifiableMap(priorityLbPolicies),\n+              Collections.unmodifiableList(priorities));\n+      if (childLb == null) {\n+        childLb = lbRegistry.getProvider(PRIORITY_POLICY_NAME).newLoadBalancer(helper);\n+      }\n+      childLb.handleResolvedAddresses(\n+          resolvedAddresses.toBuilder()\n+              .setLoadBalancingPolicyConfig(childConfig)\n+              .setAddresses(Collections.unmodifiableList(addresses))\n+              .build());\n+    }\n+\n+    private void handleEndpointResolutionError() {\n+      boolean allInError = true;\n+      for (ClusterState state :  clusterStates.values()) {\n+        if (state.status.isOk()) {\n+          allInError = false;\n+        }\n+      }\n+      if (allInError) {\n+        // Propagate the error status of the last cluster. This is the best we can do.\n+        Status error = clusterStates.get(clusters.get(clusters.size() - 1)).status;\n+        if (childLb != null) {\n+          childLb.handleNameResolutionError(error);\n+        } else {\n+          helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Resolution state of an underlying cluster.\n+     */\n+    private abstract class ClusterState {\n+      // Name of the cluster to be resolved.\n+      protected final String name;\n+      // The resource name to be used for resolving endpoints via EDS.\n+      // Always null if the cluster is a logical DNS cluster.\n+      @Nullable\n+      protected final String edsServiceName;\n+      @Nullable\n+      protected final String lrsServerName;\n+      @Nullable\n+      protected final Long maxConcurrentRequests;\n+      @Nullable\n+      protected final UpstreamTlsContext tlsContext;\n+      // Resolution status, may contain most recent error encountered.\n+      protected Status status = Status.OK;\n+      // True if has received resolution result.\n+      protected boolean resolved;\n+      // Most recently resolved addresses and config, or null if resource not exists.\n+      @Nullable\n+      protected ClusterResolutionResult result;\n+      protected boolean shutdown;\n+\n+      private ClusterState(String name, @Nullable String edsServiceName,\n+          @Nullable String lrsServerName, @Nullable Long maxConcurrentRequests,\n+          @Nullable UpstreamTlsContext tlsContext) {\n+        this.name = name;\n+        this.edsServiceName = edsServiceName;\n+        this.lrsServerName = lrsServerName;\n+        this.maxConcurrentRequests = maxConcurrentRequests;\n+        this.tlsContext = tlsContext;\n+      }\n+\n+      abstract void start();\n+\n+      void shutdown() {\n+        shutdown = true;\n+      }\n+    }\n+\n+    private class EdsClusterState extends ClusterState implements EdsResourceWatcher {\n+\n+      private EdsClusterState(String name, @Nullable String edsServiceName,\n+          @Nullable String lrsServerName, @Nullable Long maxConcurrentRequests,\n+          @Nullable UpstreamTlsContext tlsContext) {\n+        super(name, edsServiceName, lrsServerName, maxConcurrentRequests, tlsContext);\n+      }\n+\n+      @Override\n+      void start() {\n+        String resourceName = edsServiceName != null ? edsServiceName : name;\n+        logger.log(XdsLogLevel.INFO, \"Start watching EDS resource {0}\", resourceName);\n+        xdsClient.watchEdsResource(resourceName, this);\n+      }\n+\n+      @Override\n+      protected void shutdown() {\n+        super.shutdown();\n+        String resourceName = edsServiceName != null ? edsServiceName : name;\n+        logger.log(XdsLogLevel.INFO, \"Stop watching EDS resource {0}\", resourceName);\n+        xdsClient.cancelEdsResourceWatch(resourceName, this);\n+      }\n+\n+      @Override\n+      public void onChanged(final EdsUpdate update) {\n+        class EndpointsUpdated implements Runnable {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            logger.log(XdsLogLevel.DEBUG, \"Received endpoint update {0}\", update);\n+            if (logger.isLoggable(XdsLogLevel.INFO)) {\n+              logger.log(XdsLogLevel.INFO, \"Cluster {0}: {1} localities, {2} drop categories\",\n+                  update.getClusterName(), update.getLocalityLbEndpointsMap().size(),\n+                  update.getDropPolicies().size());\n+            }\n+            Map<Locality, LocalityLbEndpoints> localityLbEndpoints =\n+                update.getLocalityLbEndpointsMap();\n+            List<DropOverload> dropOverloads = update.getDropPolicies();\n+            List<EquivalentAddressGroup> addresses = new ArrayList<>();\n+            Map<String, Map<Locality, Integer>> prioritizedLocalityWeights = new HashMap<>();\n+            for (Locality locality : localityLbEndpoints.keySet()) {\n+              LocalityLbEndpoints localityLbInfo = localityLbEndpoints.get(locality);\n+              int priority = localityLbInfo.getPriority();\n+              String priorityName = priorityName(name, priority);\n+              boolean discard = true;\n+              for (LbEndpoint endpoint : localityLbInfo.getEndpoints()) {\n+                if (endpoint.isHealthy()) {\n+                  discard = false;\n+                  EquivalentAddressGroup eag =\n+                      AddressFilter.setPathFilter(\n+                          endpoint.getAddress(),\n+                          Arrays.asList(priorityName, localityName(locality)));\n+                  addresses.add(eag);\n+                }\n+              }\n+              if (discard) {\n+                logger.log(XdsLogLevel.INFO,\n+                    \"Discard locality {0} with 0 healthy endpoints\", locality);\n+                continue;\n+              }\n+              if (!prioritizedLocalityWeights.containsKey(priorityName)) {\n+                prioritizedLocalityWeights.put(priorityName, new HashMap<Locality, Integer>());\n+              }\n+              prioritizedLocalityWeights.get(priorityName).put(\n+                  locality, localityLbInfo.getLocalityWeight());\n+            }\n+            if (prioritizedLocalityWeights.isEmpty()) {\n+              // Transient state, neither as a result or an error.\n+              logger.log(XdsLogLevel.INFO,\n+                  \"Cluster {0} has no usable priority/locality/endpoint\", update.getClusterName());\n+              return;\n+            }\n+            List<String> priorities = new ArrayList<>(prioritizedLocalityWeights.keySet());\n+            Collections.sort(priorities);\n+            Map<String, PolicySelection> priorityLbPolicies =\n+                generateClusterPriorityLbPolicies(name, edsServiceName, lrsServerName,\n+                    maxConcurrentRequests, tlsContext, localityPickingPolicy,\n+                    endpointPickingPolicy, lbRegistry, prioritizedLocalityWeights, dropOverloads);\n+            status = Status.OK;\n+            resolved = true;\n+            result = new ClusterResolutionResult(addresses, priorityLbPolicies, priorities);\n+            handleEndpointResourceUpdate();\n+          }\n+        }\n+\n+        syncContext.execute(new EndpointsUpdated());\n+      }\n+\n+      @Override\n+      public void onResourceDoesNotExist(final String resourceName) {\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            logger.log(XdsLogLevel.INFO, \"Resource {0} unavailable\", resourceName);\n+            status = Status.OK;\n+            resolved = true;\n+            result = null;  // resource revoked\n+            handleEndpointResourceUpdate();\n+          }\n+        });\n+      }\n+\n+      @Override\n+      public void onError(final Status error) {\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            status = error;\n+            logger.log(XdsLogLevel.WARNING, \"Received EDS error: {0}\", error);\n+            handleEndpointResolutionError();\n+          }\n+        });\n+      }\n+    }\n+\n+    private class LogicalDnsClusterState extends ClusterState {\n+      private final NameResolver resolver;\n+      @Nullable\n+      private BackoffPolicy backoffPolicy;\n+      @Nullable\n+      private ScheduledHandle scheduledRefresh;\n+\n+      private LogicalDnsClusterState(String name, @Nullable String lrsServerName,\n+          @Nullable Long maxConcurrentRequests, @Nullable UpstreamTlsContext tlsContext) {\n+        super(name, null, lrsServerName, maxConcurrentRequests, tlsContext);\n+        NameResolver.Args args = helper.getNameResolverArgs();\n+        URI uri;\n+        try {\n+          uri = new URI(authority);\n+        } catch (URISyntaxException e) {\n+          // TODO(chengyuanzhang): unlikely to happen, but maybe handle it more gracefully.\n+          throw new AssertionError(\"Bug, invalid authority: \" + authority, e);\n+        }\n+        resolver = helper.getNameResolverRegistry().asFactory().newNameResolver(uri, args);\n+      }\n+\n+      @Override\n+      void start() {\n+        resolver.start(new NameResolverListener());\n+      }\n+\n+      @Override\n+      void shutdown() {\n+        super.shutdown();\n+        resolver.shutdown();\n+        if (scheduledRefresh != null) {\n+          scheduledRefresh.cancel();\n+        }\n+      }\n+\n+      private class DelayedNameResolverRefresh implements Runnable {\n+        @Override\n+        public void run() {\n+          scheduledRefresh = null;\n+          if (!shutdown) {\n+            resolver.refresh();\n+          }\n+        }\n+      }\n+\n+      private class NameResolverListener extends NameResolver.Listener2 {\n+        @Override\n+        public void onResult(final ResolutionResult resolutionResult) {\n+          class NameResolved implements Runnable {\n+            @Override\n+            public void run() {\n+              if (shutdown) {\n+                return;\n+              }\n+              backoffPolicy = null;  // reset backoff sequence if succeeded\n+              String priorityName = priorityName(name, 0);  // value doesn't matter\n+              List<EquivalentAddressGroup> addresses = new ArrayList<>();\n+              for (EquivalentAddressGroup eag : resolutionResult.getAddresses()) {\n+                EquivalentAddressGroup annotatedAddr =\n+                    AddressFilter.setPathFilter(\n+                        eag, Arrays.asList(\n+                            priorityName, logicalDnsClusterLocality.toString()));\n+                addresses.add(annotatedAddr);\n+              }\n+              LoadBalancerProvider endpointPickingLbProvider =\n+                  lbRegistry.getProvider(LOGICAL_DNS_CLUSTER_ENDPOINT_PICKING_POLICY_OVERRIDE);\n+              PolicySelection endpointPickingPolicy =\n+                  new PolicySelection(endpointPickingLbProvider, null);\n+              PolicySelection priorityLbPolicy =\n+                  generateClusterPriorityLbPolicy(name, edsServiceName, lrsServerName,\n+                      maxConcurrentRequests, tlsContext, endpointPickingPolicy, lbRegistry,\n+                      logicalDnsClusterLocality, Collections.<DropOverload>emptyList());\n+              status = Status.OK;\n+              resolved = true;\n+              result = new ClusterResolutionResult(addresses, priorityName, priorityLbPolicy);\n+              handleEndpointResourceUpdate();\n+            }\n+          }\n+\n+          syncContext.execute(new NameResolved());\n+        }\n+\n+        @Override\n+        public void onError(final Status error) {\n+          syncContext.execute(new Runnable() {\n+            @Override\n+            public void run() {\n+              if (shutdown) {\n+                return;\n+              }\n+              status = error;\n+              // NameResolver.Listener API cannot distinguish transient errors, we should avoid\n+              // waiting for DNS addresses indefinitely.\n+              resolved = true;\n+              handleEndpointResolutionError();\n+              if (scheduledRefresh != null && scheduledRefresh.isPending()) {\n+                return;\n+              }\n+              if (backoffPolicy == null) {\n+                backoffPolicy = backoffPolicyProvider.get();\n+              }\n+              long delayNanos = backoffPolicy.nextBackoffNanos();\n+              logger.log(XdsLogLevel.DEBUG,\n+                  \"Scheduling DNS resolution backoff for {0} ns\", delayNanos);\n+              scheduledRefresh =\n+                  syncContext.schedule(\n+                      new DelayedNameResolverRefresh(), delayNanos, TimeUnit.NANOSECONDS,\n+                      timeService);\n+            }\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n+  private static class ClusterResolutionResult {\n+    // Endpoint addresses.\n+    private final List<EquivalentAddressGroup> addresses;\n+    // Load balancing policy (with config) for each priority in the cluster.\n+    private final Map<String, PolicySelection> priorityLbPolicies;\n+    // List of priority names ordered in descending priorities.\n+    private final List<String> priorities;\n+\n+    ClusterResolutionResult(List<EquivalentAddressGroup> addresses, String priority,\n+        PolicySelection priorityLbPolicy) {\n+      this(addresses, Collections.singletonMap(priority, priorityLbPolicy),\n+          Collections.singletonList(priority));\n+    }\n+\n+    ClusterResolutionResult(List<EquivalentAddressGroup> addresses,\n+        Map<String, PolicySelection> priorityLbPolicies, List<String> priorities) {\n+      this.addresses = addresses;\n+      this.priorityLbPolicies = priorityLbPolicies;\n+      this.priorities = priorities;\n+    }\n+  }\n+\n+  /**\n+   * Generates the intra-priority LB policy for a single priority with the single given locality.\n+   *\n+   * <p>priority LB -> cluster_impl LB -> (lrs LB) -> pick_first\n+   */\n+  private PolicySelection generateClusterPriorityLbPolicy(\n+      String cluster, @Nullable String edsServiceName, @Nullable String lrsServerName,\n+      @Nullable Long maxConcurrentRequests, @Nullable UpstreamTlsContext tlsContext,\n+      PolicySelection endpointPickingPolicy, LoadBalancerRegistry lbRegistry,\n+      Locality locality, List<DropOverload> dropOverloads) {\n+    PolicySelection localityLbPolicy =\n+        generateLocalityLbConfig(locality, cluster, edsServiceName, lrsServerName,\n+            endpointPickingPolicy, lbRegistry);\n+    ClusterImplConfig clusterImplConfig =\n+        new ClusterImplConfig(cluster, edsServiceName, lrsServerName, maxConcurrentRequests,\n+            dropOverloads, localityLbPolicy, tlsContext);\n+    LoadBalancerProvider clusterImplLbProvider =\n+        lbRegistry.getProvider(XdsLbPolicies.CLUSTER_IMPL_POLICY_NAME);\n+    return new PolicySelection(clusterImplLbProvider, clusterImplConfig);\n+  }\n+\n+  /**\n+   * Generates intra-priority LB policies (with config) for priorities in the cluster.\n+   *\n+   * <p>priority LB -> cluster_impl LB (one per priority) -> weighted_target LB\n+   * -> (lrs LB (one per locality)) -> round_robin\n+   */\n+  private static Map<String, PolicySelection> generateClusterPriorityLbPolicies(\n+      String cluster, @Nullable String edsServiceName, @Nullable String lrsServerName,\n+      @Nullable Long maxConcurrentRequests, @Nullable UpstreamTlsContext tlsContext,\n+      PolicySelection localityPickingPolicy, PolicySelection endpointPickingPolicy,\n+      LoadBalancerRegistry lbRegistry,\n+      Map<String, Map<Locality, Integer>> prioritizedLocalityWeights,\n+      List<DropOverload> dropOverloads) {\n+    Map<String, PolicySelection> policies = new HashMap<>();\n+    for (String priority : prioritizedLocalityWeights.keySet()) {\n+      WeightedTargetConfig localityPickingLbConfig =\n+          generateLocalityPickingLbConfig(cluster, edsServiceName, lrsServerName,\n+              endpointPickingPolicy, lbRegistry, prioritizedLocalityWeights.get(priority));\n+      PolicySelection localityPicking =\n+          new PolicySelection(localityPickingPolicy.getProvider(), localityPickingLbConfig);\n+      ClusterImplConfig clusterImplConfig =\n+          new ClusterImplConfig(cluster, edsServiceName, lrsServerName, maxConcurrentRequests,\n+              dropOverloads, localityPicking, tlsContext);\n+      LoadBalancerProvider clusterImplLbProvider =\n+          lbRegistry.getProvider(XdsLbPolicies.CLUSTER_IMPL_POLICY_NAME);\n+      PolicySelection clusterImplPolicy =\n+          new PolicySelection(clusterImplLbProvider, clusterImplConfig);\n+      policies.put(priority, clusterImplPolicy);\n+    }\n+    return policies;\n+  }\n+\n+  private static WeightedTargetConfig generateLocalityPickingLbConfig(\n+      String cluster, @Nullable String edsServiceName, @Nullable String lrsServerName,\n+      PolicySelection endpointPickingPolicy, LoadBalancerRegistry lbRegistry,\n+      Map<Locality, Integer> localityWeights) {\n+    Map<String, WeightedPolicySelection> targets = new HashMap<>();\n+    for (Locality locality : localityWeights.keySet()) {\n+      int weight = localityWeights.get(locality);\n+      PolicySelection childPolicy =\n+          generateLocalityLbConfig(locality, cluster, edsServiceName, lrsServerName,\n+              endpointPickingPolicy, lbRegistry);\n+      targets.put(localityName(locality), new WeightedPolicySelection(weight, childPolicy));\n+    }\n+    return new WeightedTargetConfig(Collections.unmodifiableMap(targets));\n+  }\n+\n+  /**\n+   * Generates intra-locality LB policy (with config) for the given locality.\n+   */\n+  private static PolicySelection generateLocalityLbConfig(\n+      Locality locality, String cluster, @Nullable String edsServiceName,\n+      @Nullable String lrsServerName, PolicySelection endpointPickingPolicy,\n+      LoadBalancerRegistry lbRegistry) {\n+    PolicySelection policy;\n+    if (lrsServerName != null) {\n+      LrsConfig childConfig =\n+          new LrsConfig(cluster, edsServiceName, lrsServerName, locality, endpointPickingPolicy);\n+      LoadBalancerProvider childPolicyProvider = lbRegistry.getProvider(LRS_POLICY_NAME);\n+      policy = new PolicySelection(childPolicyProvider, childConfig);\n+    } else {\n+      policy = endpointPickingPolicy;\n+    }\n+    return policy;\n+  }\n+\n+  /**\n+   * Generate a string that represents the priority in the LB policy config. The string is unique\n+   * across priorities in all clusters. The string is alphabetically comparable with predicate\n+   * priorityName(c, p1) < priorityName(c, p2) iff p1 < p2. The ordering is undefined for\n+   * priorities in different clusters.\n+   */\n+  private static String priorityName(String cluster, int priority) {\n+    return cluster + \"[priority\" + priority + \"]\";\n+  }\n+\n+  /**\n+   * Generate a string that represents the locality in the LB policy config. The string is unique", "originalCommit": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgyNjUyMA==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546826520", "bodyText": "Seems you assume the caller has de-duplicated the resolvedAddresses, not only resolvedAddresses.getLoadBalancingPolicyConfig(), so this code path can only be called once. This assumption on resolver and upstream lbs is too strong.", "author": "dapengzhang0", "createdAt": "2020-12-21T17:12:54Z", "path": "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver;\n+import io.grpc.NameResolver.ResolutionResult;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterImplLoadBalancerProvider.ClusterImplConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EdsResourceWatcher;\n+import io.grpc.xds.XdsClient.EdsUpdate;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cluster_resolver_experimental LB policy. This LB policy is the child LB policy\n+ * of the cds_experimental LB policy and the parent LB policy of the priority_experimental LB\n+ * policy in the xDS load balancing hierarchy. This policy resolves endpoints of non-aggregate\n+ * clusters (e.g., EDS or Logical DNS) and groups endpoints in priorities and localities to be\n+ * used in the downstream LB policies for ine-grained load balancing purposes.\n+ */\n+final class ClusterResolverLoadBalancer extends LoadBalancer {\n+\n+  private static final String LOGICAL_DNS_CLUSTER_ENDPOINT_PICKING_POLICY_OVERRIDE = \"pick_first\";\n+  private static final Locality logicalDnsClusterLocality = new Locality(\"\", \"\", \"\");\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final GracefulSwitchLoadBalancer delegate;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private ClusterResolverConfig config;\n+\n+  ClusterResolverLoadBalancer(Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(),\n+        new ExponentialBackoffPolicy.Provider());\n+  }\n+\n+  @VisibleForTesting\n+  ClusterResolverLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry,\n+      BackoffPolicy.Provider backoffPolicyProvider) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.authority = checkNotNull(checkNotNull(helper, \"helper\").getAuthority(), \"authority\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    delegate = new GracefulSwitchLoadBalancer(helper);\n+    logger = XdsLogger.withLogId(\n+        InternalLogId.allocate(\"cluster-resolver-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    ClusterResolverConfig config =\n+        (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (!Objects.equals(this.config, config)) {\n+      logger.log(XdsLogLevel.DEBUG, \"Config: {0}\", config);\n+      delegate.switchTo(new ClusterResolverLbStateFactory());\n+    }\n+    this.config = config;\n+    delegate.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    delegate.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    delegate.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class ClusterResolverLbStateFactory extends LoadBalancer.Factory {\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ClusterResolverLbState(helper);\n+    }\n+  }\n+\n+  /**\n+   * The state of a cluster_resolver LB working session. A new instance is created whenever\n+   * the cluster_resolver LB receives a new config. The old instance is replaced when the\n+   * new one is ready to handle new RPCs.\n+   */\n+  private final class ClusterResolverLbState extends LoadBalancer {\n+    private final Helper helper;\n+    private final List<String> clusters = new ArrayList<>();\n+    private final Map<String, ClusterState> clusterStates = new HashMap<>();\n+    // An aggregate cluster is thought of as a cluster that groups the endpoints of the underlying\n+    // clusters together for load balancing purposes only. Load balancing policies (both locality\n+    // level and endpoint level) are configured by the aggregate cluster and apply to all of its\n+    // underlying clusters.\n+    private PolicySelection localityPickingPolicy;\n+    private PolicySelection endpointPickingPolicy;\n+    private ResolvedAddresses resolvedAddresses;\n+    private LoadBalancer childLb;\n+\n+    ClusterResolverLbState(Helper helper) {\n+      this.helper = checkNotNull(helper, \"helper\");\n+      logger.log(XdsLogLevel.DEBUG, \"New ClusterResolverLbState\");\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      this.resolvedAddresses = resolvedAddresses;\n+      ClusterResolverConfig config =\n+          (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+      for (DiscoveryMechanism instance : config.discoveryMechanisms) {\n+        clusters.add(instance.cluster);", "originalCommit": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg5OTQ0OA==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546899448", "bodyText": "What do you mean for resolvedAddresses is de-duplicated? It is assuming clusters in the DiscoveryMechanism list are unique. Isn't that a valid assumption?\nThis is in the switchable component of ClusterResolverLoadBalancer, which is instantiated for any ClusterResolverConfig changes. It's a very coarse-grained handling for state transition, and initially I did not like it as mentioned in the design as this causes the whole LB subtree to be changed every time a single cluster's configuration changes. But after trying out other approaches such as to handle each cluster's configuration changes individually inside the LB policy, there were some very subtle issues such as keeping each update atomic and consistent.", "author": "voidzcy", "createdAt": "2020-12-21T19:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgyNjUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkwNTI5Mw==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546905293", "bodyText": "What do you mean for resolvedAddresses is de-duplicated?\n\nBy de-duplicated, I mean handleResolvedAddresses() only gets called once for ClusterResolverLbState. Yes, resolvedAddresses.getLoadBalancingPolicyConfig() is never changed for ClusterResolverLbState, but could handleResolvedAddresses() be called more than once? Why not call delegate.handleResolvedAddresses(resolvedAddresses) inside if (!Objects.equals(this.config, config)) {}", "author": "dapengzhang0", "createdAt": "2020-12-21T20:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgyNjUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkxODkyOA==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546918928", "bodyText": "I see, you mean superfluous updates. Fixed now.", "author": "voidzcy", "createdAt": "2020-12-21T20:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgyNjUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg0NTY0Nw==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r546845647", "bodyText": "Why this change? I might have missed a discussion about it.", "author": "dapengzhang0", "createdAt": "2020-12-21T17:52:15Z", "path": "xds/src/main/java/io/grpc/xds/ClusterResolverLoadBalancer.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver;\n+import io.grpc.NameResolver.ResolutionResult;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterImplLoadBalancerProvider.ClusterImplConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EdsResourceWatcher;\n+import io.grpc.xds.XdsClient.EdsUpdate;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cluster_resolver_experimental LB policy. This LB policy is the child LB policy\n+ * of the cds_experimental LB policy and the parent LB policy of the priority_experimental LB\n+ * policy in the xDS load balancing hierarchy. This policy resolves endpoints of non-aggregate\n+ * clusters (e.g., EDS or Logical DNS) and groups endpoints in priorities and localities to be\n+ * used in the downstream LB policies for ine-grained load balancing purposes.\n+ */\n+final class ClusterResolverLoadBalancer extends LoadBalancer {\n+\n+  private static final String LOGICAL_DNS_CLUSTER_ENDPOINT_PICKING_POLICY_OVERRIDE = \"pick_first\";\n+  private static final Locality logicalDnsClusterLocality = new Locality(\"\", \"\", \"\");\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final GracefulSwitchLoadBalancer delegate;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private ClusterResolverConfig config;\n+\n+  ClusterResolverLoadBalancer(Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(),\n+        new ExponentialBackoffPolicy.Provider());\n+  }\n+\n+  @VisibleForTesting\n+  ClusterResolverLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry,\n+      BackoffPolicy.Provider backoffPolicyProvider) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.authority = checkNotNull(checkNotNull(helper, \"helper\").getAuthority(), \"authority\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    delegate = new GracefulSwitchLoadBalancer(helper);\n+    logger = XdsLogger.withLogId(\n+        InternalLogId.allocate(\"cluster-resolver-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    ClusterResolverConfig config =\n+        (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (!Objects.equals(this.config, config)) {\n+      logger.log(XdsLogLevel.DEBUG, \"Config: {0}\", config);\n+      delegate.switchTo(new ClusterResolverLbStateFactory());\n+    }\n+    this.config = config;\n+    delegate.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    delegate.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    delegate.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class ClusterResolverLbStateFactory extends LoadBalancer.Factory {\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ClusterResolverLbState(helper);\n+    }\n+  }\n+\n+  /**\n+   * The state of a cluster_resolver LB working session. A new instance is created whenever\n+   * the cluster_resolver LB receives a new config. The old instance is replaced when the\n+   * new one is ready to handle new RPCs.\n+   */\n+  private final class ClusterResolverLbState extends LoadBalancer {\n+    private final Helper helper;\n+    private final List<String> clusters = new ArrayList<>();\n+    private final Map<String, ClusterState> clusterStates = new HashMap<>();\n+    // An aggregate cluster is thought of as a cluster that groups the endpoints of the underlying\n+    // clusters together for load balancing purposes only. Load balancing policies (both locality\n+    // level and endpoint level) are configured by the aggregate cluster and apply to all of its\n+    // underlying clusters.\n+    private PolicySelection localityPickingPolicy;\n+    private PolicySelection endpointPickingPolicy;\n+    private ResolvedAddresses resolvedAddresses;\n+    private LoadBalancer childLb;\n+\n+    ClusterResolverLbState(Helper helper) {\n+      this.helper = checkNotNull(helper, \"helper\");\n+      logger.log(XdsLogLevel.DEBUG, \"New ClusterResolverLbState\");\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      this.resolvedAddresses = resolvedAddresses;\n+      ClusterResolverConfig config =\n+          (ClusterResolverConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+      for (DiscoveryMechanism instance : config.discoveryMechanisms) {\n+        clusters.add(instance.cluster);\n+        ClusterState state;\n+        if (instance.type == DiscoveryMechanism.Type.EDS) {\n+          state =\n+              new EdsClusterState(instance.cluster, instance.edsServiceName,\n+                  instance.lrsServerName, instance.maxConcurrentRequests, instance.tlsContext);\n+          clusterStates.put(instance.cluster, state);\n+        } else {  // logical DNS\n+          state = new LogicalDnsClusterState(instance.cluster, instance.lrsServerName,\n+              instance.maxConcurrentRequests, instance.tlsContext);\n+          clusterStates.put(instance.cluster, state);\n+        }\n+        state.start();\n+        localityPickingPolicy = config.localityPickingPolicy;\n+        endpointPickingPolicy = config.endpointPickingPolicy;\n+      }\n+    }\n+\n+    @Override\n+    public void handleNameResolutionError(Status error) {\n+      if (childLb != null) {\n+        childLb.handleNameResolutionError(error);\n+      } else {\n+        helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+      }\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      for (ClusterState state : clusterStates.values()) {\n+        state.shutdown();\n+      }\n+      if (childLb != null) {\n+        childLb.shutdown();\n+      }\n+    }\n+\n+    private void handleEndpointResourceUpdate() {\n+      List<EquivalentAddressGroup> addresses = new ArrayList<>();\n+      Map<String, PolicySelection> priorityLbPolicies = new HashMap<>();\n+      List<String> priorities = new ArrayList<>();  // totally ordered priority list\n+      boolean allResolved = true;\n+      for (String cluster : clusters) {\n+        ClusterState state = clusterStates.get(cluster);\n+        if (!state.resolved) {\n+          allResolved = false;\n+          continue;\n+        }\n+        if (state.result != null) {\n+          addresses.addAll(state.result.addresses);\n+          priorityLbPolicies.putAll(state.result.priorityLbPolicies);\n+          priorities.addAll(state.result.priorities);\n+        }\n+      }\n+      if (addresses.isEmpty()) {\n+        if (childLb != null) {\n+          childLb.shutdown();\n+          childLb = null;\n+        }\n+        if (allResolved) {\n+          Status unavailable = Status.UNAVAILABLE.withDescription(\"No endpoint available\");\n+          helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(unavailable));\n+        } else {\n+          helper.updateBalancingState(CONNECTING, BUFFER_PICKER);\n+        }\n+        return;\n+      }\n+      PriorityLbConfig childConfig =\n+          new PriorityLbConfig(Collections.unmodifiableMap(priorityLbPolicies),\n+              Collections.unmodifiableList(priorities));\n+      if (childLb == null) {\n+        childLb = lbRegistry.getProvider(PRIORITY_POLICY_NAME).newLoadBalancer(helper);\n+      }\n+      childLb.handleResolvedAddresses(\n+          resolvedAddresses.toBuilder()\n+              .setLoadBalancingPolicyConfig(childConfig)\n+              .setAddresses(Collections.unmodifiableList(addresses))\n+              .build());\n+    }\n+\n+    private void handleEndpointResolutionError() {\n+      boolean allInError = true;\n+      for (ClusterState state :  clusterStates.values()) {\n+        if (state.status.isOk()) {\n+          allInError = false;\n+        }\n+      }\n+      if (allInError) {\n+        // Propagate the error status of the last cluster. This is the best we can do.\n+        Status error = clusterStates.get(clusters.get(clusters.size() - 1)).status;\n+        if (childLb != null) {\n+          childLb.handleNameResolutionError(error);\n+        } else {\n+          helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Resolution state of an underlying cluster.\n+     */\n+    private abstract class ClusterState {\n+      // Name of the cluster to be resolved.\n+      protected final String name;\n+      // The resource name to be used for resolving endpoints via EDS.\n+      // Always null if the cluster is a logical DNS cluster.\n+      @Nullable\n+      protected final String edsServiceName;\n+      @Nullable\n+      protected final String lrsServerName;\n+      @Nullable\n+      protected final Long maxConcurrentRequests;\n+      @Nullable\n+      protected final UpstreamTlsContext tlsContext;\n+      // Resolution status, may contain most recent error encountered.\n+      protected Status status = Status.OK;\n+      // True if has received resolution result.\n+      protected boolean resolved;\n+      // Most recently resolved addresses and config, or null if resource not exists.\n+      @Nullable\n+      protected ClusterResolutionResult result;\n+      protected boolean shutdown;\n+\n+      private ClusterState(String name, @Nullable String edsServiceName,\n+          @Nullable String lrsServerName, @Nullable Long maxConcurrentRequests,\n+          @Nullable UpstreamTlsContext tlsContext) {\n+        this.name = name;\n+        this.edsServiceName = edsServiceName;\n+        this.lrsServerName = lrsServerName;\n+        this.maxConcurrentRequests = maxConcurrentRequests;\n+        this.tlsContext = tlsContext;\n+      }\n+\n+      abstract void start();\n+\n+      void shutdown() {\n+        shutdown = true;\n+      }\n+    }\n+\n+    private class EdsClusterState extends ClusterState implements EdsResourceWatcher {\n+\n+      private EdsClusterState(String name, @Nullable String edsServiceName,\n+          @Nullable String lrsServerName, @Nullable Long maxConcurrentRequests,\n+          @Nullable UpstreamTlsContext tlsContext) {\n+        super(name, edsServiceName, lrsServerName, maxConcurrentRequests, tlsContext);\n+      }\n+\n+      @Override\n+      void start() {\n+        String resourceName = edsServiceName != null ? edsServiceName : name;\n+        logger.log(XdsLogLevel.INFO, \"Start watching EDS resource {0}\", resourceName);\n+        xdsClient.watchEdsResource(resourceName, this);\n+      }\n+\n+      @Override\n+      protected void shutdown() {\n+        super.shutdown();\n+        String resourceName = edsServiceName != null ? edsServiceName : name;\n+        logger.log(XdsLogLevel.INFO, \"Stop watching EDS resource {0}\", resourceName);\n+        xdsClient.cancelEdsResourceWatch(resourceName, this);\n+      }\n+\n+      @Override\n+      public void onChanged(final EdsUpdate update) {\n+        class EndpointsUpdated implements Runnable {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            logger.log(XdsLogLevel.DEBUG, \"Received endpoint update {0}\", update);\n+            if (logger.isLoggable(XdsLogLevel.INFO)) {\n+              logger.log(XdsLogLevel.INFO, \"Cluster {0}: {1} localities, {2} drop categories\",\n+                  update.getClusterName(), update.getLocalityLbEndpointsMap().size(),\n+                  update.getDropPolicies().size());\n+            }\n+            Map<Locality, LocalityLbEndpoints> localityLbEndpoints =\n+                update.getLocalityLbEndpointsMap();\n+            List<DropOverload> dropOverloads = update.getDropPolicies();\n+            List<EquivalentAddressGroup> addresses = new ArrayList<>();\n+            Map<String, Map<Locality, Integer>> prioritizedLocalityWeights = new HashMap<>();\n+            for (Locality locality : localityLbEndpoints.keySet()) {\n+              LocalityLbEndpoints localityLbInfo = localityLbEndpoints.get(locality);\n+              int priority = localityLbInfo.getPriority();\n+              String priorityName = priorityName(name, priority);\n+              boolean discard = true;\n+              for (LbEndpoint endpoint : localityLbInfo.getEndpoints()) {\n+                if (endpoint.isHealthy()) {\n+                  discard = false;\n+                  EquivalentAddressGroup eag =\n+                      AddressFilter.setPathFilter(\n+                          endpoint.getAddress(),\n+                          Arrays.asList(priorityName, localityName(locality)));\n+                  addresses.add(eag);\n+                }\n+              }\n+              if (discard) {\n+                logger.log(XdsLogLevel.INFO,\n+                    \"Discard locality {0} with 0 healthy endpoints\", locality);\n+                continue;\n+              }\n+              if (!prioritizedLocalityWeights.containsKey(priorityName)) {\n+                prioritizedLocalityWeights.put(priorityName, new HashMap<Locality, Integer>());\n+              }\n+              prioritizedLocalityWeights.get(priorityName).put(\n+                  locality, localityLbInfo.getLocalityWeight());\n+            }\n+            if (prioritizedLocalityWeights.isEmpty()) {\n+              // Transient state, neither as a result or an error.", "originalCommit": "69d8a852ae6977ba771dac40a2d3aff54c6ab594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAxNzI2OA==", "url": "https://github.com/grpc/grpc-java/pull/7685#discussion_r547017268", "bodyText": "Changed to still propagate the update. It will behave the same as the EDS resource does not exist.\nThe desired behavior is still questionable:\nWhen receiving an EDS update that contains priorities/localities but no usable endpoints (in reality we've seen this happen transiently during TD resource migration): should this behave the same as the corresponding EDS resource has been removed? Or keep using previous received usable endpoints if any. Otherwise, keep waiting for next update.", "author": "voidzcy", "createdAt": "2020-12-22T01:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg0NTY0Nw=="}], "type": "inlineReview"}, {"oid": "1128c482a7db81059eaad9c3e253ba06aa746160", "url": "https://github.com/grpc/grpc-java/commit/1128c482a7db81059eaad9c3e253ba06aa746160", "message": "Fix/enhance comments.", "committedDate": "2020-12-21T19:12:55Z", "type": "commit"}, {"oid": "0fcb02f5308834349a571e3189a6a80d27e15619", "url": "https://github.com/grpc/grpc-java/commit/0fcb02f5308834349a571e3189a6a80d27e15619", "message": "Eliminate verbose variable for 'pick_first'.", "committedDate": "2020-12-21T19:14:27Z", "type": "commit"}, {"oid": "f43c6f7fa164540e823768b7dcafa2e5bb34c773", "url": "https://github.com/grpc/grpc-java/commit/f43c6f7fa164540e823768b7dcafa2e5bb34c773", "message": "Should only set locality/endpoint picking policy once.", "committedDate": "2020-12-21T19:17:23Z", "type": "commit"}, {"oid": "7a7f28be85ef15d12c7cc4d541ccc9ca19b5eac5", "url": "https://github.com/grpc/grpc-java/commit/7a7f28be85ef15d12c7cc4d541ccc9ca19b5eac5", "message": "Avoid superfluous invocation of handleResolvedAddresses.", "committedDate": "2020-12-21T20:38:45Z", "type": "commit"}, {"oid": "bcb08310acad87864dfbe01686fe81fdb146ce8f", "url": "https://github.com/grpc/grpc-java/commit/bcb08310acad87864dfbe01686fe81fdb146ce8f", "message": "Still propagate EDS updates with no usable endpoints, as if the resource is revoked.", "committedDate": "2020-12-22T01:01:40Z", "type": "commit"}, {"oid": "24da2d80af0065db5d342ddfbb10e9f121c53dd1", "url": "https://github.com/grpc/grpc-java/commit/24da2d80af0065db5d342ddfbb10e9f121c53dd1", "message": "Upper case for constant.", "committedDate": "2020-12-22T18:12:48Z", "type": "commit"}, {"oid": "aee808bf0fb559e56fdfee67de3ab4be8dcf5f9e", "url": "https://github.com/grpc/grpc-java/commit/aee808bf0fb559e56fdfee67de3ab4be8dcf5f9e", "message": "Fix cosmetic style issue.", "committedDate": "2020-12-22T18:30:32Z", "type": "commit"}]}