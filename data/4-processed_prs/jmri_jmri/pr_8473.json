{"pr_number": 8473, "pr_title": "Cleanup of duplicate / inefficient code working with XNetReply feedback.", "pr_createdAt": "2020-05-02T08:29:02Z", "pr_url": "https://github.com/JMRI/JMRI/pull/8473", "timeline": [{"oid": "980841c0e4b153293497e4e9d25444ffebafd953", "url": "https://github.com/JMRI/JMRI/commit/980841c0e4b153293497e4e9d25444ffebafd953", "message": "Cleanup of duplicate / inefficient code working with XNetReply feedback.", "committedDate": "2020-05-02T08:24:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3Mjk2Mw==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418972963", "bodyText": "Why a Deque here?  we really only need a Queue.  Seems like extra overhead.", "author": "pabender", "createdAt": "2020-05-02T15:40:34Z", "path": "java/src/jmri/jmrix/lenz/XNetTurnout.java", "diffHunk": "@@ -132,7 +134,7 @@ public XNetTurnout(String prefix, int pNumber, XNetTrafficController controller)\n         _prefix = prefix;\n         mNumber = pNumber;\n \n-        requestList = new LinkedBlockingQueue<>();\n+        requestList = new ArrayDeque<>();", "originalCommit": "980841c0e4b153293497e4e9d25444ffebafd953", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3NzU0NA==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418977544", "bodyText": "Good, let's have aLinkedList, which is probably the simplest implementation of Queue. However its runtime overhead is higher than ArrayDeque backed by an array.", "author": "svatoun", "createdAt": "2020-05-02T16:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3Mjk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk4MDg2NQ==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418980865", "bodyText": "OK.  That is a reason.  I just asked why, didn't ask for a change.", "author": "pabender", "createdAt": "2020-05-02T16:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3Mjk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk4Njc4MQ==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418986781", "bodyText": "@pabender I do value code quality and correctness: the field ought to be Queue. There was no irony in my answers -- I do need to change my bad habits when a reviewer discovers them.", "author": "svatoun", "createdAt": "2020-05-02T17:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3Mjk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzQyMw==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418973423", "bodyText": "Removing this may be problematic.\nThe feedback has to be able to trigger an off message.\nI will need to verify this works with real hardware.", "author": "pabender", "createdAt": "2020-05-02T15:44:17Z", "path": "java/src/jmri/jmrix/lenz/XNetTurnout.java", "diffHunk": "@@ -385,35 +383,23 @@ private synchronized void handleDirectModeFeedback(XNetReply l) {\n             l.resetUnsolicited();\n         }\n         if (getCommandedState() != getKnownState() || internalState == COMMANDSENT) {\n-            if (l.isFeedbackBroadcastMessage()) {\n-                int numDataBytes = l.getElement(0) & 0x0f;\n-                for (int i = 1; i < numDataBytes; i += 2) {\n-                    int messageType = l.getFeedbackMessageType(i);\n-                    if (messageType == 0 || messageType == 1) {\n-                        if ((mNumber % 2 != 0\n-                                && (l.getTurnoutMsgAddr(i) == mNumber))\n-                                || (((mNumber % 2) == 0)\n-                                && (l.getTurnoutMsgAddr(i) == mNumber - 1))) {\n-                            // This message includes feedback for this turnout\n-                            log.debug(\"Turnout {} DIRECT feedback mode - directed reply received.\", mNumber);\n-                            // set the reply as being solicited\n-                            if (l.isUnsolicited()) {\n-                                l.resetUnsolicited();\n-                            }\n-                            sendOffMessage();", "originalCommit": "980841c0e4b153293497e4e9d25444ffebafd953", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3NzkxNA==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418977914", "bodyText": "Please verify again. I am almost positive these lines were not removed, but moved to \n  \n    \n      JMRI/java/src/jmri/jmrix/lenz/XNetTurnout.java\n    \n    \n         Line 396\n      in\n      980841c\n    \n    \n    \n    \n\n        \n          \n           if (l.isUnsolicited()) { \n        \n    \n  \n\n.\nSimilar for other supposed removals.", "author": "svatoun", "createdAt": "2020-05-02T16:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzQyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk4MDU5OQ==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418980599", "bodyText": "OK.  It works with real hardware, which is what I care about.", "author": "pabender", "createdAt": "2020-05-02T16:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzQ5NA==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418973494", "bodyText": "Removing this may be problematic.\nThe feedback has to be able to trigger an off message.\nI will need to verify this works with real hardware.", "author": "pabender", "createdAt": "2020-05-02T15:44:46Z", "path": "java/src/jmri/jmrix/lenz/XNetTurnout.java", "diffHunk": "@@ -435,41 +421,26 @@ private synchronized void handleMonitoringModeFeedback(XNetReply l) {\n          */\n         log.debug(\"Handle Message for turnout {} in MONITORING feedback mode \", mNumber);\n         if (internalState == IDLE || internalState == STATUSREQUESTSENT) {\n-            if (l.isFeedbackBroadcastMessage()) {\n-                // This is a feedback message, we need to check and see if it\n-                // indicates this turnout is to change state or if it is for\n-                // another turnout.\n-                int numDataBytes = l.getElement(0) & 0x0f;\n-                for (int i = 1; i < numDataBytes; i += 2) {\n-                    if (parseFeedbackMessage(l, i) != -1) {\n-                        log.debug(\"Turnout {} MONITORING feedback mode - state change from feedback.\", mNumber);\n-                        break;\n-                    }\n-                }\n+            if (l.onTurnoutFeedback(mNumber, this::parseFeedbackMessage)) {\n+                log.debug(\"Turnout {} MONITORING feedback mode - state change from feedback.\", mNumber);\n             }\n         } else if (getCommandedState() != getKnownState()\n                 || internalState == COMMANDSENT) {\n-            if (l.isFeedbackBroadcastMessage()) {\n-                int numDataBytes = l.getElement(0) & 0x0f;\n-                for (int i = 1; i < numDataBytes; i += 2) {\n-                    int messageType = l.getFeedbackMessageType(i);\n-                    if (messageType == 0 || messageType == 1) {\n-                        // In Monitoring mode, treat both turnouts with feedback\n-                        // and turnouts without feedback as turnouts without\n-                        // feedback.  i.e. just interpret the feedback\n-                        // message, don't check to see if the motion is complete\n-                        if (parseFeedbackMessage(l, i) != -1) {\n-                            // We need to tell the turnout to shut off the output.\n-                            log.debug(\"Turnout {} MONITORING feedback mode - state change from feedback, CommandedState != KnownState.\", mNumber);\n-                            sendOffMessage();", "originalCommit": "980841c0e4b153293497e4e9d25444ffebafd953", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "211379d6f4fc3664330485e53a6b779f0cc9d204", "url": "https://github.com/JMRI/JMRI/commit/211379d6f4fc3664330485e53a6b779f0cc9d204", "message": "Use simpler collection, just Queue is needed.", "committedDate": "2020-05-02T18:09:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAzNjUwOQ==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r419036509", "bodyText": "We don't use the @Nullable annotation, see https://www.jmri.org/help/en/html/doc/Technical/SpotBugs.shtml", "author": "bobjacobsen", "createdAt": "2020-05-03T02:33:31Z", "path": "java/src/jmri/jmrix/lenz/FeedbackItem.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package jmri.jmrix.lenz;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nullable;\n+import jmri.Turnout;\n+\n+/**\n+ * Represents a single response from the XpressNet.\n+ *\n+ * @author svatopluk.dedic@gmail.com Copyright (C) 2020\n+ *\n+ */\n+public class FeedbackItem {\n+    private final int number;\n+    private final int data;\n+    private final XNetReply reply;\n+\n+    protected FeedbackItem(XNetReply reply, int number, int data) {\n+        this.number = number;\n+        this.data = data;\n+        this.reply = reply;\n+    }\n+    \n+    /**\n+     * Determines if the feedback was solicited.\n+     * @return {@code true}, if feedback was solicited.\n+     */\n+    public boolean isUnsolicited() {\n+        return reply.isUnsolicited();\n+    }\n+\n+    /**\n+     * Resets the unsolicited flag in the reply.\n+     * @see XNetReply#resetUnsolicited()\n+     */\n+    public void resetUnsolicited() {\n+        reply.resetUnsolicited();\n+    }\n+    \n+    /**\n+     * Returns the (base) address of the item.\n+     * For turnouts, return the reported address. For encoders,\n+     * return the address of the first contained sensor\n+     * @return the address.\n+     */\n+    public int getAddress() {\n+        return number;\n+    }\n+\n+    /**\n+     * Determines if the feedback is for the given Turnout address\n+     * @param address address to check\n+     * @return {@code true}, if the item applies to the address.\n+     */\n+    public boolean matchesAddress(int address) {\n+        if (isAccessory()) {\n+            return number == address;\n+        } else {\n+            return ((address - 1) & ~0x03) + 1 == number;\n+        }\n+    }\n+\n+    /**\n+     * Determines if the turnout motion has completed. Requires decoder/switch\n+     * feedback to be processed by the command station; always {@code false} if not connected.\n+     * @return {@code true} if the motion is complete.\n+     */\n+    public boolean isMotionComplete() {\n+        return (data & 0x80) == 0;\n+    }\n+\n+    /**\n+     * Returns the feedback type.\n+     * <ul>\n+     * <li> 0: Turnout without feedback\n+     * <li> 1: Turnout with feedback\n+     * <li> 2: Feedback encoder\n+     * <li> 3: reserved, invalid\n+     * </ul>\n+     * @return feedback type.\n+     */\n+    public int getType() {\n+        return (data & 0b0110_0000) >> 5;\n+    }\n+\n+    /**\n+     * Translates raw value in {@link #getAccessoryStatus} into Turnout's CLOSED/THROWN\n+     * values\n+     * @return {@link Turnout#CLOSED}, {@link Turnout#THROWN} or -1 for inconsistent.s\n+     */\n+    public int getTurnoutStatus() {\n+        int t = getType();\n+        if (t > 1) {\n+            return -1;\n+        }\n+        switch (getAccessoryStatus()) {\n+            case 0x01: return Turnout.CLOSED;\n+            case 0x02: return Turnout.THROWN;\n+            default: // fall through\n+        }\n+        return -1;\n+    }\n+    \n+    /**\n+     * Returns true, if the feedback is from feedback encoder.\n+     * @return {@code true} for encoder feedback.\n+     */\n+    public boolean isEncoder() {\n+        return getType() == 2;\n+    }\n+    \n+    /**\n+     * Returns true, if the feedback is from turnout (accessory).\n+     * @return {@code true} for turnout feedback.\n+     */\n+    public boolean isAccessory() {\n+        return getType() < 2;\n+    }\n+\n+    /**\n+     * Gives status value as specified in XPressNet.\n+     * <ul>\n+     * <li> 0x00: turnout was not operated\n+     * <li> 0x01: last command was \"0\", turnout left, CLOSED.\n+     * <li> 0x02: last command was \"1\", turnout right, THROWN.\n+     * <li> 0x03: reserved, invalid\n+     * </ul>\n+     * The method returns 0x03, if the feedback is not for accessory.\n+     * @return accessory state.\n+     */\n+    public int getAccessoryStatus() {\n+        if (!isAccessory()) {\n+            return 0x03;    // invalid\n+        }\n+        return (number & 0x01) != 0 ? (data & 0b0011) : (data & 0b1100) >> 2;\n+    }\n+\n+    /**\n+     * Returns encoder feedback for the given sensor. The function return {@code null}\n+     * if the sensor number is not within this FeedbackItem range, or the item does\n+     * not represent an encoder feedback.\n+     * @param sensorNumber sensor number, starting with 1.\n+     * @return The sensor's reported bit value (true/false) or {@code null}, if \n+     * no encoder feedback for the sensor is found. \n+     */\n+    @CheckForNull\n+    public Boolean getEncoderStatus(int sensorNumber) {\n+        if (!matchesAddress(number) || isAccessory()) {\n+            return null;\n+        } else {\n+            return (data & (1 << ((sensorNumber -1) % 4))) > 0;\n+        }\n+    }\n+\n+    /**\n+     * Returns a FeedbackItem instance for the other accessory address reported in the\n+     * item. Returns {@code null} for non-accessory feedbacks.\n+     * @return instance for the paired accessory, or {@code null}.\n+     */\n+    @Nullable", "originalCommit": "211379d6f4fc3664330485e53a6b779f0cc9d204", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAzNzA2NA==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r419037064", "bodyText": "Not sure what it means to assertNonNull on a Boolean. Is that really what was intended? (Several places)", "author": "bobjacobsen", "createdAt": "2020-05-03T02:40:16Z", "path": "java/test/jmri/jmrix/lenz/XNetReplyTest.java", "diffHunk": "@@ -1387,7 +1395,288 @@ public void testToMonitorStringInvalidFeedbackReply(){\n         XNetReply r = new XNetReply(\"42 FF FF 42\");\n         Assert.assertEquals(\"Monitor String\",\"Feedback Response: 255 255\",r.toMonitorString());\n     }\n-\n+    \n+    /**\n+     * Checks that the number of feedback items are correctly returned.\n+     */\n+    @Test\n+    public void testFeedbackItemsCount() {\n+        XNetReply r = new XNetReply(\"42 05 48 0f\");\n+        assertEquals(\"Feedback has single item\", 1, r.getFeedbackMessageItems());\n+        r = new XNetReply(\"46 05 48 06 48 07 48 0f\");\n+        assertEquals(\"Feedback has 3 items\", 3, r.getFeedbackMessageItems());\n+        r = new XNetReply(\"E3 32 00 04 C5\");\n+        assertEquals(0, r.getFeedbackMessageItems());\n+    }\n+    \n+    /**\n+     * Checks that all information is consistent from the Feedback item, \n+     * and are consistent with data served from XNetReply.\n+     * \n+     * @param reply the original reply\n+     * @param startByte start byte where the Feedback item came from\n+     * @param address the expected address\n+     * @param aStatus the expected status\n+     * @param tType the expected feedback type\n+     * @param fItem the expected feedback address \n+     */\n+    private void assertTurnoutFeedbackData(XNetReply reply, int startByte, int address, \n+            int aStatus, int tType, FeedbackItem fItem) {\n+        \n+        // general accessory feedback constraints\n+        assertFalse(\"Must not be encoder\", fItem.isEncoder());\n+        assertNull(\"Encoder functions disabled\", fItem.getEncoderStatus(address));\n+        assertTrue(\"Must be accessory\", fItem.isAccessory());\n+        \n+        // info consistent with the reply's original accessors\n+        assertEquals(\"Motion same as reply\", reply.isFeedbackMotionComplete(startByte), fItem.isMotionComplete());\n+        if ((address & 0x01) == 1) {\n+            assertTrue(\"Accepts reply's odd address\", fItem.matchesAddress(reply.getTurnoutMsgAddr(startByte)));\n+            assertEquals(address, reply.getTurnoutMsgAddr(startByte));\n+        } else {\n+            assertTrue(\"Accepts reply's even address\", fItem.matchesAddress(reply.getTurnoutMsgAddr(startByte) + 1));\n+            assertEquals(address, reply.getTurnoutMsgAddr(startByte) + 1);\n+        }\n+        assertEquals(\"Solicited same as reply\", reply.isUnsolicited(), fItem.isUnsolicited());\n+        \n+        assertEquals(\"Invalid feedback type\", tType, fItem.getType());\n+        assertEquals(\"Raw accessory status\", aStatus, fItem.getAccessoryStatus());\n+\n+        int lowAddress = (address & 0x01) > 0 ? address - 1 : address - 2;\n+        int pairAddress = (address & 0x01) > 0 ? address + 1 : address - 1;\n+        int highAddress = (address & 0x01) > 0 ? address + 2 : address + 1;\n+        \n+        assertTrue(\"Must accept own address\", fItem.matchesAddress(address));\n+        assertFalse(\"Must not accept other pair's address\", fItem.matchesAddress(pairAddress));\n+        assertFalse(\"Must not accept other addresses\", fItem.matchesAddress(lowAddress));\n+        assertFalse(\"Must not accept other addresses\", fItem.matchesAddress(highAddress));\n+\n+        int tStatus;\n+        switch (aStatus) {\n+            case 0x00: tStatus = -1; break; // not operated; shouldn't be UNKNOWN ?\n+            case 0x01: tStatus = Turnout.CLOSED; break;\n+            case 0x02: tStatus = Turnout.THROWN; break;\n+            case 0x03: tStatus = -1; break; // invalid; shouldn't be INCONSISTENT ?\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+        assertEquals(\"Turnout status\", tStatus, fItem.getTurnoutStatus());\n+        \n+        // check the paired item:\n+        FeedbackItem paired = fItem.pairedAccessoryItem();\n+        assertNotNull(\"Accessory fedbacks are always in pairs\", paired);\n+        assertFalse(\"Must not be encoder\", paired.isEncoder());\n+        assertTrue(\"Must be accessory\", paired.isAccessory());\n+        assertEquals(\"Invalid feedback type\", tType, paired.getType());\n+        assertEquals(\"Solicited same as reply\", reply.isUnsolicited(), paired.isUnsolicited());\n+        assertFalse(\"Must not accept pair's address\", paired.matchesAddress(address));\n+    }\n+    \n+    /**\n+     * Checks that information can be read from single-item feedback and\n+     * the reply are consistent.\n+     */\n+    @Test\n+    public void testSingleFeedbackTurnoutItem() {\n+        // 5 * 4, lower nibble = 21 (N/A) +22 (T)\n+        // movement NOT complete; turnout WITH feedback.\n+        XNetReply r = new XNetReply(\"42 05 28 0f\");\n+        Optional<FeedbackItem> selected = r.selectTurnoutFeedback(20);\n+        assertFalse(\"Incorrect turnout number\", selected.isPresent());\n+        selected = r.selectTurnoutFeedback(23);\n+        assertFalse(\"Incorrect turnout number\", selected.isPresent());\n+        \n+        selected = r.selectTurnoutFeedback(21);\n+        assertTrue(selected.isPresent());\n+        \n+        FeedbackItem oddItem = selected.get();\n+\n+        assertTrue(\"Motion completed\", oddItem.isMotionComplete());\n+        assertTrue(\"Initially unsolicited\", oddItem.isUnsolicited());\n+        assertTurnoutFeedbackData(r, 1, 21, 0, 1, oddItem);\n+        \n+        selected = r.selectTurnoutFeedback(22);\n+        assertTrue(selected.isPresent());\n+        \n+        FeedbackItem evenItem = selected.get();\n+        assertTurnoutFeedbackData(r, 1, 22, 2, 1, evenItem);\n+        \n+        // make solicited:\n+        oddItem.resetUnsolicited();\n+        assertFalse(r.isUnsolicited());\n+        \n+        // 5 * 4, upper nibble = 23 (C) + 24 (T)\n+        // movement IS complete; turnout WITHOUT feedback.\n+        r = new XNetReply(\"42 05 95 0f\");\n+        selected = r.selectTurnoutFeedback(23);\n+        assertTrue(selected.isPresent());\n+        \n+        oddItem = selected.get();\n+        assertFalse(\"Motion incomplete\", oddItem.isMotionComplete());\n+        assertTurnoutFeedbackData(r, 1, 23, 1, 0, oddItem);\n+        \n+        selected = r.selectTurnoutFeedback(24);\n+        assertTrue(selected.isPresent());\n+        evenItem = selected.get();\n+        assertTurnoutFeedbackData(r, 1, 24, 1, 0, evenItem);\n+    }\n+    \n+    /**\n+     * Checks that feedback module item gives invalid / erroneous / null\n+     * information when used as accessory.\n+     */\n+    @Test\n+    public void testOtherRepliesAsAccessoryFeedback() {\n+        XNetReply r = new XNetReply(\"42 05 58 0f\");\n+        // test directly the item\n+        FeedbackItem item = new FeedbackItem(r, 45, 0x58);\n+        assertEquals(45, item.getAddress());\n+        for (int a = 45; a < 45 + 4; a++) {\n+            assertTrue(item.matchesAddress(a));\n+            // last bit is set, all others are false.\n+            assertEquals(\"Bit state for sensor \" + a, a == 48, item.getEncoderStatus(a));\n+        }\n+        // does not match accessory for 0x05, 0x58\n+        assertFalse(item.matchesAddress(21));\n+        assertEquals(3, item.getAccessoryStatus());\n+        assertNull(item.pairedAccessoryItem());\n+\n+        // check that no turnout feedback can be selected\n+        for (int i = 1 ; i < 1024; i++) {\n+            assertFalse(r.selectTurnoutFeedback(i).isPresent());\n+        }\n+        \n+        // no accessory feedback present\n+        r = new XNetReply(\"E3 40 C1 04 61\");\n+        for (int i = 1 ; i < 1024; i++) {\n+            assertFalse(r.selectTurnoutFeedback(i).isPresent());\n+        }\n+    }\n+    \n+    /**\n+     * Checks that encoder feedback will return null for turnout\n+     * feedbacks.\n+     */\n+    @Test\n+    public void testOtherRepliesAsEncoder() {\n+        XNetReply r = new XNetReply(\"42 05 28 0f\");\n+        for (int i = 1 ; i < 1024; i++) {\n+            assertNull(r.selectModuleFeedback(i));\n+        }\n+        r = new XNetReply(\"E3 40 C1 04 61\");\n+        for (int i = 1 ; i < 1024; i++) {\n+            assertNull(r.selectModuleFeedback(i));\n+        }\n+\n+    }\n+\n+    \n+    /**\n+     * Checks that select will filter out accessories with an incorrect state.\n+     */\n+    @Test\n+    public void testInvalidAccessoryStateFiltered() {\n+        XNetReply r = new XNetReply(\"42 05 2B 0f\");\n+        Optional<FeedbackItem> opt = r.selectTurnoutFeedback(21);\n+        assertFalse(opt.isPresent());\n+        assertEquals(-1, r.getTurnoutStatus(1));\n+        \n+        opt = r.selectTurnoutFeedback(22);\n+        assertTrue(opt.isPresent());\n+        assertEquals(Turnout.THROWN, opt.get().getTurnoutStatus());\n+        assertEquals(r.getTurnoutStatus(0), opt.get().getTurnoutStatus());\n+    }\n+    \n+    @Test\n+    public void testSingleEncoderModuleFeedback() {\n+        // feedback 5 * 8  + 4 (upper nibble) (+1) = 45\n+        XNetReply r = new XNetReply(\"42 05 58 0f\");\n+        \n+        assertNull(r.selectModuleFeedback(44));\n+        \n+        for (int i = 45; i < 45 + 4; i++) {\n+            Boolean b = r.selectModuleFeedback(i);\n+            assertNotNull(b);", "originalCommit": "211379d6f4fc3664330485e53a6b779f0cc9d204", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1Mjg4Ng==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r419052886", "bodyText": "Boolean objects actually can be null.  It becomes a tristate variable:  True,False, or not Defined.  One of my co-workers uses this somewhat frequently.\nThe method this is testing is returning null if the reply this is applied to is not a feedback message.  If it is a feedback message, it returns the true/false value of the appropriate bit in the feedback message.\nSo it is a little different, but the meaning is correct.", "author": "pabender", "createdAt": "2020-05-03T05:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAzNzA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1Mzg0Mg==", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r419053842", "bodyText": "I did scratch my head with this return type: Optional<Boolean> would be more API consistent, lambda / stream friendly etc etc. But seemed so ridiculous...", "author": "svatoun", "createdAt": "2020-05-03T06:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAzNzA2NA=="}], "type": "inlineReview"}, {"oid": "a048134c694d7eab45c8efe7705daab920027d62", "url": "https://github.com/JMRI/JMRI/commit/a048134c694d7eab45c8efe7705daab920027d62", "message": "Use simpler collection, just Queue is needed.", "committedDate": "2020-05-05T21:11:04Z", "type": "commit"}, {"oid": "a048134c694d7eab45c8efe7705daab920027d62", "url": "https://github.com/JMRI/JMRI/commit/a048134c694d7eab45c8efe7705daab920027d62", "message": "Use simpler collection, just Queue is needed.", "committedDate": "2020-05-05T21:11:04Z", "type": "forcePushed"}]}