{"pr_number": 629, "pr_title": "Add capability of loading local formatting pattern files", "pr_createdAt": "2020-06-19T15:04:52Z", "pr_url": "https://github.com/vmware/singleton/pull/629", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMDE4MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453000181", "bodyText": "Why do we need a method that is specific to getting the En locale partterns?", "author": "jessiejuachon", "createdAt": "2020-07-10T18:17:17Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -4,21 +4,39 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n-import java.util.Map;\n-\n-import org.json.simple.JSONObject;\n-\n+import com.vmware.i18n.PatternUtil;\n import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+\n+import java.util.Map;\n \n public class LocalPatternOpt {\n \n-    public JSONObject getPatternsByLocale(String locale) {\n+    public JSONObject getEnPatterns(String locale) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMjE0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r455902147", "bodyText": "This follows the old workflow, remove this after implementing new workflow.", "author": "huihuiw01", "createdAt": "2020-07-16T16:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwMDE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNzM0OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453007348", "bodyText": "Why not patterns = getPatterns(LocaleUtility.getDefaultLocale())?", "author": "jessiejuachon", "createdAt": "2020-07-10T18:32:41Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMjk1MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r455902950", "bodyText": "This follows the old workflow, change to use default locale after implementing new workflow.", "author": "huihuiw01", "createdAt": "2020-07-16T16:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwNzM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwODQyOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453008429", "bodyText": "Why not patterns = getPatterns(LocaleUtility.getDefaultLocale())?", "author": "jessiejuachon", "createdAt": "2020-07-10T18:35:03Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMzU1MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r455903551", "bodyText": "This follows the old workflow, change to use default locale after implementing new workflow.", "author": "huihuiw01", "createdAt": "2020-07-16T16:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwODQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxMzMyOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453013328", "bodyText": "This does not follow the client workflow design. Always try to fetch from the service first even for the default locale, so remove the if-statement block.", "author": "jessiejuachon", "createdAt": "2020-07-10T18:43:01Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxNzE4OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453017189", "bodyText": "Do not use if-else statements to get the message origin from the msgOriginsQueue because the order may change in the future. in other words, .get(0) may not always return DataSourceEnum.VIP even if online mode is supported.\nInstead, iterate over msgOriginsQueue. See ComponentService.fetchMessages for reference to do this. Add a createPatternOpt method inside DataSourceEnum.Bundle which will return new LocalePatternOpt(). Add the same method inside DataSourceEnum.VIP which will return new RemotePatternOpt(). Use this DataSourceEnum.createPatternOpt just like in ComponentService.fetchMessages.\nIf you follow the above, the fallback from online to offline mode (and to any other mode added in the queue in the future) will naturally happen without having to modify this method.", "author": "jessiejuachon", "createdAt": "2020-07-10T18:48:23Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n             patterns = new LocalPatternOpt()\n-                    .getPatternsByLocale(ConstantsKeys.EN);\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-            \tpatterns = new RemotePatternOpt().getPatternsByLocale(locale);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAyNjAwNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453026005", "bodyText": "(Same comment as above)\nThis does not follow the client workflow design. Always try to fetch from the service first even for the default locale, so remove the if-statement block.", "author": "jessiejuachon", "createdAt": "2020-07-10T19:00:07Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n             patterns = new LocalPatternOpt()\n-                    .getPatternsByLocale(ConstantsKeys.EN);\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-            \tpatterns = new RemotePatternOpt().getPatternsByLocale(locale);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n+                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n+                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n             } else {\n-                patterns = new LocalPatternOpt().getPatternsByLocale(locale);\n+                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n             }\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String language, String region) {\n         JSONObject patterns = null;\n-        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-        \tpatterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n+        Locale locale = new Locale(language, region);\n+        if (LocaleUtility.isDefaultLocale(locale)) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAyNjY1OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r453026659", "bodyText": "(Same comment as above)\nDo not use if-else statements to get the message origin from the msgOriginsQueue because the order may change in the future. in other words, .get(0) may not always return DataSourceEnum.VIP even if online mode is supported.\nInstead, iterate over msgOriginsQueue. See ComponentService.fetchMessages for reference to do this. Add a createPatternOpt method inside DataSourceEnum.Bundle which will return new LocalePatternOpt(). Add the same method inside DataSourceEnum.VIP which will return new RemotePatternOpt(). Use this DataSourceEnum.createPatternOpt just like in ComponentService.fetchMessages.\nIf you follow the above, the fallback from online to offline mode (and to any other mode added in the queue in the future) will naturally happen without having to modify this method.", "author": "jessiejuachon", "createdAt": "2020-07-10T19:01:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n             patterns = new LocalPatternOpt()\n-                    .getPatternsByLocale(ConstantsKeys.EN);\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-            \tpatterns = new RemotePatternOpt().getPatternsByLocale(locale);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n+                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n+                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n             } else {\n-                patterns = new LocalPatternOpt().getPatternsByLocale(locale);\n+                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n             }\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String language, String region) {\n         JSONObject patterns = null;\n-        if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-        \tpatterns = new RemotePatternOpt().getPatternsByLocale(language, region);\n+        Locale locale = new Locale(language, region);\n+        if (LocaleUtility.isDefaultLocale(locale)) {\n+            logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n+            patterns = new LocalPatternOpt()\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            patterns = new LocalPatternOpt().getPatternsByLocale(ConstantsKeys.EN);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyODgxNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456128814", "bodyText": "Put this fallback logic in LocaleMessage so that this method here in LocaleService is always for the requested language only.\nOnce you move the fallback logic into LocaleMessage, update the cache in there in such a way that the key with the requested language is mapped to the FormatCacheItem of the fallback language.\nc.put(<cacheKeyOfRequestedLanguage>, new FormatCacheItem(<displayMapofFallbackLanguage>));\nWithout the above proposed changes, your code will always try to fetch the requested locale first before using the fallback locale that is already in the cache. With the above proposed changes, any succeeding calls for the requested language will immediately return the cached fallback locale until it expires.\nNote: You can either put the above logic in LocaleMessage as I propose (just like how it is in TranslationMessage.getMessages), or create another method here in LocaleService to keep the logic in the \"service layer\".", "author": "jessiejuachon", "createdAt": "2020-07-16T23:13:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt().getRegions(language);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+        }\n+        return regions;\n+    }\n+\n+    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(language == null || language.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        dispMap = getSupportedDisplayNames(language);\n+        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0MDAyNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456140024", "bodyText": "Are the language names coming from the offline CLDR?", "author": "jessiejuachon", "createdAt": "2020-07-16T23:49:34Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExNDg3Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r457114877", "bodyText": "Yes, because in online mode Singleton service get the language names from CLDR, so for offline mode I change the code to get the language names from CLDR, too.", "author": "huihuiw01", "createdAt": "2020-07-20T07:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0MDAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0MTE5Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456141197", "bodyText": "Why not use responseData.isEmpty()  instead of \"\".equalsIgnoreCase(responseData)?\nI saw other instances of this too.", "author": "jessiejuachon", "createdAt": "2020-07-16T23:53:01Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteLocaleOpt.java", "diffHunk": "@@ -28,11 +26,14 @@\n     public RemoteLocaleOpt() {\n     }\n \n-    public Map<String, String> getTerritoriesFromCLDR(String language) {\n+    public Map<String, String> getRegions(String language) {\n+        logger.debug(\"Look for regions from Singleton Service for locale [{}]!\", language);\n     \tMap<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(\n                 V2URL.getRegionListURL(language, VIPCfg.getInstance().getVipService().getHttpRequester().getBaseURL()),\n                 ConstantsKeys.GET, null);\n     \tString responseData = (String) response.get(URLUtils.BODY);\n+        if(responseData == null || \"\".equalsIgnoreCase(responseData))", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0NTA0MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456145040", "bodyText": "Put this fallback logic in PatternMessage so that this method here in PatternService is always for the requested language only.\nOnce you move the fallback logic into PatternMessage, update the cache in there in such a way that the key with the requested language is mapped to the FormatCacheItem of the fallback language.\nnew PatternCacheService().addPatterns(<keyOfRequestedLanguage>, <patternsOfDefaultLanguage>);\nWithout the above proposed changes, your code will always try to fetch the requested locale first before using the fallback locale that is already in the cache. With the above proposed changes, any succeeding calls for the requested language will immediately return the cached fallback locale until it expires.\nNote: You can either put the above logic in PatternMessage as I propose (just like how it is in TranslationMessage.getMessages), or create another method here in PatternService to keep the logic in the \"service layer\".", "author": "jessiejuachon", "createdAt": "2020-07-17T00:06:01Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -4,89 +4,107 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import java.util.ListIterator;\n+import java.util.Locale;\n \n /**\n  * The class represents date formatting\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n+    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n         JSONObject patterns = getPatterns(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n+        String cacheKey = PATTERNS_PREFIX + locale;\n+        patterns = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(cacheKey, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0NTQwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456145400", "bodyText": "Same comment as above (line 50)", "author": "jessiejuachon", "createdAt": "2020-07-17T00:07:16Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -4,89 +4,107 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import java.util.ListIterator;\n+import java.util.Locale;\n \n /**\n  * The class represents date formatting\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n+    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n         JSONObject patterns = getPatterns(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n+        String cacheKey = PATTERNS_PREFIX + locale;\n+        patterns = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(cacheKey, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(LocaleUtility.getDefaultLocale().toLanguageTag());\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = PATTERNS_PREFIX + language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0NzE2MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456147161", "bodyText": "Can this be private now? If yes, please change it to private.", "author": "jessiejuachon", "createdAt": "2020-07-17T00:13:35Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -4,17 +4,51 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n+import com.vmware.i18n.dto.LocaleDataDTO;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.util.Map;\n \n-import org.json.simple.JSONObject;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n-import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n+public class LocalPatternOpt implements PatternOpt{\n+    Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-public class LocalPatternOpt {\n+    public JSONObject getPatterns(String locale) {\n+        logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+        String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+        logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n+\n+    @Override\n+    public JSONObject getPatterns(String language, String region) {\n+        logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n+        LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n+        String normalizedLocale = resultData.getLocale();\n+        logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        Map<String, Object> patterns = PatternBundleUtil.readJSONFile(locale);\n+    public JSONObject getPatternsByLocale(String normalizedLocale) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5NTYzNw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r455495637", "bodyText": "Don't need this method because client should get the locale from language and region in offline mode.\nIn general, Getting Pattern by locale is enough.", "author": "Xiaochao8", "createdAt": "2020-07-16T03:59:07Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -30,63 +33,90 @@ public JSONObject getPatternsByCategory(String locale, String category) {\n \n     public JSONObject getPatterns(String locale) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n         patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(locale);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(locale, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromBundle(language, region);\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {\n+            logger.info(\"Can't find pattern for language [{}] region [{}], look for English pattern as fallback!\", language, region);\n+            patterns = getPatterns(ConstantsKeys.EN);\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String locale) {\n         JSONObject patterns = null;\n         if (LocaleUtility.isDefaultLocale(locale)) {\n-            logger.debug(\"Got pattern from local bundle!\");\n+            logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n             patterns = new LocalPatternOpt()\n-                    .getPatternsByLocale(ConstantsKeys.EN);\n+                    .getEnPatterns(ConstantsKeys.EN);\n         } else {\n-            if (VIPCfg.getInstance().getMessageOrigin() == DataSourceEnum.VIP) {\n-            \tpatterns = new RemotePatternOpt().getPatternsByLocale(locale);\n+            if (VIPCfg.getInstance().getMsgOriginsQueue().get(0) == DataSourceEnum.VIP) {\n+                logger.debug(\"Look for pattern from Singleton Service for locale [{}]!\", locale);\n+                patterns = new RemotePatternOpt().getPatternsByLocale(locale);\n             } else {\n-                patterns = new LocalPatternOpt().getPatternsByLocale(locale);\n+                logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+                String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+                logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+                patterns = new LocalPatternOpt().getPatternsByLocale(normalizedLocale);\n             }\n         }\n         return patterns;\n     }\n \n     private JSONObject getPatternsFromBundle(String language, String region) {", "originalCommit": "7548f619a3d318068aba1d886a10adb19ed4b9f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU3OTczNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465579736", "bodyText": "Yeah, but this depends on doing locale fallback/normalization first, and currently locale fallback/normalization is based on cldr locale related data. So this means L2 data needed for locale fallback/normalization must be always included in Java client package.\nBut currently to reduce the size of Java client package, pattern data is put into a separate jar, and for online mode this jar isn't neccessary. If product choose online mode and don't add this jar, change as your suggestion will lead to program broken.\nSo I prefer to remove this after we can guarantee data needed for locale fallback/normalization is always included or we define new locale fallback/normalization rule which doesn't relies on cldr data.", "author": "huihuiw01", "createdAt": "2020-08-05T09:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5NTYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjAyNw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456216027", "bodyText": "Need to log this?", "author": "Xiaochao8", "createdAt": "2020-07-17T04:47:32Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){\n+\t\tJSONObject languagesNames = null;\n+\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n+\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n+\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n+\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n+\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n+\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n+\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t}\n+\t\treturn languagesNames;\n+\n+\t}\n+\n+\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n+\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n+\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\t\t\treturn null;\n+\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\tJSONObject languagesData = null;\n+\t\ttry {\n+\t\t\tlanguagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjA1OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456216058", "bodyText": "Need to log this?", "author": "Xiaochao8", "createdAt": "2020-07-17T04:47:37Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){\n+\t\tJSONObject languagesNames = null;\n+\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n+\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n+\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n+\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n+\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n+\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n+\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t}\n+\t\treturn languagesNames;\n+\n+\t}\n+\n+\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n+\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n+\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\t\t\treturn null;\n+\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\tJSONObject languagesData = null;\n+\t\ttry {\n+\t\t\tlanguagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+\t\tif (languagesData == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t}\n+\n+\tpublic JSONObject getRegions(String displayLanguage) {\n+\t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", displayLanguage);\n+\t\tJSONObject regionsData = null;\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", displayLanguage, normalizedLocale);\n+\t\tif(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+\t\t\treturn null;\n+\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\ttry {\n+\t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjA4NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456216085", "bodyText": "Need to log this?", "author": "Xiaochao8", "createdAt": "2020-07-17T04:47:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -4,17 +4,51 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n+import com.vmware.i18n.dto.LocaleDataDTO;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.util.Map;\n \n-import org.json.simple.JSONObject;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n-import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n+public class LocalPatternOpt implements PatternOpt{\n+    Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-public class LocalPatternOpt {\n+    public JSONObject getPatterns(String locale) {\n+        logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+        String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+        logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n+\n+    @Override\n+    public JSONObject getPatterns(String language, String region) {\n+        logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n+        LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n+        String normalizedLocale = resultData.getLocale();\n+        logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        Map<String, Object> patterns = PatternBundleUtil.readJSONFile(locale);\n+    public JSONObject getPatternsByLocale(String normalizedLocale) {\n+        if(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+            return null;\n+        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n+        Map<String, Object> patterns = null;\n+        try {\n+            patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n+        } catch (ParseException e) {\n+            e.printStackTrace();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxOTE1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456219154", "bodyText": "Printf-style format strings should be used correctly (squid:S3457)", "author": "Xiaochao8", "createdAt": "2020-07-17T05:00:40Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNjE3OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456226178", "bodyText": "should  here be English?", "author": "Xiaochao8", "createdAt": "2020-07-17T05:28:59Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java", "diffHunk": "@@ -80,7 +77,7 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n     \n     private List<Locale> getSupportedLocales() {\n     \tMap<String, String> supportedLanguages = DataSourceEnum.Bundle.createLocaleOpt()\n-    \t\t\t.getLanguages(dto.getLocale());\n+    \t\t\t.getSupportedLanguages(dto.getLocale());", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE3MTU5NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458171595", "bodyText": "I only change the method's name, as discussed offline, here should not call 'getSupportedLanguages' in LocalLocaleOpt, but implement get supported locales in a new class 'LocalProductOpt', and call that.", "author": "huihuiw01", "createdAt": "2020-07-21T15:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNjE3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg4NDcwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458884700", "bodyText": "I have implemented as above reply.", "author": "huihuiw01", "createdAt": "2020-07-22T15:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNjE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2ODUwNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456268505", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    language = language.replace(\"_\", \"-\").toLowerCase();\n          \n          \n            \n                   language = language.replace(\"_\", \"-\").toLowerCase();", "author": "Xiaochao8", "createdAt": "2020-07-17T07:29:58Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5OTQyMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459199423", "bodyText": "Look like no change.", "author": "huihuiw01", "createdAt": "2020-07-23T03:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2ODUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3MzY2Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456273666", "bodyText": "Could remove this class?", "author": "Xiaochao8", "createdAt": "2020-07-17T07:40:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/util/PatternBundleUtil.java", "diffHunk": "@@ -8,13 +8,11 @@\n \n public class PatternBundleUtil {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3OTY3MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456279671", "bodyText": "Is it correct fallback here?\nAfter normalizing locale, fallback is unnecessary.", "author": "Xiaochao8", "createdAt": "2020-07-17T07:52:58Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){\n+\t\tJSONObject languagesNames = null;\n+\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n+\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n+\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n+\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n+\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxNTMzNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458215336", "bodyText": "I agree. A fallback logic must be applied only when the initial fetch for the requested displayLanguage fails.", "author": "jessiejuachon", "createdAt": "2020-07-21T16:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI3OTY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDkzOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456290939", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n          \n          \n            \n                private Map<String, String> getTerritoriesFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {", "author": "Xiaochao8", "createdAt": "2020-07-17T08:15:26Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEzMzYyNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458133624", "bodyText": "Unified the methods' name with 'Region'", "author": "huihuiw01", "createdAt": "2020-07-21T14:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MTYwNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456291604", "bodyText": "Change all region to Territory?", "author": "Xiaochao8", "createdAt": "2020-07-17T08:16:41Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1OTYzNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458159634", "bodyText": "Since the client API exposed to developer is getRegionList, so unified 'Territory' to 'region'.", "author": "huihuiw01", "createdAt": "2020-07-21T14:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MzAyMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456293022", "bodyText": "change to \"Argument is empty\"?", "author": "Xiaochao8", "createdAt": "2020-07-17T08:19:22Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt().getRegions(language);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+        }\n+        return regions;\n+    }\n+\n+    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(language == null || language.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTQyMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456295422", "bodyText": "Now client supports multiple configurations, can't get product and version in this way.", "author": "Xiaochao8", "createdAt": "2020-07-17T08:23:49Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -30,66 +31,112 @@ public LocaleService() {\n \n     public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n             List<String> languages) {\n-        \n         Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n         for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n+            if(language != null && !language.isEmpty()) {\n+                Map<String, String> regionMap = getTerritoriesFromCLDR(language);\n                 respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n             }\n         }\n         return respMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n+    public Map<String, String> getTerritoriesFromCLDR(String language){\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.trace(\"Look for region list of '\" + language + \"' from cache\");\n+        Cache c = VIPCfg.getInstance().getCacheManager().getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+            FormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n+                    + language);\n+            regionMap = cacheItem == null ? null : cacheItem.getCachedData();\n+        }\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", language);\n+            return regionMap;\n+        }\n+        Map<String, String> tmpMap = getRegionsFromDS(language, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (c != null && tmpMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", language);\n+            regionMap = JSONUtils.map2SortMap(tmpMap);\n+            FormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n+            c.put(REGION_PREFIX + language, cacheItem);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", language);\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            regionMap = getTerritoriesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getRegionsFromDS(String language, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt().getRegions(language);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(language, msgSourceQueueIter);\n+        }\n+        return regions;\n+    }\n+\n+    public Map<String, String> getDisplayNamesFromCLDR(String language) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(language == null || language.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        dispMap = getSupportedDisplayNames(language);\n+        if ((dispMap == null || dispMap.isEmpty()) && !LocaleUtility.isDefaultLocale(language)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", language);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+        }\n+        return dispMap;\n+    }\n+\n+    private Map<String, String> getSupportedDisplayNames(String language) {\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        logger.trace(\"Look for displayNames from cache\");\n         Cache c = VIPCfg.getInstance().getCacheManager()\n                 .getCache(VIPCfg.CACHE_L2);\n+        String productName = VIPCfg.getInstance().getProductName();", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMzI2Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456313266", "bodyText": "unused lines?", "author": "Xiaochao8", "createdAt": "2020-07-17T08:56:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -13,24 +27,25 @@\n import java.nio.file.Paths;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.Locale;\n import java.util.Map;\n import java.util.stream.Stream;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n+\tprivate static final String JSON_LANGUAGES = \"level2/localeData/{0}/languages.json\";\n+\tprivate static final String JSON_TERRITORIES = \"level2/localeData/{0}/territories.json\";", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTYwMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456315603", "bodyText": "Should call ProductService/LocalProductOpt to get this information rather than getting directly.", "author": "Xiaochao8", "createdAt": "2020-07-17T09:01:30Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxNzQ0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458217447", "bodyText": "@Xiaochao8 , what does the logic here have to do with \"product\"?", "author": "jessiejuachon", "createdAt": "2020-07-21T16:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNTYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxNzc1NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456317755", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n          \n          \n            \n                \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p ->p.toFile().isFile())) {", "author": "Xiaochao8", "createdAt": "2020-07-17T09:05:41Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NTQxNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456975415", "bodyText": "Suggest move fallback to PatternMessage class. There should a interface to get exact pattern data without fallback.", "author": "Xiaochao8", "createdAt": "2020-07-20T00:25:17Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -4,89 +4,107 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import java.util.ListIterator;\n+import java.util.Locale;\n \n /**\n  * The class represents date formatting\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n+    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n         JSONObject patterns = getPatterns(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n+        String cacheKey = PATTERNS_PREFIX + locale;\n+        patterns = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(cacheKey, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = getPatterns(LocaleUtility.getDefaultLocale().toLanguageTag());\n         }\n         return patterns;\n     }\n \n     public JSONObject getPatterns(String language, String region) {\n+        if((language == null || language.isEmpty()) && (region == null || region.isEmpty())) {\n+            logger.warn(\"Both language and region are empty!\");\n+            return null;\n+        }\n+        language = language.replace(\"_\", \"-\").toLowerCase();\n+        region = region.toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        String key = language + \"_\" + region;\n+        String key = PATTERNS_PREFIX + language + \"-\" + region;\n+        logger.debug(\"Look for pattern from cache for language [{}], region [{}]!\", language, region);\n         patterns = new PatternCacheService().lookForPatternsFromCache(key);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(language, region);\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   language [{}] region [{}].\\n\", language, region);// [datetime]\n-                // and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(key, patterns);\n-            }\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for language [{}], region [{}]!\", language, region);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(language, region, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for language [{}], region [{}].\\n\", language, region);// [datetime]\n+            // and\n+            new PatternCacheService().addPatterns(key, patterns);\n+            logger.debug(\"Pattern is cached for language [{}], region [{}]!\\n\\n\", language, region);\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(new Locale(language, region))) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NjI4Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456976283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (patterns == null) {\n          \n          \n            \n            return patterns == null ? null : (JSONObject) patterns.get(PatternKeys.CATEGORIES);", "author": "Xiaochao8", "createdAt": "2020-07-20T00:32:35Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -4,17 +4,51 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n+import com.vmware.i18n.dto.LocaleDataDTO;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.util.Map;\n \n-import org.json.simple.JSONObject;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n-import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n-import com.vmware.vipclient.i18n.util.PatternBundleUtil;\n+public class LocalPatternOpt implements PatternOpt{\n+    Logger logger = LoggerFactory.getLogger(LocalPatternOpt.class);\n \n-public class LocalPatternOpt {\n+    public JSONObject getPatterns(String locale) {\n+        logger.debug(\"Look for pattern from local bundle for locale [{}]!\", locale);\n+        String normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+        logger.debug(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n+\n+    @Override\n+    public JSONObject getPatterns(String language, String region) {\n+        logger.debug(\"Look for pattern from local bundle for language [{}], region [{}]!\", language, region);\n+        LocaleDataDTO resultData = CommonUtil.getLocale(language, region);\n+        String normalizedLocale = resultData.getLocale();\n+        logger.debug(\"Normalized locale for language [{}], region [{}] is [{}]\", language, region, normalizedLocale);\n+        return getPatternsByLocale(normalizedLocale);\n+    }\n \n-    public JSONObject getPatternsByLocale(String locale) {\n-        Map<String, Object> patterns = PatternBundleUtil.readJSONFile(locale);\n+    public JSONObject getPatternsByLocale(String normalizedLocale) {\n+        if(normalizedLocale == null || \"\".equalsIgnoreCase(normalizedLocale))\n+            return null;\n+        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n+        Map<String, Object> patterns = null;\n+        try {\n+            patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n+        } catch (ParseException e) {\n+            e.printStackTrace();\n+        }\n         if (patterns == null) {", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MjEzMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456982133", "bodyText": "Move this into PatternCacheService", "author": "Xiaochao8", "createdAt": "2020-07-20T01:13:53Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/PatternService.java", "diffHunk": "@@ -4,89 +4,107 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n-import com.vmware.vipclient.i18n.util.ConstantsKeys;\n-import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import java.util.ListIterator;\n+import java.util.Locale;\n \n /**\n  * The class represents date formatting\n  */\n public class PatternService {\n     Logger logger = LoggerFactory.getLogger(PatternService.class);\n+    private static final String PATTERNS_PREFIX = \"patterns_\";\n \n     public JSONObject getPatternsByCategory(String locale, String category) {\n         JSONObject patterns = getPatterns(locale);\n         return (JSONObject) patterns.get(category);\n     }\n \n     public JSONObject getPatterns(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         JSONObject patterns = null;\n-        logger.debug(\"Look for pattern from cache!\");\n-        patterns = new PatternCacheService().lookForPatternsFromCache(locale);// key\n-        if (patterns == null) {\n-            patterns = getPatternsFromBundle(locale);\n-            if ((patterns == null) && !LocaleUtility.isDefaultLocale(locale)) {\n-                patterns = getPatternsFromBundle(ConstantsKeys.EN);\n-            }\n-            if (null != patterns) {\n-                logger.info(\"Got the pattern  with   locale [{}].\\n\", locale);// [datetime] and\n-                logger.info(\"Cache pattern!\\n\\n\");\n-                new PatternCacheService().addPatterns(locale, patterns);\n-            }\n+        logger.debug(\"Look for pattern from cache for locale [{}]!\", locale);\n+        String cacheKey = PATTERNS_PREFIX + locale;\n+        patterns = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+        if (patterns != null) {\n+            logger.debug(\"Find pattern from cache for locale [{}]!\", locale);\n+            return patterns;\n+        }\n+        patterns = getPatternsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (patterns != null) {\n+            logger.debug(\"Find the pattern for locale [{}].\\n\", locale);// [datetime] and\n+            new PatternCacheService().addPatterns(cacheKey, patterns);\n+            logger.debug(\"Pattern is cached for locale [{}]!\\n\\n\", locale);\n+            return patterns;\n+        }", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NzQ3Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r458157472", "bodyText": "As explained offline, I think these logic should be here, or no logic in service layer code, but many logic in cache service code, so abort this suggestion. Only move the cache key generation code to PatternCacheService.", "author": "huihuiw01", "createdAt": "2020-07-21T14:49:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MjEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MzE4MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r456983181", "bodyText": "Suggest to do this in PatternMessage or PatternService.", "author": "Xiaochao8", "createdAt": "2020-07-20T01:20:51Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -42,27 +57,98 @@\n \t    \tif (uri.getScheme().equals(\"jar\")) {\n \t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n \t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t    \t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t    \t\t}\n \t\t\t} else {\n \t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\t\t\t\tgetSupportedLocales(path, supportedLocales, languagesNames);\n \t\t\t}\n \t    \t\n \t\t} catch (Exception e) {\n \t\t\tlogger.debug(e.getMessage());\n \t\t}\n     \treturn supportedLocales;\n     }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n+\n+    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, JSONObject languagesNames) throws IOException {\n     \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n         \tlistOfFiles.map(file -> {\n \t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n+\t\t\t\tif(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+\t\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+\t\t\t\t}\n+\t\t\t\treturn \"\";\n+\t\t\t}).forEach(language -> {\n+\t\t\t\tif(language != null && !\"\".equalsIgnoreCase(language) && !ConstantsKeys.SOURCE.equalsIgnoreCase(language)) {\n+\t\t\t\t\tif (languagesNames != null) {\n+\t\t\t\t\t\tsupportedLocales.put(language, (String) languagesNames.get(language));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tsupportedLocales.put(language, \"\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n         }\n     }\n \n+    private JSONObject getLanguagesNames(String displayLanguage){\n+\t\tJSONObject languagesNames = null;\n+\t\tlogger.debug(\"Look for languages from cache for locale [{}]!\", displayLanguage);\n+\t\tString cacheKey = LANGUAGES_PREFIX + displayLanguage;\n+\t\tlanguagesNames = new PatternCacheService().lookForPatternsFromCache(cacheKey);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages from cache for locale [{}]!\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(displayLanguage);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages from local bundle for locale [{}].\\n\", displayLanguage);// [datetime] and\n+\t\t\tnew PatternCacheService().addPatterns(cacheKey, languagesNames);\n+\t\t\tlogger.debug(\"Languages is cached for locale [{}]!\\n\\n\", displayLanguage);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(displayLanguage)) {\n+\t\t\tlogger.info(\"Can't find languages for locale [{}], look for English languages as fallback!\", displayLanguage);\n+\t\t\tlanguagesNames = getLanguagesNames(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t}\n+\t\treturn languagesNames;\n+\n+\t}\n+\n+\tprivate JSONObject getLanguagesNamesFromBundle(String displayLanguage) {\n+\t\tlogger.debug(\"Look for languages from local package bundle for locale [{}]!\", displayLanguage);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(displayLanguage, localePathMap, localeAliasesMap);", "originalCommit": "8f732faa63f3cb38684ffb3029e9b486047572eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU4NjU3MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465586571", "bodyText": "This is locale related code, so your suggestion should be 'do this in LocaleMessage or LocaleService.', right?\nThe reason of can't resolve it now is the same with below comment:\nDon't need this method because client should get the locale from language and region in offline mode.\nIn general, Getting Pattern by locale is enough.\nCurrently locale fallback/normalization is based on cldr locale related data. So this means L2 data needed for locale fallback/normalization must be always included in Java client package.\nBut currently to reduce the size of Java client package, pattern data is put into a separate jar, and for online mode this jar isn't neccessary. If product choose online mode and don't add this jar, change as your suggestion will lead to program broken.\nSo I prefer to remove this after we can guarantee data needed for locale fallback/normalization is always included or we define new locale fallback/normalization rule which doesn't relies on cldr data.", "author": "huihuiw01", "createdAt": "2020-08-05T09:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MzE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU3MTg0Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459571846", "bodyText": "Let's not have anything hardcoded to English.\nIn this case, you can leave the dto's display locale as null. It will be handled in the service layer. See code suggestion in LocaleService.", "author": "jessiejuachon", "createdAt": "2020-07-23T16:21:13Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -56,9 +72,7 @@ public LocaleMessage() {\n      * @return a list contains the supported language tags\n      */\n     public List<String> getSupportedLanguageTagList() {\n-        Map<String, String> languageTagMap = new LocaleService()\n-                .getDisplayNamesFromCLDR(java.util.Locale.ENGLISH.toLanguageTag(), \n-                \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        Map<String, String> languageTagMap = getDisplayNamesFromCLDR(java.util.Locale.ENGLISH.toLanguageTag());", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0OTc5Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459749797", "bodyText": "Use the suggested LocaleDTO that also has the locale (display locale's language tag) property in it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public LocaleService(BaseDTO dto) {\n          \n          \n            \n                public LocaleService(LocaleDTO dto) {", "author": "jessiejuachon", "createdAt": "2020-07-23T21:54:34Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMDQ0OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459810449", "bodyText": "See #673 for reference\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    if (!msgSourceQueueIter.hasNext())\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n          \n          \n            \n                    dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n          \n          \n            \n                    if (dispMap == null || dispMap.isEmpty()) {\n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n          \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n            }\n          \n          \n            \n               private Map<String, String> getSupportedLanguagesFromDS(String displayLanguageTag, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    if (!msgSourceQueueIter.hasNext()) {\n          \n          \n            \n                        logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    DataSourceEnum dataSource = msgSourceQueueIter.next();\n          \n          \n            \n                    dispMap = dataSource.createLocaleOpt().getSupportedLanguages(displayLanguageTag);\n          \n          \n            \n                    if (dispMap == null || dispMap.isEmpty()) {\n          \n          \n            \n                        logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(displayLanguageTag, msgSourceQueueIter);\n          \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T01:18:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n+    public Map<String, String> getRegionsFromCLDR(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n         }\n-        return respMap;\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        \n-        if (dispMap == null || dispMap.isEmpty()) {\n-        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n+        return regions;\n+    }\n+\n+    public Map<String, String> getSupportedDisplayNames(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        String productName = dto.getProductID();\n+        String version = dto.getVersion();\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (dispMap != null) {\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, locale);\n+            return dispMap;\n+        }\n+        //cacheItem = new FormatCacheItem();\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (dispMap != null && dispMap.size() > 0) {\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);\n+            return dispMap;\n         }\n         return dispMap;\n     }\n \n+\n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if (!msgSourceQueueIter.hasNext())\n+            return dispMap;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n+        if (dispMap == null || dispMap.isEmpty()) {\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n+        }\n+        return dispMap;\n+    }\n }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMTE4Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459811183", "bodyText": "See #673 for reference\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Map<String, String> getSupportedDisplayNames(String locale) {\n          \n          \n            \n                    locale = locale.replace(\"_\", \"-\").toLowerCase();\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n          \n          \n            \n                    String productName = dto.getProductID();\n          \n          \n            \n                    String version = dto.getVersion();\n          \n          \n            \n                    FormattingCacheService formattingCacheService = new FormattingCacheService();\n          \n          \n            \n                    dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n          \n          \n            \n                    if (dispMap != null) {\n          \n          \n            \n                        logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, locale);\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    //cacheItem = new FormatCacheItem();\n          \n          \n            \n                    dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                    if (dispMap != null && dispMap.size() > 0) {\n          \n          \n            \n                        logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, locale);\n          \n          \n            \n                        formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                        logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n                public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n            \n          \n          \n            \n                    // if display language is null, just proceed to the next available fallback locale\n          \n          \n            \n                    if (displayLanguageTag == null) {\n          \n          \n            \n                        if (fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n          \n          \n            \n                    //TODO This will be implemented in Huihui's PR\n          \n          \n            \n                    /*\n          \n          \n            \n                    logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n          \n          \n            \n                    String productName = dto.getProductID();\n          \n          \n            \n                    String version = dto.getVersion();\n          \n          \n            \n                    FormattingCacheService formattingCacheService = new FormattingCacheService();\n          \n          \n            \n                    FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n          \n          \n            \n                    if (cacheItem != null) {\n          \n          \n            \n                        logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n          \n          \n            \n                        dispMap = cacheItem.getCachedData();\n          \n          \n            \n                        if (cacheItem.isExpired()) {\n          \n          \n            \n                            populateCacheTask(displayLanguageTag);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                    */\n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                        if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n          \n          \n            \n                            if (dispMap != null && !dispMap.isEmpty()) {\n          \n          \n            \n                                // TODO: Huihui has implemented this in another PR\n          \n          \n            \n                                /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                                logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    //}\n          \n          \n            \n            \n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private void populateCacheTask(String displayLanguageTag) {\n          \n          \n            \n                    Callable<Map<String, String>> callable = () -> {\n          \n          \n            \n                        try {\n          \n          \n            \n                            Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                            // To make sure that the thread will close\n          \n          \n            \n                            // even when an exception is thrown\n          \n          \n            \n                            return null;\n          \n          \n            \n                        }\n          \n          \n            \n                    };\n          \n          \n            \n                    FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n          \n          \n            \n                    Thread thread = new Thread(task);\n          \n          \n            \n                    thread.start();\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T01:22:18Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n+    public Map<String, String> getRegionsFromCLDR(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n         }\n-        return respMap;\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        \n-        if (dispMap == null || dispMap.isEmpty()) {\n-        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n+        return regions;\n+    }\n+\n+    public Map<String, String> getSupportedDisplayNames(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        String productName = dto.getProductID();\n+        String version = dto.getVersion();\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (dispMap != null) {\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, locale);\n+            return dispMap;\n+        }\n+        //cacheItem = new FormatCacheItem();\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (dispMap != null && dispMap.size() > 0) {\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", productName, version, locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);\n+            return dispMap;\n         }\n         return dispMap;\n     }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxOTQ1MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465619450", "bodyText": "As we discussed offline, will add cache update in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-05T10:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxMTE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxNjkzNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459816936", "bodyText": "Remove locale parameter, make it a property of LocaleDTO.\nSee code suggestion for getSupportedLanguagesFromDS below for reference", "author": "jessiejuachon", "createdAt": "2020-07-24T01:50:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n+    public Map<String, String> getRegionsFromCLDR(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n         }\n-        return respMap;\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        \n-        if (dispMap == null || dispMap.isEmpty()) {\n-        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n+        return regions;\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MDE3NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465750175", "bodyText": "As we discussed offline, add a new class LocaleDTO in case parameter increase, but won\u2019t put locale into it.\nBecause 'locale' is a frequently changed parameter, put it into DTO will need new service instance multiple times when its value changed, and new instance is time consuming.", "author": "huihuiw01", "createdAt": "2020-08-05T14:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxNjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxNzYyMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459817620", "bodyText": "Remove locale parameter, make it a property of LocaleDTO.\nUse fallbackLocalesIter as parameter and recursively call the method to apply locale fallback logic.\nSee code suggestion for getSupportedDisplayNames below for reference", "author": "jessiejuachon", "createdAt": "2020-07-24T01:53:40Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,92 +4,91 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Map;\n \n public class LocaleService {\n \n     Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n     public static final String DISPN_PREFIX  = \"dispn_\";\n+    private BaseDTO dto = null;\n \n-    public LocaleService() {\n+    public LocaleService(BaseDTO dto) {\n+        this.dto = dto;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n+    public Map<String, String> getRegionsFromCLDR(String locale){", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxODA1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465618054", "bodyText": "Remove locale parameter, make it a property of LocaleDTO.\nAs we discussed offline, add a new class LocaleDTO in case parameter increase, but won\u2019t put locale into it.\nBecause 'locale' is a frequently changed parameter, put it into DTO will need new service instance multiple times when its value changed, and new instance is time consuming.\n\n\nUse fallbackLocalesIter as parameter and recursively call the method to apply locale fallback logic.\nI can get the fallback iterator in service layer, no need to get it in message layer and pass it, xiaochao also suggest this.", "author": "huihuiw01", "createdAt": "2020-08-05T10:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxNzYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyMzUwNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459823506", "bodyText": "Fallback and caching logic must be handled in the service layer, not in here. See my code suggestion in LocaeService.getSupportedDisplayNames (renamed it to getSupportedLanguages).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    if(locale == null || locale.isEmpty()) {\n          \n          \n            \n                        logger.warn(\"Locale is empty!\");\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    BaseDTO dto = new BaseDTO();\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    }else{\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    dispMap = localeService.getSupportedDisplayNames(locale);\n          \n          \n            \n                    if(dispMap != null && !dispMap.isEmpty()){\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (!LocaleUtility.isDefaultLocale(locale)) {\n          \n          \n            \n                        logger.info(\"Can't find supported languages for locale [{}], look for English languages as fallback!\", locale);\n          \n          \n            \n                        Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n          \n          \n            \n                        dispMap = localeService.getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n          \n          \n            \n                        if (dispMap != null && dispMap.size() > 0) {\n          \n          \n            \n                            new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                            logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n          \n          \n            \n                                    dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n                private Map<String, String> getDisplayNamesFromCLDR(LocaleDTO dto) {\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    return new LocaleService(dto).getSupportedLanguages(LocaleUtility.getFallbackLocales().iterator());\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T02:22:05Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        BaseDTO dto = new BaseDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        dispMap = localeService.getSupportedDisplayNames(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for English languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = localeService.getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n+            }\n+        }\n+        return dispMap;\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNDM2MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459824360", "bodyText": "Use LocaleDTO to hold the display locale. Do not pass it as a parameter here.\nMove the locale fallback and caching logic in the service layer (See my comments in LocaleService).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getRegionsFromCLDR(String locale){\n          \n          \n            \n                    Map<String, String> regionMap = null;\n          \n          \n            \n                    LocaleService localeService = new LocaleService(null);\n          \n          \n            \n                    regionMap = localeService.getRegionsFromCLDR(locale);\n          \n          \n            \n                    if (regionMap != null) {\n          \n          \n            \n                        return regionMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (!LocaleUtility.isDefaultLocale(locale)) {\n          \n          \n            \n                        logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n          \n          \n            \n                        regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n          \n          \n            \n                        if (regionMap != null) {\n          \n          \n            \n                            new FormattingCacheService().addRegions(locale, regionMap);\n          \n          \n            \n                            logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return regionMap;\n          \n          \n            \n                }\n          \n          \n            \n                private Map<String, String> getRegionsFromCLDR(LocaleDTO dto) {\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    return new LocaleService(dto). getRegionsFromCLDR(LocaleUtility.getFallbackLocales().iterator());\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T02:26:35Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxNTI3MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465615270", "bodyText": "resolved:\nMove the locale fallback and caching logic in the service layer\nnot resolved:\nUse LocaleDTO to hold the display locale. Do not pass it as a parameter here.\nAs we discussed offline,  add a new class LocaleDTO in case parameter increase,  but won\u2019t put locale into it.\nBecause 'locale' is a frequently changed parameter, put it into DTO will need new service instance multiple times when its value changed, and new instance is time consuming.", "author": "huihuiw01", "createdAt": "2020-08-05T10:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNDM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNDg0NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459824844", "bodyText": "Use LocaleDTO to hold the display language tag instead of passing as a parameter.\nRefer to LocaleDTO in #673\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Map<String, String> regionMap = getRegionsFromCLDR(locale);\n          \n          \n            \n                     LocaleDTO dto = new LocaleDTO();\n          \n          \n            \n                    dto.setDisplayLanguage(locale);\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    } else {\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n                    Map<String, String> regionMap = getRegionsFromCLDR(dto);", "author": "jessiejuachon", "createdAt": "2020-07-24T02:29:20Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -33,8 +43,15 @@ public LocaleMessage() {\n      * @return map the key is the supported language tag, value is all region data mapped by\n      *         language tag\n      */\n-    public Map<String, Map<String, String>> getRegionList(List<String> supportedLanguageList) {\n-        return new LocaleService().getTerritoriesFromCLDR(supportedLanguageList);\n+    public Map<String, Map<String, String>> getRegionList(List<String> localeList) {\n+        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n+        for (String locale : localeList) {\n+            if(locale != null && !locale.isEmpty()) {\n+                Map<String, String> regionMap = getRegionsFromCLDR(locale);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0OTQzNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465749436", "bodyText": "As we discussed offline, add a new class LocaleDTO in case parameter increase, but won\u2019t put locale into it.\nBecause 'locale' is a frequently changed parameter, put it into DTO will need new service instance multiple times when its value changed, and new instance is time consuming.", "author": "huihuiw01", "createdAt": "2020-08-05T14:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNDg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNTI0Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459825243", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n          \n          \n            \n            \t\tpublic LocaleOpt createLocaleOpt(LocaleDTO dto) {", "author": "jessiejuachon", "createdAt": "2020-07-24T02:31:29Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new RemotePatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new RemoteLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNTM1Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459825356", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n          \n          \n            \n            \t\tpublic LocaleOpt createLocaleOpt(LocaleDTO dto) {", "author": "jessiejuachon", "createdAt": "2020-07-24T02:32:00Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNTQwNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459825405", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract LocaleOpt createLocaleOpt(BaseDTO dto);\n          \n          \n            \n                public abstract LocaleOpt createLocaleOpt(LocaleDTO dto);", "author": "jessiejuachon", "createdAt": "2020-07-24T02:32:13Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new RemotePatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new RemoteLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new RemoteLocaleOpt(dto);\n \t\t}\n     };\n+    public abstract ProductOpt createProductOpt(BaseDTO dto);\n     public abstract MessageOpt createMessageOpt(MessagesDTO dto);\n-    public abstract LocaleOpt createLocaleOpt();\n+    public abstract PatternOpt createPatternOpt();\n+    public abstract LocaleOpt createLocaleOpt(BaseDTO dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjM1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459826354", "bodyText": "See my comments in LocaleMessage regarding:\n\nmoving the fallback and caching logic in to the service layer\npassing Iterator iter = LocaleUtility.getFallbackLocales().iterator() to the service\nusing a PatternDTO to hold the locale parameter.", "author": "jessiejuachon", "createdAt": "2020-07-24T02:37:29Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java", "diffHunk": "@@ -4,16 +4,20 @@\n  */\n package com.vmware.vipclient.i18n.base.instances;\n \n-import java.util.Locale;\n-\n+import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n+import com.vmware.vipclient.i18n.messages.service.PatternService;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.json.simple.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.messages.service.PatternService;\n+import java.util.Locale;\n \n /**\n  * provide api to get pattern data from remote or locale\n  */\n public class PatternMessage implements Message {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMDcyMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464730723", "bodyText": "Is locale (display language) always required for getPatternMessage? If yes, then ignore my comment above.", "author": "jessiejuachon", "createdAt": "2020-08-04T00:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYwNDgxMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465604812", "bodyText": "Yeah, it's required for getPatternMessage, because it's required parameter when call Singleton service API.", "author": "huihuiw01", "createdAt": "2020-08-05T09:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYxMDc0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465610747", "bodyText": "resolved:\n\nmoving the fallback and caching logic in to the service layer\n\nnot  resolved:\n\n\npassing Iterator iter = LocaleUtility.getFallbackLocales().iterator() to the service\nI can get the fallback iterator in service layer, no need to get it in message layer and pass it, xiaochao also suggest this.\n\n\nusing a PatternDTO to hold the locale parameter.\nCurrently only one parameter 'locale' is needed, and it's better passed as method parameter, so no need to define PatternDTO. As we discussed offline, you are also ok with this.", "author": "huihuiw01", "createdAt": "2020-08-05T09:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MDgwMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459860802", "bodyText": "return FormatCacheItem. Inside FormatCacheItem, implement an isExpired() method that can be used in the service layer.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Map<String, String> getSupportedLanguages(BaseDTO dto, String locale) {\n          \n          \n            \n                    String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n          \n          \n            \n                    return getFormattings(cacheKey);\n          \n          \n            \n                }\n          \n          \n            \n                public FormatCacheItem getSupportedLanguages(BaseDTO dto, String locale) {\n          \n          \n            \n                    String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n          \n          \n            \n                    return getFormattings(cacheKey);\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T05:40:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.service;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+import org.json.simple.JSONObject;\n+\n+import java.util.Map;\n+\n+public class FormattingCacheService {\n+\n+    public FormattingCacheService() {\n+\n+    }\n+\n+    public void addPatterns(String locale, JSONObject o) {\n+        String cacheKey = getPatternsCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addPatterns(String language, String region, JSONObject o) {\n+        String cacheKey = getPatternsCacheKey(language, region);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n+        o = JSONUtils.map2SortMap(o);\n+        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addLanguagesNames(String locale, Map<String, String> o) {\n+        String cacheKey = getLanguagesNamesCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addRegions(String locale, Map<String, String> o) {\n+        o = JSONUtils.map2SortMap(o);\n+        String cacheKey = getRegionsCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public JSONObject getPatterns(String locale) {\n+        String cacheKey = getPatternsCacheKey(locale);\n+        return getFormattingPatterns(cacheKey);\n+    }\n+\n+    public JSONObject getPatterns(String language, String region) {\n+        String cacheKey = getPatternsCacheKey(language, region);\n+        return getFormattingPatterns(cacheKey);\n+    }\n+\n+    public Map<String, String> getSupportedLanguages(BaseDTO dto, String locale) {\n+        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n+        return getFormattings(cacheKey);\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1Mzk2OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465553969", "bodyText": "This comment is related to cache update, as we discussed offline, cache update will be added in the next PR, so I will resolve this comment in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-05T08:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MDgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MTgyNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r459861826", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getFormattings(String key) {\n          \n          \n            \n                    Map<String, String> o = null;\n          \n          \n            \n                    Cache c = VIPCfg.getInstance().getCacheManager()\n          \n          \n            \n                            .getCache(VIPCfg.CACHE_L2);\n          \n          \n            \n                    if (c != null) {\n          \n          \n            \n                    \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(key);\n          \n          \n            \n                    \tif (cacheItem != null)\n          \n          \n            \n                    \t\to = cacheItem.getCachedData();\n          \n          \n            \n                    }\n          \n          \n            \n                    return o;\n          \n          \n            \n                }\n          \n          \n            \n                private FormatCacheItem getFormattings(String key) {\n          \n          \n            \n                    FormatCacheItem cacheItem  = null;\n          \n          \n            \n                    Cache c = VIPCfg.getInstance().getCacheManager()\n          \n          \n            \n                            .getCache(VIPCfg.CACHE_L2);\n          \n          \n            \n                    if (c != null) {\n          \n          \n            \n                    \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(key);\n          \n          \n            \n                    }\n          \n          \n            \n                    return cacheItem;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-07-24T05:44:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/FormattingCacheService.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.service;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.Cache;\n+import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import com.vmware.vipclient.i18n.util.JSONUtils;\n+import org.json.simple.JSONObject;\n+\n+import java.util.Map;\n+\n+public class FormattingCacheService {\n+\n+    public FormattingCacheService() {\n+\n+    }\n+\n+    public void addPatterns(String locale, JSONObject o) {\n+        String cacheKey = getPatternsCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addPatterns(String language, String region, JSONObject o) {\n+        String cacheKey = getPatternsCacheKey(language, region);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addSupportedLanguages(BaseDTO dto, String locale, Map<String, String> o) {\n+        o = JSONUtils.map2SortMap(o);\n+        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addLanguagesNames(String locale, Map<String, String> o) {\n+        String cacheKey = getLanguagesNamesCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public void addRegions(String locale, Map<String, String> o) {\n+        o = JSONUtils.map2SortMap(o);\n+        String cacheKey = getRegionsCacheKey(locale);\n+        addFormattings(cacheKey, o);\n+    }\n+\n+    public JSONObject getPatterns(String locale) {\n+        String cacheKey = getPatternsCacheKey(locale);\n+        return getFormattingPatterns(cacheKey);\n+    }\n+\n+    public JSONObject getPatterns(String language, String region) {\n+        String cacheKey = getPatternsCacheKey(language, region);\n+        return getFormattingPatterns(cacheKey);\n+    }\n+\n+    public Map<String, String> getSupportedLanguages(BaseDTO dto, String locale) {\n+        String cacheKey = getSupportedLanguagesCacheKey(dto, locale);\n+        return getFormattings(cacheKey);\n+    }\n+\n+    public Map<String, String> getLanguagesNames(String locale) {\n+        String cacheKey = getLanguagesNamesCacheKey(locale);\n+        return getFormattings(cacheKey);\n+    }\n+\n+    public Map<String, String> getRegions(String locale) {\n+        String cacheKey = getRegionsCacheKey(locale);\n+        return getFormattings(cacheKey);\n+    }\n+\n+    private String getPatternsCacheKey(String locale){\n+        return ConstantsKeys.PATTERNS_PREFIX + locale;\n+    }\n+\n+    private String getPatternsCacheKey(String language, String region){\n+        return ConstantsKeys.PATTERNS_PREFIX + language + \"-\" + region;\n+    }\n+\n+    private String getSupportedLanguagesCacheKey(BaseDTO dto, String locale){\n+        return ConstantsKeys.DISPNS_PREFIX + dto.getProductID() + ConstantsKeys.UNDERLINE + dto.getVersion() + ConstantsKeys.UNDERLINE + locale;\n+    }\n+\n+    private String getLanguagesNamesCacheKey(String locale){\n+        return ConstantsKeys.LANGUAGES_PREFIX + locale;\n+    }\n+\n+    private String getRegionsCacheKey(String locale){\n+        return ConstantsKeys.REGIONS_PREFIX + locale;\n+    }\n+\n+    private JSONObject getFormattingPatterns(String key) {\n+        Map<String, String> o = getFormattings(key);\n+        if (o != null) {\n+            return new JSONObject(o);\n+        }\n+        return null;\n+    }\n+\n+    private void addFormattings(String key, Map<String, String> o) {\n+        if (null != key && null != o) {\n+            Cache c = VIPCfg.getInstance().getCacheManager()\n+                    .getCache(VIPCfg.CACHE_L2);\n+            if (c != null) {\n+                c.put(key, new FormatCacheItem(o));\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> getFormattings(String key) {\n+        Map<String, String> o = null;\n+        Cache c = VIPCfg.getInstance().getCacheManager()\n+                .getCache(VIPCfg.CACHE_L2);\n+        if (c != null) {\n+        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(key);\n+        \tif (cacheItem != null)\n+        \t\to = cacheItem.getCachedData();\n+        }\n+        return o;\n+    }", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1MzY4NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465553684", "bodyText": "This comment is related to cache update, as we discussed offline, cache update will be added in the next PR, so I will resolve this comment in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-05T08:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwMzk5MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462103991", "bodyText": "Suggest to change to because class name of local ProductOpt is LocalProuctOpt\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ProductBasedOpt extends BaseOpt implements ProductOpt {\n          \n          \n            \n            public class RemoteProductOpt extends BaseOpt implements ProductOpt {", "author": "Xiaochao8", "createdAt": "2020-07-29T07:45:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/ProductBasedOpt.java", "diffHunk": "@@ -4,19 +4,19 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.server;\n \n-import java.util.Map;\n-\n-import org.json.simple.JSONArray;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.messages.api.opt.BaseOpt;\n-import com.vmware.vipclient.i18n.messages.api.opt.Opt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.url.URLUtils;\n import com.vmware.vipclient.i18n.messages.api.url.V2URL;\n import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONArray;\n+\n+import java.util.List;\n+import java.util.Map;\n \n-public class ProductBasedOpt extends BaseOpt implements Opt {\n+public class ProductBasedOpt extends BaseOpt implements ProductOpt {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTQ5Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462105497", "bodyText": "Since we have more than one message such as Translation message and locale message.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract MessageOpt createMessageOpt(MessagesDTO dto);\n          \n          \n            \n                public abstract TranslationOpt createTranslationOpt(MessagesDTO dto);", "author": "Xiaochao8", "createdAt": "2020-07-29T07:48:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new RemotePatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new RemoteLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new RemoteLocaleOpt(dto);\n \t\t}\n     };\n+    public abstract ProductOpt createProductOpt(BaseDTO dto);\n     public abstract MessageOpt createMessageOpt(MessagesDTO dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMTk2OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462821969", "bodyText": "I don't make change to this code line, and this is L3 related code, wouldn't like to change them in L2 related PR.\nOr code changes may make reviewers confused.", "author": "huihuiw01", "createdAt": "2020-07-30T08:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTkxMQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462105911", "bodyText": "In my opinion, pattern is a kind of locale data. So these 2 interfaces may be merged.", "author": "Xiaochao8", "createdAt": "2020-07-29T07:49:32Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new RemotePatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new RemoteLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new RemoteLocaleOpt(dto);\n \t\t}\n     };\n+    public abstract ProductOpt createProductOpt(BaseDTO dto);\n     public abstract MessageOpt createMessageOpt(MessagesDTO dto);\n-    public abstract LocaleOpt createLocaleOpt();\n+    public abstract PatternOpt createPatternOpt();\n+    public abstract LocaleOpt createLocaleOpt(BaseDTO dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMjAyMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462822022", "bodyText": "Pattern data is format data, not locale data. So they are different, shouldn't be put into one interface.\nBTW, on service side, they are are regarded as different resources and provided by different APIs and implemented by different interfaces.", "author": "huihuiw01", "createdAt": "2020-07-30T08:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNTkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNzU3Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462107572", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new ComponentBasedOpt(dto);\n          \n          \n            \n                        return new RemoteTranslationOpt(dto);", "author": "Xiaochao8", "createdAt": "2020-07-29T07:52:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);\n         }\n \n+        @Override\n+        public PatternOpt createPatternOpt() {\n+            return new LocalPatternOpt();\n+        }\n+\n \t\t@Override\n-\t\tpublic LocaleOpt createLocaleOpt() {\n-\t\t\treturn new LocalLocaleOpt();\n+\t\tpublic LocaleOpt createLocaleOpt(BaseDTO dto) {\n+\t\t\treturn new LocalLocaleOpt(dto);\n \t\t}\n     }, \n     VIP {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new ProductBasedOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new ComponentBasedOpt(dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMjA2NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462822065", "bodyText": "I don't make change to this code line, and this is L3 related code, wouldn't like to change them in L2 related PR.\nOr code changes may make reviewers confused.", "author": "huihuiw01", "createdAt": "2020-07-30T08:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNzU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNzg4Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462107883", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new LocalMessagesOpt(dto);\n          \n          \n            \n                        return new LocalTranslationOpt(dto);", "author": "Xiaochao8", "createdAt": "2020-07-29T07:53:07Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/DataSourceEnum.java", "diffHunk": "@@ -5,36 +5,65 @@\n package com.vmware.vipclient.i18n.base;\n \n import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.PatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.MessageOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalPatternOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.local.LocalMessagesOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.local.LocalProductOpt;\n import com.vmware.vipclient.i18n.messages.api.opt.server.ComponentBasedOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.ProductBasedOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n import com.vmware.vipclient.i18n.messages.dto.MessagesDTO;\n import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n+import com.vmware.vipclient.i18n.messages.api.opt.server.RemotePatternOpt;\n \n public enum DataSourceEnum {\n     Bundle {\n+        @Override\n+        public ProductOpt createProductOpt(BaseDTO dto) {\n+            return new LocalProductOpt(dto);\n+        }\n+\n     \t@Override\n         public MessageOpt createMessageOpt(MessagesDTO dto) {\n             return new LocalMessagesOpt(dto);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyMjExNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462822116", "bodyText": "I don't make change to this code line, and this is L3 related code, wouldn't like to change them in L2 related PR.\nOr code changes may make reviewers confused.", "author": "huihuiw01", "createdAt": "2020-07-30T08:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwNzg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwOTM0OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462109348", "bodyText": "Suggest to move this into ProductOpt. It looks better to put all product related interfaces together.", "author": "Xiaochao8", "createdAt": "2020-07-29T07:55:34Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/LocaleOpt.java", "diffHunk": "@@ -7,5 +7,6 @@\n import java.util.Map;\n \n public interface LocaleOpt {\n-\tpublic Map<String, String> getLanguages(String displayLanguage);\n+\tpublic Map<String, String> getSupportedLanguages(String locale);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgxODQ4Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462818487", "bodyText": "This method is to get supported languages(including language's displayName), corresponding to Singleton service API '/i18n/api/v2/locale/supportedLanguageList' under locale-api, different with get supported locales(only including language tag, no language's displayName).\nI add 'getSupportedLocales' method in ProductOpt, corresponding to Singleton service API '/i18n/api/v2/translation/products/{productName}/versions/{version}/localelist' under translation-product-api.\nOrganize them similar to Singleton service.", "author": "huihuiw01", "createdAt": "2020-07-30T07:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEwOTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExMjc3Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462112776", "bodyText": "Why do this change?", "author": "Xiaochao8", "createdAt": "2020-07-29T08:01:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/I18nFactory.java", "diffHunk": "@@ -90,7 +90,7 @@ public Message getMessageInstance(Class c, VIPCfg cfg) {\n         if (null == cfg) {\n             key = c.getCanonicalName();\n         } else {\n-            key = cfg.getProductName();\n+            key = c.getCanonicalName() + \".\" + cfg.getProductName();", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgyNDczMQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462824731", "bodyText": "Because two different instances(TranslationMessage and LocaleMessage) support shared component, if not add class name, the key for two different instances is the same, one instance maybe covered by the other.", "author": "huihuiw01", "createdAt": "2020-07-30T08:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjExMjc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyOTI3Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462129272", "bodyText": "It has different reasons to failure, locale is just one of them. So I think that no fallback is acceptable.", "author": "Xiaochao8", "createdAt": "2020-07-29T08:29:08Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        BaseDTO dto = new BaseDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        dispMap = localeService.getSupportedDisplayNames(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3NTIwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466675200", "bodyText": "Why \"no fallback is acceptable\"? If it fails for any reason, why not try the fallback locale?", "author": "jessiejuachon", "createdAt": "2020-08-06T20:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyOTI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyOTk4Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462129987", "bodyText": "Default doesn't need to be English. Suggest to search English to see if other similar typos exist.", "author": "Xiaochao8", "createdAt": "2020-07-29T08:30:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        BaseDTO dto = new BaseDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        dispMap = localeService.getSupportedDisplayNames(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for English languages as fallback!\", locale);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMDc0MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462130741", "bodyText": "Cache has been processed in service layer.", "author": "Xiaochao8", "createdAt": "2020-07-29T08:31:17Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;\n     }\n \n+    private Map<String, String> getRegionsFromCLDR(String locale){\n+        Map<String, String> regionMap = null;\n+        LocaleService localeService = new LocaleService(null);\n+        regionMap = localeService.getRegionsFromCLDR(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for English regions as fallback!\", locale);\n+            regionMap = localeService.getRegionsFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return dispMap;\n+        }\n+        BaseDTO dto = new BaseDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        dispMap = localeService.getSupportedDisplayNames(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for English languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = localeService.getSupportedDisplayNames(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMjA2Mw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462832063", "bodyText": "This is changed according to Jessiely's suggestion, cache default locale's content as requested locale, or will always try to fetch the requested locale first before using the fallback locale that is already in the cache, which may increase product UI loading time.\nBelow is Jessiely's original words:\nPut this fallback logic in LocaleMessage so that this method here in LocaleService is always for the requested language only.\nOnce you move the fallback logic into LocaleMessage, update the cache in there in such a way that the key with the requested language is mapped to the FormatCacheItem of the fallback language.\nc.put(, new FormatCacheItem());\nWithout the above proposed changes, your code will always try to fetch the requested locale first before using the fallback locale that is already in the cache. With the above proposed changes, any succeeding calls for the requested language will immediately return the cached fallback locale until it expires.\nNote: You can either put the above logic in LocaleMessage as I propose (just like how it is in TranslationMessage.getMessages), or create another method here in LocaleService to keep the logic in the \"service layer\".", "author": "huihuiw01", "createdAt": "2020-07-30T08:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMDc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEzMjM5Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462132396", "bodyText": "Immediately return this expression instead of assigning it to the temporary variable \"languageTagList\".", "author": "Xiaochao8", "createdAt": "2020-07-29T08:33:52Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +85,68 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n         Collection<String> valueCollection = dispNameMap.values();\n         List<String> dispNameList = new ArrayList<String>(valueCollection);\n         return dispNameList;", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NTQ3MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462175471", "bodyText": "It seems this class can have a static instance of PatternService.", "author": "Xiaochao8", "createdAt": "2020-07-29T09:46:16Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java", "diffHunk": "@@ -26,7 +30,22 @@ public PatternMessage() {\n      * @return\n      */\n     public JSONObject getPatternMessage(Locale locale) {\n-        return new PatternService().getPatterns(locale.toLanguageTag());\n+        JSONObject patterns = null;\n+        PatternService ps = new PatternService();", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3Njg0NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462176844", "bodyText": "Is it necessary to store into cache?", "author": "Xiaochao8", "createdAt": "2020-07-29T09:48:43Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java", "diffHunk": "@@ -26,7 +30,22 @@ public PatternMessage() {\n      * @return\n      */\n     public JSONObject getPatternMessage(Locale locale) {\n-        return new PatternService().getPatterns(locale.toLanguageTag());\n+        JSONObject patterns = null;\n+        PatternService ps = new PatternService();\n+        patterns = ps.getPatterns(locale.toLanguageTag());\n+        if (patterns != null) {\n+            return patterns;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find pattern for locale [{}], look for English pattern as fallback!\", locale);\n+            patterns = ps.getPatterns(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (patterns != null) {\n+                new FormattingCacheService().addPatterns(locale.toLanguageTag(), patterns);", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMjY5MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462832690", "bodyText": "Same reason as that for LocaleMessage.", "author": "huihuiw01", "createdAt": "2020-07-30T08:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3Njg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4Njk1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462186954", "bodyText": "Because this method is about translation. How about put all translation methods into ProductService?", "author": "Xiaochao8", "createdAt": "2020-07-29T10:05:47Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -25,30 +23,30 @@ public ProductService(MessagesDTO dto) {\n     }\n \n     // get supported components defined in vip service\n-    public JSONArray getComponentsFromRemoteVIP() {\n+    public List<String> getComponents() {\n         BaseDTO baseDTO = new BaseDTO();\n         baseDTO.setProductID(dto.getProductID());\n         baseDTO.setVersion(dto.getVersion());\n         ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n-        return dao.getComponentsFromRemoteVIP();\n+        return dao.getComponents();\n     }\n \n     // get supported locales defined in vip service\n-    public JSONArray getSupportedLocalesFromRemoteVIP() {\n+    public List<String> getSupportedLocales() {\n         BaseDTO baseDTO = new BaseDTO();\n         baseDTO.setProductID(dto.getProductID());\n         baseDTO.setVersion(dto.getVersion());\n         ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n-        return dao.getSupportedLocalesFromRemoteVIP();\n+        return dao.getSupportedLocales();\n     }\n \n     public List<Map> getAllComponentTranslation() {", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "436d2269beca89dcae5fa3aed0c0940428bb367e", "url": "https://github.com/vmware/singleton/commit/436d2269beca89dcae5fa3aed0c0940428bb367e", "message": "fix NullPointerException in DateFormatting when default locale's pattern is not available", "committedDate": "2020-07-30T15:13:58Z", "type": "forcePushed"}, {"oid": "4867ae524a2b481d8ba4e1a1ae4084defbf90b5b", "url": "https://github.com/vmware/singleton/commit/4867ae524a2b481d8ba4e1a1ae4084defbf90b5b", "message": "fix NullPointerException in DateFormatting when default locale's pattern is not available", "committedDate": "2020-07-31T10:58:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMDI4NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r462710285", "bodyText": "The comment needs update.", "author": "Xiaochao8", "createdAt": "2020-07-30T03:18:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -4,20 +4,30 @@\n  */\n package com.vmware.vipclient.i18n.base.instances;\n \n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n+import com.vmware.vipclient.i18n.messages.service.LocaleService;\n+import com.vmware.vipclient.i18n.util.LocaleUtility;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.messages.service.LocaleService;\n-\n /**\n  * This class is a utility class to provide APIs related locale of specific product supported\n  * by VIP, on behind the APIs will fetch data from VIP service and wrapper the result as basic\n  * java util class to be called by prodcut's codes.\n  */", "originalCommit": "08c54d48dc3b183317dfa6af0e19d40b760c05f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMDE2NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464710164", "bodyText": "Enable this test again. See my comments on not using vipconfig-offline.properties.", "author": "jessiejuachon", "createdAt": "2020-08-03T23:16:05Z", "path": "src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java", "diffHunk": "@@ -178,7 +185,7 @@ public void testGetPatternMessageWithBundle() {\n         Assert.assertEquals(\"\\\"\u6211\u7684\u786c\u76d8\\\"\u4e0a\u6709345,678\u4e2a\u6587\u4ef6\u3002\", pluralMessage6);\n     }\n \n-    @Test\n+   // @Test", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464712151", "bodyText": "Just pass a null here. Get the fallback locale when you are in the service layer.\nAlso, do not use LocaleUtility.getDefaultLocale(). Iterate over the fallback locale queue in the service layer because there may be more than one fallback/default locale in the future (see code suggestion in LocaleService as well).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, String> languageTagMap = getDisplayNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n          \n          \n            \n                    Map<String, String> languageTagMap = getDisplayNamesFromCLDR(null);\n          \n      \n    \n    \n  \n\nNote: Please also change in other places where you used LocaleUtility.getDefaultLocale().", "author": "jessiejuachon", "createdAt": "2020-08-03T23:22:31Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -56,12 +71,12 @@ public LocaleMessage() {\n      * @return a list contains the supported language tags\n      */\n     public List<String> getSupportedLanguageTagList() {\n-        Map<String, String> languageTagMap = new LocaleService()\n-                .getDisplayNamesFromCLDR(java.util.Locale.ENGLISH.toLanguageTag(), \n-                \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        Collection<String> keyCollection = languageTagMap.keySet();\n-        List<String> languageTagList = new ArrayList<String>(keyCollection);\n-        return languageTagList;\n+        Map<String, String> languageTagMap = getDisplayNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4Nzg1NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465787854", "bodyText": "I can't pass null here, and use fallback locale in service layer.\nThe reason is for supportedLanguageList API in Singleton service, when locale parameter is empty, the behavior is get displayName with each languageTag, the logic is more complex than a detail locale, this method is just for return languageTag, so I think needn't execute that complex logic, pass default locale is better.\nCould you give me an example in what kind of situation there maybe more than one default locale?", "author": "huihuiw01", "createdAt": "2020-08-05T14:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA5NTMxOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466095318", "bodyText": "It looks this method can be removed because nobody uses it...", "author": "Xiaochao8", "createdAt": "2020-08-06T01:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMjM1OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466502358", "bodyText": "Yeah, maybe nobody use it, but since it's in a class exposed to user, so keep it.\nBut we may needn't spend much time or discussion on it.", "author": "huihuiw01", "createdAt": "2020-08-06T15:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODI5MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466698290", "bodyText": "@huihuiw01 , I am not asking you to pass null to the Singleton service. I am asking to pass null to getDisplayNamesFromCLDR(null), which will call LocaleService.getDisplayNames(null). When LocaleService.getDisplayNames receives a null value, it will get the next item from the fallback locales queue, and use that to pass to the Singleton service. See my code suggestion in LocaleService.getDisplayNames.", "author": "jessiejuachon", "createdAt": "2020-08-06T21:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxNTQ5Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464715496", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n          \n          \n            \n                    if(locale == null || locale.isEmpty()) {\n          \n          \n            \n                        logger.warn(\"Locale is empty!\");\n          \n          \n            \n                        return null;\n          \n          \n            \n                    }\n          \n          \n            \n                    LocaleDTO dto = new LocaleDTO();\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    }else{\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    return localeService.getDisplayNames(locale);\n          \n          \n            \n                }\n          \n          \n            \n                private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n          \n          \n            \n                    LocaleDTO dto = new LocaleDTO();\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    }else{\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n                    LocaleService localeService = new LocaleService(dto);\n          \n          \n            \n                    return localeService.getDisplayNames(locale);\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-03T23:33:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +86,37 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n+        if(dispNameMap != null) {\n+            Collection<String> valueCollection = dispNameMap.values();\n+            return new ArrayList<String>(valueCollection);\n+        }\n+        return new ArrayList();\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        LocaleDTO dto = new LocaleDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }\n+        LocaleService localeService = new LocaleService(dto);\n+        return localeService.getDisplayNames(locale);\n     }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyMDEwOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464720108", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Map<String, String> getDisplayNames(String locale) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    dispMap = getSupportedDisplayNamesByLocale(locale);\n          \n          \n            \n                    if(dispMap != null && !dispMap.isEmpty()){\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (!LocaleUtility.isDefaultLocale(locale)) {\n          \n          \n            \n                        logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n          \n          \n            \n                        Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n          \n          \n            \n                        dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n          \n          \n            \n                        if (dispMap != null && dispMap.size() > 0) {\n          \n          \n            \n                            new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                            logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n          \n          \n            \n                                    dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                        }\n          \n          \n            \n                public Map<String, String> getDisplayNames(String locale) {\n          \n          \n            \n                    Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n          \n          \n            \n                    return this.getDisplayNames(fallbackLocalesIter);\n          \n          \n            \n                }\n          \n          \n            \n                public Map<String, String> getDisplayNames(String locale, Iterator<Locale> fallbackLocalesIter) {\n          \n          \n            \n                    Map<String, String> dispMap = new HashMap<String, String>();\n          \n          \n            \n                    if (locale == null) {\n          \n          \n            \n                        if (fallbackLocalesIter != null && fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            locale = fallbackLocalesIter.next().toLanguageTag();\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        }\n          \n          \n            \n                    } \n          \n          \n            \n                    dispMap = getSupportedDisplayNamesByLocale(locale);\n          \n          \n            \n                    if(dispMap == null || dispMap.isEmpty()) {\n          \n          \n            \n                        logger.info(\"Can't find supported languages for locale [{}]\", locale);\n          \n          \n            \n                        return getDisplayNames(null, fallbackLocalesIter);\n          \n          \n            \n                    } \n          \n          \n            \n                    new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-03T23:49:27Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n             }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzU3Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466503577", "bodyText": "Will do in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-06T15:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyMDEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNjYwNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464726604", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-04T00:12:54Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n             }\n-        };\n-        FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n-        Thread thread = new Thread(task);\n-        thread.start();\n+        }\n+        return dispMap;\n     }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNzQwOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464727409", "bodyText": "See code suggestion for getDisplayNames. Iterate over the fall back locale queue instead of calling LocaleUtility.getDefaultLocale().", "author": "jessiejuachon", "createdAt": "2020-08-04T00:15:39Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzY2NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466503665", "bodyText": "Will do in the next PR.", "author": "huihuiw01", "createdAt": "2020-08-06T15:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNzQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyODQ1OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464728458", "bodyText": "I still do not see my previous code suggestion\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);\n          \n          \n            \n                        logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);", "author": "jessiejuachon", "createdAt": "2020-08-04T00:19:27Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n             }\n-        };\n-        FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n-        Thread thread = new Thread(task);\n-        thread.start();\n+        }\n+        return dispMap;\n     }\n \n-    private Map<String, String> getSupportedLanguagesFromDS(String displayLanguageTag, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (dispMap != null) {\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(displayLanguageTag);\n-        if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, msgSourceQueueIter);\n+        //cacheItem = new FormatCacheItem();\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (dispMap != null && dispMap.size() > 0) {\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            return dispMap;\n         }\n         return dispMap;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n-        }\n-        return respMap;\n-    }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n-        }\n-        \n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if (!msgSourceQueueIter.hasNext())\n+            return dispMap;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n-        \treturn getDisplayNamesFromCLDR(language, msgSourceQueueIter);\n+            dispMap = getSupportedLanguagesFromDS(locale, msgSourceQueueIter);", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjI3MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465736270", "bodyText": "Actually I resolve this in cache update commit, since I plan to put cache update in a new PR, so I reset that commit, after reset the change reset, too. So I resolve this in this PR again.", "author": "huihuiw01", "createdAt": "2020-08-05T13:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyODQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyODcwNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464728704", "bodyText": "I still do not see my previous code suggestion\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!msgSourceQueueIter.hasNext())\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    if (!msgSourceQueueIter.hasNext()) {\n          \n          \n            \n                        logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }", "author": "jessiejuachon", "createdAt": "2020-08-04T00:20:21Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,125 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n-import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n-    }\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext())\n+            return regions;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);\n             }\n-        };\n-        FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n-        Thread thread = new Thread(task);\n-        thread.start();\n+        }\n+        return dispMap;\n     }\n \n-    private Map<String, String> getSupportedLanguagesFromDS(String displayLanguageTag, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+    public Map<String, String> getSupportedDisplayNamesByLocale(String locale) {\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext()) {\n-            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n+        logger.debug(\"Look for displayNames from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        dispMap = formattingCacheService.getSupportedLanguages(dto, locale);\n+        if (dispMap != null) {\n+            logger.debug(\"Find displayNames from cache for product [{}], version [{}], locale [{}]!\", dto.getProductID(), dto.getVersion(), locale);\n             return dispMap;\n         }\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        dispMap = dataSource.createLocaleOpt().getSupportedLanguages(displayLanguageTag);\n-        if (dispMap == null || dispMap.isEmpty()) {\n-            logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, msgSourceQueueIter);\n+        //cacheItem = new FormatCacheItem();\n+        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (dispMap != null && dispMap.size() > 0) {\n+            logger.debug(\"Find the displayNames for product [{}], version [{}], locale [{}].\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n+            logger.debug(\"DisplayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\", dto.getProductID(), dto.getVersion(), locale);\n+            return dispMap;\n         }\n         return dispMap;\n     }\n \n-    public Map<String, Map<String, String>> getTerritoriesFromCLDR(\n-            List<String> languages) {\n-        \n-        Map<String, Map<String, String>> respMap = new HashMap<String, Map<String, String>>();\n-        for (String language : languages) {\n-            language = language.toLowerCase();\n-            Map<String, String> regionMap = null;\n-            logger.trace(\"look for region list of '\" + language + \"' from cache\");\n-            Cache c = VIPCfg.getInstance().getCacheManager()\n-                    .getCache(VIPCfg.CACHE_L2);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(REGION_PREFIX\n-                        + language);    \n-                regionMap = cacheItem == null ? regionMap : cacheItem.getCachedData();\n-            }\n-            if (regionMap != null) {\n-                respMap.put(language, regionMap);\n-                continue;\n-            }\n-            logger.trace(\"get region list of '\" + language\n-                    + \"' data from backend\");\n-            Map<String, String> tmpMap = new RemoteLocaleOpt()\n-\t\t\t\t        .getTerritoriesFromCLDR(language);\n-            regionMap = JSONUtils.map2SortMap(tmpMap);\n-            respMap.put(language, regionMap);\n-            if (c != null) {\n-            \tFormatCacheItem cacheItem = new FormatCacheItem(regionMap);\n-                c.put(REGION_PREFIX + language, cacheItem);\n-            }\n-        }\n-        return respMap;\n-    }\n \n-    public Map<String, String> getDisplayNamesFromCLDR(String language, \n-    \t\tListIterator<DataSourceEnum> msgSourceQueueIter) {\n-    \tMap<String, String> dispMap = new HashMap<String, String>(); \t\n-    \tif (!msgSourceQueueIter.hasNext()) \n-    \t\treturn dispMap;\n-        \n-        logger.trace(\"look for displayNames from cache\");\n-        Cache c = VIPCfg.getInstance().getCacheManager()\n-                .getCache(VIPCfg.CACHE_L2);\n-        if (c != null) {\n-        \tFormatCacheItem cacheItem = (FormatCacheItem) c.get(DISPN_PREFIX + language); \n-        \tif (cacheItem == null) {\n-        \t\tcacheItem = new FormatCacheItem();\n-        \t}\n-            dispMap = cacheItem.getCachedData();\n-            if (dispMap.isEmpty()) {\n-            \tDataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n-            \tMap<String, String> tmpMap = dataSource.createLocaleOpt().getSupportedLanguages(language);\n-                dispMap = JSONUtils.map2SortMap(tmpMap);\n-                if (dispMap != null && dispMap.size() > 0) {\n-                    c.put(DISPN_PREFIX + language, new FormatCacheItem(dispMap));\n-                }\n-            }\n-        }\n-        \n+    private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        if (!msgSourceQueueIter.hasNext())\n+            return dispMap;", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNTE2MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464735160", "bodyText": "No need for this check because there is already a check on line 91 when method is called recursively", "author": "jessiejuachon", "createdAt": "2020-08-04T00:43:47Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -106,4 +81,28 @@ public JSONArray getSupportedLocalesFromRemoteVIP() {\n         return components;\n     }\n \n+    /**\n+     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n+     *\n+     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n+     * @return list of locales of the product specified in the dto object\n+     */\n+    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {\n+        if (!msgSourceQueueIter.hasNext()) { return null; }\n+\n+        DataSourceEnum dataSource = msgSourceQueueIter.next();\n+        ProductOpt opt = dataSource.createProductOpt(dto);\n+        List<String> locales = opt.getSupportedLocales();\n+        // If failed to get components from the data source\n+        if (locales.isEmpty()) {\n+            // Try the next dataSource in the queue\n+            if (msgSourceQueueIter.hasNext()) {", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyOTQ2OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465829468", "bodyText": "Write the same with you, just copy 'getComponents' method which already exsits in this class.", "author": "huihuiw01", "createdAt": "2020-08-05T15:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNTE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1OTkyNA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464759924", "bodyText": "This will cause other tests to fail because VIPCFG is a singleton. I had added vipconfig-offline before, but Colin and Xiaochao do not want to use it inside the tests because they say that we should not be able to re-initialize VIPCfg. Hence, that .properties file is not used anymore. Only vipconfig.properties is used, and if I have to modify any property for certain unit tests, I do it inside the test itself. See LocaleTest.testGetSupportedLocalesOfflineBundles for an example.", "author": "jessiejuachon", "createdAt": "2020-08-04T02:19:54Z", "path": "src/test/java/com/vmware/vip/i18n/DateFormatUtilOfflineTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vip.i18n;\n+\n+import com.vmware.vipclient.i18n.I18nFactory;\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n+import com.vmware.vipclient.i18n.base.instances.DateFormatting;\n+import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Date;\n+import java.util.Locale;\n+\n+public class DateFormatUtilOfflineTest extends BaseTestClass {\n+\n+    final String fullDateForEn = \"Monday, November 20, 2017\";\n+    final String longDateForEn = \"November 20, 2017\";\n+    final String mediumDateForEn = \"Nov 20, 2017\";\n+    final String shortDateForEn = \"11/20/17\";\n+    final String fullTimeForEn = \"1:39:24 PM GMT+08:00\";\n+    final String longTimeForEn = \"1:39:24 PM GMT+8\";\n+    final String mediumTimeForEn = \"1:39:24 PM\";\n+    final String shortTimeForEn = \"1:39 PM\";\n+    final String fullForEn = \"Monday, November 20, 2017 at 1:39:24 PM GMT+08:00\";\n+    final String longForEn = \"November 20, 2017 at 1:39:24 PM GMT+8\";\n+    final String mediumForEn = \"Nov 20, 2017, 1:39:24 PM\";\n+    final String shortForEn = \"11/20/17, 1:39 PM\";\n+\n+    final String fullDateForZh = \"2017\u5e7411\u670820\u65e5\u661f\u671f\u4e00\";\n+    final String longDateForZh = \"2017\u5e7411\u670820\u65e5\";\n+    final String mediumDateForZh = \"2017\u5e7411\u670820\u65e5\";\n+    final String shortDateForZh = \"2017/11/20\";\n+    final String fullTimeForZh = \"GMT+08:00 \u4e0b\u53481:39:24\";\n+    final String longTimeForZh = \"GMT+8 \u4e0b\u53481:39:24\";\n+    final String mediumTimeForZh = \"\u4e0b\u53481:39:24\";\n+    final String shortTimeForZh = \"\u4e0b\u53481:39\";\n+    final String fullForZh = \"2017\u5e7411\u670820\u65e5\u661f\u671f\u4e00 GMT+08:00 \u4e0b\u53481:39:24\";\n+    final String longForZh = \"2017\u5e7411\u670820\u65e5 GMT+8 \u4e0b\u53481:39:24\";\n+    final String mediumForZh = \"2017\u5e7411\u670820\u65e5 \u4e0b\u53481:39:24\";\n+    final String shortForZh = \"2017/11/20 \u4e0b\u53481:39\";\n+\n+    final String fullDateForFr = \"lundi 20 novembre 2017\";\n+    final String longDateForFr = \"20 novembre 2017\";\n+    final String mediumDateForFr = \"20 nov. 2017\";\n+    final String shortDateForFr = \"20/11/2017\";\n+    final String fullTimeForFr = \"13:39:24 GMT+08:00\";\n+    final String longTimeForFr = \"13:39:24 GMT+8\";\n+    final String mediumTimeForFr = \"13:39:24\";\n+    final String shortTimeForFr = \"13:39\";\n+    final String fullForFr = \"lundi 20 novembre 2017 \u00e0 13:39:24 GMT+08:00\";\n+    final String longForFr = \"20 novembre 2017 \u00e0 13:39:24 GMT+8\";\n+    final String mediumForFr = \"20 nov. 2017 \u00e0 13:39:24\";\n+    final String shortForFr = \"20/11/2017 13:39\";\n+\n+    final long timestamp = 1511156364801l;\n+    final String timeZone = \"GMT+8\";\n+    Date date = new Date(timestamp);\n+\n+    DateFormatting dateFormatI18n;\n+\n+    @Before\n+    public void init() {\n+        VIPCfg gc = VIPCfg.getInstance();\n+        try {\n+            gc.initialize(\"vipconfig-offline\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0MjAwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465742000", "bodyText": "As we discussed offline, unit tests is for testing different scenarios, not for mock real scenarios,  re-initialize is acceptable. And use  properties is more convenient, or we need do setMsgOriginsQueue in many places to re-initialize data source.\nSo I clear data source queue before each initiallization by calling clearDataSource method in the constructor of parent class of all test classes 'BaseTestClass', and problem is resolved.", "author": "huihuiw01", "createdAt": "2020-08-05T13:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1OTkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDAzNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464760035", "bodyText": "Same comment: \"This will cause other tests to fail because VIPCFG is a singleton. I had added vipconfig-offline before, but Colin and Xiaochao do not want to use it inside the tests because they say that we should not be able to re-initialize VIPCfg. Hence, that .properties file is not used anymore. Only vipconfig.properties is used, and if I have to modify any property for certain unit tests, I do it inside the test itself. See LocaleTest.testGetSupportedLocalesOfflineBundles for an example. \"", "author": "jessiejuachon", "createdAt": "2020-08-04T02:20:17Z", "path": "src/test/java/com/vmware/vip/i18n/MessageFormatOfflineTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vip.i18n;\n+\n+import com.vmware.vipclient.i18n.I18nFactory;\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n+import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n+import com.vmware.vipclient.i18n.l2.text.MessageFormat;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.text.FieldPosition;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+public class MessageFormatOfflineTest extends BaseTestClass {\n+\n+    @Before\n+    public void init() {\n+        VIPCfg gc = VIPCfg.getInstance();\n+        try {\n+            gc.initialize(\"vipconfig-offline\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0MjU2OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465742568", "bodyText": "Same resolution as above.", "author": "huihuiw01", "createdAt": "2020-08-05T13:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDE4NA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464760184", "bodyText": "Same comment: \"This will cause other tests to fail because VIPCFG is a singleton. I had added vipconfig-offline before, but Colin and Xiaochao do not want to use it inside the tests because they say that we should not be able to re-initialize VIPCfg. Hence, that .properties file is not used anymore. Only vipconfig.properties is used, and if I have to modify any property for certain unit tests, I do it inside the test itself. See LocaleTest.testGetSupportedLocalesOfflineBundles for an example. \"", "author": "jessiejuachon", "createdAt": "2020-08-04T02:20:48Z", "path": "src/test/java/com/vmware/vip/i18n/NumberFormatUtilOfflineTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vip.i18n;\n+\n+import com.vmware.vipclient.i18n.I18nFactory;\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n+import com.vmware.vipclient.i18n.base.instances.NumberFormatting;\n+import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Locale;\n+\n+public class NumberFormatUtilOfflineTest extends BaseTestClass {\n+\n+    NumberFormatting numberFormatI18n;\n+\n+    @Before\n+    public void init() {\n+        VIPCfg gc = VIPCfg.getInstance();\n+        try {\n+            gc.initialize(\"vipconfig-offline\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0MjY0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465742647", "bodyText": "Same resolution as above.", "author": "huihuiw01", "createdAt": "2020-08-05T13:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDIzMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464760230", "bodyText": "Same comment: \"This will cause other tests to fail because VIPCFG is a singleton. I had added vipconfig-offline before, but Colin and Xiaochao do not want to use it inside the tests because they say that we should not be able to re-initialize VIPCfg. Hence, that .properties file is not used anymore. Only vipconfig.properties is used, and if I have to modify any property for certain unit tests, I do it inside the test itself. See LocaleTest.testGetSupportedLocalesOfflineBundles for an example. \"", "author": "jessiejuachon", "createdAt": "2020-08-04T02:21:00Z", "path": "src/test/java/com/vmware/vip/i18n/PluralFormatOfflineTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vip.i18n;\n+\n+import com.vmware.vipclient.i18n.I18nFactory;\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.base.cache.FormattingCache;\n+import com.vmware.vipclient.i18n.exceptions.VIPClientInitException;\n+import com.vmware.vipclient.i18n.l2.text.PluralFormat;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.text.FieldPosition;\n+import java.util.Locale;\n+\n+public class PluralFormatOfflineTest extends BaseTestClass {\n+\n+    public PluralFormatOfflineTest() {\n+        // TODO Auto-generated constructor stub\n+    }\n+\n+    @Before\n+    public void init() {\n+        VIPCfg gc = VIPCfg.getInstance();\n+        try {\n+            gc.initialize(\"vipconfig-offline\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0Mjc1Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465742752", "bodyText": "Same resolution as above.", "author": "huihuiw01", "createdAt": "2020-08-05T13:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc2MDIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc5MDg3Ng==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464790876", "bodyText": "Just like what I put in the Javadoc comment of this method,  the plan is to deprecate this V2URL endpoint on service side because it is but a subset of V2URL.getSupportedLanguageListURL (language tags only instead of tags + display names). So call RemoteLocaleOpt.getSupportedLanguages(default locale) in here and just grab the keySet().\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public List<String> getSupportedLocales() {\n          \n          \n            \n                    JSONArray msgObject = new JSONArray();\n          \n          \n            \n                    String responseStr = \"\";\n          \n          \n            \n                    Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(V2URL.getSupportedLocaleListURL(\n          \n          \n            \n                public List<String> getSupportedLocales() {\n          \n          \n            \n                    Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n          \n          \n            \n                    return getSupportedLocales(fallbackLocalesIter);\n          \n          \n            \n                }\n          \n          \n            \n                private List<String> getSupportedLocales(Iterator<Locale> fallbackLocalesIter) {\n          \n          \n            \n                    if (fallbackLocalesIter != null && fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                        String locale = fallbackLocalesIter.next().toLanguageTag();\n          \n          \n            \n                        Map<String, String> supportedLocales = RemoteLocaleOpt.getSupportedLanguages(locale);\n          \n          \n            \n                        if (supportedLocales == null || supportedLocales.isEmpty()) {\n          \n          \n            \n                            return getSupportedLocales(fallbackLocalesIter);\n          \n          \n            \n                        }\n          \n          \n            \n                        return supportedLocales.keySet();\n          \n          \n            \n                    }\n          \n          \n            \n                    return null;\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-04T04:23:51Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java", "diffHunk": "@@ -52,7 +52,7 @@ public ProductBasedOpt(BaseDTO dto) {\n      * @see com.vmware.vipclient.i18n.messages.dao.ILocaleDao#getSupportedLocales()\n      * @deprecated Replaced by {@link com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt#getSupportedLanguages(String)()}\n      */\n-    @Deprecated public JSONArray getSupportedLocalesFromRemoteVIP() {\n+    public List<String> getSupportedLocales() {\n         JSONArray msgObject = new JSONArray();\n         String responseStr = \"\";\n         Map<String, Object> response = VIPCfg.getInstance().getVipService().getHttpRequester().request(V2URL.getSupportedLocaleListURL(", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjExNzA4MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466117081", "bodyText": "I prefer to deprecate this V2URL endpoint after V3 API is available.\nLooks like V3 API url is different with V2, after V3 is available, this need to be changed again.", "author": "huihuiw01", "createdAt": "2020-08-06T03:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc5MDg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg0NzI4OQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464847289", "bodyText": "It's better to solve the problem instead of commenting it.", "author": "Xiaochao8", "createdAt": "2020-08-04T07:15:12Z", "path": "src/test/java/com/vmware/vip/i18n/TranslationMessageTest.java", "diffHunk": "@@ -178,7 +185,7 @@ public void testGetPatternMessageWithBundle() {\n         Assert.assertEquals(\"\\\"\u6211\u7684\u786c\u76d8\\\"\u4e0a\u6709345,678\u4e2a\u6587\u4ef6\u3002\", pluralMessage6);\n     }\n \n-    @Test", "originalCommit": "a456440e78eee1bb7b0e1079dab66174a1648710", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg0OTk1NQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464849955", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LocaleDTO dto = new LocaleDTO();\n          \n          \n            \n                    if(cfg != null) {\n          \n          \n            \n                        dto.setProductID(cfg.getProductName());\n          \n          \n            \n                        dto.setVersion(cfg.getVersion());\n          \n          \n            \n                    }else{\n          \n          \n            \n                        dto.setProductID(VIPCfg.getInstance().getProductName());\n          \n          \n            \n                        dto.setVersion(VIPCfg.getInstance().getVersion());\n          \n          \n            \n                    }\n          \n          \n            \n              LocaleDTO dto = new LocaleDTO(cfg)", "author": "Xiaochao8", "createdAt": "2020-08-04T07:20:39Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/LocaleMessage.java", "diffHunk": "@@ -71,12 +86,37 @@ public LocaleMessage() {\n      *            a language tag determines the display name's localization\n      * @return a list contains the display names\n      */\n-    public List<String> getSupportedDisplayNameList(String displayLanguage) {\n-        Map<String, String> dispNameMap = new LocaleService().getDisplayNamesFromCLDR(displayLanguage, \n-        \t\tVIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-        Collection<String> valueCollection = dispNameMap.values();\n-        List<String> dispNameList = new ArrayList<String>(valueCollection);\n-        return dispNameList;\n+    public List<String> getSupportedDisplayNameList(String displayLocale) {\n+        Map<String, String> dispNameMap = getDisplayNamesFromCLDR(displayLocale);\n+        if(dispNameMap != null) {\n+            Collection<String> valueCollection = dispNameMap.values();\n+            return new ArrayList<String>(valueCollection);\n+        }\n+        return new ArrayList();\n+    }\n+\n+    private Map<String, String> getDisplayNamesFromCLDR(String locale) {\n+        if(locale == null || locale.isEmpty()) {\n+            logger.warn(\"Locale is empty!\");\n+            return null;\n+        }\n+        LocaleDTO dto = new LocaleDTO();\n+        if(cfg != null) {\n+            dto.setProductID(cfg.getProductName());\n+            dto.setVersion(cfg.getVersion());\n+        }else{\n+            dto.setProductID(VIPCfg.getInstance().getProductName());\n+            dto.setVersion(VIPCfg.getInstance().getVersion());\n+        }", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg1MDQ0MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r464850441", "bodyText": "Remove this line.", "author": "Xiaochao8", "createdAt": "2020-08-04T07:21:44Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -28,45 +30,18 @@ public ProductService(BaseDTO dto) {\n         this.dto = dto;\n     }\n \n-    /**\n-     * get supported components defined in vip service\n-     * @return JSONArray\n-     * @deprecated Replaced by {@link #getComponents(Iterator<>)}\n-     */\n-    @Deprecated\n-    public JSONArray getComponentsFromRemoteVIP() {\n-        BaseDTO baseDTO = new BaseDTO();\n-        baseDTO.setProductID(dto.getProductID());\n-        baseDTO.setVersion(dto.getVersion());\n-        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n-        return dao.getComponentsFromRemoteVIP();\n-    }\n-\n-    /**\n-     * get supported locales defined in vip service\n-     * @deprecated Replaced by {@link com.vmware.vipclient.i18n.messages.service.LocaleService#getSupportedLanguages(Iterator<>)}\n-     */\n-    @Deprecated\n-    public JSONArray getSupportedLocalesFromRemoteVIP() {\n-        BaseDTO baseDTO = new BaseDTO();\n-        baseDTO.setProductID(dto.getProductID());\n-        baseDTO.setVersion(dto.getVersion());\n-        ProductBasedOpt dao = new ProductBasedOpt(baseDTO);\n-        return dao.getSupportedLocalesFromRemoteVIP();\n-    }\n-\n     /**\n      * Retrieves translated messages of all components of a product in the requested locale (See the dto object).\n      *\n      * @return translated messages of all components of a product locale specified in the dto object\n      */\n     public List<Map> getAllComponentTranslation() {\n         List<Map> list = new ArrayList<Map>();\n-        LocaleDTO localeDTO = new LocaleDTO(dto.getProductID(), dto.getVersion());\n-        Map<String, String> locales = new LocaleService(localeDTO).getSupportedLanguages();\n+        LocaleDTO localeDTO = new LocaleDTO();", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA4MzUxNw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465083517", "bodyText": "are -> is", "author": "Xiaochao8", "createdAt": "2020-08-04T14:16:25Z", "path": "src/main/java/com/vmware/vipclient/i18n/base/instances/PatternMessage.java", "diffHunk": "@@ -36,6 +42,10 @@ public JSONObject getPatternMessage(Locale locale) {\n      * @return\n      */\n     public JSONObject getPatternMessage(String language, String region) {\n+        if((language == null || language.isEmpty()) || (region == null || region.isEmpty())) {\n+            logger.warn(\"Either language or region are empty!\");", "originalCommit": "ea7e7aad21a289e1d416584c0b6880ab0b7c9cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyMTcyOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465121728", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\ttry {\n          \n          \n            \n            \t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n          \n          \n            \n            \t\t} catch (ParseException e) {\n          \n          \n            \n            \t\t\te.printStackTrace();\n          \n          \n            \n            \t\t\tlogger.error(e.getMessage());\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif (regionsData == null) {\n          \n          \n            \n            \t\t\treturn null;\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\treturn (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n          \n          \n            \n                    try {\n          \n          \n            \n                        regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n          \n          \n            \n                        return (JSONObject) regionsData.get(PatternKeys.TERRITORIES);\n          \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                        logger.error(e.getMessage());\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return null;", "author": "Xiaochao8", "createdAt": "2020-08-04T15:07:10Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -4,65 +4,129 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.stream.Stream;\n-\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n+import org.json.simple.parser.ParseException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n     private static final String BUNDLE_PREFIX = \"messages_\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-   \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate static final String BUNDLE_SUFFIX = \".json\";\n+\n+\tprivate LocaleDTO dto = null;\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n+\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n+\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n-    }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n-        }\n+\t\treturn supportedLanguageNames;\n     }\n \n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/\n+\n+    private Map<String, String> getLanguagesNamesFromCLDR(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlogger.debug(\"Look for languages' names from cache for locale [{}]!\", locale);\n+\t\tFormattingCacheService formattingCacheService = new FormattingCacheService();\n+\t\tlanguagesNames = formattingCacheService.getLanguagesNames(locale);// key\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find languages' names from cache for locale [{}]!\", locale);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tlanguagesNames = getLanguagesNamesFromBundle(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\tlogger.debug(\"Find the languages' names from local bundle for locale [{}].\\n\", locale);// [datetime] and\n+\t\t\tformattingCacheService.addLanguagesNames(locale, languagesNames);\n+\t\t\tlogger.debug(\"Languages' names are cached for locale [{}]!\\n\\n\", locale);\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate JSONObject getLanguagesNamesFromBundle(String locale) {\n+\t\tlogger.debug(\"Look for languages' names from local package bundle for locale [{}]!\", locale);\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n+\t\t\treturn null;\n+\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+\t\tJSONObject languagesData = null;\n+\t\ttry {\n+\t\t\tlanguagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();\n+\t\t\tlogger.error(e.getMessage());\n+\t\t}\n+\t\tif (languagesData == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t}\n+\n+\tpublic JSONObject getRegions(String locale) {\n+\t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n+\t\tJSONObject regionsData = null;\n+\t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n+\t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n+\t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n+\t\t\treturn null;\n+\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n+\t\ttry {\n+\t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n+\t\t} catch (ParseException e) {\n+\t\t\te.printStackTrace();\n+\t\t\tlogger.error(e.getMessage());\n+\t\t}\n+\t\tif (regionsData == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (JSONObject) regionsData.get(PatternKeys.TERRITORIES);", "originalCommit": "1610a70670615d27073abf930cc7274dd1653a9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyMzM0OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465123348", "bodyText": "Since the '@deprecated' is removed, this 'Deprecated' needs to be removed as well.", "author": "Xiaochao8", "createdAt": "2020-08-04T15:09:29Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/server/RemoteProductOpt.java", "diffHunk": "@@ -29,7 +29,7 @@ public ProductBasedOpt(BaseDTO dto) {\n      * @see com.vmware.vipclient.i18n.messages.dao.IComponentDao#getComponents()\n      * @Deprecated Replaced by {@link com.vmware.vipclient.i18n.messages.api.opt.server.RemoteComponentOpt#getComponents()}", "originalCommit": "1610a70670615d27073abf930cc7274dd1653a9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEyNzg4MQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r465127881", "bodyText": "Because this is an interface, please keep msgSourceQueueIter internally. Don't include it as a parameter.\nThe upper layer don't need to know this.", "author": "Xiaochao8", "createdAt": "2020-08-04T15:15:40Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -106,4 +81,28 @@ public JSONArray getSupportedLocalesFromRemoteVIP() {\n         return components;\n     }\n \n+    /**\n+     * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n+     *\n+     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n+     * @return list of locales of the product specified in the dto object\n+     */\n+    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {", "originalCommit": "1610a70670615d27073abf930cc7274dd1653a9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNjM5OA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466706398", "bodyText": "There are 2 items in the below suggestion:\n\nUse of fallbackLocalesIter\nCache update using populateCacheTask.\n\nYou had mentioned you wanted to do #2 (cache update) in next PR, in which case just remove populateCacheTask from code suggestion below and log an issue in github.\nBut what about #1 (using fallbackLocalesIter) ?  Do you also want to do this in the next PR even if it has nothing to do with cache update? That is fine, just log another issuein github.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    dispMap = getSupportedDisplayNamesByLocale(locale);\n          \n          \n            \n                    if(dispMap != null && !dispMap.isEmpty()){\n          \n          \n            \n                        return dispMap;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (locale != null && !locale.isEmpty() && !LocaleUtility.isDefaultLocale(locale)) {\n          \n          \n            \n                        logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n          \n          \n            \n                        Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n          \n          \n            \n                        dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n          \n          \n            \n                        if (dispMap != null && dispMap.size() > 0) {\n          \n          \n            \n                            new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                            logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n          \n          \n            \n                                    dto.getProductID(), dto.getVersion(), locale);\n          \n          \n            \n                    // if display language is null, just proceed to the next available fallback locale\n          \n          \n            \n                    if (locale == null) {\n          \n          \n            \n                        if (fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            locale = fallbackLocalesIter.next().toLanguageTag();\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    locale = locale.replace(\"_\", \"-\").toLowerCase();\n          \n          \n            \n                    logger.debug(\"Look for supported languages from cache for locale [{}]\", locale);\n          \n          \n            \n                    String productName = dto.getProductID();\n          \n          \n            \n                    String version = dto.getVersion();\n          \n          \n            \n                    FormattingCacheService formattingCacheService = new FormattingCacheService();\n          \n          \n            \n                    FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, locale);\n          \n          \n            \n                    if (cacheItem != null) {\n          \n          \n            \n                        logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, locale);\n          \n          \n            \n                        dispMap = cacheItem.getCachedData();\n          \n          \n            \n                        if (cacheItem.isExpired()) {\n          \n          \n            \n                            populateCacheTask(locale);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                    \n          \n          \n            \n                        dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                        if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n          \n          \n            \n                            dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n          \n          \n            \n                            if (dispMap != null && !dispMap.isEmpty()) {\n          \n          \n            \n                                formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n          \n          \n            \n                                logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    //}\n          \n          \n            \n                    return dispMap;\n          \n          \n            \n                }\n          \n          \n            \n                private void populateCacheTask(String locale) {\n          \n          \n            \n                    Callable<Map<String, String>> callable = () -> {\n          \n          \n            \n                        try {\n          \n          \n            \n                            Map<String, String> dispMap = getSupportedLanguagesFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n          \n          \n            \n                            return dispMap;\n          \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                            // To make sure that the thread will close\n          \n          \n            \n                            // even when an exception is thrown\n          \n          \n            \n                            return null;\n          \n          \n            \n                        }\n          \n          \n            \n                    };\n          \n          \n            \n                    FutureTask<Map<String, String>> task = new FutureTask<>(callable);\n          \n          \n            \n                    Thread thread = new Thread(task);\n          \n          \n            \n                    thread.start();\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-06T21:52:52Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,136 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n+    public LocaleService() {\n     }\n+\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        if (!LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find regions for locale [{}], look for default locale's regions as fallback!\", locale);\n+            regionMap = getRegionsByLocale(LocaleUtility.getDefaultLocale().toLanguageTag());\n+            if (regionMap != null) {\n+                new FormattingCacheService().addRegions(locale, regionMap);\n+                logger.debug(\"Default locale's regions is cached for locale [{}]!\\n\\n\", locale);\n+            }\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(Iterator<Locale> fallbackLocalesIter) {\n-        return getSupportedLanguages(null, fallbackLocalesIter);\n+    public Map<String, String> getRegionsByLocale(String locale){\n+        locale = locale.replace(\"_\", \"-\").toLowerCase();\n+        Map<String, String> regionMap = null;\n+        logger.debug(\"Look for region list from cache for locale [{}]\", locale);\n+        FormattingCacheService formattingCacheService = new FormattingCacheService();\n+        regionMap = formattingCacheService.getRegions(locale);\n+        if (regionMap != null) {\n+            logger.debug(\"Find regions from cache for locale [{}]!\", locale);\n+            return regionMap;\n+        }\n+        regionMap = getRegionsFromDS(locale, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n+        if (regionMap != null) {\n+            logger.debug(\"Find the regions for locale [{}].\\n\", locale);\n+            formattingCacheService.addRegions(locale, regionMap);\n+            logger.debug(\"Regions is cached for locale [{}]!\\n\\n\", locale);\n+            return regionMap;\n+        }\n+        return regionMap;\n     }\n \n-    public Map<String, String> getSupportedLanguages(String displayLanguageTag, Iterator<Locale> fallbackLocalesIter) {\n-        Map<String, String> dispMap = new HashMap<String, String>();\n-\n-        // if display language is null, just proceed to the next available fallback locale\n-        if (displayLanguageTag == null) {\n-            if (fallbackLocalesIter.hasNext()) {\n-                displayLanguageTag = fallbackLocalesIter.next().toLanguageTag();\n-            } else {\n-                return dispMap;\n-            }\n+    private Map<String, String> getRegionsFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n+        Map<String, String> regions = null;\n+        if (!msgSourceQueueIter.hasNext()) {\n+            logger.error(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED_ALL));\n+            return regions;\n         }\n-        displayLanguageTag = displayLanguageTag.replace(\"_\", \"-\").toLowerCase();\n-        \n-        //TODO This will be implemented in Huihui's PR\n-        /*\n-        logger.debug(\"Look for supported languages from cache for locale [{}]\", displayLanguageTag);\n-        String productName = dto.getProductID();\n-        String version = dto.getVersion();\n-        FormattingCacheService formattingCacheService = new FormattingCacheService();\n-        FormatCacheItem cacheItem = formattingCacheService.getSupportedLanguages(dto, displayLanguageTag);\n-        if (cacheItem != null) {\n-            logger.debug(\"Found displayNames from cache for product [{}], version [{}], locale [{}]!\", productName, version, displayLanguageTag);\n-            dispMap = cacheItem.getCachedData();\n-            if (cacheItem.isExpired()) {\n-                populateCacheTask(displayLanguageTag);\n-            }\n-        } else {\n-        */\n-            dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-            if ((dispMap == null || dispMap.isEmpty()) && fallbackLocalesIter.hasNext()) {\n-                dispMap = new LocaleService(dto).getSupportedLanguages(fallbackLocalesIter);\n-                if (dispMap != null && !dispMap.isEmpty()) {\n-                    // TODO: Huihui has implemented this in another PR\n-                    /*formattingCacheService.addSupportedLanguages(dto, locale, dispMap);\n-                    logger.debug(\"List of supported languages added to cache for product [{}], version [{}], locale [{}]!\\n\\n\", productName, version, locale);*/\n-                }\n-            }\n-        //}\n-\n-        return dispMap;\n+        DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n+        regions = dataSource.createLocaleOpt(dto).getRegions(locale);\n+        if (regions == null || regions.isEmpty()) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_REGIONS_FAILED, dataSource.toString()));\n+            regions = getRegionsFromDS(locale, msgSourceQueueIter);\n+        }\n+        return regions;\n     }\n \n-    private void populateCacheTask(String displayLanguageTag) {\n-        Callable<Map<String, String>> callable = () -> {\n-            try {\n-                Map<String, String> dispMap = getSupportedLanguagesFromDS(displayLanguageTag, VIPCfg.getInstance().getMsgOriginsQueue().listIterator());\n-                return dispMap;\n-            } catch (Exception e) {\n-                // To make sure that the thread will close\n-                // even when an exception is thrown\n-                return null;\n+    public Map<String, String> getDisplayNames(String locale) {\n+        Map<String, String> dispMap = new HashMap<String, String>();\n+        dispMap = getSupportedDisplayNamesByLocale(locale);\n+        if(dispMap != null && !dispMap.isEmpty()){\n+            return dispMap;\n+        }\n+        if (locale != null && !locale.isEmpty() && !LocaleUtility.isDefaultLocale(locale)) {\n+            logger.info(\"Can't find supported languages for locale [{}], look for default locale's languages as fallback!\", locale);\n+            Locale fallbackLocale = LocaleUtility.getDefaultLocale();\n+            dispMap = getSupportedDisplayNamesByLocale(fallbackLocale.toLanguageTag());\n+            if (dispMap != null && dispMap.size() > 0) {\n+                new FormattingCacheService().addSupportedLanguages(dto, locale, dispMap);\n+                logger.debug(\"Default locale's displayNames is cached for product [{}], version [{}], locale [{}]!\\n\\n\",\n+                        dto.getProductID(), dto.getVersion(), locale);", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNjI1MA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466936250", "bodyText": "Use of fallbackLocalesIter\nresolved", "author": "huihuiw01", "createdAt": "2020-08-07T09:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNjM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2NDQxOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466764419", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (components.isEmpty()) {\n          \n          \n            \n                        if (components == null || components.isEmpty()) {", "author": "Xiaochao8", "createdAt": "2020-08-07T01:04:17Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -58,23 +56,17 @@ public ProductService(BaseDTO dto) {\n     /**\n      * Retrieves the list of components of a product. It recursively applies data source fallback mechanism in case of failure.\n      *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n      * @return list of components of the product specified in the dto object\n      */\n-    public List<String> getComponents (Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext())\n-            return null;\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> components = opt.getComponents();\n-        // If failed to get components from the data source\n-        if (components.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                components = getComponents(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n+    public List<String> getComponents(){\n+        List<String> components = null;\n+        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n+        while((components == null || components.isEmpty()) && msgSourceQueueIter.hasNext()){\n+            DataSourceEnum dataSource = msgSourceQueueIter.next();\n+            ProductOpt opt = dataSource.createProductOpt(dto);\n+            components = opt.getComponents();\n+            // If failed to get components from the data source, log the error.\n+            if (components.isEmpty()) {", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNDM0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466934347", "bodyText": "Actually \u2018components\u2019 won't be null as opt.getComponents() method new ArrayList and won't return null.", "author": "huihuiw01", "createdAt": "2020-08-07T09:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2NDQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2ODcyMQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466768721", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        JSONObject regionsData = null;\n          \n          \n            \n            \t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n          \n          \n            \n            \t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);\n          \n          \n            \n            \t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n          \n          \n            \n            \t\t\tJSONObject regionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);", "author": "Xiaochao8", "createdAt": "2020-08-07T01:20:25Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -96,37 +95,33 @@ private JSONObject getLanguagesNamesFromBundle(String locale) {\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n-\t\tString languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n-\t\tJSONObject languagesData = null;\n-\t\ttry {\n-\t\t\tlanguagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n-\t\t} catch (ParseException e) {\n+        try {\n+            JSONObject languagesData = null;\n+            String languagesJsonStr = PatternUtil.getLanguageFromLib(normalizedLocale);\n+            languagesData = (JSONObject) new JSONParser().parse(languagesJsonStr);\n+            return (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+\t\t} catch (Exception e) {\n \t\t\te.printStackTrace();\n \t\t\tlogger.error(e.getMessage());\n \t\t}\n-\t\tif (languagesData == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn (JSONObject) languagesData.get(PatternKeys.LANGUAGES);\n+        return null;\n \t}\n \n \tpublic JSONObject getRegions(String locale) {\n \t\tlogger.debug(\"Look for regions from local bundle for locale [{}]!\", locale);\n-\t\tJSONObject regionsData = null;\n \t\tString normalizedLocale = CommonUtil.getCLDRLocale(locale, localePathMap, localeAliasesMap);\n \t\tlogger.info(\"Normalized locale for locale [{}] is [{}]\", locale, normalizedLocale);\n \t\tif(normalizedLocale == null || normalizedLocale.isEmpty())\n \t\t\treturn null;\n-\t\tString regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n-\t\ttry {\n+        try {\n+            JSONObject regionsData = null;\n+\t\t    String regionsJsonStr = PatternUtil.getRegionFromLib(normalizedLocale);\n \t\t\tregionsData = (JSONObject) new JSONParser().parse(regionsJsonStr);", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2ODkxMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466768912", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<String, Object> patterns = null;\n          \n          \n            \n                        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n          \n          \n            \n                        patterns = (Map<String, Object>) new JSONParser().parse(patternStr);\n          \n          \n            \n                        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n          \n          \n            \n                        Map<String, Object> patterns = (Map<String, Object>) new JSONParser().parse(patternStr);", "author": "Xiaochao8", "createdAt": "2020-08-07T01:20:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalPatternOpt.java", "diffHunk": "@@ -42,14 +41,15 @@ public JSONObject getPatterns(String language, String region) {\n     private JSONObject getPatternsByLocale(String normalizedLocale) {\n         if(normalizedLocale == null || normalizedLocale.isEmpty())\n             return null;\n-        String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n-        Map<String, Object> patterns = null;\n         try {\n+            Map<String, Object> patterns = null;\n+            String patternStr = PatternUtil.getPatternFromLib(normalizedLocale, null);\n             patterns = (Map<String, Object>) new JSONParser().parse(patternStr);", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MTYwMA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466771600", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n          \n          \n            \n                        logger.error(ConstantsMsg.GET_LANGUAGES_FAILED_ALL);", "author": "Xiaochao8", "createdAt": "2020-08-07T01:31:22Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -116,11 +124,14 @@ public LocaleService(LocaleDTO dto) {\n \n     private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext())\n+        if (!msgSourceQueueIter.hasNext()) {\n+            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MjAzOQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466772039", "bodyText": "Suggest log in this way. FromatUtils is heavy and unnecessary.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));\n          \n          \n            \n                        logger.debug(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource);", "author": "Xiaochao8", "createdAt": "2020-08-07T01:32:57Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -116,11 +124,14 @@ public LocaleService(LocaleDTO dto) {\n \n     private Map<String, String> getSupportedLanguagesFromDS(String locale, ListIterator<DataSourceEnum> msgSourceQueueIter) {\n         Map<String, String> dispMap = new HashMap<String, String>();\n-        if (!msgSourceQueueIter.hasNext())\n+        if (!msgSourceQueueIter.hasNext()) {\n+            logger.error(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED_ALL));\n             return dispMap;\n+        }\n         DataSourceEnum dataSource = (DataSourceEnum) msgSourceQueueIter.next();\n         dispMap = dataSource.createLocaleOpt(dto).getSupportedLanguages(locale);\n         if (dispMap == null || dispMap.isEmpty()) {\n+            logger.debug(FormatUtils.format(ConstantsMsg.GET_LANGUAGES_FAILED, dataSource.toString()));", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MzMyMQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466773321", "bodyText": "It's sure that component and locale are normalized. Don't need to do further procession.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),\n          \n          \n            \n                                MessagesDTO msgDTO = new MessagesDTO(component, languageTag, dto.getProductID(), dto.getVersion());", "author": "Xiaochao8", "createdAt": "2020-08-07T01:37:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -37,10 +36,9 @@ public ProductService(BaseDTO dto) {\n      */\n     public List<Map> getAllComponentTranslation() {\n         List<Map> list = new ArrayList<Map>();\n-        LocaleDTO localeDTO = new LocaleDTO();\n-        List<String> locales = this.getSupportedLocales(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        List<String> components = this.getComponents(VIPCfg.getInstance().getMsgOriginsQueue().iterator());\n-        if (locales != null) {\n+        List<String> locales = this.getSupportedLocales();\n+        List<String> components = this.getComponents();\n+        if (locales != null && components != null) {\n             for (String languageTag : locales) {\n                 for (Object component : components) {\n                     MessagesDTO msgDTO = new MessagesDTO(((String) component).trim(), LocaleUtility.fmtToMappedLocale(Locale.forLanguageTag(languageTag)).toString().trim(),", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNTk0Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466935942", "bodyText": "Don't make this change as this is L3 code and not sure whether there will be error or not if don't do such process.", "author": "huihuiw01", "createdAt": "2020-08-07T09:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MzMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NTg1Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466775857", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (locales.isEmpty()) {\n          \n          \n            \n                        if (locales==null || locales.isEmpty()) {", "author": "Xiaochao8", "createdAt": "2020-08-07T01:47:42Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -84,23 +76,18 @@ public ProductService(BaseDTO dto) {\n     /**\n      * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n      *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n      * @return list of locales of the product specified in the dto object\n      */\n-    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext()) { return null; }\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> locales = opt.getSupportedLocales();\n-        // If failed to get components from the data source\n-        if (locales.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                locales = getSupportedLocales(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n+    public List<String> getSupportedLocales(){\n+        List<String> locales = null;\n+        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n+        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n+            DataSourceEnum dataSource = msgSourceQueueIter.next();\n+            ProductOpt opt = dataSource.createProductOpt(dto);\n+            locales = opt.getSupportedLocales();\n+            // If failed to get locales from the data source, log the error.\n+            if (locales.isEmpty()) {", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNDkxOA==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466934918", "bodyText": "Actually \u2018locales\u2019 won't be null as opt.getSupportedLocales() method new ArrayList and won't return null.", "author": "huihuiw01", "createdAt": "2020-08-07T09:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NTg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NjAxMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r466776013", "bodyText": "FormatUtils.format is heavy and unnecessary.", "author": "Xiaochao8", "createdAt": "2020-08-07T01:48:23Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/ProductService.java", "diffHunk": "@@ -84,23 +76,18 @@ public ProductService(BaseDTO dto) {\n     /**\n      * Retrieves the list of locales of a product. It recursively applies data source fallback mechanism in case of failure.\n      *\n-     * @param msgSourceQueueIter Iterator of DataSourceEnum sources\n      * @return list of locales of the product specified in the dto object\n      */\n-    public List<String> getSupportedLocales(Iterator<DataSourceEnum> msgSourceQueueIter) {\n-        if (!msgSourceQueueIter.hasNext()) { return null; }\n-\n-        DataSourceEnum dataSource = msgSourceQueueIter.next();\n-        ProductOpt opt = dataSource.createProductOpt(dto);\n-        List<String> locales = opt.getSupportedLocales();\n-        // If failed to get components from the data source\n-        if (locales.isEmpty()) {\n-            // Try the next dataSource in the queue\n-            if (msgSourceQueueIter.hasNext()) {\n-                locales = getSupportedLocales(msgSourceQueueIter);\n-                // If no more data source in queue, log the error. This means that neither online nor offline fetch succeeded.\n-            } else {\n-                logger.error(FormatUtils.format(ConstantsMsg.GET_COMPONENTS_FAILED, dataSource.toString()));\n+    public List<String> getSupportedLocales(){\n+        List<String> locales = null;\n+        Iterator<DataSourceEnum> msgSourceQueueIter = VIPCfg.getInstance().getMsgOriginsQueue().iterator();\n+        while((locales == null || locales.isEmpty()) && msgSourceQueueIter.hasNext()){\n+            DataSourceEnum dataSource = msgSourceQueueIter.next();\n+            ProductOpt opt = dataSource.createProductOpt(dto);\n+            locales = opt.getSupportedLocales();\n+            // If failed to get locales from the data source, log the error.\n+            if (locales.isEmpty()) {\n+                logger.error(FormatUtils.format(ConstantsMsg.GET_LOCALES_FAILED, dataSource.toString()));", "originalCommit": "0ebee3aab4b547bde70582d77fc3030fef97f3cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNTMyNw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r467535327", "bodyText": "This logic is scattered across multiple files. It's redundant and error-prone. It's better to merge this kind of logic into one.", "author": "Xiaochao8", "createdAt": "2020-08-09T04:39:55Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/service/LocaleService.java", "diffHunk": "@@ -4,179 +4,146 @@\n  */\n package com.vmware.vipclient.i18n.messages.service;\n \n-import java.util.*;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.FutureTask;\n-\n import com.vmware.vipclient.i18n.VIPCfg;\n import com.vmware.vipclient.i18n.base.DataSourceEnum;\n-import com.vmware.vipclient.i18n.base.cache.Cache;\n-import com.vmware.vipclient.i18n.base.cache.FormatCacheItem;\n import com.vmware.vipclient.i18n.common.ConstantsMsg;\n-import com.vmware.vipclient.i18n.messages.api.opt.server.RemoteLocaleOpt;\n import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n-import com.vmware.vipclient.i18n.util.FormatUtils;\n-import com.vmware.vipclient.i18n.util.JSONUtils;\n import com.vmware.vipclient.i18n.util.LocaleUtility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n public class LocaleService {\n-    Logger logger = LoggerFactory.getLogger(LocaleService.class.getName());\n-    private static final String REGION_PREFIX = \"region_\";\n-    public static final String DISPN_PREFIX  = \"dispn_\";\n-    private LocaleDTO dto;\n \n-    public LocaleService() {\n+    Logger                      logger        = LoggerFactory.getLogger(LocaleService.class.getName());\n+    private LocaleDTO dto = null;\n \n+    public LocaleService() {\n     }\n+\n     public LocaleService(LocaleDTO dto) {\n         this.dto = dto;\n     }\n \n-    public Map<String, String> getSupportedLanguages() {\n-        return getSupportedLanguages(null, LocaleUtility.getFallbackLocales().iterator());\n+    public Map<String, String> getRegions(String locale){\n+        Map<String, String> regionMap = getRegionsByLocale(locale);\n+        if (regionMap != null) {\n+            return regionMap;\n+        }\n+        Iterator<Locale> fallbackLocalesIter = LocaleUtility.getFallbackLocales().iterator();\n+        while (fallbackLocalesIter.hasNext()) {", "originalCommit": "fe81284c2dea1187a885e048eb8579f253958bac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "url": "https://github.com/vmware/singleton/commit/4043b9937b6c4e9dbca2b87f275dd08bdbffde81", "message": "add L2 pattern files and make some change to support loading them correctly", "committedDate": "2020-08-18T13:49:59Z", "type": "commit"}, {"oid": "d6b11b3add639da4e746fa8aab2e215e12bbb9e8", "url": "https://github.com/vmware/singleton/commit/d6b11b3add639da4e746fa8aab2e215e12bbb9e8", "message": "On offline mode read pattern data from separate jar", "committedDate": "2020-08-18T13:55:34Z", "type": "commit"}, {"oid": "f82003b26bbb7739f9d354f3a2b8bd1ce0db5542", "url": "https://github.com/vmware/singleton/commit/f82003b26bbb7739f9d354f3a2b8bd1ce0db5542", "message": "Optimize get pattern code & add unit tests for offline mode", "committedDate": "2020-08-18T13:58:08Z", "type": "commit"}, {"oid": "d5790aec436d38628b0d086ef92979d76561a24e", "url": "https://github.com/vmware/singleton/commit/d5790aec436d38628b0d086ef92979d76561a24e", "message": "Enable offline mode support for getSupportedLanguages and getRegionList API", "committedDate": "2020-08-18T13:59:09Z", "type": "commit"}, {"oid": "231bd39c4326128f71deda96d99aff5dbbc2f708", "url": "https://github.com/vmware/singleton/commit/231bd39c4326128f71deda96d99aff5dbbc2f708", "message": "Adjust L2 API according to new workflow", "committedDate": "2020-08-18T14:01:11Z", "type": "commit"}, {"oid": "671b3fceff372567e10cb93b88f5f47d6a6bf953", "url": "https://github.com/vmware/singleton/commit/671b3fceff372567e10cb93b88f5f47d6a6bf953", "message": "fix review comments: mainly move fallback logic to outer layer and other minor comments", "committedDate": "2020-08-18T14:01:40Z", "type": "commit"}, {"oid": "b59a7cdcfc78a84c5823bbd141b5ce20eca1c795", "url": "https://github.com/vmware/singleton/commit/b59a7cdcfc78a84c5823bbd141b5ce20eca1c795", "message": "Change supportedLanguage API to support multiple configurations", "committedDate": "2020-08-18T14:03:10Z", "type": "commit"}, {"oid": "cd5289331ed321a95336669f593f7f8c9bd7a0de", "url": "https://github.com/vmware/singleton/commit/cd5289331ed321a95336669f593f7f8c9bd7a0de", "message": "fix CI reported issue: add license and copyright header for new added files", "committedDate": "2020-08-18T14:05:19Z", "type": "commit"}, {"oid": "8896f73098e8569649033d9095c7e0054a3fe1f7", "url": "https://github.com/vmware/singleton/commit/8896f73098e8569649033d9095c7e0054a3fe1f7", "message": "fix review comments: move fallback logic to service layer", "committedDate": "2020-08-18T14:05:45Z", "type": "commit"}, {"oid": "e47bb729b3571dc516310a71dcd4ab702c9300e5", "url": "https://github.com/vmware/singleton/commit/e47bb729b3571dc516310a71dcd4ab702c9300e5", "message": "fix review comment: use LocaleDTO instead of BaseDTO as data transfer object for parameter scalability", "committedDate": "2020-08-18T14:06:22Z", "type": "commit"}, {"oid": "b19fc1f37d93876786f30b64927983aaeb0d59bf", "url": "https://github.com/vmware/singleton/commit/b19fc1f37d93876786f30b64927983aaeb0d59bf", "message": "fix some minor review comments", "committedDate": "2020-08-18T14:06:41Z", "type": "commit"}, {"oid": "9246c42b1d99ae1c44651be6084f38619328d4ad", "url": "https://github.com/vmware/singleton/commit/9246c42b1d99ae1c44651be6084f38619328d4ad", "message": "fix NullPointerException in DateFormatting when default locale's pattern is not available", "committedDate": "2020-08-18T14:08:10Z", "type": "commit"}, {"oid": "1737b297212b80a5d0440dd03c441e1f7dda7183", "url": "https://github.com/vmware/singleton/commit/1737b297212b80a5d0440dd03c441e1f7dda7183", "message": "fix unit tests failure problems reported in CI", "committedDate": "2020-08-18T14:08:45Z", "type": "commit"}, {"oid": "966e4886deaa8cbc1ee4925eb8b57f836d9d2970", "url": "https://github.com/vmware/singleton/commit/966e4886deaa8cbc1ee4925eb8b57f836d9d2970", "message": "fix CI failure problem: add license header for sample-client-app/build.gradle", "committedDate": "2020-08-19T06:34:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3MDQyMg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473170422", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void getComponents(Path path, List<String> components) throws IOException {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> p.toFile().isDirectory())) {\n          \n          \n            \n                        listOfFiles.map(file -> {\n          \n          \n            \n                            return file.getFileName().toString();\n          \n          \n            \n                        }).forEach(component -> {\n          \n          \n            \n                            if(component != null && !component.isEmpty()) {\n          \n          \n            \n                                components.add(component);\n          \n          \n            \n                            }\n          \n          \n            \n                        });\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            }\n          \n          \n            \n                private void getComponents(Path path, List<String> components) throws IOException {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.list(path).filter(p -> !Files.isRegularFile(p))) {\n          \n          \n            \n                        listOfFiles.forEach(s -> components.add(s.getFileName().toString()));\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-19T16:38:33Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.local;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class LocalProductOpt implements ProductOpt {\n+    private Logger logger = LoggerFactory.getLogger(LocalProductOpt.class);\n+    private static final String BUNDLE_PREFIX = \"messages_\";\n+    private static final String BUNDLE_SUFFIX = \".json\";\n+\n+    private BaseDTO dto = null;\n+\n+    public LocalProductOpt(BaseDTO dto) {\n+        this.dto = dto;\n+    }\n+\n+    public List<String> getSupportedLocales() {\n+        List<String> supportedLocales = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getSupportedLocales(path, supportedLocales);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getSupportedLocales(path, supportedLocales);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return supportedLocales;\n+    }\n+\n+    public List<String> getComponents() {\n+        List<String> components = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getComponents(path, components);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getComponents(path, components);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return components;\n+    }\n+\n+    private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n+            listOfFiles.map(file -> {\n+                String fileName = file.getFileName().toString();\n+                if(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+                    return fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+                }\n+                return \"\";\n+            }).forEach(language -> {\n+                if(language != null && !language.isEmpty()) {\n+                    supportedLocales.add(language);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void getComponents(Path path, List<String> components) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> p.toFile().isDirectory())) {\n+            listOfFiles.map(file -> {\n+                return file.getFileName().toString();\n+            }).forEach(component -> {\n+                if(component != null && !component.isEmpty()) {\n+                    components.add(component);\n+                }\n+            });\n+        }\n+    }\n+}", "originalCommit": "966e4886deaa8cbc1ee4925eb8b57f836d9d2970", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3NTY0Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473175647", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n          \n          \n            \n                        listOfFiles.map(file -> {\n          \n          \n            \n                            String fileName = file.getFileName().toString();\n          \n          \n            \n                            if(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n          \n          \n            \n                                return fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n          \n          \n            \n                            }\n          \n          \n            \n                            return \"\";\n          \n          \n            \n                        }).forEach(language -> {\n          \n          \n            \n                            if(language != null && !language.isEmpty()) {\n          \n          \n            \n                                supportedLocales.add(language);\n          \n          \n            \n                            }\n          \n          \n            \n                        });\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p) && p.getFileName().toString().startsWith(BUNDLE_PREFIX) && p.getFileName().toString().endsWith(BUNDLE_SUFFIX))) {\n          \n          \n            \n                        listOfFiles.map(file -> {\n          \n          \n            \n                            return file.getFileName().toString().substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n          \n          \n            \n                        }).forEach(language -> {\n          \n          \n            \n                            supportedLocales.add(language);\n          \n          \n            \n                        });\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "jessiejuachon", "createdAt": "2020-08-19T16:47:20Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.local;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class LocalProductOpt implements ProductOpt {\n+    private Logger logger = LoggerFactory.getLogger(LocalProductOpt.class);\n+    private static final String BUNDLE_PREFIX = \"messages_\";\n+    private static final String BUNDLE_SUFFIX = \".json\";\n+\n+    private BaseDTO dto = null;\n+\n+    public LocalProductOpt(BaseDTO dto) {\n+        this.dto = dto;\n+    }\n+\n+    public List<String> getSupportedLocales() {\n+        List<String> supportedLocales = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getSupportedLocales(path, supportedLocales);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getSupportedLocales(path, supportedLocales);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return supportedLocales;\n+    }\n+\n+    public List<String> getComponents() {\n+        List<String> components = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getComponents(path, components);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getComponents(path, components);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return components;\n+    }\n+\n+    private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n+            listOfFiles.map(file -> {\n+                String fileName = file.getFileName().toString();\n+                if(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+                    return fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+                }\n+                return \"\";\n+            }).forEach(language -> {\n+                if(language != null && !language.isEmpty()) {\n+                    supportedLocales.add(language);\n+                }\n+            });\n+        }\n+    }", "originalCommit": "966e4886deaa8cbc1ee4925eb8b57f836d9d2970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU3OTE4Mg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473579182", "bodyText": "These two conditions are for filtering file name, not for filter path,\nfileName.getFileName().startsWith(BUNDLE_PREFIX) && fileName.getFileName().endsWith(BUNDLE_SUFFIX)\nor locale list will be empty because no path meet these conditions.", "author": "huihuiw01", "createdAt": "2020-08-20T04:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3NTY0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1NjAzNg==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r474156036", "bodyText": "I made a mistake of not adding .toString() to p.getFileName(). I have updated the code suggestion.\nFiles.walk will iterate over ALL paths -- all folders AND files inside the root path and  the root path itself. So yes, it will apply to files as well.  The .filter part will check if each item is a file (not a folder) that starts with BUNDLE_PREFIX and ends with BUNDLE_SUFFIX. If one of these conditions fail, the item will not be included in listOfFiles. This way, you do not need the if statement.\nYou also do not need to return an empty String so that you can remove if(language != null && !language.isEmpty())\nTest the code suggestion above and see if it works. I have tested it and seems to be no problem.", "author": "jessiejuachon", "createdAt": "2020-08-20T17:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3NTY0Nw=="}], "type": "inlineReview"}, {"oid": "3b7d7ab9d9cc4fdf4fbdba0051adee87c837af2f", "url": "https://github.com/vmware/singleton/commit/3b7d7ab9d9cc4fdf4fbdba0051adee87c837af2f", "message": "Merge branch 'g11n-java-client' of https://github.com/vmware/singleton into g11n-java-client_addPatternFiles", "committedDate": "2020-08-19T17:13:50Z", "type": "commit"}, {"oid": "98ae1b411ebd4b2abe1c9bd5295a80b2dcf7c77b", "url": "https://github.com/vmware/singleton/commit/98ae1b411ebd4b2abe1c9bd5295a80b2dcf7c77b", "message": "Comment out the failed unit test", "committedDate": "2020-08-19T17:16:17Z", "type": "commit"}, {"oid": "c93e4a5953d5ab216bb2cca73ffad6cadac56d56", "url": "https://github.com/vmware/singleton/commit/c93e4a5953d5ab216bb2cca73ffad6cadac56d56", "message": "fix bugs reported in CI code scan", "committedDate": "2020-08-19T17:17:28Z", "type": "commit"}, {"oid": "1a3a60154b4acbd1da1ed0fafa4b76491a4f6671", "url": "https://github.com/vmware/singleton/commit/1a3a60154b4acbd1da1ed0fafa4b76491a4f6671", "message": "fix unit test failures", "committedDate": "2020-08-19T17:18:30Z", "type": "commit"}, {"oid": "aa05d390658d0a34dd9f40cc4d16e2e1ee8a3270", "url": "https://github.com/vmware/singleton/commit/aa05d390658d0a34dd9f40cc4d16e2e1ee8a3270", "message": "resolve the failed unit test which is commented out earlier", "committedDate": "2020-08-19T17:20:16Z", "type": "commit"}, {"oid": "a99124825d99b1d0106e00baddc768ac63784f54", "url": "https://github.com/vmware/singleton/commit/a99124825d99b1d0106e00baddc768ac63784f54", "message": "fix NullPointerException in NumberFormatService when no pattern data found", "committedDate": "2020-08-19T17:21:40Z", "type": "commit"}, {"oid": "c6e55dadaf7646faf5a16245b0a53680af16ec6d", "url": "https://github.com/vmware/singleton/commit/c6e55dadaf7646faf5a16245b0a53680af16ec6d", "message": "fix review comment: add failed log", "committedDate": "2020-08-19T17:23:09Z", "type": "commit"}, {"oid": "62c4d18380fa82f27e134fe9e4ce3229b3b382ad", "url": "https://github.com/vmware/singleton/commit/62c4d18380fa82f27e134fe9e4ce3229b3b382ad", "message": "fix review comments", "committedDate": "2020-08-19T17:23:54Z", "type": "commit"}, {"oid": "5b94af00b5bb68c2dec3ea766faf3c754473b182", "url": "https://github.com/vmware/singleton/commit/5b94af00b5bb68c2dec3ea766faf3c754473b182", "message": "fix some minor review comments", "committedDate": "2020-08-19T17:27:18Z", "type": "commit"}, {"oid": "e2348d4319ce569fffd95f51cf0f837bd7bbcdd6", "url": "https://github.com/vmware/singleton/commit/e2348d4319ce569fffd95f51cf0f837bd7bbcdd6", "message": "fix review comment: use fallback iterator instead of default locale when do fallback", "committedDate": "2020-08-19T17:28:10Z", "type": "commit"}, {"oid": "cac8e89f782d2c9655aaf97a08c7678fe73a2cca", "url": "https://github.com/vmware/singleton/commit/cac8e89f782d2c9655aaf97a08c7678fe73a2cca", "message": "Correct one error message", "committedDate": "2020-08-19T17:29:04Z", "type": "commit"}, {"oid": "2a0fb4bf89cff86f7da727d8fe95029b3edac3c9", "url": "https://github.com/vmware/singleton/commit/2a0fb4bf89cff86f7da727d8fe95029b3edac3c9", "message": "resolve problem which leads to sample-app smoke test failure", "committedDate": "2020-08-19T17:30:04Z", "type": "commit"}, {"oid": "b24297d64dc07954534384fc70bb4e400cccc86c", "url": "https://github.com/vmware/singleton/commit/b24297d64dc07954534384fc70bb4e400cccc86c", "message": "fetch pattern jar package from mavenCentral", "committedDate": "2020-08-19T17:33:39Z", "type": "commit"}, {"oid": "2f2c76ef824d424ef3888589166265937643edc2", "url": "https://github.com/vmware/singleton/commit/2f2c76ef824d424ef3888589166265937643edc2", "message": "fix CI failure problem: add license header for sample-client-app/build.gradle", "committedDate": "2020-08-19T17:34:11Z", "type": "commit"}, {"oid": "2f2c76ef824d424ef3888589166265937643edc2", "url": "https://github.com/vmware/singleton/commit/2f2c76ef824d424ef3888589166265937643edc2", "message": "fix CI failure problem: add license header for sample-client-app/build.gradle", "committedDate": "2020-08-19T17:34:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQ4MDgzNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473480835", "bodyText": "There are 2 GET_LOCALES_FAILED. This must have caused a compile error, right?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String GET_LOCALES_FAILED   = \"Failed to get list of locales from {0} data source\";", "author": "jessiejuachon", "createdAt": "2020-08-20T00:41:54Z", "path": "src/main/java/com/vmware/vipclient/i18n/common/ConstantsMsg.java", "diffHunk": "@@ -17,5 +17,9 @@\n     public static final String GET_MESSAGE_FAILED   = \"Failed to get any message for key: {0} of component {1}, requested locale: {2}\";\r\n     public static final String GET_LANGUAGES_FAILED   = \"Failed to get supported languages from {0} data source\";\r\n     public static final String GET_LANGUAGES_FAILED_ALL   = \"Failed to get supported languages from any data source\";\r\n+    public static final String GET_REGIONS_FAILED   = \"Failed to get regions from {0} data source\";\r\n+    public static final String GET_REGIONS_FAILED_ALL   = \"Failed to get regions from any data source\";\r\n+    public static final String GET_LOCALES_FAILED   = \"Failed to get list of locales from {0} data source\";\r\n     public static final String GET_COMPONENTS_FAILED   = \"Failed to get list of components from {0} data source\";\r\n+    public static final String GET_LOCALES_FAILED   = \"Failed to get list of locales from {0} data source\";\r", "originalCommit": "2f2c76ef824d424ef3888589166265937643edc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUwOTMxNQ==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r473509315", "bodyText": "Can this be removed since it is commented out?", "author": "jessiejuachon", "createdAt": "2020-08-20T01:26:22Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalLocaleOpt.java", "diffHunk": "@@ -4,65 +4,122 @@\n  */\n package com.vmware.vipclient.i18n.messages.api.opt.local;\n \n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.stream.Stream;\n-\n+import com.vmware.i18n.PatternUtil;\n+import com.vmware.i18n.utils.CommonUtil;\n+import com.vmware.vipclient.i18n.base.DataSourceEnum;\n+import com.vmware.vipclient.i18n.l2.common.PatternKeys;\n+import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import com.vmware.vipclient.i18n.messages.dto.LocaleDTO;\n+import com.vmware.vipclient.i18n.messages.service.FormattingCacheService;\n+import com.vmware.vipclient.i18n.util.ConstantsKeys;\n+import org.json.simple.JSONObject;\n+import org.json.simple.parser.JSONParser;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.vmware.vipclient.i18n.VIPCfg;\n-import com.vmware.vipclient.i18n.messages.api.opt.LocaleOpt;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localeAliasesMap;\n+import static com.vmware.i18n.pattern.service.impl.PatternServiceImpl.localePathMap;\n \n public class LocalLocaleOpt implements LocaleOpt{\n \n     private Logger logger = LoggerFactory.getLogger(LocalLocaleOpt.class);\n     private static final String BUNDLE_PREFIX = \"messages_\";\n-    \n-    @Override\n-    public Map<String, String> getSupportedLanguages(String displayLanguage) {\n-   \n-    \tMap<String, String> supportedLocales = new HashMap<String, String>();\n-\t\ttry {\n-\t\t\t\n-\t\t\tPath path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n-\t\t\t\n-\t\t\tURI uri = Thread.currentThread().getContextClassLoader().\n-\t\t\t\t\tgetResource(path.toString()).toURI();\n+\tprivate static final String BUNDLE_SUFFIX = \".json\";\n+\n+\tprivate LocaleDTO dto = null;\n \n-\t    \tif (uri.getScheme().equals(\"jar\")) {\n-\t    \t\ttry (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n-\t    \t\t\tpath = fileSystem.getPath(path.toString());\n-\t    \t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n-\t    \t\t}\n-\t\t\t} else {\n-\t\t\t\tpath = Paths.get(uri);\n-\t\t\t\tgetSupportedLocales(path, supportedLocales, displayLanguage);\n+\tpublic LocalLocaleOpt(LocaleDTO dto) {\n+\t\tthis.dto = dto;\n+\t}\n+\n+\t@Override\n+    public Map<String, String> getSupportedLanguages(String locale) {\n+\t\tMap<String, String> supportedLanguageNames = new HashMap<String, String>();\n+\t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n+\t\t\t\t.getSupportedLocales();\n+\t\tif(supportedLanguages != null && !supportedLanguages.isEmpty()) {\n+\t\t\tMap<String, String> languagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\t\tif (languagesNames == null || languagesNames.isEmpty())\n+\t\t\t\treturn supportedLanguageNames;\n+\t\t\tfor(String language : supportedLanguages){\n+\t\t\t\tif(!ConstantsKeys.SOURCE.equalsIgnoreCase(language))\n+\t\t\t\t\tsupportedLanguageNames.put(language, (String) languagesNames.get(language));\n \t\t\t}\n-\t    \t\n-\t\t} catch (Exception e) {\n-\t\t\tlogger.debug(e.getMessage());\n \t\t}\n-    \treturn supportedLocales;\n-    }\n-    \n-    private void getSupportedLocales(Path path, Map<String, String> supportedLocales, String displayLanguage) throws IOException {\n-    \tLocale inLocale = Locale.forLanguageTag(displayLanguage); \n-    \ttry (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n-        \tlistOfFiles.map(file -> {\n-\t\t\t\tString fileName = file.getFileName().toString();\n-\t\t\t\treturn fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n-\t\t\t}).forEach(s->supportedLocales.put(s, Locale.forLanguageTag(s).getDisplayName(inLocale)));\n-        }\n+\t\treturn supportedLanguageNames;\n     }\n \n+\t/*private Map<String, String> getLanguagesNames(String locale){\n+\t\tMap<String, String> languagesNames = null;\n+\t\tlanguagesNames = getLanguagesNamesFromCLDR(locale);\n+\t\tif (languagesNames != null) {\n+\t\t\treturn languagesNames;\n+\t\t}\n+\t\tif (!LocaleUtility.isDefaultLocale(locale)) {\n+\t\t\tlogger.info(\"Can't find languages' names for locale [{}], look for English regions as fallback!\", locale);\n+\t\t\tlanguagesNames = getLanguagesNamesFromCLDR(LocaleUtility.getDefaultLocale().toLanguageTag());\n+\t\t\tif (languagesNames != null) {\n+\t\t\t\tnew FormattingCacheService().addLanguagesNames(locale, languagesNames);\n+\t\t\t\tlogger.debug(\"Default locale's languages' names is cached for locale [{}]!\\n\\n\", locale);\n+\t\t\t}\n+\t\t}\n+\t\treturn languagesNames;\n+\t}*/", "originalCommit": "2f2c76ef824d424ef3888589166265937643edc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ae7c31aae3f5a7a42caad5bff413edf1499d57a5", "url": "https://github.com/vmware/singleton/commit/ae7c31aae3f5a7a42caad5bff413edf1499d57a5", "message": "Fixing failing CI", "committedDate": "2020-08-20T01:32:24Z", "type": "commit"}, {"oid": "6e9d8ea1dc9790b297339f0a2c25824b5e38287e", "url": "https://github.com/vmware/singleton/commit/6e9d8ea1dc9790b297339f0a2c25824b5e38287e", "message": "fix review comments", "committedDate": "2020-08-20T04:07:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5MzEwMw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r471893103", "bodyText": "Use arguments instead of a concatenation.", "author": "Xiaochao8", "createdAt": "2020-08-18T03:31:23Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalMessagesOpt.java", "diffHunk": "@@ -78,6 +78,7 @@ public void getComponentMessages(MessageCacheItem cacheItem) {\n     private List<Locale> getSupportedLocales() {\n \t\tList<String> supportedLanguages = DataSourceEnum.Bundle.createProductOpt(dto)\n     \t\t\t.getSupportedLocales();\n+        logger.debug(\"supported languages: \"+supportedLanguages.toString());", "originalCommit": "f114f0f559367dd7cc4ee9ca3150dd689f767dee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9a91587ec36dc64cb607d2a1aff0e6a6c6ab66f1", "url": "https://github.com/vmware/singleton/commit/9a91587ec36dc64cb607d2a1aff0e6a6c6ab66f1", "message": "fix review comment: optimize one log", "committedDate": "2020-08-20T08:06:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1Njc4Nw==", "url": "https://github.com/vmware/singleton/pull/629#discussion_r474156787", "bodyText": "Use Files.list here because Files.walk iterates recursively which we do not need here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> !Files.isRegularFile(p))) {\n          \n          \n            \n                    try (Stream<Path> listOfFiles = Files.list(path).filter(p -> !Files.isRegularFile(p))) {", "author": "jessiejuachon", "createdAt": "2020-08-20T17:31:50Z", "path": "src/main/java/com/vmware/vipclient/i18n/messages/api/opt/local/LocalProductOpt.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019 VMware, Inc.\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package com.vmware.vipclient.i18n.messages.api.opt.local;\n+\n+import com.vmware.vipclient.i18n.VIPCfg;\n+import com.vmware.vipclient.i18n.messages.api.opt.ProductOpt;\n+import com.vmware.vipclient.i18n.messages.dto.BaseDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class LocalProductOpt implements ProductOpt {\n+    private Logger logger = LoggerFactory.getLogger(LocalProductOpt.class);\n+    private static final String BUNDLE_PREFIX = \"messages_\";\n+    private static final String BUNDLE_SUFFIX = \".json\";\n+\n+    private BaseDTO dto = null;\n+\n+    public LocalProductOpt(BaseDTO dto) {\n+        this.dto = dto;\n+    }\n+\n+    public List<String> getSupportedLocales() {\n+        List<String> supportedLocales = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getSupportedLocales(path, supportedLocales);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getSupportedLocales(path, supportedLocales);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return supportedLocales;\n+    }\n+\n+    public List<String> getComponents() {\n+        List<String> components = new ArrayList<String>();\n+        try {\n+\n+            Path path = Paths.get(VIPCfg.getInstance().getOfflineResourcesBaseUrl());\n+\n+            URI uri = Thread.currentThread().getContextClassLoader().\n+                    getResource(path.toString()).toURI();\n+\n+            if (uri.getScheme().equals(\"jar\")) {\n+                try (FileSystem fileSystem = FileSystems.newFileSystem(uri, Collections.<String, Object>emptyMap())) {\n+                    path = fileSystem.getPath(path.toString());\n+                    getComponents(path, components);\n+                }\n+            } else {\n+                path = Paths.get(uri);\n+                getComponents(path, components);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(e.getMessage());\n+        }\n+        return components;\n+    }\n+\n+    private void getSupportedLocales(Path path, List<String> supportedLocales) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> Files.isRegularFile(p))) {\n+            listOfFiles.map(file -> {\n+                String fileName = file.getFileName().toString();\n+                if(fileName.startsWith(BUNDLE_PREFIX) && fileName.endsWith(BUNDLE_SUFFIX)) {\n+                    return fileName.substring(BUNDLE_PREFIX.length(), fileName.indexOf('.'));\n+                }\n+                return \"\";\n+            }).forEach(language -> {\n+                if(language != null && !language.isEmpty()) {\n+                    supportedLocales.add(language);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void getComponents(Path path, List<String> components) throws IOException {\n+        try (Stream<Path> listOfFiles = Files.walk(path).filter(p -> !Files.isRegularFile(p))) {", "originalCommit": "9a91587ec36dc64cb607d2a1aff0e6a6c6ab66f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e4b755a1287b032521b8217613c348e74a8e902", "url": "https://github.com/vmware/singleton/commit/9e4b755a1287b032521b8217613c348e74a8e902", "message": "Use Files.list which is non-recursive when getting offline component list", "committedDate": "2020-08-20T17:52:42Z", "type": "commit"}, {"oid": "fa86a44140e1c1ba395f449ad7abac3af7f8f1c4", "url": "https://github.com/vmware/singleton/commit/fa86a44140e1c1ba395f449ad7abac3af7f8f1c4", "message": "fix review comment: optimize code for getting supported locales", "committedDate": "2020-08-21T01:26:45Z", "type": "commit"}, {"oid": "c95636a9bad9af9fb5eea483d4e92dc133e58dbd", "url": "https://github.com/vmware/singleton/commit/c95636a9bad9af9fb5eea483d4e92dc133e58dbd", "message": "Merge branch 'g11n-java-client' of https://github.com/vmware/singleton into g11n-java-client_addPatternFiles", "committedDate": "2020-08-21T01:35:17Z", "type": "commit"}]}