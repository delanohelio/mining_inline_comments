{"pr_number": 2335, "pr_title": "[RESTEASY-2531] expanded and refactored chapter", "pr_createdAt": "2020-03-25T15:16:21Z", "pr_url": "https://github.com/resteasy/resteasy/pull/2335", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc3MDgwOA==", "url": "https://github.com/resteasy/resteasy/pull/2335#discussion_r413770808", "bodyText": "small typo, s/mulitpart/multipart/", "author": "asoldano", "createdAt": "2020-04-23T12:25:15Z", "path": "docbook/reference/en/en-US/modules/Multipart.xml", "diffHunk": "@@ -101,468 +185,836 @@ public interface InputPart {\n    boolean isContentTypeFromMessage();\n \n    /**\n-    * Change the media type of the body part before you extract it.  Useful for specifying a charset.\n-    *\n+    * Change the media type of the body part before you extract it.\n+    * Useful for specifying a charset.\n     * @param mediaType media type\n     */\n    void setMediaType(MediaType mediaType);\n }}]]></programlisting>\n-        <para>\n-            Each part has a set of headers associated with it.\n-            You can unmarshall the part by calling one of the getBody() methods. The Type genericType parameter can be\n-            null,\n-            but the Class type parameter must be set. RESTEasy will find a MessageBodyReader based on the media type\n-            of the part as well as the type information you pass in. The following piece of code is unmarshalling\n-            parts which are XML into a JAXB annotated class called Customer:\n-        </para>\n-        <programlisting><![CDATA[@Path(\"/multipart\")\n-public class MyService\n-{\n-    @PUT\n-    @Consumes(\"multipart/mixed\")\n-    public void put(MultipartInput input)\n-    {\n-        List<Customer> customers = new ArrayList...;\n-        for (InputPart part : input.getParts())\n-        {\n-            Customer cust = part.getBody(Customer.class, null);\n-            customers.add(cust);\n-        }\n-        input.close();\n-    }\n-}]]></programlisting>\n-        <para>\n-            Sometimes you may want to unmarshall a body part that is sensitive to generic type metadata. In this case\n-            you can use the org.jboss.resteasy.util.GenericType class. Here's an example of unmarshalling a type that\n-            is sensitive to generic type metadata:\n-        </para>\n-        <programlisting><![CDATA[@Path(\"/multipart\")\n-public class MyService\n-{\n-    @PUT\n-    @Consumes(\"multipart/mixed\")\n-    public void put(MultipartInput input)\n-    {\n-        for (InputPart part : input.getParts())\n-        {\n-            List<Customer> cust = part.getBody(new GenericType<List<Customer>>() {});\n-        }\n-        input.close();\n-    }\n-}]]></programlisting>\n-        <para>\n-            Use of GenericType is required because it is really the only way to obtain generic type information at\n-            runtime.\n-        </para>\n-    </section>\n-    <section id=\"multipart_list\">\n-        <title>java.util.List with multipart data</title>\n-        <para>If your body parts are uniform, you do not have to manually unmarshall each and every part.\n-            You can just provide a java.util.List as your input parameter. It must have the type it is\n-            unmarshalling with the generic parameter of the List type declaration. Here's an example again\n-            of unmarshalling a list of customers:\n-        </para>\n-        <programlisting><![CDATA[\n-@Path(\"/multipart\")\n-public class MyService\n-{\n-    @PUT\n-    @Consumes(\"multipart/mixed\")\n-    public void put(List<Customer> customers)\n-    {\n-        ...\n-    }\n-}]]></programlisting>\n-        The above example will accept the multipart data of a list of customers, and unmarshall them correctly.\n-    </section>\n-    <section id=\"MultipartFormData\">\n-        <title>Input with multipart/form-data</title>\n-        <para>When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in\n-            multipart/form-data mime type. \"multipart/form-data\" is often found in web application HTML Form documents\n-            and is generally used to\n-            upload files. The form-data format is the same as other multipart formats, except that each inlined piece\n-            of content has a name associated with it. The interface used for form-data input is\n-            <code>MultipartFormDataInput</code>\n-        </para>\n-        <programlisting><![CDATA[package org.jboss.resteasy.plugins.providers.multipart;\n \n-import java.io.IOException;\n-import java.lang.reflect.Type;\n-import java.util.List;\n-import java.util.Map;\n+      </section>\n+\n+      <section id=\"Simple_mulitpart_message_example\">\n+         <title>Simple mulitpart/mixed message example</title>", "originalCommit": "053d2f95c9895915fdcdf9ef457cefe07d66b440", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc3MTcxNA==", "url": "https://github.com/resteasy/resteasy/pull/2335#discussion_r413771714", "bodyText": "typo again", "author": "asoldano", "createdAt": "2020-04-23T12:26:35Z", "path": "docbook/reference/en/en-US/modules/Multipart.xml", "diffHunk": "@@ -101,468 +185,836 @@ public interface InputPart {\n    boolean isContentTypeFromMessage();\n \n    /**\n-    * Change the media type of the body part before you extract it.  Useful for specifying a charset.\n-    *\n+    * Change the media type of the body part before you extract it.\n+    * Useful for specifying a charset.\n     * @param mediaType media type\n     */\n    void setMediaType(MediaType mediaType);\n }}]]></programlisting>\n-        <para>\n-            Each part has a set of headers associated with it.\n-            You can unmarshall the part by calling one of the getBody() methods. The Type genericType parameter can be\n-            null,\n-            but the Class type parameter must be set. RESTEasy will find a MessageBodyReader based on the media type\n-            of the part as well as the type information you pass in. The following piece of code is unmarshalling\n-            parts which are XML into a JAXB annotated class called Customer:\n-        </para>\n-        <programlisting><![CDATA[@Path(\"/multipart\")\n-public class MyService\n-{\n-    @PUT\n-    @Consumes(\"multipart/mixed\")\n-    public void put(MultipartInput input)\n-    {\n-        List<Customer> customers = new ArrayList...;\n-        for (InputPart part : input.getParts())\n-        {\n-            Customer cust = part.getBody(Customer.class, null);\n-            customers.add(cust);\n-        }\n-        input.close();\n-    }\n-}]]></programlisting>\n-        <para>\n-            Sometimes you may want to unmarshall a body part that is sensitive to generic type metadata. In this case\n-            you can use the org.jboss.resteasy.util.GenericType class. Here's an example of unmarshalling a type that\n-            is sensitive to generic type metadata:\n-        </para>\n-        <programlisting><![CDATA[@Path(\"/multipart\")\n-public class MyService\n-{\n-    @PUT\n-    @Consumes(\"multipart/mixed\")\n-    public void put(MultipartInput input)\n-    {\n-        for (InputPart part : input.getParts())\n-        {\n-            List<Customer> cust = part.getBody(new GenericType<List<Customer>>() {});\n-        }\n-        input.close();\n-    }\n-}]]></programlisting>\n-        <para>\n-            Use of GenericType is required because it is really the only way to obtain generic type information at\n-            runtime.\n-        </para>\n-    </section>\n-    <section id=\"multipart_list\">\n-        <title>java.util.List with multipart data</title>\n-        <para>If your body parts are uniform, you do not have to manually unmarshall each and every part.\n-            You can just provide a java.util.List as your input parameter. It must have the type it is\n-            unmarshalling with the generic parameter of the List type declaration. Here's an example again\n-            of unmarshalling a list of customers:\n-        </para>\n-        <programlisting><![CDATA[\n-@Path(\"/multipart\")\n-public class MyService\n-{\n-    @PUT\n-    @Consumes(\"multipart/mixed\")\n-    public void put(List<Customer> customers)\n-    {\n-        ...\n-    }\n-}]]></programlisting>\n-        The above example will accept the multipart data of a list of customers, and unmarshall them correctly.\n-    </section>\n-    <section id=\"MultipartFormData\">\n-        <title>Input with multipart/form-data</title>\n-        <para>When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in\n-            multipart/form-data mime type. \"multipart/form-data\" is often found in web application HTML Form documents\n-            and is generally used to\n-            upload files. The form-data format is the same as other multipart formats, except that each inlined piece\n-            of content has a name associated with it. The interface used for form-data input is\n-            <code>MultipartFormDataInput</code>\n-        </para>\n-        <programlisting><![CDATA[package org.jboss.resteasy.plugins.providers.multipart;\n \n-import java.io.IOException;\n-import java.lang.reflect.Type;\n-import java.util.List;\n-import java.util.Map;\n+      </section>\n+\n+      <section id=\"Simple_mulitpart_message_example\">\n+         <title>Simple mulitpart/mixed message example</title>\n+      <para>The following example shows how to read and write a simple multipart/mixed\n+         message.\n+      </para>\n+      <para>The data to be transfered is a very simple class, Soup.\n+      </para>\n+      <programlisting>\n+<![CDATA[\n+package org.jboss.resteasy.test.providers.multipart.resource;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlElement;\n+\n+@XmlRootElement(name = \"soup\")\n+@XmlAccessorType(XmlAccessType.FIELD)\n+public class Soup {\n+    @XmlElement\n+    private String id;\n \n-import javax.ws.rs.core.GenericType;\n+    public Soup(){}\n+    public Soup(final String id){this.id = id;}\n+    public String getId(){return id;}\n+}\n+]]></programlisting>\n \n-public interface MultipartFormDataInput extends MultipartInput {\n-   /**\n-    * @return A parameter map containing a list of values per name.\n-    */\n-   Map<String, List<InputPart>> getFormDataMap();\n \n-   <T> T getFormDataPart(String key, Class<T> rawType, Type genericType)\n-         throws IOException;\n+         <para>This code fragment creates a multipart/mixed message passing\n+            Soup information using class, <code>MultipartOutput</code>.\n+         </para>\n+         <programlisting>\n+ <![CDATA[\n+      MultipartOutput multipartOutput = new MultipartOutput();\n+      multipartOutput.addPart(new Soup(\"Chicken Noodle\"),\n+            MediaType.APPLICATION_XML_TYPE);\n+      multipartOutput.addPart(new Soup(\"Vegetable\"),\n+            MediaType.APPLICATION_XML_TYPE);\n+      multipartOutput.addPart(\"Granny's Soups\", MediaType.TEXT_PLAIN_TYPE);\n+ ]]></programlisting>\n+\n+         <para>This code fragment uses class <code>MultipartInput</code>\n+            to extract the Soup information provided by multipartOutput\n+            above.\n+         </para>\n+         <programlisting>\n+            <![CDATA[\n+      // MultipartInput multipartInput, the entity returned in the client in a\n+      // Response object or the input value of an endpoint method parameter.\n+      for (InputPart inputPart : multipartInput.getParts()) {\n+          if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {\n+              Soup c = inputPart.getBody(Soup.class, null);\n+              String name = c.getId();\n+          } else {\n+              String s = inputPart.getBody(String.class, null);\n+          }\n+      }\n+ ]]></programlisting>\n+\n+         <para>Returning a multipart/mixed message from an endpoint can be done\n+            in two ways.  <code>MultipartOutput</code> can be returned as the method's\n+            return object or as an entity in a <code>Response</code> object.\n+         </para>\n+    <programlisting>\n+<![CDATA[\n+    @GET\n+    @Path(\"soups/obj\")\n+    @Produces(\"multipart/mixed\")\n+    public MultipartOutput soupsObj() {\n+        return multipartOutput;\n+    }\n \n-   <T> T getFormDataPart(String key, GenericType<T> type) throws IOException;\n-}]]></programlisting>\n-        <para>\n-            It works in much the same way as MultipartInput described earlier in this chapter.\n-        </para>\n+    @GET\n+    @Path(\"soups/resp\")\n+    @Produces(\"multipart/mixed\")\n+    public Response soupsResp() {\n+      return Response.ok(multipartOutput, MediaType.valueOf(\"multipart/mixed\"))\n+                     .build();\n+    }\n+]]></programlisting>\n \n-    </section>\n-    <section id=\"multipart_map\">\n-        <title>java.util.Map with multipart/form-data</title>\n-        <para>With form-data, if your body parts are uniform, you do not have to manually unmarshall each and every\n-            part.\n-            You can just provide a java.util.Map as your input parameter. It must have the type it is\n-            unmarshalling with the generic parameter of the List type declaration. Here's an example of\n-            of unmarshalling a Map of Customer objects which are JAXB annotated classes.\n-        </para>\n-        <programlisting><![CDATA[@Path(\"/multipart\")\n-public class MyService\n-{\n-    @PUT\n-    @Consumes(\"multipart/form-data\")\n-    public void put(Map<String, Customer> customers)\n-    {\n-        ...\n+      <para>There is no difference in the way a client retrieves the message\n+         from the endpoint.  It is done as follows.\n+      </para>\n+         <programlisting>\n+            <![CDATA[\n+      ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();\n+      ResteasyWebTarget target = client.target(THE_URL);\n+      Response response = target.request().get();\n+      MultipartInput multipartInput = response.readEntity(MultipartInput.class);\n+\n+      for (InputPart inputPart : multipartInput.getParts()) {\n+          if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {\n+              Soup c = inputPart.getBody(Soup.class, null);\n+              String name = c.getId();\n+          } else {\n+              String s = inputPart.getBody(String.class, null);\n+          }\n+      }\n+\n+      client.close();\n+ ]]></programlisting>\n+\n+\n+      <para>\n+         A client sends the message, multipartOutput, to an endpoint\n+         as an entity object in an HTTP method call in this code fragment.\n+      </para>\n+         <programlisting>\n+<![CDATA[\n+        ResteasyClient client = (ResteasyClient)ClientBuilder.newClient();\n+        ResteasyWebTarget target = client.target(SOME_URL + \"/register/soups\");\n+        Entity<MultipartOutput> entity = Entity.entity(multipartOutput,\n+                new MediaType(\"multipart\", \"mixed\"));\n+        Response response = target.request().post(entity);\n+ ]]></programlisting>\n+\n+   <para>Here is the endpoint receiving the message and extracting the contents.\n+   </para>\n+   <programlisting>\n+       <![CDATA[\n+ @POST\n+ @Consumes(\"multipart/mixed\")\n+ @Path(\"register/soups\")\n+  public void registerSoups(MultipartInput multipartInput) throws IOException {\n+\n+      for (InputPart inputPart : multipartInput.getParts()) {\n+         if (MediaType.APPLICATION_XML_TYPE.equals(inputPart.getMediaType())) {\n+                Soup c = inputPart.getBody(Soup.class, null);\n+                String name = c.getId();\n+         } else {\n+                String s = inputPart.getBody(String.class, null);\n+         }\n+      }\n+  }\n+ ]]></programlisting>\n+\n+      </section>\n+\n+      <section id=\"message_with_GenericType_example\">\n+         <title>Mulitpart/mixed message with GenericType example</title>", "originalCommit": "053d2f95c9895915fdcdf9ef457cefe07d66b440", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9d62966bcb8fdcfb5e35b41e21d63e9796a5bd45", "url": "https://github.com/resteasy/resteasy/commit/9d62966bcb8fdcfb5e35b41e21d63e9796a5bd45", "message": "[RESTEASY-2531] expanded and refactored chapter", "committedDate": "2020-04-27T14:01:52Z", "type": "commit"}, {"oid": "9d62966bcb8fdcfb5e35b41e21d63e9796a5bd45", "url": "https://github.com/resteasy/resteasy/commit/9d62966bcb8fdcfb5e35b41e21d63e9796a5bd45", "message": "[RESTEASY-2531] expanded and refactored chapter", "committedDate": "2020-04-27T14:01:52Z", "type": "forcePushed"}]}