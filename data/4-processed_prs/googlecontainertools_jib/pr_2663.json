{"pr_number": 2663, "pr_title": "Adding ability check the registry for manifests and push `builtImages` concurrently to the server", "pr_createdAt": "2020-08-05T20:21:14Z", "pr_url": "https://github.com/GoogleContainerTools/jib/pull/2663", "timeline": [{"oid": "5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "url": "https://github.com/GoogleContainerTools/jib/commit/5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "message": "Adding functionality to push up image manifests to the registry", "committedDate": "2020-08-06T17:10:26Z", "type": "commit"}, {"oid": "5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "url": "https://github.com/GoogleContainerTools/jib/commit/5e5bf5ae768580dc73e6ec90e7628c19ec518e75", "message": "Adding functionality to push up image manifests to the registry", "committedDate": "2020-08-06T17:10:26Z", "type": "forcePushed"}, {"oid": "78cd01de020acbaa61bbbcd9f41760880fd5dc48", "url": "https://github.com/GoogleContainerTools/jib/commit/78cd01de020acbaa61bbbcd9f41760880fd5dc48", "message": "Style Fixes", "committedDate": "2020-08-06T19:38:14Z", "type": "commit"}, {"oid": "0bbc64253adf78befa8bb0cac7e5a97401c72c77", "url": "https://github.com/GoogleContainerTools/jib/commit/0bbc64253adf78befa8bb0cac7e5a97401c72c77", "message": "Removing commented out lines", "committedDate": "2020-08-06T19:41:02Z", "type": "commit"}, {"oid": "4fae9f105d0c4f4c3796607f047a06f54b546668", "url": "https://github.com/GoogleContainerTools/jib/commit/4fae9f105d0c4f4c3796607f047a06f54b546668", "message": "Fixing the Null Away Error", "committedDate": "2020-08-06T20:11:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjE5MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466696191", "bodyText": "I don't think this is correct. As the original code, it should depend on baseImagesAndLayers. Depending on builtImages... means that this code will block until you complete building Images.", "author": "chanseokoh", "createdAt": "2020-08-06T21:28:26Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -331,20 +333,22 @@ private void pushBaseImageLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageLayerPushResults =\n+    results.builtImagesAndLayerPushResults =\n         executorService.submit(\n             () -> {\n-              List<List<Future<BlobDescriptor>>> pushResults = new ArrayList<>();\n-              for (List<Future<PreparedLayer>> baseImageLayers :\n-                  results.baseImagesAndLayers.get().values()) {\n+              Map<Future<Image>, List<Future<BlobDescriptor>>> pushResults = new HashMap<>();\n+\n+              for (Map.Entry<Future<Image>, List<Future<PreparedLayer>>> entry :\n+                  results.builtImagesAndLayers.get().entrySet()) {", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4NDQ3OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467084478", "bodyText": "The logic here is to be able to keep track of builtimage -> baseImageLayerPushResults so that we can be able to use realizeFutures on the correct baseImageLayerPushResults in the pushImages step.\nThe reason why I am depending on builtImages here is because inorder to be able to match builtImage -> baseImageLayerPushResults you need to have the builtImage -> baseImageLayer mapping first which I create in the buildimage function.\nOn the brighter side ,all of these extra mapping can be avoided if we decided to for go realizeFutures(baseImageLayerPushResults) in the pushImage step", "author": "louismurerwa", "createdAt": "2020-08-07T14:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwMzYxNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467103614", "bodyText": "I can understand why it ended up like this, but I think this is not correct for a few reasons. I will just mention one reason that can alone make this not acceptable:\nresults.builtImagesAndLayers is the result coming from scheduling a thread in buildImages(). And calling results.builtImagesAndLayers.get() here means you will wait until the thread scheduled in buildImages() runs to completion. Conceptually, it means you'll wait until \"images\" are built. The code will now speak that \"in order to be able to push base image layers, I need to build images first.\" OTOH, previously, this pushBaseImageLayers() didn't have any dependency on buildImages(). Pushing base image layers can start as soon as we have base image layers. But with this change, you can start pushing only after the thread from buildImages() completed. This is a significant departure from the current async dependencies behaviors. Whenever we change the original intention, there should be a clear reason; just to allow making some other parts technically easy to make it work with minimal changes can't be a reason.", "author": "chanseokoh", "createdAt": "2020-08-07T15:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExMDY4OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467110689", "bodyText": "That makes sense - this implementation does slow down things.I'l revert this to the previous implementation and we can make changes starting from there.", "author": "louismurerwa", "createdAt": "2020-08-07T15:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NjQ1OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466696458", "bodyText": "builtImagesAndBaseImageLayerPushResults", "author": "chanseokoh", "createdAt": "2020-08-06T21:29:04Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -331,20 +333,22 @@ private void pushBaseImageLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageLayerPushResults =\n+    results.builtImagesAndLayerPushResults =", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5NzA0NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466697045", "bodyText": "Since we won't use builtImagesAndLayers in pushBaseImageLayers() (see my other comment), perhaps we don't need to change buildImages() code?", "author": "chanseokoh", "createdAt": "2020-08-06T21:30:27Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -379,9 +384,9 @@ private void buildImages() {\n                                     realizeFutures(Verify.verifyNotNull(entry.getValue())),\n                                     realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                                 .call());\n-                builtImages.add(builtImage);\n+                builtImagesAndLayers.put(builtImage, entry.getValue());", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODQ5NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466698494", "bodyText": "I think we should keep using builtImages. I think using builtImagesAndContainerConfigurationPushResults to get an Image causes confusion and feels like abusing.", "author": "chanseokoh", "createdAt": "2020-08-06T21:33:54Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5OTQ1Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466699456", "bodyText": "Do we really need this change? I was aware that we can always use .iterator().next() to retrieve a value from a single-entry map, but you've been so far consistently calling Map.get(). Mixing patterns makes it harder to understand code.", "author": "chanseokoh", "createdAt": "2020-08-06T21:36:04Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDY4Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466700682", "bodyText": "It takes some seconds to get what entry.getKey() means. I suggest declaring a local variable Future<Image> builtImage = entry.getKey() before this realizeFutures(). The same goes for entry.getValue().", "author": "chanseokoh", "createdAt": "2020-08-06T21:39:13Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .keySet()\n+                                    .iterator()\n+                                    .next())\n+                            .get())\n                     .call());\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              for (Map.Entry<Future<Image>, Future<BlobDescriptor>> entry :\n+                  results.builtImagesAndContainerConfigurationPushResults.get().entrySet()) {\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .builtImagesAndLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(entry.getKey())));", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5NTE5NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467095195", "bodyText": "@chanseokoh This is the line that has caused all the changes in the structure of the code .Do we really need to realizeFutures(baseImageLayerPushResults)  here ?\nIs there any way we could for-go realizing these futures here?\nOnce we have answered this question ,I can easily refactor the code.", "author": "louismurerwa", "createdAt": "2020-08-07T14:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExNDI4OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467114289", "bodyText": "Every line of code is there for a reason. We have realizeFutures() in the original code, so I assume there must be a reason. If you can't or don't know if what the existing code does or why it is there, you should assume it's necessary. Even when you think some code is unnecessary, you need to think through and really spend a lot of time before taking out some code.\nIn this case, I think it's definitely necessary. You can push a manifest only after you confirmed that you've done pushing layers. Otherwise, a registry will return \"bad manifest push; layers described in the manifest don't exist.\" And I can see the only place where we confirm the base image push results is here.", "author": "chanseokoh", "createdAt": "2020-08-07T15:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMDY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMTA4OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466701089", "bodyText": "ditto about the .iterator().next() practice.", "author": "chanseokoh", "createdAt": "2020-08-06T21:40:07Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .keySet()\n+                                    .iterator()\n+                                    .next())\n+                            .get())\n                     .call());\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              for (Map.Entry<Future<Image>, Future<BlobDescriptor>> entry :\n+                  results.builtImagesAndContainerConfigurationPushResults.get().entrySet()) {\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .builtImagesAndLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(entry.getKey())));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(entry.getValue()).get(),\n+                                      entry.getKey().get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(entry.getValue()).get().getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  results\n+                                      .builtImagesAndLayers\n+                                      .get()\n+                                      .keySet()\n+                                      .iterator()\n+                                      .next()", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwMTEyOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r466701128", "bodyText": "ditto", "author": "chanseokoh", "createdAt": "2020-08-06T21:40:12Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -439,80 +444,122 @@ private void checkImageInTargetRegistry() {\n                                 results\n                                     .builtImagesAndContainerConfigurationPushResults\n                                     .get()\n-                                    .get(results.builtImages.get().get(0)))\n+                                    .values()\n+                                    .iterator()\n+                                    .next())\n                             .get(),\n-                        results.builtImages.get().get(0).get())\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .keySet()\n+                                    .iterator()\n+                                    .next())\n+                            .get())\n                     .call());\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              for (Map.Entry<Future<Image>, Future<BlobDescriptor>> entry :\n+                  results.builtImagesAndContainerConfigurationPushResults.get().entrySet()) {\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .builtImagesAndLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(entry.getKey())));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(entry.getValue()).get(),\n+                                      entry.getKey().get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(entry.getValue()).get().getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  results\n+                                      .builtImagesAndLayers\n+                                      .get()\n+                                      .keySet()\n+                                      .iterator()\n+                                      .next()\n+                                      .get())\n+                              .call());\n+              buildResults.add(buildResult);\n+              return buildResults;\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new WriteTarFileStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  outputPath,\n+                                  results\n+                                      .builtImagesAndLayers\n+                                      .get()\n+                                      .keySet()\n+                                      .iterator()", "originalCommit": "4fae9f105d0c4f4c3796607f047a06f54b546668", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "55054594749e03da22349101ae6cc3bf8032941a", "url": "https://github.com/GoogleContainerTools/jib/commit/55054594749e03da22349101ae6cc3bf8032941a", "message": "Style Fixes", "committedDate": "2020-08-07T15:43:52Z", "type": "commit"}, {"oid": "ae90ce7407aecb5bcd45d88811a5461ec3afdbf8", "url": "https://github.com/GoogleContainerTools/jib/commit/ae90ce7407aecb5bcd45d88811a5461ec3afdbf8", "message": "Updating the code structure and adding functionality to match baseimage -> builtimage", "committedDate": "2020-08-07T19:23:29Z", "type": "commit"}, {"oid": "b88b7bc4f8c8d3105f924dd4a4bea41b5336caf1", "url": "https://github.com/GoogleContainerTools/jib/commit/b88b7bc4f8c8d3105f924dd4a4bea41b5336caf1", "message": "Style Fixes", "committedDate": "2020-08-07T19:56:42Z", "type": "commit"}, {"oid": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "url": "https://github.com/GoogleContainerTools/jib/commit/e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "message": "Style Fixes", "committedDate": "2020-08-07T20:02:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4MjMyMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467282320", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                results.baseImagesAndbaseImageLayerPushResults =\n          \n          \n            \n                results.baseImagesAndBaseImageLayerPushResults =\n          \n      \n    \n    \n  \n\nbut because this time it's all about base images, I think we can go with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                results.baseImagesAndbaseImageLayerPushResults =\n          \n          \n            \n                results.baseImagesAndLayerPushResults =", "author": "chanseokoh", "createdAt": "2020-08-07T21:32:44Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -331,20 +332,23 @@ private void pushBaseImageLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageLayerPushResults =\n+    results.baseImagesAndbaseImageLayerPushResults =", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NTAyMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467285020", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            builtImagesAndBaseImages.put(builtImage, entry.getKey());\n          \n          \n            \n                            builtImagesAndBaseImages.put(builtImage, entry.getKey() /* base Image */);", "author": "chanseokoh", "createdAt": "2020-08-07T21:36:19Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -379,21 +383,21 @@ private void buildImages() {\n                                     realizeFutures(Verify.verifyNotNull(entry.getValue())),\n                                     realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                                 .call());\n-                builtImages.add(builtImage);\n+                builtImagesAndBaseImages.put(builtImage, entry.getKey());", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NzY3OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467287679", "bodyText": "You only need the key, so no need for entrySet(). And let's add a check; I'm certain the check will become useful going forward.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Future<Image> builtImage = entry.getKey();\n          \n          \n            \n                          Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n          \n          \n            \n                          Future<Image> builtImage = results.builtImagesAndBaseImages.get().keySet().iterator().next();", "author": "chanseokoh", "createdAt": "2020-08-07T21:39:54Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NTU4NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467295585", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Future<Image> builtImage = entry.getKey();\n          \n          \n            \n                          Verify.verify(results.builtImagesAndBaseImages.get().size() == 1, \"multi-platform image building not supported when pushing to Docker engine\");\n          \n          \n            \n                          Future<Image> builtImage = results.builtImagesAndBaseImages.get().keySet().iterator().next();", "author": "chanseokoh", "createdAt": "2020-08-07T21:50:09Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjU1NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467296554", "bodyText": "Can be simplified by return Collections.singletonList(executorService.submit(...)).", "author": "chanseokoh", "createdAt": "2020-08-07T21:51:23Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzQ1Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467297456", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Map.Entry<Future<Image>, Image> entry =\n          \n          \n            \n                              results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n          \n          \n            \n                          Future<Image> builtImage = entry.getKey();\n          \n          \n            \n                          Verify.verify(results.builtImagesAndBaseImages.get().size() == 1, \"multi-platform image building not supported when building a local tar image\");\n          \n          \n            \n                          Future<Image> builtImage = results.builtImagesAndBaseImages.get().keySet().iterator().next();", "author": "chanseokoh", "createdAt": "2020-08-07T21:52:33Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call());\n+              buildResults.add(buildResult);\n+              return buildResults;\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5ODAyNg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r467298026", "bodyText": "Ditto. No need to create an array.", "author": "chanseokoh", "createdAt": "2020-08-07T21:53:17Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +434,138 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n                                   results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .baseImagesAndbaseImageLayerPushResults\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n+                                      .get()\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+              Future<BuildResult> buildResult =\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call());\n+              buildResults.add(buildResult);\n+              return buildResults;\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map.Entry<Future<Image>, Image> entry =\n+                  results.builtImagesAndBaseImages.get().entrySet().iterator().next();\n+              Future<Image> builtImage = entry.getKey();\n+\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();", "originalCommit": "e8f8c4193f22f374b9d4b7a2eb91b58398be359f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "url": "https://github.com/GoogleContainerTools/jib/commit/00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "message": "Style Fixes", "committedDate": "2020-08-10T14:34:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA4MTU4NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468081584", "bodyText": "I think we can block until we get the built Image?\n              Image builtImage =\n                  results.builtImagesAndBaseImages.get().keySet().iterator().next().get();\nNext, I think we should avoid scheduling another thread. We can use Futures.immediateFuture (a utility method to directly instantiate a Future from a concrete value) that just wraps a value instead of actually scheduling a thread.\n              Image builtImage =\n                  results.builtImagesAndBaseImages.get().keySet().iterator().next().get();\n\n              return Collections.singletonList(\n                  Futures.immediateFuture(\n                      new LoadDockerStep(\n                              buildContext,\n                              childProgressDispatcherFactory,\n                              dockerClient,\n                              builtImage)\n                          .call()));", "author": "chanseokoh", "createdAt": "2020-08-10T18:00:03Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +435,133 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n-                                  results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n+                                  results.baseImagesAndLayerPushResults.get().get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(\n+                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  \"multi-platform image building not supported when pushing to Docker engine\");\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+\n+              return Collections.singletonList(\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call()));\n+            });", "originalCommit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODExMDE3MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468110170", "bodyText": "And I think this is more readable:\n              BuildResult buildResult =\n                  new LoadDockerStep(\n                          buildContext, childProgressDispatcherFactory, dockerClient, builtImage)\n                      .call();\n              return Collections.singletonList(Futures.immediateFuture(buildResult));", "author": "chanseokoh", "createdAt": "2020-08-10T18:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA4MTU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODQ2MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468098460", "bodyText": "ditto", "author": "chanseokoh", "createdAt": "2020-08-10T18:31:37Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +435,133 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n-                                  results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n+                                  results.baseImagesAndLayerPushResults.get().get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))\n+                                          .get(),\n+                                      builtImage.get(),\n+                                      results.manifestCheckResult.get().isPresent()));\n+\n+                          realizeFutures(manifestPushResults);\n+                          return manifestPushResults.isEmpty()\n+                              ? new BuildResult(\n+                                  results.manifestCheckResult.get().get().getDigest(),\n+                                  Verify.verifyNotNull(\n+                                          results\n+                                              .builtImagesAndContainerConfigurationPushResults\n+                                              .get()\n+                                              .get(builtImage))\n                                       .get()\n-                                      .get(results.builtImages.get().get(0)))\n-                              .get(),\n-                          results.builtImages.get().get(0).get(),\n-                          results.manifestCheckResult.get().isPresent()));\n-              realizeFutures(manifestPushResults);\n-              return manifestPushResults.isEmpty()\n-                  ? new BuildResult(\n-                      results.manifestCheckResult.get().get().getDigest(),\n-                      Verify.verifyNotNull(\n-                              results\n-                                  .builtImagesAndContainerConfigurationPushResults\n-                                  .get()\n-                                  .get(results.builtImages.get().get(0)))\n-                          .get()\n-                          .getDigest())\n-                  // Manifest pushers return the same BuildResult.\n-                  : manifestPushResults.get(0).get();\n+                                      .getDigest())\n+                              // Manifest pushers return the same BuildResult.\n+                              : manifestPushResults.get(0).get();\n+                        });\n+\n+                buildResults.add(buildResult);\n+              }\n+              return buildResults;\n             });\n   }\n \n   private void loadDocker(DockerClient dockerClient) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new LoadDockerStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        dockerClient,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(\n+                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  \"multi-platform image building not supported when pushing to Docker engine\");\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+\n+              return Collections.singletonList(\n+                  executorService.submit(\n+                      () ->\n+                          new LoadDockerStep(\n+                                  buildContext,\n+                                  childProgressDispatcherFactory,\n+                                  dockerClient,\n+                                  builtImage.get())\n+                              .call()));\n+            });\n   }\n \n   private void writeTarFile(Path outputPath) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n-            () ->\n-                new WriteTarFileStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        outputPath,\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(\n+                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  \"multi-platform image building not supported when building a local tar image\");\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+\n+              return Collections.singletonList(\n+                  executorService.submit(", "originalCommit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMjU0Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2663#discussion_r468132543", "bodyText": "This is also used on line 500, so I suggest refactor out into a local variable. I think it will considerable improve readability.", "author": "chanseokoh", "createdAt": "2020-08-10T19:29:05Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -430,89 +435,133 @@ private void checkImageInTargetRegistry() {\n \n     results.manifestCheckResult =\n         executorService.submit(\n-            () ->\n-                new CheckImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                                results\n-                                    .builtImagesAndContainerConfigurationPushResults\n-                                    .get()\n-                                    .get(results.builtImages.get().get(0)))\n-                            .get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Verify.verify(results.builtImagesAndBaseImages.get().size() == 1);\n+              Future<Image> builtImage =\n+                  results.builtImagesAndBaseImages.get().keySet().iterator().next();\n+              return new CheckImageStep(\n+                      buildContext,\n+                      childProgressDispatcherFactory,\n+                      results.targetRegistryClient.get(),\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(builtImage))\n+                          .get(),\n+                      builtImage.get())\n+                  .call();\n+            });\n   }\n \n   private void pushImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.buildResult =\n+    results.buildResults =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> manifestPushResults =\n-                  scheduleCallables(\n-                      PushImageStep.makeList(\n-                          buildContext,\n-                          childProgressDispatcherFactory,\n-                          results.targetRegistryClient.get(),\n-                          Verify.verifyNotNull(\n-                                  results\n-                                      .builtImagesAndContainerConfigurationPushResults\n+              List<Future<BuildResult>> buildResults = new ArrayList<>();\n+\n+              for (Map.Entry<Future<Image>, Image> entry :\n+                  results.builtImagesAndBaseImages.get().entrySet()) {\n+\n+                Future<Image> builtImage = entry.getKey();\n+                Image baseImage = entry.getValue();\n+\n+                Future<BuildResult> buildResult =\n+                    executorService.submit(\n+                        () -> {\n+                          realizeFutures(\n+                              Verify.verifyNotNull(\n+                                  results.baseImagesAndLayerPushResults.get().get(baseImage)));\n+\n+                          List<Future<BuildResult>> manifestPushResults =\n+                              scheduleCallables(\n+                                  PushImageStep.makeList(\n+                                      buildContext,\n+                                      childProgressDispatcherFactory,\n+                                      results.targetRegistryClient.get(),\n+                                      Verify.verifyNotNull(\n+                                              results\n+                                                  .builtImagesAndContainerConfigurationPushResults\n+                                                  .get()\n+                                                  .get(builtImage))", "originalCommit": "00140cd64838a07c01212b5e9a6b54b2e8c2c1df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8a92200f852c12e1925e2e08dc0c88817ed3009b", "url": "https://github.com/GoogleContainerTools/jib/commit/8a92200f852c12e1925e2e08dc0c88817ed3009b", "message": "Style Fixes", "committedDate": "2020-08-11T15:31:09Z", "type": "commit"}, {"oid": "97dfb42924055a67eb73b3a63b50bf0704fd0f17", "url": "https://github.com/GoogleContainerTools/jib/commit/97dfb42924055a67eb73b3a63b50bf0704fd0f17", "message": "Refactor code; no behavior change", "committedDate": "2020-08-11T16:16:45Z", "type": "commit"}, {"oid": "718c32c8dd92987a3d7c1cdfb6e735426593eb62", "url": "https://github.com/GoogleContainerTools/jib/commit/718c32c8dd92987a3d7c1cdfb6e735426593eb62", "message": "Merge remote-tracking branch 'origin/master' into pushImages", "committedDate": "2020-08-11T16:17:05Z", "type": "commit"}, {"oid": "d3c7019d986039014fa140888af5eac73ecd447c", "url": "https://github.com/GoogleContainerTools/jib/commit/d3c7019d986039014fa140888af5eac73ecd447c", "message": "Update comment", "committedDate": "2020-08-11T16:19:20Z", "type": "commit"}]}