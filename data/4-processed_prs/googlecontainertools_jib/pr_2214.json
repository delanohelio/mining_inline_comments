{"pr_number": 2214, "pr_title": "Implement update checks", "pr_createdAt": "2020-01-06T22:11:27Z", "pr_url": "https://github.com/GoogleContainerTools/jib/pull/2214", "timeline": [{"oid": "4128ce935c7afb5407457eb96e58c96ce9856217", "url": "https://github.com/GoogleContainerTools/jib/commit/4128ce935c7afb5407457eb96e58c96ce9856217", "message": "Progress", "committedDate": "2020-01-03T20:26:54Z", "type": "commit"}, {"oid": "76fb821a1ce25043cc0276edbdea5bc94a352cb0", "url": "https://github.com/GoogleContainerTools/jib/commit/76fb821a1ce25043cc0276edbdea5bc94a352cb0", "message": "Add method for retrieving XDG config directory", "committedDate": "2020-01-03T20:59:53Z", "type": "commit"}, {"oid": "907b8fce0c0d5012371352d06d185fb05478e3b8", "url": "https://github.com/GoogleContainerTools/jib/commit/907b8fce0c0d5012371352d06d185fb05478e3b8", "message": "Merge branch 'xdg-config' of github.com:GoogleContainerTools/jib into i2193-update-checks", "committedDate": "2020-01-03T21:56:07Z", "type": "commit"}, {"oid": "88a86b896463d85f9200fe4cfd5e5102972ca7ba", "url": "https://github.com/GoogleContainerTools/jib/commit/88a86b896463d85f9200fe4cfd5e5102972ca7ba", "message": "Progress", "committedDate": "2020-01-03T22:38:15Z", "type": "commit"}, {"oid": "0dbc81f758709cc77a64191b26170f8a31aa8df1", "url": "https://github.com/GoogleContainerTools/jib/commit/0dbc81f758709cc77a64191b26170f8a31aa8df1", "message": "Add unit tests", "committedDate": "2020-01-06T20:31:56Z", "type": "commit"}, {"oid": "b80d27234d7254811042cde15e8b87835325619e", "url": "https://github.com/GoogleContainerTools/jib/commit/b80d27234d7254811042cde15e8b87835325619e", "message": "Travis?", "committedDate": "2020-01-06T21:34:50Z", "type": "commit"}, {"oid": "6f93837068fcf97f28ea2cdea348624d313ef7f4", "url": "https://github.com/GoogleContainerTools/jib/commit/6f93837068fcf97f28ea2cdea348624d313ef7f4", "message": "Update comment", "committedDate": "2020-01-06T22:46:01Z", "type": "commit"}, {"oid": "575b74a7bd8f88a1233eb6591fd0cc0ca31bbae4", "url": "https://github.com/GoogleContainerTools/jib/commit/575b74a7bd8f88a1233eb6591fd0cc0ca31bbae4", "message": "Return full path", "committedDate": "2020-01-07T18:17:23Z", "type": "commit"}, {"oid": "fefc308ad9d9c4a7608cc5044c731e6eb49cac6e", "url": "https://github.com/GoogleContainerTools/jib/commit/fefc308ad9d9c4a7608cc5044c731e6eb49cac6e", "message": "Fix comment", "committedDate": "2020-01-07T18:19:51Z", "type": "commit"}, {"oid": "8c75b78fe4f0ad25eb7507ecf31d2f9bfc1ad6dd", "url": "https://github.com/GoogleContainerTools/jib/commit/8c75b78fe4f0ad25eb7507ecf31d2f9bfc1ad6dd", "message": "Reduce diff", "committedDate": "2020-01-07T18:22:48Z", "type": "commit"}, {"oid": "0aed062c9771bd527f8f55476fbee03f68d4218b", "url": "https://github.com/GoogleContainerTools/jib/commit/0aed062c9771bd527f8f55476fbee03f68d4218b", "message": "Nevermind", "committedDate": "2020-01-07T18:23:54Z", "type": "commit"}, {"oid": "ef8ad1e852f9a92e4a69dca25d189895f7ab3a83", "url": "https://github.com/GoogleContainerTools/jib/commit/ef8ad1e852f9a92e4a69dca25d189895f7ab3a83", "message": "Change base image cache directory", "committedDate": "2020-01-07T19:57:08Z", "type": "commit"}, {"oid": "7257f98911d5d41ff1b059c2e50f9d431e7b30fc", "url": "https://github.com/GoogleContainerTools/jib/commit/7257f98911d5d41ff1b059c2e50f9d431e7b30fc", "message": "Share code", "committedDate": "2020-01-07T21:35:50Z", "type": "commit"}, {"oid": "594bf738f518969d49c5e288efe9a60f974bde12", "url": "https://github.com/GoogleContainerTools/jib/commit/594bf738f518969d49c5e288efe9a60f974bde12", "message": "Fix test", "committedDate": "2020-01-07T21:43:57Z", "type": "commit"}, {"oid": "4fd8727a326712cf5923fde7190c6dba7d97fe56", "url": "https://github.com/GoogleContainerTools/jib/commit/4fd8727a326712cf5923fde7190c6dba7d97fe56", "message": "Feedback", "committedDate": "2020-01-09T16:48:02Z", "type": "commit"}, {"oid": "f51248e9f682bb55750b6a5fca1364b7577090ab", "url": "https://github.com/GoogleContainerTools/jib/commit/f51248e9f682bb55750b6a5fca1364b7577090ab", "message": "Merge branch 'i2216-change-cache-location' of github.com:GoogleContainerTools/jib into i2193-update-checks", "committedDate": "2020-01-09T17:58:46Z", "type": "commit"}, {"oid": "dfe86e9d2fdfadde2c786cc54dd2f88e566eb346", "url": "https://github.com/GoogleContainerTools/jib/commit/dfe86e9d2fdfadde2c786cc54dd2f88e566eb346", "message": "Fix directory", "committedDate": "2020-01-09T17:59:37Z", "type": "commit"}, {"oid": "c7709af8eeb9523ff179bc72a0247599e5a4a495", "url": "https://github.com/GoogleContainerTools/jib/commit/c7709af8eeb9523ff179bc72a0247599e5a4a495", "message": "Add system property for config directory", "committedDate": "2020-01-09T20:19:52Z", "type": "commit"}, {"oid": "3057a5686af6e9063ff02e80edefe9143e198dc1", "url": "https://github.com/GoogleContainerTools/jib/commit/3057a5686af6e9063ff02e80edefe9143e198dc1", "message": "Merge branch 'master' of github.com:GoogleContainerTools/jib into i2193-update-checks", "committedDate": "2020-01-09T20:22:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkzODU4Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364938587", "bodyText": "I believe this returns the project version, like <version>0.0.1-SNAPSHOT</version> in pom.xml. We have ProjectInfo.VERSION (which works only when the code is packaged as a JAR).", "author": "chanseokoh", "createdAt": "2020-01-09T20:11:40Z", "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildTarMojo.java", "diffHunk": "@@ -65,6 +68,12 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n     MavenProjectProperties projectProperties =\n         MavenProjectProperties.getForProject(\n             getProject(), getSession(), getLog(), tempDirectoryProvider);\n+    UpdateChecker updateChecker =\n+        UpdateChecker.checkForUpdate(\n+            projectProperties.isOffline() || !getLog().isInfoEnabled(),\n+            projectProperties.getVersion(),", "originalCommit": "dfe86e9d2fdfadde2c786cc54dd2f88e566eb346", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk0NTA5Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364945097", "bodyText": "Abort if", "author": "chanseokoh", "createdAt": "2020-01-09T20:28:16Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(\n+        executorService.submit(\n+            () -> performUpdateCheck(skip, version, versionUrl, getConfigDir())));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort of update checks are disabled", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk0NzUzNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364947534", "bodyText": "This is not really necessary given the circumstances, but since it's not a big deal to do it, let's have HttpURLConnection connection = (HttpURLConnection) ... and call connection.disconnect() at the end.\nAnd there should be some way to set some timeout values with HttpURLConnection. It's worth setting them a small value.\nAnd can you verify Maven and Gradle both terminate right away even if this thread is alive, e.g., by putting Thread.sleep(10000) here? (UPDATE: see #2214 (comment).)", "author": "chanseokoh", "createdAt": "2020-01-09T20:34:46Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(\n+        executorService.submit(\n+            () -> performUpdateCheck(skip, version, versionUrl, getConfigDir())));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort of update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));\n+      }\n+\n+      // Check time of last update check\n+      Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      URLConnection connection = new URL(versionUrl).openConnection();", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwNzA2MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366007061", "bodyText": "Looks like it does terminate right away.", "author": "TadCordle", "createdAt": "2020-01-13T20:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk0NzUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk0ODg5Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364948892", "bodyText": "How about attempting to delete both the config file and lastUpdateCheck? That can fix the situation if any of the files is corrupt.", "author": "chanseokoh", "createdAt": "2020-01-09T20:38:15Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(\n+        executorService.submit(\n+            () -> performUpdateCheck(skip, version, versionUrl, getConfigDir())));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort of update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));\n+      }\n+\n+      // Check time of last update check\n+      Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      URLConnection connection = new URL(versionUrl).openConnection();\n+      BufferedReader bufferedReader =\n+          new BufferedReader(\n+              new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+      String latestVersion = bufferedReader.readLine().trim();\n+      Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+      if (currentVersion.equals(latestVersion)) {\n+        return Optional.empty();\n+      }\n+      return Optional.of(\n+          \"A new version of Jib (\"\n+              + latestVersion\n+              + \") is available (currently using \"\n+              + currentVersion\n+              + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+    } catch (IOException ignored) {\n+      // Fail silently", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MDQ2OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364950469", "bodyText": "I think reading and writing files is fast enough, so they don't have to be in a thread? I think it's OK to run only the network connection code in a thread.", "author": "chanseokoh", "createdAt": "2020-01-09T20:42:12Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(\n+        executorService.submit(\n+            () -> performUpdateCheck(skip, version, versionUrl, getConfigDir())));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk1ODg2MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r365958861", "bodyText": "Is there a disadvantage to just running the whole thing in a different thread?", "author": "TadCordle", "createdAt": "2020-01-13T18:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MDQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk3MTkxMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r365971911", "bodyText": "Not really. I think either way is fine.", "author": "chanseokoh", "createdAt": "2020-01-13T18:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MDQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MTAyMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364951023", "bodyText": "Just temporaryFolder.getRoot()?", "author": "chanseokoh", "createdAt": "2020-01-09T20:43:33Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MjEwNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364952107", "bodyText": "I think it's nice to write an actual JSON, like Files.write(..., \"{\\\"disableUpdateCheck\\\":true}\".getBytes(...)).", "author": "chanseokoh", "createdAt": "2020-01-09T20:46:38Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_skip() {\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    config.setDisableUpdateCheck(true);\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MzMzOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364953338", "bodyText": "Does MoreExecutors.newDirectExecutorService() work? You may be able to remove Thread.sleep(). Otherwise, I think this test can be flaky.\nOr better yet, I think Futures.immediateFuture(Optional.of(\"Hello\")).", "author": "chanseokoh", "createdAt": "2020-01-09T20:49:58Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_skip() {\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    config.setDisableUpdateCheck(true);\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));\n+\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer = new TestWebServer(false, Collections.singletonList(\"bad\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(true, \"1.0.2\", badServer.getEndpoint(), configDir);\n+      Assert.assertFalse(message.isPresent());\n+    }\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_success() throws InterruptedException {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =\n+        new UpdateChecker(executorService.submit(() -> Optional.of(\"Hello\")));\n+    Thread.sleep(100);", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1NDUyNQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364954525", "bodyText": "Future is a simple interface, so I think it's better to implement one whose isDone() always returns false.", "author": "chanseokoh", "createdAt": "2020-01-09T20:53:01Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_skip() {\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    config.setDisableUpdateCheck(true);\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));\n+\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer = new TestWebServer(false, Collections.singletonList(\"bad\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(true, \"1.0.2\", badServer.getEndpoint(), configDir);\n+      Assert.assertFalse(message.isPresent());\n+    }\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_success() throws InterruptedException {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =\n+        new UpdateChecker(executorService.submit(() -> Optional.of(\"Hello\")));\n+    Thread.sleep(100);\n+    Optional<String> result = updateChecker.finishUpdateCheck();\n+    Assert.assertTrue(result.isPresent());\n+    Assert.assertEquals(\"Hello\", result.get());\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_notDone() {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1NDkxOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364954918", "bodyText": "Q: this just writes {}?", "author": "chanseokoh", "createdAt": "2020-01-09T20:54:06Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+\n+/** Tests for {@link UpdateChecker} */\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.newFolder().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_skip() {\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    config.setDisableUpdateCheck(true);\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));\n+\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(true, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer = new TestWebServer(false, Collections.singletonList(\"bad\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(true, \"1.0.2\", badServer.getEndpoint(), configDir);\n+      Assert.assertFalse(message.isPresent());\n+    }\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_success() throws InterruptedException {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =\n+        new UpdateChecker(executorService.submit(() -> Optional.of(\"Hello\")));\n+    Thread.sleep(100);\n+    Optional<String> result = updateChecker.finishUpdateCheck();\n+    Assert.assertTrue(result.isPresent());\n+    Assert.assertEquals(\"Hello\", result.get());\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_notDone() {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    UpdateChecker updateChecker =\n+        new UpdateChecker(\n+            executorService.submit(\n+                () -> {\n+                  try {\n+                    Thread.sleep(100);\n+                  } catch (InterruptedException ignored) {\n+                  }\n+                  return Optional.of(\"Hello\");\n+                }));\n+    Optional<String> result = updateChecker.finishUpdateCheck();\n+    Assert.assertFalse(result.isPresent());\n+  }\n+\n+  private void setupConfigAndLastUpdateCheck() throws IOException {\n+    UpdateChecker.ConfigJsonTemplate config = new UpdateChecker.ConfigJsonTemplate();\n+    JsonTemplateMapper.writeTo(config, Files.newOutputStream(configDir.resolve(\"config.json\")));", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyODQ1MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r365928451", "bodyText": "Nope, writes {\"disableUpdateCheck\":false}.", "author": "TadCordle", "createdAt": "2020-01-13T17:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1NDkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2NDY3MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364964671", "bodyText": "It feels weird to put \"skip\" in here?\nCould the maven/gradle calls to checkForUpdate be implemented in a way like\nUpdater.for(ProjectProperties).checkForUpdates()\n\nwhere \"for\" decides whether to skip or not? Or something of that sort.", "author": "loosebazooka", "createdAt": "2020-01-09T21:19:34Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2NTMyOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r364965328", "bodyText": "do you have do some work here to shutdown the executor?", "author": "loosebazooka", "createdAt": "2020-01-09T21:21:17Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param version the current version of Jib being used\n+   * @param versionUrl the location to check for the latest version\n+   * @param executorService the {@link ExecutorService}\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(\n+      boolean skip, String version, String versionUrl, ExecutorService executorService) {\n+    return new UpdateChecker(", "originalCommit": "3057a5686af6e9063ff02e80edefe9143e198dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwMzI5Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366003297", "bodyText": "I should probably provide more context:\nExecutorService x = Executors.newSingleThreadExecutor();\nx.submit(() -> System.out.println(\"goose\"));\n// x.shutdown();\n\nIn this example, without x.shutdown, running this will pause until the thread is cleaned up (or something like that)\nMore context here: https://stackoverflow.com/questions/20057497/program-does-not-terminate-immediately-when-all-executorservice-tasks-are-done", "author": "loosebazooka", "createdAt": "2020-01-13T20:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2NTMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwNjMwNQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366006305", "bodyText": "Yeah, I think we can save the executor service and call shutdown() in finishUpdateCheck().", "author": "TadCordle", "createdAt": "2020-01-13T20:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2NTMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwODM0NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366008344", "bodyText": "Oh, looks like we can shut it down immediately after submitting.", "author": "TadCordle", "createdAt": "2020-01-13T20:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2NTMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwOTA5Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366009097", "bodyText": "Should the executor service be isolated to the update checker? I may have missed why we are passing it in?", "author": "loosebazooka", "createdAt": "2020-01-13T20:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2NTMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAwOTY5Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366009696", "bodyText": "Yeah you can use shutdown if you know you're not submitting any more jobs.\nBut if the executor is coming from outside, then there's no way to ensure that it is exclusively being used for this purpose?", "author": "loosebazooka", "createdAt": "2020-01-13T20:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk2NTMyOA=="}], "type": "inlineReview"}, {"oid": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "url": "https://github.com/GoogleContainerTools/jib/commit/14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "message": "Fixes and feedback", "committedDate": "2020-01-13T20:37:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzODg0Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366038842", "bodyText": "I think s is too short. s --> updateMessage", "author": "chanseokoh", "createdAt": "2020-01-13T21:30:56Z", "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/BuildDockerTask.java", "diffHunk": "@@ -145,6 +151,10 @@ public void buildDocker()\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzODg5NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366038894", "bodyText": "ditto", "author": "chanseokoh", "createdAt": "2020-01-13T21:31:03Z", "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/BuildImageTask.java", "diffHunk": "@@ -143,6 +149,10 @@ public void buildImage()\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzOTQ2OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366039468", "bodyText": "ditto", "author": "chanseokoh", "createdAt": "2020-01-13T21:32:20Z", "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/BuildTarTask.java", "diffHunk": "@@ -159,6 +165,10 @@ public void buildTar()\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzOTUwMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366039501", "bodyText": "ditto", "author": "chanseokoh", "createdAt": "2020-01-13T21:32:25Z", "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildDockerMojo.java", "diffHunk": "@@ -134,6 +139,10 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzOTUzMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366039531", "bodyText": "ditto", "author": "chanseokoh", "createdAt": "2020-01-13T21:32:29Z", "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildImageMojo.java", "diffHunk": "@@ -148,6 +153,10 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzOTU1Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366039557", "bodyText": "ditto", "author": "chanseokoh", "createdAt": "2020-01-13T21:32:33Z", "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildTarMojo.java", "diffHunk": "@@ -126,6 +131,10 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .finishUpdateCheck()\n+          .ifPresent(\n+              s -> projectProperties.log(LogEvent.lifecycle(\"\\n\\u001B[33m\" + s + \"\\u001B[0m\\n\")));", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0MzI1Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366043252", "bodyText": "I can't explain which one is more suitable, but I use Verify.verifyNotNull() in this situation.", "author": "chanseokoh", "createdAt": "2020-01-13T21:41:06Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(boolean skip, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    skip,\n+                    Preconditions.checkNotNull(ProjectInfo.VERSION),", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0NDA4NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366044084", "bodyText": "I think it's meaningful to close newOutputStream() in this case.", "author": "chanseokoh", "createdAt": "2020-01-13T21:43:03Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(boolean skip, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    skip,\n+                    Preconditions.checkNotNull(ProjectInfo.VERSION),\n+                    versionUrl,\n+                    getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0NTYwMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366045600", "bodyText": "I think it's worth putting it in a finally { } block to disconnect early even in an error case.", "author": "chanseokoh", "createdAt": "2020-01-13T21:46:30Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(boolean skip, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    skip,\n+                    Preconditions.checkNotNull(ProjectInfo.VERSION),\n+                    versionUrl,\n+                    getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));\n+      }\n+\n+      // Check time of last update check\n+      Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      connection.setConnectTimeout(3000);\n+      BufferedReader bufferedReader =\n+          new BufferedReader(\n+              new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+      String latestVersion = bufferedReader.readLine().trim();\n+      connection.disconnect();", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0NjUwNQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366046505", "bodyText": "nit: Files.deleteIfExists(configFile) and Files.deleteIfExists(lastUpdateCheck) after putting these various outside the try block. As this method is very long, I think it helps avoid the mistake of using different path.", "author": "chanseokoh", "createdAt": "2020-01-13T21:48:38Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Strings;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param skip if {@code true}, the update check itself will be skipped\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(boolean skip, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    skip,\n+                    Preconditions.checkNotNull(ProjectInfo.VERSION),\n+                    versionUrl,\n+                    getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      boolean skip, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (skip || Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    try {\n+      Path configFile = configDir.resolve(\"config.json\");\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        JsonTemplateMapper.writeTo(config, Files.newOutputStream(configFile));\n+      }\n+\n+      // Check time of last update check\n+      Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      connection.setConnectTimeout(3000);\n+      BufferedReader bufferedReader =\n+          new BufferedReader(\n+              new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+      String latestVersion = bufferedReader.readLine().trim();\n+      connection.disconnect();\n+\n+      Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+      if (currentVersion.equals(latestVersion)) {\n+        return Optional.empty();\n+      }\n+      return Optional.of(\n+          \"A new version of Jib (\"\n+              + latestVersion\n+              + \") is available (currently using \"\n+              + currentVersion\n+              + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+    } catch (IOException ex) {\n+      try {\n+        Files.deleteIfExists(configDir.resolve(\"config.json\"));\n+        Files.deleteIfExists(configDir.resolve(\"lastUpdateCheck\"));", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0ODk1OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366048959", "bodyText": "Is this necessary? If not, remove it, because it's confusing?", "author": "chanseokoh", "createdAt": "2020-01-13T21:54:16Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link UpdateChecker} */\n+@RunWith(MockitoJUnitRunner.class)\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.getRoot().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(false, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Files.setLastModifiedTime(configDir.resolve(\"lastUpdateCheck\"), modifiedTime);", "originalCommit": "14fe3f5911e2c013d56529fa2e4d23f3c33f0e2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA1MTQzMA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366051430", "bodyText": "Oops, old stuff I didn't clean up.", "author": "TadCordle", "createdAt": "2020-01-13T21:59:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA0ODk1OQ=="}], "type": "inlineReview"}, {"oid": "55b0f1d76324201c34944f9ab5417a40a7c8ee45", "url": "https://github.com/GoogleContainerTools/jib/commit/55b0f1d76324201c34944f9ab5417a40a7c8ee45", "message": "Comments", "committedDate": "2020-01-13T22:05:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA4MDc5MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366080791", "bodyText": "I still kinda think this would be cleaner if we skip wasn't part of the update checker mechanic and we only created an update checker as needed.\nOptional<UpdateChecker> updaterChecker = MavenUpdateChecker.for(projectProperties, getLog())\n\n...\n...\nupdateChecker.ifPresent().finish....", "author": "loosebazooka", "createdAt": "2020-01-13T23:19:46Z", "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildDockerMojo.java", "diffHunk": "@@ -73,6 +75,9 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n     MavenProjectProperties projectProperties =\n         MavenProjectProperties.getForProject(\n             getProject(), getSession(), getLog(), tempDirectoryProvider);\n+    UpdateChecker updateChecker =", "originalCommit": "55b0f1d76324201c34944f9ab5417a40a7c8ee45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA4MTE1MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366081151", "bodyText": "the  MojoCommon.VERSION_URL could be part of MavenUpdateChecker too", "author": "loosebazooka", "createdAt": "2020-01-13T23:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA4MDc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA4MTMyMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366081321", "bodyText": "or something like this (not necessarily this exactly)", "author": "loosebazooka", "createdAt": "2020-01-13T23:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA4MDc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQwMzMxNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366403314", "bodyText": "I'd rather not make a new class, but I agree the Optional approach could be better, so I'll try something like that.", "author": "TadCordle", "createdAt": "2020-01-14T15:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA4MDc5MQ=="}], "type": "inlineReview"}, {"oid": "bb25ca9768f6960807de68c783ce90298b7d8cea", "url": "https://github.com/GoogleContainerTools/jib/commit/bb25ca9768f6960807de68c783ce90298b7d8cea", "message": "Extract 'skip'", "committedDate": "2020-01-14T16:21:33Z", "type": "commit"}, {"oid": "789defa56482019432632f6bc98aa4baaffbbf0b", "url": "https://github.com/GoogleContainerTools/jib/commit/789defa56482019432632f6bc98aa4baaffbbf0b", "message": "Fix reversed logic", "committedDate": "2020-01-14T20:00:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMTQ5Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366611492", "bodyText": "oh this is cool, didn't know you could do that with optionals.", "author": "loosebazooka", "createdAt": "2020-01-14T22:41:46Z", "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/BuildDockerTask.java", "diffHunk": "@@ -145,6 +150,12 @@ public void buildDocker()\n \n     } finally {\n       tempDirectoryProvider.close();\n+      updateChecker\n+          .flatMap(UpdateChecker::finishUpdateCheck)", "originalCommit": "789defa56482019432632f6bc98aa4baaffbbf0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366613466", "bodyText": "I'm not sure I understand what's going on here? why do we delete these files?", "author": "loosebazooka", "createdAt": "2020-01-14T22:47:19Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      try {\n+        Files.deleteIfExists(configFile);", "originalCommit": "789defa56482019432632f6bc98aa4baaffbbf0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NjEyNg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366956126", "bodyText": "Was suggested by @chanseokoh to avoid corruption in case the thread is interrupted while writing to a file.", "author": "TadCordle", "createdAt": "2020-01-15T15:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2MDQyMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366960422", "bodyText": "About corruption: theoretically the files are shared resources among multiple concurrent Jib runs, although the likelihood is very low that the files are concurrently modified. That's why I am OK with not doing any synchronization for a shared object here.\nI'm not saying that this would be the only source of possible corruption. But if the files were ever corrupted somehow, Jib would not be able to recover (it will just throw an IOExcetion again and again) without deleting the corrupted files. I just want it to be able to recover.", "author": "chanseokoh", "createdAt": "2020-01-15T16:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2MTMzOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366961338", "bodyText": "And yeah, I think thread interrupted might be another source of possible corruption.", "author": "chanseokoh", "createdAt": "2020-01-15T16:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1OTQzNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367059434", "bodyText": "deleting the config file could potentially result in the user's non-update-check config to be deleted no?", "author": "loosebazooka", "createdAt": "2020-01-15T19:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1OTU4Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367059587", "bodyText": "I don't think we should ever delete the user's config file.", "author": "loosebazooka", "createdAt": "2020-01-15T19:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1OTg3MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367059870", "bodyText": "We can output a message saying your config is corrupt? And for the user to go clean it up?", "author": "loosebazooka", "createdAt": "2020-01-15T19:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2NDcwNQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367064705", "bodyText": "Yeah, I wanted a simple solution, but in principle I agree it's better to let the user delete the files.", "author": "chanseokoh", "createdAt": "2020-01-15T19:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2Njg2OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367066868", "bodyText": "Also, if it is not corruption but a temporary IO error, I think it still makes sense to report the error saying that Jib couldn't read its config file (but not a fatal error).", "author": "chanseokoh", "createdAt": "2020-01-15T19:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNDE5OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366614199", "bodyText": "I think that this just tries to interrupt the process running the thread if it's still running? Do we need to check in performUpdateCheck that the thread hasn't been interrupted?", "author": "loosebazooka", "createdAt": "2020-01-14T22:49:25Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      try {\n+        Files.deleteIfExists(configFile);\n+        Files.deleteIfExists(lastUpdateCheck);\n+      } catch (IOException ignored) {\n+        // Fail silently\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  /**\n+   * Returns the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   * otherwise returns the default config directory.\n+   *\n+   * @return the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   *     otherwise returns the default config directory.\n+   */\n+  private static Path getConfigDir() {\n+    String configDirProperty = System.getProperty(PropertyNames.CONFIG_DIRECTORY);\n+    if (!Strings.isNullOrEmpty(configDirProperty)) {\n+      return Paths.get(configDirProperty);\n+    }\n+    return XdgDirectories.getConfigHome();\n+  }\n+\n+  private final Future<Optional<String>> updateMessageFuture;\n+\n+  @VisibleForTesting\n+  UpdateChecker(Future<Optional<String>> updateMessageFuture) {\n+    this.updateMessageFuture = updateMessageFuture;\n+  }\n+\n+  /**\n+   * Returns a message indicating Jib should be upgraded if the check succeeded and the current\n+   * version is outdated, or returns {@code Optional.empty()} if the check was interrupted or did\n+   * not determine that a later version was available.\n+   *\n+   * @return the {@link Optional} message to upgrade Jib if a later version was found, else {@code\n+   *     Optional.empty()}.\n+   */\n+  public Optional<String> finishUpdateCheck() {\n+    if (updateMessageFuture.isDone()) {\n+      try {\n+        return updateMessageFuture.get();\n+      } catch (InterruptedException | ExecutionException ignored) {\n+        // Fail silently;\n+      }\n+    }\n+    updateMessageFuture.cancel(true);", "originalCommit": "789defa56482019432632f6bc98aa4baaffbbf0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxOTMxNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366619314", "bodyText": "I regarded this as an optional thing which may have virtually no effect in many cases. @TadCordle tested and observed that the build terminates right away even if \"the thread is still alive.\" (#2214 (comment)). However, I just realized that the test using a single Thread.sleep() to simulate a  long-running thread is flawed, since I believe Thread.sleep() will unblock (by throwing InterruptedException) when a future is cancelled. @TadCordle the code to test this should look like this:\nwhile (true) {\n  try {\n    Thread.sleep(600000);\n  } catch (Exception e) {}\n}", "author": "chanseokoh", "createdAt": "2020-01-14T23:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNDE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1ODcwMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366958701", "bodyText": "Still seems to terminate the thread immediately with the new test code.", "author": "TadCordle", "createdAt": "2020-01-15T15:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNDE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2MTgzOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366961839", "bodyText": "That's good. For both Maven and Gradle?", "author": "chanseokoh", "createdAt": "2020-01-15T16:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNDE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2MzEyNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r366963124", "bodyText": "Yup \ud83d\udc4d", "author": "TadCordle", "createdAt": "2020-01-15T16:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNDE5OQ=="}], "type": "inlineReview"}, {"oid": "3a7ab0f9d2bc873ddfadb11ee1cfcde66523a57b", "url": "https://github.com/GoogleContainerTools/jib/commit/3a7ab0f9d2bc873ddfadb11ee1cfcde66523a57b", "message": "Improve maven formatting", "committedDate": "2020-01-15T16:18:37Z", "type": "commit"}, {"oid": "9aa3c32929106d6c7cb9112b052573f572daa9da", "url": "https://github.com/GoogleContainerTools/jib/commit/9aa3c32929106d6c7cb9112b052573f572daa9da", "message": "Share gradle code", "committedDate": "2020-01-15T16:24:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MDUwMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367060503", "bodyText": "I feel like a bad configfile should be caught here -- and the user should be informed that it is indeed corrupt. We then should not do an update because there's no way to know if they had previously configured it or not.", "author": "loosebazooka", "createdAt": "2020-01-15T19:21:22Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }", "originalCommit": "9aa3c32929106d6c7cb9112b052573f572daa9da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MTQ3Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367061472", "bodyText": "perhaps another catch here to cleanup this config file (if we're writing it)", "author": "loosebazooka", "createdAt": "2020-01-15T19:23:29Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {", "originalCommit": "9aa3c32929106d6c7cb9112b052573f572daa9da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2NDA1NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367064054", "bodyText": "Following @loosebazooka's suggestion, getting here most likely means the file is corrupted.", "author": "chanseokoh", "createdAt": "2020-01-15T19:28:49Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+    try {\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        ConfigJsonTemplate config =\n+            JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+        if (config.disableUpdateCheck) {\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        String fileContents =\n+            new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+        try {\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException ex) {\n+          // Ignore parse failure; assume update check hasn't been performed", "originalCommit": "9aa3c32929106d6c7cb9112b052573f572daa9da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3NDA2Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367074066", "bodyText": "I think we can auto-delete this one. The user probably shouldn't be touching lastUpdateCheck.", "author": "TadCordle", "createdAt": "2020-01-15T19:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2NDA1NA=="}], "type": "inlineReview"}, {"oid": "746d7f40aec8f286b7b9cffa8e132459f560e777", "url": "https://github.com/GoogleContainerTools/jib/commit/746d7f40aec8f286b7b9cffa8e132459f560e777", "message": "More explicit error handling", "committedDate": "2020-01-15T20:06:27Z", "type": "commit"}, {"oid": "23d9f473aefb4cb717bc619b59adfd7e51e66af8", "url": "https://github.com/GoogleContainerTools/jib/commit/23d9f473aefb4cb717bc619b59adfd7e51e66af8", "message": "Javadoc and better warning message", "committedDate": "2020-01-15T20:09:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4MzE4Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367083183", "bodyText": "perhaps we should log debug?", "author": "loosebazooka", "createdAt": "2020-01-15T20:10:53Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -137,13 +153,8 @@ public static UpdateChecker checkForUpdate(String versionUrl) {\n         connection.disconnect();\n       }\n \n-    } catch (IOException ex) {\n-      try {\n-        Files.deleteIfExists(configFile);\n-        Files.deleteIfExists(lastUpdateCheck);\n-      } catch (IOException ignored) {\n-        // Fail silently\n-      }\n+    } catch (IOException ignored) {\n+      // Fail other exceptions silently", "originalCommit": "746d7f40aec8f286b7b9cffa8e132459f560e777", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4MzUxNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367083517", "bodyText": "or maybe that's not useful...", "author": "loosebazooka", "createdAt": "2020-01-15T20:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4MzE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4Mzk2NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367083964", "bodyText": "Add the exception message too? I guess better than nothing.", "author": "chanseokoh", "createdAt": "2020-01-15T20:12:43Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param warningLogger {@link Consumer} used to log warnings\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<String> warningLogger, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    warningLogger,\n+                    Verify.verifyNotNull(ProjectInfo.VERSION),\n+                    versionUrl,\n+                    getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<String> warningLogger, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          warningLogger.accept(\n+              \"Failed to read global Jib config; you may need to fix or delete \" + configFile);", "originalCommit": "23d9f473aefb4cb717bc619b59adfd7e51e66af8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "28f4a8c210baed8f40a682860e664e678e0eb594", "url": "https://github.com/GoogleContainerTools/jib/commit/28f4a8c210baed8f40a682860e664e678e0eb594", "message": "More logging", "committedDate": "2020-01-15T20:34:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NzEzNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367147134", "bodyText": "I don't think I know what this is about?", "author": "loosebazooka", "createdAt": "2020-01-15T22:44:53Z", "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/TaskCommon.java", "diffHunk": "@@ -63,7 +87,8 @@ static void disableHttpLogging() {\n     OutputEventListener defaultOutputEventListener = context.getOutputEventListener();\n     context.setOutputEventListener(\n         event -> {\n-          LogEvent logEvent = (LogEvent) event;\n+          org.gradle.internal.logging.events.LogEvent logEvent =", "originalCommit": "28f4a8c210baed8f40a682860e664e678e0eb594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NzQ4Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367147487", "bodyText": "Gradle and Jib both have classes named LogEvent, so I opted to use the full name for this one.", "author": "TadCordle", "createdAt": "2020-01-15T22:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NzEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NzUzMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367147532", "bodyText": "oh I figured it out.", "author": "loosebazooka", "createdAt": "2020-01-15T22:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0NzEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NTQ1NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367685454", "bodyText": "I think this should be in it's own class outside of UpdateChecker (if we're going to be eventually using a common config file for jib), but we can do this in another PR.", "author": "loosebazooka", "createdAt": "2020-01-16T22:35:04Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting", "originalCommit": "28f4a8c210baed8f40a682860e664e678e0eb594", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NjMxNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367686314", "bodyText": "Similarly we should think about how we want to read configFile earlier (maybe as part of project properties?)?", "author": "loosebazooka", "createdAt": "2020-01-16T22:37:39Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");", "originalCommit": "28f4a8c210baed8f40a682860e664e678e0eb594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MDM3Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367690373", "bodyText": "Will do later if we end up using the config file for anything other than update checks.", "author": "TadCordle", "createdAt": "2020-01-16T22:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NjMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NzMwMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367687302", "bodyText": "can we close the connection here to interrupt a read?", "author": "loosebazooka", "createdAt": "2020-01-16T22:40:14Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          Files.deleteIfExists(configFile);\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          Files.delete(lastUpdateCheck);\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      log.accept(LogEvent.debug(\"Update check failed; \" + ex.getMessage()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  /**\n+   * Returns the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   * otherwise returns the default config directory.\n+   *\n+   * @return the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   *     otherwise returns the default config directory.\n+   */\n+  private static Path getConfigDir() {\n+    String configDirProperty = System.getProperty(PropertyNames.CONFIG_DIRECTORY);\n+    if (!Strings.isNullOrEmpty(configDirProperty)) {\n+      return Paths.get(configDirProperty);\n+    }\n+    return XdgDirectories.getConfigHome();\n+  }\n+\n+  private final Future<Optional<String>> updateMessageFuture;\n+\n+  @VisibleForTesting\n+  UpdateChecker(Future<Optional<String>> updateMessageFuture) {\n+    this.updateMessageFuture = updateMessageFuture;\n+  }\n+\n+  /**\n+   * Returns a message indicating Jib should be upgraded if the check succeeded and the current\n+   * version is outdated, or returns {@code Optional.empty()} if the check was interrupted or did\n+   * not determine that a later version was available.\n+   *\n+   * @return the {@link Optional} message to upgrade Jib if a later version was found, else {@code\n+   *     Optional.empty()}.\n+   */\n+  public Optional<String> finishUpdateCheck() {\n+    if (updateMessageFuture.isDone()) {\n+      try {\n+        return updateMessageFuture.get();\n+      } catch (InterruptedException | ExecutionException ignored) {\n+        // Fail silently;\n+      }\n+    }\n+    updateMessageFuture.cancel(true);", "originalCommit": "28f4a8c210baed8f40a682860e664e678e0eb594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MTMwMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367691302", "bodyText": "Is it necessary? updateMessageFuture.cancel(true) should interrupt the read regardless, shouldn't it? Or will the connection be left open if we interrupt it and don't disconnect here?", "author": "TadCordle", "createdAt": "2020-01-16T22:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDQxNg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367694416", "bodyText": "I'm not really concerned about this. Looks like the Maven/Gradle JVM always terminates no matter what I do in the update checker thread. And particularly it doesn't matter much to close the connection if the build is about to exit.", "author": "chanseokoh", "createdAt": "2020-01-16T23:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcwMzgzMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367703832", "bodyText": "I think the 3 second timeout is generally enough.", "author": "loosebazooka", "createdAt": "2020-01-16T23:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NzMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5Mjk5OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367692998", "bodyText": "It's a minor point, but I guess there's no need to generate the file. We can remove this whole section?", "author": "chanseokoh", "createdAt": "2020-01-16T22:58:02Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          Files.deleteIfExists(configFile);\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+        }", "originalCommit": "28f4a8c210baed8f40a682860e664e678e0eb594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NTc4MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367695780", "bodyText": "I want to generate the file automatically so it's easier to opt-out when the user goes looking for it.", "author": "TadCordle", "createdAt": "2020-01-16T23:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5Mjk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NjQzNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367696437", "bodyText": "Ah, that's a good point.", "author": "chanseokoh", "createdAt": "2020-01-16T23:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5Mjk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MzgzNQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367693835", "bodyText": "I'd put this before Files.delete(). If we got here due to IOException, there's good chance Files.delete() will fail too. deleteIfExists() will be safer?", "author": "chanseokoh", "createdAt": "2020-01-16T23:00:40Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          Files.deleteIfExists(configFile);\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          Files.delete(lastUpdateCheck);\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));", "originalCommit": "28f4a8c210baed8f40a682860e664e678e0eb594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NjA3Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367696072", "bodyText": "Will deleteIfExists() make a difference when this is inside a block that checks if the file exists?", "author": "TadCordle", "createdAt": "2020-01-16T23:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MzgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NjUyNQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367696525", "bodyText": "Ah, you're right.", "author": "chanseokoh", "createdAt": "2020-01-16T23:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MzgzNQ=="}], "type": "inlineReview"}, {"oid": "946626a35f3b27aac3f6016fc44da8c734b31c69", "url": "https://github.com/GoogleContainerTools/jib/commit/946626a35f3b27aac3f6016fc44da8c734b31c69", "message": "Log before deletion", "committedDate": "2020-01-16T23:11:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMjQ2MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367732461", "bodyText": "Optional, but it seems a bit unusual to have the non-expected case come last", "author": "briandealwis", "createdAt": "2020-01-17T01:33:11Z", "path": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/MojoCommon.java", "diffHunk": "@@ -40,6 +44,27 @@\n   @VisibleForTesting\n   public static final String REQUIRED_VERSION_PROPERTY_NAME = \"jib.requiredVersion\";\n \n+  public static final String VERSION_URL = \"https://storage.googleapis.com/jib-versions/jib-maven\";\n+\n+  static Optional<UpdateChecker> newUpdateChecker(ProjectProperties projectProperties, Log logger) {\n+    if (!projectProperties.isOffline() && logger.isInfoEnabled()) {\n+      return Optional.of(UpdateChecker.checkForUpdate(projectProperties::log, VERSION_URL));\n+    }\n+    return Optional.empty();", "originalCommit": "946626a35f3b27aac3f6016fc44da8c734b31c69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzA0OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367733048", "bodyText": "I guess this is plugins.common but there may be some consumer that wants to provide a execution service", "author": "briandealwis", "createdAt": "2020-01-17T01:35:53Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();", "originalCommit": "946626a35f3b27aac3f6016fc44da8c734b31c69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2NzM3MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367967370", "bodyText": "It made some sense to me to manage the lifecycle within the updater (so we could shut it down). But I guess taskcommon could do that.", "author": "loosebazooka", "createdAt": "2020-01-17T14:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzA0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4MDE5Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367980192", "bodyText": "It seems a bit unnecessary to me at the moment; like you said, this is plugins common, so we're the only consumer. Wouldn't it just lead to things being more spread out/more duplicate code creating creating an ExecutorService for the updater?", "author": "TadCordle", "createdAt": "2020-01-17T15:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzA0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwNTUwNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368005507", "bodyText": "As a framework, this code shouldn't be making that decision (IMHO).", "author": "briandealwis", "createdAt": "2020-01-17T15:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzc2Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367733762", "bodyText": "If you passed in the instant, that would make this more easily tested", "author": "briandealwis", "createdAt": "2020-01-17T01:39:15Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {", "originalCommit": "946626a35f3b27aac3f6016fc44da8c734b31c69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyNTQwOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367925409", "bodyText": "It's easier for us to make the decision to shut it down this way.", "author": "loosebazooka", "createdAt": "2020-01-17T13:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NDY5OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367954698", "bodyText": "I just meant pass in the Instant as an argument?  @TadCordle had been asking about testing.  Or alternatively pass in the Clock.", "author": "briandealwis", "createdAt": "2020-01-17T14:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2NjgyOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367966829", "bodyText": "I commented on the wrong comment... Oops. I meant for the executor", "author": "loosebazooka", "createdAt": "2020-01-17T14:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3ODg5OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367978898", "bodyText": "@briandealwis I think it might help for unit testing, but I think that's in good enough shape right now. The harder problem is integration testing.", "author": "TadCordle", "createdAt": "2020-01-17T15:00:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNDIwMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368014202", "bodyText": "This class is hard to test because all of the logic is hard-coded into this single method.  Extract the last-check time determination, the current-time generation (Supplier), the modification time comparison (BiPredicate), and this class should be testable through unit tests.", "author": "briandealwis", "createdAt": "2020-01-17T16:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczMzc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNDIxMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r367734213", "bodyText": "Could we direct them to the change log?", "author": "briandealwis", "createdAt": "2020-01-17T01:41:30Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+          Files.delete(lastUpdateCheck);\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        String latestVersion = bufferedReader.readLine().trim();\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(latestVersion)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + latestVersion\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");", "originalCommit": "946626a35f3b27aac3f6016fc44da8c734b31c69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1fba58ae41fd747e559d54ede4ce45a97675c6f", "url": "https://github.com/GoogleContainerTools/jib/commit/b1fba58ae41fd747e559d54ede4ce45a97675c6f", "message": "Comments", "committedDate": "2020-01-17T15:47:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwNzM1NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368007354", "bodyText": "This method is quite large and would benefit from being broken down.", "author": "briandealwis", "createdAt": "2020-01-17T15:55:08Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(", "originalCommit": "946626a35f3b27aac3f6016fc44da8c734b31c69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNDY4Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368034682", "bodyText": "I'd rather keep it like this; it is a bit long, but it's straightforward to read through. Would rather avoid adding mental context switches to the code. Thoughts @loosebazooka @chanseokoh ?", "author": "TadCordle", "createdAt": "2020-01-17T16:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwNzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExMzE4OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368113189", "bodyText": "Without saying much, I think a pseudo-code-like high-level branching description as a method like below helps:\nvoid performUpdateCheck() {\n    try {\n      if (!checkGlobalConfig(...)) { // or isUpdateCheckDisabled() or something else\n        return Optional.empty();\n      }\n      if (!checkLastUpdateTime(...)) { // or isTimeToCheckBack() or something else, some name that itself gives you the confidence by just reading it that you don't even feel the necessity to look into the method code\n        return Optional.empty();\n      }\n      ... = fetchUrl(versionUrl); // or something else, the method may have a larger scope than just contacting the server, or it may just be okay to not have a method at this point\n      \n    } catch ( ... ) {\n    }\n  }\nA long method may be comfortable to the repo maintainers, but it may not be so to people new to the repo. Like, what I feel when I try to read this.", "author": "chanseokoh", "createdAt": "2020-01-17T20:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwNzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyMjY0OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368122648", "bodyText": "But since this PR has been dragged too long and having like 100+ comments, let's not do it here. It may trigger another cascade of changes.", "author": "chanseokoh", "createdAt": "2020-01-17T20:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwNzM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwOTQyOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368009429", "bodyText": "This doesn't seem right: we're returning an instance whose class name suggests that it exists to perform an update, but the operation is already in progress.  We could just return the future and make this be a static class\nOr maybe skip the executor entirely and leave how to actually schedule the check to the caller.", "author": "briandealwis", "createdAt": "2020-01-17T15:58:50Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static UpdateChecker checkForUpdate(Consumer<LogEvent> log, String versionUrl) {\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    Future<Optional<String>> messageFuture =\n+        executorService.submit(\n+            () ->\n+                performUpdateCheck(\n+                    log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+    executorService.shutdown();\n+    return new UpdateChecker(messageFuture);", "originalCommit": "946626a35f3b27aac3f6016fc44da8c734b31c69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTU4Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368021582", "bodyText": "2020", "author": "loosebazooka", "createdAt": "2020-01-17T16:23:32Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2019 Google LLC.", "originalCommit": "b1fba58ae41fd747e559d54ede4ce45a97675c6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyMTY1Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368021657", "bodyText": "2020", "author": "loosebazooka", "createdAt": "2020-01-17T16:23:40Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2019 Google LLC.", "originalCommit": "b1fba58ae41fd747e559d54ede4ce45a97675c6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c865371ab7bf8dab76361796af551f485dc743e3", "url": "https://github.com/GoogleContainerTools/jib/commit/c865371ab7bf8dab76361796af551f485dc743e3", "message": "Copyright", "committedDate": "2020-01-17T16:34:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMTYyOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368031628", "bodyText": "Should the logger also be checked that nothing is logged?", "author": "briandealwis", "createdAt": "2020-01-17T16:44:01Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link UpdateChecker} */\n+@RunWith(MockitoJUnitRunner.class)\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.getRoot().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    Files.write(\n+        configDir.resolve(\"config.json\"),\n+        \"{\\\"disableUpdateCheck\\\":true}\".getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer =\n+        new TestWebServer(false, Collections.singletonList(\"HTTP/1.1 400 Bad Request\\n\\n\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(\n+              ignored -> {}, \"1.0.2\", badServer.getEndpoint(), configDir);", "originalCommit": "c865371ab7bf8dab76361796af551f485dc743e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzQ3MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368033471", "bodyText": "Can we also check for invalid content in the config.json, and that the lastUpdateCheck file is removed on invalid content too.", "author": "briandealwis", "createdAt": "2020-01-17T16:47:35Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link UpdateChecker} */\n+@RunWith(MockitoJUnitRunner.class)\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.getRoot().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    Files.write(\n+        configDir.resolve(\"config.json\"),\n+        \"{\\\"disableUpdateCheck\\\":true}\".getBytes(StandardCharsets.UTF_8));", "originalCommit": "c865371ab7bf8dab76361796af551f485dc743e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f6a10f157d85e345e649547be19b5baa48829384", "url": "https://github.com/GoogleContainerTools/jib/commit/f6a10f157d85e345e649547be19b5baa48829384", "message": "Merge branch 'master' of github.com:GoogleContainerTools/jib into i2193-update-checks", "committedDate": "2020-01-17T16:58:16Z", "type": "commit"}, {"oid": "f6a0aa52fd7b38b0cf1d123326e56f82ca6932e0", "url": "https://github.com/GoogleContainerTools/jib/commit/f6a0aa52fd7b38b0cf1d123326e56f82ca6932e0", "message": "More tests", "committedDate": "2020-01-17T17:16:50Z", "type": "commit"}, {"oid": "a7b70a8cf465db9b498161041c6c16dde6d99a8b", "url": "https://github.com/GoogleContainerTools/jib/commit/a7b70a8cf465db9b498161041c6c16dde6d99a8b", "message": "Stuff", "committedDate": "2020-01-17T17:36:52Z", "type": "commit"}, {"oid": "e8befde7c10b88ddbabcb55bc41154817a456ab7", "url": "https://github.com/GoogleContainerTools/jib/commit/e8befde7c10b88ddbabcb55bc41154817a456ab7", "message": "Javadoc", "committedDate": "2020-01-17T17:43:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNzU0NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368107544", "bodyText": "Remember I also suggested ImmediateFuture()? I think there's no good reason to do executorService.submit().", "author": "chanseokoh", "createdAt": "2020-01-17T19:48:00Z", "path": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/UpdateCheckerTest.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.api.LogEvent.Level;\n+import com.google.cloud.tools.jib.http.TestWebServer;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.FileTime;\n+import java.security.GeneralSecurityException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.contrib.java.lang.system.RestoreSystemProperties;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+/** Tests for {@link UpdateChecker} */\n+@RunWith(MockitoJUnitRunner.class)\n+public class UpdateCheckerTest {\n+\n+  @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private TestWebServer testWebServer;\n+  private Path configDir;\n+\n+  @Before\n+  public void setUp()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    testWebServer =\n+        new TestWebServer(\n+            false, Collections.singletonList(\"HTTP/1.1 200 OK\\nContent-Length:5\\n\\n2.0.0\"), 1);\n+    configDir = temporaryFolder.getRoot().toPath();\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    testWebServer.close();\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_newVersionFound() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_onLatest() throws IOException {\n+    Instant before = Instant.now();\n+    setupConfigAndLastUpdateCheck();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"2.0.0\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_noConfigOrLastUpdateCheck() throws IOException {\n+    Instant before = Instant.now();\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_lastUpdateCheckTooSoon() throws IOException {\n+    FileTime modifiedTime = FileTime.from(Instant.now().minusSeconds(12));\n+    setupConfigAndLastUpdateCheck();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"),\n+        modifiedTime.toString().getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+\n+    // lastUpdateCheck should not have changed\n+    String lastUpdateTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertEquals(Instant.parse(lastUpdateTime), modifiedTime.toInstant());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_systemProperty() {\n+    System.setProperty(PropertyNames.DISABLE_UPDATE_CHECKS, \"true\");\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_configDisabled() throws IOException {\n+    Files.write(\n+        configDir.resolve(\"config.json\"),\n+        \"{\\\"disableUpdateCheck\\\":true}\".getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_badConfig() throws IOException {\n+    Files.write(\n+        configDir.resolve(\"config.json\"), \"corrupt config\".getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    Assert.assertFalse(message.isPresent());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_badLastUpdateTime() throws IOException {\n+    Instant before = Instant.now();\n+    Files.write(\n+        configDir.resolve(\"lastUpdateCheck\"), \"bad timestamp\".getBytes(StandardCharsets.UTF_8));\n+    Optional<String> message =\n+        UpdateChecker.performUpdateCheck(\n+            ignored -> {}, \"1.0.2\", testWebServer.getEndpoint(), configDir);\n+    String modifiedTime =\n+        new String(\n+            Files.readAllBytes(configDir.resolve(\"lastUpdateCheck\")), StandardCharsets.UTF_8);\n+    Assert.assertTrue(Instant.parse(modifiedTime).isAfter(before));\n+    Assert.assertTrue(message.isPresent());\n+    Assert.assertEquals(\n+        \"A new version of Jib (2.0.0) is available (currently using 1.0.2). Update your build \"\n+            + \"configuration to use the latest features and fixes!\",\n+        message.get());\n+  }\n+\n+  @Test\n+  public void testPerformUpdateCheck_failSilently()\n+      throws InterruptedException, GeneralSecurityException, URISyntaxException, IOException {\n+    try (TestWebServer badServer =\n+        new TestWebServer(false, Collections.singletonList(\"HTTP/1.1 400 Bad Request\\n\\n\"), 1)) {\n+      Optional<String> message =\n+          UpdateChecker.performUpdateCheck(\n+              logEvent -> {\n+                Assert.assertEquals(logEvent.getLevel(), Level.DEBUG);\n+                Assert.assertTrue(logEvent.getMessage().contains(\"Update check failed; \"));\n+              },\n+              \"1.0.2\",\n+              badServer.getEndpoint(),\n+              configDir);\n+      Assert.assertFalse(message.isPresent());\n+    }\n+  }\n+\n+  @Test\n+  public void testFinishUpdateCheck_success() {\n+    ExecutorService executorService = MoreExecutors.newDirectExecutorService();\n+    Future<Optional<String>> updateCheckFuture = executorService.submit(() -> Optional.of(\"Hello\"));", "originalCommit": "e8befde7c10b88ddbabcb55bc41154817a456ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExNjY0OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r368116648", "bodyText": "If newUpdateChecker creates Executors.newSingleThreadExecutor(), let's make it \"close\" it, i.e., calling shutdown() in newUpdateChecker. And although I don't care much since I know our plugins just terminate without even calling shutdown(), I guess it doesn't harm to guarantee it in finally.\n} finally {\n   executorService.shutdown();\n}", "author": "chanseokoh", "createdAt": "2020-01-17T20:11:48Z", "path": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/TaskCommon.java", "diffHunk": "@@ -17,25 +17,58 @@\n package com.google.cloud.tools.jib.gradle;\n \n import com.google.api.client.http.HttpTransport;\n+import com.google.cloud.tools.jib.ProjectInfo;\n import com.google.cloud.tools.jib.api.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.FilePermissions;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.plugins.common.ProjectProperties;\n+import com.google.cloud.tools.jib.plugins.common.UpdateChecker;\n+import com.google.common.util.concurrent.Futures;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n import java.util.logging.Level;\n import javax.annotation.Nullable;\n import org.gradle.api.Project;\n import org.gradle.api.Task;\n import org.gradle.api.UnknownTaskException;\n+import org.gradle.api.logging.Logger;\n import org.gradle.api.plugins.WarPlugin;\n import org.gradle.api.tasks.TaskProvider;\n-import org.gradle.internal.logging.events.LogEvent;\n import org.gradle.internal.logging.events.OutputEventListener;\n import org.gradle.internal.logging.slf4j.OutputEventListenerBackedLoggerContext;\n import org.slf4j.LoggerFactory;\n \n /** Collection of common methods to share between Gradle tasks. */\n class TaskCommon {\n \n+  public static final String VERSION_URL = \"https://storage.googleapis.com/jib-versions/jib-gradle\";\n+\n+  static Future<Optional<String>> newUpdateChecker(\n+      ProjectProperties projectProperties, Logger logger) {\n+    if (projectProperties.isOffline() || !logger.isLifecycleEnabled()) {\n+      return Futures.immediateFuture(Optional.empty());\n+    }\n+    return UpdateChecker.checkForUpdate(\n+        Executors.newSingleThreadExecutor(), projectProperties::log, VERSION_URL);", "originalCommit": "e8befde7c10b88ddbabcb55bc41154817a456ab7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0c94c7660639458d2e617486ddf1346fc16e67f1", "url": "https://github.com/GoogleContainerTools/jib/commit/0c94c7660639458d2e617486ddf1346fc16e67f1", "message": "Json", "committedDate": "2020-01-17T20:26:58Z", "type": "commit"}, {"oid": "ae6288ccd5b1bbe54b2dad2a2d710f76277cb216", "url": "https://github.com/GoogleContainerTools/jib/commit/ae6288ccd5b1bbe54b2dad2a2d710f76277cb216", "message": "More code", "committedDate": "2020-01-17T20:33:34Z", "type": "commit"}, {"oid": "d95d34bd3aaaae05e986bc69760169e7e925aec0", "url": "https://github.com/GoogleContainerTools/jib/commit/d95d34bd3aaaae05e986bc69760169e7e925aec0", "message": "Fix", "committedDate": "2020-01-17T20:45:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA3ODk0Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369078947", "bodyText": "any reason for this?", "author": "loosebazooka", "createdAt": "2020-01-21T15:44:43Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/PluginConfigurationProcessor.java", "diffHunk": "@@ -166,10 +166,8 @@ public static JibBuildRunner createJibBuildRunnerForRegistryImage(\n         rawConfiguration.getToCredHelper().orElse(null));\n \n     boolean alwaysCacheBaseImage =\n-        Boolean.valueOf(\n-            rawConfiguration\n-                .getProperty(PropertyNames.ALWAYS_CACHE_BASE_IMAGE)\n-                .orElse(Boolean.FALSE.toString()));\n+        Boolean.parseBoolean(\n+            rawConfiguration.getProperty(PropertyNames.ALWAYS_CACHE_BASE_IMAGE).orElse(\"false\"));", "originalCommit": "d95d34bd3aaaae05e986bc69760169e7e925aec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4MjYwNg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369082606", "bodyText": "Just a cleanup thing I noticed.", "author": "TadCordle", "createdAt": "2020-01-21T15:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA3ODk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA3OTY1Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369079652", "bodyText": "what happens when the verify fails?", "author": "loosebazooka", "createdAt": "2020-01-21T15:45:53Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /** JSON template for content downloaded during version check. */\n+  private static class VersionJsonTemplate implements JsonTemplate {\n+    private String latest = \"\";\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param executorService the {@link ExecutorService}\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static Future<Optional<String>> checkForUpdate(\n+      ExecutorService executorService, Consumer<LogEvent> log, String versionUrl) {\n+    return executorService.submit(\n+        () ->\n+            performUpdateCheck(\n+                log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));", "originalCommit": "d95d34bd3aaaae05e986bc69760169e7e925aec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4NzI2Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369087262", "bodyText": "I added it to make nullaway happy. Will ProjectInfo.VERSION every actually be null in practice?", "author": "TadCordle", "createdAt": "2020-01-21T15:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA3OTY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA5MDM1NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369090355", "bodyText": "No. As long as the code runs inside a JAR (which is the case, our plugins are downloaded as a JAR), I believe this is never null. However, I think this is null in our tests. We should be good.", "author": "chanseokoh", "createdAt": "2020-01-21T16:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA3OTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4MTE3MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369081170", "bodyText": "I thought we had some sort of static class do this?", "author": "loosebazooka", "createdAt": "2020-01-21T15:48:10Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /** JSON template for content downloaded during version check. */\n+  private static class VersionJsonTemplate implements JsonTemplate {\n+    private String latest = \"\";\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param executorService the {@link ExecutorService}\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static Future<Optional<String>> checkForUpdate(\n+      ExecutorService executorService, Consumer<LogEvent> log, String versionUrl) {\n+    return executorService.submit(\n+        () ->\n+            performUpdateCheck(\n+                log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+          Files.delete(lastUpdateCheck);\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        VersionJsonTemplate version =\n+            JsonTemplateMapper.readJson(\n+                bufferedReader.readLine().trim(), VersionJsonTemplate.class);\n+        Files.write(lastUpdateCheck, Instant.now().toString().getBytes(StandardCharsets.UTF_8));\n+        if (currentVersion.equals(version.latest)) {\n+          return Optional.empty();\n+        }\n+        return Optional.of(\n+            \"A new version of Jib (\"\n+                + version.latest\n+                + \") is available (currently using \"\n+                + currentVersion\n+                + \"). Update your build configuration to use the latest features and fixes!\");\n+\n+      } finally {\n+        connection.disconnect();\n+      }\n+\n+    } catch (IOException ex) {\n+      log.accept(LogEvent.debug(\"Update check failed; \" + ex.getMessage()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  /**\n+   * Returns a message indicating Jib should be upgraded if the check succeeded and the current\n+   * version is outdated, or returns {@code Optional.empty()} if the check was interrupted or did\n+   * not determine that a later version was available.\n+   *\n+   * @param updateMessageFuture the {@link Future} returned by {@link UpdateChecker#checkForUpdate}\n+   * @return the {@link Optional} message to upgrade Jib if a later version was found, else {@code\n+   *     Optional.empty()}.\n+   */\n+  public static Optional<String> finishUpdateCheck(Future<Optional<String>> updateMessageFuture) {\n+    if (updateMessageFuture.isDone()) {\n+      try {\n+        return updateMessageFuture.get();\n+      } catch (InterruptedException | ExecutionException ignored) {\n+        // Fail silently;\n+      }\n+    }\n+    updateMessageFuture.cancel(true);\n+    return Optional.empty();\n+  }\n+\n+  /**\n+   * Returns the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   * otherwise returns the default config directory.\n+   *\n+   * @return the config directory set by {@link PropertyNames#CONFIG_DIRECTORY} if not null,\n+   *     otherwise returns the default config directory.\n+   */\n+  private static Path getConfigDir() {", "originalCommit": "d95d34bd3aaaae05e986bc69760169e7e925aec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4NDk5MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369084990", "bodyText": "This includes some extra system properties stuff, I guess I can move that into the static class.", "author": "TadCordle", "createdAt": "2020-01-21T15:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4MTE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4NTgyOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369085829", "bodyText": "Oh wait sorry, this uses system property as part of the plugin frontend, so it doesn't belong in jib core.", "author": "TadCordle", "createdAt": "2020-01-21T15:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4MTE3MA=="}], "type": "inlineReview"}, {"oid": "216bda4c48975c84729b6e9a123cc23b65157224", "url": "https://github.com/GoogleContainerTools/jib/commit/216bda4c48975c84729b6e9a123cc23b65157224", "message": "Ignore unknown fields from pulled json", "committedDate": "2020-01-21T15:49:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA4NDYwOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369084608", "bodyText": "readLine() seems unsafe. It will break if our JSON file is not a single-line JSON. I think you used BufferedReader only to use readLine(), so perhaps it's no longer necessary. Maybe use InputStream directly?", "author": "chanseokoh", "createdAt": "2020-01-21T15:53:30Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /** JSON template for content downloaded during version check. */\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  private static class VersionJsonTemplate implements JsonTemplate {\n+    private String latest = \"\";\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param executorService the {@link ExecutorService}\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static Future<Optional<String>> checkForUpdate(\n+      ExecutorService executorService, Consumer<LogEvent> log, String versionUrl) {\n+    return executorService.submit(\n+        () ->\n+            performUpdateCheck(\n+                log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+          Files.delete(lastUpdateCheck);\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();\n+      try {\n+        connection.setConnectTimeout(3000);\n+        BufferedReader bufferedReader =\n+            new BufferedReader(\n+                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));\n+        VersionJsonTemplate version =\n+            JsonTemplateMapper.readJson(\n+                bufferedReader.readLine().trim(), VersionJsonTemplate.class);", "originalCommit": "216bda4c48975c84729b6e9a123cc23b65157224", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "05bd091cf4f3228fcd6b46f2d7241c21668179af", "url": "https://github.com/GoogleContainerTools/jib/commit/05bd091cf4f3228fcd6b46f2d7241c21668179af", "message": "Input stream", "committedDate": "2020-01-21T15:59:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MjE4NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369572185", "bodyText": "I realize that this doesn't handle proxies.", "author": "briandealwis", "createdAt": "2020-01-22T13:56:20Z", "path": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.plugins.common;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.google.cloud.tools.jib.ProjectInfo;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.filesystem.XdgDirectories;\n+import com.google.cloud.tools.jib.json.JsonTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.format.DateTimeParseException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.function.Consumer;\n+\n+/** Checks if Jib is up-to-date. */\n+public class UpdateChecker {\n+\n+  /** JSON template for the configuration file used to enable/disable update checks. */\n+  @VisibleForTesting\n+  static class ConfigJsonTemplate implements JsonTemplate {\n+    private boolean disableUpdateCheck;\n+\n+    @VisibleForTesting\n+    void setDisableUpdateCheck(boolean disableUpdateCheck) {\n+      this.disableUpdateCheck = disableUpdateCheck;\n+    }\n+  }\n+\n+  /** JSON template for content downloaded during version check. */\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  private static class VersionJsonTemplate implements JsonTemplate {\n+    private String latest = \"\";\n+  }\n+\n+  /**\n+   * Begins checking for an update in a separate thread.\n+   *\n+   * @param executorService the {@link ExecutorService}\n+   * @param log {@link Consumer} used to log messages\n+   * @param versionUrl the location to check for the latest version\n+   * @return a new {@link UpdateChecker}\n+   */\n+  public static Future<Optional<String>> checkForUpdate(\n+      ExecutorService executorService, Consumer<LogEvent> log, String versionUrl) {\n+    return executorService.submit(\n+        () ->\n+            performUpdateCheck(\n+                log, Verify.verifyNotNull(ProjectInfo.VERSION), versionUrl, getConfigDir()));\n+  }\n+\n+  @VisibleForTesting\n+  static Optional<String> performUpdateCheck(\n+      Consumer<LogEvent> log, String currentVersion, String versionUrl, Path configDir) {\n+    // Abort if offline or update checks are disabled\n+    if (Boolean.getBoolean(PropertyNames.DISABLE_UPDATE_CHECKS)) {\n+      return Optional.empty();\n+    }\n+\n+    Path configFile = configDir.resolve(\"config.json\");\n+    Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n+\n+    try {\n+      // Check global config\n+      if (Files.exists(configFile)) {\n+        // Abort if update checks are disabled\n+        try {\n+          ConfigJsonTemplate config =\n+              JsonTemplateMapper.readJsonFromFile(configFile, ConfigJsonTemplate.class);\n+          if (config.disableUpdateCheck) {\n+            return Optional.empty();\n+          }\n+        } catch (IOException ex) {\n+          log.accept(\n+              LogEvent.warn(\n+                  \"Failed to read global Jib config: \"\n+                      + ex.getMessage()\n+                      + \"; you may need to fix or delete \"\n+                      + configFile\n+                      + \"; \"));\n+          return Optional.empty();\n+        }\n+      } else {\n+        // Generate config file if it doesn't exist\n+        ConfigJsonTemplate config = new ConfigJsonTemplate();\n+        Files.createDirectories(configDir);\n+        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+          JsonTemplateMapper.writeTo(config, outputStream);\n+        } catch (IOException ex) {\n+          // If attempt to generate new config file failed, delete so we can try again next time\n+          log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n+          Files.deleteIfExists(configFile);\n+        }\n+      }\n+\n+      // Check time of last update check\n+      if (Files.exists(lastUpdateCheck)) {\n+        try {\n+          String fileContents =\n+              new String(Files.readAllBytes(lastUpdateCheck), StandardCharsets.UTF_8);\n+          Instant modifiedTime = Instant.parse(fileContents);\n+          if (modifiedTime.plus(Duration.ofDays(1)).isAfter(Instant.now())) {\n+            return Optional.empty();\n+          }\n+        } catch (DateTimeParseException | IOException ex) {\n+          // If reading update time failed, file might be corrupt, so delete it\n+          log.accept(LogEvent.debug(\"Failed to read lastUpdateCheck; \" + ex.getMessage()));\n+          Files.delete(lastUpdateCheck);\n+        }\n+      }\n+\n+      // Check for update\n+      HttpURLConnection connection = (HttpURLConnection) new URL(versionUrl).openConnection();", "originalCommit": "05bd091cf4f3228fcd6b46f2d7241c21668179af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzODQ5OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369638498", "bodyText": "In what way?", "author": "TadCordle", "createdAt": "2020-01-22T15:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MjE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY0MzQwNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2214#discussion_r369643404", "bodyText": "Sorry should have phrased that as a question \u2014 does this handle proxies?  But it is being called after activating the MavenSettingsProxyProvider, so all good.", "author": "briandealwis", "createdAt": "2020-01-22T15:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MjE4NQ=="}], "type": "inlineReview"}]}