{"pr_number": 2233, "pr_title": "Refresh bearer auth token if expired", "pr_createdAt": "2020-01-14T23:57:58Z", "pr_url": "https://github.com/GoogleContainerTools/jib/pull/2233", "timeline": [{"oid": "9e1d08736439b3bbbaec16d262d1aef2cb4d47aa", "url": "https://github.com/GoogleContainerTools/jib/commit/9e1d08736439b3bbbaec16d262d1aef2cb4d47aa", "message": "wip", "committedDate": "2020-01-09T23:53:12Z", "type": "commit"}, {"oid": "40aee1ff5739274cbce2fc9b146faaefba86620b", "url": "https://github.com/GoogleContainerTools/jib/commit/40aee1ff5739274cbce2fc9b146faaefba86620b", "message": "wip", "committedDate": "2020-01-10T00:07:24Z", "type": "commit"}, {"oid": "5cd295b9cb38f1917b424e4fc6a46f405504ef2f", "url": "https://github.com/GoogleContainerTools/jib/commit/5cd295b9cb38f1917b424e4fc6a46f405504ef2f", "message": "refactor", "committedDate": "2020-01-13T18:06:27Z", "type": "commit"}, {"oid": "632a275554607c9d033b8415db7ba0e4c4ea7ff7", "url": "https://github.com/GoogleContainerTools/jib/commit/632a275554607c9d033b8415db7ba0e4c4ea7ff7", "message": "comment", "committedDate": "2020-01-13T18:08:55Z", "type": "commit"}, {"oid": "423bfffbaf5f5e774618f2f6ec520525081d6b2c", "url": "https://github.com/GoogleContainerTools/jib/commit/423bfffbaf5f5e774618f2f6ec520525081d6b2c", "message": "Refresh works now", "committedDate": "2020-01-13T21:34:24Z", "type": "commit"}, {"oid": "d934edd594622c228fc799f7804747e2d4b9162b", "url": "https://github.com/GoogleContainerTools/jib/commit/d934edd594622c228fc799f7804747e2d4b9162b", "message": "wip", "committedDate": "2020-01-14T22:39:16Z", "type": "commit"}, {"oid": "0c80c30d8e6e1c729031c8a9f3d75909ef46f96b", "url": "https://github.com/GoogleContainerTools/jib/commit/0c80c30d8e6e1c729031c8a9f3d75909ef46f96b", "message": "clean up", "committedDate": "2020-01-15T18:21:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMjc3Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367022777", "bodyText": "As evident from calling this method, now this new AuthenticatePushStep is a combination of Retrieve(Target)RegistryCredentialsStep (which is now gone) + old AuthenticatePushStep. You can start authenticating only after you have retrieved a credential, so I think there's no point of doing RetrieveRegistryCredentialsStep in a separate thread. So basically I renamed RetrieveRegistryCredentialsStep --> RegistryCredentialRetriever and am retrieving credentials directly here.\nOther than that, this step is doing the same thing. doBearerAuth(readOnlyAuth=false) internally creates RegistryAuthenticator and calls authenticatePush(). And if RegistryAuthenticator cannot be created, you do basic auth (fromBasicCredentials).", "author": "chanseokoh", "createdAt": "2020-01-15T17:59:06Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/AuthenticatePushStep.java", "diffHunk": "@@ -21,58 +21,53 @@\n import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n import com.google.cloud.tools.jib.builder.TimerEventDispatcher;\n import com.google.cloud.tools.jib.configuration.BuildContext;\n-import com.google.cloud.tools.jib.http.Authorization;\n-import com.google.cloud.tools.jib.registry.RegistryAuthenticator;\n+import com.google.cloud.tools.jib.registry.RegistryClient;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n import java.io.IOException;\n-import java.util.Optional;\n import java.util.concurrent.Callable;\n-import javax.annotation.Nullable;\n \n /**\n  * Authenticates push to a target registry using Docker Token Authentication.\n  *\n  * @see <a\n  *     href=\"https://docs.docker.com/registry/spec/auth/token/\">https://docs.docker.com/registry/spec/auth/token/</a>\n  */\n-class AuthenticatePushStep implements Callable<Optional<Authorization>> {\n+class AuthenticatePushStep implements Callable<RegistryClient> {\n \n   private static final String DESCRIPTION = \"Authenticating push to %s\";\n \n   private final BuildContext buildContext;\n   private final ProgressEventDispatcher.Factory progressEventDispatcherFactory;\n-  @Nullable private final Credential registryCredential;\n \n   AuthenticatePushStep(\n-      BuildContext buildContext,\n-      ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n-      @Nullable Credential registryCredential) {\n+      BuildContext buildContext, ProgressEventDispatcher.Factory progressEventDispatcherFactory) {\n     this.buildContext = buildContext;\n     this.progressEventDispatcherFactory = progressEventDispatcherFactory;\n-    this.registryCredential = registryCredential;\n   }\n \n   @Override\n-  public Optional<Authorization> call() throws IOException, RegistryException {\n+  public RegistryClient call() throws CredentialRetrievalException, IOException, RegistryException {\n     String registry = buildContext.getTargetImageConfiguration().getImageRegistry();\n     try (ProgressEventDispatcher ignored =\n             progressEventDispatcherFactory.create(\"authenticating push to \" + registry, 1);\n         TimerEventDispatcher ignored2 =\n             new TimerEventDispatcher(\n                 buildContext.getEventHandlers(), String.format(DESCRIPTION, registry))) {\n-      Optional<RegistryAuthenticator> registryAuthenticator =\n+      Credential credential =\n+          RegistryCredentialRetriever.getTargetImageCredential(buildContext).orElse(null);", "originalCommit": "d934edd594622c228fc799f7804747e2d4b9162b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNTQ1Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367025453", "bodyText": "Just restructured this part to make the issue #2220 clear.", "author": "chanseokoh", "createdAt": "2020-01-15T18:05:11Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -101,73 +88,77 @@ public ImageAndAuthorization call()\n     ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n     if (imageReference.isScratch()) {\n       eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n-      return new ImageAndAuthorization(Image.builder(buildContext.getTargetFormat()).build(), null);\n+      return new ImageAndRegistryClient(\n+          Image.builder(buildContext.getTargetFormat()).build(), null);\n     }\n \n     eventHandlers.dispatch(\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n-    if (buildContext.isOffline() || imageReference.isTagDigest()) {\n+    if (buildContext.isOffline()) {\n       Optional<Image> image = getCachedBaseImage();\n       if (image.isPresent()) {\n-        return new ImageAndAuthorization(image.get(), null);\n+        return new ImageAndRegistryClient(image.get(), null);\n       }\n-      if (buildContext.isOffline()) {\n-        throw new IOException(\n-            \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+      throw new IOException(\n+          \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+\n+    } else if (imageReference.isTagDigest()) {\n+      Optional<Image> image = getCachedBaseImage();\n+      if (image.isPresent()) {\n+        RegistryClient noAuthRegistryClient =\n+            buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n+        // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized if\n+        // layers have to be downloaded. https://github.com/GoogleContainerTools/jib/issues/2220\n+        return new ImageAndRegistryClient(image.get(), noAuthRegistryClient);", "originalCommit": "d934edd594622c228fc799f7804747e2d4b9162b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjgxNg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367026816", "bodyText": "This pattern is bad, but I just can't leave it to do the same meaningless no-auth attempt that is destined to fail. This is part of the issue #2202. This part should be restructured later. But I am not doing it here.", "author": "chanseokoh", "createdAt": "2020-01-15T18:08:18Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -101,73 +88,77 @@ public ImageAndAuthorization call()\n     ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n     if (imageReference.isScratch()) {\n       eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n-      return new ImageAndAuthorization(Image.builder(buildContext.getTargetFormat()).build(), null);\n+      return new ImageAndRegistryClient(\n+          Image.builder(buildContext.getTargetFormat()).build(), null);\n     }\n \n     eventHandlers.dispatch(\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n-    if (buildContext.isOffline() || imageReference.isTagDigest()) {\n+    if (buildContext.isOffline()) {\n       Optional<Image> image = getCachedBaseImage();\n       if (image.isPresent()) {\n-        return new ImageAndAuthorization(image.get(), null);\n+        return new ImageAndRegistryClient(image.get(), null);\n       }\n-      if (buildContext.isOffline()) {\n-        throw new IOException(\n-            \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+      throw new IOException(\n+          \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+\n+    } else if (imageReference.isTagDigest()) {\n+      Optional<Image> image = getCachedBaseImage();\n+      if (image.isPresent()) {\n+        RegistryClient noAuthRegistryClient =\n+            buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n+        // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized if\n+        // layers have to be downloaded. https://github.com/GoogleContainerTools/jib/issues/2220\n+        return new ImageAndRegistryClient(image.get(), noAuthRegistryClient);\n       }\n     }\n \n     try (ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"pulling base image manifest\", 2);\n         TimerEventDispatcher ignored1 = new TimerEventDispatcher(eventHandlers, DESCRIPTION)) {\n+\n       // First, try with no credentials.\n+      RegistryClient noAuthRegistryClient =\n+          buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n       try {\n-        return new ImageAndAuthorization(pullBaseImage(null, progressEventDispatcher), null);\n+        return new ImageAndRegistryClient(\n+            pullBaseImage(noAuthRegistryClient, progressEventDispatcher), noAuthRegistryClient);\n \n-      } catch (RegistryUnauthorizedException ignored2) {\n+      } catch (RegistryUnauthorizedException ex) {\n         eventHandlers.dispatch(\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        // If failed, then, retrieve base registry credentials and try with retrieved credentials.\n-        // TODO: Refactor the logic in RetrieveRegistryCredentialsStep out to\n-        // registry.credentials.RegistryCredentialsRetriever.\n         Credential registryCredential =\n-            RetrieveRegistryCredentialsStep.forBaseImage(\n-                    buildContext, progressEventDispatcher.newChildProducer())\n-                .call()\n-                .orElse(null);\n+            RegistryCredentialRetriever.getBaseImageCredential(buildContext).orElse(null);\n \n-        Authorization registryAuthorization =\n-            registryCredential == null || registryCredential.isOAuth2RefreshToken()\n-                ? null\n-                : Authorization.fromBasicCredentials(\n-                    registryCredential.getUsername(), registryCredential.getPassword());\n+        RegistryClient registryClient =\n+            buildContext\n+                .newBaseImageRegistryClientFactory()\n+                .setCredential(registryCredential)\n+                .newRegistryClient();\n \n         try {\n-          return new ImageAndAuthorization(\n-              pullBaseImage(registryAuthorization, progressEventDispatcher), registryAuthorization);\n+          // TODO: refactor the code (https://github.com/GoogleContainerTools/jib/pull/2202)\n+          if (registryCredential == null || registryCredential.isOAuth2RefreshToken()) {\n+            throw ex;", "originalCommit": "d934edd594622c228fc799f7804747e2d4b9162b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTM1MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369309350", "bodyText": "is the restructure required before we do a 2.0.0?", "author": "loosebazooka", "createdAt": "2020-01-22T00:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjgxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY0MTMxNA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369641314", "bodyText": "It's not required. But as of now (which doesn't have this jump), you just make the same meaningless call with null credential only to fail again. (In line 126, we already failed with \"noAuthRegistryClient\". No reason to do this again.) This is a simple guard, so I think this is safe. I want to have this in 2.0.0 for better performance. Most registries will hit this path.", "author": "chanseokoh", "createdAt": "2020-01-22T15:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDQwMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367030401", "bodyText": "Just renamed from RetrieveRegistryCredentialsStep (and thus simplied).", "author": "chanseokoh", "createdAt": "2020-01-15T18:16:10Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/RegistryCredentialRetriever.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.builder.steps;\n+\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.configuration.BuildContext;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import java.util.Optional;\n+\n+/** Attempts to retrieve registry credentials. */\n+class RegistryCredentialRetriever {", "originalCommit": "d934edd594622c228fc799f7804747e2d4b9162b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDczMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367030733", "bodyText": "As mentioned, two steps combined.", "author": "chanseokoh", "createdAt": "2020-01-15T18:16:53Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -149,8 +147,7 @@ public StepsRunner registryPushSteps() {\n     rootProgressDescription = \"building image to registry\";\n     boolean layersRequiredLocally = buildContext.getAlwaysCacheBaseImage();\n \n-    stepsToRun.add(this::retrieveTargetRegistryCredentials);\n-    stepsToRun.add(this::authenticatePush);\n+    stepsToRun.add(this::authenticateBearerPush);", "originalCommit": "d934edd594622c228fc799f7804747e2d4b9162b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "912c4b9fe6460e9076e21b25359fa4bf59994579", "url": "https://github.com/GoogleContainerTools/jib/commit/912c4b9fe6460e9076e21b25359fa4bf59994579", "message": "Add tests", "committedDate": "2020-01-16T00:10:11Z", "type": "commit"}, {"oid": "912c4b9fe6460e9076e21b25359fa4bf59994579", "url": "https://github.com/GoogleContainerTools/jib/commit/912c4b9fe6460e9076e21b25359fa4bf59994579", "message": "Add tests", "committedDate": "2020-01-16T00:10:11Z", "type": "forcePushed"}, {"oid": "f4217f3ef42b2391bca989db446dec39a304e278", "url": "https://github.com/GoogleContainerTools/jib/commit/f4217f3ef42b2391bca989db446dec39a304e278", "message": "typo", "committedDate": "2020-01-16T00:12:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3MjQzNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367972437", "bodyText": "Would it make sense to swap the order of these parameters?  eventHandlers is an ancillary object passed in for logging purposes, but it appears to have primary importance.", "author": "briandealwis", "createdAt": "2020-01-17T14:48:37Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/RegistryCredentialRetriever.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.builder.steps;\n+\n+import com.google.cloud.tools.jib.api.Credential;\n+import com.google.cloud.tools.jib.api.CredentialRetriever;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.configuration.BuildContext;\n+import com.google.cloud.tools.jib.configuration.ImageConfiguration;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n+import java.util.Optional;\n+\n+/** Attempts to retrieve registry credentials. */\n+class RegistryCredentialRetriever {\n+\n+  /** Retrieves credentials for the base image. */\n+  static Optional<Credential> getBaseImageCredential(BuildContext buildContext)\n+      throws CredentialRetrievalException {\n+    return retrieve(buildContext.getEventHandlers(), buildContext.getBaseImageConfiguration());\n+  }\n+\n+  /** Retrieves credentials for the target image. */\n+  static Optional<Credential> getTargetImageCredential(BuildContext buildContext)\n+      throws CredentialRetrievalException {\n+    return retrieve(buildContext.getEventHandlers(), buildContext.getTargetImageConfiguration());\n+  }\n+\n+  private static Optional<Credential> retrieve(\n+      EventHandlers eventHandlers, ImageConfiguration imageConfiguration)", "originalCommit": "f4217f3ef42b2391bca989db446dec39a304e278", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3NDU0Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367974547", "bodyText": "Since we use @Nullable from jsr305 we could use its @ThreadSafe too?", "author": "briandealwis", "createdAt": "2020-01-17T14:52:26Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -35,18 +40,21 @@\n import com.google.cloud.tools.jib.json.JsonTemplate;\n import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n import com.google.common.base.Strings;\n+import com.google.common.base.Verify;\n import com.google.common.collect.ImmutableSetMultimap;\n import com.google.common.collect.Multimap;\n import java.io.IOException;\n import java.net.URL;\n import java.util.List;\n import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Consumer;\n import java.util.stream.Stream;\n import javax.annotation.Nullable;\n \n-/** Interfaces with a registry. */\n+/** Interfaces with a registry. Thread-safe. */\n public class RegistryClient {", "originalCommit": "f4217f3ef42b2391bca989db446dec39a304e278", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwNTA3NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368005074", "bodyText": "We've never used it, so this will be our first usage. \ud83d\ude05", "author": "chanseokoh", "createdAt": "2020-01-17T15:50:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3NDU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4MDk3NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r367980974", "bodyText": "PlainHttpClient?", "author": "briandealwis", "createdAt": "2020-01-17T15:04:17Z", "path": "jib-core/src/test/java/com/google/cloud/tools/jib/registry/HttpOnlyFailoverHttpClient.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2019 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.google.api.client.http.GenericUrl;\n+import com.google.cloud.tools.jib.http.FailoverHttpClient;\n+import com.google.cloud.tools.jib.http.Request;\n+import com.google.cloud.tools.jib.http.Response;\n+import java.io.IOException;\n+import java.net.URL;\n+\n+/** Forces sending all requests in plain-HTTP protocol. For testing only. */\n+class HttpOnlyFailoverHttpClient extends FailoverHttpClient {", "originalCommit": "f4217f3ef42b2391bca989db446dec39a304e278", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4ee4cdd3779efa3f50e16ff5723203f2ea5a1271", "url": "https://github.com/GoogleContainerTools/jib/commit/4ee4cdd3779efa3f50e16ff5723203f2ea5a1271", "message": "Swap arguments, rename method, add @ThreadSafe, add test", "committedDate": "2020-01-17T15:55:38Z", "type": "commit"}, {"oid": "35ec93f531770eb9f8698f6773ba218bfd81c63b", "url": "https://github.com/GoogleContainerTools/jib/commit/35ec93f531770eb9f8698f6773ba218bfd81c63b", "message": "Make it safer, just in case", "committedDate": "2020-01-17T20:33:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzNzU1MQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368137551", "bodyText": "should readOnly be a fixed value of a registry client? Do we intend to reuse a registry client to do readonly once and then write later?\nPerhaps this can go on the factory?", "author": "loosebazooka", "createdAt": "2020-01-17T21:09:49Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -242,46 +252,113 @@ public static Factory factory(\n   }\n \n   private final EventHandlers eventHandlers;\n-  @Nullable private final Authorization authorization;\n+  @Nullable private final Credential credential;\n   private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n   private final String userAgent;\n   private final FailoverHttpClient httpClient;\n \n+  // mutable\n+  private final AtomicReference<Authorization> authorization = new AtomicReference<>();\n+  private boolean readOnlyBearerAuth;\n+\n   /**\n    * Instantiate with {@link #factory}.\n    *\n    * @param eventHandlers the event handlers used for dispatching log events\n-   * @param authorization the {@link Authorization} to access the registry/repository\n+   * @param credential credential for registry/repository; will not be used unless {@link\n+   *     #configureBasicAuth} or {@link #doBearerAuth} is called\n    * @param registryEndpointRequestProperties properties of registry endpoint requests\n    * @param userAgent {@code User-Agent} header to send with the request\n    * @param httpClient HTTP client\n    */\n   private RegistryClient(\n       EventHandlers eventHandlers,\n-      @Nullable Authorization authorization,\n+      @Nullable Credential credential,\n       RegistryEndpointRequestProperties registryEndpointRequestProperties,\n       String userAgent,\n       FailoverHttpClient httpClient) {\n     this.eventHandlers = eventHandlers;\n-    this.authorization = authorization;\n+    this.credential = credential;\n     this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n     this.userAgent = userAgent;\n     this.httpClient = httpClient;\n   }\n \n+  public void configureBasicAuth() {\n+    Preconditions.checkNotNull(credential);\n+    Preconditions.checkState(!credential.isOAuth2RefreshToken());\n+\n+    authorization.set(\n+        Authorization.fromBasicCredentials(credential.getUsername(), credential.getPassword()));\n+\n+    String registry = registryEndpointRequestProperties.getServerUrl();\n+    String repository = registryEndpointRequestProperties.getImageName();\n+    eventHandlers.dispatch(\n+        LogEvent.debug(\"configured basic auth for \" + registry + \"/\" + repository));\n+  }\n+\n   /**\n-   * @return the {@link RegistryAuthenticator} to authenticate pulls/pushes with the registry, or\n-   *     {@link Optional#empty()} if no token authentication is necessary\n+   * Attempts bearer authentication.\n+   *\n+   * @param readOnlyBearerAuth true to request pull scope only; false for pull and push", "originalCommit": "35ec93f531770eb9f8698f6773ba218bfd81c63b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0Mzc2OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368143768", "bodyText": "As the name suggests, this read-only vs. read-write applies only when doing bearer auth. Before doing any auth or in the case of basic auth, the registry client itself is unrestricted. It will then be up to the server who will say you cannot do anything, can read, or can read and write.\nThe class is mutable, and potentially it's possible to do doBearerAuth(true) and later doBearerAuth(false), but I never intend to do it. But the point is, the client doesn't know if it's going to be read only (just requesting read only) before doing doBearerAuth(). And it is a bit sad, but I don't think the factory should initiate doBearerAuth().", "author": "chanseokoh", "createdAt": "2020-01-17T21:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzNzU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MDE3Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368140176", "bodyText": "Should we use readOnly to validate registry calls (you cannot use a readOnlyClient auth'd to do writes?)", "author": "loosebazooka", "createdAt": "2020-01-17T21:17:53Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -242,46 +252,113 @@ public static Factory factory(\n   }\n \n   private final EventHandlers eventHandlers;\n-  @Nullable private final Authorization authorization;\n+  @Nullable private final Credential credential;\n   private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n   private final String userAgent;\n   private final FailoverHttpClient httpClient;\n \n+  // mutable\n+  private final AtomicReference<Authorization> authorization = new AtomicReference<>();\n+  private boolean readOnlyBearerAuth;\n+\n   /**\n    * Instantiate with {@link #factory}.\n    *\n    * @param eventHandlers the event handlers used for dispatching log events\n-   * @param authorization the {@link Authorization} to access the registry/repository\n+   * @param credential credential for registry/repository; will not be used unless {@link\n+   *     #configureBasicAuth} or {@link #doBearerAuth} is called\n    * @param registryEndpointRequestProperties properties of registry endpoint requests\n    * @param userAgent {@code User-Agent} header to send with the request\n    * @param httpClient HTTP client\n    */\n   private RegistryClient(\n       EventHandlers eventHandlers,\n-      @Nullable Authorization authorization,\n+      @Nullable Credential credential,\n       RegistryEndpointRequestProperties registryEndpointRequestProperties,\n       String userAgent,\n       FailoverHttpClient httpClient) {\n     this.eventHandlers = eventHandlers;\n-    this.authorization = authorization;\n+    this.credential = credential;\n     this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n     this.userAgent = userAgent;\n     this.httpClient = httpClient;\n   }\n \n+  public void configureBasicAuth() {\n+    Preconditions.checkNotNull(credential);\n+    Preconditions.checkState(!credential.isOAuth2RefreshToken());\n+\n+    authorization.set(\n+        Authorization.fromBasicCredentials(credential.getUsername(), credential.getPassword()));\n+\n+    String registry = registryEndpointRequestProperties.getServerUrl();\n+    String repository = registryEndpointRequestProperties.getImageName();\n+    eventHandlers.dispatch(\n+        LogEvent.debug(\"configured basic auth for \" + registry + \"/\" + repository));\n+  }\n+\n   /**\n-   * @return the {@link RegistryAuthenticator} to authenticate pulls/pushes with the registry, or\n-   *     {@link Optional#empty()} if no token authentication is necessary\n+   * Attempts bearer authentication.\n+   *\n+   * @param readOnlyBearerAuth true to request pull scope only; false for pull and push\n+   * @return true if bearer authentication succeeded; false if the server expects basic\n+   *     authentication (and thus bearer authentication was not attempted)\n    * @throws IOException if communicating with the endpoint fails\n    * @throws RegistryException if communicating with the endpoint fails\n+   * @throws RegistryAuthenticationFailedException if authentication fails\n+   * @throws RegistryCredentialsNotSentException if authentication failed and credentials were not\n+   *     sent over plain HTTP\n    */\n-  public Optional<RegistryAuthenticator> getRegistryAuthenticator()\n-      throws IOException, RegistryException {\n-    // Gets the WWW-Authenticate header (eg. 'WWW-Authenticate: Bearer\n-    // realm=\"https://gcr.io/v2/token\",service=\"gcr.io\"')\n-    return callRegistryEndpoint(\n-        new AuthenticationMethodRetriever(\n-            registryEndpointRequestProperties, getUserAgent(), httpClient));\n+  public boolean doBearerAuth(boolean readOnlyBearerAuth) throws IOException, RegistryException {\n+    this.readOnlyBearerAuth = readOnlyBearerAuth;", "originalCommit": "35ec93f531770eb9f8698f6773ba218bfd81c63b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE2MzUyOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368163529", "bodyText": "Technically you can still use it to make these requests (theoretically it works as long as the server doesn't reject), but I've added a check anyway.", "author": "chanseokoh", "createdAt": "2020-01-17T22:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MDE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MDU0Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368140542", "bodyText": "perhaps 5 should be configurable or a const?", "author": "loosebazooka", "createdAt": "2020-01-17T21:18:57Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -463,13 +544,31 @@ String getUserAgent() {\n    */\n   private <T> T callRegistryEndpoint(RegistryEndpointProvider<T> registryEndpointProvider)\n       throws IOException, RegistryException {\n-    return new RegistryEndpointCaller<>(\n-            eventHandlers,\n-            userAgent,\n-            registryEndpointProvider,\n-            authorization,\n-            registryEndpointRequestProperties,\n-            httpClient)\n-        .call();\n+    int bearerTokenRefreshes = 0;\n+    while (true) {\n+      try {\n+        return new RegistryEndpointCaller<>(\n+                eventHandlers,\n+                getUserAgent(),\n+                registryEndpointProvider,\n+                authorization.get(),\n+                registryEndpointRequestProperties,\n+                httpClient)\n+            .call();\n+\n+      } catch (RegistryUnauthorizedException ex) {\n+        if (ex.getHttpResponseException().getStatusCode()\n+                != HttpStatusCodes.STATUS_CODE_UNAUTHORIZED\n+            || !isBearerAuth(authorization.get())\n+            || ++bearerTokenRefreshes >= 5) {", "originalCommit": "35ec93f531770eb9f8698f6773ba218bfd81c63b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE2MzU0Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r368163543", "bodyText": "I think a const here.", "author": "chanseokoh", "createdAt": "2020-01-17T22:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MDU0Mg=="}], "type": "inlineReview"}, {"oid": "bcc620a61100454b367359ef348e0c3d6a83fb5e", "url": "https://github.com/GoogleContainerTools/jib/commit/bcc620a61100454b367359ef348e0c3d6a83fb5e", "message": "Add checks, extract as a constant", "committedDate": "2020-01-17T22:31:59Z", "type": "commit"}, {"oid": "112f91f213f4914e6441df3dd5d4ba5a1b099ea2", "url": "https://github.com/GoogleContainerTools/jib/commit/112f91f213f4914e6441df3dd5d4ba5a1b099ea2", "message": "Merge branch 'master' into i691-new-refresh-token", "committedDate": "2020-01-21T18:06:12Z", "type": "commit"}, {"oid": "af9618933a0c4c308f85bceb244a1777ab338a7c", "url": "https://github.com/GoogleContainerTools/jib/commit/af9618933a0c4c308f85bceb244a1777ab338a7c", "message": ">=", "committedDate": "2020-01-21T18:10:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NTE1NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369195154", "bodyText": "I wonder if we should combine these integration tests into one file at some point, like RegistryClientIntegrationTest or something.", "author": "TadCordle", "createdAt": "2020-01-21T19:22:00Z", "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/BearerAuthenticationIntegrationTest.java", "diffHunk": "@@ -18,15 +18,12 @@\n \n import com.google.cloud.tools.jib.api.RegistryException;\n import com.google.cloud.tools.jib.event.EventHandlers;\n-import com.google.cloud.tools.jib.http.Authorization;\n import com.google.cloud.tools.jib.http.FailoverHttpClient;\n import java.io.IOException;\n-import java.util.Optional;\n-import org.junit.Assert;\n import org.junit.Test;\n \n-/** Integration tests for {@link AuthenticationMethodRetriever}. */\n-public class AuthenticationMethodRetrieverIntegrationTest {\n+/** Integration tests for bearer authentication. */\n+public class BearerAuthenticationIntegrationTest {", "originalCommit": "af9618933a0c4c308f85bceb244a1777ab338a7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1OTA1Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369259053", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                              \"The registry asked for basic authentication, but the registry had refused basic\"\n          \n          \n            \n                              \"The registry asked for basic authentication, but the registry had refused basic \"", "author": "TadCordle", "createdAt": "2020-01-21T21:43:59Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java", "diffHunk": "@@ -101,73 +88,81 @@ public ImageAndAuthorization call()\n     ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n     if (imageReference.isScratch()) {\n       eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n-      return new ImageAndAuthorization(Image.builder(buildContext.getTargetFormat()).build(), null);\n+      return new ImageAndRegistryClient(\n+          Image.builder(buildContext.getTargetFormat()).build(), null);\n     }\n \n     eventHandlers.dispatch(\n         LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n-    if (buildContext.isOffline() || imageReference.isTagDigest()) {\n+    if (buildContext.isOffline()) {\n       Optional<Image> image = getCachedBaseImage();\n       if (image.isPresent()) {\n-        return new ImageAndAuthorization(image.get(), null);\n+        return new ImageAndRegistryClient(image.get(), null);\n       }\n-      if (buildContext.isOffline()) {\n-        throw new IOException(\n-            \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+      throw new IOException(\n+          \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+\n+    } else if (imageReference.isTagDigest()) {\n+      Optional<Image> image = getCachedBaseImage();\n+      if (image.isPresent()) {\n+        RegistryClient noAuthRegistryClient =\n+            buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n+        // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized if\n+        // layers have to be downloaded. https://github.com/GoogleContainerTools/jib/issues/2220\n+        return new ImageAndRegistryClient(image.get(), noAuthRegistryClient);\n       }\n     }\n \n     try (ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"pulling base image manifest\", 2);\n         TimerEventDispatcher ignored1 = new TimerEventDispatcher(eventHandlers, DESCRIPTION)) {\n+\n       // First, try with no credentials.\n+      RegistryClient noAuthRegistryClient =\n+          buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n       try {\n-        return new ImageAndAuthorization(pullBaseImage(null, progressEventDispatcher), null);\n+        return new ImageAndRegistryClient(\n+            pullBaseImage(noAuthRegistryClient, progressEventDispatcher), noAuthRegistryClient);\n \n-      } catch (RegistryUnauthorizedException ignored2) {\n+      } catch (RegistryUnauthorizedException ex) {\n         eventHandlers.dispatch(\n             LogEvent.lifecycle(\n                 \"The base image requires auth. Trying again for \" + imageReference + \"...\"));\n \n-        // If failed, then, retrieve base registry credentials and try with retrieved credentials.\n-        // TODO: Refactor the logic in RetrieveRegistryCredentialsStep out to\n-        // registry.credentials.RegistryCredentialsRetriever.\n         Credential registryCredential =\n-            RetrieveRegistryCredentialsStep.forBaseImage(\n-                    buildContext, progressEventDispatcher.newChildProducer())\n-                .call()\n-                .orElse(null);\n+            RegistryCredentialRetriever.getBaseImageCredential(buildContext).orElse(null);\n \n-        Authorization registryAuthorization =\n-            registryCredential == null || registryCredential.isOAuth2RefreshToken()\n-                ? null\n-                : Authorization.fromBasicCredentials(\n-                    registryCredential.getUsername(), registryCredential.getPassword());\n+        RegistryClient registryClient =\n+            buildContext\n+                .newBaseImageRegistryClientFactory()\n+                .setCredential(registryCredential)\n+                .newRegistryClient();\n \n         try {\n-          return new ImageAndAuthorization(\n-              pullBaseImage(registryAuthorization, progressEventDispatcher), registryAuthorization);\n+          // TODO: refactor the code (https://github.com/GoogleContainerTools/jib/pull/2202)\n+          if (registryCredential == null || registryCredential.isOAuth2RefreshToken()) {\n+            throw ex;\n+          }\n+\n+          eventHandlers.dispatch(LogEvent.debug(\"Trying basic auth for \" + imageReference + \"...\"));\n+          registryClient.configureBasicAuth();\n+          return new ImageAndRegistryClient(\n+              pullBaseImage(registryClient, progressEventDispatcher), registryClient);\n \n         } catch (RegistryUnauthorizedException registryUnauthorizedException) {\n           // The registry requires us to authenticate using the Docker Token Authentication.\n           // See https://docs.docker.com/registry/spec/auth/token\n-          Optional<RegistryAuthenticator> registryAuthenticator =\n-              buildContext\n-                  .newBaseImageRegistryClientFactory()\n-                  .newRegistryClient()\n-                  .getRegistryAuthenticator();\n-          if (registryAuthenticator.isPresent()) {\n-            Authorization pullAuthorization =\n-                registryAuthenticator.get().authenticatePull(registryCredential);\n-\n-            return new ImageAndAuthorization(\n-                pullBaseImage(pullAuthorization, progressEventDispatcher), pullAuthorization);\n+          eventHandlers.dispatch(\n+              LogEvent.debug(\"Trying bearer auth for \" + imageReference + \"...\"));\n+          if (registryClient.doBearerAuth(true)) {\n+            return new ImageAndRegistryClient(\n+                pullBaseImage(registryClient, progressEventDispatcher), registryClient);\n           }\n           eventHandlers.dispatch(\n               LogEvent.error(\n-                  \"Failed to retrieve authentication challenge for registry that required token \"\n-                      + \"authentication\"));\n+                  \"The registry asked for basic authentication, but the registry had refused basic\"", "originalCommit": "af9618933a0c4c308f85bceb244a1777ab338a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTY2Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369309667", "bodyText": "probably don't need had either.\n- the registry had refused\n+ the registry refused", "author": "loosebazooka", "createdAt": "2020-01-22T00:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1OTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyOTcyOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369629729", "bodyText": "I think \"had\" is fine? It makes it explicit that the refusal had happened before the server asked for basic auth.", "author": "chanseokoh", "createdAt": "2020-01-22T15:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1OTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwNDIyNQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369304225", "bodyText": "I think for public methods, people generally are discourage from using boolean as a parameter? I think(?) that this is only an internal API so it's okay. Just wondering how you feel about doing doReadOnlyBearerAuth and doReadWriteBearerAuth that call into this?", "author": "loosebazooka", "createdAt": "2020-01-21T23:45:58Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -242,46 +254,112 @@ public static Factory factory(\n   }\n \n   private final EventHandlers eventHandlers;\n-  @Nullable private final Authorization authorization;\n+  @Nullable private final Credential credential;\n   private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n   private final String userAgent;\n   private final FailoverHttpClient httpClient;\n \n+  // mutable\n+  private final AtomicReference<Authorization> authorization = new AtomicReference<>();\n+  private boolean readOnlyBearerAuth;\n+\n   /**\n    * Instantiate with {@link #factory}.\n    *\n    * @param eventHandlers the event handlers used for dispatching log events\n-   * @param authorization the {@link Authorization} to access the registry/repository\n+   * @param credential credential for registry/repository; will not be used unless {@link\n+   *     #configureBasicAuth} or {@link #doBearerAuth} is called\n    * @param registryEndpointRequestProperties properties of registry endpoint requests\n    * @param userAgent {@code User-Agent} header to send with the request\n    * @param httpClient HTTP client\n    */\n   private RegistryClient(\n       EventHandlers eventHandlers,\n-      @Nullable Authorization authorization,\n+      @Nullable Credential credential,\n       RegistryEndpointRequestProperties registryEndpointRequestProperties,\n       String userAgent,\n       FailoverHttpClient httpClient) {\n     this.eventHandlers = eventHandlers;\n-    this.authorization = authorization;\n+    this.credential = credential;\n     this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n     this.userAgent = userAgent;\n     this.httpClient = httpClient;\n   }\n \n+  public void configureBasicAuth() {\n+    Preconditions.checkNotNull(credential);\n+    Preconditions.checkState(!credential.isOAuth2RefreshToken());\n+\n+    authorization.set(\n+        Authorization.fromBasicCredentials(credential.getUsername(), credential.getPassword()));\n+\n+    String registry = registryEndpointRequestProperties.getServerUrl();\n+    String repository = registryEndpointRequestProperties.getImageName();\n+    eventHandlers.dispatch(\n+        LogEvent.debug(\"configured basic auth for \" + registry + \"/\" + repository));\n+  }\n+\n   /**\n-   * @return the {@link RegistryAuthenticator} to authenticate pulls/pushes with the registry, or\n-   *     {@link Optional#empty()} if no token authentication is necessary\n+   * Attempts bearer authentication.\n+   *\n+   * @param readOnlyBearerAuth true to request pull scope only; false for pull and push\n+   * @return true if bearer authentication succeeded; false if the server expects basic\n+   *     authentication (and thus bearer authentication was not attempted)\n    * @throws IOException if communicating with the endpoint fails\n    * @throws RegistryException if communicating with the endpoint fails\n+   * @throws RegistryAuthenticationFailedException if authentication fails\n+   * @throws RegistryCredentialsNotSentException if authentication failed and credentials were not\n+   *     sent over plain HTTP\n    */\n-  public Optional<RegistryAuthenticator> getRegistryAuthenticator()\n-      throws IOException, RegistryException {\n-    // Gets the WWW-Authenticate header (eg. 'WWW-Authenticate: Bearer\n-    // realm=\"https://gcr.io/v2/token\",service=\"gcr.io\"')\n-    return callRegistryEndpoint(\n-        new AuthenticationMethodRetriever(\n-            registryEndpointRequestProperties, getUserAgent(), httpClient));\n+  public boolean doBearerAuth(boolean readOnlyBearerAuth) throws IOException, RegistryException {", "originalCommit": "af9618933a0c4c308f85bceb244a1777ab338a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNzkyMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369637922", "bodyText": "Ah, didn't know that. I can do it that way.", "author": "chanseokoh", "createdAt": "2020-01-22T15:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwNDIyNQ=="}], "type": "inlineReview"}, {"oid": "90414b3e391d87eefb80def73f40192c945699a8", "url": "https://github.com/GoogleContainerTools/jib/commit/90414b3e391d87eefb80def73f40192c945699a8", "message": "review comments", "committedDate": "2020-01-22T15:53:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3MTE4NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369771184", "bodyText": "{@code true} and {@code false}?", "author": "TadCordle", "createdAt": "2020-01-22T19:55:22Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -242,46 +254,131 @@ public static Factory factory(\n   }\n \n   private final EventHandlers eventHandlers;\n-  @Nullable private final Authorization authorization;\n+  @Nullable private final Credential credential;\n   private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n   private final String userAgent;\n   private final FailoverHttpClient httpClient;\n \n+  // mutable\n+  private final AtomicReference<Authorization> authorization = new AtomicReference<>();\n+  private boolean readOnlyBearerAuth;\n+\n   /**\n    * Instantiate with {@link #factory}.\n    *\n    * @param eventHandlers the event handlers used for dispatching log events\n-   * @param authorization the {@link Authorization} to access the registry/repository\n+   * @param credential credential for registry/repository; will not be used unless {@link\n+   *     #configureBasicAuth} or {@link #doBearerAuth} is called\n    * @param registryEndpointRequestProperties properties of registry endpoint requests\n    * @param userAgent {@code User-Agent} header to send with the request\n    * @param httpClient HTTP client\n    */\n   private RegistryClient(\n       EventHandlers eventHandlers,\n-      @Nullable Authorization authorization,\n+      @Nullable Credential credential,\n       RegistryEndpointRequestProperties registryEndpointRequestProperties,\n       String userAgent,\n       FailoverHttpClient httpClient) {\n     this.eventHandlers = eventHandlers;\n-    this.authorization = authorization;\n+    this.credential = credential;\n     this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n     this.userAgent = userAgent;\n     this.httpClient = httpClient;\n   }\n \n+  public void configureBasicAuth() {\n+    Preconditions.checkNotNull(credential);\n+    Preconditions.checkState(!credential.isOAuth2RefreshToken());\n+\n+    authorization.set(\n+        Authorization.fromBasicCredentials(credential.getUsername(), credential.getPassword()));\n+\n+    String registry = registryEndpointRequestProperties.getServerUrl();\n+    String repository = registryEndpointRequestProperties.getImageName();\n+    eventHandlers.dispatch(\n+        LogEvent.debug(\"configured basic auth for \" + registry + \"/\" + repository));\n+  }\n+\n   /**\n-   * @return the {@link RegistryAuthenticator} to authenticate pulls/pushes with the registry, or\n-   *     {@link Optional#empty()} if no token authentication is necessary\n+   * Attempts bearer authentication for pull.\n+   *\n+   * @return true if bearer authentication succeeded; false if the server expects basic", "originalCommit": "90414b3e391d87eefb80def73f40192c945699a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c9f9dfeb1ffb89b379405e9229b42e8116c3eb86", "url": "https://github.com/GoogleContainerTools/jib/commit/c9f9dfeb1ffb89b379405e9229b42e8116c3eb86", "message": "javadocs and minor cleanups", "committedDate": "2020-01-22T21:35:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0NjMxMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369846313", "bodyText": "Does it make sense to make this 2 allocation units now, or is it so quick, this doesn't really matter.", "author": "loosebazooka", "createdAt": "2020-01-22T22:43:41Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/AuthenticatePushStep.java", "diffHunk": "@@ -21,58 +21,53 @@\n import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n import com.google.cloud.tools.jib.builder.TimerEventDispatcher;\n import com.google.cloud.tools.jib.configuration.BuildContext;\n-import com.google.cloud.tools.jib.http.Authorization;\n-import com.google.cloud.tools.jib.registry.RegistryAuthenticator;\n+import com.google.cloud.tools.jib.registry.RegistryClient;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n import java.io.IOException;\n-import java.util.Optional;\n import java.util.concurrent.Callable;\n-import javax.annotation.Nullable;\n \n /**\n  * Authenticates push to a target registry using Docker Token Authentication.\n  *\n  * @see <a\n  *     href=\"https://docs.docker.com/registry/spec/auth/token/\">https://docs.docker.com/registry/spec/auth/token/</a>\n  */\n-class AuthenticatePushStep implements Callable<Optional<Authorization>> {\n+class AuthenticatePushStep implements Callable<RegistryClient> {\n \n   private static final String DESCRIPTION = \"Authenticating push to %s\";\n \n   private final BuildContext buildContext;\n   private final ProgressEventDispatcher.Factory progressEventDispatcherFactory;\n-  @Nullable private final Credential registryCredential;\n \n   AuthenticatePushStep(\n-      BuildContext buildContext,\n-      ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n-      @Nullable Credential registryCredential) {\n+      BuildContext buildContext, ProgressEventDispatcher.Factory progressEventDispatcherFactory) {\n     this.buildContext = buildContext;\n     this.progressEventDispatcherFactory = progressEventDispatcherFactory;\n-    this.registryCredential = registryCredential;\n   }\n \n   @Override\n-  public Optional<Authorization> call() throws IOException, RegistryException {\n+  public RegistryClient call() throws CredentialRetrievalException, IOException, RegistryException {\n     String registry = buildContext.getTargetImageConfiguration().getImageRegistry();\n     try (ProgressEventDispatcher ignored =\n             progressEventDispatcherFactory.create(\"authenticating push to \" + registry, 1);", "originalCommit": "c9f9dfeb1ffb89b379405e9229b42e8116c3eb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIyMzQxOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r370223419", "bodyText": "I find no problem to have 2 allocations.", "author": "chanseokoh", "createdAt": "2020-01-23T16:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0NjMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0OTU5Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369849593", "bodyText": "I find this flow to be a little strange. But maybe that's just a consequence of our code, should the registry client just handle this basic auth stuff?\nIs there a reason we want the steps of authorizing the client to exist separate and outside the client?", "author": "loosebazooka", "createdAt": "2020-01-22T22:52:33Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/AuthenticatePushStep.java", "diffHunk": "@@ -21,58 +21,53 @@\n import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n import com.google.cloud.tools.jib.builder.TimerEventDispatcher;\n import com.google.cloud.tools.jib.configuration.BuildContext;\n-import com.google.cloud.tools.jib.http.Authorization;\n-import com.google.cloud.tools.jib.registry.RegistryAuthenticator;\n+import com.google.cloud.tools.jib.registry.RegistryClient;\n+import com.google.cloud.tools.jib.registry.credentials.CredentialRetrievalException;\n import java.io.IOException;\n-import java.util.Optional;\n import java.util.concurrent.Callable;\n-import javax.annotation.Nullable;\n \n /**\n  * Authenticates push to a target registry using Docker Token Authentication.\n  *\n  * @see <a\n  *     href=\"https://docs.docker.com/registry/spec/auth/token/\">https://docs.docker.com/registry/spec/auth/token/</a>\n  */\n-class AuthenticatePushStep implements Callable<Optional<Authorization>> {\n+class AuthenticatePushStep implements Callable<RegistryClient> {\n \n   private static final String DESCRIPTION = \"Authenticating push to %s\";\n \n   private final BuildContext buildContext;\n   private final ProgressEventDispatcher.Factory progressEventDispatcherFactory;\n-  @Nullable private final Credential registryCredential;\n \n   AuthenticatePushStep(\n-      BuildContext buildContext,\n-      ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n-      @Nullable Credential registryCredential) {\n+      BuildContext buildContext, ProgressEventDispatcher.Factory progressEventDispatcherFactory) {\n     this.buildContext = buildContext;\n     this.progressEventDispatcherFactory = progressEventDispatcherFactory;\n-    this.registryCredential = registryCredential;\n   }\n \n   @Override\n-  public Optional<Authorization> call() throws IOException, RegistryException {\n+  public RegistryClient call() throws CredentialRetrievalException, IOException, RegistryException {\n     String registry = buildContext.getTargetImageConfiguration().getImageRegistry();\n     try (ProgressEventDispatcher ignored =\n             progressEventDispatcherFactory.create(\"authenticating push to \" + registry, 1);\n         TimerEventDispatcher ignored2 =\n             new TimerEventDispatcher(\n                 buildContext.getEventHandlers(), String.format(DESCRIPTION, registry))) {\n-      Optional<RegistryAuthenticator> registryAuthenticator =\n+      Credential credential =\n+          RegistryCredentialRetriever.getTargetImageCredential(buildContext).orElse(null);\n+\n+      RegistryClient registryClient =\n           buildContext\n               .newTargetImageRegistryClientFactory()\n-              .newRegistryClient()\n-              .getRegistryAuthenticator();\n-      if (registryAuthenticator.isPresent()) {\n-        return Optional.of(registryAuthenticator.get().authenticatePush(registryCredential));\n+              .setCredential(credential)", "originalCommit": "c9f9dfeb1ffb89b379405e9229b42e8116c3eb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg1MDEwMQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r369850101", "bodyText": "Actually looking at stuff further down the code, the flow is ever so slightly different everywhere?", "author": "loosebazooka", "createdAt": "2020-01-22T22:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0OTU5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIxMTUyOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2233#discussion_r370211529", "bodyText": "Yeah. I understand the flow may seem strange and make you think perhaps this logic could just be put inside the registry client. I thought the same.\nI don't have any history, but our way of doing auth has been like this:\n\nFor pull (base image): first try pulling a manifest without any credentials. If it fails, configure basic auth no matter what and try pulling a manifest again. If it fails, initiate pull bearer auth (and try pulling a manifest).\nFor push (target image): always initiate push bearer auth first. If the server returns asking for basic auth, configure basic auth.\n\nSo, for now, basically the overall auth logic is different per use-case and needs to be defined at a higher level. That's why I made the registry client provide the necessary knobs (configureBasicAuth and doPull/PushBearerAuth) and let the caller decide how to drive it.", "author": "chanseokoh", "createdAt": "2020-01-23T16:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0OTU5Mw=="}], "type": "inlineReview"}, {"oid": "a4eb78eccfc4ab22795dfdbe258b9ec78b50e446", "url": "https://github.com/GoogleContainerTools/jib/commit/a4eb78eccfc4ab22795dfdbe258b9ec78b50e446", "message": "CHANGELOG and progress dispatch", "committedDate": "2020-01-23T16:28:55Z", "type": "commit"}]}