{"pr_number": 2531, "pr_title": "New option to skip pushing images (manifests) if the image (manifest) already exists in the target registry", "pr_createdAt": "2020-06-16T15:36:12Z", "pr_url": "https://github.com/GoogleContainerTools/jib/pull/2531", "timeline": [{"oid": "81dd88496527fe2e27ac61b55f24623d30f59177", "url": "https://github.com/GoogleContainerTools/jib/commit/81dd88496527fe2e27ac61b55f24623d30f59177", "message": "Adds proposal to control the pushing of tags on existing images in target registry.", "committedDate": "2020-04-06T14:15:00Z", "type": "commit"}, {"oid": "9eaf43bc9b05540afe487039408c0bf6a26a9a4c", "url": "https://github.com/GoogleContainerTools/jib/commit/9eaf43bc9b05540afe487039408c0bf6a26a9a4c", "message": "Updates proposal with more detail.", "committedDate": "2020-04-14T12:01:23Z", "type": "commit"}, {"oid": "7a5faaf2ad4da52ca224566469ee73a92e266eee", "url": "https://github.com/GoogleContainerTools/jib/commit/7a5faaf2ad4da52ca224566469ee73a92e266eee", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-04-15T08:24:15Z", "type": "commit"}, {"oid": "987c58cfec454be74a4c14c387c6e3446d43c47b", "url": "https://github.com/GoogleContainerTools/jib/commit/987c58cfec454be74a4c14c387c6e3446d43c47b", "message": "Work for tags-on-existing-images.md", "committedDate": "2020-05-08T19:08:35Z", "type": "commit"}, {"oid": "75a9b926d90690cf01dc499cce722490a233be0e", "url": "https://github.com/GoogleContainerTools/jib/commit/75a9b926d90690cf01dc499cce722490a233be0e", "message": "Merge branch 'master' of https://github.com/GoogleContainerTools/jib", "committedDate": "2020-05-08T19:08:51Z", "type": "commit"}, {"oid": "8719adbd4662aad591573ae8d31c130622556932", "url": "https://github.com/GoogleContainerTools/jib/commit/8719adbd4662aad591573ae8d31c130622556932", "message": "Cleanup.", "committedDate": "2020-06-14T12:05:54Z", "type": "commit"}, {"oid": "1533d8f0be3de9c54e119a996fcfca0df2838bd1", "url": "https://github.com/GoogleContainerTools/jib/commit/1533d8f0be3de9c54e119a996fcfca0df2838bd1", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-06-14T12:07:38Z", "type": "commit"}, {"oid": "82b1f34206ee6f9a309b521e29c3016de21bf591", "url": "https://github.com/GoogleContainerTools/jib/commit/82b1f34206ee6f9a309b521e29c3016de21bf591", "message": "* Simplified implementation:\n  * Removed newly added class ManifestDescriptor, replaced it with already existing ManifestAndDigest.\n  * Removed the CheckImageStep and incorporated the check within the PushImageStep. Implementation now follows similar checks, eg, in PushBlopStep.\n* Adds unit and integration tests.\n* Fixes resulting from testing.", "committedDate": "2020-06-16T15:05:00Z", "type": "commit"}, {"oid": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "url": "https://github.com/GoogleContainerTools/jib/commit/cb5acaa9a3a12d311e1f94a840b052c9daabb536", "message": "Code formatting changes.", "committedDate": "2020-06-16T15:31:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0MzIyMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r444243223", "bodyText": "this comment seems to be off? maybe should be unknown ?", "author": "loosebazooka", "createdAt": "2020-06-23T13:55:29Z", "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/ManifestCheckerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.google.cloud.tools.jib.api.RegistryException;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.http.FailoverHttpClient;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import java.io.IOException;\n+import java.util.Optional;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+/** Integration tests for {@link ManifestChecker}. */\n+public class ManifestCheckerIntegrationTest {\n+\n+  /** A known manifest list sha for openjdk:11-jre-slim. */\n+  public static final String KNOWN_MANIFEST =\n+      \"sha256:8ab7b3078b01ba66b937b7fbe0b9eccf60449cc101c42e99aeefaba0e1781155\";\n+\n+  /** A known manifest list sha for openjdk:11-jre-slim. */", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0Mzk5Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r444243997", "bodyText": "is this necessary? who's using busybox? Actually the whole localRegistry harness maybe isn't used? we can remove it?", "author": "loosebazooka", "createdAt": "2020-06-23T13:56:29Z", "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/ManifestCheckerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.google.cloud.tools.jib.api.RegistryException;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.http.FailoverHttpClient;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import java.io.IOException;\n+import java.util.Optional;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+/** Integration tests for {@link ManifestChecker}. */\n+public class ManifestCheckerIntegrationTest {\n+\n+  /** A known manifest list sha for openjdk:11-jre-slim. */\n+  public static final String KNOWN_MANIFEST =\n+      \"sha256:8ab7b3078b01ba66b937b7fbe0b9eccf60449cc101c42e99aeefaba0e1781155\";\n+\n+  /** A known manifest list sha for openjdk:11-jre-slim. */\n+  public static final String UNKNOWN_MANIFEST =\n+      \"sha256:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n+\n+  @ClassRule public static final LocalRegistry localRegistry = new LocalRegistry(5000);\n+\n+  @BeforeClass\n+  public static void setUp() throws IOException, InterruptedException {\n+    localRegistry.pullAndPushToLocal(\"busybox\", \"busybox\");", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NDk5MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r444244990", "bodyText": "2018 -> 2020", "author": "loosebazooka", "createdAt": "2020-06-23T13:57:44Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r444247674", "bodyText": "I don't think we should be duplicating code like this, the code in ManifestPuller and this can go out of sync. Is there a way provide a shared resource that both can refrence?", "author": "loosebazooka", "createdAt": "2020-06-23T14:01:18Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.api.client.http.HttpMethods;\n+import com.google.api.client.http.HttpStatusCodes;\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.http.BlobHttpContent;\n+import com.google.cloud.tools.jib.http.Response;\n+import com.google.cloud.tools.jib.http.ResponseException;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.OciManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.UnknownManifestFormatException;\n+import com.google.cloud.tools.jib.image.json.V21ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestListTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/** Checks an image's manifest. */\n+public class ManifestChecker<T extends ManifestTemplate>\n+    implements RegistryEndpointProvider<Optional<ManifestAndDigest<T>>> {\n+\n+  private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n+  private final String imageDescriptor;\n+  private final Class<T> manifestTemplateClass;\n+\n+  ManifestChecker(\n+      RegistryEndpointRequestProperties registryEndpointRequestProperties,\n+      String imageDescriptor,\n+      Class<T> manifestTemplateClass) {\n+    this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n+    this.imageDescriptor = imageDescriptor;\n+    this.manifestTemplateClass = manifestTemplateClass;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public BlobHttpContent getContent() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAccept() {", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3NDE4Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445174186", "bodyText": "Agreed. I really think we should not duplicate this much amount of code.", "author": "chanseokoh", "createdAt": "2020-06-24T21:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDExMTg1OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450111859", "bodyText": "I don't see an easy way how to extract common code from the 2 classes, given that they implement the RegistryEndpointProvider interface with 2 different types. A simple option would be to completely do away with the ManifestChecker class and change the implementation of RegistryClient.checkImage to use RegistryClient.pullManifest and catch the exception when the image does not exist, like so:\n  public Optional<ManifestAndDigest<ManifestTemplate>> checkImage(String imageDigest)\n    throws IOException, RegistryException {\n    try {\n      return Optional.ofNullable(pullManifest(imageDigest, ManifestTemplate.class));\n    } catch (RegistryErrorException e) {\n      return Optional.empty();\n    }\n  }\n\nWhat do you think?", "author": "karlmuscat", "createdAt": "2020-07-06T09:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMTE2OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450231168", "bodyText": "Would you mind if I push changes to your PR?", "author": "chanseokoh", "createdAt": "2020-07-06T13:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzNjAxMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450236013", "bodyText": "Why would I? \ud83d\ude04", "author": "karlmuscat", "createdAt": "2020-07-06T13:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxMjM4Ng==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450412386", "bodyText": "Discussed this with @loosebazooka. I can take care of code duplication in a follow-up PR.", "author": "chanseokoh", "createdAt": "2020-07-06T18:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ4NDEzNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450484137", "bodyText": "I've just taken care of this in this PR.", "author": "chanseokoh", "createdAt": "2020-07-06T21:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI0NzY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTU3NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445169575", "bodyText": "This check is still suffering from the concurrency issue I mentioned in #2387 (comment). As we discussed, you should follow the design outlined in the proposal to create a separate -Step class to call registryClient.checkImage(). If the program control already reached here, it means multiple PushImageSteps are scheduled and running.", "author": "chanseokoh", "createdAt": "2020-06-24T21:01:33Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushImageStep.java", "diffHunk": "@@ -47,23 +45,25 @@\n       ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n       RegistryClient registryClient,\n       BlobDescriptor containerConfigurationDigestAndSize,\n-      Image builtImage)\n-      throws IOException {\n+      BuildableManifestTemplate manifestTemplate,\n+      DescriptorDigest imageDigest)\n+      throws IOException, RegistryException {\n     Set<String> tags = buildContext.getAllTargetImageTags();\n \n+    EventHandlers eventHandlers = buildContext.getEventHandlers();\n+\n     try (TimerEventDispatcher ignored =\n-            new TimerEventDispatcher(\n-                buildContext.getEventHandlers(), \"Preparing manifest pushers\");\n+            new TimerEventDispatcher(eventHandlers, \"Preparing manifest pushers\");\n         ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"launching manifest pushers\", tags.size())) {\n \n-      // Gets the image manifest to push.\n-      BuildableManifestTemplate manifestTemplate =\n-          new ImageToJsonTranslator(builtImage)\n-              .getManifestTemplate(\n-                  buildContext.getTargetFormat(), containerConfigurationDigestAndSize);\n+      if (JibSystemProperties.skipExistingImages()\n+          && registryClient.checkImage(imageDigest.toString()).isPresent()) {", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0Njk3NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450046974", "bodyText": "The PushImageStep steps are being created after the condition is evaluated to false. If it evaluates to true, no steps are created and an empty list is returned. It seems like it achieves the same behaviour but with simpler code. If you think that adding a new step is better, Ill change it.", "author": "karlmuscat", "createdAt": "2020-07-06T07:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNTc1NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450225755", "bodyText": "Oh, I jumped into the conclusion too early after I saw this check in this file.\nHowever, you still need to create a separate Step for a blocking network call. makeList() should just create and return necessary Steps instantaneously and should never block thread scheduling in StepsRunner.", "author": "chanseokoh", "createdAt": "2020-07-06T13:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI1Njc5Nw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450256797", "bodyText": "Ok. Can you have a look at commit 987c58c? I had initially introduced a step before the makeList call. You should look at CheckImageStep, PushImageStep and StepsRunner. Should I change it to something like that?", "author": "karlmuscat", "createdAt": "2020-07-06T14:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI4NDI2Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450284263", "bodyText": "The direction seems right. However, we maintain complete separation between business logic (what Steps do) and the async handling (what StepsRunner do). That is, StepsRunner doesn't care what each Step does or implies but is only interested in scheduling Steps, passing parameters to them as necessary, and ultimately storing results in results.*. All the business logic (building a manifest and computing its digest and the conditional skip) should go out of StepsRunner. For example, StepsRunner code shouldn't have conditional Step scheduling based on the result of some step. So, probably you should put the manifest construction and digest computation into CheckImageStep. The step would then return an Optional<Manifest...>, and StepsRunner would just store the result. (If deemed necessary, CheckImageStep could return the manifest it built, but because anyone can easily build the same manifest later, this may be unnecessary.) This manifest check result should probably be passed into makeList() where it returns either an empty list or multiple PushImageStep instances based on the result. The responsibility of makeList() should just be about properly instantiating necessary -Step instances where all the core business logic goes in.", "author": "chanseokoh", "createdAt": "2020-07-06T15:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMyMzcyMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450323723", "bodyText": "Pushed new changes for this.", "author": "karlmuscat", "createdAt": "2020-07-06T16:01:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTg2OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445169868", "bodyText": "2020", "author": "chanseokoh", "createdAt": "2020-06-24T21:02:08Z", "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/ManifestCheckerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2018 Google LLC.", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDM1OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445170358", "bodyText": "Please catch the specific exception and verify the exception message (assertEquals(..., ex.getMessage()) or assertThat(ex.getMessage(), ....containsString(...)) for example).", "author": "chanseokoh", "createdAt": "2020-06-24T21:03:11Z", "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());\n+\n+    // Push the same image with a different tag, with SKIP_EXISTING_IMAGES enabled.\n+    JibContainer image2 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"new_testtag\"),\n+            Collections.emptyList());\n+\n+    // Test that the pull request throws an exception, indicating that the new tag was not pushed.\n+    String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n+    try {\n+      localRegistry.pull(imageReference3);\n+      Assert.fail(\n+          \"jib.skipExistingImages was enabled and digest was already pushed, \"\n+              + \"hence testtag2 shouldn't have been pushed.\");\n+    } catch (RuntimeException ignore) {\n+      // As expected, registry throws exception that manifest is unknown.", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0ODAwOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450048009", "bodyText": "The exception thrown is a RuntimeException. I'll add assertions on the message though.", "author": "karlmuscat", "createdAt": "2020-07-06T07:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyMjgwMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450222802", "bodyText": "Sounds good. Please verify the message.", "author": "chanseokoh", "createdAt": "2020-07-06T13:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzNjQxOA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450236418", "bodyText": "nit: per our style, it should be ex instead of e:\n } catch (RuntimeException ex) {", "author": "chanseokoh", "createdAt": "2020-07-06T13:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MDM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTc5NQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445171795", "bodyText": "We use @Rule RestoreSystemProperties to clean up system properties, because cleaning this way is fragile unless it's wrapper around try { ... } finally { ...}.", "author": "chanseokoh", "createdAt": "2020-06-24T21:06:11Z", "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());\n+\n+    // Push the same image with a different tag, with SKIP_EXISTING_IMAGES enabled.\n+    JibContainer image2 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"new_testtag\"),\n+            Collections.emptyList());\n+\n+    // Test that the pull request throws an exception, indicating that the new tag was not pushed.\n+    String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n+    try {\n+      localRegistry.pull(imageReference3);\n+      Assert.fail(\n+          \"jib.skipExistingImages was enabled and digest was already pushed, \"\n+              + \"hence testtag2 shouldn't have been pushed.\");\n+    } catch (RuntimeException ignore) {\n+      // As expected, registry throws exception that manifest is unknown.\n+    }\n+\n+    // Test that both images have the same properties.\n+    Assert.assertEquals(image1.getDigest(), image2.getDigest());\n+    Assert.assertEquals(image1.getImageId(), image2.getImageId());\n+\n+    // Cleanup. Disable option to not disrupt other tests.\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"false\");", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyMzY0NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450223644", "bodyText": "Just in case, I will \"unresolve\" conversations (include this) until I can verify actual changes. :)", "author": "chanseokoh", "createdAt": "2020-07-06T13:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzNDk0NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450234944", "bodyText": "Ah, I was looking at an earlier commit. I will undo \"unresolving\".", "author": "chanseokoh", "createdAt": "2020-07-06T13:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MTc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MzIwNw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445173207", "bodyText": "I think we can skip this testing, as the target of this test method is to test SKIP_EXISTING_IMAGES. Our integration are increasing running more Docker images and getting slower.", "author": "chanseokoh", "createdAt": "2020-06-24T21:09:17Z", "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA0NjkxOQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450046919", "bodyText": "Do you mean that all the test is unnecessary, or just the part where testtag and testtag2 are pulled and tested for existence?", "author": "karlmuscat", "createdAt": "2020-07-06T07:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIxODg3MA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450218870", "bodyText": "Sorry, I mean this \"Hello, world\" assertion on this line and and assertDockerInpsect() on line 243. Also remove them on line 236 and 237.", "author": "chanseokoh", "createdAt": "2020-07-06T13:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MzIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3MzY5OQ==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445173699", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n          \n          \n            \n                try {\n          \n          \n            \n                  localRegistry.pull(imageReference3);\n          \n          \n            \n                try {\n          \n          \n            \n                  localRegistry.pull(\"localhost:5000/testimagerepo:new_testtag\");", "author": "chanseokoh", "createdAt": "2020-06-24T21:10:13Z", "path": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ContainerizerIntegrationTest.java", "diffHunk": "@@ -218,7 +219,60 @@ public void testSteps_forBuildToDockerRegistry_multipleTags()\n   }\n \n   @Test\n-  public void tesBuildToDockerRegistry_dockerHubBaseImage()\n+  public void testSteps_forBuildToDockerRegistry_skipExistingDigest()\n+      throws IOException, InterruptedException, ExecutionException, RegistryException,\n+          CacheDirectoryCreationException {\n+    System.setProperty(JibSystemProperties.SKIP_EXISTING_IMAGES, \"true\");\n+\n+    JibContainer image1 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"testtag\"),\n+            Collections.singletonList(\"testtag2\"));\n+\n+    // Test that the initial image with the original tag has been pushed.\n+    String imageReference = \"localhost:5000/testimagerepo:testtag\";\n+    localRegistry.pull(imageReference);\n+    assertDockerInspect(imageReference);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\", new Command(\"docker\", \"run\", \"--rm\", imageReference).run());\n+\n+    // Test that any additional tags have also been pushed with the original image.\n+    String imageReference2 = \"localhost:5000/testimagerepo:testtag2\";\n+    localRegistry.pull(imageReference2);\n+    assertDockerInspect(imageReference2);\n+    Assert.assertEquals(\n+        \"Hello, world. An argument.\\n\",\n+        new Command(\"docker\", \"run\", \"--rm\", imageReference2).run());\n+\n+    // Push the same image with a different tag, with SKIP_EXISTING_IMAGES enabled.\n+    JibContainer image2 =\n+        buildRegistryImage(\n+            ImageReference.of(\"gcr.io\", \"distroless/java\", DISTROLESS_DIGEST),\n+            ImageReference.of(\"localhost:5000\", \"testimagerepo\", \"new_testtag\"),\n+            Collections.emptyList());\n+\n+    // Test that the pull request throws an exception, indicating that the new tag was not pushed.\n+    String imageReference3 = \"localhost:5000/testimagerepo:new_testtag\";\n+    try {\n+      localRegistry.pull(imageReference3);", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3NDk0OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r445174948", "bodyText": "I didn't find any usage of passing manifestTemplateClass in this PR. Maybe just\n  public Optional<ManifestAndDigest<ManifestTemplate>> checkImage(String imageDigest)\n\n?", "author": "chanseokoh", "createdAt": "2020-06-24T21:12:48Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/RegistryClient.java", "diffHunk": "@@ -367,6 +367,31 @@ private Authorization refreshBearerAuth(@Nullable String wwwAuthenticate)\n     return Verify.verifyNotNull(initialBearerAuthenticator.get()).authenticatePush(credential);\n   }\n \n+  /**\n+   * Check if an image is on the registry.\n+   *\n+   * @param <T> child type of ManifestTemplate\n+   * @param manifestTemplateClass the specific version of manifest template to check\n+   * @param imageDigest the image digest to check for\n+   * @return the image's {@link ManifestAndDigest} if the image exists on the registry, or {@link\n+   *     Optional#empty()} if it doesn't\n+   * @throws IOException if communicating with the endpoint fails\n+   * @throws RegistryException if communicating with the endpoint fails\n+   */\n+  public <T extends ManifestTemplate> Optional<ManifestAndDigest<T>> checkImage(\n+      String imageDigest, Class<T> manifestTemplateClass) throws IOException, RegistryException {", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "150be620a68238860cef42149dfae580238e092a", "url": "https://github.com/GoogleContainerTools/jib/commit/150be620a68238860cef42149dfae580238e092a", "message": "Code cleanup, post-review.", "committedDate": "2020-07-06T08:42:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMzA1Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450233053", "bodyText": "Could you explain these two checks (responseException.getContext() and ErrorCodes.MANIFEST_UNKNOWN)? I am asking because we've seen different registries have different behaviors that are not really conformant to the Registry API standard, and would like to know if these checks are specific to a certain registry implementation.", "author": "chanseokoh", "createdAt": "2020-07-06T13:48:58Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/registry/ManifestChecker.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2018 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.registry;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.api.client.http.HttpMethods;\n+import com.google.api.client.http.HttpStatusCodes;\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.http.BlobHttpContent;\n+import com.google.cloud.tools.jib.http.Response;\n+import com.google.cloud.tools.jib.http.ResponseException;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.OciManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.UnknownManifestFormatException;\n+import com.google.cloud.tools.jib.image.json.V21ManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestListTemplate;\n+import com.google.cloud.tools.jib.image.json.V22ManifestTemplate;\n+import com.google.cloud.tools.jib.json.JsonTemplateMapper;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+\n+/** Checks an image's manifest. */\n+public class ManifestChecker<T extends ManifestTemplate>\n+    implements RegistryEndpointProvider<Optional<ManifestAndDigest<T>>> {\n+\n+  private final RegistryEndpointRequestProperties registryEndpointRequestProperties;\n+  private final String imageDescriptor;\n+  private final Class<T> manifestTemplateClass;\n+\n+  ManifestChecker(\n+      RegistryEndpointRequestProperties registryEndpointRequestProperties,\n+      String imageDescriptor,\n+      Class<T> manifestTemplateClass) {\n+    this.registryEndpointRequestProperties = registryEndpointRequestProperties;\n+    this.imageDescriptor = imageDescriptor;\n+    this.manifestTemplateClass = manifestTemplateClass;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public BlobHttpContent getContent() {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<String> getAccept() {\n+    if (manifestTemplateClass.equals(V21ManifestTemplate.class)) {\n+      return Collections.singletonList(V21ManifestTemplate.MEDIA_TYPE);\n+    }\n+    if (manifestTemplateClass.equals(V22ManifestTemplate.class)) {\n+      return Collections.singletonList(V22ManifestTemplate.MANIFEST_MEDIA_TYPE);\n+    }\n+    if (manifestTemplateClass.equals(OciManifestTemplate.class)) {\n+      return Collections.singletonList(OciManifestTemplate.MANIFEST_MEDIA_TYPE);\n+    }\n+    if (manifestTemplateClass.equals(V22ManifestListTemplate.class)) {\n+      return Collections.singletonList(V22ManifestListTemplate.MANIFEST_MEDIA_TYPE);\n+    }\n+\n+    // V22ManifestListTemplate is not included by default, we don't explicitly accept\n+    // it, we only handle it if referenced by sha256 (see getManifestTemplateFromJson) in which\n+    // case registries ignore the \"accept\" directive and just return a manifest list anyway.\n+    return Arrays.asList(\n+        OciManifestTemplate.MANIFEST_MEDIA_TYPE,\n+        V22ManifestTemplate.MANIFEST_MEDIA_TYPE,\n+        V21ManifestTemplate.MEDIA_TYPE);\n+  }\n+\n+  /** Parses the response body into a {@link ManifestAndDigest}. */\n+  @Override\n+  public Optional<ManifestAndDigest<T>> handleResponse(Response response)\n+      throws IOException, UnknownManifestFormatException {\n+    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+    DescriptorDigest digest =\n+        Digests.computeDigest(response.getBody(), byteArrayOutputStream).getDigest();\n+    String jsonString = byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n+    T manifestTemplate = getManifestTemplateFromJson(jsonString);\n+    return Optional.of(new ManifestAndDigest<>(manifestTemplate, digest));\n+  }\n+\n+  @Override\n+  public URL getApiRoute(String apiRouteBase) throws MalformedURLException {\n+    return new URL(\n+        apiRouteBase\n+            + registryEndpointRequestProperties.getImageName()\n+            + \"/manifests/\"\n+            + imageDescriptor);\n+  }\n+\n+  @Override\n+  public String getHttpMethod() {\n+    return HttpMethods.GET;\n+  }\n+\n+  @Override\n+  public String getActionDescription() {\n+    return \"pull image manifest for \"\n+        + registryEndpointRequestProperties.getServerUrl()\n+        + \"/\"\n+        + registryEndpointRequestProperties.getImageName()\n+        + \":\"\n+        + imageDescriptor;\n+  }\n+\n+  /**\n+   * Instantiates a {@link ManifestTemplate} from a JSON string. This checks the {@code\n+   * schemaVersion} field of the JSON to determine which manifest version to use.\n+   */\n+  private T getManifestTemplateFromJson(String jsonString)\n+      throws IOException, UnknownManifestFormatException {\n+    ObjectNode node = new ObjectMapper().readValue(jsonString, ObjectNode.class);\n+    if (!node.has(\"schemaVersion\")) {\n+      throw new UnknownManifestFormatException(\"Cannot find field 'schemaVersion' in manifest\");\n+    }\n+\n+    int schemaVersion = node.get(\"schemaVersion\").asInt(-1);\n+    if (schemaVersion == -1) {\n+      throw new UnknownManifestFormatException(\"`schemaVersion` field is not an integer\");\n+    }\n+\n+    if (schemaVersion == 1) {\n+      return manifestTemplateClass.cast(\n+          JsonTemplateMapper.readJson(jsonString, V21ManifestTemplate.class));\n+    }\n+    if (schemaVersion == 2) {\n+      // 'schemaVersion' of 2 can be either Docker V2.2 or OCI.\n+      String mediaType = node.get(\"mediaType\").asText();\n+      if (V22ManifestTemplate.MANIFEST_MEDIA_TYPE.equals(mediaType)) {\n+        return manifestTemplateClass.cast(\n+            JsonTemplateMapper.readJson(jsonString, V22ManifestTemplate.class));\n+      }\n+      if (OciManifestTemplate.MANIFEST_MEDIA_TYPE.equals(mediaType)) {\n+        return manifestTemplateClass.cast(\n+            JsonTemplateMapper.readJson(jsonString, OciManifestTemplate.class));\n+      }\n+      if (V22ManifestListTemplate.MANIFEST_MEDIA_TYPE.equals(mediaType)) {\n+        return manifestTemplateClass.cast(\n+            JsonTemplateMapper.readJson(jsonString, V22ManifestListTemplate.class));\n+      }\n+      throw new UnknownManifestFormatException(\"Unknown mediaType: \" + mediaType);\n+    }\n+    throw new UnknownManifestFormatException(\n+        \"Unknown schemaVersion: \" + schemaVersion + \" - only 1 and 2 are supported\");\n+  }\n+\n+  @Override\n+  public Optional<ManifestAndDigest<T>> handleHttpResponseException(\n+      ResponseException responseException) throws ResponseException {\n+    if (responseException.getStatusCode() != HttpStatusCodes.STATUS_CODE_NOT_FOUND) {\n+      throw responseException;\n+    }\n+\n+    // Finds a MANIFEST_BLOB_UNKNOWN error response code.\n+    if (responseException.getContent() == null) {\n+      return Optional.empty();\n+    }\n+\n+    ErrorCodes errorCode = ErrorResponseUtil.getErrorCode(responseException);\n+    if (errorCode == ErrorCodes.MANIFEST_UNKNOWN) {\n+      return Optional.empty();\n+    }", "originalCommit": "cb5acaa9a3a12d311e1f94a840b052c9daabb536", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI0MDI3OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450240278", "bodyText": "I have followed the same pattern done in BlobChecker.", "author": "karlmuscat", "createdAt": "2020-07-06T13:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMzA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxMTg3NA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450411874", "bodyText": "Alright, I will look into the Registry API specification later for this part and will probably take care of this one way or another in a follow-up PR. But I think at least this works and doesn't actually break things, since this is just an extra manifest check; the worst case would be getting an error later. So I think we are good to go.", "author": "chanseokoh", "createdAt": "2020-07-06T18:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMzA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxMDI1OA==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450910258", "bodyText": "This looks good.", "author": "chanseokoh", "createdAt": "2020-07-07T14:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMzA1Mw=="}], "type": "inlineReview"}, {"oid": "0eb1ec9d4c19347ce5064d3e7b015f0f29727807", "url": "https://github.com/GoogleContainerTools/jib/commit/0eb1ec9d4c19347ce5064d3e7b015f0f29727807", "message": "Code cleanup, post-review.", "committedDate": "2020-07-06T14:14:18Z", "type": "commit"}, {"oid": "27c22cd9455b645f5307798e8571a963fa099d61", "url": "https://github.com/GoogleContainerTools/jib/commit/27c22cd9455b645f5307798e8571a963fa099d61", "message": "* Adds a new CheckImageStep and integrates it in the StepsRunner.\n* Reverts PushImageStep to the state before the PR started, apart from the manifest existence check.", "committedDate": "2020-07-06T16:01:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMyOTE4Mg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450329182", "bodyText": "Make the fields private final.", "author": "chanseokoh", "createdAt": "2020-07-06T16:10:49Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/CheckImageStep.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Google LLC.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.google.cloud.tools.jib.builder.steps;\n+\n+import com.google.cloud.tools.jib.api.DescriptorDigest;\n+import com.google.cloud.tools.jib.api.LogEvent;\n+import com.google.cloud.tools.jib.api.RegistryException;\n+import com.google.cloud.tools.jib.blob.BlobDescriptor;\n+import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n+import com.google.cloud.tools.jib.builder.TimerEventDispatcher;\n+import com.google.cloud.tools.jib.configuration.BuildContext;\n+import com.google.cloud.tools.jib.event.EventHandlers;\n+import com.google.cloud.tools.jib.global.JibSystemProperties;\n+import com.google.cloud.tools.jib.hash.Digests;\n+import com.google.cloud.tools.jib.image.Image;\n+import com.google.cloud.tools.jib.image.json.BuildableManifestTemplate;\n+import com.google.cloud.tools.jib.image.json.ImageToJsonTranslator;\n+import com.google.cloud.tools.jib.image.json.ManifestTemplate;\n+import com.google.cloud.tools.jib.registry.ManifestAndDigest;\n+import com.google.cloud.tools.jib.registry.RegistryClient;\n+import java.io.IOException;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+\n+/** Checks the existence of a manifest. */\n+class CheckImageStep implements Callable<Optional<ManifestAndDigest<ManifestTemplate>>> {\n+\n+  private static final String DESCRIPTION = \"Checking existence of manifest\";\n+\n+  BuildContext buildContext;\n+  ProgressEventDispatcher.Factory progressEventDispatcherFactory;\n+  RegistryClient registryClient;\n+  BlobDescriptor containerConfigurationDigestAndSize;\n+  Image image;", "originalCommit": "27c22cd9455b645f5307798e8571a963fa099d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ4NzY5Mw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450487693", "bodyText": "Done.", "author": "chanseokoh", "createdAt": "2020-07-06T21:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMyOTE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM0MDcyMw==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450340723", "bodyText": "On second thought, we could make makeList() always return a non-empty list and have PushImageStep.call() decide whether to skip pushing, but I can take care of this later in a follow-up PR. But at the same time, I think this approach is still acceptable.", "author": "chanseokoh", "createdAt": "2020-07-06T16:29:04Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java", "diffHunk": "@@ -394,10 +415,15 @@ private void pushImages() {\n                           childProgressDispatcherFactory,\n                           results.targetRegistryClient.get(),\n                           results.containerConfigurationPushResult.get(),\n-                          results.builtImage.get()));\n+                          results.builtImage.get(),\n+                          results.manifestCheckResult.get().isPresent()));\n               realizeFutures(manifestPushResults);\n               // Manifest pushers return the same BuildResult.\n-              return manifestPushResults.get(0).get();\n+              return manifestPushResults.isEmpty()", "originalCommit": "27c22cd9455b645f5307798e8571a963fa099d61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQzMDYxMg==", "url": "https://github.com/GoogleContainerTools/jib/pull/2531#discussion_r450430612", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return ImmutableList.<PushImageStep>builder().build();\n          \n          \n            \n                    return ImmutableList.of();", "author": "chanseokoh", "createdAt": "2020-07-06T19:20:04Z", "path": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushImageStep.java", "diffHunk": "@@ -47,16 +48,25 @@\n       ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n       RegistryClient registryClient,\n       BlobDescriptor containerConfigurationDigestAndSize,\n-      Image builtImage)\n+      Image builtImage,\n+      boolean manifestAlreadyExists)\n       throws IOException {\n     Set<String> tags = buildContext.getAllTargetImageTags();\n \n+    EventHandlers eventHandlers = buildContext.getEventHandlers();\n+\n     try (TimerEventDispatcher ignored =\n-            new TimerEventDispatcher(\n-                buildContext.getEventHandlers(), \"Preparing manifest pushers\");\n+            new TimerEventDispatcher(eventHandlers, \"Preparing manifest pushers\");\n         ProgressEventDispatcher progressEventDispatcher =\n             progressEventDispatcherFactory.create(\"launching manifest pushers\", tags.size())) {\n \n+      if (JibSystemProperties.skipExistingImages() && manifestAlreadyExists) {\n+        eventHandlers.dispatch(\n+            LogEvent.info(\"Skipping pushing manifest; manifest already exists.\"));\n+\n+        return ImmutableList.<PushImageStep>builder().build();", "originalCommit": "27c22cd9455b645f5307798e8571a963fa099d61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c3fb5093898c56728164b36b74b306a70931ecd3", "url": "https://github.com/GoogleContainerTools/jib/commit/c3fb5093898c56728164b36b74b306a70931ecd3", "message": "Refactor code", "committedDate": "2020-07-06T21:09:08Z", "type": "commit"}, {"oid": "f132d74cc7a8efd4cf47abe9410e4924c2ae45e0", "url": "https://github.com/GoogleContainerTools/jib/commit/f132d74cc7a8efd4cf47abe9410e4924c2ae45e0", "message": "Merge remote-tracking branch 'origin/master' into karlmuscat", "committedDate": "2020-07-06T21:25:23Z", "type": "commit"}, {"oid": "026f2e29653f446fbce772981e9085440c1d95c2", "url": "https://github.com/GoogleContainerTools/jib/commit/026f2e29653f446fbce772981e9085440c1d95c2", "message": "CHANGELOG", "committedDate": "2020-07-06T22:01:19Z", "type": "commit"}, {"oid": "6756f1cfe3b6e5b3ba882be59d603a37424dfa3f", "url": "https://github.com/GoogleContainerTools/jib/commit/6756f1cfe3b6e5b3ba882be59d603a37424dfa3f", "message": "Update comments", "committedDate": "2020-07-06T22:05:52Z", "type": "commit"}, {"oid": "2ebc0610c67a319664eea8f21c3a8b7a7762e34f", "url": "https://github.com/GoogleContainerTools/jib/commit/2ebc0610c67a319664eea8f21c3a8b7a7762e34f", "message": "Improve test", "committedDate": "2020-07-07T14:21:37Z", "type": "commit"}]}