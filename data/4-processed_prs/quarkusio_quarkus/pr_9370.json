{"pr_number": 9370, "pr_title": "Add a Redis extension", "pr_createdAt": "2020-05-16T09:00:22Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9370", "timeline": [{"oid": "f83ccaca2c929572b1ef5d8291ac9138be2f18bd", "url": "https://github.com/quarkusio/quarkus/commit/f83ccaca2c929572b1ef5d8291ac9138be2f18bd", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T09:09:33Z", "type": "forcePushed"}, {"oid": "5b6f88cfa294ef70e9e3af2a96ba30bea80f0792", "url": "https://github.com/quarkusio/quarkus/commit/5b6f88cfa294ef70e9e3af2a96ba30bea80f0792", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T12:44:54Z", "type": "forcePushed"}, {"oid": "b10c8c791ef519a097880e67c702b4de691e8567", "url": "https://github.com/quarkusio/quarkus/commit/b10c8c791ef519a097880e67c702b4de691e8567", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T13:04:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTgwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426155805", "bodyText": "Given this is a new extension, shouldn't we just forgo the Axle client altogether?", "author": "geoand", "createdAt": "2020-05-16T13:56:48Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,536 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.\n+\n+[NOTE]\n+====\n+This extension is considered `preview`.\n+API or configuration properties might change as the extension matures.\n+Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].\n+====\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"vertx-redis, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to do the perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n+\n+Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.vertx.mutiny.redis.client.Response;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+@Singleton\n+class IncrementService {\n+\n+    @Inject\n+    SyncRedisAPI syncRedisAPI; <1>\n+\n+    @Inject\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI; <2>\n+\n+    @Inject\n+    io.vertx.axle.redis.client.RedisAPI axleRedisAPI; <3>", "originalCommit": "b10c8c791ef519a097880e67c702b4de691e8567", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2Njc2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426166767", "bodyText": "I am seeing that it is deprecated in other extensions e.g mailer. I'll  remove it.", "author": "machi1990", "createdAt": "2020-05-16T16:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426156079", "bodyText": "Let's try and not use this style anymore.\nRecently we have updated, Data source, Mongo, Mailer and Flyway (for Liquibase I just opened a PR) to avoid this old ugly pattern.\nSo let's try and use the new better pattern with this extension please.", "author": "geoand", "createdAt": "2020-05-16T14:00:20Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/runtime/RedisAPIsProducer.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package io.quarkus.vertx.redis.runtime;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.vertx.core.Vertx;\n+import io.vertx.redis.client.Redis;\n+import io.vertx.redis.client.RedisAPI;\n+import io.vertx.redis.client.RedisOptions;\n+\n+@ApplicationScoped\n+public class RedisAPIsProducer {\n+    static long timeout = 10;\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    Redis redisClient;\n+\n+    RedisAPI redisAPI;\n+\n+    SyncRedisAPI syncRedisAPI;\n+\n+    io.vertx.axle.redis.client.Redis axleRedisClient;\n+\n+    io.vertx.axle.redis.client.RedisAPI axleRedisAPI;\n+\n+    io.vertx.mutiny.redis.client.Redis mutinyRedisClient;\n+\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI;\n+\n+    void initialize(RedisOptions redisOptions) {", "originalCommit": "b10c8c791ef519a097880e67c702b4de691e8567", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2NjQyNA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426166424", "bodyText": "I had this pattern hanging in for a while, but I honestly do not think it is ugly. I'll try to change it for consistency with the other.", "author": "machi1990", "createdAt": "2020-05-16T16:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2Nzc1OA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426167758", "bodyText": "It's ugly in the sense that a CDI bean is created without having it's state fully populated. That goes against what CDI is meant for and was only done in the older versions of code because we had no better alternative.\nWith the advent of synthetic beans, we now have a much more consistent way of handling things.", "author": "geoand", "createdAt": "2020-05-16T16:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE3MDUwNA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426170504", "bodyText": "Thanks for clarifying it. I do not think we need here right? I mean, I needed the .initialize() method because in the earlier version of the extension there was no better way of injecting runtime config roots, now that we can I think we can make use of that. And remove other unnecessary bits. So good eye for spotting this one :-)", "author": "machi1990", "createdAt": "2020-05-16T16:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE3MDc1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r426170757", "bodyText": "Yes exactly my point. Config roots can just be infected into the beans.\nAny extra options not provided by config root but created in recorders should create synthetic beans that are then injected into the beans where they are used", "author": "geoand", "createdAt": "2020-05-16T16:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NjA3OQ=="}], "type": "inlineReview"}, {"oid": "4e6190c281059772ea95f52270e36411141392fc", "url": "https://github.com/quarkusio/quarkus/commit/4e6190c281059772ea95f52270e36411141392fc", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T16:43:08Z", "type": "forcePushed"}, {"oid": "cb7a3b807b2caf7a13815f36ddd63d3967966f37", "url": "https://github.com/quarkusio/quarkus/commit/cb7a3b807b2caf7a13815f36ddd63d3967966f37", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T16:46:58Z", "type": "forcePushed"}, {"oid": "bffa19bb8c004c40b8f56d836176de0d49bc5ecb", "url": "https://github.com/quarkusio/quarkus/commit/bffa19bb8c004c40b8f56d836176de0d49bc5ecb", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-16T19:20:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTAxNg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429169016", "bodyText": "I wonder if it makes sense to group these methods somehow. My reasoning is that we have a ton of methods so perhaps it would be useful to users to be able to more easily locate methods if they can be added to appropriate groups.", "author": "geoand", "createdAt": "2020-05-22T10:29:32Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/SyncRedisAPI.java", "diffHunk": "@@ -0,0 +1,417 @@\n+package io.quarkus.vertx.redis;\n+\n+import java.util.List;\n+\n+import io.vertx.redis.client.Response;\n+\n+/**\n+ * A synchronous RedisAPI offering blocking Redis commands.\n+ * The commands have a default timeout of 10 seconds which can be configured\n+ * via {@code quarkus.redis.timeout} configuration knob.\n+ *\n+ * For more information about how each individual command visit\n+ * the <a href=\"https://redis.io/commands\">Redis Commands Page</a>\n+ */\n+public interface SyncRedisAPI {", "originalCommit": "bffa19bb8c004c40b8f56d836176de0d49bc5ecb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2OTM0NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429369344", "bodyText": "This API design was heavily inspired by the mutiny based API.\nI'll be inclined to keep this dense to match the reactive counterpart.\nIn the future this class be gone as IIRC there a plans in Vert.x to provide a blocking based API - I just cannot seem to find the issue/PR were I saw this plan.\n/cc @pmlopes @cescoffier if you have any info.", "author": "machi1990", "createdAt": "2020-05-22T17:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3MzUzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429373539", "bodyText": "Hi, I don't know how you wrote this but on vertx upstream there's an handlebar template we have to generate this from the redis metadata. Perhaps you can reuse, improve it if you like", "author": "pmlopes", "createdAt": "2020-05-22T17:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NjQ3NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429376474", "bodyText": "In the future this class be gone as IIRC there a plans in Vert.x to provide a blocking based API - I just cannot seem to find the issue/PR were I saw this plan.\n/cc @pmlopes @cescoffier if you have any info.\n\nFound the issue - smallrye/smallrye-mutiny-vertx-bindings#13 but it seem closed.\n\nHi, I don't know how you wrote this but on vertx upstream there's an handlebar template we have to generate this from the redis metadata. Perhaps you can reuse, improve it if you like\n\nWell, IDE did most of the work for me really.", "author": "machi1990", "createdAt": "2020-05-22T17:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTMwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429169301", "bodyText": "These can be private final, no?", "author": "geoand", "createdAt": "2020-05-22T10:30:07Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/runtime/RedisAPIProducer.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package io.quarkus.vertx.redis.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.vertx.core.Vertx;\n+import io.vertx.redis.client.Redis;\n+import io.vertx.redis.client.RedisAPI;\n+import io.vertx.redis.client.RedisClientType;\n+import io.vertx.redis.client.RedisOptions;\n+\n+@ApplicationScoped\n+public class RedisAPIProducer {\n+    private static final char AT = '@';\n+    private static final char COLON = ':';\n+    private static final char SLASH = '/';\n+    private static final String REDIS_SCHEME = \"redis://\";\n+    private long timeout = 10;\n+\n+    Redis redisClient;\n+\n+    RedisAPI redisAPI;\n+\n+    SyncRedisAPI syncRedisAPI;\n+\n+    io.vertx.mutiny.redis.client.Redis mutinyRedisClient;\n+\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI;", "originalCommit": "bffa19bb8c004c40b8f56d836176de0d49bc5ecb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzMDQ0MA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429330440", "bodyText": "Good idea.", "author": "machi1990", "createdAt": "2020-05-22T15:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTMwMQ=="}], "type": "inlineReview"}, {"oid": "ff70985ad036e48d54730a01023fdf2332e23a5b", "url": "https://github.com/quarkusio/quarkus/commit/ff70985ad036e48d54730a01023fdf2332e23a5b", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-22T17:39:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NTA1MA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429375050", "bodyText": "Redistribution has now an official iana registered connection string url format. Upstream we have the parser under the impl package but if it makes sense you could refer to it RedisURI as the api is stable and shouldn't change.", "author": "pmlopes", "createdAt": "2020-05-22T17:40:14Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/runtime/RedisAPIProducer.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package io.quarkus.vertx.redis.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.vertx.core.Vertx;\n+import io.vertx.redis.client.Redis;\n+import io.vertx.redis.client.RedisAPI;\n+import io.vertx.redis.client.RedisClientType;\n+import io.vertx.redis.client.RedisOptions;\n+\n+@ApplicationScoped\n+class RedisAPIProducer {\n+    private static final char AT = '@';\n+    private static final char COLON = ':';\n+    private static final char SLASH = '/';\n+    private static final String REDIS_SCHEME = \"redis://\";\n+    private long timeout = 10;\n+\n+    private final Redis redisClient;\n+\n+    private final RedisAPI redisAPI;\n+\n+    private final SyncRedisAPI syncRedisAPI;\n+\n+    private final io.vertx.mutiny.redis.client.Redis mutinyRedisClient;\n+\n+    private final io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI;\n+\n+    public RedisAPIProducer(RedisConfig config, Vertx vertx) {\n+        RedisOptions options = new RedisOptions();\n+        options.setType(config.clientType);\n+\n+        if (RedisClientType.STANDALONE == config.clientType) {\n+            if (config.hosts.isPresent() && config.hosts.get().size() > 1) {\n+                throw new ConfigurationException(\"Multiple hosts supplied for non clustered configuration\");\n+            }\n+        }\n+\n+        if (config.hosts.isPresent()) {\n+            Set<InetSocketAddress> hosts = config.hosts.get();\n+            for (InetSocketAddress host : hosts) {\n+                options.addConnectionString(buildRedisUrl(host, config.password, config.database));\n+            }\n+        } else {\n+            InetSocketAddress defaultRedisAddress = new InetSocketAddress(\"localhost\", 6379);\n+            options.addConnectionString(buildRedisUrl(defaultRedisAddress, config.password, config.database));\n+        }\n+\n+        if (config.timeout.isPresent()) {\n+            timeout = config.timeout.get().getSeconds();\n+        }\n+\n+        redisClient = Redis.createClient(vertx, options);\n+        redisAPI = RedisAPI.api(redisClient);\n+        mutinyRedisClient = io.vertx.mutiny.redis.client.Redis.newInstance(redisClient);\n+        mutinyRedisAPI = io.vertx.mutiny.redis.client.RedisAPI.api(mutinyRedisClient);\n+        syncRedisAPI = new SyncRedisAPIImpl(mutinyRedisAPI, timeout);\n+    }\n+\n+    @Produces\n+    @Singleton\n+    Redis redis() {\n+        return redisClient;\n+    }\n+\n+    @Produces\n+    @Singleton\n+    RedisAPI redisAPI() {\n+        return redisAPI;\n+    }\n+\n+    @Produces\n+    @Singleton\n+    SyncRedisAPI syncRedisAPI() {\n+        return syncRedisAPI;\n+    }\n+\n+    @Produces\n+    @Singleton\n+    io.vertx.mutiny.redis.client.Redis mutinyRedisClient() {\n+        return mutinyRedisClient;\n+    }\n+\n+    @Produces\n+    @Singleton\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI() {\n+        return mutinyRedisAPI;\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        this.redis().close();\n+    }\n+\n+    private String buildRedisUrl(InetSocketAddress address, Optional<String> password, int database) {", "originalCommit": "ff70985ad036e48d54730a01023fdf2332e23a5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NjY5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429376697", "bodyText": "Great. Good to know. I'll look into that.", "author": "machi1990", "createdAt": "2020-05-22T17:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NTA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NTY3NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429375674", "bodyText": "I think if you use the connection string format I think all this class is not needed.", "author": "pmlopes", "createdAt": "2020-05-22T17:41:41Z", "path": "extensions/vertx-redis/runtime/src/main/java/io/quarkus/vertx/redis/runtime/RedisConfig.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vertx.redis.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.vertx.redis.client.RedisClientType;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class RedisConfig {", "originalCommit": "ff70985ad036e48d54730a01023fdf2332e23a5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3OTU4NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r429379584", "bodyText": "Thanks for the review. We'll still need this class as it is the configuration root class.\nQuick question: Does ssl work with the new api? Do you have an example how I can set it up?", "author": "machi1990", "createdAt": "2020-05-22T17:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NTY3NA=="}], "type": "inlineReview"}, {"oid": "53608c48aa58abefaec50fdf4c33ec84e41d4481", "url": "https://github.com/quarkusio/quarkus/commit/53608c48aa58abefaec50fdf4c33ec84e41d4481", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-22T18:43:08Z", "type": "forcePushed"}, {"oid": "2a10b8a494b7e2ff585a42191c883c81c41bedf9", "url": "https://github.com/quarkusio/quarkus/commit/2a10b8a494b7e2ff585a42191c883c81c41bedf9", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-23T07:57:51Z", "type": "forcePushed"}, {"oid": "1c396334e3dce8c9e7933fb1bc6e1760246bd88d", "url": "https://github.com/quarkusio/quarkus/commit/1c396334e3dce8c9e7933fb1bc6e1760246bd88d", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-05-30T09:35:19Z", "type": "forcePushed"}, {"oid": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "url": "https://github.com/quarkusio/quarkus/commit/31f3c279e6082578e12fb89583a8c8c34fd0407b", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-06-02T18:43:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0NzY0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441447647", "bodyText": "I would probably add a specific label for it.", "author": "gsmet", "createdAt": "2020-06-17T10:31:47Z", "path": ".github/boring-cyborg.yml", "diffHunk": "@@ -280,9 +280,11 @@ labelPRBasedOnFilePath:\n         - extensions/vertx/**/*\n         - extensions/vertx-core/**/*\n         - extensions/vertx-graphql/**/*\n+        - extensions/vertx-redis/**/*\n         - extensions/vertx-http/**/*\n         - extensions/vertx-keycloak/**/*\n         - extensions/vertx-web/**/*\n         - integration-tests/vertx/**/*\n         - integration-tests/vertx-graphql/**/*\n+        - integration-tests/vertx-redis/**/*", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MDc2OA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443040768", "bodyText": "Sure, I am adding the area/redis label. We'll need it created I suppose.", "author": "machi1990", "createdAt": "2020-06-19T20:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0NzY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0ODU2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441448567", "bodyText": "I don't know about the name. The SQL clients went for Reactive XXX client. MongoDB is simply mongodb-client.\n@cescoffier WDYT?", "author": "gsmet", "createdAt": "2020-06-17T10:33:38Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/builditem/FeatureBuildItem.java", "diffHunk": "@@ -114,6 +114,7 @@\n     public static final String VERTX_WEB = \"vertx-web\";\n     public static final String VERTX_GRAPHQL = \"vertx-graphql\";\n     public static final String WEBJARS_LOCATOR = \"webjars-locator\";\n+    public static final String VERTX_REDIS = \"vertx-redis\";", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ2ODMzOA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441468338", "bodyText": "After discussion with @cescoffier , let's be consistent with the MongoDB one and name it redis-client.", "author": "gsmet", "createdAt": "2020-06-17T11:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0ODU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0ODg1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441448857", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This guide demonstrates how your Quarkus application can use the Redis extension.\n          \n          \n            \n            This guide demonstrates how your Quarkus application can connect to a Redis datastore using the Redis Client extension.", "author": "gsmet", "createdAt": "2020-06-17T10:34:10Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0OTA1NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441449054", "bodyText": "We have a status include things for that. Have a look at the Hibernate Search Elasticsearch doc.", "author": "gsmet", "createdAt": "2020-06-17T10:34:33Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.\n+\n+[NOTE]\n+====\n+This extension is considered `preview`.\n+API or configuration properties might change as the extension matures.\n+Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].\n+====", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0OTU3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441449579", "bodyText": "See the other guides, we now add a XML snippet with the GA (it's recent so it's normal you didn't add it).", "author": "gsmet", "createdAt": "2020-06-17T10:35:33Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.\n+\n+[NOTE]\n+====\n+This extension is considered `preview`.\n+API or configuration properties might change as the extension matures.\n+Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].\n+====\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"vertx-redis, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MTk1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443041951", "bodyText": "Good idea.\nDone.", "author": "machi1990", "createdAt": "2020-06-19T21:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0OTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MDMxMA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441450310", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            With this class, we'll be able to do the perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n          \n          \n            \n            With this class, we'll be able to perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.", "author": "gsmet", "createdAt": "2020-06-17T10:36:49Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.\n+\n+[NOTE]\n+====\n+This extension is considered `preview`.\n+API or configuration properties might change as the extension matures.\n+Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].\n+====\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"vertx-redis, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to do the perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MDY1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441450657", "bodyText": "Do we really want the FQCN here?", "author": "gsmet", "createdAt": "2020-06-17T10:37:27Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.\n+\n+[NOTE]\n+====\n+This extension is considered `preview`.\n+API or configuration properties might change as the extension matures.\n+Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].\n+====\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"vertx-redis, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to do the perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n+\n+Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.vertx.mutiny.redis.client.Response;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+@Singleton\n+class IncrementService {\n+\n+    @Inject\n+    SyncRedisAPI syncRedisAPI; <1>\n+\n+    @Inject\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI; <2>", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAwMjYzOA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443002638", "bodyText": "Surely not. I\u2019ll update this part along with the quickstart. Good catch", "author": "machi1990", "createdAt": "2020-06-19T19:06:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MDY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MDc3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441450775", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Inject the mutiny reactive redis client\n          \n          \n            \n            2. Inject the Mutiny reactive Redis client", "author": "gsmet", "createdAt": "2020-06-17T10:37:42Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.\n+\n+[NOTE]\n+====\n+This extension is considered `preview`.\n+API or configuration properties might change as the extension matures.\n+Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].\n+====\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"vertx-redis, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to do the perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n+\n+Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.vertx.mutiny.redis.client.Response;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+@Singleton\n+class IncrementService {\n+\n+    @Inject\n+    SyncRedisAPI syncRedisAPI; <1>\n+\n+    @Inject\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI; <2>\n+\n+    Uni<Void> del(String key) {\n+        return mutinyRedisAPI.del(Arrays.asList(key))\n+                .map(response -> null);\n+    }\n+\n+    String get(String key) {\n+        return syncRedisAPI.get(key).toString();\n+    }\n+\n+    void set(String key, Integer value) {\n+        syncRedisAPI.set(Arrays.asList(key, value.toString()));\n+    }\n+\n+    void increment(String key, Integer incrementBy) {\n+        syncRedisAPI.incrby(key, incrementBy.toString());\n+    }\n+\n+    Uni<List<String>> keys() {\n+        return mutinyRedisAPI\n+                .keys(\"*\")\n+                .map(response -> {\n+                    List<String> result = new ArrayList<>();\n+                    for (Response r : response) {\n+                        result.add(r.toString());\n+                    }\n+                    return result;\n+                });\n+    }\n+}\n+----\n+\n+1. Inject the Redis synchronous client\n+2. Inject the mutiny reactive redis client", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MTA2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441451062", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ./mvnw compile quarkus:dev\n          \n          \n            \n            ./mvnw quarkus:dev\n          \n      \n    \n    \n  \n\ncompile shouldn't be needed anymore", "author": "gsmet", "createdAt": "2020-06-17T10:38:15Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.\n+\n+[NOTE]\n+====\n+This extension is considered `preview`.\n+API or configuration properties might change as the extension matures.\n+Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].\n+====\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"vertx-redis, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to do the perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n+\n+Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.vertx.mutiny.redis.client.Response;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+@Singleton\n+class IncrementService {\n+\n+    @Inject\n+    SyncRedisAPI syncRedisAPI; <1>\n+\n+    @Inject\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI; <2>\n+\n+    Uni<Void> del(String key) {\n+        return mutinyRedisAPI.del(Arrays.asList(key))\n+                .map(response -> null);\n+    }\n+\n+    String get(String key) {\n+        return syncRedisAPI.get(key).toString();\n+    }\n+\n+    void set(String key, Integer value) {\n+        syncRedisAPI.set(Arrays.asList(key, value.toString()));\n+    }\n+\n+    void increment(String key, Integer incrementBy) {\n+        syncRedisAPI.incrby(key, incrementBy.toString());\n+    }\n+\n+    Uni<List<String>> keys() {\n+        return mutinyRedisAPI\n+                .keys(\"*\")\n+                .map(response -> {\n+                    List<String> result = new ArrayList<>();\n+                    for (Response r : response) {\n+                        result.add(r.toString());\n+                    }\n+                    return result;\n+                });\n+    }\n+}\n+----\n+\n+1. Inject the Redis synchronous client\n+2. Inject the mutiny reactive redis client\n+\n+== Creating the Increment Resource\n+\n+Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.core.MediaType;\n+import java.util.List;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"/increments\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class IncrementResource {\n+\n+    @Inject\n+    IncrementService service;\n+\n+    @GET\n+    public Uni<List<String>> keys() {\n+        return service.keys();\n+    }\n+\n+    @POST\n+    public Increment create(Increment increment) {\n+        service.set(increment.key, increment.value);\n+        return increment;\n+    }\n+\n+    @GET\n+    @Path(\"/{key}\")\n+    public Increment get(@PathParam(\"key\") String key) {\n+        return new Increment(key, Integer.valueOf(service.get(key)));\n+    }\n+\n+    @PUT\n+    @Path(\"/{key}\")\n+    public void increment(@PathParam(\"key\") String key, Integer value) {\n+        service.increment(key, value);\n+    }\n+\n+    @DELETE\n+    @Path(\"/{key}\")\n+    public Uni<Void> delete(@PathParam(\"key\") String key) {\n+        return service.del(key);\n+    }\n+}\n+----\n+\n+== Modifying the test class\n+\n+Edit the `src/test/java/org/acme/redis/IncrementResourceTest.java` file to the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import static org.hamcrest.Matchers.is;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+\n+import static io.restassured.RestAssured.given;\n+\n+import io.restassured.http.ContentType;\n+\n+@QuarkusTest\n+public class IncrementResourceTest {\n+\n+    @Test\n+    public void testRedisOperations() {\n+        // verify that we have nothing\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(0));\n+\n+        // create a first increment key with an initial value of 0\n+        given()\n+                .contentType(ContentType.JSON)\n+                .accept(ContentType.JSON)\n+                .body(\"{\\\"key\\\":\\\"first-key\\\",\\\"value\\\":0}\")\n+                .when()\n+                .post(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"first-key\"))\n+                .body(\"value\", is(0));\n+\n+        // create a second increment key with an initial value of 10\n+        given()\n+                .contentType(ContentType.JSON)\n+                .accept(ContentType.JSON)\n+                .body(\"{\\\"key\\\":\\\"second-key\\\",\\\"value\\\":10}\")\n+                .when()\n+                .post(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"second-key\"))\n+                .body(\"value\", is(10));\n+\n+        // increment first key by 1\n+        given()\n+                .contentType(ContentType.JSON)\n+                .body(\"1\")\n+                .when()\n+                .put(\"/increments/first-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that key has been incremented\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments/first-key\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"first-key\"))\n+                .body(\"value\", is(1));\n+\n+        // increment second key by 1000\n+        given()\n+                .contentType(ContentType.JSON)\n+                .body(\"1000\")\n+                .when()\n+                .put(\"/increments/second-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that key has been incremented\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments/second-key\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"second-key\"))\n+                .body(\"value\", is(1010));\n+\n+        // verify that we have two keys in registered\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(2));\n+\n+        // delete first key\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .delete(\"/increments/first-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that we have one key left after deletion\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(1));\n+\n+        // delete second key\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .delete(\"/increments/second-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that there is no key left\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(0));\n+    }\n+}\n+----\n+\n+== Get it running\n+\n+If you followed the instructions, you should have the Redis server running.\n+Then, you just need to run the application using:\n+\n+[source, shell]\n+----\n+./mvnw compile quarkus:dev", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MTUyMg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441451522", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            === Retrieve an new increment\n          \n          \n            \n            === Retrieve a new increment", "author": "gsmet", "createdAt": "2020-06-17T10:39:13Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.\n+\n+[NOTE]\n+====\n+This extension is considered `preview`.\n+API or configuration properties might change as the extension matures.\n+Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].\n+====\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"vertx-redis, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to do the perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n+\n+Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.vertx.mutiny.redis.client.Response;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+@Singleton\n+class IncrementService {\n+\n+    @Inject\n+    SyncRedisAPI syncRedisAPI; <1>\n+\n+    @Inject\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI; <2>\n+\n+    Uni<Void> del(String key) {\n+        return mutinyRedisAPI.del(Arrays.asList(key))\n+                .map(response -> null);\n+    }\n+\n+    String get(String key) {\n+        return syncRedisAPI.get(key).toString();\n+    }\n+\n+    void set(String key, Integer value) {\n+        syncRedisAPI.set(Arrays.asList(key, value.toString()));\n+    }\n+\n+    void increment(String key, Integer incrementBy) {\n+        syncRedisAPI.incrby(key, incrementBy.toString());\n+    }\n+\n+    Uni<List<String>> keys() {\n+        return mutinyRedisAPI\n+                .keys(\"*\")\n+                .map(response -> {\n+                    List<String> result = new ArrayList<>();\n+                    for (Response r : response) {\n+                        result.add(r.toString());\n+                    }\n+                    return result;\n+                });\n+    }\n+}\n+----\n+\n+1. Inject the Redis synchronous client\n+2. Inject the mutiny reactive redis client\n+\n+== Creating the Increment Resource\n+\n+Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.core.MediaType;\n+import java.util.List;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"/increments\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class IncrementResource {\n+\n+    @Inject\n+    IncrementService service;\n+\n+    @GET\n+    public Uni<List<String>> keys() {\n+        return service.keys();\n+    }\n+\n+    @POST\n+    public Increment create(Increment increment) {\n+        service.set(increment.key, increment.value);\n+        return increment;\n+    }\n+\n+    @GET\n+    @Path(\"/{key}\")\n+    public Increment get(@PathParam(\"key\") String key) {\n+        return new Increment(key, Integer.valueOf(service.get(key)));\n+    }\n+\n+    @PUT\n+    @Path(\"/{key}\")\n+    public void increment(@PathParam(\"key\") String key, Integer value) {\n+        service.increment(key, value);\n+    }\n+\n+    @DELETE\n+    @Path(\"/{key}\")\n+    public Uni<Void> delete(@PathParam(\"key\") String key) {\n+        return service.del(key);\n+    }\n+}\n+----\n+\n+== Modifying the test class\n+\n+Edit the `src/test/java/org/acme/redis/IncrementResourceTest.java` file to the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import static org.hamcrest.Matchers.is;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+\n+import static io.restassured.RestAssured.given;\n+\n+import io.restassured.http.ContentType;\n+\n+@QuarkusTest\n+public class IncrementResourceTest {\n+\n+    @Test\n+    public void testRedisOperations() {\n+        // verify that we have nothing\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(0));\n+\n+        // create a first increment key with an initial value of 0\n+        given()\n+                .contentType(ContentType.JSON)\n+                .accept(ContentType.JSON)\n+                .body(\"{\\\"key\\\":\\\"first-key\\\",\\\"value\\\":0}\")\n+                .when()\n+                .post(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"first-key\"))\n+                .body(\"value\", is(0));\n+\n+        // create a second increment key with an initial value of 10\n+        given()\n+                .contentType(ContentType.JSON)\n+                .accept(ContentType.JSON)\n+                .body(\"{\\\"key\\\":\\\"second-key\\\",\\\"value\\\":10}\")\n+                .when()\n+                .post(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"second-key\"))\n+                .body(\"value\", is(10));\n+\n+        // increment first key by 1\n+        given()\n+                .contentType(ContentType.JSON)\n+                .body(\"1\")\n+                .when()\n+                .put(\"/increments/first-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that key has been incremented\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments/first-key\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"first-key\"))\n+                .body(\"value\", is(1));\n+\n+        // increment second key by 1000\n+        given()\n+                .contentType(ContentType.JSON)\n+                .body(\"1000\")\n+                .when()\n+                .put(\"/increments/second-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that key has been incremented\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments/second-key\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"second-key\"))\n+                .body(\"value\", is(1010));\n+\n+        // verify that we have two keys in registered\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(2));\n+\n+        // delete first key\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .delete(\"/increments/first-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that we have one key left after deletion\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(1));\n+\n+        // delete second key\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .delete(\"/increments/second-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that there is no key left\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(0));\n+    }\n+}\n+----\n+\n+== Get it running\n+\n+If you followed the instructions, you should have the Redis server running.\n+Then, you just need to run the application using:\n+\n+[source, shell]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+Open another terminal and run the `curl http://localhost:8080/increments` command.\n+\n+== Interacting with the application\n+As we have seen above, the API exposes five Rest endpoints.\n+In this section we are going to see how to initialise an increment, see the list of current increments,\n+incrementing a value given its key, retrieving the current value of an increment, and finally deleting\n+a key.\n+\n+=== Creating a new increment\n+\n+[source, shell]\n+----\n+curl -X POST -H \"Content-Type: application/json\" -d '{\"key\":\"first\",\"value\":10}' http://localhost:8080/increments <1>\n+----\n+\n+1. We create the first increment, with the key `first` and an initial value of `10`.\n+\n+Running the above command should return the result below:\n+\n+[source, json]\n+-----\n+{\n+  \"key\": \"first\",\n+  \"value\": 10\n+}\n+-----\n+\n+=== See current increments keys\n+\n+To see the list of current increments keys, run the following command:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/increments\n+----\n+\n+The above command should return  `[\"first\"]` indicating that we have only one increment thus far.\n+\n+=== Retrieve an new increment", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MTg0NA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441451844", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Packaging and run in JVM mode\n          \n          \n            \n            == Packaging and running in JVM mode", "author": "gsmet", "createdAt": "2020-06-17T10:39:56Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can use the Redis extension.\n+\n+[NOTE]\n+====\n+This extension is considered `preview`.\n+API or configuration properties might change as the extension matures.\n+Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].\n+====\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"vertx-redis, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to do the perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n+\n+Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import io.quarkus.vertx.redis.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.vertx.mutiny.redis.client.Response;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+@Singleton\n+class IncrementService {\n+\n+    @Inject\n+    SyncRedisAPI syncRedisAPI; <1>\n+\n+    @Inject\n+    io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI; <2>\n+\n+    Uni<Void> del(String key) {\n+        return mutinyRedisAPI.del(Arrays.asList(key))\n+                .map(response -> null);\n+    }\n+\n+    String get(String key) {\n+        return syncRedisAPI.get(key).toString();\n+    }\n+\n+    void set(String key, Integer value) {\n+        syncRedisAPI.set(Arrays.asList(key, value.toString()));\n+    }\n+\n+    void increment(String key, Integer incrementBy) {\n+        syncRedisAPI.incrby(key, incrementBy.toString());\n+    }\n+\n+    Uni<List<String>> keys() {\n+        return mutinyRedisAPI\n+                .keys(\"*\")\n+                .map(response -> {\n+                    List<String> result = new ArrayList<>();\n+                    for (Response r : response) {\n+                        result.add(r.toString());\n+                    }\n+                    return result;\n+                });\n+    }\n+}\n+----\n+\n+1. Inject the Redis synchronous client\n+2. Inject the mutiny reactive redis client\n+\n+== Creating the Increment Resource\n+\n+Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.core.MediaType;\n+import java.util.List;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"/increments\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class IncrementResource {\n+\n+    @Inject\n+    IncrementService service;\n+\n+    @GET\n+    public Uni<List<String>> keys() {\n+        return service.keys();\n+    }\n+\n+    @POST\n+    public Increment create(Increment increment) {\n+        service.set(increment.key, increment.value);\n+        return increment;\n+    }\n+\n+    @GET\n+    @Path(\"/{key}\")\n+    public Increment get(@PathParam(\"key\") String key) {\n+        return new Increment(key, Integer.valueOf(service.get(key)));\n+    }\n+\n+    @PUT\n+    @Path(\"/{key}\")\n+    public void increment(@PathParam(\"key\") String key, Integer value) {\n+        service.increment(key, value);\n+    }\n+\n+    @DELETE\n+    @Path(\"/{key}\")\n+    public Uni<Void> delete(@PathParam(\"key\") String key) {\n+        return service.del(key);\n+    }\n+}\n+----\n+\n+== Modifying the test class\n+\n+Edit the `src/test/java/org/acme/redis/IncrementResourceTest.java` file to the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import static org.hamcrest.Matchers.is;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+\n+import static io.restassured.RestAssured.given;\n+\n+import io.restassured.http.ContentType;\n+\n+@QuarkusTest\n+public class IncrementResourceTest {\n+\n+    @Test\n+    public void testRedisOperations() {\n+        // verify that we have nothing\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(0));\n+\n+        // create a first increment key with an initial value of 0\n+        given()\n+                .contentType(ContentType.JSON)\n+                .accept(ContentType.JSON)\n+                .body(\"{\\\"key\\\":\\\"first-key\\\",\\\"value\\\":0}\")\n+                .when()\n+                .post(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"first-key\"))\n+                .body(\"value\", is(0));\n+\n+        // create a second increment key with an initial value of 10\n+        given()\n+                .contentType(ContentType.JSON)\n+                .accept(ContentType.JSON)\n+                .body(\"{\\\"key\\\":\\\"second-key\\\",\\\"value\\\":10}\")\n+                .when()\n+                .post(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"second-key\"))\n+                .body(\"value\", is(10));\n+\n+        // increment first key by 1\n+        given()\n+                .contentType(ContentType.JSON)\n+                .body(\"1\")\n+                .when()\n+                .put(\"/increments/first-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that key has been incremented\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments/first-key\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"first-key\"))\n+                .body(\"value\", is(1));\n+\n+        // increment second key by 1000\n+        given()\n+                .contentType(ContentType.JSON)\n+                .body(\"1000\")\n+                .when()\n+                .put(\"/increments/second-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that key has been incremented\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments/second-key\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"second-key\"))\n+                .body(\"value\", is(1010));\n+\n+        // verify that we have two keys in registered\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(2));\n+\n+        // delete first key\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .delete(\"/increments/first-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that we have one key left after deletion\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(1));\n+\n+        // delete second key\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .delete(\"/increments/second-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that there is no key left\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(0));\n+    }\n+}\n+----\n+\n+== Get it running\n+\n+If you followed the instructions, you should have the Redis server running.\n+Then, you just need to run the application using:\n+\n+[source, shell]\n+----\n+./mvnw compile quarkus:dev\n+----\n+\n+Open another terminal and run the `curl http://localhost:8080/increments` command.\n+\n+== Interacting with the application\n+As we have seen above, the API exposes five Rest endpoints.\n+In this section we are going to see how to initialise an increment, see the list of current increments,\n+incrementing a value given its key, retrieving the current value of an increment, and finally deleting\n+a key.\n+\n+=== Creating a new increment\n+\n+[source, shell]\n+----\n+curl -X POST -H \"Content-Type: application/json\" -d '{\"key\":\"first\",\"value\":10}' http://localhost:8080/increments <1>\n+----\n+\n+1. We create the first increment, with the key `first` and an initial value of `10`.\n+\n+Running the above command should return the result below:\n+\n+[source, json]\n+-----\n+{\n+  \"key\": \"first\",\n+  \"value\": 10\n+}\n+-----\n+\n+=== See current increments keys\n+\n+To see the list of current increments keys, run the following command:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/increments\n+----\n+\n+The above command should return  `[\"first\"]` indicating that we have only one increment thus far.\n+\n+=== Retrieve an new increment\n+\n+To retrieve an increment using its key, we will have to run the below command:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/increments/first <1>\n+----\n+\n+1. Running this command, should return the following result:\n+\n+[source, json]\n+----\n+{\n+  \"key\": \"first\",\n+  \"value\": 10\n+}\n+----\n+\n+=== Increment a value given its key\n+\n+To increment a value, run the following command:\n+\n+[source, shell]\n+----\n+curl -X PUT -H \"Content-Type: application/json\" -d '27' http://localhost:8080/increments/first <1>\n+----\n+\n+1. Increment the `first` value by 27.\n+\n+Now, running the command `curl http://localhost:8080/increments/first` should return the following result:\n+\n+[source, json]\n+----\n+{\n+  \"key\": \"first\",\n+  \"value\": 37 <1>\n+}\n+----\n+\n+1. We see that the value of the `first` key is now `37` which is exactly the result of `10 + 27`, quick maths.\n+\n+=== Deleting a key\n+\n+Use the command below, to delete an increment given its key.\n+\n+[source, shell]\n+----\n+curl -X DELETE  http://localhost:8080/increments/first <1>\n+----\n+\n+1. Delete the `first` increment.\n+\n+Now, running the command `curl http://localhost:8080/increments` should return an empty list `[]`\n+\n+== Packaging and run in JVM mode", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ2ODc0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r441468742", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            = Quarkus - Using Vertx Redis extension\n          \n          \n            \n            = Quarkus - Using the Redis Client", "author": "gsmet", "createdAt": "2020-06-17T11:14:23Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,530 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using Vertx Redis extension", "originalCommit": "31f3c279e6082578e12fb89583a8c8c34fd0407b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f7ff316e7469c059eba9a4da23d0ead689b9a1f", "url": "https://github.com/quarkusio/quarkus/commit/6f7ff316e7469c059eba9a4da23d0ead689b9a1f", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-06-19T20:52:22Z", "type": "forcePushed"}, {"oid": "001ceb768e9675f74db784985b3c1158561ab23c", "url": "https://github.com/quarkusio/quarkus/commit/001ceb768e9675f74db784985b3c1158561ab23c", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-06-19T21:00:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNTk4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443335986", "bodyText": "Can you remove \"vert.x\" here? It's based on Vert.x, but it does not have to be named after it. (It still need to be mentioned in the documentation).", "author": "cescoffier", "createdAt": "2020-06-22T06:13:07Z", "path": "docs/src/main/asciidoc/native-and-ssl.adoc", "diffHunk": "@@ -74,6 +74,7 @@ As SSL is de facto the standard nowadays, we decided to enable its support autom\n  * the Keycloak extension (`quarkus-keycloak`),\n  * the Kubernetes client extension (`quarkus-kubernetes-client`),\n  * the Mailer extension (`quarkus-mailer`),\n+ * the Vert.x Redis extension (`quarkus-vertx-redis`),", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNjI1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443336255", "bodyText": "// missing before the <1> and <2> - without the code cannot be copied.", "author": "cescoffier", "createdAt": "2020-06-22T06:14:02Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,547 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using the Redis Client\n+:extension-status: preview\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can connect to a Redis datastore using the Redis Client extension.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"redis-client, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+\n+If you already have your Quarkus project configured, you can add the `redis-client` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"redis-client\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-redis-client</artifactId>\n+</dependency>\n+----\n+\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNjQwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443336401", "bodyText": "We need to rediscuss this name. In addition to be sync, it's blocking.", "author": "cescoffier", "createdAt": "2020-06-22T06:14:27Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,547 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using the Redis Client\n+:extension-status: preview\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can connect to a Redis datastore using the Redis Client extension.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"redis-client, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+\n+If you already have your Quarkus project configured, you can add the `redis-client` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"redis-client\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-redis-client</artifactId>\n+</dependency>\n+----\n+\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n+\n+Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.vertx.mutiny.redis.client.Response;\n+import io.vertx.mutiny.redis.client.RedisAPI;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+@Singleton\n+class IncrementService {\n+\n+    @Inject\n+    SyncRedisAPI syncRedisAPI; <1>", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxOTcwMw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444319703", "bodyText": "It is sync and blocking since it is a synchronous client. Okay with the renaming to RedisClient and I'll also a ReactiveRedisClient (which was not there as I expected users to be using the mutiny based one).", "author": "machi1990", "createdAt": "2020-06-23T15:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNjQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNjgxMA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443336810", "bodyText": "The empty line should be removed here.", "author": "cescoffier", "createdAt": "2020-06-22T06:15:48Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,547 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using the Redis Client\n+:extension-status: preview\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can connect to a Redis datastore using the Redis Client extension.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"redis-client, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+\n+If you already have your Quarkus project configured, you can add the `redis-client` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"redis-client\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-redis-client</artifactId>\n+</dependency>\n+----\n+\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n+\n+Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.vertx.mutiny.redis.client.Response;\n+import io.vertx.mutiny.redis.client.RedisAPI;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+@Singleton\n+class IncrementService {\n+\n+    @Inject\n+    SyncRedisAPI syncRedisAPI; <1>\n+\n+    @Inject\n+    RedisAPI mutinyRedisAPI; <2>\n+\n+    Uni<Void> del(String key) {\n+        return mutinyRedisAPI.del(Arrays.asList(key))\n+                .map(response -> null);\n+    }\n+\n+    String get(String key) {\n+        return syncRedisAPI.get(key).toString();\n+    }\n+\n+    void set(String key, Integer value) {\n+        syncRedisAPI.set(Arrays.asList(key, value.toString()));\n+    }\n+\n+    void increment(String key, Integer incrementBy) {\n+        syncRedisAPI.incrby(key, incrementBy.toString());\n+    }\n+\n+    Uni<List<String>> keys() {\n+        return mutinyRedisAPI\n+                .keys(\"*\")\n+                .map(response -> {\n+                    List<String> result = new ArrayList<>();\n+                    for (Response r : response) {\n+                        result.add(r.toString());\n+                    }\n+                    return result;\n+                });\n+    }\n+}\n+----\n+", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNzExOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443337119", "bodyText": "Somewhere it should be stated that the client is based on the Vert.x client and a link to the Vert.x client documentation should be added.", "author": "cescoffier", "createdAt": "2020-06-22T06:16:52Z", "path": "docs/src/main/asciidoc/redis.adoc", "diffHunk": "@@ -0,0 +1,547 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using the Redis Client\n+:extension-status: preview\n+include::./attributes.adoc[]\n+\n+This guide demonstrates how your Quarkus application can connect to a Redis datastore using the Redis Client extension.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven 3.5.3+\n+* A running Redis server, or Docker Compose to start one\n+* GraalVM installed if you want to run in native mode.\n+\n+== Architecture\n+\n+In this guide, we are going to expose a simple Rest API to increment numbers by using the https://redis.io/commands/incrby[`INCRBY`] command.\n+Along the way, we'll see how to use other Redis commands like `GET`, `SET`, `DEL` and `KEYS`.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `redis-quickstart` {quickstarts-tree-url}/redis-quickstart[directory].\n+\n+== Creating the Maven Project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source, subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=redis-quickstart \\\n+    -Dextensions=\"redis-client, resteasy-jsonb, resteasy-mutiny\"\n+cd redis-quickstart\n+----\n+\n+This command generates a Maven project, importing the Redis extension.\n+\n+\n+If you already have your Quarkus project configured, you can add the `redis-client` extension\n+to your project by running the following command in your project base directory:\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"redis-client\"\n+----\n+\n+This will add the following to your `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-redis-client</artifactId>\n+</dependency>\n+----\n+\n+\n+== Starting the Redis server\n+\n+Then, we need to start a Redis instance (if you do not have one already) using the following command:\n+\n+[source, bash]\n+----\n+docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name redis_quarkus_test -p 6379:6379 redis:5.0.6\n+----\n+\n+== Configuring Redis properties\n+\n+Once we have the Redis server running, we need to configure the Redis connection properties.\n+This is done in the `application.properties` configuration file. Edit it to the following content:\n+\n+[source]\n+----\n+quarkus.redis.hosts=localhost:6379 <1>\n+----\n+\n+1. Configure Redis hosts to connect to. Here we connect to the Redis server we started in the previous section\n+\n+== Creating the Increment POJO\n+\n+We are going to model our increments using the `Increment` POJO.\n+Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+public class Increment {\n+    public String key; <1>\n+    public int value; <2>\n+\n+    public Increment(String key, int value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    public Increment() {\n+    }\n+}\n+----\n+\n+1. The key that will be used as the Redis key\n+2. The value held by the Redis key\n+\n+\n+== Creating the Increment Service\n+\n+We are going to create an `IncrementService` class which will play the role of a Redis client.\n+With this class, we'll be able to perform the `SET`, `GET` , `DELET`, `KEYS` and `INCRBY` Redis commands.\n+\n+Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.vertx.mutiny.redis.client.Response;\n+import io.vertx.mutiny.redis.client.RedisAPI;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+@Singleton\n+class IncrementService {\n+\n+    @Inject\n+    SyncRedisAPI syncRedisAPI; <1>\n+\n+    @Inject\n+    RedisAPI mutinyRedisAPI; <2>\n+\n+    Uni<Void> del(String key) {\n+        return mutinyRedisAPI.del(Arrays.asList(key))\n+                .map(response -> null);\n+    }\n+\n+    String get(String key) {\n+        return syncRedisAPI.get(key).toString();\n+    }\n+\n+    void set(String key, Integer value) {\n+        syncRedisAPI.set(Arrays.asList(key, value.toString()));\n+    }\n+\n+    void increment(String key, Integer incrementBy) {\n+        syncRedisAPI.incrby(key, incrementBy.toString());\n+    }\n+\n+    Uni<List<String>> keys() {\n+        return mutinyRedisAPI\n+                .keys(\"*\")\n+                .map(response -> {\n+                    List<String> result = new ArrayList<>();\n+                    for (Response r : response) {\n+                        result.add(r.toString());\n+                    }\n+                    return result;\n+                });\n+    }\n+}\n+----\n+\n+1. Inject the Redis synchronous client\n+2. Inject the Mutiny reactive Redis client\n+\n+== Creating the Increment Resource\n+\n+Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.core.MediaType;\n+import java.util.List;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"/increments\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class IncrementResource {\n+\n+    @Inject\n+    IncrementService service;\n+\n+    @GET\n+    public Uni<List<String>> keys() {\n+        return service.keys();\n+    }\n+\n+    @POST\n+    public Increment create(Increment increment) {\n+        service.set(increment.key, increment.value);\n+        return increment;\n+    }\n+\n+    @GET\n+    @Path(\"/{key}\")\n+    public Increment get(@PathParam(\"key\") String key) {\n+        return new Increment(key, Integer.valueOf(service.get(key)));\n+    }\n+\n+    @PUT\n+    @Path(\"/{key}\")\n+    public void increment(@PathParam(\"key\") String key, Integer value) {\n+        service.increment(key, value);\n+    }\n+\n+    @DELETE\n+    @Path(\"/{key}\")\n+    public Uni<Void> delete(@PathParam(\"key\") String key) {\n+        return service.del(key);\n+    }\n+}\n+----\n+\n+== Modifying the test class\n+\n+Edit the `src/test/java/org/acme/redis/IncrementResourceTest.java` file to the following content:\n+\n+[source, java]\n+----\n+package org.acme.redis;\n+\n+import static org.hamcrest.Matchers.is;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import io.quarkus.test.junit.QuarkusTest;\n+\n+import static io.restassured.RestAssured.given;\n+\n+import io.restassured.http.ContentType;\n+\n+@QuarkusTest\n+public class IncrementResourceTest {\n+\n+    @Test\n+    public void testRedisOperations() {\n+        // verify that we have nothing\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(0));\n+\n+        // create a first increment key with an initial value of 0\n+        given()\n+                .contentType(ContentType.JSON)\n+                .accept(ContentType.JSON)\n+                .body(\"{\\\"key\\\":\\\"first-key\\\",\\\"value\\\":0}\")\n+                .when()\n+                .post(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"first-key\"))\n+                .body(\"value\", is(0));\n+\n+        // create a second increment key with an initial value of 10\n+        given()\n+                .contentType(ContentType.JSON)\n+                .accept(ContentType.JSON)\n+                .body(\"{\\\"key\\\":\\\"second-key\\\",\\\"value\\\":10}\")\n+                .when()\n+                .post(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"second-key\"))\n+                .body(\"value\", is(10));\n+\n+        // increment first key by 1\n+        given()\n+                .contentType(ContentType.JSON)\n+                .body(\"1\")\n+                .when()\n+                .put(\"/increments/first-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that key has been incremented\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments/first-key\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"first-key\"))\n+                .body(\"value\", is(1));\n+\n+        // increment second key by 1000\n+        given()\n+                .contentType(ContentType.JSON)\n+                .body(\"1000\")\n+                .when()\n+                .put(\"/increments/second-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that key has been incremented\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments/second-key\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"key\", is(\"second-key\"))\n+                .body(\"value\", is(1010));\n+\n+        // verify that we have two keys in registered\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(2));\n+\n+        // delete first key\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .delete(\"/increments/first-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that we have one key left after deletion\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(1));\n+\n+        // delete second key\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .delete(\"/increments/second-key\")\n+                .then()\n+                .statusCode(204);\n+\n+        // verify that there is no key left\n+        given()\n+                .accept(ContentType.JSON)\n+                .when()\n+                .get(\"/increments\")\n+                .then()\n+                .statusCode(200)\n+                .body(\"size()\", is(0));\n+    }\n+}\n+----\n+\n+== Get it running\n+\n+If you followed the instructions, you should have the Redis server running.\n+Then, you just need to run the application using:\n+\n+[source, shell]\n+----\n+./mvnw quarkus:dev\n+----\n+\n+Open another terminal and run the `curl http://localhost:8080/increments` command.\n+\n+== Interacting with the application\n+As we have seen above, the API exposes five Rest endpoints.\n+In this section we are going to see how to initialise an increment, see the list of current increments,\n+incrementing a value given its key, retrieving the current value of an increment, and finally deleting\n+a key.\n+\n+=== Creating a new increment\n+\n+[source, shell]\n+----\n+curl -X POST -H \"Content-Type: application/json\" -d '{\"key\":\"first\",\"value\":10}' http://localhost:8080/increments <1>\n+----\n+\n+1. We create the first increment, with the key `first` and an initial value of `10`.\n+\n+Running the above command should return the result below:\n+\n+[source, json]\n+-----\n+{\n+  \"key\": \"first\",\n+  \"value\": 10\n+}\n+-----\n+\n+=== See current increments keys\n+\n+To see the list of current increments keys, run the following command:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/increments\n+----\n+\n+The above command should return  `[\"first\"]` indicating that we have only one increment thus far.\n+\n+=== Retrieve a new increment\n+\n+To retrieve an increment using its key, we will have to run the below command:\n+\n+[source, shell]\n+----\n+curl http://localhost:8080/increments/first <1>\n+----\n+\n+1. Running this command, should return the following result:\n+\n+[source, json]\n+----\n+{\n+  \"key\": \"first\",\n+  \"value\": 10\n+}\n+----\n+\n+=== Increment a value given its key\n+\n+To increment a value, run the following command:\n+\n+[source, shell]\n+----\n+curl -X PUT -H \"Content-Type: application/json\" -d '27' http://localhost:8080/increments/first <1>\n+----\n+\n+1. Increment the `first` value by 27.\n+\n+Now, running the command `curl http://localhost:8080/increments/first` should return the following result:\n+\n+[source, json]\n+----\n+{\n+  \"key\": \"first\",\n+  \"value\": 37 <1>\n+}\n+----\n+\n+1. We see that the value of the `first` key is now `37` which is exactly the result of `10 + 27`, quick maths.\n+\n+=== Deleting a key\n+\n+Use the command below, to delete an increment given its key.\n+\n+[source, shell]\n+----\n+curl -X DELETE  http://localhost:8080/increments/first <1>\n+----\n+\n+1. Delete the `first` increment.\n+\n+Now, running the command `curl http://localhost:8080/increments` should return an empty list `[]`\n+\n+== Packaging and running in JVM mode\n+\n+You can run the application as a conventional jar file.\n+\n+First, we will need to package it:\n+\n+[source, shell]\n+----\n+./mvnw package\n+----\n+\n+NOTE: This command will start a Redis instance to execute the tests. Thus your Redis containers need to be stopped.\n+\n+Then run it:\n+\n+[source, shell]\n+----\n+java -jar ./target/redis-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+== Running Native\n+\n+You can also create a native executable from this application without making any\n+source code changes. A native executable removes the dependency on the JVM:\n+everything needed to run the application on the target platform is included in\n+the executable, allowing the application to run with minimal resource overhead.\n+\n+Compiling a native executable takes a bit longer, as GraalVM performs additional\n+steps to remove unnecessary codepaths. Use the  `native` profile to compile a\n+native executable:\n+\n+[source, shell]\n+----\n+./mvnw package -Pnative\n+----\n+\n+Once the build is finished, you can run the executable with:\n+\n+[source, shell]\n+----\n+./target/redis-quickstart-1.0-SNAPSHOT-runner\n+----\n+\n+== Connection Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vertx-redis` will automatically add a readiness health check\n+to validate the connection to the Redis server.\n+\n+So when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be disabled by setting the `quarkus.redis.health.enabled` property to `false` in your `application.properties`.\n+\n+== Configuration Reference", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNzM2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443337362", "bodyText": "It should be tested with more complicated objects (list, json, pojo...)", "author": "cescoffier", "createdAt": "2020-06-22T06:17:41Z", "path": "integration-tests/redis-client/src/main/java/io/quarkus/redis/it/RedisResource.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package io.quarkus.redis.it;\n+\n+import java.util.Arrays;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.redis.client.RedisAPI;\n+\n+@Path(\"/quarkus-redis\")\n+@ApplicationScoped\n+public class RedisResource {\n+    @Inject\n+    SyncRedisAPI syncRedisAPI;\n+\n+    @Inject\n+    RedisAPI reactiveRedisAPI;\n+\n+    // synchronous\n+    @GET\n+    @Path(\"/sync/{key}\")\n+    public String getSync(@PathParam(\"key\") String key) {\n+        return syncRedisAPI.get(key).toString();\n+    }\n+\n+    @POST\n+    @Path(\"/sync/{key}\")\n+    public void setSync(@PathParam(\"key\") String key, String value) {\n+        this.syncRedisAPI.set(Arrays.asList(key, value));\n+    }\n+\n+    // reactive\n+    @GET\n+    @Path(\"/reactive/{key}\")\n+    public Uni<String> getReactive(@PathParam(\"key\") String key) {", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODAwNg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443338006", "bodyText": "There is a lot more options to be configured:\nhttps://github.com/vert-x3/vertx-redis-client/blob/master/src/main/java/io/vertx/redis/client/RedisOptions.java", "author": "cescoffier", "createdAt": "2020-06-22T06:19:44Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisConfig.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.vertx.redis.client.RedisClientType;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class RedisConfig {", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxMTY0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444311645", "bodyText": "Yes, let's add them gradually as they are requested.", "author": "machi1990", "createdAt": "2020-06-23T15:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODMxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443338315", "bodyText": "shouldn't we use the synthetic bean approach?", "author": "cescoffier", "createdAt": "2020-06-22T06:20:43Z", "path": "extensions/redis-client/deployment/src/main/java/io/quarkus/redis/client/deployment/RedisClientProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package io.quarkus.redis.client.deployment;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.Feature;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.smallrye.health.deployment.spi.HealthBuildItem;\n+import io.vertx.redis.client.impl.types.BulkType;\n+\n+public class RedisClientProcessor {\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(Feature.REDIS_CLIENT);\n+    }\n+\n+    @BuildStep\n+    ExtensionSslNativeSupportBuildItem activateSslNativeSupport() {\n+        return new ExtensionSslNativeSupportBuildItem(Feature.REDIS_CLIENT.getName());\n+    }\n+\n+    @BuildStep\n+    AdditionalBeanBuildItem registerAPIsProducer() {\n+        return AdditionalBeanBuildItem.unremovableOf(\"io.quarkus.redis.client.runtime.RedisAPIProducer\");", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxMjQwMw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444312403", "bodyText": "Why?", "author": "machi1990", "createdAt": "2020-06-23T15:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3MTg4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449471885", "bodyText": "We had some issues with beans not being injectable in gRPC for instance.\nI might admit that I have no idea if it will be the case here. @mkouba could you confirm if we need the synthetic bean approach or if the producer approach will fly here?", "author": "gsmet", "createdAt": "2020-07-03T09:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ4ODc2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449488769", "bodyText": "Synthetic beans are the way to go if there is a possibility that someone attempts to inject @Dependent/@Singleton bean produced by an uninitialized producer bean (usually before the StartupEvent is fired). From what I see the RedisAPIProducer is not initialized by a recorder so I think it's OK.", "author": "mkouba", "createdAt": "2020-07-03T09:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzODM5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443338395", "bodyText": "name looks off", "author": "cescoffier", "createdAt": "2020-06-22T06:20:58Z", "path": "extensions/redis-client/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,65 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-redis-client-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+\n+    <artifactId>quarkus-redis-client</artifactId>\n+\n+    <name>Quarkus -Redis Client - Runtime</name>", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NDY3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443354676", "bodyText": "Make sure this is documented as it does not use the default value attribute.", "author": "cescoffier", "createdAt": "2020-06-22T07:05:02Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisAPIProducer.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Set;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.vertx.core.Vertx;\n+import io.vertx.redis.client.Redis;\n+import io.vertx.redis.client.RedisAPI;\n+import io.vertx.redis.client.RedisClientType;\n+import io.vertx.redis.client.RedisOptions;\n+\n+@ApplicationScoped\n+class RedisAPIProducer {\n+    private static final char AT = '@';\n+    private static final char COLON = ':';\n+    private static final char SLASH = '/';\n+    private static final String REDIS_SCHEME = \"redis://\";\n+    private static final String REDIS_SSL_SCHEME = \"rediss://\";\n+\n+    private long timeout = 10;\n+\n+    private final RedisConfig config;\n+\n+    private final Redis redisClient;\n+\n+    private final RedisAPI redisAPI;\n+\n+    private final SyncRedisAPI syncRedisAPI;\n+\n+    private final io.vertx.mutiny.redis.client.Redis mutinyRedisClient;\n+\n+    private final io.vertx.mutiny.redis.client.RedisAPI mutinyRedisAPI;\n+\n+    public RedisAPIProducer(RedisConfig config, Vertx vertx) {\n+        this.config = config;\n+        RedisOptions options = new RedisOptions();\n+        options.setType(config.clientType);\n+\n+        if (RedisClientType.STANDALONE == config.clientType) {\n+            if (config.hosts.isPresent() && config.hosts.get().size() > 1) {\n+                throw new ConfigurationException(\"Multiple hosts supplied for non clustered configuration\");\n+            }\n+        }\n+\n+        if (config.hosts.isPresent()) {\n+            Set<InetSocketAddress> hosts = config.hosts.get();\n+            for (InetSocketAddress host : hosts) {\n+                String connectionString = buildConnectionString(host);\n+                options.addConnectionString(connectionString);\n+            }\n+        } else {\n+            InetSocketAddress defaultRedisAddress = new InetSocketAddress(\"localhost\", 6379);", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxNDM1MA==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444314350", "bodyText": "It should be automatically documented with this default value https://github.com/quarkusio/quarkus/pull/9370/files#diff-61bc41cc0a7b78f75d4088c283c29ffbR25", "author": "machi1990", "createdAt": "2020-06-23T15:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NDY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NTQwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443355401", "bodyText": "You should use mutiyResponse.await().atMost(Duration.ofSeconds(timeout);", "author": "cescoffier", "createdAt": "2020-06-22T07:06:48Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/SyncRedisAPIImpl.java", "diffHunk": "@@ -0,0 +1,1039 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.redis.client.RedisAPI;\n+import io.vertx.redis.client.Response;\n+\n+class SyncRedisAPIImpl implements SyncRedisAPI {\n+\n+    private final RedisAPI redisAPI;\n+    private final long timeout;\n+\n+    public SyncRedisAPIImpl(RedisAPI redisAPI, long timeout) {\n+        this.redisAPI = redisAPI;\n+        this.timeout = timeout;\n+    }\n+\n+    @Override\n+    public void close() {\n+        redisAPI.close();\n+    }\n+\n+    @Override\n+    public Response append(String arg0, String arg1) {\n+        return await(redisAPI.append(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response asking() {\n+        return await(redisAPI.asking());\n+    }\n+\n+    @Override\n+    public Response auth(String arg0) {\n+        return await(redisAPI.auth(arg0));\n+    }\n+\n+    @Override\n+    public Response bgrewriteaof() {\n+        return await(redisAPI.bgrewriteaof());\n+    }\n+\n+    @Override\n+    public Response bgsave(List<String> args) {\n+        return await(redisAPI.bgsave(args));\n+    }\n+\n+    @Override\n+    public Response bitcount(List<String> args) {\n+        return await(redisAPI.bitcount(args));\n+    }\n+\n+    @Override\n+    public Response bitfield(List<String> args) {\n+        return await(redisAPI.bitfield(args));\n+    }\n+\n+    @Override\n+    public Response bitop(List<String> args) {\n+        return await(redisAPI.bitop(args));\n+    }\n+\n+    @Override\n+    public Response bitpos(List<String> args) {\n+        return await(redisAPI.bitpos(args));\n+    }\n+\n+    @Override\n+    public Response blpop(List<String> args) {\n+        return await(redisAPI.blpop(args));\n+    }\n+\n+    @Override\n+    public Response brpop(List<String> args) {\n+        return await(redisAPI.brpop(args));\n+    }\n+\n+    @Override\n+    public Response brpoplpush(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.brpoplpush(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response bzpopmax(List<String> args) {\n+        return await(redisAPI.bzpopmax(args));\n+    }\n+\n+    @Override\n+    public Response bzpopmin(List<String> args) {\n+        return await(redisAPI.bzpopmin(args));\n+    }\n+\n+    @Override\n+    public Response client(List<String> args) {\n+        return await(redisAPI.client(args));\n+    }\n+\n+    @Override\n+    public Response cluster(List<String> args) {\n+        return await(redisAPI.cluster(args));\n+    }\n+\n+    @Override\n+    public Response command() {\n+        return await(redisAPI.command());\n+    }\n+\n+    @Override\n+    public Response config(List<String> args) {\n+        return await(redisAPI.config(args));\n+    }\n+\n+    @Override\n+    public Response dbsize() {\n+        return await(redisAPI.dbsize());\n+    }\n+\n+    @Override\n+    public Response debug(List<String> args) {\n+        return await(redisAPI.debug(args));\n+    }\n+\n+    @Override\n+    public Response decr(String arg0) {\n+        return await(redisAPI.decr(arg0));\n+    }\n+\n+    @Override\n+    public Response decrby(String arg0, String arg1) {\n+        return await(redisAPI.decrby(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response del(List<String> args) {\n+        return await(redisAPI.del(args));\n+    }\n+\n+    @Override\n+    public Response discard() {\n+        return await(redisAPI.discard());\n+    }\n+\n+    @Override\n+    public Response dump(String arg0) {\n+        return await(redisAPI.dump(arg0));\n+    }\n+\n+    @Override\n+    public Response echo(String arg0) {\n+        return await(redisAPI.echo(arg0));\n+    }\n+\n+    @Override\n+    public Response eval(List<String> args) {\n+        return await(redisAPI.eval(args));\n+    }\n+\n+    @Override\n+    public Response evalsha(List<String> args) {\n+        return await(redisAPI.evalsha(args));\n+    }\n+\n+    @Override\n+    public Response exec() {\n+        return await(redisAPI.exec());\n+    }\n+\n+    @Override\n+    public Response exists(List<String> args) {\n+        return await(redisAPI.exists(args));\n+    }\n+\n+    @Override\n+    public Response expire(String arg0, String arg1) {\n+        return await(redisAPI.expire(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response expireat(String arg0, String arg1) {\n+        return await(redisAPI.expireat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response flushall(List<String> args) {\n+        return await(redisAPI.flushall(args));\n+    }\n+\n+    @Override\n+    public Response flushdb(List<String> args) {\n+        return await(redisAPI.flushdb(args));\n+    }\n+\n+    @Override\n+    public Response geoadd(List<String> args) {\n+        return await(redisAPI.geoadd(args));\n+    }\n+\n+    @Override\n+    public Response geodist(List<String> args) {\n+        return await(redisAPI.geodist(args));\n+    }\n+\n+    @Override\n+    public Response geohash(List<String> args) {\n+        return await(redisAPI.geohash(args));\n+    }\n+\n+    @Override\n+    public Response geopos(List<String> args) {\n+        return await(redisAPI.geopos(args));\n+    }\n+\n+    @Override\n+    public Response georadius(List<String> args) {\n+        return await(redisAPI.georadius(args));\n+    }\n+\n+    @Override\n+    public Response georadiusRo(List<String> args) {\n+        return await(redisAPI.georadiusRo(args));\n+    }\n+\n+    @Override\n+    public Response georadiusbymember(List<String> args) {\n+        return await(redisAPI.georadiusbymember(args));\n+    }\n+\n+    @Override\n+    public Response georadiusbymemberRo(List<String> args) {\n+        return await(redisAPI.georadiusbymemberRo(args));\n+    }\n+\n+    @Override\n+    public Response get(String arg0) {\n+        return await(redisAPI.get(arg0));\n+    }\n+\n+    @Override\n+    public Response getbit(String arg0, String arg1) {\n+        return await(redisAPI.getbit(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response getrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.getrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response getset(String arg0, String arg1) {\n+        return await(redisAPI.getset(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hdel(List<String> args) {\n+        return await(redisAPI.hdel(args));\n+    }\n+\n+    @Override\n+    public Response hexists(String arg0, String arg1) {\n+        return await(redisAPI.hexists(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hget(String arg0, String arg1) {\n+        return await(redisAPI.hget(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hgetall(String arg0) {\n+        return await(redisAPI.hgetall(arg0));\n+    }\n+\n+    @Override\n+    public Response hincrby(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hincrby(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hincrbyfloat(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hincrbyfloat(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hkeys(String arg0) {\n+        return await(redisAPI.hkeys(arg0));\n+    }\n+\n+    @Override\n+    public Response hlen(String arg0) {\n+        return await(redisAPI.hlen(arg0));\n+    }\n+\n+    @Override\n+    public Response hmget(List<String> args) {\n+        return await(redisAPI.hmget(args));\n+    }\n+\n+    @Override\n+    public Response hmset(List<String> args) {\n+        return await(redisAPI.hmset(args));\n+    }\n+\n+    @Override\n+    public Response host(List<String> args) {\n+        return await(redisAPI.host(args));\n+    }\n+\n+    @Override\n+    public Response hscan(List<String> args) {\n+        return await(redisAPI.hscan(args));\n+    }\n+\n+    @Override\n+    public Response hset(List<String> args) {\n+        return await(redisAPI.hset(args));\n+    }\n+\n+    @Override\n+    public Response hsetnx(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hsetnx(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hstrlen(String arg0, String arg1) {\n+        return await(redisAPI.hstrlen(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hvals(String arg0) {\n+        return await(redisAPI.hvals(arg0));\n+    }\n+\n+    @Override\n+    public Response incr(String arg0) {\n+        return await(redisAPI.incr(arg0));\n+    }\n+\n+    @Override\n+    public Response incrby(String arg0, String arg1) {\n+        return await(redisAPI.incrby(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response incrbyfloat(String arg0, String arg1) {\n+        return await(redisAPI.incrbyfloat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response info(List<String> args) {\n+        return await(redisAPI.info(args));\n+    }\n+\n+    @Override\n+    public Response keys(String arg0) {\n+        return await(redisAPI.keys(arg0));\n+    }\n+\n+    @Override\n+    public Response lastsave() {\n+        return await(redisAPI.lastsave());\n+    }\n+\n+    @Override\n+    public Response latency(List<String> args) {\n+        return await(redisAPI.latency(args));\n+    }\n+\n+    @Override\n+    public Response lindex(String arg0, String arg1) {\n+        return await(redisAPI.lindex(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response linsert(String arg0, String arg1, String arg2, String arg3) {\n+        return await(redisAPI.linsert(arg0, arg1, arg2, arg3));\n+    }\n+\n+    @Override\n+    public Response llen(String arg0) {\n+        return await(redisAPI.llen(arg0));\n+    }\n+\n+    @Override\n+    public Response lolwut(List<String> args) {\n+        return await(redisAPI.lolwut(args));\n+    }\n+\n+    @Override\n+    public Response lpop(String arg0) {\n+        return await(redisAPI.lpop(arg0));\n+    }\n+\n+    @Override\n+    public Response lpush(List<String> args) {\n+        return await(redisAPI.lpush(args));\n+    }\n+\n+    @Override\n+    public Response lpushx(List<String> args) {\n+        return await(redisAPI.lpushx(args));\n+    }\n+\n+    @Override\n+    public Response lrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response lrem(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lrem(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response lset(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lset(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response ltrim(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.ltrim(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response memory(List<String> args) {\n+        return await(redisAPI.memory(args));\n+    }\n+\n+    @Override\n+    public Response mget(List<String> args) {\n+        return await(redisAPI.mget(args));\n+    }\n+\n+    @Override\n+    public Response migrate(List<String> args) {\n+        return await(redisAPI.migrate(args));\n+    }\n+\n+    @Override\n+    public Response module(List<String> args) {\n+        return await(redisAPI.module(args));\n+    }\n+\n+    @Override\n+    public Response monitor() {\n+        return await(redisAPI.monitor());\n+    }\n+\n+    @Override\n+    public Response move(String arg0, String arg1) {\n+        return await(redisAPI.move(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response mset(List<String> args) {\n+        return await(redisAPI.mset(args));\n+    }\n+\n+    @Override\n+    public Response msetnx(List<String> args) {\n+        return await(redisAPI.msetnx(args));\n+    }\n+\n+    @Override\n+    public Response multi() {\n+        return await(redisAPI.multi());\n+    }\n+\n+    @Override\n+    public Response object(List<String> args) {\n+        return await(redisAPI.object(args));\n+    }\n+\n+    @Override\n+    public Response persist(String arg0) {\n+        return await(redisAPI.persist(arg0));\n+    }\n+\n+    @Override\n+    public Response pexpire(String arg0, String arg1) {\n+        return await(redisAPI.pexpire(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pexpireat(String arg0, String arg1) {\n+        return await(redisAPI.pexpireat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pfadd(List<String> args) {\n+        return await(redisAPI.pfadd(args));\n+    }\n+\n+    @Override\n+    public Response pfcount(List<String> args) {\n+        return await(redisAPI.pfcount(args));\n+    }\n+\n+    @Override\n+    public Response pfdebug(List<String> args) {\n+        return await(redisAPI.pfdebug(args));\n+    }\n+\n+    @Override\n+    public Response pfmerge(List<String> args) {\n+        return await(redisAPI.pfmerge(args));\n+    }\n+\n+    @Override\n+    public Response pfselftest() {\n+        return await(redisAPI.pfselftest());\n+    }\n+\n+    @Override\n+    public Response ping(List<String> args) {\n+        return await(redisAPI.ping(args));\n+    }\n+\n+    @Override\n+    public Response post(List<String> args) {\n+        return await(redisAPI.post(args));\n+    }\n+\n+    @Override\n+    public Response psetex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.psetex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response psubscribe(List<String> args) {\n+        return await(redisAPI.psubscribe(args));\n+    }\n+\n+    @Override\n+    public Response psync(String arg0, String arg1) {\n+        return await(redisAPI.psync(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pttl(String arg0) {\n+        return await(redisAPI.pttl(arg0));\n+    }\n+\n+    @Override\n+    public Response publish(String arg0, String arg1) {\n+        return await(redisAPI.publish(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pubsub(List<String> args) {\n+        return await(redisAPI.pubsub(args));\n+    }\n+\n+    @Override\n+    public Response punsubscribe(List<String> args) {\n+        return await(redisAPI.punsubscribe(args));\n+    }\n+\n+    @Override\n+    public Response randomkey() {\n+        return await(redisAPI.randomkey());\n+    }\n+\n+    @Override\n+    public Response readonly() {\n+        return await(redisAPI.readonly());\n+    }\n+\n+    @Override\n+    public Response readwrite() {\n+        return await(redisAPI.readwrite());\n+    }\n+\n+    @Override\n+    public Response rename(String arg0, String arg1) {\n+        return await(redisAPI.rename(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response renamenx(String arg0, String arg1) {\n+        return await(redisAPI.renamenx(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response replconf(List<String> args) {\n+        return await(redisAPI.replconf(args));\n+    }\n+\n+    @Override\n+    public Response replicaof(String arg0, String arg1) {\n+        return await(redisAPI.replicaof(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response restore(List<String> args) {\n+        return await(redisAPI.restore(args));\n+    }\n+\n+    @Override\n+    public Response restoreAsking(List<String> args) {\n+        return await(redisAPI.restoreAsking(args));\n+    }\n+\n+    @Override\n+    public Response role() {\n+        return await(redisAPI.role());\n+    }\n+\n+    @Override\n+    public Response rpop(String arg0) {\n+        return await(redisAPI.rpop(arg0));\n+    }\n+\n+    @Override\n+    public Response rpoplpush(String arg0, String arg1) {\n+        return await(redisAPI.rpoplpush(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response rpush(List<String> args) {\n+        return await(redisAPI.rpush(args));\n+    }\n+\n+    @Override\n+    public Response rpushx(List<String> args) {\n+        return await(redisAPI.rpushx(args));\n+    }\n+\n+    @Override\n+    public Response sadd(List<String> args) {\n+        return await(redisAPI.sadd(args));\n+    }\n+\n+    @Override\n+    public Response save() {\n+        return await(redisAPI.save());\n+    }\n+\n+    @Override\n+    public Response scan(List<String> args) {\n+        return await(redisAPI.scan(args));\n+    }\n+\n+    @Override\n+    public Response scard(String arg0) {\n+        return await(redisAPI.scard(arg0));\n+    }\n+\n+    @Override\n+    public Response script(List<String> args) {\n+        return await(redisAPI.script(args));\n+    }\n+\n+    @Override\n+    public Response sdiff(List<String> args) {\n+        return await(redisAPI.sdiff(args));\n+    }\n+\n+    @Override\n+    public Response sdiffstore(List<String> args) {\n+        return await(redisAPI.sdiffstore(args));\n+    }\n+\n+    @Override\n+    public Response select(String arg0) {\n+        return await(redisAPI.select(arg0));\n+    }\n+\n+    @Override\n+    public Response set(List<String> args) {\n+        return await(redisAPI.set(args));\n+    }\n+\n+    @Override\n+    public Response setbit(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setbit(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response setex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response setnx(String arg0, String arg1) {\n+        return await(redisAPI.setnx(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response setrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response shutdown(List<String> args) {\n+        return await(redisAPI.shutdown(args));\n+    }\n+\n+    @Override\n+    public Response sinter(List<String> args) {\n+        return await(redisAPI.sinter(args));\n+    }\n+\n+    @Override\n+    public Response sinterstore(List<String> args) {\n+        return await(redisAPI.sinterstore(args));\n+    }\n+\n+    @Override\n+    public Response sismember(String arg0, String arg1) {\n+        return await(redisAPI.sismember(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response slaveof(String arg0, String arg1) {\n+        return await(redisAPI.slaveof(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response slowlog(List<String> args) {\n+        return await(redisAPI.slowlog(args));\n+    }\n+\n+    @Override\n+    public Response smembers(String arg0) {\n+        return await(redisAPI.smembers(arg0));\n+    }\n+\n+    @Override\n+    public Response smove(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.smove(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response sort(List<String> args) {\n+        return await(redisAPI.sort(args));\n+    }\n+\n+    @Override\n+    public Response spop(List<String> args) {\n+        return await(redisAPI.spop(args));\n+    }\n+\n+    @Override\n+    public Response srandmember(List<String> args) {\n+        return await(redisAPI.srandmember(args));\n+    }\n+\n+    @Override\n+    public Response srem(List<String> args) {\n+        return await(redisAPI.srem(args));\n+    }\n+\n+    @Override\n+    public Response sscan(List<String> args) {\n+        return await(redisAPI.sscan(args));\n+    }\n+\n+    @Override\n+    public Response strlen(String arg0) {\n+        return await(redisAPI.strlen(arg0));\n+    }\n+\n+    @Override\n+    public Response subscribe(List<String> args) {\n+        return await(redisAPI.subscribe(args));\n+    }\n+\n+    @Override\n+    public Response substr(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.substr(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response sunion(List<String> args) {\n+        return await(redisAPI.sunion(args));\n+    }\n+\n+    @Override\n+    public Response sunionstore(List<String> args) {\n+        return await(redisAPI.sunionstore(args));\n+    }\n+\n+    @Override\n+    public Response swapdb(String arg0, String arg1) {\n+        return await(redisAPI.swapdb(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response sync() {\n+        return await(redisAPI.sync());\n+    }\n+\n+    @Override\n+    public Response time() {\n+        return await(redisAPI.time());\n+    }\n+\n+    @Override\n+    public Response touch(List<String> args) {\n+        return await(redisAPI.touch(args));\n+    }\n+\n+    @Override\n+    public Response ttl(String arg0) {\n+        return await(redisAPI.ttl(arg0));\n+    }\n+\n+    @Override\n+    public Response type(String arg0) {\n+        return await(redisAPI.type(arg0));\n+    }\n+\n+    @Override\n+    public Response unlink(List<String> args) {\n+        return await(redisAPI.unlink(args));\n+    }\n+\n+    @Override\n+    public Response unsubscribe(List<String> args) {\n+        return await(redisAPI.unsubscribe(args));\n+    }\n+\n+    @Override\n+    public Response unwatch() {\n+        return await(redisAPI.unwatch());\n+    }\n+\n+    @Override\n+    public Response wait(String arg0, String arg1) {\n+        return await(redisAPI.wait(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response watch(List<String> args) {\n+        return await(redisAPI.watch(args));\n+    }\n+\n+    @Override\n+    public Response xack(List<String> args) {\n+        return await(redisAPI.xack(args));\n+    }\n+\n+    @Override\n+    public Response xadd(List<String> args) {\n+        return await(redisAPI.xadd(args));\n+    }\n+\n+    @Override\n+    public Response xclaim(List<String> args) {\n+        return await(redisAPI.xclaim(args));\n+    }\n+\n+    @Override\n+    public Response xdel(List<String> args) {\n+        return await(redisAPI.xdel(args));\n+    }\n+\n+    @Override\n+    public Response xgroup(List<String> args) {\n+        return await(redisAPI.xgroup(args));\n+    }\n+\n+    @Override\n+    public Response xinfo(List<String> args) {\n+        return await(redisAPI.xinfo(args));\n+    }\n+\n+    @Override\n+    public Response xlen(String arg0) {\n+        return await(redisAPI.xlen(arg0));\n+    }\n+\n+    @Override\n+    public Response xpending(List<String> args) {\n+        return await(redisAPI.xpending(args));\n+    }\n+\n+    @Override\n+    public Response xrange(List<String> args) {\n+        return await(redisAPI.xrange(args));\n+    }\n+\n+    @Override\n+    public Response xread(List<String> args) {\n+        return await(redisAPI.xread(args));\n+    }\n+\n+    @Override\n+    public Response xreadgroup(List<String> args) {\n+        return await(redisAPI.xreadgroup(args));\n+    }\n+\n+    @Override\n+    public Response xrevrange(List<String> args) {\n+        return await(redisAPI.xrevrange(args));\n+    }\n+\n+    @Override\n+    public Response xsetid(String arg0, String arg1) {\n+        return await(redisAPI.xsetid(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response xtrim(List<String> args) {\n+        return await(redisAPI.xtrim(args));\n+    }\n+\n+    @Override\n+    public Response zadd(List<String> args) {\n+        return await(redisAPI.zadd(args));\n+    }\n+\n+    @Override\n+    public Response zcard(String arg0) {\n+        return await(redisAPI.zcard(arg0));\n+    }\n+\n+    @Override\n+    public Response zcount(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zcount(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zincrby(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zincrby(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zinterstore(List<String> args) {\n+        return await(redisAPI.zinterstore(args));\n+    }\n+\n+    @Override\n+    public Response zlexcount(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zlexcount(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zpopmax(List<String> args) {\n+        return await(redisAPI.zpopmax(args));\n+    }\n+\n+    @Override\n+    public Response zpopmin(List<String> args) {\n+        return await(redisAPI.zpopmin(args));\n+    }\n+\n+    @Override\n+    public Response zrange(List<String> args) {\n+        return await(redisAPI.zrange(args));\n+    }\n+\n+    @Override\n+    public Response zrangebylex(List<String> args) {\n+        return await(redisAPI.zrangebylex(args));\n+    }\n+\n+    @Override\n+    public Response zrangebyscore(List<String> args) {\n+        return await(redisAPI.zrangebyscore(args));\n+    }\n+\n+    @Override\n+    public Response zrank(String arg0, String arg1) {\n+        return await(redisAPI.zrank(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zrem(List<String> args) {\n+        return await(redisAPI.zrem(args));\n+    }\n+\n+    @Override\n+    public Response zremrangebylex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebylex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zremrangebyrank(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebyrank(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zremrangebyscore(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebyscore(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zrevrange(List<String> args) {\n+        return await(redisAPI.zrevrange(args));\n+    }\n+\n+    @Override\n+    public Response zrevrangebylex(List<String> args) {\n+        return await(redisAPI.zrevrangebylex(args));\n+    }\n+\n+    @Override\n+    public Response zrevrangebyscore(List<String> args) {\n+        return await(redisAPI.zrevrangebyscore(args));\n+    }\n+\n+    @Override\n+    public Response zrevrank(String arg0, String arg1) {\n+        return await(redisAPI.zrevrank(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zscan(List<String> args) {\n+        return await(redisAPI.zscan(args));\n+    }\n+\n+    @Override\n+    public Response zscore(String arg0, String arg1) {\n+        return await(redisAPI.zscore(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zunionstore(List<String> args) {\n+        return await(redisAPI.zunionstore(args));\n+    }\n+\n+    private Response await(Uni<io.vertx.mutiny.redis.client.Response> mutinyResponse) {\n+        try {\n+            return mutinyResponse.subscribeAsCompletionStage()", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxNDY5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444314692", "bodyText": "Cool.", "author": "machi1990", "createdAt": "2020-06-23T15:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NTQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NTcxNw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r443355717", "bodyText": "you need to reset the interrupt flag if you get an InterruptedException.\nIn case of an ExecutionException, the cause must be wrapped not the exception.", "author": "cescoffier", "createdAt": "2020-06-22T07:07:32Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/SyncRedisAPIImpl.java", "diffHunk": "@@ -0,0 +1,1039 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.quarkus.redis.client.SyncRedisAPI;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.mutiny.redis.client.RedisAPI;\n+import io.vertx.redis.client.Response;\n+\n+class SyncRedisAPIImpl implements SyncRedisAPI {\n+\n+    private final RedisAPI redisAPI;\n+    private final long timeout;\n+\n+    public SyncRedisAPIImpl(RedisAPI redisAPI, long timeout) {\n+        this.redisAPI = redisAPI;\n+        this.timeout = timeout;\n+    }\n+\n+    @Override\n+    public void close() {\n+        redisAPI.close();\n+    }\n+\n+    @Override\n+    public Response append(String arg0, String arg1) {\n+        return await(redisAPI.append(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response asking() {\n+        return await(redisAPI.asking());\n+    }\n+\n+    @Override\n+    public Response auth(String arg0) {\n+        return await(redisAPI.auth(arg0));\n+    }\n+\n+    @Override\n+    public Response bgrewriteaof() {\n+        return await(redisAPI.bgrewriteaof());\n+    }\n+\n+    @Override\n+    public Response bgsave(List<String> args) {\n+        return await(redisAPI.bgsave(args));\n+    }\n+\n+    @Override\n+    public Response bitcount(List<String> args) {\n+        return await(redisAPI.bitcount(args));\n+    }\n+\n+    @Override\n+    public Response bitfield(List<String> args) {\n+        return await(redisAPI.bitfield(args));\n+    }\n+\n+    @Override\n+    public Response bitop(List<String> args) {\n+        return await(redisAPI.bitop(args));\n+    }\n+\n+    @Override\n+    public Response bitpos(List<String> args) {\n+        return await(redisAPI.bitpos(args));\n+    }\n+\n+    @Override\n+    public Response blpop(List<String> args) {\n+        return await(redisAPI.blpop(args));\n+    }\n+\n+    @Override\n+    public Response brpop(List<String> args) {\n+        return await(redisAPI.brpop(args));\n+    }\n+\n+    @Override\n+    public Response brpoplpush(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.brpoplpush(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response bzpopmax(List<String> args) {\n+        return await(redisAPI.bzpopmax(args));\n+    }\n+\n+    @Override\n+    public Response bzpopmin(List<String> args) {\n+        return await(redisAPI.bzpopmin(args));\n+    }\n+\n+    @Override\n+    public Response client(List<String> args) {\n+        return await(redisAPI.client(args));\n+    }\n+\n+    @Override\n+    public Response cluster(List<String> args) {\n+        return await(redisAPI.cluster(args));\n+    }\n+\n+    @Override\n+    public Response command() {\n+        return await(redisAPI.command());\n+    }\n+\n+    @Override\n+    public Response config(List<String> args) {\n+        return await(redisAPI.config(args));\n+    }\n+\n+    @Override\n+    public Response dbsize() {\n+        return await(redisAPI.dbsize());\n+    }\n+\n+    @Override\n+    public Response debug(List<String> args) {\n+        return await(redisAPI.debug(args));\n+    }\n+\n+    @Override\n+    public Response decr(String arg0) {\n+        return await(redisAPI.decr(arg0));\n+    }\n+\n+    @Override\n+    public Response decrby(String arg0, String arg1) {\n+        return await(redisAPI.decrby(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response del(List<String> args) {\n+        return await(redisAPI.del(args));\n+    }\n+\n+    @Override\n+    public Response discard() {\n+        return await(redisAPI.discard());\n+    }\n+\n+    @Override\n+    public Response dump(String arg0) {\n+        return await(redisAPI.dump(arg0));\n+    }\n+\n+    @Override\n+    public Response echo(String arg0) {\n+        return await(redisAPI.echo(arg0));\n+    }\n+\n+    @Override\n+    public Response eval(List<String> args) {\n+        return await(redisAPI.eval(args));\n+    }\n+\n+    @Override\n+    public Response evalsha(List<String> args) {\n+        return await(redisAPI.evalsha(args));\n+    }\n+\n+    @Override\n+    public Response exec() {\n+        return await(redisAPI.exec());\n+    }\n+\n+    @Override\n+    public Response exists(List<String> args) {\n+        return await(redisAPI.exists(args));\n+    }\n+\n+    @Override\n+    public Response expire(String arg0, String arg1) {\n+        return await(redisAPI.expire(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response expireat(String arg0, String arg1) {\n+        return await(redisAPI.expireat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response flushall(List<String> args) {\n+        return await(redisAPI.flushall(args));\n+    }\n+\n+    @Override\n+    public Response flushdb(List<String> args) {\n+        return await(redisAPI.flushdb(args));\n+    }\n+\n+    @Override\n+    public Response geoadd(List<String> args) {\n+        return await(redisAPI.geoadd(args));\n+    }\n+\n+    @Override\n+    public Response geodist(List<String> args) {\n+        return await(redisAPI.geodist(args));\n+    }\n+\n+    @Override\n+    public Response geohash(List<String> args) {\n+        return await(redisAPI.geohash(args));\n+    }\n+\n+    @Override\n+    public Response geopos(List<String> args) {\n+        return await(redisAPI.geopos(args));\n+    }\n+\n+    @Override\n+    public Response georadius(List<String> args) {\n+        return await(redisAPI.georadius(args));\n+    }\n+\n+    @Override\n+    public Response georadiusRo(List<String> args) {\n+        return await(redisAPI.georadiusRo(args));\n+    }\n+\n+    @Override\n+    public Response georadiusbymember(List<String> args) {\n+        return await(redisAPI.georadiusbymember(args));\n+    }\n+\n+    @Override\n+    public Response georadiusbymemberRo(List<String> args) {\n+        return await(redisAPI.georadiusbymemberRo(args));\n+    }\n+\n+    @Override\n+    public Response get(String arg0) {\n+        return await(redisAPI.get(arg0));\n+    }\n+\n+    @Override\n+    public Response getbit(String arg0, String arg1) {\n+        return await(redisAPI.getbit(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response getrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.getrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response getset(String arg0, String arg1) {\n+        return await(redisAPI.getset(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hdel(List<String> args) {\n+        return await(redisAPI.hdel(args));\n+    }\n+\n+    @Override\n+    public Response hexists(String arg0, String arg1) {\n+        return await(redisAPI.hexists(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hget(String arg0, String arg1) {\n+        return await(redisAPI.hget(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hgetall(String arg0) {\n+        return await(redisAPI.hgetall(arg0));\n+    }\n+\n+    @Override\n+    public Response hincrby(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hincrby(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hincrbyfloat(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hincrbyfloat(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hkeys(String arg0) {\n+        return await(redisAPI.hkeys(arg0));\n+    }\n+\n+    @Override\n+    public Response hlen(String arg0) {\n+        return await(redisAPI.hlen(arg0));\n+    }\n+\n+    @Override\n+    public Response hmget(List<String> args) {\n+        return await(redisAPI.hmget(args));\n+    }\n+\n+    @Override\n+    public Response hmset(List<String> args) {\n+        return await(redisAPI.hmset(args));\n+    }\n+\n+    @Override\n+    public Response host(List<String> args) {\n+        return await(redisAPI.host(args));\n+    }\n+\n+    @Override\n+    public Response hscan(List<String> args) {\n+        return await(redisAPI.hscan(args));\n+    }\n+\n+    @Override\n+    public Response hset(List<String> args) {\n+        return await(redisAPI.hset(args));\n+    }\n+\n+    @Override\n+    public Response hsetnx(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.hsetnx(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response hstrlen(String arg0, String arg1) {\n+        return await(redisAPI.hstrlen(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response hvals(String arg0) {\n+        return await(redisAPI.hvals(arg0));\n+    }\n+\n+    @Override\n+    public Response incr(String arg0) {\n+        return await(redisAPI.incr(arg0));\n+    }\n+\n+    @Override\n+    public Response incrby(String arg0, String arg1) {\n+        return await(redisAPI.incrby(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response incrbyfloat(String arg0, String arg1) {\n+        return await(redisAPI.incrbyfloat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response info(List<String> args) {\n+        return await(redisAPI.info(args));\n+    }\n+\n+    @Override\n+    public Response keys(String arg0) {\n+        return await(redisAPI.keys(arg0));\n+    }\n+\n+    @Override\n+    public Response lastsave() {\n+        return await(redisAPI.lastsave());\n+    }\n+\n+    @Override\n+    public Response latency(List<String> args) {\n+        return await(redisAPI.latency(args));\n+    }\n+\n+    @Override\n+    public Response lindex(String arg0, String arg1) {\n+        return await(redisAPI.lindex(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response linsert(String arg0, String arg1, String arg2, String arg3) {\n+        return await(redisAPI.linsert(arg0, arg1, arg2, arg3));\n+    }\n+\n+    @Override\n+    public Response llen(String arg0) {\n+        return await(redisAPI.llen(arg0));\n+    }\n+\n+    @Override\n+    public Response lolwut(List<String> args) {\n+        return await(redisAPI.lolwut(args));\n+    }\n+\n+    @Override\n+    public Response lpop(String arg0) {\n+        return await(redisAPI.lpop(arg0));\n+    }\n+\n+    @Override\n+    public Response lpush(List<String> args) {\n+        return await(redisAPI.lpush(args));\n+    }\n+\n+    @Override\n+    public Response lpushx(List<String> args) {\n+        return await(redisAPI.lpushx(args));\n+    }\n+\n+    @Override\n+    public Response lrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response lrem(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lrem(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response lset(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.lset(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response ltrim(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.ltrim(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response memory(List<String> args) {\n+        return await(redisAPI.memory(args));\n+    }\n+\n+    @Override\n+    public Response mget(List<String> args) {\n+        return await(redisAPI.mget(args));\n+    }\n+\n+    @Override\n+    public Response migrate(List<String> args) {\n+        return await(redisAPI.migrate(args));\n+    }\n+\n+    @Override\n+    public Response module(List<String> args) {\n+        return await(redisAPI.module(args));\n+    }\n+\n+    @Override\n+    public Response monitor() {\n+        return await(redisAPI.monitor());\n+    }\n+\n+    @Override\n+    public Response move(String arg0, String arg1) {\n+        return await(redisAPI.move(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response mset(List<String> args) {\n+        return await(redisAPI.mset(args));\n+    }\n+\n+    @Override\n+    public Response msetnx(List<String> args) {\n+        return await(redisAPI.msetnx(args));\n+    }\n+\n+    @Override\n+    public Response multi() {\n+        return await(redisAPI.multi());\n+    }\n+\n+    @Override\n+    public Response object(List<String> args) {\n+        return await(redisAPI.object(args));\n+    }\n+\n+    @Override\n+    public Response persist(String arg0) {\n+        return await(redisAPI.persist(arg0));\n+    }\n+\n+    @Override\n+    public Response pexpire(String arg0, String arg1) {\n+        return await(redisAPI.pexpire(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pexpireat(String arg0, String arg1) {\n+        return await(redisAPI.pexpireat(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pfadd(List<String> args) {\n+        return await(redisAPI.pfadd(args));\n+    }\n+\n+    @Override\n+    public Response pfcount(List<String> args) {\n+        return await(redisAPI.pfcount(args));\n+    }\n+\n+    @Override\n+    public Response pfdebug(List<String> args) {\n+        return await(redisAPI.pfdebug(args));\n+    }\n+\n+    @Override\n+    public Response pfmerge(List<String> args) {\n+        return await(redisAPI.pfmerge(args));\n+    }\n+\n+    @Override\n+    public Response pfselftest() {\n+        return await(redisAPI.pfselftest());\n+    }\n+\n+    @Override\n+    public Response ping(List<String> args) {\n+        return await(redisAPI.ping(args));\n+    }\n+\n+    @Override\n+    public Response post(List<String> args) {\n+        return await(redisAPI.post(args));\n+    }\n+\n+    @Override\n+    public Response psetex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.psetex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response psubscribe(List<String> args) {\n+        return await(redisAPI.psubscribe(args));\n+    }\n+\n+    @Override\n+    public Response psync(String arg0, String arg1) {\n+        return await(redisAPI.psync(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pttl(String arg0) {\n+        return await(redisAPI.pttl(arg0));\n+    }\n+\n+    @Override\n+    public Response publish(String arg0, String arg1) {\n+        return await(redisAPI.publish(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response pubsub(List<String> args) {\n+        return await(redisAPI.pubsub(args));\n+    }\n+\n+    @Override\n+    public Response punsubscribe(List<String> args) {\n+        return await(redisAPI.punsubscribe(args));\n+    }\n+\n+    @Override\n+    public Response randomkey() {\n+        return await(redisAPI.randomkey());\n+    }\n+\n+    @Override\n+    public Response readonly() {\n+        return await(redisAPI.readonly());\n+    }\n+\n+    @Override\n+    public Response readwrite() {\n+        return await(redisAPI.readwrite());\n+    }\n+\n+    @Override\n+    public Response rename(String arg0, String arg1) {\n+        return await(redisAPI.rename(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response renamenx(String arg0, String arg1) {\n+        return await(redisAPI.renamenx(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response replconf(List<String> args) {\n+        return await(redisAPI.replconf(args));\n+    }\n+\n+    @Override\n+    public Response replicaof(String arg0, String arg1) {\n+        return await(redisAPI.replicaof(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response restore(List<String> args) {\n+        return await(redisAPI.restore(args));\n+    }\n+\n+    @Override\n+    public Response restoreAsking(List<String> args) {\n+        return await(redisAPI.restoreAsking(args));\n+    }\n+\n+    @Override\n+    public Response role() {\n+        return await(redisAPI.role());\n+    }\n+\n+    @Override\n+    public Response rpop(String arg0) {\n+        return await(redisAPI.rpop(arg0));\n+    }\n+\n+    @Override\n+    public Response rpoplpush(String arg0, String arg1) {\n+        return await(redisAPI.rpoplpush(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response rpush(List<String> args) {\n+        return await(redisAPI.rpush(args));\n+    }\n+\n+    @Override\n+    public Response rpushx(List<String> args) {\n+        return await(redisAPI.rpushx(args));\n+    }\n+\n+    @Override\n+    public Response sadd(List<String> args) {\n+        return await(redisAPI.sadd(args));\n+    }\n+\n+    @Override\n+    public Response save() {\n+        return await(redisAPI.save());\n+    }\n+\n+    @Override\n+    public Response scan(List<String> args) {\n+        return await(redisAPI.scan(args));\n+    }\n+\n+    @Override\n+    public Response scard(String arg0) {\n+        return await(redisAPI.scard(arg0));\n+    }\n+\n+    @Override\n+    public Response script(List<String> args) {\n+        return await(redisAPI.script(args));\n+    }\n+\n+    @Override\n+    public Response sdiff(List<String> args) {\n+        return await(redisAPI.sdiff(args));\n+    }\n+\n+    @Override\n+    public Response sdiffstore(List<String> args) {\n+        return await(redisAPI.sdiffstore(args));\n+    }\n+\n+    @Override\n+    public Response select(String arg0) {\n+        return await(redisAPI.select(arg0));\n+    }\n+\n+    @Override\n+    public Response set(List<String> args) {\n+        return await(redisAPI.set(args));\n+    }\n+\n+    @Override\n+    public Response setbit(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setbit(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response setex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response setnx(String arg0, String arg1) {\n+        return await(redisAPI.setnx(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response setrange(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.setrange(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response shutdown(List<String> args) {\n+        return await(redisAPI.shutdown(args));\n+    }\n+\n+    @Override\n+    public Response sinter(List<String> args) {\n+        return await(redisAPI.sinter(args));\n+    }\n+\n+    @Override\n+    public Response sinterstore(List<String> args) {\n+        return await(redisAPI.sinterstore(args));\n+    }\n+\n+    @Override\n+    public Response sismember(String arg0, String arg1) {\n+        return await(redisAPI.sismember(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response slaveof(String arg0, String arg1) {\n+        return await(redisAPI.slaveof(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response slowlog(List<String> args) {\n+        return await(redisAPI.slowlog(args));\n+    }\n+\n+    @Override\n+    public Response smembers(String arg0) {\n+        return await(redisAPI.smembers(arg0));\n+    }\n+\n+    @Override\n+    public Response smove(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.smove(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response sort(List<String> args) {\n+        return await(redisAPI.sort(args));\n+    }\n+\n+    @Override\n+    public Response spop(List<String> args) {\n+        return await(redisAPI.spop(args));\n+    }\n+\n+    @Override\n+    public Response srandmember(List<String> args) {\n+        return await(redisAPI.srandmember(args));\n+    }\n+\n+    @Override\n+    public Response srem(List<String> args) {\n+        return await(redisAPI.srem(args));\n+    }\n+\n+    @Override\n+    public Response sscan(List<String> args) {\n+        return await(redisAPI.sscan(args));\n+    }\n+\n+    @Override\n+    public Response strlen(String arg0) {\n+        return await(redisAPI.strlen(arg0));\n+    }\n+\n+    @Override\n+    public Response subscribe(List<String> args) {\n+        return await(redisAPI.subscribe(args));\n+    }\n+\n+    @Override\n+    public Response substr(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.substr(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response sunion(List<String> args) {\n+        return await(redisAPI.sunion(args));\n+    }\n+\n+    @Override\n+    public Response sunionstore(List<String> args) {\n+        return await(redisAPI.sunionstore(args));\n+    }\n+\n+    @Override\n+    public Response swapdb(String arg0, String arg1) {\n+        return await(redisAPI.swapdb(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response sync() {\n+        return await(redisAPI.sync());\n+    }\n+\n+    @Override\n+    public Response time() {\n+        return await(redisAPI.time());\n+    }\n+\n+    @Override\n+    public Response touch(List<String> args) {\n+        return await(redisAPI.touch(args));\n+    }\n+\n+    @Override\n+    public Response ttl(String arg0) {\n+        return await(redisAPI.ttl(arg0));\n+    }\n+\n+    @Override\n+    public Response type(String arg0) {\n+        return await(redisAPI.type(arg0));\n+    }\n+\n+    @Override\n+    public Response unlink(List<String> args) {\n+        return await(redisAPI.unlink(args));\n+    }\n+\n+    @Override\n+    public Response unsubscribe(List<String> args) {\n+        return await(redisAPI.unsubscribe(args));\n+    }\n+\n+    @Override\n+    public Response unwatch() {\n+        return await(redisAPI.unwatch());\n+    }\n+\n+    @Override\n+    public Response wait(String arg0, String arg1) {\n+        return await(redisAPI.wait(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response watch(List<String> args) {\n+        return await(redisAPI.watch(args));\n+    }\n+\n+    @Override\n+    public Response xack(List<String> args) {\n+        return await(redisAPI.xack(args));\n+    }\n+\n+    @Override\n+    public Response xadd(List<String> args) {\n+        return await(redisAPI.xadd(args));\n+    }\n+\n+    @Override\n+    public Response xclaim(List<String> args) {\n+        return await(redisAPI.xclaim(args));\n+    }\n+\n+    @Override\n+    public Response xdel(List<String> args) {\n+        return await(redisAPI.xdel(args));\n+    }\n+\n+    @Override\n+    public Response xgroup(List<String> args) {\n+        return await(redisAPI.xgroup(args));\n+    }\n+\n+    @Override\n+    public Response xinfo(List<String> args) {\n+        return await(redisAPI.xinfo(args));\n+    }\n+\n+    @Override\n+    public Response xlen(String arg0) {\n+        return await(redisAPI.xlen(arg0));\n+    }\n+\n+    @Override\n+    public Response xpending(List<String> args) {\n+        return await(redisAPI.xpending(args));\n+    }\n+\n+    @Override\n+    public Response xrange(List<String> args) {\n+        return await(redisAPI.xrange(args));\n+    }\n+\n+    @Override\n+    public Response xread(List<String> args) {\n+        return await(redisAPI.xread(args));\n+    }\n+\n+    @Override\n+    public Response xreadgroup(List<String> args) {\n+        return await(redisAPI.xreadgroup(args));\n+    }\n+\n+    @Override\n+    public Response xrevrange(List<String> args) {\n+        return await(redisAPI.xrevrange(args));\n+    }\n+\n+    @Override\n+    public Response xsetid(String arg0, String arg1) {\n+        return await(redisAPI.xsetid(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response xtrim(List<String> args) {\n+        return await(redisAPI.xtrim(args));\n+    }\n+\n+    @Override\n+    public Response zadd(List<String> args) {\n+        return await(redisAPI.zadd(args));\n+    }\n+\n+    @Override\n+    public Response zcard(String arg0) {\n+        return await(redisAPI.zcard(arg0));\n+    }\n+\n+    @Override\n+    public Response zcount(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zcount(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zincrby(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zincrby(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zinterstore(List<String> args) {\n+        return await(redisAPI.zinterstore(args));\n+    }\n+\n+    @Override\n+    public Response zlexcount(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zlexcount(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zpopmax(List<String> args) {\n+        return await(redisAPI.zpopmax(args));\n+    }\n+\n+    @Override\n+    public Response zpopmin(List<String> args) {\n+        return await(redisAPI.zpopmin(args));\n+    }\n+\n+    @Override\n+    public Response zrange(List<String> args) {\n+        return await(redisAPI.zrange(args));\n+    }\n+\n+    @Override\n+    public Response zrangebylex(List<String> args) {\n+        return await(redisAPI.zrangebylex(args));\n+    }\n+\n+    @Override\n+    public Response zrangebyscore(List<String> args) {\n+        return await(redisAPI.zrangebyscore(args));\n+    }\n+\n+    @Override\n+    public Response zrank(String arg0, String arg1) {\n+        return await(redisAPI.zrank(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zrem(List<String> args) {\n+        return await(redisAPI.zrem(args));\n+    }\n+\n+    @Override\n+    public Response zremrangebylex(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebylex(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zremrangebyrank(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebyrank(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zremrangebyscore(String arg0, String arg1, String arg2) {\n+        return await(redisAPI.zremrangebyscore(arg0, arg1, arg2));\n+    }\n+\n+    @Override\n+    public Response zrevrange(List<String> args) {\n+        return await(redisAPI.zrevrange(args));\n+    }\n+\n+    @Override\n+    public Response zrevrangebylex(List<String> args) {\n+        return await(redisAPI.zrevrangebylex(args));\n+    }\n+\n+    @Override\n+    public Response zrevrangebyscore(List<String> args) {\n+        return await(redisAPI.zrevrangebyscore(args));\n+    }\n+\n+    @Override\n+    public Response zrevrank(String arg0, String arg1) {\n+        return await(redisAPI.zrevrank(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zscan(List<String> args) {\n+        return await(redisAPI.zscan(args));\n+    }\n+\n+    @Override\n+    public Response zscore(String arg0, String arg1) {\n+        return await(redisAPI.zscore(arg0, arg1));\n+    }\n+\n+    @Override\n+    public Response zunionstore(List<String> args) {\n+        return await(redisAPI.zunionstore(args));\n+    }\n+\n+    private Response await(Uni<io.vertx.mutiny.redis.client.Response> mutinyResponse) {\n+        try {\n+            return mutinyResponse.subscribeAsCompletionStage()\n+                    .toCompletableFuture()\n+                    .get(timeout, SECONDS)\n+                    .getDelegate();\n+        } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+            throw new RuntimeException(e);", "originalCommit": "001ceb768e9675f74db784985b3c1158561ab23c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxODM3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r444318376", "bodyText": "I guess it is not needed anymore with this #9370 (comment) suggestion.", "author": "machi1990", "createdAt": "2020-06-23T15:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1NTcxNw=="}], "type": "inlineReview"}, {"oid": "9650b0d0a202057bdf1713eea2ae4e937dbeeb6a", "url": "https://github.com/quarkusio/quarkus/commit/9650b0d0a202057bdf1713eea2ae4e937dbeeb6a", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-06-23T16:08:03Z", "type": "forcePushed"}, {"oid": "4685feef64bdf495521bff8b26e4af6282d5b6ab", "url": "https://github.com/quarkusio/quarkus/commit/4685feef64bdf495521bff8b26e4af6282d5b6ab", "message": "feat: add a redis extension\n\nCreates a vertx redis extension that provides different flavours of RedisAPI.\n\nfixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-07-01T15:09:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3MDk0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449470941", "bodyText": "This is very minor but alphabetical order FTW :).", "author": "gsmet", "createdAt": "2020-07-03T09:07:59Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/Feature.java", "diffHunk": "@@ -114,7 +114,7 @@\n     VERTX_WEB,\n     VERTX_GRAPHQL,\n     WEBJARS_LOCATOR,\n-    ;\n+    REDIS_CLIENT;", "originalCommit": "4685feef64bdf495521bff8b26e4af6282d5b6ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3MjI3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449472273", "bodyText": "I don't know how it was done for the others but if it's not API, it should probably go in the runtime. subpackage.", "author": "gsmet", "createdAt": "2020-07-03T09:10:35Z", "path": "extensions/redis-client/deployment/src/main/java/io/quarkus/redis/client/deployment/RedisClientProcessor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package io.quarkus.redis.client.deployment;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.Feature;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.smallrye.health.deployment.spi.HealthBuildItem;\n+import io.vertx.redis.client.impl.types.BulkType;\n+\n+public class RedisClientProcessor {\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(Feature.REDIS_CLIENT);\n+    }\n+\n+    @BuildStep\n+    ExtensionSslNativeSupportBuildItem activateSslNativeSupport() {\n+        return new ExtensionSslNativeSupportBuildItem(Feature.REDIS_CLIENT.getName());\n+    }\n+\n+    @BuildStep\n+    AdditionalBeanBuildItem registerAPIsProducer() {\n+        return AdditionalBeanBuildItem.unremovableOf(\"io.quarkus.redis.client.runtime.RedisAPIProducer\");\n+    }\n+\n+    @BuildStep\n+    HealthBuildItem addHealthCheck(RedisBuildTimeConfig buildTimeConfig) {\n+        return new HealthBuildItem(\"io.quarkus.redis.client.health.RedisHealthCheck\", buildTimeConfig.healthEnabled);", "originalCommit": "4685feef64bdf495521bff8b26e4af6282d5b6ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3Mjg1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449472853", "bodyText": "I think it should be something like Connect to Redis in either imperative or reactive style to be consistent with the other descriptions on code.quarkus.io.", "author": "gsmet", "createdAt": "2020-07-03T09:11:34Z", "path": "extensions/redis-client/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,65 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-redis-client-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+\n+    <artifactId>quarkus-redis-client</artifactId>\n+\n+    <name>Quarkus - Redis Client - Runtime</name>\n+    <description>Synchronous and Reactive Redis client</description>", "originalCommit": "4685feef64bdf495521bff8b26e4af6282d5b6ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ3MzYzMw==", "url": "https://github.com/quarkusio/quarkus/pull/9370#discussion_r449473633", "bodyText": "I would use 10s here for the documentation to be clearer.", "author": "gsmet", "createdAt": "2020-07-03T09:13:01Z", "path": "extensions/redis-client/runtime/src/main/java/io/quarkus/redis/client/runtime/RedisConfig.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package io.quarkus.redis.client.runtime;\n+\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.vertx.redis.client.RedisClientType;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class RedisConfig {\n+\n+    /**\n+     * The redis password\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The redis hosts\n+     */\n+    @ConfigItem(defaultValue = \"localhost:6379\")\n+    public Optional<Set<InetSocketAddress>> hosts;\n+\n+    /**\n+     * The redis database\n+     */\n+    @ConfigItem\n+    public int database;\n+\n+    /**\n+     * The maximum delay to wait before a blocking command to redis server times out\n+     */\n+    @ConfigItem(defaultValue = \"10\")", "originalCommit": "4685feef64bdf495521bff8b26e4af6282d5b6ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "495e0172b2545bc2b00ff6dd91aa8c327d95d5c6", "url": "https://github.com/quarkusio/quarkus/commit/495e0172b2545bc2b00ff6dd91aa8c327d95d5c6", "message": "feat: add a redis extension\n\nCreates a redis-client extension that provides different flavours of\nredis clients:\nImperative and Reactive client.\n\nFixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-07-03T14:34:24Z", "type": "forcePushed"}, {"oid": "76a6fcbf267f6e2646266420135166b13ab5aee0", "url": "https://github.com/quarkusio/quarkus/commit/76a6fcbf267f6e2646266420135166b13ab5aee0", "message": "feat: add a redis extension\n\nCreates a redis-client extension that provides different flavours of\nredis clients:\nImperative and Reactive client.\n\nFixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-07-04T20:15:55Z", "type": "commit"}, {"oid": "76a6fcbf267f6e2646266420135166b13ab5aee0", "url": "https://github.com/quarkusio/quarkus/commit/76a6fcbf267f6e2646266420135166b13ab5aee0", "message": "feat: add a redis extension\n\nCreates a redis-client extension that provides different flavours of\nredis clients:\nImperative and Reactive client.\n\nFixes https://github.com/quarkusio/quarkus/issues/4453", "committedDate": "2020-07-04T20:15:55Z", "type": "forcePushed"}]}