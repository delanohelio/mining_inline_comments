{"pr_number": 6411, "pr_title": "The big ClassLoader change", "pr_createdAt": "2020-01-06T05:27:54Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/6411", "timeline": [{"oid": "876fad788de08dbfabbe45d82799af74a9f758bb", "url": "https://github.com/quarkusio/quarkus/commit/876fad788de08dbfabbe45d82799af74a9f758bb", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-07T00:20:02Z", "type": "forcePushed"}, {"oid": "995beea1e20a130be357587ed4644d78323f82a7", "url": "https://github.com/quarkusio/quarkus/commit/995beea1e20a130be357587ed4644d78323f82a7", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-07T00:30:35Z", "type": "forcePushed"}, {"oid": "3e02fa7642d90a17947f94ecc215d3db398df1aa", "url": "https://github.com/quarkusio/quarkus/commit/3e02fa7642d90a17947f94ecc215d3db398df1aa", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-07T02:46:44Z", "type": "forcePushed"}, {"oid": "48c6c2045a76b86135099b5d068906374da28437", "url": "https://github.com/quarkusio/quarkus/commit/48c6c2045a76b86135099b5d068906374da28437", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-07T03:17:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY2ODk1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r363668955", "bodyText": "Just curious, any reason not to do it the nio way with Files.newInputStream(configFile)?", "author": "aloubyansky", "createdAt": "2020-01-07T09:52:09Z", "path": "core/deployment/src/main/java/io/quarkus/runner/bootstrap/GenerateConfigTask.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package io.quarkus.runner.bootstrap;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.builder.BuildChainBuilder;\n+import io.quarkus.builder.BuildExecutionBuilder;\n+import io.quarkus.builder.BuildResult;\n+import io.quarkus.deployment.builditem.ArchiveRootBuildItem;\n+import io.quarkus.deployment.builditem.ConfigDescriptionBuildItem;\n+import io.quarkus.deployment.util.FileUtil;\n+\n+/**\n+ * This phase generates an example configuration file\n+ *\n+ * @author Stuart Douglas\n+ */\n+public class GenerateConfigTask {\n+\n+    private static final Logger log = Logger.getLogger(GenerateConfigTask.class);\n+\n+    private final Path configFile;\n+\n+    public GenerateConfigTask(Path configFile) {\n+        this.configFile = configFile;\n+    }\n+\n+    public Path run(CuratedApplication application) {\n+        //first lets look for some config, as it is not on the current class path\n+        //and we need to load it to run the build process\n+        try {\n+            AugmentAction augmentAction = new AugmentAction(application, Collections.emptyList());\n+            BuildResult buildResult = augmentAction.runCustomAction(new Consumer<BuildChainBuilder>() {\n+                @Override\n+                public void accept(BuildChainBuilder chainBuilder) {\n+                    chainBuilder.addFinal(ConfigDescriptionBuildItem.class);\n+                    chainBuilder.addInitial(ArchiveRootBuildItem.class);\n+                }\n+            }, new Consumer<BuildExecutionBuilder>() {\n+                @Override\n+                public void accept(BuildExecutionBuilder buildExecutionBuilder) {\n+                    try {\n+                        buildExecutionBuilder.produce(new ArchiveRootBuildItem(Files.createTempDirectory(\"empty\")));\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            });\n+\n+            List<ConfigDescriptionBuildItem> descriptions = buildResult.consumeMulti(ConfigDescriptionBuildItem.class);\n+            Collections.sort(descriptions);\n+\n+            String existing = \"\";\n+            if (Files.exists(configFile)) {\n+                try (InputStream in = new FileInputStream(configFile.toFile())) {", "originalCommit": "723c74cc261169fe32d33b7299de6b036e2d06f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY2OTMyMA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r363669320", "bodyText": "Same here. Or it looks like alternatively you could do Files.newBufferedWriter and write directly there instead of sb using newLine().", "author": "aloubyansky", "createdAt": "2020-01-07T09:52:59Z", "path": "core/deployment/src/main/java/io/quarkus/runner/bootstrap/GenerateConfigTask.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package io.quarkus.runner.bootstrap;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.builder.BuildChainBuilder;\n+import io.quarkus.builder.BuildExecutionBuilder;\n+import io.quarkus.builder.BuildResult;\n+import io.quarkus.deployment.builditem.ArchiveRootBuildItem;\n+import io.quarkus.deployment.builditem.ConfigDescriptionBuildItem;\n+import io.quarkus.deployment.util.FileUtil;\n+\n+/**\n+ * This phase generates an example configuration file\n+ *\n+ * @author Stuart Douglas\n+ */\n+public class GenerateConfigTask {\n+\n+    private static final Logger log = Logger.getLogger(GenerateConfigTask.class);\n+\n+    private final Path configFile;\n+\n+    public GenerateConfigTask(Path configFile) {\n+        this.configFile = configFile;\n+    }\n+\n+    public Path run(CuratedApplication application) {\n+        //first lets look for some config, as it is not on the current class path\n+        //and we need to load it to run the build process\n+        try {\n+            AugmentAction augmentAction = new AugmentAction(application, Collections.emptyList());\n+            BuildResult buildResult = augmentAction.runCustomAction(new Consumer<BuildChainBuilder>() {\n+                @Override\n+                public void accept(BuildChainBuilder chainBuilder) {\n+                    chainBuilder.addFinal(ConfigDescriptionBuildItem.class);\n+                    chainBuilder.addInitial(ArchiveRootBuildItem.class);\n+                }\n+            }, new Consumer<BuildExecutionBuilder>() {\n+                @Override\n+                public void accept(BuildExecutionBuilder buildExecutionBuilder) {\n+                    try {\n+                        buildExecutionBuilder.produce(new ArchiveRootBuildItem(Files.createTempDirectory(\"empty\")));\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            });\n+\n+            List<ConfigDescriptionBuildItem> descriptions = buildResult.consumeMulti(ConfigDescriptionBuildItem.class);\n+            Collections.sort(descriptions);\n+\n+            String existing = \"\";\n+            if (Files.exists(configFile)) {\n+                try (InputStream in = new FileInputStream(configFile.toFile())) {\n+                    existing = new String(FileUtil.readFileContents(in), StandardCharsets.UTF_8);\n+                }\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (ConfigDescriptionBuildItem i : descriptions) {\n+                //we don't want to add these if they already exist\n+                //either in commended or uncommented form\n+                if (existing.contains(\"\\n\" + i.getPropertyName() + \"=\") ||\n+                        existing.contains(\"\\n#\" + i.getPropertyName() + \"=\")) {\n+                    continue;\n+                }\n+\n+                sb.append(\"\\n#\\n\");\n+                sb.append(formatDocs(i.getDocs()));\n+                sb.append(\"\\n#\\n#\");\n+                sb.append(i.getPropertyName() + \"=\" + i.getDefaultValue());\n+                sb.append(\"\\n\");\n+            }\n+\n+            try (FileOutputStream out = new FileOutputStream(configFile.toFile(), true)) {", "originalCommit": "723c74cc261169fe32d33b7299de6b036e2d06f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NzMwMA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r363847300", "bodyText": "Not that it should be an issue, but I assume this is not needed since QuarkusBootstrap.builder(appClassLocation).setMode(QuarkusBootstrap.Mode.TEST); is being used later", "author": "geoand", "createdAt": "2020-01-07T16:56:04Z", "path": "test-framework/junit5/src/main/java/io/quarkus/test/junit/QuarkusTestExtension.java", "diffHunk": "@@ -3,220 +3,90 @@\n import static io.quarkus.test.common.PathTestHelper.getAppClassLocation;\n import static io.quarkus.test.common.PathTestHelper.getTestClassesLocation;\n \n-import java.io.BufferedReader;\n import java.io.Closeable;\n import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.Collections;\n import java.util.concurrent.LinkedBlockingDeque;\n-import java.util.function.BiFunction;\n import java.util.function.Consumer;\n import java.util.function.Predicate;\n \n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.AfterAllCallback;\n import org.junit.jupiter.api.extension.AfterEachCallback;\n import org.junit.jupiter.api.extension.BeforeAllCallback;\n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestInstanceFactory;\n import org.junit.jupiter.api.extension.TestInstanceFactoryContext;\n import org.junit.jupiter.api.extension.TestInstantiationException;\n-import org.junit.platform.commons.JUnitException;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n import org.opentest4j.TestAbortedException;\n \n-import io.quarkus.bootstrap.BootstrapClassLoaderFactory;\n-import io.quarkus.bootstrap.BootstrapException;\n-import io.quarkus.bootstrap.DefineClassVisibleURLClassLoader;\n-import io.quarkus.bootstrap.util.IoUtils;\n-import io.quarkus.bootstrap.util.PropertyUtils;\n+import io.quarkus.bootstrap.app.AdditionalDependency;\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.bootstrap.app.QuarkusBootstrap;\n import io.quarkus.builder.BuildChainBuilder;\n import io.quarkus.builder.BuildContext;\n import io.quarkus.builder.BuildStep;\n-import io.quarkus.deployment.ClassOutput;\n-import io.quarkus.deployment.QuarkusClassWriter;\n import io.quarkus.deployment.builditem.TestAnnotationBuildItem;\n import io.quarkus.deployment.builditem.TestClassPredicateBuildItem;\n-import io.quarkus.deployment.util.IoUtil;\n-import io.quarkus.runner.RuntimeRunner;\n-import io.quarkus.runner.TransformerTarget;\n-import io.quarkus.runtime.LaunchMode;\n-import io.quarkus.test.common.NativeImageLauncher;\n+import io.quarkus.deployment.proxy.ProxyConfiguration;\n+import io.quarkus.deployment.proxy.ProxyFactory;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.runner.bootstrap.AugmentAction;\n+import io.quarkus.runner.bootstrap.RunningQuarkusApplication;\n+import io.quarkus.test.common.DefineClassVisibleClassLoader;\n import io.quarkus.test.common.PathTestHelper;\n import io.quarkus.test.common.PropertyTestUtil;\n import io.quarkus.test.common.RestAssuredURLManager;\n-import io.quarkus.test.common.TestInjectionManager;\n-import io.quarkus.test.common.TestInstantiator;\n import io.quarkus.test.common.TestResourceManager;\n import io.quarkus.test.common.TestScopeManager;\n import io.quarkus.test.common.http.TestHTTPResourceManager;\n \n+//todo: share common core with QuarkusUnitTest\n public class QuarkusTestExtension\n-        implements BeforeEachCallback, AfterEachCallback, TestInstanceFactory, BeforeAllCallback {\n+        implements BeforeEachCallback, AfterEachCallback, TestInstanceFactory, BeforeAllCallback, InvocationInterceptor,\n+        AfterAllCallback {\n \n-    private URLClassLoader appCl;\n-    private ClassLoader originalCl;\n     private static boolean failedBoot;\n \n-    /**\n-     * As part of the test run we need to create files in the test-classes directory\n-     *\n-     * We attempt to clean these up with a shutdown hook, but if the processes is killed (e.g. hitting the red\n-     * IDE button) it can leave these files behind which interfere with subsequent runs.\n-     *\n-     * To fix this we create a file that contains the names of all the files we have created, and at the start of a new\n-     * run we remove them if this file exists.\n-     */\n-    private static final String CREATED_FILES = \"CREATED_FILES.txt\";\n-    private final RestAssuredURLManager restAssuredURLManager = new RestAssuredURLManager(false);\n+    private static Class<?> actualTestClass;\n+    private static Object actualTestInstance;\n+    private static ClassLoader originalCl;\n+    private static RunningQuarkusApplication runningQuarkusApplication;\n+    private static Path testClassLocation;\n+    private static boolean allowPackagePrivateMethods;\n \n     private ExtensionState doJavaStart(ExtensionContext context, TestResourceManager testResourceManager) {\n \n-        final LinkedBlockingDeque<Runnable> shutdownTasks = new LinkedBlockingDeque<>();\n+        try {\n+            final LinkedBlockingDeque<Runnable> shutdownTasks = new LinkedBlockingDeque<>();\n \n-        Path appClassLocation = getAppClassLocation(context.getRequiredTestClass());\n+            Path appClassLocation = getAppClassLocation(context.getRequiredTestClass());\n \n-        appCl = createQuarkusBuildClassLoader(appClassLocation);\n-        originalCl = setCCL(appCl);\n+            QuarkusBootstrap.builder(appClassLocation);", "originalCommit": "723c74cc261169fe32d33b7299de6b036e2d06f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2OTg5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r363969896", "bodyText": "+100 for this doc!\nIt would be wonderful to have this document completed so people that haven't followed the ClassLoader system design discussions can have a good reference point and perhaps even be able to contribute somewhat to the review process", "author": "geoand", "createdAt": "2020-01-07T21:54:35Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,23 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference", "originalCommit": "723c74cc261169fe32d33b7299de6b036e2d06f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c8f2f82b994f83ade934cfef2a34c5a2e63a349", "url": "https://github.com/quarkusio/quarkus/commit/1c8f2f82b994f83ade934cfef2a34c5a2e63a349", "message": "More fixes", "committedDate": "2020-01-07T22:21:27Z", "type": "forcePushed"}, {"oid": "956aa03a208245b5aa7d5526449a052e3f1f07e0", "url": "https://github.com/quarkusio/quarkus/commit/956aa03a208245b5aa7d5526449a052e3f1f07e0", "message": "Move interfaces to augment into bootstrap", "committedDate": "2020-01-08T01:59:43Z", "type": "forcePushed"}, {"oid": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "url": "https://github.com/quarkusio/quarkus/commit/296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "message": "More fixes", "committedDate": "2020-01-08T10:33:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE2Nzc4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364167783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            (which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n          \n          \n            \n            (which is why it cannot load application classes that may be hot deployed). Its parent is the base ClassLoader, and it is", "author": "gsmet", "createdAt": "2020-01-08T10:42:04Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE2Nzg5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364167897", "bodyText": "I think we should have an explanation of what that means.", "author": "gsmet", "createdAt": "2020-01-08T10:42:22Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3ODExMQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364178111", "bodyText": "The explanation exists, but it's further down, so I agree it should be moved up here", "author": "geoand", "createdAt": "2020-01-08T11:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE2Nzg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDI0MTk5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364241995", "bodyText": "Can you also please add an explanation why this classloader needs to be transformer safe? Is this need driven by the fact that we need to transform dependencies in some cases?", "author": "geoand", "createdAt": "2020-01-08T13:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE2Nzg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE2ODc4NA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364168784", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n          \n          \n            \n            This can load all application classes, its parent is the Augment ClassLoader so it can also load all deployment classes.", "author": "gsmet", "createdAt": "2020-01-08T10:44:32Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE2ODk2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364168966", "bodyText": "Oh, you explain it there.", "author": "gsmet", "createdAt": "2020-01-08T10:45:03Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3Mjk4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364172983", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            (which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader.\n          \n          \n            \n            (which is why it cannot load application classes that may be hot deployed). Its parent is the base ClassLoader.", "author": "gsmet", "createdAt": "2020-01-08T10:54:36Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.\n+\n+Base Runtime ClassLoader::\n+\n+This loads all the runtime extension dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader.", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3MzMxMg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364173312", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate\n          \n          \n            \n            This also means that the runtime version can be linked against a different set of dependencies, e.g. the Hibernate ORM", "author": "gsmet", "createdAt": "2020-01-08T10:55:25Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.\n+\n+Base Runtime ClassLoader::\n+\n+This loads all the runtime extension dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader.\n+\n+This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this\n+transformation is no longer possible). This means that only transformers registered in the first application start\n+will take effect, however as these transformers are expected to be idempotent this should not cause problems.\n+\n+This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set\n+values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications\n+to behave more like a production application (production applications are isolated in that they run in a whole new JVM).\n+\n+This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3MzQ0NA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364173444", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This ClassLoader is used to load the application classes and other hot deployable resources. It's parent it the base runtime\n          \n          \n            \n            This ClassLoader is used to load the application classes and other hot deployable resources. Its parent is the base runtime", "author": "gsmet", "createdAt": "2020-01-08T10:55:45Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.\n+\n+Base Runtime ClassLoader::\n+\n+This loads all the runtime extension dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader.\n+\n+This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this\n+transformation is no longer possible). This means that only transformers registered in the first application start\n+will take effect, however as these transformers are expected to be idempotent this should not cause problems.\n+\n+This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set\n+values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications\n+to behave more like a production application (production applications are isolated in that they run in a whole new JVM).\n+\n+This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate\n+version used at deployment time might want to include ByteBuddy, while the version used at runtime does not.\n+\n+Runtime Class Loader::\n+\n+This ClassLoader is used to load the application classes and other hot deployable resources. It's parent it the base runtime", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3MzYyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364173629", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The runtime ClassLoader is always isolated. This means that it will have it's own copies of almost every class from the\n          \n          \n            \n            The runtime ClassLoader is always isolated. This means that it will have its own copies of almost every class from the", "author": "gsmet", "createdAt": "2020-01-08T10:56:14Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.\n+\n+Base Runtime ClassLoader::\n+\n+This loads all the runtime extension dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader.\n+\n+This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this\n+transformation is no longer possible). This means that only transformers registered in the first application start\n+will take effect, however as these transformers are expected to be idempotent this should not cause problems.\n+\n+This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set\n+values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications\n+to behave more like a production application (production applications are isolated in that they run in a whole new JVM).\n+\n+This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate\n+version used at deployment time might want to include ByteBuddy, while the version used at runtime does not.\n+\n+Runtime Class Loader::\n+\n+This ClassLoader is used to load the application classes and other hot deployable resources. It's parent it the base runtime\n+ClassLoader, and it is recreated when the application is restarted.\n+\n+\n+== Isolated ClassLoaders\n+\n+The runtime ClassLoader is always isolated. This means that it will have it's own copies of almost every class from the", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3Mzk0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364173942", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            mark a dependency as parent first then all of it's dependencies must also be parent first,\n          \n          \n            \n            mark a dependency as parent first then all of its dependencies must also be parent first,", "author": "gsmet", "createdAt": "2020-01-08T10:57:00Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.\n+\n+Base Runtime ClassLoader::\n+\n+This loads all the runtime extension dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader.\n+\n+This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this\n+transformation is no longer possible). This means that only transformers registered in the first application start\n+will take effect, however as these transformers are expected to be idempotent this should not cause problems.\n+\n+This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set\n+values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications\n+to behave more like a production application (production applications are isolated in that they run in a whole new JVM).\n+\n+This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate\n+version used at deployment time might want to include ByteBuddy, while the version used at runtime does not.\n+\n+Runtime Class Loader::\n+\n+This ClassLoader is used to load the application classes and other hot deployable resources. It's parent it the base runtime\n+ClassLoader, and it is recreated when the application is restarted.\n+\n+\n+== Isolated ClassLoaders\n+\n+The runtime ClassLoader is always isolated. This means that it will have it's own copies of almost every class from the\n+resolved dependency list. The exception to this are:\n+\n+- JDK classes\n+- Classes from artifacts that extensions have marked as parent first (more on this later).\n+\n+=== Parent First Dependencies\n+\n+There are some classes that should not be loaded in an isolated manner, but that should always be loaded by the system\n+ClassLoader (or whatever ClassLoader is responsible for bootstrapping Quarkus). Most extensions do not need to worry about\n+this, however there are a few cases where this is necessary:\n+\n+- Some logging related classes, as logging must be loaded by the system ClassLoader\n+- Quarkus bootstrap itself\n+\n+If this is required it can be configured in the `quarkus-bootstrap-maven-plugin`. Note that if you\n+mark a dependency as parent first then all of it's dependencies must also be parent first,", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE4MTQwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364181401", "bodyText": "I think this needs to have more attention drawn to it. Extension authors would probably need to know more about this", "author": "geoand", "createdAt": "2020-01-08T11:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3Mzk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3NDQ3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364174472", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            not compatible with Quarkus. To deal with this this extensions can specify artifacts that should never be loaded. This is\n          \n          \n            \n            not compatible with Quarkus. To deal with this, extensions can specify artifacts that should never be loaded. This is", "author": "gsmet", "createdAt": "2020-01-08T10:58:18Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.\n+\n+Base Runtime ClassLoader::\n+\n+This loads all the runtime extension dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader.\n+\n+This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this\n+transformation is no longer possible). This means that only transformers registered in the first application start\n+will take effect, however as these transformers are expected to be idempotent this should not cause problems.\n+\n+This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set\n+values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications\n+to behave more like a production application (production applications are isolated in that they run in a whole new JVM).\n+\n+This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate\n+version used at deployment time might want to include ByteBuddy, while the version used at runtime does not.\n+\n+Runtime Class Loader::\n+\n+This ClassLoader is used to load the application classes and other hot deployable resources. It's parent it the base runtime\n+ClassLoader, and it is recreated when the application is restarted.\n+\n+\n+== Isolated ClassLoaders\n+\n+The runtime ClassLoader is always isolated. This means that it will have it's own copies of almost every class from the\n+resolved dependency list. The exception to this are:\n+\n+- JDK classes\n+- Classes from artifacts that extensions have marked as parent first (more on this later).\n+\n+=== Parent First Dependencies\n+\n+There are some classes that should not be loaded in an isolated manner, but that should always be loaded by the system\n+ClassLoader (or whatever ClassLoader is responsible for bootstrapping Quarkus). Most extensions do not need to worry about\n+this, however there are a few cases where this is necessary:\n+\n+- Some logging related classes, as logging must be loaded by the system ClassLoader\n+- Quarkus bootstrap itself\n+\n+If this is required it can be configured in the `quarkus-bootstrap-maven-plugin`. Note that if you\n+mark a dependency as parent first then all of it's dependencies must also be parent first,\n+or a `LinkageError` can occur.\n+\n+[source,xml]\n+----\n+<plugin>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+    <configuration>\n+        <parentFirstArtifacts>\n+            <parentFirstArtifact>io.quarkus:quarkus-bootstrap-core</parentFirstArtifact>\n+            <parentFirstArtifact>io.quarkus:quarkus-development-mode-spi</parentFirstArtifact>\n+            <parentFirstArtifact>org.jboss.logmanager:jboss-logmanager-embedded</parentFirstArtifact>\n+            <parentFirstArtifact>org.jboss.logging:jboss-logging</parentFirstArtifact>\n+            <parentFirstArtifact>org.ow2.asm:asm</parentFirstArtifact>\n+        </parentFirstArtifacts>\n+    </configuration>\n+</plugin>\n+----\n+\n+=== Banned Dependencies\n+\n+There are some dependencies that we can be sure we do not want. This generally happens when a dependency has had a name\n+change (e.g. smallrye-config changing groups from `org.smallrye` to `org.smallrye.config`, the `javax` -> `jakarta` rename).\n+This can cause problems, as if these artifacts end up in the dependency tree out of date classes can be loaded that are\n+not compatible with Quarkus. To deal with this this extensions can specify artifacts that should never be loaded. This is", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3NDczNg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364174736", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This should only be done if the extension depends on a never version of these artifacts. If the extension does not bring\n          \n          \n            \n            This should only be done if the extension depends on a newer version of these artifacts. If the extension does not bring", "author": "gsmet", "createdAt": "2020-01-08T10:58:59Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.\n+\n+Base Runtime ClassLoader::\n+\n+This loads all the runtime extension dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader.\n+\n+This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this\n+transformation is no longer possible). This means that only transformers registered in the first application start\n+will take effect, however as these transformers are expected to be idempotent this should not cause problems.\n+\n+This ClassLoader is isolated from the Augment and Deployment ClassLoaders. This means that it is not possible to set\n+values in a static field in the deployment side, and expect to read it at runtime. This allows dev and test applications\n+to behave more like a production application (production applications are isolated in that they run in a whole new JVM).\n+\n+This also means that the runtime version can be linked against a different set of dependencies, e.g. the hibernate\n+version used at deployment time might want to include ByteBuddy, while the version used at runtime does not.\n+\n+Runtime Class Loader::\n+\n+This ClassLoader is used to load the application classes and other hot deployable resources. It's parent it the base runtime\n+ClassLoader, and it is recreated when the application is restarted.\n+\n+\n+== Isolated ClassLoaders\n+\n+The runtime ClassLoader is always isolated. This means that it will have it's own copies of almost every class from the\n+resolved dependency list. The exception to this are:\n+\n+- JDK classes\n+- Classes from artifacts that extensions have marked as parent first (more on this later).\n+\n+=== Parent First Dependencies\n+\n+There are some classes that should not be loaded in an isolated manner, but that should always be loaded by the system\n+ClassLoader (or whatever ClassLoader is responsible for bootstrapping Quarkus). Most extensions do not need to worry about\n+this, however there are a few cases where this is necessary:\n+\n+- Some logging related classes, as logging must be loaded by the system ClassLoader\n+- Quarkus bootstrap itself\n+\n+If this is required it can be configured in the `quarkus-bootstrap-maven-plugin`. Note that if you\n+mark a dependency as parent first then all of it's dependencies must also be parent first,\n+or a `LinkageError` can occur.\n+\n+[source,xml]\n+----\n+<plugin>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+    <configuration>\n+        <parentFirstArtifacts>\n+            <parentFirstArtifact>io.quarkus:quarkus-bootstrap-core</parentFirstArtifact>\n+            <parentFirstArtifact>io.quarkus:quarkus-development-mode-spi</parentFirstArtifact>\n+            <parentFirstArtifact>org.jboss.logmanager:jboss-logmanager-embedded</parentFirstArtifact>\n+            <parentFirstArtifact>org.jboss.logging:jboss-logging</parentFirstArtifact>\n+            <parentFirstArtifact>org.ow2.asm:asm</parentFirstArtifact>\n+        </parentFirstArtifacts>\n+    </configuration>\n+</plugin>\n+----\n+\n+=== Banned Dependencies\n+\n+There are some dependencies that we can be sure we do not want. This generally happens when a dependency has had a name\n+change (e.g. smallrye-config changing groups from `org.smallrye` to `org.smallrye.config`, the `javax` -> `jakarta` rename).\n+This can cause problems, as if these artifacts end up in the dependency tree out of date classes can be loaded that are\n+not compatible with Quarkus. To deal with this this extensions can specify artifacts that should never be loaded. This is\n+done by modifying the `quarkus-bootstrap-maven-plugin` config in the pom (which generates the `quarkus-extension.properties`\n+file). Simply add an `excludedArtifacts` section as shown below:\n+\n+[source,xml]\n+----\n+<plugin>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-bootstrap-maven-plugin</artifactId>\n+    <configuration>\n+        <excludedArtifacts>\n+            <excludedArtifact>io.smallrye:smallrye-config</excludedArtifact>\n+            <excludedArtifact>javax.enterprise:cdi-api</excludedArtifact>\n+        </excludedArtifacts>\n+    </configuration>\n+</plugin>\n+----\n+\n+This should only be done if the extension depends on a never version of these artifacts. If the extension does not bring", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3NzQ2NA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364177464", "bodyText": "as well as other user dependencies is mentioned here for Base Runtime Classloader, however Augment ClassLoader also mentions as well as other user dependencies.\nThis seems kind of confusing, but I assume that the former is done at build time and the latter at runtime? Maybe a note should be made about this?", "author": "geoand", "createdAt": "2020-01-08T11:05:54Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.\n+\n+Base Runtime ClassLoader::\n+\n+This loads all the runtime extension dependencies, as well as other user dependencies. It does not load the", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDE3ODk1NA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r364178954", "bodyText": "Could we have an example of what sort of transformations are meant here?", "author": "geoand", "createdAt": "2020-01-08T11:10:08Z", "path": "docs/src/main/asciidoc/class-loading-reference.adoc", "diffHunk": "@@ -0,0 +1,163 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Class Loading Reference\n+\n+include::./attributes.adoc[]\n+\n+This document explains the Quarkus class loading architecture. It is intended for extension\n+authors and advanced users who want to understand exactly how Quarkus works.\n+\n+The Quarkus class loading architecture is slightly different depending on the mode that\n+the application is run in. When running a production application everything is loaded\n+in the system ClassLoader, so it is a completely flat class path. This also applies to\n+native image mode which does not really support multiple ClassLoaders, and is based on\n+a normal production Quarkus application.\n+\n+For all other use cases (e.g. tests, dev mode, and building the application) Quarkus\n+uses the class loading architecture outlined here.\n+\n+== Bootstrapping Quarkus\n+\n+All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This\n+class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus\n+application. The end result of this process is a `CuratedApplication`, which contains all the class loading information\n+for the application.\n+\n+The `CuratedApplication` can then be used to create an `AugmentAction` instance, which can create production application\n+and start/restart runtime ones. This application instance exists within an isolated ClassLoader, it is not necessary\n+to have any of the Quarkus deployment classes on the class path as the curate process will resolve them for you.\n+\n+This bootstrap process should be the same no matter how Quarkus is launched, just with different parameters passed in.\n+\n+=== Current Run Modes\n+\n+At the moment we have the following use cases for bootstrapping Quarkus:\n+\n+- Maven creating production application\n+- Maven dev mode\n+- Gradle creating a production application\n+- Gradle dev mode\n+- QuarkusTest (Maven, Gradle and IDE)\n+- QuarkusUnitTest (Maven, Gradle and IDE)\n+- QuarkusDevModeTest (Maven, Gradle and IDE)\n+- Arquillian Adaptor\n+\n+One of the goals of this refactor is to have all these different run modes boot Quarkus in fundamentally the same way.\n+\n+== ClassLoader Implementations\n+\n+Quarkus has the following ClassLoaders:\n+\n+Base ClassLoader:: \n+\n+This is usually the normal JVM System ClassLoader. In some environments such as Maven it may be different. This ClassLoader\n+is used to load the bootstrap classes, and other ClassLoader instances will delegate the loading of JDK classes to it.\n+\n+Augment ClassLoader::\n+\n+This loads all the `-deployment` artifacts and their dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader, and it is\n+transformer safe.\n+\n+At present this can be configured to delegate to the Base ClassLoader, however the plan is for this option to go away and\n+always have this as an isolated ClassLoader. Making this an isolated ClassLoader is complicated as it means that all\n+the builder classes are isolated, which means that use cases that want to customise the build chains are slightly more complex.\n+\n+Deployment ClassLoader::\n+\n+This can load all application classes, it's parent is the Augment ClassLoader so it can also load all deployment classes.\n+\n+This ClassLoader is non-persistent, it will be re-created when the application is started, and is isolated. This ClassLoader\n+is the context ClassLoader that is used when running the build steps. It is transformer safe so loading application classes\n+will not prevent them from being transformed.\n+\n+Base Runtime ClassLoader::\n+\n+This loads all the runtime extension dependencies, as well as other user dependencies. It does not load the\n+application root or any hot deployed code. This ClassLoader is persistent, even if the application restarts it will remain\n+(which is why it cannot load application classes that may be hot deployed). It's parent is the base ClassLoader.\n+\n+This loads code that is not hot-reloadable, but it does support transformation (although once the class is loaded this\n+transformation is no longer possible). This means that only transformers registered in the first application start\n+will take effect, however as these transformers are expected to be idempotent this should not cause problems.", "originalCommit": "296a2b6229dc8163b2b8f7d5827d4fc2c12a02e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3a398d3467137f09b93d6d937306ea296c9ef399", "url": "https://github.com/quarkusio/quarkus/commit/3a398d3467137f09b93d6d937306ea296c9ef399", "message": "Native test fixes", "committedDate": "2020-01-08T22:56:20Z", "type": "forcePushed"}, {"oid": "fc4ac1500431d3bb6e0e7292f3a5a57e745c13cc", "url": "https://github.com/quarkusio/quarkus/commit/fc4ac1500431d3bb6e0e7292f3a5a57e745c13cc", "message": "Native test fixes", "committedDate": "2020-01-08T23:24:01Z", "type": "forcePushed"}, {"oid": "4a1dddcf7d71c64bce5688ac1c6c1a43f527a1cf", "url": "https://github.com/quarkusio/quarkus/commit/4a1dddcf7d71c64bce5688ac1c6c1a43f527a1cf", "message": "Arquillian container fixes for the TCK", "committedDate": "2020-01-09T01:33:12Z", "type": "forcePushed"}, {"oid": "3b419e9955c88b1a6777c04d65037319b6175171", "url": "https://github.com/quarkusio/quarkus/commit/3b419e9955c88b1a6777c04d65037319b6175171", "message": "Arquillian container fixes for the TCK", "committedDate": "2020-01-09T04:23:34Z", "type": "forcePushed"}, {"oid": "38c199c6c9147bab421b0987d1c51d729c1472b2", "url": "https://github.com/quarkusio/quarkus/commit/38c199c6c9147bab421b0987d1c51d729c1472b2", "message": "Add -e", "committedDate": "2020-01-09T08:32:57Z", "type": "forcePushed"}, {"oid": "05ca1201971debd689bf74535a3eb41df0827481", "url": "https://github.com/quarkusio/quarkus/commit/05ca1201971debd689bf74535a3eb41df0827481", "message": "More fixes", "committedDate": "2020-01-09T15:27:09Z", "type": "forcePushed"}, {"oid": "47ae5f5e22b69c5ef9435352d5052f5db58384ef", "url": "https://github.com/quarkusio/quarkus/commit/47ae5f5e22b69c5ef9435352d5052f5db58384ef", "message": "More MP/Arquillian fixes", "committedDate": "2020-01-10T01:10:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE0NDAyMg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365144022", "bodyText": "Is the request context no longer active by default for tests, then?", "author": "FroMage", "createdAt": "2020-01-10T09:34:25Z", "path": "integration-tests/hibernate-orm-panache/src/test/java/io/quarkus/it/panache/PanacheFunctionalityTest.java", "diffHunk": "@@ -45,6 +55,7 @@ public void testPanacheSerialisation() {\n \n     @DisabledOnNativeImage\n     @Test\n+    @ActivateRequestContext", "originalCommit": "9507fcdfeab36ab1fbe654c7349e3a53db30f602", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE1Nzc3NA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365157774", "bodyText": "ah, good catch. I need to fix this, the test scope setup is being run from outside the scope of the deployment so it is not actually activating the scope.", "author": "stuartwdouglas", "createdAt": "2020-01-10T10:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE0NDAyMg=="}], "type": "inlineReview"}, {"oid": "cebea96d85f71c6d8a8b220229e48992c3c67ed2", "url": "https://github.com/quarkusio/quarkus/commit/cebea96d85f71c6d8a8b220229e48992c3c67ed2", "message": "minor", "committedDate": "2020-01-13T01:58:37Z", "type": "forcePushed"}, {"oid": "92f80fe8f854a059a867a496bad4285060e7376c", "url": "https://github.com/quarkusio/quarkus/commit/92f80fe8f854a059a867a496bad4285060e7376c", "message": "Make sure class loaders are closed", "committedDate": "2020-01-13T09:16:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NTYxMw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365785613", "bodyText": "I guess it'd be safer to close it in finally in case runAugment throws a runtime exception. In general though, I don't see CuratedApplication being closed anywhere else which looks like a major issue. Did I overlook something?\nI get that depending on the mode it may have different lifecycles. But it'd be great to improve the design around it to make it more clear.\nWe do need to test prove it on Windows which is more sensitive to closing resources.", "author": "aloubyansky", "createdAt": "2020-01-13T12:48:30Z", "path": "core/deployment/src/main/java/io/quarkus/runner/bootstrap/AugmentActionImpl.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package io.quarkus.runner.bootstrap;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import io.quarkus.bootstrap.app.AdditionalDependency;\n+import io.quarkus.bootstrap.app.ArtifactResult;\n+import io.quarkus.bootstrap.app.AugmentAction;\n+import io.quarkus.bootstrap.app.AugmentResult;\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.bootstrap.app.QuarkusBootstrap;\n+import io.quarkus.bootstrap.classloading.QuarkusClassLoader;\n+import io.quarkus.builder.BuildChain;\n+import io.quarkus.builder.BuildChainBuilder;\n+import io.quarkus.builder.BuildExecutionBuilder;\n+import io.quarkus.builder.BuildResult;\n+import io.quarkus.builder.item.BuildItem;\n+import io.quarkus.deployment.ExtensionLoader;\n+import io.quarkus.deployment.QuarkusAugmentor;\n+import io.quarkus.deployment.builditem.ApplicationClassNameBuildItem;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.ConfigDescriptionBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedClassBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.pkg.builditem.ArtifactResultBuildItem;\n+import io.quarkus.deployment.pkg.builditem.JarBuildItem;\n+import io.quarkus.deployment.pkg.builditem.NativeImageBuildItem;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.configuration.ProfileManager;\n+\n+/**\n+ * The augmentation task that produces the application.\n+ */\n+public class AugmentActionImpl implements AugmentAction {\n+\n+    private final QuarkusBootstrap quarkusBootstrap;\n+    private final CuratedApplication curatedApplication;\n+    private final LaunchMode launchMode;\n+    private final List<Consumer<BuildChainBuilder>> chainCustomizers;\n+\n+    /**\n+     * A map that is shared between all re-runs of the same augment instance. This is\n+     * only really relevant in dev mode, however it is present in all modes for consistency.\n+     * \n+     */\n+    private final Map<Class<?>, Object> reloadContext = new ConcurrentHashMap<>();\n+\n+    public AugmentActionImpl(CuratedApplication curatedApplication) {\n+        this(curatedApplication, Collections.emptyList());\n+    }\n+\n+    public AugmentActionImpl(CuratedApplication curatedApplication, List<Consumer<BuildChainBuilder>> chainCustomizers) {\n+        this.quarkusBootstrap = curatedApplication.getQuarkusBootstrap();\n+        this.curatedApplication = curatedApplication;\n+        this.chainCustomizers = chainCustomizers;\n+        this.launchMode = quarkusBootstrap.getMode() == QuarkusBootstrap.Mode.PROD ? LaunchMode.NORMAL\n+                : quarkusBootstrap.getMode() == QuarkusBootstrap.Mode.TEST ? LaunchMode.TEST : LaunchMode.DEVELOPMENT;\n+    }\n+\n+    @Override\n+    public AugmentResult createProductionApplication() {\n+        if (launchMode != LaunchMode.NORMAL) {\n+            throw new IllegalStateException(\"Can only create a production application when using NORMAL launch mode\");\n+        }\n+        BuildResult result = runAugment(true, Collections.emptySet(), ArtifactResultBuildItem.class);\n+        JarBuildItem jarBuildItem = result.consumeOptional(JarBuildItem.class);\n+        NativeImageBuildItem nativeImageBuildItem = result.consumeOptional(NativeImageBuildItem.class);\n+        curatedApplication.close();", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NjIzNw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365786237", "bodyText": "Ah, sorry, I see RunningQuarkusApplicationImpl.", "author": "aloubyansky", "createdAt": "2020-01-13T12:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NTYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA2MzAzOA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366063038", "bodyText": "There were some gradle failures on windows that were due to this (the app not being closed). The gradle tests create a temp dir and the test fails if the dir cannot be released.", "author": "stuartwdouglas", "createdAt": "2020-01-13T22:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NTYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4Nzc3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365787772", "bodyText": "augmentAction looks like a leftover. Can be removed?", "author": "aloubyansky", "createdAt": "2020-01-13T12:53:58Z", "path": "core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package io.quarkus.runner.bootstrap;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+import org.jboss.logging.Logger;\n+import org.objectweb.asm.ClassVisitor;\n+\n+import io.quarkus.bootstrap.app.AdditionalDependency;\n+import io.quarkus.bootstrap.app.AugmentAction;\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.bootstrap.app.RunningQuarkusApplication;\n+import io.quarkus.bootstrap.app.StartupAction;\n+import io.quarkus.bootstrap.classloading.ClassPathElement;\n+import io.quarkus.bootstrap.classloading.MemoryClassPathElement;\n+import io.quarkus.bootstrap.classloading.QuarkusClassLoader;\n+import io.quarkus.builder.BuildResult;\n+import io.quarkus.deployment.builditem.ApplicationClassNameBuildItem;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.DeploymentClassLoaderBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedClassBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.configuration.RunTimeConfigurationGenerator;\n+\n+public class StartupActionImpl implements StartupAction {\n+\n+    private static final Logger log = Logger.getLogger(StartupActionImpl.class);\n+\n+    static final String DEBUG_CLASSES_DIR = System.getProperty(\"quarkus.debug.generated-classes-dir\");\n+\n+    private final CuratedApplication curatedApplication;\n+    private final AugmentAction augmentAction;\n+    private final BuildResult buildResult;\n+\n+    public StartupActionImpl(CuratedApplication curatedApplication, AugmentAction augmentAction, BuildResult buildResult) {\n+        this.curatedApplication = curatedApplication;\n+        this.augmentAction = augmentAction;", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwOTU5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365809596", "bodyText": "This method looks equivalent to i.getArtifact().getKey().", "author": "aloubyansky", "createdAt": "2020-01-13T13:43:01Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/app/CuratedApplication.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package io.quarkus.bootstrap.app;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+import io.quarkus.bootstrap.classloading.ClassPathElement;\n+import io.quarkus.bootstrap.classloading.DirectoryClassPathElement;\n+import io.quarkus.bootstrap.classloading.JarClassPathElement;\n+import io.quarkus.bootstrap.classloading.MemoryClassPathElement;\n+import io.quarkus.bootstrap.classloading.QuarkusClassLoader;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.bootstrap.model.AppDependency;\n+import io.quarkus.bootstrap.model.AppModel;\n+import io.quarkus.bootstrap.resolver.AppModelResolver;\n+\n+/**\n+ * The result of the curate step that is done by QuarkusBootstrap.\n+ *\n+ * This is responsible creating all the class loaders used by the application.\n+ *\n+ *\n+ */\n+public class CuratedApplication implements Serializable, Closeable {\n+\n+    private static final String AUGMENTOR = \"io.quarkus.runner.bootstrap.AugmentActionImpl\";\n+\n+    /**\n+     * The class path elements for the various artifacts. These can be used in multiple class loaders\n+     * so this map allows them to be shared.\n+     *\n+     * This should not be used for hot reloadable elements\n+     */\n+    private final Map<AppArtifact, ClassPathElement> augmentationElements = new HashMap<>();\n+\n+    /**\n+     * The augmentation class loader.\n+     */\n+    private volatile QuarkusClassLoader augmentClassLoader;\n+\n+    /**\n+     * The base runtime class loader.\n+     */\n+    private volatile QuarkusClassLoader baseRuntimeClassLoader;\n+\n+    private final QuarkusBootstrap quarkusBootstrap;\n+    private final CurationResult curationResult;\n+    final AppModel appModel;\n+\n+    CuratedApplication(QuarkusBootstrap quarkusBootstrap, CurationResult curationResult) {\n+        this.quarkusBootstrap = quarkusBootstrap;\n+        this.curationResult = curationResult;\n+        this.appModel = curationResult.getAppModel();\n+    }\n+\n+    public AppModel getAppModel() {\n+        return appModel;\n+    }\n+\n+    public QuarkusBootstrap getQuarkusBootstrap() {\n+        return quarkusBootstrap;\n+    }\n+\n+    public boolean hasUpdatedDeps() {\n+        return curationResult.hasUpdatedDeps();\n+    }\n+\n+    public List<AppDependency> getUpdatedDeps() {\n+        return curationResult.getUpdatedDependencies();\n+    }\n+\n+    public Object runInAugmentClassLoader(String consumerName, Map<String, Object> params) {\n+        return runInCl(consumerName, params, getAugmentClassLoader());\n+    }\n+\n+    public Object runInBaseRuntimeClassLoader(String consumerName, Map<String, Object> params) {\n+        return runInCl(consumerName, params, getBaseRuntimeClassLoader());\n+    }\n+\n+    public CurationResult getCurationResult() {\n+        return curationResult;\n+    }\n+\n+    public AugmentAction createAugmentor() {\n+        try {\n+            Class<?> augmentor = getAugmentClassLoader().loadClass(AUGMENTOR);\n+            return (AugmentAction) augmentor.getConstructor(CuratedApplication.class).newInstance(this);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * This creates an augmentor, but uses the supplied class name to customise the build chain.\n+     *\n+     * The class name that is passed in must be the name of an implementation of\n+     * {@code Function<Map<String, Object>, List<Consumer<BuildChainBuilder>>>}\n+     * which is used to generate a list of build chain customisers to control the build.\n+     */\n+    public AugmentAction createAugmentor(String functionName, Map<String, Object> props) {\n+        try {\n+            Class<?> augmentor = getAugmentClassLoader().loadClass(AUGMENTOR);\n+            Function<Object, List<?>> function = (Function<Object, List<?>>) getAugmentClassLoader().loadClass(functionName).newInstance();\n+            List<?> res = function.apply(props);\n+            return (AugmentAction) augmentor.getConstructor(CuratedApplication.class, List.class).newInstance(this, res);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Object runInCl(String consumerName, Map<String, Object> params, QuarkusClassLoader cl) {\n+        ClassLoader old = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(cl);\n+            Class<? extends BiConsumer<CuratedApplication, Map<String, Object>>> clazz = (Class<? extends BiConsumer<CuratedApplication, Map<String, Object>>>) cl\n+                    .loadClass(consumerName);\n+            BiConsumer<CuratedApplication, Map<String, Object>> biConsumer = clazz.newInstance();\n+            biConsumer.accept(this, params);\n+            return biConsumer;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            Thread.currentThread().setContextClassLoader(old);\n+        }\n+    }\n+\n+    private synchronized ClassPathElement getElement(AppArtifact artifact) {\n+        if (!artifact.getType().equals(\"jar\")) {\n+            //avoid the need for this sort of check in multiple places\n+            return ClassPathElement.EMPTY;\n+        }\n+        if (augmentationElements.containsKey(artifact)) {\n+            return augmentationElements.get(artifact);\n+        }\n+        Path path = artifact.getPath();\n+        ClassPathElement element;\n+        if (Files.isDirectory(path)) {\n+            element = new DirectoryClassPathElement(path);\n+        } else {\n+            element = new JarClassPathElement(path);\n+        }\n+        augmentationElements.put(artifact, element);\n+        return element;\n+    }\n+\n+    public synchronized QuarkusClassLoader getAugmentClassLoader() {\n+        if (augmentClassLoader == null) {\n+            //first run, we need to build all the class loaders\n+            QuarkusClassLoader.Builder builder = QuarkusClassLoader.builder(\"Augmentation Class Loader\",\n+                    quarkusBootstrap.getBaseClassLoader(), !quarkusBootstrap.isIsolateDeployment());\n+            //we want a class loader that can load the deployment artifacts and all their dependencies, but not\n+            //any of the runtime artifacts, or user classes\n+            //this will load any deployment artifacts from the parent CL if they are present\n+            Set<AppArtifact> deploymentArtifacts = new HashSet<>();\n+            for (AppDependency i : appModel.getFullDeploymentDeps()) {\n+                AppArtifactKey key = getKey(i);\n+                deploymentArtifacts.add(i.getArtifact());\n+                ClassPathElement element = getElement(i.getArtifact());\n+                builder.addElement(element);\n+                if (appModel.getParentFirstArtifacts().contains(key)) {\n+                    //we always load this from the parent if it is available, as this acts as a bridge between the running\n+                    //app and the dev mode code\n+                    builder.addParentFirstElement(element);\n+                }\n+            }\n+            for (AppDependency userDep : appModel.getUserDependencies()) {\n+                if (!deploymentArtifacts.contains(userDep.getArtifact())) {\n+                    AppArtifactKey key = getKey(userDep);\n+                    ClassPathElement element = getElement(userDep.getArtifact());\n+                    if (appModel.getParentFirstArtifacts().contains(key)) {\n+                        //this mostly happens when building quarkus itself\n+                        builder.addParentFirstElement(element);\n+                    }\n+                    builder.addElement(element);\n+                }\n+            }\n+\n+            for (Path i : quarkusBootstrap.getAdditionalDeploymentArchives()) {\n+                builder.addElement(ClassPathElement.fromPath(i));\n+            }\n+            //now make sure we can't accidentally load other deps from this CL\n+            //only extensions and their dependencies.\n+            //            for (AppDependency userDep : appModel.getUserDependencies()) {\n+            //                if (!deploymentArtifacts.contains(userDep.getArtifact())) {\n+            //                    ClassPathElement element = getElement(userDep.getArtifact());\n+            //                    builder.addBannedElement(element);\n+            //                }\n+            //            }\n+            augmentClassLoader = builder.build();\n+\n+        }\n+        return augmentClassLoader;\n+    }\n+\n+    private AppArtifactKey getKey(AppDependency i) {", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3Mjg0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365872847", "bodyText": "Why not use AppArtifactKey instead?", "author": "aloubyansky", "createdAt": "2020-01-13T15:42:18Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/AppModelGradleResolver.java", "diffHunk": "@@ -228,4 +267,31 @@ private Properties resolveDescriptor(final Path path) {\n         }\n         return rtProps;\n     }\n+\n+    static final class AppKey {", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3Nzg2OA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365877868", "bodyText": "Is bootstrap closed anywhere?", "author": "aloubyansky", "createdAt": "2020-01-13T15:51:05Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/tasks/QuarkusGenerateConfig.java", "diffHunk": "@@ -56,14 +49,18 @@ public void buildQuarkus() {\n         if (name == null || name.isEmpty()) {\n             name = \"application.properties.example\";\n         }\n-\n-        try (CuratedApplicationCreator appCreationContext = CuratedApplicationCreator.builder()\n-                .setWorkDir(getProject().getBuildDir().toPath())\n-                .build()) {\n-            appCreationContext.runTask(new GenerateConfigTask(new File(target, name).toPath()));\n+        try {\n+            CuratedApplication bootstrap = QuarkusBootstrap.builder(getProject().getBuildDir().toPath())", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MzY2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365883662", "bodyText": "That's an interesting one. If it's not needed any more, this whole task is questionable. We shouldn't be resolving the app model here, at a minimum.", "author": "aloubyansky", "createdAt": "2020-01-13T16:00:57Z", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/tasks/QuarkusTestConfig.java", "diffHunk": "@@ -34,7 +33,7 @@ public void setupTest() {\n \n             for (Test test : getProject().getTasks().withType(Test.class)) {\n                 final Map<String, Object> props = test.getSystemProperties();\n-                props.put(BootstrapClassLoaderFactory.PROP_DEPLOYMENT_CP, deploymentCp);\n+                //props.put(BootstrapClassLoaderFactory.PROP_DEPLOYMENT_CP, deploymentCp);", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMDU5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365930599", "bodyText": "IIUIC, here is a potential issue with this change. Gradle and Maven perform version convergence differently. The way it currently is in master we are using the same Gradle resolver for tests and actual builds.\nWith this change it looks like we are going to be using the Maven resolver for the tests and the Gradle one for the actual builds. And the dev mode will always be using the Maven resolver in DevModeMain.", "author": "aloubyansky", "createdAt": "2020-01-13T17:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MzY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA2Njc5MA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366066790", "bodyText": "This is something I am not sure about, and wanted some feedback on.\nIf this is removed we fall back to class path based discovery in the maven resolver (unless there happens to be a pom present as well). The main advantage of this is that it should allow gradle tests to also run in the IDE, which does not work at the moment.\nIf that is not possible then we need to somehow encode the app model into this system prop and restore the old behaviour.", "author": "stuartwdouglas", "createdAt": "2020-01-13T22:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MzY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI3Mjg0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366272845", "bodyText": "While it does not look elegant in this case, we are ending up testing against a different set of deps than the ones used for the build. They should be aligned. Either we use those resolved by Gradle all the way or we use those that we resolve in QuarkusBootstrap.", "author": "aloubyansky", "createdAt": "2020-01-14T10:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MzY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI3MzQ3MA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366273470", "bodyText": "By not looking elegant I refer to the classpath shared through the system property.", "author": "aloubyansky", "createdAt": "2020-01-14T10:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MzY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5MjkyMw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365892923", "bodyText": "I think .setWorkspace(localProject.getWorkspace()) should still be necessary. Otherwise, it won't be able to resolve artifacts that are supposed to be produced by the workspace but haven't actually been installed.", "author": "aloubyansky", "createdAt": "2020-01-13T16:17:59Z", "path": "devtools/maven/src/main/java/io/quarkus/maven/DevMojo.java", "diffHunk": "@@ -528,49 +528,45 @@ void prepare() throws Exception {\n             }\n \n             setKotlinSpecificFlags(devModeContext);\n-\n-            final AppModel appModel;\n-            try {\n-                RepositorySystem repoSystem = DevMojo.this.repoSystem;\n-                final LocalProject localProject;\n-                if (noDeps) {\n-                    localProject = LocalProject.load(outputDirectory.toPath());\n-                    addProject(devModeContext, localProject);\n-                    pomFiles.add(localProject.getDir().resolve(\"pom.xml\"));\n-                } else {\n-                    localProject = LocalProject.loadWorkspace(outputDirectory.toPath());\n-                    for (LocalProject project : localProject.getSelfWithLocalDeps()) {\n-                        if (project.getClassesDir() != null) {\n-                            //if this project also contains Quarkus extensions we do no want to include these in the discovery\n-                            //a bit of an edge case, but if you try and include a sample project with your extension you will\n-                            //run into problems without this\n-                            if (Files.exists(project.getClassesDir().resolve(\"META-INF/quarkus-extension.properties\")) ||\n-                                    Files.exists(project.getClassesDir().resolve(\"META-INF/quarkus-build-steps.list\"))) {\n-                                continue;\n-                            }\n+            RepositorySystem repoSystem = DevMojo.this.repoSystem;\n+            final LocalProject localProject;\n+            if (noDeps) {\n+                localProject = LocalProject.load(outputDirectory.toPath());\n+                addProject(devModeContext, localProject);\n+                pomFiles.add(localProject.getDir().resolve(\"pom.xml\"));\n+            } else {\n+                localProject = LocalProject.loadWorkspace(outputDirectory.toPath());\n+                for (LocalProject project : localProject.getSelfWithLocalDeps()) {\n+                    if (project.getClassesDir() != null) {\n+                        //if this project also contains Quarkus extensions we do no want to include these in the discovery\n+                        //a bit of an edge case, but if you try and include a sample project with your extension you will\n+                        //run into problems without this\n+                        if (Files.exists(project.getClassesDir().resolve(\"META-INF/quarkus-extension.properties\")) ||\n+                                Files.exists(project.getClassesDir().resolve(\"META-INF/quarkus-build-steps.list\"))) {\n+                            continue;\n                         }\n-                        addProject(devModeContext, project);\n-                        pomFiles.add(project.getDir().resolve(\"pom.xml\"));\n                     }\n-                    repoSystem = MavenRepoInitializer.getRepositorySystem(repoSession.isOffline(), localProject.getWorkspace());\n-                }\n-\n-                appModel = new BootstrapAppModelResolver(MavenArtifactResolver.builder()\n-                        .setRepositorySystem(repoSystem)\n-                        .setRepositorySystemSession(repoSession)\n-                        .setRemoteRepositories(repos)\n-                        .setWorkspace(localProject.getWorkspace())\n-                        .build())\n-                                .setDevMode(true)\n-                                .resolveModel(localProject.getAppArtifact());\n-                if (appModel.getAllDependencies().isEmpty()) {\n-                    throw new RuntimeException(\"Unable to resolve application dependencies\");\n+                    addProject(devModeContext, project);\n+                    pomFiles.add(project.getDir().resolve(\"pom.xml\"));\n                 }\n-            } catch (Exception e) {\n-                throw new MojoExecutionException(\"Failed to resolve Quarkus application model\", e);\n+                repoSystem = MavenRepoInitializer.getRepositorySystem(repoSession.isOffline(), localProject.getWorkspace());\n             }\n-            for (AppDependency appDep : appModel.getAllDependencies()) {\n-                addToClassPaths(classPathManifest, devModeContext, appDep.getArtifact().getPath().toFile());\n+            DefaultArtifact bootstrap = new DefaultArtifact(\"io.quarkus\", \"quarkus-development-mode\", \"jar\",\n+                    pluginDef.getVersion());\n+            MavenArtifactResolver mavenArtifactResolver = MavenArtifactResolver.builder()\n+                    .setRepositorySystem(repoSystem)\n+                    .setRepositorySystemSession(repoSession)\n+                    .setRemoteRepositories(repos)", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMDgyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365920829", "bodyText": "Actually, you don't need to set the workspace here since you are not resolving any app deps with this resolver. Which means you can also simply use DevMojo.this.repoSystem and remove repoSystem local variable.", "author": "aloubyansky", "createdAt": "2020-01-13T17:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5MjkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5NzUwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365897505", "bodyText": "I'd simply use mavenArtifactResolver.resolveDependencies( instead. It does delegate to this method after all, it's purely to use softer words :) and possibly create less confusion for those reading the code and not to learn what these method names actually mean.", "author": "aloubyansky", "createdAt": "2020-01-13T16:25:41Z", "path": "devtools/maven/src/main/java/io/quarkus/maven/DevMojo.java", "diffHunk": "@@ -528,49 +528,45 @@ void prepare() throws Exception {\n             }\n \n             setKotlinSpecificFlags(devModeContext);\n-\n-            final AppModel appModel;\n-            try {\n-                RepositorySystem repoSystem = DevMojo.this.repoSystem;\n-                final LocalProject localProject;\n-                if (noDeps) {\n-                    localProject = LocalProject.load(outputDirectory.toPath());\n-                    addProject(devModeContext, localProject);\n-                    pomFiles.add(localProject.getDir().resolve(\"pom.xml\"));\n-                } else {\n-                    localProject = LocalProject.loadWorkspace(outputDirectory.toPath());\n-                    for (LocalProject project : localProject.getSelfWithLocalDeps()) {\n-                        if (project.getClassesDir() != null) {\n-                            //if this project also contains Quarkus extensions we do no want to include these in the discovery\n-                            //a bit of an edge case, but if you try and include a sample project with your extension you will\n-                            //run into problems without this\n-                            if (Files.exists(project.getClassesDir().resolve(\"META-INF/quarkus-extension.properties\")) ||\n-                                    Files.exists(project.getClassesDir().resolve(\"META-INF/quarkus-build-steps.list\"))) {\n-                                continue;\n-                            }\n+            RepositorySystem repoSystem = DevMojo.this.repoSystem;\n+            final LocalProject localProject;\n+            if (noDeps) {\n+                localProject = LocalProject.load(outputDirectory.toPath());\n+                addProject(devModeContext, localProject);\n+                pomFiles.add(localProject.getDir().resolve(\"pom.xml\"));\n+            } else {\n+                localProject = LocalProject.loadWorkspace(outputDirectory.toPath());\n+                for (LocalProject project : localProject.getSelfWithLocalDeps()) {\n+                    if (project.getClassesDir() != null) {\n+                        //if this project also contains Quarkus extensions we do no want to include these in the discovery\n+                        //a bit of an edge case, but if you try and include a sample project with your extension you will\n+                        //run into problems without this\n+                        if (Files.exists(project.getClassesDir().resolve(\"META-INF/quarkus-extension.properties\")) ||\n+                                Files.exists(project.getClassesDir().resolve(\"META-INF/quarkus-build-steps.list\"))) {\n+                            continue;\n                         }\n-                        addProject(devModeContext, project);\n-                        pomFiles.add(project.getDir().resolve(\"pom.xml\"));\n                     }\n-                    repoSystem = MavenRepoInitializer.getRepositorySystem(repoSession.isOffline(), localProject.getWorkspace());\n-                }\n-\n-                appModel = new BootstrapAppModelResolver(MavenArtifactResolver.builder()\n-                        .setRepositorySystem(repoSystem)\n-                        .setRepositorySystemSession(repoSession)\n-                        .setRemoteRepositories(repos)\n-                        .setWorkspace(localProject.getWorkspace())\n-                        .build())\n-                                .setDevMode(true)\n-                                .resolveModel(localProject.getAppArtifact());\n-                if (appModel.getAllDependencies().isEmpty()) {\n-                    throw new RuntimeException(\"Unable to resolve application dependencies\");\n+                    addProject(devModeContext, project);\n+                    pomFiles.add(project.getDir().resolve(\"pom.xml\"));\n                 }\n-            } catch (Exception e) {\n-                throw new MojoExecutionException(\"Failed to resolve Quarkus application model\", e);\n+                repoSystem = MavenRepoInitializer.getRepositorySystem(repoSession.isOffline(), localProject.getWorkspace());\n             }\n-            for (AppDependency appDep : appModel.getAllDependencies()) {\n-                addToClassPaths(classPathManifest, devModeContext, appDep.getArtifact().getPath().toFile());\n+            DefaultArtifact bootstrap = new DefaultArtifact(\"io.quarkus\", \"quarkus-development-mode\", \"jar\",\n+                    pluginDef.getVersion());\n+            MavenArtifactResolver mavenArtifactResolver = MavenArtifactResolver.builder()\n+                    .setRepositorySystem(repoSystem)\n+                    .setRepositorySystemSession(repoSession)\n+                    .setRemoteRepositories(repos)\n+                    .build();\n+            DependencyResult cpRes = mavenArtifactResolver.resolveManagedDependencies(", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwODQxMg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365908412", "bodyText": "context doesn't seem to be closed, btw.", "author": "aloubyansky", "createdAt": "2020-01-13T16:45:23Z", "path": "core/devmode/src/main/java/io/quarkus/dev/DevModeMain.java", "diffHunk": "@@ -43,24 +29,16 @@\n     public static final String DEV_MODE_CONTEXT = \"META-INF/dev-mode-context.dat\";\n     private static final Logger log = Logger.getLogger(DevModeMain.class);\n \n-    private static volatile ClassLoader currentAppClassLoader;\n-    private static volatile URLClassLoader runtimeCl;\n     private final DevModeContext context;\n \n-    private static volatile Closeable runner;\n-    static volatile Throwable deploymentProblem;\n-    static volatile Throwable compileProblem;\n-    static volatile RuntimeUpdatesProcessor runtimeUpdatesProcessor;\n-    private List<HotReplacementSetup> hotReplacement = new ArrayList<>();\n-\n-    private final Map<Class<?>, Object> liveReloadContext = new ConcurrentHashMap<>();\n+    private static volatile CuratedApplication curatedApplication;\n+    private Closeable realCloseable;\n \n     public DevModeMain(DevModeContext context) {\n         this.context = context;\n     }\n \n     public static void main(String... args) throws Exception {\n-        Timing.staticInitStarted();\n \n         try (InputStream devModeCp = DevModeMain.class.getClassLoader().getResourceAsStream(DEV_MODE_CONTEXT)) {\n             DevModeContext context = (DevModeContext) new ObjectInputStream(new DataInputStream(devModeCp)).readObject();", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA2NzQ3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366067471", "bodyText": "context is not Closeable", "author": "stuartwdouglas", "createdAt": "2020-01-13T22:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwODQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI2NDU2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366264565", "bodyText": "Sorry, I meant the instance of DevModeMain.", "author": "aloubyansky", "createdAt": "2020-01-14T10:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwODQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI2NTEzMA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366265130", "bodyText": "instantiated below at line 45", "author": "aloubyansky", "createdAt": "2020-01-14T10:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwODQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2NzAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368867024", "bodyText": "So what about closing the instance of DevModeMain?", "author": "aloubyansky", "createdAt": "2020-01-21T08:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwODQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk1NTczMw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368955733", "bodyText": "I have changed it to be closed after the park, but in practice it would have been cleaned up by the normal shutdown hook anyway.", "author": "stuartwdouglas", "createdAt": "2020-01-21T11:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwODQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMzM3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365923371", "bodyText": "Looks like curatedApplication isn't closed. I would also strongly recommend creating maven artifact resolvers in mojos and passing them to the bootstrap.", "author": "aloubyansky", "createdAt": "2020-01-13T17:13:56Z", "path": "devtools/maven/src/main/java/io/quarkus/maven/GenerateConfigMojo.java", "diffHunk": "@@ -95,48 +91,28 @@ public void execute() throws MojoExecutionException {\n             getLog().info(\"Type of the artifact is POM, skipping generate-config goal\");\n             return;\n         }\n-\n-        final Artifact projectArtifact = project.getArtifact();\n-        final AppArtifact appArtifact = new AppArtifact(projectArtifact.getGroupId(), projectArtifact.getArtifactId(),\n-                projectArtifact.getClassifier(), \"pom\",\n-                projectArtifact.getVersion());\n-        final AppModel appModel;\n-        final BootstrapAppModelResolver modelResolver;\n-        try {\n-            LocalProject localProject = LocalProject.load(project.getBasedir().toPath());\n-            modelResolver = new BootstrapAppModelResolver(\n-                    MavenArtifactResolver.builder()\n-                            .setRepositorySystem(repoSystem)\n-                            .setRepositorySystemSession(repoSession)\n-                            .setRemoteRepositories(repos)\n-                            .setWorkspace(localProject.getWorkspace())\n-                            .build());\n-            appModel = modelResolver.resolveModel(appArtifact);\n-        } catch (Exception e) {\n-            throw new MojoExecutionException(\"Failed to resolve application model \" + appArtifact + \" dependencies\", e);\n-        }\n         if (project.getResources().isEmpty()) {\n             throw new MojoExecutionException(\"No resources directory, cannot create application.properties\");\n         }\n+        try {\n+            CuratedApplication curatedApplication = QuarkusBootstrap.builder(Paths.get(project.getBuild().getOutputDirectory()))", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNjcwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366616701", "bodyText": "how do you do that? This is a seperate JVM.\nOne option could be to resolve the app model in the mojo and serialize the resolved app.", "author": "stuartwdouglas", "createdAt": "2020-01-14T22:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMzM3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMTAzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366621035", "bodyText": "Isn't curated application going to be usually created in the Mojo when running from maven?", "author": "aloubyansky", "createdAt": "2020-01-14T23:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMzM3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMzAzMw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366623033", "bodyText": "Except for dev mode, and tests (which have always done their own resolution). I can make dev mode work by serialising the result into the dev mode runner jar, but there is not much I can do with tests.", "author": "stuartwdouglas", "createdAt": "2020-01-14T23:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyMzM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNDMxNw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r365924317", "bodyText": "Let's create the maven artifact resolver and pass it to the bootstrap here.", "author": "aloubyansky", "createdAt": "2020-01-13T17:16:02Z", "path": "devtools/maven/src/main/java/io/quarkus/maven/NativeImageMojo.java", "diffHunk": "@@ -186,278 +175,157 @@ public NativeImageMojo() {\n     @Override\n     public void execute() throws MojoExecutionException, MojoFailureException {\n \n-        if (project.getPackaging().equals(\"pom\") && appArtifact == null) {\n-            getLog().info(\"Type of the artifact is POM and appArtifact parameter has not been set, skipping native-image goal\");\n+        if (project.getPackaging().equals(\"pom\")) {\n+            getLog().info(\"Type of the artifact is POM, skipping build goal\");\n             return;\n         }\n \n-        final CuratedApplicationCreator.Builder creatorBuilder = CuratedApplicationCreator.builder();\n-\n-        // The runner JAR has not been built yet, so we are going to build it\n-        final AppArtifact appCoords;\n-        AppArtifact managingProject = null;\n-        DefaultArtifact appMvnArtifact = null;\n-        if (appArtifact == null) {\n-            appMvnArtifact = new DefaultArtifact(project.getArtifact().getGroupId(),\n-                    project.getArtifact().getArtifactId(),\n-                    project.getArtifact().getClassifier(),\n-                    project.getArtifact().getArtifactHandler().getExtension(),\n-                    project.getArtifact().getVersion());\n-            appCoords = new AppArtifact(appMvnArtifact.getGroupId(), appMvnArtifact.getArtifactId(),\n-                    appMvnArtifact.getClassifier(), appMvnArtifact.getExtension(),\n-                    appMvnArtifact.getVersion());\n-        } else {\n-            final String[] coordsArr = appArtifact.split(\":\");\n-            if (coordsArr.length < 2 || coordsArr.length > 5) {\n-                throw new MojoExecutionException(\n-                        \"appArtifact expression \" + appArtifact\n-                                + \" does not follow format groupId:artifactId:classifier:type:version\");\n-            }\n-            final String groupId = coordsArr[0];\n-            final String artifactId = coordsArr[1];\n-            String classifier = \"\";\n-            String type = \"jar\";\n-            String version = null;\n-            if (coordsArr.length == 3) {\n-                version = coordsArr[2];\n-            } else if (coordsArr.length > 3) {\n-                classifier = coordsArr[2] == null ? \"\" : coordsArr[2];\n-                type = coordsArr[3] == null ? \"jar\" : coordsArr[3];\n-                if (coordsArr.length > 4) {\n-                    version = coordsArr[4];\n+        boolean clear = false;\n+        try {\n+\n+            final Properties projectProperties = project.getProperties();\n+            final Properties realProperties = new Properties();\n+            for (String name : projectProperties.stringPropertyNames()) {\n+                if (name.startsWith(\"quarkus.\")) {\n+                    realProperties.setProperty(name, projectProperties.getProperty(name));\n                 }\n             }\n-            if (version == null) {\n-                for (Artifact dep : project.getArtifacts()) {\n-                    if (dep.getArtifactId().equals(artifactId)\n-                            && dep.getGroupId().equals(groupId)\n-                            && dep.getClassifier().equals(classifier)\n-                            && dep.getType().equals(type)) {\n-                        appMvnArtifact = new DefaultArtifact(dep.getGroupId(),\n-                                dep.getArtifactId(),\n-                                dep.getClassifier(),\n-                                dep.getArtifactHandler().getExtension(),\n-                                dep.getVersion());\n-                        break;\n+            realProperties.putIfAbsent(\"quarkus.application.name\", project.getArtifactId());\n+            realProperties.putIfAbsent(\"quarkus.application.version\", project.getVersion());\n+\n+            Map<String, String> config = createCustomConfig();\n+            Map<String, String> old = new HashMap<>();\n+            for (Map.Entry<String, String> e : config.entrySet()) {\n+                old.put(e.getKey(), System.getProperty(e.getKey()));\n+                System.setProperty(e.getKey(), e.getValue());\n+            }\n+            try {\n+                CuratedApplication curatedApplication = QuarkusBootstrap.builder(outputDirectory.toPath())", "originalCommit": "92f80fe8f854a059a867a496bad4285060e7376c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA2ODA3OA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366068078", "bodyText": "Ok. All the resolution stuff is what I am least sure about, I think it is likely that some of my changes are not 100% correct, or at the very least not as efficient as they could be.", "author": "stuartwdouglas", "createdAt": "2020-01-13T22:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNDMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA3MDU1OA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366070558", "bodyText": "First, the repo system, session, repos, etc here are properly initialized in the mojo, let's call them the original ones, because in tests and now in bootstrap we are re-creating them (currently, most probably using different versions of the api and impl and there have been lots of issues related to this initialization). Second, avoiding them being re-initialized is going to be a lot more efficient, given that Maven has already cached some artifact and resolution request-related data.", "author": "aloubyansky", "createdAt": "2020-01-13T22:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkyNDMxNw=="}], "type": "inlineReview"}, {"oid": "85fe23fa41bcd6547377bdeb57ae4dcf91d4c24d", "url": "https://github.com/quarkusio/quarkus/commit/85fe23fa41bcd6547377bdeb57ae4dcf91d4c24d", "message": "Allow classes to be loaded after close so shutdown hooks don't pollute the log", "committedDate": "2020-01-14T02:38:35Z", "type": "forcePushed"}, {"oid": "7845f8b2ef7b9a43488b6212959a86c6e21272f7", "url": "https://github.com/quarkusio/quarkus/commit/7845f8b2ef7b9a43488b6212959a86c6e21272f7", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-14T03:35:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI3Njg1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366276851", "bodyText": "Was there a reason to remove appArtifact check here?\nappArtifact is used in the platform integration tests. The reason I allowed pom project and appArtifact combination was that the project was simply pulling all the code from the plugin config and dependencies and didn't produce any JAR.", "author": "aloubyansky", "createdAt": "2020-01-14T11:03:55Z", "path": "devtools/maven/src/main/java/io/quarkus/maven/NativeImageMojo.java", "diffHunk": "@@ -186,278 +176,164 @@ public NativeImageMojo() {\n     @Override\n     public void execute() throws MojoExecutionException, MojoFailureException {\n \n-        if (project.getPackaging().equals(\"pom\") && appArtifact == null) {", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI3NzY3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366277671", "bodyText": "It looks like somebody has removed pom packaging from the platform tests, although the rest of the config remains the same. It could still be just a POM though.", "author": "aloubyansky", "createdAt": "2020-01-14T11:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI3Njg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI4NTA1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366285055", "bodyText": "The issue is that this is not very reliable. Neither pom.properties nor pom.xml are always present. I don't think JARs built with Gradle contain those. You can try a simple test: scan JARs in your local repo and list those that don't include META-INF/maven.\nSo this approach can be used only as \"the best effort\" in cases when nothing else is available.", "author": "aloubyansky", "createdAt": "2020-01-14T11:24:29Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -0,0 +1,512 @@\n+package io.quarkus.bootstrap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.net.URL;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.model.Model;\n+import org.eclipse.aether.repository.RepositoryPolicy;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CurationResult;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.bootstrap.model.AppDependency;\n+import io.quarkus.bootstrap.model.AppModel;\n+import io.quarkus.bootstrap.resolver.AppModelResolver;\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.BootstrapAppModelResolver;\n+import io.quarkus.bootstrap.resolver.maven.MavenArtifactResolver;\n+import io.quarkus.bootstrap.resolver.maven.workspace.LocalProject;\n+import io.quarkus.bootstrap.resolver.maven.workspace.ModelUtils;\n+import io.quarkus.bootstrap.resolver.update.DefaultUpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.DependenciesOrigin;\n+import io.quarkus.bootstrap.resolver.update.UpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdate;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdateNumber;\n+import io.quarkus.bootstrap.util.ZipUtils;\n+\n+/**\n+ * The factory that creates the application dependency model.\n+ *\n+ * This is used to build the application class loader.\n+ */\n+public class BootstrapAppModelFactory {\n+\n+    private static final String QUARKUS = \"quarkus\";\n+    private static final String BOOTSTRAP = \"bootstrap\";\n+    private static final String DEPLOYMENT_CP = \"deployment.cp\";\n+\n+    public static final String CREATOR_APP_GROUP_ID = \"creator.app.groupId\";\n+    public static final String CREATOR_APP_ARTIFACT_ID = \"creator.app.artifactId\";\n+    public static final String CREATOR_APP_CLASSIFIER = \"creator.app.classifier\";\n+    public static final String CREATOR_APP_TYPE = \"creator.app.type\";\n+    public static final String CREATOR_APP_VERSION = \"creator.app.version\";\n+\n+    private static final int CP_CACHE_FORMAT_ID = 2;\n+\n+    private static final Logger log = Logger.getLogger(BootstrapAppModelFactory.class);\n+\n+    public static BootstrapAppModelFactory newInstance() {\n+        return new BootstrapAppModelFactory();\n+    }\n+\n+    private Path appClasses;\n+    private List<Path> appCp = new ArrayList<>(0);\n+    private boolean localProjectsDiscovery;\n+    private Boolean offline;\n+    private boolean enableClasspathCache = false;\n+    private boolean test;\n+    private boolean devMode;\n+    private AppModelResolver bootstrapAppModelResolver;\n+\n+    private VersionUpdateNumber versionUpdateNumber;\n+    private VersionUpdate versionUpdate;\n+    private DependenciesOrigin dependenciesOrigin;\n+    private AppArtifact appArtifact;\n+    private MavenArtifactResolver mavenArtifactResolver;\n+\n+    private BootstrapAppModelFactory() {\n+    }\n+\n+    public BootstrapAppModelFactory setTest(boolean test) {\n+        this.test = test;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDevMode(boolean devMode) {\n+        this.devMode = devMode;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppClasses(Path appClasses) {\n+        this.appClasses = appClasses;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory addToClassPath(Path path) {\n+        this.appCp.add(path);\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setLocalProjectsDiscovery(boolean localProjectsDiscovery) {\n+        this.localProjectsDiscovery = localProjectsDiscovery;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setOffline(Boolean offline) {\n+        this.offline = offline;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setEnableClasspathCache(boolean enable) {\n+        this.enableClasspathCache = enable;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setBootstrapAppModelResolver(AppModelResolver bootstrapAppModelResolver) {\n+        this.bootstrapAppModelResolver = bootstrapAppModelResolver;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdateNumber(VersionUpdateNumber versionUpdateNumber) {\n+        this.versionUpdateNumber = versionUpdateNumber;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdate(VersionUpdate versionUpdate) {\n+        this.versionUpdate = versionUpdate;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDependenciesOrigin(DependenciesOrigin dependenciesOrigin) {\n+        this.dependenciesOrigin = dependenciesOrigin;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppArtifact(AppArtifact appArtifact) {\n+        this.appArtifact = appArtifact;\n+        return this;\n+    }\n+\n+    public AppModelResolver getAppModelResolver() {\n+        try {\n+            if (bootstrapAppModelResolver != null) {\n+                return bootstrapAppModelResolver;\n+            }\n+            if (appClasses == null) {\n+                throw new IllegalArgumentException(\"Application classes path has not been set\");\n+            }\n+            if (!Files.isDirectory(appClasses)) {\n+                final MavenArtifactResolver mvn;\n+                if (mavenArtifactResolver == null) {\n+                    final MavenArtifactResolver.Builder mvnBuilder = MavenArtifactResolver.builder();\n+                    if (offline != null) {\n+                        mvnBuilder.setOffline(offline);\n+                    }\n+                    final LocalProject localProject = localProjectsDiscovery\n+                            ? LocalProject.loadWorkspace(Paths.get(\"\").normalize().toAbsolutePath(), false)\n+                            : null;\n+                    if (localProject != null) {\n+                        mvnBuilder.setWorkspace(localProject.getWorkspace());\n+                    }\n+                    mvn = mvnBuilder.build();\n+                } else {\n+                    mvn = mavenArtifactResolver;\n+                }\n+\n+                return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                        .setTest(test)\n+                        .setDevMode(devMode);\n+            }\n+\n+            final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+                    ? LocalProject.loadWorkspace(appClasses, false)\n+                    : LocalProject.load(appClasses, false);\n+\n+            final MavenArtifactResolver mvn;\n+            if(mavenArtifactResolver == null) {\n+                final MavenArtifactResolver.Builder builder = MavenArtifactResolver.builder();\n+                if (localProject != null) {\n+                    builder.setWorkspace(localProject.getWorkspace());\n+                }\n+                if (offline != null) {\n+                    builder.setOffline(offline);\n+                }\n+                mvn = builder.build();\n+            } else {\n+                mvn = mavenArtifactResolver;\n+            }\n+            return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                    .setTest(test)\n+                    .setDevMode(devMode);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create resolver for \" + appClasses, e);\n+        }\n+    }\n+\n+    public CurationResult resolveAppModel() throws BootstrapException {\n+        if (appClasses == null) {\n+            throw new IllegalArgumentException(\"Application classes path has not been set\");\n+        }\n+\n+        if (!Files.isDirectory(appClasses)) {\n+            return createAppModelForJar(appClasses);\n+        }\n+        //        final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+        //                ? LocalProject.loadWorkspace(appClasses)\n+        //                : LocalProject.load(appClasses);\n+        final LocalProject localProject = LocalProject.loadWorkspace(appClasses, false);\n+        if (localProject == null) {\n+            log.warn(\"Unable to locate maven project, falling back to classpath discovery\");\n+            return doClasspathDiscovery();\n+        }\n+        try {\n+            Path cachedCpPath = null;\n+            if (enableClasspathCache) {\n+                cachedCpPath = resolveCachedCpPath(localProject);\n+                if (Files.exists(cachedCpPath)) {\n+                    try (DataInputStream reader = new DataInputStream(Files.newInputStream(cachedCpPath))) {\n+                        if (reader.readInt() == CP_CACHE_FORMAT_ID) {\n+                            if (reader.readInt() == localProject.getWorkspace().getId()) {\n+                                ObjectInputStream in = new ObjectInputStream(reader);\n+                                return new CurationResult((AppModel) in.readObject(), () -> getAppModelResolver());\n+                            } else {\n+                                debug(\"Cached deployment classpath has expired for %s\", localProject.getAppArtifact());\n+                            }\n+                        } else {\n+                            debug(\"Unsupported classpath cache format in %s for %s\", cachedCpPath,\n+                                    localProject.getAppArtifact());\n+                        }\n+                    } catch (IOException e) {\n+                        log.warn(\"Failed to read deployment classpath cache from \" + cachedCpPath + \" for \"\n+                                + localProject.getAppArtifact(), e);\n+                    }\n+                }\n+            }\n+\n+            AppModelResolver appModelResolver = getAppModelResolver();\n+            CurationResult curationResult = new CurationResult(appModelResolver\n+                    .resolveModel(localProject.getAppArtifact()), new FixedSuppler<>(appModelResolver));\n+            if (cachedCpPath != null) {\n+                Files.createDirectories(cachedCpPath.getParent());\n+                try (DataOutputStream out = new DataOutputStream(Files.newOutputStream(cachedCpPath))) {\n+                    out.writeInt(CP_CACHE_FORMAT_ID);\n+                    out.writeInt(localProject.getWorkspace().getId());\n+                    ObjectOutputStream obj = new ObjectOutputStream(out);\n+                    obj.writeObject(curationResult.getAppModel());\n+                } catch (Exception e) {\n+                    log.warn(\"Failed to write classpath cache\", e);\n+                }\n+            }\n+            return curationResult;\n+        } catch (Exception e) {\n+            throw new BootstrapException(\"Failed to create the application model for \" + localProject.getAppArtifact(), e);\n+        }\n+    }\n+\n+    /**\n+     * If no maven project is around do discovery based on the class path.\n+     *\n+     * This is used to run gradle tests, and allows them to run from both the IDE\n+     * and the gradle test task\n+     *\n+     */\n+    private CurationResult doClasspathDiscovery() {\n+        try {\n+            AppModelResolver resolver = getAppModelResolver();\n+\n+            Set<URL> urls = new HashSet<>();\n+            //this is pretty yuck, but under JDK11 the URLClassLoader trick does not work\n+            Enumeration<URL> manifests = Thread.currentThread().getContextClassLoader().getResources(\"META-INF/MANIFEST.MF\");\n+            while (manifests.hasMoreElements()) {\n+                URL url = manifests.nextElement();\n+                if (url.getProtocol().equals(\"jar\")) {\n+                    String path = url.getPath();\n+                    if (path.startsWith(\"file:\")) {\n+                        path = path.substring(5, path.lastIndexOf('!'));\n+                        urls.add(new File(URLDecoder.decode(path, StandardCharsets.UTF_8.name())).toURI().toURL());\n+                    }\n+                }\n+            }\n+            List<AppDependency> artifacts = new ArrayList<>();\n+            for (URL jarUrl : urls) {\n+                try (JarInputStream file = new JarInputStream(jarUrl.openConnection().getInputStream())) {\n+                    JarEntry entry = file.getNextJarEntry();\n+                    while (entry != null) {\n+                        if (entry.getName().endsWith(\"/pom.properties\") && entry.getName().startsWith(\"META-INF/maven\")) {", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNTU4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366615586", "bodyText": "Thinking about it we don't actually need the artifact names here, the path is what is really important. We just need some way to make sure we don't get jdk jars.", "author": "stuartwdouglas", "createdAt": "2020-01-14T22:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI4NTA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NTIxMA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366985210", "bodyText": "Right, unless we wanted to apply a filter.", "author": "aloubyansky", "createdAt": "2020-01-15T16:45:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI4NTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI4NTU3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366285576", "bodyText": "Looks like this one isn't used anywhere.", "author": "aloubyansky", "createdAt": "2020-01-14T11:25:52Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -0,0 +1,512 @@\n+package io.quarkus.bootstrap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.net.URL;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.model.Model;\n+import org.eclipse.aether.repository.RepositoryPolicy;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CurationResult;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.bootstrap.model.AppDependency;\n+import io.quarkus.bootstrap.model.AppModel;\n+import io.quarkus.bootstrap.resolver.AppModelResolver;\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.BootstrapAppModelResolver;\n+import io.quarkus.bootstrap.resolver.maven.MavenArtifactResolver;\n+import io.quarkus.bootstrap.resolver.maven.workspace.LocalProject;\n+import io.quarkus.bootstrap.resolver.maven.workspace.ModelUtils;\n+import io.quarkus.bootstrap.resolver.update.DefaultUpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.DependenciesOrigin;\n+import io.quarkus.bootstrap.resolver.update.UpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdate;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdateNumber;\n+import io.quarkus.bootstrap.util.ZipUtils;\n+\n+/**\n+ * The factory that creates the application dependency model.\n+ *\n+ * This is used to build the application class loader.\n+ */\n+public class BootstrapAppModelFactory {\n+\n+    private static final String QUARKUS = \"quarkus\";\n+    private static final String BOOTSTRAP = \"bootstrap\";\n+    private static final String DEPLOYMENT_CP = \"deployment.cp\";\n+\n+    public static final String CREATOR_APP_GROUP_ID = \"creator.app.groupId\";\n+    public static final String CREATOR_APP_ARTIFACT_ID = \"creator.app.artifactId\";\n+    public static final String CREATOR_APP_CLASSIFIER = \"creator.app.classifier\";\n+    public static final String CREATOR_APP_TYPE = \"creator.app.type\";\n+    public static final String CREATOR_APP_VERSION = \"creator.app.version\";\n+\n+    private static final int CP_CACHE_FORMAT_ID = 2;\n+\n+    private static final Logger log = Logger.getLogger(BootstrapAppModelFactory.class);\n+\n+    public static BootstrapAppModelFactory newInstance() {\n+        return new BootstrapAppModelFactory();\n+    }\n+\n+    private Path appClasses;\n+    private List<Path> appCp = new ArrayList<>(0);\n+    private boolean localProjectsDiscovery;\n+    private Boolean offline;\n+    private boolean enableClasspathCache = false;\n+    private boolean test;\n+    private boolean devMode;\n+    private AppModelResolver bootstrapAppModelResolver;\n+\n+    private VersionUpdateNumber versionUpdateNumber;\n+    private VersionUpdate versionUpdate;\n+    private DependenciesOrigin dependenciesOrigin;\n+    private AppArtifact appArtifact;\n+    private MavenArtifactResolver mavenArtifactResolver;\n+\n+    private BootstrapAppModelFactory() {\n+    }\n+\n+    public BootstrapAppModelFactory setTest(boolean test) {\n+        this.test = test;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDevMode(boolean devMode) {\n+        this.devMode = devMode;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppClasses(Path appClasses) {\n+        this.appClasses = appClasses;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory addToClassPath(Path path) {\n+        this.appCp.add(path);\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setLocalProjectsDiscovery(boolean localProjectsDiscovery) {\n+        this.localProjectsDiscovery = localProjectsDiscovery;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setOffline(Boolean offline) {\n+        this.offline = offline;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setEnableClasspathCache(boolean enable) {\n+        this.enableClasspathCache = enable;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setBootstrapAppModelResolver(AppModelResolver bootstrapAppModelResolver) {\n+        this.bootstrapAppModelResolver = bootstrapAppModelResolver;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdateNumber(VersionUpdateNumber versionUpdateNumber) {\n+        this.versionUpdateNumber = versionUpdateNumber;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdate(VersionUpdate versionUpdate) {\n+        this.versionUpdate = versionUpdate;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDependenciesOrigin(DependenciesOrigin dependenciesOrigin) {\n+        this.dependenciesOrigin = dependenciesOrigin;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppArtifact(AppArtifact appArtifact) {\n+        this.appArtifact = appArtifact;\n+        return this;\n+    }\n+\n+    public AppModelResolver getAppModelResolver() {\n+        try {\n+            if (bootstrapAppModelResolver != null) {\n+                return bootstrapAppModelResolver;\n+            }\n+            if (appClasses == null) {\n+                throw new IllegalArgumentException(\"Application classes path has not been set\");\n+            }\n+            if (!Files.isDirectory(appClasses)) {\n+                final MavenArtifactResolver mvn;\n+                if (mavenArtifactResolver == null) {\n+                    final MavenArtifactResolver.Builder mvnBuilder = MavenArtifactResolver.builder();\n+                    if (offline != null) {\n+                        mvnBuilder.setOffline(offline);\n+                    }\n+                    final LocalProject localProject = localProjectsDiscovery\n+                            ? LocalProject.loadWorkspace(Paths.get(\"\").normalize().toAbsolutePath(), false)\n+                            : null;\n+                    if (localProject != null) {\n+                        mvnBuilder.setWorkspace(localProject.getWorkspace());\n+                    }\n+                    mvn = mvnBuilder.build();\n+                } else {\n+                    mvn = mavenArtifactResolver;\n+                }\n+\n+                return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                        .setTest(test)\n+                        .setDevMode(devMode);\n+            }\n+\n+            final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+                    ? LocalProject.loadWorkspace(appClasses, false)\n+                    : LocalProject.load(appClasses, false);\n+\n+            final MavenArtifactResolver mvn;\n+            if(mavenArtifactResolver == null) {\n+                final MavenArtifactResolver.Builder builder = MavenArtifactResolver.builder();\n+                if (localProject != null) {\n+                    builder.setWorkspace(localProject.getWorkspace());\n+                }\n+                if (offline != null) {\n+                    builder.setOffline(offline);\n+                }\n+                mvn = builder.build();\n+            } else {\n+                mvn = mavenArtifactResolver;\n+            }\n+            return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                    .setTest(test)\n+                    .setDevMode(devMode);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create resolver for \" + appClasses, e);\n+        }\n+    }\n+\n+    public CurationResult resolveAppModel() throws BootstrapException {\n+        if (appClasses == null) {\n+            throw new IllegalArgumentException(\"Application classes path has not been set\");\n+        }\n+\n+        if (!Files.isDirectory(appClasses)) {\n+            return createAppModelForJar(appClasses);\n+        }\n+        //        final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+        //                ? LocalProject.loadWorkspace(appClasses)\n+        //                : LocalProject.load(appClasses);\n+        final LocalProject localProject = LocalProject.loadWorkspace(appClasses, false);\n+        if (localProject == null) {\n+            log.warn(\"Unable to locate maven project, falling back to classpath discovery\");\n+            return doClasspathDiscovery();\n+        }\n+        try {\n+            Path cachedCpPath = null;\n+            if (enableClasspathCache) {\n+                cachedCpPath = resolveCachedCpPath(localProject);\n+                if (Files.exists(cachedCpPath)) {\n+                    try (DataInputStream reader = new DataInputStream(Files.newInputStream(cachedCpPath))) {\n+                        if (reader.readInt() == CP_CACHE_FORMAT_ID) {\n+                            if (reader.readInt() == localProject.getWorkspace().getId()) {\n+                                ObjectInputStream in = new ObjectInputStream(reader);\n+                                return new CurationResult((AppModel) in.readObject(), () -> getAppModelResolver());\n+                            } else {\n+                                debug(\"Cached deployment classpath has expired for %s\", localProject.getAppArtifact());\n+                            }\n+                        } else {\n+                            debug(\"Unsupported classpath cache format in %s for %s\", cachedCpPath,\n+                                    localProject.getAppArtifact());\n+                        }\n+                    } catch (IOException e) {\n+                        log.warn(\"Failed to read deployment classpath cache from \" + cachedCpPath + \" for \"\n+                                + localProject.getAppArtifact(), e);\n+                    }\n+                }\n+            }\n+\n+            AppModelResolver appModelResolver = getAppModelResolver();\n+            CurationResult curationResult = new CurationResult(appModelResolver\n+                    .resolveModel(localProject.getAppArtifact()), new FixedSuppler<>(appModelResolver));\n+            if (cachedCpPath != null) {\n+                Files.createDirectories(cachedCpPath.getParent());\n+                try (DataOutputStream out = new DataOutputStream(Files.newOutputStream(cachedCpPath))) {\n+                    out.writeInt(CP_CACHE_FORMAT_ID);\n+                    out.writeInt(localProject.getWorkspace().getId());\n+                    ObjectOutputStream obj = new ObjectOutputStream(out);\n+                    obj.writeObject(curationResult.getAppModel());\n+                } catch (Exception e) {\n+                    log.warn(\"Failed to write classpath cache\", e);\n+                }\n+            }\n+            return curationResult;\n+        } catch (Exception e) {\n+            throw new BootstrapException(\"Failed to create the application model for \" + localProject.getAppArtifact(), e);\n+        }\n+    }\n+\n+    /**\n+     * If no maven project is around do discovery based on the class path.\n+     *\n+     * This is used to run gradle tests, and allows them to run from both the IDE\n+     * and the gradle test task\n+     *\n+     */\n+    private CurationResult doClasspathDiscovery() {\n+        try {\n+            AppModelResolver resolver = getAppModelResolver();\n+\n+            Set<URL> urls = new HashSet<>();\n+            //this is pretty yuck, but under JDK11 the URLClassLoader trick does not work\n+            Enumeration<URL> manifests = Thread.currentThread().getContextClassLoader().getResources(\"META-INF/MANIFEST.MF\");\n+            while (manifests.hasMoreElements()) {\n+                URL url = manifests.nextElement();\n+                if (url.getProtocol().equals(\"jar\")) {\n+                    String path = url.getPath();\n+                    if (path.startsWith(\"file:\")) {\n+                        path = path.substring(5, path.lastIndexOf('!'));\n+                        urls.add(new File(URLDecoder.decode(path, StandardCharsets.UTF_8.name())).toURI().toURL());\n+                    }\n+                }\n+            }\n+            List<AppDependency> artifacts = new ArrayList<>();\n+            for (URL jarUrl : urls) {\n+                try (JarInputStream file = new JarInputStream(jarUrl.openConnection().getInputStream())) {\n+                    JarEntry entry = file.getNextJarEntry();\n+                    while (entry != null) {\n+                        if (entry.getName().endsWith(\"/pom.properties\") && entry.getName().startsWith(\"META-INF/maven\")) {\n+                            Properties p = new Properties();\n+                            p.load(file);\n+                            AppArtifact artifact = new AppArtifact(p.getProperty(\"groupId\"),\n+                                    p.getProperty(\"artifactId\"),\n+                                    p.getProperty(\"classifier\"),\n+                                    \"jar\",\n+                                    p.getProperty(\"version\"));\n+                            artifact.setPath(Paths.get(jarUrl.toURI()));\n+                            artifacts.add(\n+                                    new AppDependency(artifact, \"compile\"));\n+                        }\n+                        entry = file.getNextJarEntry();\n+                    }\n+                }\n+            }\n+\n+            //we now have our deployment time artifacts, lets resolve all their deps\n+            AppModel model = resolver.resolveManagedModel(appArtifact, artifacts, null);\n+            return new CurationResult(model, new FixedSuppler<>(resolver));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private CurationResult createAppModelForJar(Path appArtifactPath) {\n+        log.debug(\"provideOutcome depsOrigin=\" + dependenciesOrigin + \", versionUpdate=\" + versionUpdate\n+                + \", versionUpdateNumber=\"\n+                + versionUpdateNumber);\n+\n+        AppArtifact stateArtifact = null;\n+        boolean loadedFromState = false;\n+        AppModelResolver modelResolver = getAppModelResolver();\n+        final AppModel initialDepsList;\n+        AppArtifact appArtifact = this.appArtifact;\n+        try {\n+            if (appArtifact == null) {\n+                appArtifact = ModelUtils.resolveAppArtifact(appArtifactPath);\n+            }\n+            Path appJar;\n+            try {\n+                appJar = modelResolver.resolve(appArtifact);\n+            } catch (AppModelResolverException e) {\n+                throw new RuntimeException(\"Failed to resolve artifact\", e);\n+            }\n+            if (!Files.exists(appJar)) {\n+                throw new RuntimeException(\"Application \" + appJar + \" does not exist on disk\");\n+            }\n+\n+            modelResolver.relink(appArtifact, appJar);\n+\n+            if (dependenciesOrigin == DependenciesOrigin.LAST_UPDATE) {\n+                log.info(\"Looking for the state of the last update\");\n+                Path statePath = null;\n+                try {\n+                    stateArtifact = ModelUtils.getStateArtifact(appArtifact);\n+                    final String latest = modelResolver.getLatestVersion(stateArtifact, null, false);\n+                    if (!stateArtifact.getVersion().equals(latest)) {\n+                        stateArtifact = new AppArtifact(stateArtifact.getGroupId(), stateArtifact.getArtifactId(),\n+                                stateArtifact.getClassifier(), stateArtifact.getType(), latest);\n+                    }\n+                    statePath = modelResolver.resolve(stateArtifact);\n+                    log.info(\"- located the state at \" + statePath);\n+                } catch (AppModelResolverException e) {\n+                    // for now let's assume this means artifact does not exist\n+                    // System.out.println(\" no state found\");\n+                }\n+\n+                if (statePath != null) {\n+                    Model model;\n+                    try {\n+                        model = ModelUtils.readModel(statePath);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(\"Failed to read application state \" + statePath, e);\n+                    }\n+                    /*\n+                     * final Properties props = model.getProperties(); final String appGroupId =\n+                     * props.getProperty(CurateOutcome.CREATOR_APP_GROUP_ID); final String appArtifactId =\n+                     * props.getProperty(CurateOutcome.CREATOR_APP_ARTIFACT_ID); final String appClassifier =\n+                     * props.getProperty(CurateOutcome.CREATOR_APP_CLASSIFIER); final String appType =\n+                     * props.getProperty(CurateOutcome.CREATOR_APP_TYPE); final String appVersion =\n+                     * props.getProperty(CurateOutcome.CREATOR_APP_VERSION); final AppArtifact modelAppArtifact = new\n+                     * AppArtifact(appGroupId, appArtifactId, appClassifier, appType, appVersion);\n+                     */\n+                    final List<Dependency> modelStateDeps = model.getDependencies();\n+                    final List<AppDependency> updatedDeps = new ArrayList<>(modelStateDeps.size());\n+                    final String groupIdProp = \"${\" + CREATOR_APP_GROUP_ID + \"}\";\n+                    for (Dependency modelDep : modelStateDeps) {\n+                        if (modelDep.getGroupId().equals(groupIdProp)) {\n+                            continue;\n+                        }\n+                        updatedDeps.add(new AppDependency(new AppArtifact(modelDep.getGroupId(), modelDep.getArtifactId(),\n+                                modelDep.getClassifier(), modelDep.getType(), modelDep.getVersion()), modelDep.getScope(),\n+                                modelDep.isOptional()));\n+                    }\n+                    initialDepsList = modelResolver.resolveModel(appArtifact, updatedDeps);\n+                    loadedFromState = true;\n+                } else {\n+                    initialDepsList = modelResolver.resolveModel(appArtifact);\n+                }\n+            } else {\n+                initialDepsList = modelResolver.resolveModel(appArtifact);\n+            }\n+        } catch (AppModelResolverException | IOException e) {\n+            throw new RuntimeException(\"Failed to resolve initial application dependencies\", e);\n+        }\n+\n+        if (versionUpdate == VersionUpdate.NONE) {\n+            return new CurationResult(initialDepsList, new FixedSuppler<>(modelResolver), Collections.emptyList(),\n+                    loadedFromState, appArtifact,\n+                    stateArtifact);\n+        }\n+\n+        log.info(\"Checking for available updates\");\n+        List<AppDependency> appDeps;\n+        try {\n+            appDeps = modelResolver.resolveUserDependencies(appArtifact, initialDepsList.getUserDependencies());\n+        } catch (AppModelResolverException e) {\n+            throw new RuntimeException(\"Failed to determine the list of dependencies to update\", e);\n+        }\n+        final Iterator<AppDependency> depsI = appDeps.iterator();\n+        while (depsI.hasNext()) {\n+            final AppArtifact appDep = depsI.next().getArtifact();\n+            if (!appDep.getType().equals(AppArtifact.TYPE_JAR)) {\n+                depsI.remove();\n+                continue;\n+            }\n+            final Path path = appDep.getPath();\n+            if (Files.isDirectory(path)) {\n+                if (!Files.exists(path.resolve(BootstrapConstants.DESCRIPTOR_PATH))) {\n+                    depsI.remove();\n+                }\n+            } else {\n+                try (FileSystem artifactFs = ZipUtils.newFileSystem(path)) {\n+                    if (!Files.exists(artifactFs.getPath(BootstrapConstants.DESCRIPTOR_PATH))) {\n+                        depsI.remove();\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(\"Failed to open \" + path, e);\n+                }\n+            }\n+        }\n+\n+        final UpdateDiscovery ud = new DefaultUpdateDiscovery(modelResolver, versionUpdateNumber);\n+        List<AppDependency> availableUpdates = null;\n+        int i = 0;\n+        while (i < appDeps.size()) {\n+            final AppDependency dep = appDeps.get(i++);\n+            final AppArtifact depArtifact = dep.getArtifact();\n+            final String updatedVersion = versionUpdate == VersionUpdate.NEXT ? ud.getNextVersion(depArtifact)\n+                    : ud.getLatestVersion(depArtifact);\n+            if (updatedVersion == null || depArtifact.getVersion().equals(updatedVersion)) {\n+                continue;\n+            }\n+            log.info(dep.getArtifact() + \" -> \" + updatedVersion);\n+            if (availableUpdates == null) {\n+                availableUpdates = new ArrayList<>();\n+            }\n+            availableUpdates.add(new AppDependency(new AppArtifact(depArtifact.getGroupId(), depArtifact.getArtifactId(),\n+                    depArtifact.getClassifier(), depArtifact.getType(), updatedVersion), dep.getScope()));\n+        }\n+\n+        if (availableUpdates != null) {\n+            try {\n+                return new CurationResult(modelResolver.resolveModel(appArtifact, availableUpdates),\n+                        new FixedSuppler<>(modelResolver),\n+                        availableUpdates,\n+                        loadedFromState, appArtifact, stateArtifact);\n+            } catch (AppModelResolverException e) {\n+                throw new RuntimeException(e);\n+            }\n+        } else {\n+            log.info(\"- no updates available\");\n+            return new CurationResult(initialDepsList, new FixedSuppler<>(modelResolver), Collections.emptyList(),\n+                    loadedFromState, appArtifact,\n+                    stateArtifact);\n+        }\n+    }\n+\n+    private static Path resolveCachedCpPath(LocalProject project) {\n+        return project.getOutputDir().resolve(QUARKUS).resolve(BOOTSTRAP).resolve(DEPLOYMENT_CP);\n+    }\n+\n+    private static org.apache.maven.model.RepositoryPolicy toMavenRepoPolicy(RepositoryPolicy policy) {", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5MTI0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366291241", "bodyText": "This one looks somewhat confusing. If aggregateParentResources is false then it will still be looking for the resources in the parent but only if nothing was found locally. Is there a specific use-case where this is needed? I'm just thinking wouldn't simply consulting the parent only if aggregateParentResources was true work?", "author": "aloubyansky", "createdAt": "2020-01-14T11:40:05Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/classloading/QuarkusClassLoader.java", "diffHunk": "@@ -0,0 +1,504 @@\n+package io.quarkus.bootstrap.classloading;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.security.ProtectionDomain;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import org.jboss.logging.Logger;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+\n+/**\n+ * The ClassLoader used for non production Quarkus applications (i.e. dev and test mode). Production\n+ * applications use a flat classpath so just use the system class loader.\n+ *\n+ *\n+ */\n+public class QuarkusClassLoader extends ClassLoader implements Closeable {\n+\n+    private static final Logger log = Logger.getLogger(QuarkusClassLoader.class);\n+\n+    static {\n+        registerAsParallelCapable();\n+    }\n+\n+    private final String name;\n+    private final List<ClassPathElement> elements;\n+    private final ConcurrentMap<ClassPathElement, ProtectionDomain> protectionDomains = new ConcurrentHashMap<>();\n+    private final ClassLoader parent;\n+    /**\n+     * If this is true it will attempt to load from the parent first\n+     */\n+    private final boolean parentFirst;\n+    private final boolean aggregateParentResources;\n+    private final List<ClassPathElement> bannedElements;\n+    private final List<ClassPathElement> parentFirstElements;\n+\n+    /**\n+     * The element that holds resettable in-memory classses.\n+     *\n+     * A reset occurs when new transformers and in-memory classes are added to a ClassLoader. It happens after each\n+     * start in dev mode, however in general the reset resources will be the same. There are some cases where this is\n+     * not the case though:\n+     *\n+     * - Dev mode failed start will not end up with transformers or generated classes being registered. The reset\n+     * in this case will add them.\n+     * - Platform CDI beans that are considered to be removed and have the removed status changed will result in\n+     * additional classes being added to the class loader.\n+     *\n+     */\n+    private volatile MemoryClassPathElement resettableElement;\n+\n+    private volatile Map<String, List<BiFunction<String, ClassVisitor, ClassVisitor>>> bytecodeTransformers;\n+    private volatile ClassLoader transformerClassLoader;\n+    private volatile ClassLoaderState state;\n+\n+    private QuarkusClassLoader(Builder builder) {\n+        //we need the parent to be null\n+        //as MP has super broken class loading where it attempts to resolve stuff from the parent\n+        //will hopefully be fixed in 1.4\n+        //e.g. https://github.com/eclipse/microprofile-config/issues/390\n+        //e.g. https://github.com/eclipse/microprofile-reactive-streams-operators/pull/130\n+        super(null);\n+        this.name = builder.name;\n+        this.elements = builder.elements;\n+        this.bytecodeTransformers = builder.bytecodeTransformers;\n+        this.bannedElements = builder.bannedElements;\n+        this.parentFirstElements = builder.parentFirstElements;\n+        this.parent = builder.parent;\n+        this.parentFirst = builder.parentFirst;\n+        this.resettableElement = builder.resettableElement;\n+        this.transformerClassLoader = builder.transformerClassLoader;\n+        this.aggregateParentResources = builder.aggregateParentResources;\n+    }\n+\n+    public static Builder builder(String name, ClassLoader parent, boolean parentFirst) {\n+        return new Builder(name, parent, parentFirst);\n+    }\n+\n+    private String sanitizeName(String name) {\n+        if (name.startsWith(\"/\")) {\n+            return name.substring(1);\n+        }\n+        return name;\n+    }\n+\n+    private boolean parentFirst(String name, ClassLoaderState state) {\n+        return parentFirst || state.parentFirstResources.contains(name);\n+    }\n+\n+    public void reset(Map<String, byte[]> resources,\n+            Map<String, List<BiFunction<String, ClassVisitor, ClassVisitor>>> bytecodeTransformers, ClassLoader transformerClassLoader) {\n+        if (resettableElement == null) {\n+            throw new IllegalStateException(\"Classloader is no resettable\");\n+        }\n+        this.transformerClassLoader = transformerClassLoader;\n+        synchronized (this) {\n+            resettableElement.reset(resources);\n+            this.bytecodeTransformers = bytecodeTransformers;\n+            state = null;\n+        }\n+    }\n+\n+    @Override\n+    public Enumeration<URL> getResources(String nm) throws IOException {\n+        ClassLoaderState state = getState();\n+        String name = sanitizeName(nm);\n+        //for resources banned means that we don't delegate to the parent, as there can be multiple resources\n+        //for single resources we still respect this\n+        boolean banned = state.bannedResources.contains(name);\n+        List<URL> resources = new ArrayList<>();\n+        //ClassPathElement[] providers = loadableResources.get(name);\n+        //if (providers != null) {\n+        //    for (ClassPathElement element : providers) {\n+        //        resources.add(element.getResource(nm).getUrl());\n+        //    }\n+        //}\n+        for (ClassPathElement i : elements) {\n+            ClassPathResource res = i.getResource(nm);\n+            if (res != null) {\n+                resources.add(res.getUrl());\n+            }\n+        }\n+        if (!banned) {\n+            if(resources.isEmpty() || aggregateParentResources) {", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NDYzOA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366774638", "bodyText": "this is used for the deployment and runtime class loaders, so that getResources gets everything that would be on the actual application class path, without anything that may have leaked in on the system class path.\nI am not sure about just never consulting the parent, as it would effectively hide JDK resources. Arc needs to be able to index JDK classes at times, so if we did not delegate at all this would cause problems.", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5MTI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5Mjk1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366292955", "bodyText": "How about taking the value of aggregateParentResources into account here and in getResourceAsStream below? Wondering whether it's this way on purpose. Otherwise, it'd be probably a good idea to have a consistent resource access switch.", "author": "aloubyansky", "createdAt": "2020-01-14T11:44:14Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/classloading/QuarkusClassLoader.java", "diffHunk": "@@ -0,0 +1,504 @@\n+package io.quarkus.bootstrap.classloading;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.security.ProtectionDomain;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import org.jboss.logging.Logger;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.ClassWriter;\n+\n+/**\n+ * The ClassLoader used for non production Quarkus applications (i.e. dev and test mode). Production\n+ * applications use a flat classpath so just use the system class loader.\n+ *\n+ *\n+ */\n+public class QuarkusClassLoader extends ClassLoader implements Closeable {\n+\n+    private static final Logger log = Logger.getLogger(QuarkusClassLoader.class);\n+\n+    static {\n+        registerAsParallelCapable();\n+    }\n+\n+    private final String name;\n+    private final List<ClassPathElement> elements;\n+    private final ConcurrentMap<ClassPathElement, ProtectionDomain> protectionDomains = new ConcurrentHashMap<>();\n+    private final ClassLoader parent;\n+    /**\n+     * If this is true it will attempt to load from the parent first\n+     */\n+    private final boolean parentFirst;\n+    private final boolean aggregateParentResources;\n+    private final List<ClassPathElement> bannedElements;\n+    private final List<ClassPathElement> parentFirstElements;\n+\n+    /**\n+     * The element that holds resettable in-memory classses.\n+     *\n+     * A reset occurs when new transformers and in-memory classes are added to a ClassLoader. It happens after each\n+     * start in dev mode, however in general the reset resources will be the same. There are some cases where this is\n+     * not the case though:\n+     *\n+     * - Dev mode failed start will not end up with transformers or generated classes being registered. The reset\n+     * in this case will add them.\n+     * - Platform CDI beans that are considered to be removed and have the removed status changed will result in\n+     * additional classes being added to the class loader.\n+     *\n+     */\n+    private volatile MemoryClassPathElement resettableElement;\n+\n+    private volatile Map<String, List<BiFunction<String, ClassVisitor, ClassVisitor>>> bytecodeTransformers;\n+    private volatile ClassLoader transformerClassLoader;\n+    private volatile ClassLoaderState state;\n+\n+    private QuarkusClassLoader(Builder builder) {\n+        //we need the parent to be null\n+        //as MP has super broken class loading where it attempts to resolve stuff from the parent\n+        //will hopefully be fixed in 1.4\n+        //e.g. https://github.com/eclipse/microprofile-config/issues/390\n+        //e.g. https://github.com/eclipse/microprofile-reactive-streams-operators/pull/130\n+        super(null);\n+        this.name = builder.name;\n+        this.elements = builder.elements;\n+        this.bytecodeTransformers = builder.bytecodeTransformers;\n+        this.bannedElements = builder.bannedElements;\n+        this.parentFirstElements = builder.parentFirstElements;\n+        this.parent = builder.parent;\n+        this.parentFirst = builder.parentFirst;\n+        this.resettableElement = builder.resettableElement;\n+        this.transformerClassLoader = builder.transformerClassLoader;\n+        this.aggregateParentResources = builder.aggregateParentResources;\n+    }\n+\n+    public static Builder builder(String name, ClassLoader parent, boolean parentFirst) {\n+        return new Builder(name, parent, parentFirst);\n+    }\n+\n+    private String sanitizeName(String name) {\n+        if (name.startsWith(\"/\")) {\n+            return name.substring(1);\n+        }\n+        return name;\n+    }\n+\n+    private boolean parentFirst(String name, ClassLoaderState state) {\n+        return parentFirst || state.parentFirstResources.contains(name);\n+    }\n+\n+    public void reset(Map<String, byte[]> resources,\n+            Map<String, List<BiFunction<String, ClassVisitor, ClassVisitor>>> bytecodeTransformers, ClassLoader transformerClassLoader) {\n+        if (resettableElement == null) {\n+            throw new IllegalStateException(\"Classloader is no resettable\");\n+        }\n+        this.transformerClassLoader = transformerClassLoader;\n+        synchronized (this) {\n+            resettableElement.reset(resources);\n+            this.bytecodeTransformers = bytecodeTransformers;\n+            state = null;\n+        }\n+    }\n+\n+    @Override\n+    public Enumeration<URL> getResources(String nm) throws IOException {\n+        ClassLoaderState state = getState();\n+        String name = sanitizeName(nm);\n+        //for resources banned means that we don't delegate to the parent, as there can be multiple resources\n+        //for single resources we still respect this\n+        boolean banned = state.bannedResources.contains(name);\n+        List<URL> resources = new ArrayList<>();\n+        //ClassPathElement[] providers = loadableResources.get(name);\n+        //if (providers != null) {\n+        //    for (ClassPathElement element : providers) {\n+        //        resources.add(element.getResource(nm).getUrl());\n+        //    }\n+        //}\n+        for (ClassPathElement i : elements) {\n+            ClassPathResource res = i.getResource(nm);\n+            if (res != null) {\n+                resources.add(res.getUrl());\n+            }\n+        }\n+        if (!banned) {\n+            if(resources.isEmpty() || aggregateParentResources) {\n+                Enumeration<URL> res = parent.getResources(nm);\n+                while (res.hasMoreElements()) {\n+                    resources.add(res.nextElement());\n+                }\n+            }\n+        }\n+        return Collections.enumeration(resources);\n+    }\n+\n+    private ClassLoaderState getState() {\n+        ClassLoaderState state = this.state;\n+        if (state == null) {\n+            synchronized (this) {\n+                state = this.state;\n+                if (state == null) {\n+                    Map<String, List<ClassPathElement>> elementMap = new HashMap<>();\n+                    for (ClassPathElement element : elements) {\n+                        for (String i : element.getProvidedResources()) {\n+                            if (i.startsWith(\"/\")) {\n+                                throw new RuntimeException(\n+                                        \"Resources cannot start with /, \" + i + \" is incorrect provided by \" + element);\n+                            }\n+                            List<ClassPathElement> list = elementMap.get(i);\n+                            if (list == null) {\n+                                elementMap.put(i, list = new ArrayList<>());\n+                            }\n+                            list.add(element);\n+                        }\n+                    }\n+                    Map<String, ClassPathElement[]> finalElements = new HashMap<>();\n+                    for (Map.Entry<String, List<ClassPathElement>> i : elementMap.entrySet()) {\n+                        finalElements.put(i.getKey(), i.getValue().toArray(new ClassPathElement[i.getValue().size()]));\n+                    }\n+                    Set<String> banned = new HashSet<>();\n+                    for (ClassPathElement i : bannedElements) {\n+                        banned.addAll(i.getProvidedResources());\n+                    }\n+                    Set<String> parentFirstResources = new HashSet<>();\n+                    for (ClassPathElement i : parentFirstElements) {\n+                        parentFirstResources.addAll(i.getProvidedResources());\n+                    }\n+                    return this.state = new ClassLoaderState(finalElements, banned, parentFirstResources);\n+                }\n+            }\n+        }\n+        return state;\n+    }\n+\n+    @Override\n+    public URL getResource(String nm) {\n+        String name = sanitizeName(nm);\n+        ClassLoaderState state = getState();\n+        if (state.bannedResources.contains(name)) {\n+            return null;\n+        }\n+        //        ClassPathElement[] providers = loadableResources.get(name);\n+        //        if (providers != null) {\n+        //            return providers[0].getResource(nm).getUrl();\n+        //        }\n+        //TODO: because of dev mode we can't use the fast path her, we need to iterate\n+        for (ClassPathElement i : elements) {\n+            ClassPathResource res = i.getResource(name);\n+            if (res != null) {\n+                return res.getUrl();\n+            }\n+        }\n+        return parent.getResource(nm);", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3Njc5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366776797", "bodyText": "So we can't completely hide the JDK resources or ArC can't index them, but we want to hide duplicate/unwanted copies of META-INF/services files. I was not 100% sure about this but I can't really think of a better approach.", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5Mjk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3ODI3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366778271", "bodyText": "Ok", "author": "aloubyansky", "createdAt": "2020-01-15T09:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5Mjk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5NTc0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366295741", "bodyText": "directMvnDeps are supposed to be only the direct deps, their transitive deps aren't in there.", "author": "aloubyansky", "createdAt": "2020-01-14T11:50:54Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/resolver/BootstrapAppModelResolver.java", "diffHunk": "@@ -130,24 +143,42 @@ public AppModel resolveModel(AppArtifact appArtifact, List<AppDependency> direct\n         return resolveManagedModel(appArtifact, directDeps, null);\n     }\n \n-    public AppModel resolveManagedModel(AppArtifact appArtifact, List<AppDependency> directDeps, AppArtifact managingProject) throws AppModelResolverException {\n+    @Override\n+    public AppModel resolveManagedModel(AppArtifact appArtifact, List<AppDependency> directDeps, AppArtifact managingProject)\n+            throws AppModelResolverException {\n         return doResolveModel(appArtifact, toAetherDeps(directDeps), managingProject);\n     }\n \n-    private AppModel doResolveModel(AppArtifact appArtifact, List<Dependency> directMvnDeps, AppArtifact managingProject) throws AppModelResolverException {\n+    private AppModel doResolveModel(AppArtifact appArtifact, List<Dependency> directMvnDeps, AppArtifact managingProject)\n+            throws AppModelResolverException {\n+        AppModel.Builder appBuilder = new AppModel.Builder();\n         List<Dependency> managedDeps = Collections.emptyList();\n         List<RemoteRepository> managedRepos = Collections.emptyList();\n-        if(managingProject != null) {\n+        if (managingProject != null) {\n             final ArtifactDescriptorResult managingDescr = mvn.resolveDescriptor(toAetherArtifact(managingProject));\n             managedDeps = managingDescr.getManagedDependencies();\n             managedRepos = mvn.newResolutionRepositories(managingDescr.getRepositories());\n         }\n-\n-        DependencyNode resolvedDeps = mvn.resolveManagedDependencies(toAetherArtifact(appArtifact),\n-                directMvnDeps, managedDeps, managedRepos, devmode ? new String[] { \"test\" } : new String[0]).getRoot();\n+        List<String> excludedScopes = new ArrayList<>();\n+        if (!test) {\n+            excludedScopes.add(\"test\");\n+        }\n+        if (!devmode) {\n+            excludedScopes.add(\"provided\");\n+        }\n \n         final Set<AppArtifactKey> appDeps = new HashSet<>();\n         final List<AppDependency> userDeps = new ArrayList<>();\n+        DependencyNode resolvedDeps;\n+        if (appArtifact != null) {\n+            resolvedDeps = mvn.resolveManagedDependencies(toAetherArtifact(appArtifact),\n+                    directMvnDeps, managedDeps, managedRepos, excludedScopes.toArray(new String[0])).getRoot();\n+        } else {\n+            //if there is no main artifact we assume we already have all the deps we need\n+            //we just turn them into a DependencyNode\n+            resolvedDeps = mvn.toDependencyTree(directMvnDeps, managedRepos).getRoot();", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5NzQ2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366297467", "bodyText": "Looks like deploymentDependencies is not used for anything useful.", "author": "aloubyansky", "createdAt": "2020-01-14T11:55:08Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/resolver/BootstrapAppModelResolver.java", "diffHunk": "@@ -157,28 +188,38 @@ public boolean visitEnter(DependencyNode node) {\n             @Override\n             public boolean visitLeave(DependencyNode node) {\n                 final Dependency dep = node.getDependency();\n-                if(dep != null) {\n+                if (dep != null) {\n                     final AppArtifact appArtifact = toAppArtifact(dep.getArtifact());\n                     appDeps.add(appArtifact.getKey());\n                     userDeps.add(new AppDependency(appArtifact, dep.getScope(), dep.isOptional()));\n                 }\n                 return true;\n-            }});\n-        for(DependencyNode child : resolvedDeps.getChildren()) {\n+            }\n+        });\n+        for (DependencyNode child : resolvedDeps.getChildren()) {\n             child.accept(visitor);\n         }\n-\n+        List<RemoteRepository> repos;\n+        if (appArtifact != null) {\n+            repos = mvn.aggregateRepositories(managedRepos,\n+                    mvn.newResolutionRepositories(mvn.resolveDescriptor(toAetherArtifact(appArtifact)).getRepositories()));\n+        } else {\n+            repos = managedRepos;\n+        }\n         final DeploymentInjectingDependencyVisitor deploymentInjector = new DeploymentInjectingDependencyVisitor(mvn,\n-                managedDeps, mvn.aggregateRepositories(managedRepos, mvn.newResolutionRepositories(mvn.resolveDescriptor(toAetherArtifact(appArtifact)).getRepositories())));\n+                managedDeps, repos, appBuilder);\n         try {\n             deploymentInjector.injectDeploymentDependencies(resolvedDeps);\n         } catch (BootstrapDependencyProcessingException e) {\n-            throw new AppModelResolverException(\"Failed to inject extension deployment dependencies for \" + resolvedDeps.getArtifact(), e.getCause());\n+            throw new AppModelResolverException(\n+                    \"Failed to inject extension deployment dependencies for \" + resolvedDeps.getArtifact(), e.getCause());\n         }\n \n         List<AppDependency> deploymentDeps = Collections.emptyList();\n-        if(deploymentInjector.isInjectedDeps()) {\n-            final DependencyGraphTransformationContext context = new SimpleDependencyGraphTransformationContext(mvn.getSession());\n+        List<Dependency> deploymentDependencies = new ArrayList<>();", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3Mzk1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368873952", "bodyText": "Please remove deploymentDependencies.", "author": "aloubyansky", "createdAt": "2020-01-21T08:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5NzQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5ODA3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366298071", "bodyText": "Let's keep using AppArtifactKey instead.", "author": "aloubyansky", "createdAt": "2020-01-14T11:56:32Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/resolver/BootstrapAppModelResolver.java", "diffHunk": "@@ -336,4 +418,31 @@ private static AppArtifact toAppArtifact(Artifact artifact) {\n         }\n         return directMvnDeps;\n     }\n+\n+    static final class AppKey {", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjI5ODcxNw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366298717", "bodyText": "Ah, this method is actually not used. Is it? So AppKey can simply be removed with this method.", "author": "aloubyansky", "createdAt": "2020-01-14T11:58:14Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/resolver/BootstrapAppModelResolver.java", "diffHunk": "@@ -297,37 +352,64 @@ private VersionRangeResult resolveVersionRangeResult(AppArtifact appArtifact, St\n \n     static List<AppDependency> toAppDepList(DependencyNode rootNode) {\n         final List<DependencyNode> depNodes = rootNode.getChildren();\n-        if(depNodes.isEmpty()) {\n+        if (depNodes.isEmpty()) {\n             return Collections.emptyList();\n         }\n-        final List<AppDependency> appDeps =  new ArrayList<>();\n+        final List<AppDependency> appDeps = new ArrayList<>();\n         collect(depNodes, appDeps);\n         return appDeps;\n     }\n \n     private static void collect(List<DependencyNode> nodes, List<AppDependency> appDeps) {\n-        for(DependencyNode node : nodes) {\n+        for (DependencyNode node : nodes) {\n             collect(node.getChildren(), appDeps);\n             final Dependency dep = node.getDependency();\n             appDeps.add(new AppDependency(toAppArtifact(node.getArtifact()), dep.getScope(), dep.isOptional()));\n         }\n     }\n \n     private static Artifact toAetherArtifact(AppArtifact artifact) {\n-        return new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getClassifier(), artifact.getType(), artifact.getVersion());\n+        Artifact defaultArtifact = new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(),\n+                artifact.getClassifier(),\n+                artifact.getType(), artifact.getVersion());\n+        if (artifact.getPath() != null) {\n+            defaultArtifact = defaultArtifact.setFile(artifact.getPath().toFile());\n+        }\n+        return defaultArtifact;\n     }\n \n     private static AppArtifact toAppArtifact(Artifact artifact) {\n-        final AppArtifact appArtifact = new AppArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getClassifier(), artifact.getExtension(), artifact.getVersion());\n+        final AppArtifact appArtifact = new AppArtifact(artifact.getGroupId(), artifact.getArtifactId(),\n+                artifact.getClassifier(), artifact.getExtension(), artifact.getVersion());\n         final File file = artifact.getFile();\n-        if(file != null) {\n+        if (file != null) {\n             appArtifact.setPath(file.toPath());\n         }\n         return appArtifact;\n     }\n \n+    private static AppArtifact toAppArtifact(Artifact artifact, Map<AppKey, AppArtifact> versions) {", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwMDg0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366300843", "bodyText": "I guess it's safe to re-use new Dependency(node.getArtifact(), JavaScopes.COMPILE) created above.", "author": "aloubyansky", "createdAt": "2020-01-14T12:03:47Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/resolver/maven/DeploymentInjectingDependencyVisitor.java", "diffHunk": "@@ -111,19 +115,23 @@ private void processPlatformArtifact(DependencyNode node, Path descriptor) throw\n             return;\n         }\n         final String value = rtProps.getProperty(BootstrapConstants.PROP_DEPLOYMENT_ARTIFACT);\n+        appBuilder.handleExtensionProperties(rtProps, node.getArtifact().toString());\n         if(value == null) {\n             return;\n         }\n-        if(value != null) {\n-            Artifact deploymentArtifact = toArtifact(value);\n-            if(deploymentArtifact.getVersion() == null || deploymentArtifact.getVersion().isEmpty()) {\n-                deploymentArtifact = deploymentArtifact.setVersion(node.getArtifact().getVersion());\n-            }\n-            node.setData(QUARKUS_DEPLOYMENT_ARTIFACT, deploymentArtifact);\n-            runtimeNodes.add(node);\n-            managedDeps.add(new Dependency(node.getArtifact(), JavaScopes.COMPILE));\n-            managedDeps.add(new Dependency(deploymentArtifact, JavaScopes.COMPILE));\n+        Artifact deploymentArtifact = toArtifact(value);\n+        if(deploymentArtifact.getVersion() == null || deploymentArtifact.getVersion().isEmpty()) {\n+            deploymentArtifact = deploymentArtifact.setVersion(node.getArtifact().getVersion());\n         }\n+        node.setData(QUARKUS_DEPLOYMENT_ARTIFACT, deploymentArtifact);\n+        runtimeNodes.add(node);\n+        managedDeps.add(new Dependency(node.getArtifact(), JavaScopes.COMPILE));\n+        runtimeExtensionDeps.add(new Dependency(node.getArtifact(), JavaScopes.COMPILE));", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwMjQwMA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366302400", "bodyText": "This method doesn't seem to be used anywhere. Let's remove it for now.", "author": "aloubyansky", "createdAt": "2020-01-14T12:07:58Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/resolver/maven/MavenArtifactResolver.java", "diffHunk": "@@ -312,6 +317,46 @@ public DependencyResult resolveManagedDependencies(Artifact artifact, List<Depen\n         }\n     }\n \n+    /**\n+     * Turns the list of dependencies into a simple dependency tree\n+     */\n+    public DependencyResult toDependencyTree(List<Dependency> deps, List<RemoteRepository> mainRepos) throws AppModelResolverException {\n+        DependencyResult result = new DependencyResult(new DependencyRequest().setCollectRequest(new CollectRequest(deps, Collections.emptyList(), mainRepos)));\n+        DefaultDependencyNode root = new DefaultDependencyNode((Dependency) null);\n+        result.setRoot(root);\n+        GenericVersionScheme vs = new GenericVersionScheme();\n+        for(Dependency i : deps) {\n+            DefaultDependencyNode node = new DefaultDependencyNode(i);\n+            try {\n+                node.setVersionConstraint(vs.parseVersionConstraint(i.getArtifact().getVersion()));\n+                node.setVersion(vs.parseVersion(i.getArtifact().getVersion()));\n+            } catch (InvalidVersionSpecificationException e) {\n+                throw new RuntimeException(e);\n+            }\n+            root.getChildren().add(node);\n+        }\n+        return result;\n+    }\n+    public DependencyResult resolveManagedDependencies(List<Dependency> deps, List<Dependency> managedDeps, List<RemoteRepository> mainRepos) throws AppModelResolverException {", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NDU5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368874595", "bodyText": "Please remove this method.", "author": "aloubyansky", "createdAt": "2020-01-21T08:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwMjQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNDA3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366304075", "bodyText": "I agree this was an ugly choice to design it this way. But by default \"test\" and \"provided\" should be excluded. That is, if the caller doesn't provide anything.", "author": "aloubyansky", "createdAt": "2020-01-14T12:12:16Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/resolver/maven/MavenArtifactResolver.java", "diffHunk": "@@ -328,7 +373,7 @@ private CollectRequest newCollectManagedRequest(Artifact artifact, List<Dependen\n         final ArtifactDescriptorResult descr = resolveDescriptor(artifact);\n         Collection<String> excluded;\n         if(excludedScopes.length == 0) {\n-            excluded = Arrays.asList(new String[] {\"test\", \"provided\"});\n+            excluded = Collections.emptyList();", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4Mjk2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366782961", "bodyText": "This is why there is now explicit devmode and test flags, as if you are running the dev mode tests you need both.", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNDA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MzU5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366783599", "bodyText": "That is why I changed this, as there are cases where there are no excluded scopes, so now it is up to the caller.", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNDA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk5NDg4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366994885", "bodyText": "This is a different default behavior though. But let's leave it for now. I didn't do it well in the first place, so I'll probably review it later.", "author": "aloubyansky", "createdAt": "2020-01-15T17:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNDA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNDc3OA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366304778", "bodyText": "Just curious, was there a case when it actually was a String? Which option was that?", "author": "aloubyansky", "createdAt": "2020-01-14T12:14:09Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/resolver/maven/options/BootstrapMavenOptions.java", "diffHunk": "@@ -90,7 +93,7 @@ public String getOptionValue(String name) {\n \n     public String[] getOptionValues(String name) {\n         final Object o = options.get(name);\n-        return o == null ? null : (String[]) o;\n+        return o == null ? null : o instanceof String ? new String[] { o.toString() } : (String[]) o;", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MDE0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366770141", "bodyText": "I think it was these ones: \n  \n    \n      quarkus/independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/resolver/maven/options/BootstrapMavenOptionsParser.java\n    \n    \n         Line 25\n      in\n      8f0d158\n    \n    \n    \n    \n\n        \n          \n           putBoolean(cmdLine, map, CLIManager.SUPRESS_SNAPSHOT_UPDATES);", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNDc3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3NjY0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366776642", "bodyText": "If you recall how to reproduce that, please let me know. If not we'll merge it anyway. But I'd like to see the stacktrace.", "author": "aloubyansky", "createdAt": "2020-01-15T09:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNDc3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MjA3OA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366782078", "bodyText": "I can't actually remember, and it might not even be a problem any more as this PR has gone through so many changes.", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNDc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNjcxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366306719", "bodyText": "This one is redundant.", "author": "aloubyansky", "createdAt": "2020-01-14T12:19:05Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/util/IoUtils.java", "diffHunk": "@@ -1,6 +1,7 @@\n package io.quarkus.bootstrap.util;\n \n import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwNzA2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366307066", "bodyText": "Why? I think it's important to keep the list.", "author": "aloubyansky", "createdAt": "2020-01-14T12:19:57Z", "path": "independent-projects/bootstrap/core/src/test/java/io/quarkus/bootstrap/resolver/CollectDependenciesBase.java", "diffHunk": "@@ -43,8 +44,8 @@ public void testCollectedDependencies() throws Exception {\n             expected.addAll(expectedResult);\n             expected.addAll(deploymentDeps);\n         }\n-        final List<AppDependency> resolvedDeps = getTestResolver().resolveModel(root.toAppArtifact()).getAllDependencies();\n-        assertEquals(expected, resolvedDeps);\n+        final List<AppDependency> resolvedDeps = getTestResolver().resolveModel(root.toAppArtifact()).getFullDeploymentDeps();\n+        assertEquals(new HashSet<>(expected), new HashSet<>(resolvedDeps));", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwODM3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366308372", "bodyText": "Where is this used in core?", "author": "aloubyansky", "createdAt": "2020-01-14T12:23:10Z", "path": "independent-projects/bootstrap/core/pom.xml", "diffHunk": "@@ -14,6 +14,10 @@\n     <name>Quarkus - Bootstrap - Core</name>\n \n     <dependencies>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm</artifactId>\n+        </dependency>", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MTMxNg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366781316", "bodyText": "The ClassLoader implementation allows for transformers, and the transformer API is based on ASM.", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwODM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMwOTU4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366309585", "bodyText": "TBH, I'm not familiar with this test but if for LambdaException it's still relevant to make sure the type is IAE, shouldn't this turn into multiple catches?", "author": "aloubyansky", "createdAt": "2020-01-14T12:26:14Z", "path": "integration-tests/amazon-lambda/src/test/java/io/quarkus/it/amazon/lambda/AmazonLambdaSimpleTestCase.java", "diffHunk": "@@ -29,9 +28,9 @@ public void testSimpleLambdaFailure() throws Exception {\n             OutputObject out = LambdaClient.invoke(OutputObject.class, in);\n             out.getResult();\n             Assertions.fail();\n-        } catch (LambdaException e) {\n+        } catch (Exception e) {\n             Assertions.assertEquals(ProcessingService.CAN_ONLY_GREET_NICKNAMES, e.getMessage());\n-            Assertions.assertEquals(IllegalArgumentException.class.getName(), e.getType());\n+            //Assertions.assertEquals(IllegalArgumentException.class.getName(), e.getType());", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxMTk5NA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366311994", "bodyText": "Exception won't be generic enough here?", "author": "aloubyansky", "createdAt": "2020-01-14T12:32:24Z", "path": "test-framework/common/src/main/java/io/quarkus/test/common/TestResourceManager.java", "diffHunk": "@@ -84,10 +84,10 @@ public void stop() {\n                 throw new RuntimeException(\"Unable to stop Quarkus test resource \" + testResource, e);\n             }\n         }\n-        ConfigProviderResolver cpr = ConfigProviderResolver.instance();\n         try {\n+            ConfigProviderResolver cpr = ConfigProviderResolver.instance();\n             cpr.releaseConfig(cpr.getConfig());\n-        } catch (IllegalStateException ignored) {\n+        } catch (Throwable ignored) {", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4MDE5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366780191", "bodyText": "This may not be nessesary any more, there were some smallrye class loading problems that resulted in Error's being thrown. I think they are fixed now as the CL always returns null from getParent, but I need to re-check.", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxMTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxMjk5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366312999", "bodyText": "Is this a leftover?", "author": "aloubyansky", "createdAt": "2020-01-14T12:34:41Z", "path": "test-framework/junit5/src/main/java/io/quarkus/test/junit/QuarkusTestExtension.java", "diffHunk": "@@ -3,259 +3,123 @@\n import static io.quarkus.test.common.PathTestHelper.getAppClassLocation;\n import static io.quarkus.test.common.PathTestHelper.getTestClassesLocation;\n \n-import java.io.BufferedReader;\n import java.io.Closeable;\n import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n+import java.lang.annotation.Annotation;\n+import java.lang.management.ManagementFactory;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.Enumeration;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.LinkedBlockingDeque;\n-import java.util.function.BiFunction;\n import java.util.function.Consumer;\n+import java.util.function.Function;\n import java.util.function.Predicate;\n \n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.AfterAllCallback;\n import org.junit.jupiter.api.extension.AfterEachCallback;\n import org.junit.jupiter.api.extension.BeforeAllCallback;\n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestInstanceFactory;\n import org.junit.jupiter.api.extension.TestInstanceFactoryContext;\n import org.junit.jupiter.api.extension.TestInstantiationException;\n-import org.junit.platform.commons.JUnitException;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n import org.opentest4j.TestAbortedException;\n \n-import io.quarkus.bootstrap.BootstrapClassLoaderFactory;\n-import io.quarkus.bootstrap.BootstrapException;\n-import io.quarkus.bootstrap.DefineClassVisibleURLClassLoader;\n-import io.quarkus.bootstrap.util.IoUtils;\n-import io.quarkus.bootstrap.util.PropertyUtils;\n+import io.quarkus.bootstrap.app.AdditionalDependency;\n+import io.quarkus.bootstrap.app.AugmentAction;\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.bootstrap.app.QuarkusBootstrap;\n+import io.quarkus.bootstrap.app.RunningQuarkusApplication;\n import io.quarkus.builder.BuildChainBuilder;\n import io.quarkus.builder.BuildContext;\n import io.quarkus.builder.BuildStep;\n-import io.quarkus.deployment.ClassOutput;\n-import io.quarkus.deployment.QuarkusClassWriter;\n import io.quarkus.deployment.builditem.TestAnnotationBuildItem;\n import io.quarkus.deployment.builditem.TestClassPredicateBuildItem;\n-import io.quarkus.deployment.util.IoUtil;\n-import io.quarkus.runner.RuntimeRunner;\n-import io.quarkus.runner.TransformerTarget;\n-import io.quarkus.runtime.LaunchMode;\n-import io.quarkus.test.common.NativeImageLauncher;\n+import io.quarkus.deployment.proxy.ProxyConfiguration;\n+import io.quarkus.deployment.proxy.ProxyFactory;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.runtime.Timing;\n+import io.quarkus.test.common.DefineClassVisibleClassLoader;\n import io.quarkus.test.common.PathTestHelper;\n import io.quarkus.test.common.PropertyTestUtil;\n import io.quarkus.test.common.RestAssuredURLManager;\n-import io.quarkus.test.common.TestInjectionManager;\n-import io.quarkus.test.common.TestInstantiator;\n import io.quarkus.test.common.TestResourceManager;\n import io.quarkus.test.common.TestScopeManager;\n import io.quarkus.test.common.http.TestHTTPResourceManager;\n \n+//todo: share common core with QuarkusUnitTest\n public class QuarkusTestExtension\n-        implements BeforeEachCallback, AfterEachCallback, TestInstanceFactory, BeforeAllCallback {\n+        implements BeforeEachCallback, AfterEachCallback, TestInstanceFactory, BeforeAllCallback, InvocationInterceptor,\n+        AfterAllCallback {\n \n-    private URLClassLoader appCl;\n-    private ClassLoader originalCl;\n     private static boolean failedBoot;\n \n-    /**\n-     * As part of the test run we need to create files in the test-classes directory\n-     *\n-     * We attempt to clean these up with a shutdown hook, but if the processes is killed (e.g. hitting the red\n-     * IDE button) it can leave these files behind which interfere with subsequent runs.\n-     *\n-     * To fix this we create a file that contains the names of all the files we have created, and at the start of a new\n-     * run we remove them if this file exists.\n-     */\n-    private static final String CREATED_FILES = \"CREATED_FILES.txt\";\n-    private final RestAssuredURLManager restAssuredURLManager = new RestAssuredURLManager(false);\n+    private static Class<?> actualTestClass;\n+    private static Object actualTestInstance;\n+    private static ClassLoader originalCl;\n+    private static RunningQuarkusApplication runningQuarkusApplication;\n+    private static Path testClassLocation;\n+    private static boolean allowPackagePrivateMethods;\n \n     private ExtensionState doJavaStart(ExtensionContext context, TestResourceManager testResourceManager) {\n \n-        final LinkedBlockingDeque<Runnable> shutdownTasks = new LinkedBlockingDeque<>();\n+        try {\n+            final LinkedBlockingDeque<Runnable> shutdownTasks = new LinkedBlockingDeque<>();\n \n-        Path appClassLocation = getAppClassLocation(context.getRequiredTestClass());\n+            Path appClassLocation = getAppClassLocation(context.getRequiredTestClass());\n \n-        appCl = createQuarkusBuildClassLoader(appClassLocation);\n-        originalCl = setCCL(appCl);\n+            System.err\n+                    .println(\"INIT TIME \" + (System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime()));", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxMzE5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366313191", "bodyText": "This one too?", "author": "aloubyansky", "createdAt": "2020-01-14T12:35:09Z", "path": "test-framework/junit5/src/main/java/io/quarkus/test/junit/QuarkusTestExtension.java", "diffHunk": "@@ -3,259 +3,123 @@\n import static io.quarkus.test.common.PathTestHelper.getAppClassLocation;\n import static io.quarkus.test.common.PathTestHelper.getTestClassesLocation;\n \n-import java.io.BufferedReader;\n import java.io.Closeable;\n import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n+import java.lang.annotation.Annotation;\n+import java.lang.management.ManagementFactory;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.Enumeration;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.LinkedBlockingDeque;\n-import java.util.function.BiFunction;\n import java.util.function.Consumer;\n+import java.util.function.Function;\n import java.util.function.Predicate;\n \n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.AfterAllCallback;\n import org.junit.jupiter.api.extension.AfterEachCallback;\n import org.junit.jupiter.api.extension.BeforeAllCallback;\n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestInstanceFactory;\n import org.junit.jupiter.api.extension.TestInstanceFactoryContext;\n import org.junit.jupiter.api.extension.TestInstantiationException;\n-import org.junit.platform.commons.JUnitException;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n import org.opentest4j.TestAbortedException;\n \n-import io.quarkus.bootstrap.BootstrapClassLoaderFactory;\n-import io.quarkus.bootstrap.BootstrapException;\n-import io.quarkus.bootstrap.DefineClassVisibleURLClassLoader;\n-import io.quarkus.bootstrap.util.IoUtils;\n-import io.quarkus.bootstrap.util.PropertyUtils;\n+import io.quarkus.bootstrap.app.AdditionalDependency;\n+import io.quarkus.bootstrap.app.AugmentAction;\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.bootstrap.app.QuarkusBootstrap;\n+import io.quarkus.bootstrap.app.RunningQuarkusApplication;\n import io.quarkus.builder.BuildChainBuilder;\n import io.quarkus.builder.BuildContext;\n import io.quarkus.builder.BuildStep;\n-import io.quarkus.deployment.ClassOutput;\n-import io.quarkus.deployment.QuarkusClassWriter;\n import io.quarkus.deployment.builditem.TestAnnotationBuildItem;\n import io.quarkus.deployment.builditem.TestClassPredicateBuildItem;\n-import io.quarkus.deployment.util.IoUtil;\n-import io.quarkus.runner.RuntimeRunner;\n-import io.quarkus.runner.TransformerTarget;\n-import io.quarkus.runtime.LaunchMode;\n-import io.quarkus.test.common.NativeImageLauncher;\n+import io.quarkus.deployment.proxy.ProxyConfiguration;\n+import io.quarkus.deployment.proxy.ProxyFactory;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.runtime.Timing;\n+import io.quarkus.test.common.DefineClassVisibleClassLoader;\n import io.quarkus.test.common.PathTestHelper;\n import io.quarkus.test.common.PropertyTestUtil;\n import io.quarkus.test.common.RestAssuredURLManager;\n-import io.quarkus.test.common.TestInjectionManager;\n-import io.quarkus.test.common.TestInstantiator;\n import io.quarkus.test.common.TestResourceManager;\n import io.quarkus.test.common.TestScopeManager;\n import io.quarkus.test.common.http.TestHTTPResourceManager;\n \n+//todo: share common core with QuarkusUnitTest\n public class QuarkusTestExtension\n-        implements BeforeEachCallback, AfterEachCallback, TestInstanceFactory, BeforeAllCallback {\n+        implements BeforeEachCallback, AfterEachCallback, TestInstanceFactory, BeforeAllCallback, InvocationInterceptor,\n+        AfterAllCallback {\n \n-    private URLClassLoader appCl;\n-    private ClassLoader originalCl;\n     private static boolean failedBoot;\n \n-    /**\n-     * As part of the test run we need to create files in the test-classes directory\n-     *\n-     * We attempt to clean these up with a shutdown hook, but if the processes is killed (e.g. hitting the red\n-     * IDE button) it can leave these files behind which interfere with subsequent runs.\n-     *\n-     * To fix this we create a file that contains the names of all the files we have created, and at the start of a new\n-     * run we remove them if this file exists.\n-     */\n-    private static final String CREATED_FILES = \"CREATED_FILES.txt\";\n-    private final RestAssuredURLManager restAssuredURLManager = new RestAssuredURLManager(false);\n+    private static Class<?> actualTestClass;\n+    private static Object actualTestInstance;\n+    private static ClassLoader originalCl;\n+    private static RunningQuarkusApplication runningQuarkusApplication;\n+    private static Path testClassLocation;\n+    private static boolean allowPackagePrivateMethods;\n \n     private ExtensionState doJavaStart(ExtensionContext context, TestResourceManager testResourceManager) {\n \n-        final LinkedBlockingDeque<Runnable> shutdownTasks = new LinkedBlockingDeque<>();\n+        try {\n+            final LinkedBlockingDeque<Runnable> shutdownTasks = new LinkedBlockingDeque<>();\n \n-        Path appClassLocation = getAppClassLocation(context.getRequiredTestClass());\n+            Path appClassLocation = getAppClassLocation(context.getRequiredTestClass());\n \n-        appCl = createQuarkusBuildClassLoader(appClassLocation);\n-        originalCl = setCCL(appCl);\n+            System.err\n+                    .println(\"INIT TIME \" + (System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime()));\n \n-        final ClassLoader testClassLoader = context.getRequiredTestClass().getClassLoader();\n-        final Path testWiringClassesDir;\n-        final RuntimeRunner.Builder runnerBuilder = RuntimeRunner.builder();\n+            final QuarkusBootstrap.Builder runnerBuilder = QuarkusBootstrap.builder(appClassLocation)\n+                    .setIsolateDeployment(true)\n+                    .setMode(QuarkusBootstrap.Mode.TEST);\n+\n+            originalCl = Thread.currentThread().getContextClassLoader();\n+            testClassLocation = getTestClassesLocation(context.getRequiredTestClass());\n+            allowPackagePrivateMethods = Files.isDirectory(testClassLocation);\n \n-        final Path testClassLocation = getTestClassesLocation(context.getRequiredTestClass());\n-        if (Files.isDirectory(testClassLocation)) {\n-            testWiringClassesDir = testClassLocation;\n-        } else {\n             if (!appClassLocation.equals(testClassLocation)) {\n-                runnerBuilder.addAdditionalArchive(testClassLocation);\n-            }\n-            testWiringClassesDir = Paths.get(\"\").normalize().toAbsolutePath().resolve(\"target\").resolve(\"test-classes\");\n-            if (Files.exists(testWiringClassesDir)) {\n-                IoUtils.recursiveDelete(testWiringClassesDir);\n-            }\n-            try {\n-                Files.createDirectories(testWiringClassesDir);\n-            } catch (IOException e) {\n-                throw new IllegalStateException(\n-                        \"Failed to create a directory for wiring test classes at \" + testWiringClassesDir, e);\n+                runnerBuilder.addAdditionalApplicationArchive(new AdditionalDependency(testClassLocation, true, true));\n             }\n-        }\n-\n-        Path createdFilesPath = testWiringClassesDir.resolve(CREATED_FILES);\n-        if (Files.exists(createdFilesPath)) {\n-            cleanupOldRun(createdFilesPath);\n-        }\n-        try (OutputStream created = Files.newOutputStream(createdFilesPath)) {\n-\n-            RuntimeRunner runtimeRunner = runnerBuilder\n-                    .setLaunchMode(LaunchMode.TEST)\n-                    .setClassLoader(appCl)\n-                    .setTarget(appClassLocation)\n-                    .addAdditionalArchive(testWiringClassesDir)\n-                    .setClassOutput(new ClassOutput() {\n-                        @Override\n-                        public void writeClass(boolean applicationClass, String className, byte[] data) throws IOException {\n-                            Path location = testWiringClassesDir.resolve(className.replace('.', '/') + \".class\");\n-                            Files.createDirectories(location.getParent());\n-                            Files.write(location, data);\n-                            handleCreatedFile(location, created, testWiringClassesDir, shutdownTasks);\n-                        }\n+            CuratedApplication curatedApplication = runnerBuilder.setTest(true).build().bootstrap();\n+            Timing.staticInitStarted(curatedApplication.getBaseRuntimeClassLoader());\n+            System.err.println(\n+                    \"CURATE TIME \" + (System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime()));", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxMzMzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366313331", "bodyText": "And this one?", "author": "aloubyansky", "createdAt": "2020-01-14T12:35:29Z", "path": "test-framework/junit5/src/main/java/io/quarkus/test/junit/QuarkusTestExtension.java", "diffHunk": "@@ -3,259 +3,123 @@\n import static io.quarkus.test.common.PathTestHelper.getAppClassLocation;\n import static io.quarkus.test.common.PathTestHelper.getTestClassesLocation;\n \n-import java.io.BufferedReader;\n import java.io.Closeable;\n import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n+import java.lang.annotation.Annotation;\n+import java.lang.management.ManagementFactory;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.Enumeration;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.LinkedBlockingDeque;\n-import java.util.function.BiFunction;\n import java.util.function.Consumer;\n+import java.util.function.Function;\n import java.util.function.Predicate;\n \n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.AfterAllCallback;\n import org.junit.jupiter.api.extension.AfterEachCallback;\n import org.junit.jupiter.api.extension.BeforeAllCallback;\n import org.junit.jupiter.api.extension.BeforeEachCallback;\n import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.InvocationInterceptor;\n+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;\n import org.junit.jupiter.api.extension.TestInstanceFactory;\n import org.junit.jupiter.api.extension.TestInstanceFactoryContext;\n import org.junit.jupiter.api.extension.TestInstantiationException;\n-import org.junit.platform.commons.JUnitException;\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassVisitor;\n-import org.objectweb.asm.ClassWriter;\n import org.opentest4j.TestAbortedException;\n \n-import io.quarkus.bootstrap.BootstrapClassLoaderFactory;\n-import io.quarkus.bootstrap.BootstrapException;\n-import io.quarkus.bootstrap.DefineClassVisibleURLClassLoader;\n-import io.quarkus.bootstrap.util.IoUtils;\n-import io.quarkus.bootstrap.util.PropertyUtils;\n+import io.quarkus.bootstrap.app.AdditionalDependency;\n+import io.quarkus.bootstrap.app.AugmentAction;\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.bootstrap.app.QuarkusBootstrap;\n+import io.quarkus.bootstrap.app.RunningQuarkusApplication;\n import io.quarkus.builder.BuildChainBuilder;\n import io.quarkus.builder.BuildContext;\n import io.quarkus.builder.BuildStep;\n-import io.quarkus.deployment.ClassOutput;\n-import io.quarkus.deployment.QuarkusClassWriter;\n import io.quarkus.deployment.builditem.TestAnnotationBuildItem;\n import io.quarkus.deployment.builditem.TestClassPredicateBuildItem;\n-import io.quarkus.deployment.util.IoUtil;\n-import io.quarkus.runner.RuntimeRunner;\n-import io.quarkus.runner.TransformerTarget;\n-import io.quarkus.runtime.LaunchMode;\n-import io.quarkus.test.common.NativeImageLauncher;\n+import io.quarkus.deployment.proxy.ProxyConfiguration;\n+import io.quarkus.deployment.proxy.ProxyFactory;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.runtime.Timing;\n+import io.quarkus.test.common.DefineClassVisibleClassLoader;\n import io.quarkus.test.common.PathTestHelper;\n import io.quarkus.test.common.PropertyTestUtil;\n import io.quarkus.test.common.RestAssuredURLManager;\n-import io.quarkus.test.common.TestInjectionManager;\n-import io.quarkus.test.common.TestInstantiator;\n import io.quarkus.test.common.TestResourceManager;\n import io.quarkus.test.common.TestScopeManager;\n import io.quarkus.test.common.http.TestHTTPResourceManager;\n \n+//todo: share common core with QuarkusUnitTest\n public class QuarkusTestExtension\n-        implements BeforeEachCallback, AfterEachCallback, TestInstanceFactory, BeforeAllCallback {\n+        implements BeforeEachCallback, AfterEachCallback, TestInstanceFactory, BeforeAllCallback, InvocationInterceptor,\n+        AfterAllCallback {\n \n-    private URLClassLoader appCl;\n-    private ClassLoader originalCl;\n     private static boolean failedBoot;\n \n-    /**\n-     * As part of the test run we need to create files in the test-classes directory\n-     *\n-     * We attempt to clean these up with a shutdown hook, but if the processes is killed (e.g. hitting the red\n-     * IDE button) it can leave these files behind which interfere with subsequent runs.\n-     *\n-     * To fix this we create a file that contains the names of all the files we have created, and at the start of a new\n-     * run we remove them if this file exists.\n-     */\n-    private static final String CREATED_FILES = \"CREATED_FILES.txt\";\n-    private final RestAssuredURLManager restAssuredURLManager = new RestAssuredURLManager(false);\n+    private static Class<?> actualTestClass;\n+    private static Object actualTestInstance;\n+    private static ClassLoader originalCl;\n+    private static RunningQuarkusApplication runningQuarkusApplication;\n+    private static Path testClassLocation;\n+    private static boolean allowPackagePrivateMethods;\n \n     private ExtensionState doJavaStart(ExtensionContext context, TestResourceManager testResourceManager) {\n \n-        final LinkedBlockingDeque<Runnable> shutdownTasks = new LinkedBlockingDeque<>();\n+        try {\n+            final LinkedBlockingDeque<Runnable> shutdownTasks = new LinkedBlockingDeque<>();\n \n-        Path appClassLocation = getAppClassLocation(context.getRequiredTestClass());\n+            Path appClassLocation = getAppClassLocation(context.getRequiredTestClass());\n \n-        appCl = createQuarkusBuildClassLoader(appClassLocation);\n-        originalCl = setCCL(appCl);\n+            System.err\n+                    .println(\"INIT TIME \" + (System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime()));\n \n-        final ClassLoader testClassLoader = context.getRequiredTestClass().getClassLoader();\n-        final Path testWiringClassesDir;\n-        final RuntimeRunner.Builder runnerBuilder = RuntimeRunner.builder();\n+            final QuarkusBootstrap.Builder runnerBuilder = QuarkusBootstrap.builder(appClassLocation)\n+                    .setIsolateDeployment(true)\n+                    .setMode(QuarkusBootstrap.Mode.TEST);\n+\n+            originalCl = Thread.currentThread().getContextClassLoader();\n+            testClassLocation = getTestClassesLocation(context.getRequiredTestClass());\n+            allowPackagePrivateMethods = Files.isDirectory(testClassLocation);\n \n-        final Path testClassLocation = getTestClassesLocation(context.getRequiredTestClass());\n-        if (Files.isDirectory(testClassLocation)) {\n-            testWiringClassesDir = testClassLocation;\n-        } else {\n             if (!appClassLocation.equals(testClassLocation)) {\n-                runnerBuilder.addAdditionalArchive(testClassLocation);\n-            }\n-            testWiringClassesDir = Paths.get(\"\").normalize().toAbsolutePath().resolve(\"target\").resolve(\"test-classes\");\n-            if (Files.exists(testWiringClassesDir)) {\n-                IoUtils.recursiveDelete(testWiringClassesDir);\n-            }\n-            try {\n-                Files.createDirectories(testWiringClassesDir);\n-            } catch (IOException e) {\n-                throw new IllegalStateException(\n-                        \"Failed to create a directory for wiring test classes at \" + testWiringClassesDir, e);\n+                runnerBuilder.addAdditionalApplicationArchive(new AdditionalDependency(testClassLocation, true, true));\n             }\n-        }\n-\n-        Path createdFilesPath = testWiringClassesDir.resolve(CREATED_FILES);\n-        if (Files.exists(createdFilesPath)) {\n-            cleanupOldRun(createdFilesPath);\n-        }\n-        try (OutputStream created = Files.newOutputStream(createdFilesPath)) {\n-\n-            RuntimeRunner runtimeRunner = runnerBuilder\n-                    .setLaunchMode(LaunchMode.TEST)\n-                    .setClassLoader(appCl)\n-                    .setTarget(appClassLocation)\n-                    .addAdditionalArchive(testWiringClassesDir)\n-                    .setClassOutput(new ClassOutput() {\n-                        @Override\n-                        public void writeClass(boolean applicationClass, String className, byte[] data) throws IOException {\n-                            Path location = testWiringClassesDir.resolve(className.replace('.', '/') + \".class\");\n-                            Files.createDirectories(location.getParent());\n-                            Files.write(location, data);\n-                            handleCreatedFile(location, created, testWiringClassesDir, shutdownTasks);\n-                        }\n+            CuratedApplication curatedApplication = runnerBuilder.setTest(true).build().bootstrap();\n+            Timing.staticInitStarted(curatedApplication.getBaseRuntimeClassLoader());\n+            System.err.println(\n+                    \"CURATE TIME \" + (System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime()));\n+            AugmentAction augmentAction = curatedApplication.createAugmentor(TestBuildChainFunction.class.getName(),\n+                    Collections.emptyMap());\n+            runningQuarkusApplication = augmentAction.createInitialRuntimeApplication().run();\n \n-                        @Override\n-                        public void writeResource(String name, byte[] data) throws IOException {\n-                            Path location = testWiringClassesDir.resolve(name);\n-                            Files.createDirectories(location.getParent());\n-                            Files.write(location, data);\n-                            handleCreatedFile(location, created, testWiringClassesDir, shutdownTasks);\n-                        }\n-                    })\n-                    .setTransformerTarget(new TransformerTarget() {\n-                        @Override\n-                        public void setTransformers(\n-                                Map<String, List<BiFunction<String, ClassVisitor, ClassVisitor>>> functions) {\n-                            ClassLoader main = Thread.currentThread().getContextClassLoader();\n+            System.err.println(\n+                    \"REAL START TIME \" + (System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime()));", "originalCommit": "0748b17567e42dd79e38502eb7c512189ba362d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fca2a4cecb63ac2a6abf50900a68bc91d811aa49", "url": "https://github.com/quarkusio/quarkus/commit/fca2a4cecb63ac2a6abf50900a68bc91d811aa49", "message": "Remove the need for test proxies", "committedDate": "2020-01-15T02:32:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NDkzOA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366764938", "bodyText": "Just wondering whether classLoader which is the application's augment classloader should also be closed here.", "author": "aloubyansky", "createdAt": "2020-01-15T09:16:18Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/QuarkusAugmentor.java", "diffHunk": "@@ -141,6 +145,9 @@ public BuildResult run() throws Exception {\n                 } catch (Exception e) {\n                 }\n             }\n+            if (deploymentClassLoader instanceof Closeable) {\n+                ((Closeable) deploymentClassLoader).close();\n+            }", "originalCommit": "494030ef4d760c753f26a8fab51c06950cd472f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NjIwNg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366766206", "bodyText": "No, they have different lifecycles. This one is recreated on each hot reload, the other lasts for the life of dev mode apps.", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NDkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2OTQ5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366769496", "bodyText": "Shouldn't we deleteOnExit this dir? Or do a more controlled cleanup? Perhaps we should consider introducing some kind of Quarkus-post-build-clean-up tasks in perspective.", "author": "aloubyansky", "createdAt": "2020-01-15T09:25:58Z", "path": "core/deployment/src/main/java/io/quarkus/runner/bootstrap/GenerateConfigTask.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package io.quarkus.runner.bootstrap;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.builder.BuildChainBuilder;\n+import io.quarkus.builder.BuildExecutionBuilder;\n+import io.quarkus.builder.BuildResult;\n+import io.quarkus.deployment.builditem.ArchiveRootBuildItem;\n+import io.quarkus.deployment.builditem.ConfigDescriptionBuildItem;\n+\n+/**\n+ * This phase generates an example configuration file\n+ *\n+ * @author Stuart Douglas\n+ */\n+public class GenerateConfigTask {\n+\n+    private static final Logger log = Logger.getLogger(GenerateConfigTask.class);\n+\n+    private final Path configFile;\n+\n+    public GenerateConfigTask(Path configFile) {\n+        this.configFile = configFile;\n+    }\n+\n+    public Path run(CuratedApplication application) {\n+        //first lets look for some config, as it is not on the current class path\n+        //and we need to load it to run the build process\n+        try {\n+            AugmentActionImpl augmentAction = new AugmentActionImpl(application, Collections.emptyList());\n+            BuildResult buildResult = augmentAction.runCustomAction(new Consumer<BuildChainBuilder>() {\n+                @Override\n+                public void accept(BuildChainBuilder chainBuilder) {\n+                    chainBuilder.addFinal(ConfigDescriptionBuildItem.class);\n+                    chainBuilder.addInitial(ArchiveRootBuildItem.class);\n+                }\n+            }, new Consumer<BuildExecutionBuilder>() {\n+                @Override\n+                public void accept(BuildExecutionBuilder buildExecutionBuilder) {\n+                    try {\n+                        buildExecutionBuilder.produce(new ArchiveRootBuildItem(Files.createTempDirectory(\"empty\")));", "originalCommit": "494030ef4d760c753f26a8fab51c06950cd472f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3ODEwMg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366778102", "bodyText": "good catch, but in this case it can just be deleted immediately after.", "author": "stuartwdouglas", "createdAt": "2020-01-15T09:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2OTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NDUwNg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366984506", "bodyText": "The code here is assuming it's a JAR. It could be a directory containing classes, couldn't it?", "author": "aloubyansky", "createdAt": "2020-01-15T16:43:53Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -0,0 +1,522 @@\n+package io.quarkus.bootstrap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.net.URL;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.model.Model;\n+import org.eclipse.aether.repository.RepositoryPolicy;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CurationResult;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.bootstrap.model.AppDependency;\n+import io.quarkus.bootstrap.model.AppModel;\n+import io.quarkus.bootstrap.resolver.AppModelResolver;\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.BootstrapAppModelResolver;\n+import io.quarkus.bootstrap.resolver.maven.MavenArtifactResolver;\n+import io.quarkus.bootstrap.resolver.maven.workspace.LocalProject;\n+import io.quarkus.bootstrap.resolver.maven.workspace.ModelUtils;\n+import io.quarkus.bootstrap.resolver.update.DefaultUpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.DependenciesOrigin;\n+import io.quarkus.bootstrap.resolver.update.UpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdate;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdateNumber;\n+import io.quarkus.bootstrap.util.ZipUtils;\n+\n+/**\n+ * The factory that creates the application dependency model.\n+ *\n+ * This is used to build the application class loader.\n+ */\n+public class BootstrapAppModelFactory {\n+\n+    private static final String QUARKUS = \"quarkus\";\n+    private static final String BOOTSTRAP = \"bootstrap\";\n+    private static final String DEPLOYMENT_CP = \"deployment.cp\";\n+\n+    public static final String CREATOR_APP_GROUP_ID = \"creator.app.groupId\";\n+    public static final String CREATOR_APP_ARTIFACT_ID = \"creator.app.artifactId\";\n+    public static final String CREATOR_APP_CLASSIFIER = \"creator.app.classifier\";\n+    public static final String CREATOR_APP_TYPE = \"creator.app.type\";\n+    public static final String CREATOR_APP_VERSION = \"creator.app.version\";\n+\n+    private static final int CP_CACHE_FORMAT_ID = 2;\n+\n+    private static final Logger log = Logger.getLogger(BootstrapAppModelFactory.class);\n+    private AppArtifact managingProject;\n+\n+    public static BootstrapAppModelFactory newInstance() {\n+        return new BootstrapAppModelFactory();\n+    }\n+\n+    private Path appClasses;\n+    private List<Path> appCp = new ArrayList<>(0);\n+    private boolean localProjectsDiscovery;\n+    private Boolean offline;\n+    private boolean enableClasspathCache = false;\n+    private boolean test;\n+    private boolean devMode;\n+    private AppModelResolver bootstrapAppModelResolver;\n+\n+    private VersionUpdateNumber versionUpdateNumber;\n+    private VersionUpdate versionUpdate;\n+    private DependenciesOrigin dependenciesOrigin;\n+    private AppArtifact appArtifact;\n+    private MavenArtifactResolver mavenArtifactResolver;\n+\n+    private BootstrapAppModelFactory() {\n+    }\n+\n+    public BootstrapAppModelFactory setTest(boolean test) {\n+        this.test = test;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDevMode(boolean devMode) {\n+        this.devMode = devMode;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppClasses(Path appClasses) {\n+        this.appClasses = appClasses;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory addToClassPath(Path path) {\n+        this.appCp.add(path);\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setLocalProjectsDiscovery(boolean localProjectsDiscovery) {\n+        this.localProjectsDiscovery = localProjectsDiscovery;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setOffline(Boolean offline) {\n+        this.offline = offline;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setEnableClasspathCache(boolean enable) {\n+        this.enableClasspathCache = enable;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setBootstrapAppModelResolver(AppModelResolver bootstrapAppModelResolver) {\n+        this.bootstrapAppModelResolver = bootstrapAppModelResolver;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdateNumber(VersionUpdateNumber versionUpdateNumber) {\n+        this.versionUpdateNumber = versionUpdateNumber;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdate(VersionUpdate versionUpdate) {\n+        this.versionUpdate = versionUpdate;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDependenciesOrigin(DependenciesOrigin dependenciesOrigin) {\n+        this.dependenciesOrigin = dependenciesOrigin;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppArtifact(AppArtifact appArtifact) {\n+        this.appArtifact = appArtifact;\n+        return this;\n+    }\n+\n+    public AppModelResolver getAppModelResolver() {\n+        try {\n+            if (bootstrapAppModelResolver != null) {\n+                return bootstrapAppModelResolver;\n+            }\n+            if (appClasses == null) {\n+                throw new IllegalArgumentException(\"Application classes path has not been set\");\n+            }\n+            if (!Files.isDirectory(appClasses)) {\n+                final MavenArtifactResolver mvn;\n+                if (mavenArtifactResolver == null) {\n+                    final MavenArtifactResolver.Builder mvnBuilder = MavenArtifactResolver.builder();\n+                    if (offline != null) {\n+                        mvnBuilder.setOffline(offline);\n+                    }\n+                    final LocalProject localProject = localProjectsDiscovery\n+                            ? LocalProject.loadWorkspace(Paths.get(\"\").normalize().toAbsolutePath(), false)\n+                            : null;\n+                    if (localProject != null) {\n+                        mvnBuilder.setWorkspace(localProject.getWorkspace());\n+                        if(managingProject == null) {\n+                            //TODO: big hack, all this needs to be cleaned up\n+                            managingProject = localProject.getAppArtifact();\n+                        }\n+                    }\n+                    mvn = mvnBuilder.build();\n+                } else {\n+                    mvn = mavenArtifactResolver;\n+                }\n+\n+                return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                        .setTest(test)\n+                        .setDevMode(devMode);\n+            }\n+\n+            final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+                    ? LocalProject.loadWorkspace(appClasses, false)\n+                    : LocalProject.load(appClasses, false);\n+\n+            final MavenArtifactResolver mvn;\n+            if(mavenArtifactResolver == null) {\n+                final MavenArtifactResolver.Builder builder = MavenArtifactResolver.builder();\n+                if (localProject != null) {\n+                    builder.setWorkspace(localProject.getWorkspace());\n+                }\n+                if (offline != null) {\n+                    builder.setOffline(offline);\n+                }\n+                mvn = builder.build();\n+            } else {\n+                mvn = mavenArtifactResolver;\n+            }\n+            return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                    .setTest(test)\n+                    .setDevMode(devMode);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create resolver for \" + appClasses, e);\n+        }\n+    }\n+\n+    public CurationResult resolveAppModel() throws BootstrapException {\n+        if (appClasses == null) {\n+            throw new IllegalArgumentException(\"Application classes path has not been set\");\n+        }\n+\n+        if (!Files.isDirectory(appClasses)) {\n+            return createAppModelForJar(appClasses);\n+        }\n+        //        final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+        //                ? LocalProject.loadWorkspace(appClasses)\n+        //                : LocalProject.load(appClasses);\n+        final LocalProject localProject = LocalProject.loadWorkspace(appClasses, false);\n+        if (localProject == null) {\n+            log.warn(\"Unable to locate maven project, falling back to classpath discovery\");\n+            return doClasspathDiscovery();\n+        }\n+        try {\n+            Path cachedCpPath = null;\n+            if (enableClasspathCache) {\n+                cachedCpPath = resolveCachedCpPath(localProject);\n+                if (Files.exists(cachedCpPath)) {\n+                    try (DataInputStream reader = new DataInputStream(Files.newInputStream(cachedCpPath))) {\n+                        if (reader.readInt() == CP_CACHE_FORMAT_ID) {\n+                            if (reader.readInt() == localProject.getWorkspace().getId()) {\n+                                ObjectInputStream in = new ObjectInputStream(reader);\n+                                return new CurationResult((AppModel) in.readObject(), () -> getAppModelResolver());\n+                            } else {\n+                                debug(\"Cached deployment classpath has expired for %s\", localProject.getAppArtifact());\n+                            }\n+                        } else {\n+                            debug(\"Unsupported classpath cache format in %s for %s\", cachedCpPath,\n+                                    localProject.getAppArtifact());\n+                        }\n+                    } catch (IOException e) {\n+                        log.warn(\"Failed to read deployment classpath cache from \" + cachedCpPath + \" for \"\n+                                + localProject.getAppArtifact(), e);\n+                    }\n+                }\n+            }\n+\n+            AppModelResolver appModelResolver = getAppModelResolver();\n+            CurationResult curationResult = new CurationResult(appModelResolver\n+                    .resolveManagedModel(localProject.getAppArtifact(), Collections.emptyList(), managingProject), new FixedSuppler<>(appModelResolver));\n+            if (cachedCpPath != null) {\n+                Files.createDirectories(cachedCpPath.getParent());\n+                try (DataOutputStream out = new DataOutputStream(Files.newOutputStream(cachedCpPath))) {\n+                    out.writeInt(CP_CACHE_FORMAT_ID);\n+                    out.writeInt(localProject.getWorkspace().getId());\n+                    ObjectOutputStream obj = new ObjectOutputStream(out);\n+                    obj.writeObject(curationResult.getAppModel());\n+                } catch (Exception e) {\n+                    log.warn(\"Failed to write classpath cache\", e);\n+                }\n+            }\n+            return curationResult;\n+        } catch (Exception e) {\n+            throw new BootstrapException(\"Failed to create the application model for \" + localProject.getAppArtifact(), e);\n+        }\n+    }\n+\n+    /**\n+     * If no maven project is around do discovery based on the class path.\n+     *\n+     * This is used to run gradle tests, and allows them to run from both the IDE\n+     * and the gradle test task\n+     *\n+     */\n+    private CurationResult doClasspathDiscovery() {\n+        try {\n+            AppModelResolver resolver = getAppModelResolver();\n+\n+            Set<URL> urls = new HashSet<>();\n+            //this is pretty yuck, but under JDK11 the URLClassLoader trick does not work\n+            Enumeration<URL> manifests = Thread.currentThread().getContextClassLoader().getResources(\"META-INF/MANIFEST.MF\");\n+            while (manifests.hasMoreElements()) {\n+                URL url = manifests.nextElement();\n+                if (url.getProtocol().equals(\"jar\")) {\n+                    String path = url.getPath();\n+                    if (path.startsWith(\"file:\")) {\n+                        path = path.substring(5, path.lastIndexOf('!'));", "originalCommit": "5616a758fac6a29df2ad5a052cafbc50fe47cfe7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MDE4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r367160182", "bodyText": "no, see the if statement above.", "author": "stuartwdouglas", "createdAt": "2020-01-15T23:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NDUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI0NDU2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r367244561", "bodyText": "Ok, my point was though about directories containing classes that are on classpath. If you are launching from an IDE that is what should appear on the classpath, right? So why is this method adding only the JARs?", "author": "aloubyansky", "createdAt": "2020-01-16T06:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NDUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk1OTQwOA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368959408", "bodyText": "I need to think about this one a bit more, but it is really a last resort case when we have no info. I could just delete it but I think it is worth keeping and trying to solve any reported problems as they arise.", "author": "stuartwdouglas", "createdAt": "2020-01-21T11:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NDUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3MjY0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368972646", "bodyText": "I think you can keep it for now. AFAIU, this method may get called when (re)building an app from a JAR in the first place. Probably a pretty good chance that everything comes in a JAR at that point.", "author": "aloubyansky", "createdAt": "2020-01-21T12:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NDUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NTU2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366985567", "bodyText": "Aren't these the runtime artifacts?", "author": "aloubyansky", "createdAt": "2020-01-15T16:45:54Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -0,0 +1,522 @@\n+package io.quarkus.bootstrap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.net.URL;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.model.Model;\n+import org.eclipse.aether.repository.RepositoryPolicy;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CurationResult;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.bootstrap.model.AppDependency;\n+import io.quarkus.bootstrap.model.AppModel;\n+import io.quarkus.bootstrap.resolver.AppModelResolver;\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.BootstrapAppModelResolver;\n+import io.quarkus.bootstrap.resolver.maven.MavenArtifactResolver;\n+import io.quarkus.bootstrap.resolver.maven.workspace.LocalProject;\n+import io.quarkus.bootstrap.resolver.maven.workspace.ModelUtils;\n+import io.quarkus.bootstrap.resolver.update.DefaultUpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.DependenciesOrigin;\n+import io.quarkus.bootstrap.resolver.update.UpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdate;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdateNumber;\n+import io.quarkus.bootstrap.util.ZipUtils;\n+\n+/**\n+ * The factory that creates the application dependency model.\n+ *\n+ * This is used to build the application class loader.\n+ */\n+public class BootstrapAppModelFactory {\n+\n+    private static final String QUARKUS = \"quarkus\";\n+    private static final String BOOTSTRAP = \"bootstrap\";\n+    private static final String DEPLOYMENT_CP = \"deployment.cp\";\n+\n+    public static final String CREATOR_APP_GROUP_ID = \"creator.app.groupId\";\n+    public static final String CREATOR_APP_ARTIFACT_ID = \"creator.app.artifactId\";\n+    public static final String CREATOR_APP_CLASSIFIER = \"creator.app.classifier\";\n+    public static final String CREATOR_APP_TYPE = \"creator.app.type\";\n+    public static final String CREATOR_APP_VERSION = \"creator.app.version\";\n+\n+    private static final int CP_CACHE_FORMAT_ID = 2;\n+\n+    private static final Logger log = Logger.getLogger(BootstrapAppModelFactory.class);\n+    private AppArtifact managingProject;\n+\n+    public static BootstrapAppModelFactory newInstance() {\n+        return new BootstrapAppModelFactory();\n+    }\n+\n+    private Path appClasses;\n+    private List<Path> appCp = new ArrayList<>(0);\n+    private boolean localProjectsDiscovery;\n+    private Boolean offline;\n+    private boolean enableClasspathCache = false;\n+    private boolean test;\n+    private boolean devMode;\n+    private AppModelResolver bootstrapAppModelResolver;\n+\n+    private VersionUpdateNumber versionUpdateNumber;\n+    private VersionUpdate versionUpdate;\n+    private DependenciesOrigin dependenciesOrigin;\n+    private AppArtifact appArtifact;\n+    private MavenArtifactResolver mavenArtifactResolver;\n+\n+    private BootstrapAppModelFactory() {\n+    }\n+\n+    public BootstrapAppModelFactory setTest(boolean test) {\n+        this.test = test;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDevMode(boolean devMode) {\n+        this.devMode = devMode;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppClasses(Path appClasses) {\n+        this.appClasses = appClasses;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory addToClassPath(Path path) {\n+        this.appCp.add(path);\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setLocalProjectsDiscovery(boolean localProjectsDiscovery) {\n+        this.localProjectsDiscovery = localProjectsDiscovery;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setOffline(Boolean offline) {\n+        this.offline = offline;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setEnableClasspathCache(boolean enable) {\n+        this.enableClasspathCache = enable;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setBootstrapAppModelResolver(AppModelResolver bootstrapAppModelResolver) {\n+        this.bootstrapAppModelResolver = bootstrapAppModelResolver;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdateNumber(VersionUpdateNumber versionUpdateNumber) {\n+        this.versionUpdateNumber = versionUpdateNumber;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdate(VersionUpdate versionUpdate) {\n+        this.versionUpdate = versionUpdate;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDependenciesOrigin(DependenciesOrigin dependenciesOrigin) {\n+        this.dependenciesOrigin = dependenciesOrigin;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppArtifact(AppArtifact appArtifact) {\n+        this.appArtifact = appArtifact;\n+        return this;\n+    }\n+\n+    public AppModelResolver getAppModelResolver() {\n+        try {\n+            if (bootstrapAppModelResolver != null) {\n+                return bootstrapAppModelResolver;\n+            }\n+            if (appClasses == null) {\n+                throw new IllegalArgumentException(\"Application classes path has not been set\");\n+            }\n+            if (!Files.isDirectory(appClasses)) {\n+                final MavenArtifactResolver mvn;\n+                if (mavenArtifactResolver == null) {\n+                    final MavenArtifactResolver.Builder mvnBuilder = MavenArtifactResolver.builder();\n+                    if (offline != null) {\n+                        mvnBuilder.setOffline(offline);\n+                    }\n+                    final LocalProject localProject = localProjectsDiscovery\n+                            ? LocalProject.loadWorkspace(Paths.get(\"\").normalize().toAbsolutePath(), false)\n+                            : null;\n+                    if (localProject != null) {\n+                        mvnBuilder.setWorkspace(localProject.getWorkspace());\n+                        if(managingProject == null) {\n+                            //TODO: big hack, all this needs to be cleaned up\n+                            managingProject = localProject.getAppArtifact();\n+                        }\n+                    }\n+                    mvn = mvnBuilder.build();\n+                } else {\n+                    mvn = mavenArtifactResolver;\n+                }\n+\n+                return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                        .setTest(test)\n+                        .setDevMode(devMode);\n+            }\n+\n+            final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+                    ? LocalProject.loadWorkspace(appClasses, false)\n+                    : LocalProject.load(appClasses, false);\n+\n+            final MavenArtifactResolver mvn;\n+            if(mavenArtifactResolver == null) {\n+                final MavenArtifactResolver.Builder builder = MavenArtifactResolver.builder();\n+                if (localProject != null) {\n+                    builder.setWorkspace(localProject.getWorkspace());\n+                }\n+                if (offline != null) {\n+                    builder.setOffline(offline);\n+                }\n+                mvn = builder.build();\n+            } else {\n+                mvn = mavenArtifactResolver;\n+            }\n+            return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                    .setTest(test)\n+                    .setDevMode(devMode);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create resolver for \" + appClasses, e);\n+        }\n+    }\n+\n+    public CurationResult resolveAppModel() throws BootstrapException {\n+        if (appClasses == null) {\n+            throw new IllegalArgumentException(\"Application classes path has not been set\");\n+        }\n+\n+        if (!Files.isDirectory(appClasses)) {\n+            return createAppModelForJar(appClasses);\n+        }\n+        //        final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+        //                ? LocalProject.loadWorkspace(appClasses)\n+        //                : LocalProject.load(appClasses);\n+        final LocalProject localProject = LocalProject.loadWorkspace(appClasses, false);\n+        if (localProject == null) {\n+            log.warn(\"Unable to locate maven project, falling back to classpath discovery\");\n+            return doClasspathDiscovery();\n+        }\n+        try {\n+            Path cachedCpPath = null;\n+            if (enableClasspathCache) {\n+                cachedCpPath = resolveCachedCpPath(localProject);\n+                if (Files.exists(cachedCpPath)) {\n+                    try (DataInputStream reader = new DataInputStream(Files.newInputStream(cachedCpPath))) {\n+                        if (reader.readInt() == CP_CACHE_FORMAT_ID) {\n+                            if (reader.readInt() == localProject.getWorkspace().getId()) {\n+                                ObjectInputStream in = new ObjectInputStream(reader);\n+                                return new CurationResult((AppModel) in.readObject(), () -> getAppModelResolver());\n+                            } else {\n+                                debug(\"Cached deployment classpath has expired for %s\", localProject.getAppArtifact());\n+                            }\n+                        } else {\n+                            debug(\"Unsupported classpath cache format in %s for %s\", cachedCpPath,\n+                                    localProject.getAppArtifact());\n+                        }\n+                    } catch (IOException e) {\n+                        log.warn(\"Failed to read deployment classpath cache from \" + cachedCpPath + \" for \"\n+                                + localProject.getAppArtifact(), e);\n+                    }\n+                }\n+            }\n+\n+            AppModelResolver appModelResolver = getAppModelResolver();\n+            CurationResult curationResult = new CurationResult(appModelResolver\n+                    .resolveManagedModel(localProject.getAppArtifact(), Collections.emptyList(), managingProject), new FixedSuppler<>(appModelResolver));\n+            if (cachedCpPath != null) {\n+                Files.createDirectories(cachedCpPath.getParent());\n+                try (DataOutputStream out = new DataOutputStream(Files.newOutputStream(cachedCpPath))) {\n+                    out.writeInt(CP_CACHE_FORMAT_ID);\n+                    out.writeInt(localProject.getWorkspace().getId());\n+                    ObjectOutputStream obj = new ObjectOutputStream(out);\n+                    obj.writeObject(curationResult.getAppModel());\n+                } catch (Exception e) {\n+                    log.warn(\"Failed to write classpath cache\", e);\n+                }\n+            }\n+            return curationResult;\n+        } catch (Exception e) {\n+            throw new BootstrapException(\"Failed to create the application model for \" + localProject.getAppArtifact(), e);\n+        }\n+    }\n+\n+    /**\n+     * If no maven project is around do discovery based on the class path.\n+     *\n+     * This is used to run gradle tests, and allows them to run from both the IDE\n+     * and the gradle test task\n+     *\n+     */\n+    private CurationResult doClasspathDiscovery() {\n+        try {\n+            AppModelResolver resolver = getAppModelResolver();\n+\n+            Set<URL> urls = new HashSet<>();\n+            //this is pretty yuck, but under JDK11 the URLClassLoader trick does not work\n+            Enumeration<URL> manifests = Thread.currentThread().getContextClassLoader().getResources(\"META-INF/MANIFEST.MF\");\n+            while (manifests.hasMoreElements()) {\n+                URL url = manifests.nextElement();\n+                if (url.getProtocol().equals(\"jar\")) {\n+                    String path = url.getPath();\n+                    if (path.startsWith(\"file:\")) {\n+                        path = path.substring(5, path.lastIndexOf('!'));\n+                        urls.add(new File(URLDecoder.decode(path, StandardCharsets.UTF_8.name())).toURI().toURL());\n+                    }\n+                }\n+            }\n+            List<AppDependency> artifacts = new ArrayList<>();\n+            for (URL jarUrl : urls) {\n+                try (JarInputStream file = new JarInputStream(jarUrl.openConnection().getInputStream())) {\n+                    JarEntry entry = file.getNextJarEntry();\n+                    while (entry != null) {\n+                        if (entry.getName().endsWith(\"/pom.properties\") && entry.getName().startsWith(\"META-INF/maven\")) {\n+                            Properties p = new Properties();\n+                            p.load(file);\n+                            AppArtifact artifact = new AppArtifact(p.getProperty(\"groupId\"),\n+                                    p.getProperty(\"artifactId\"),\n+                                    p.getProperty(\"classifier\"),\n+                                    \"jar\",\n+                                    p.getProperty(\"version\"));\n+                            artifact.setPath(Paths.get(jarUrl.toURI()));\n+                            artifacts.add(\n+                                    new AppDependency(artifact, \"compile\"));\n+                        }\n+                        entry = file.getNextJarEntry();\n+                    }\n+                }\n+            }\n+\n+            //we now have our deployment time artifacts, lets resolve all their deps", "originalCommit": "5616a758fac6a29df2ad5a052cafbc50fe47cfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4Njg5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366986899", "bodyText": "For this invocation we'd need the actual GAVs.", "author": "aloubyansky", "createdAt": "2020-01-15T16:48:17Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -0,0 +1,522 @@\n+package io.quarkus.bootstrap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.net.URL;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.model.Model;\n+import org.eclipse.aether.repository.RepositoryPolicy;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CurationResult;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.bootstrap.model.AppDependency;\n+import io.quarkus.bootstrap.model.AppModel;\n+import io.quarkus.bootstrap.resolver.AppModelResolver;\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.BootstrapAppModelResolver;\n+import io.quarkus.bootstrap.resolver.maven.MavenArtifactResolver;\n+import io.quarkus.bootstrap.resolver.maven.workspace.LocalProject;\n+import io.quarkus.bootstrap.resolver.maven.workspace.ModelUtils;\n+import io.quarkus.bootstrap.resolver.update.DefaultUpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.DependenciesOrigin;\n+import io.quarkus.bootstrap.resolver.update.UpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdate;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdateNumber;\n+import io.quarkus.bootstrap.util.ZipUtils;\n+\n+/**\n+ * The factory that creates the application dependency model.\n+ *\n+ * This is used to build the application class loader.\n+ */\n+public class BootstrapAppModelFactory {\n+\n+    private static final String QUARKUS = \"quarkus\";\n+    private static final String BOOTSTRAP = \"bootstrap\";\n+    private static final String DEPLOYMENT_CP = \"deployment.cp\";\n+\n+    public static final String CREATOR_APP_GROUP_ID = \"creator.app.groupId\";\n+    public static final String CREATOR_APP_ARTIFACT_ID = \"creator.app.artifactId\";\n+    public static final String CREATOR_APP_CLASSIFIER = \"creator.app.classifier\";\n+    public static final String CREATOR_APP_TYPE = \"creator.app.type\";\n+    public static final String CREATOR_APP_VERSION = \"creator.app.version\";\n+\n+    private static final int CP_CACHE_FORMAT_ID = 2;\n+\n+    private static final Logger log = Logger.getLogger(BootstrapAppModelFactory.class);\n+    private AppArtifact managingProject;\n+\n+    public static BootstrapAppModelFactory newInstance() {\n+        return new BootstrapAppModelFactory();\n+    }\n+\n+    private Path appClasses;\n+    private List<Path> appCp = new ArrayList<>(0);\n+    private boolean localProjectsDiscovery;\n+    private Boolean offline;\n+    private boolean enableClasspathCache = false;\n+    private boolean test;\n+    private boolean devMode;\n+    private AppModelResolver bootstrapAppModelResolver;\n+\n+    private VersionUpdateNumber versionUpdateNumber;\n+    private VersionUpdate versionUpdate;\n+    private DependenciesOrigin dependenciesOrigin;\n+    private AppArtifact appArtifact;\n+    private MavenArtifactResolver mavenArtifactResolver;\n+\n+    private BootstrapAppModelFactory() {\n+    }\n+\n+    public BootstrapAppModelFactory setTest(boolean test) {\n+        this.test = test;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDevMode(boolean devMode) {\n+        this.devMode = devMode;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppClasses(Path appClasses) {\n+        this.appClasses = appClasses;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory addToClassPath(Path path) {\n+        this.appCp.add(path);\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setLocalProjectsDiscovery(boolean localProjectsDiscovery) {\n+        this.localProjectsDiscovery = localProjectsDiscovery;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setOffline(Boolean offline) {\n+        this.offline = offline;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setEnableClasspathCache(boolean enable) {\n+        this.enableClasspathCache = enable;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setBootstrapAppModelResolver(AppModelResolver bootstrapAppModelResolver) {\n+        this.bootstrapAppModelResolver = bootstrapAppModelResolver;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdateNumber(VersionUpdateNumber versionUpdateNumber) {\n+        this.versionUpdateNumber = versionUpdateNumber;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdate(VersionUpdate versionUpdate) {\n+        this.versionUpdate = versionUpdate;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDependenciesOrigin(DependenciesOrigin dependenciesOrigin) {\n+        this.dependenciesOrigin = dependenciesOrigin;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppArtifact(AppArtifact appArtifact) {\n+        this.appArtifact = appArtifact;\n+        return this;\n+    }\n+\n+    public AppModelResolver getAppModelResolver() {\n+        try {\n+            if (bootstrapAppModelResolver != null) {\n+                return bootstrapAppModelResolver;\n+            }\n+            if (appClasses == null) {\n+                throw new IllegalArgumentException(\"Application classes path has not been set\");\n+            }\n+            if (!Files.isDirectory(appClasses)) {\n+                final MavenArtifactResolver mvn;\n+                if (mavenArtifactResolver == null) {\n+                    final MavenArtifactResolver.Builder mvnBuilder = MavenArtifactResolver.builder();\n+                    if (offline != null) {\n+                        mvnBuilder.setOffline(offline);\n+                    }\n+                    final LocalProject localProject = localProjectsDiscovery\n+                            ? LocalProject.loadWorkspace(Paths.get(\"\").normalize().toAbsolutePath(), false)\n+                            : null;\n+                    if (localProject != null) {\n+                        mvnBuilder.setWorkspace(localProject.getWorkspace());\n+                        if(managingProject == null) {\n+                            //TODO: big hack, all this needs to be cleaned up\n+                            managingProject = localProject.getAppArtifact();\n+                        }\n+                    }\n+                    mvn = mvnBuilder.build();\n+                } else {\n+                    mvn = mavenArtifactResolver;\n+                }\n+\n+                return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                        .setTest(test)\n+                        .setDevMode(devMode);\n+            }\n+\n+            final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+                    ? LocalProject.loadWorkspace(appClasses, false)\n+                    : LocalProject.load(appClasses, false);\n+\n+            final MavenArtifactResolver mvn;\n+            if(mavenArtifactResolver == null) {\n+                final MavenArtifactResolver.Builder builder = MavenArtifactResolver.builder();\n+                if (localProject != null) {\n+                    builder.setWorkspace(localProject.getWorkspace());\n+                }\n+                if (offline != null) {\n+                    builder.setOffline(offline);\n+                }\n+                mvn = builder.build();\n+            } else {\n+                mvn = mavenArtifactResolver;\n+            }\n+            return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                    .setTest(test)\n+                    .setDevMode(devMode);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create resolver for \" + appClasses, e);\n+        }\n+    }\n+\n+    public CurationResult resolveAppModel() throws BootstrapException {\n+        if (appClasses == null) {\n+            throw new IllegalArgumentException(\"Application classes path has not been set\");\n+        }\n+\n+        if (!Files.isDirectory(appClasses)) {\n+            return createAppModelForJar(appClasses);\n+        }\n+        //        final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+        //                ? LocalProject.loadWorkspace(appClasses)\n+        //                : LocalProject.load(appClasses);\n+        final LocalProject localProject = LocalProject.loadWorkspace(appClasses, false);\n+        if (localProject == null) {\n+            log.warn(\"Unable to locate maven project, falling back to classpath discovery\");\n+            return doClasspathDiscovery();\n+        }\n+        try {\n+            Path cachedCpPath = null;\n+            if (enableClasspathCache) {\n+                cachedCpPath = resolveCachedCpPath(localProject);\n+                if (Files.exists(cachedCpPath)) {\n+                    try (DataInputStream reader = new DataInputStream(Files.newInputStream(cachedCpPath))) {\n+                        if (reader.readInt() == CP_CACHE_FORMAT_ID) {\n+                            if (reader.readInt() == localProject.getWorkspace().getId()) {\n+                                ObjectInputStream in = new ObjectInputStream(reader);\n+                                return new CurationResult((AppModel) in.readObject(), () -> getAppModelResolver());\n+                            } else {\n+                                debug(\"Cached deployment classpath has expired for %s\", localProject.getAppArtifact());\n+                            }\n+                        } else {\n+                            debug(\"Unsupported classpath cache format in %s for %s\", cachedCpPath,\n+                                    localProject.getAppArtifact());\n+                        }\n+                    } catch (IOException e) {\n+                        log.warn(\"Failed to read deployment classpath cache from \" + cachedCpPath + \" for \"\n+                                + localProject.getAppArtifact(), e);\n+                    }\n+                }\n+            }\n+\n+            AppModelResolver appModelResolver = getAppModelResolver();\n+            CurationResult curationResult = new CurationResult(appModelResolver\n+                    .resolveManagedModel(localProject.getAppArtifact(), Collections.emptyList(), managingProject), new FixedSuppler<>(appModelResolver));\n+            if (cachedCpPath != null) {\n+                Files.createDirectories(cachedCpPath.getParent());\n+                try (DataOutputStream out = new DataOutputStream(Files.newOutputStream(cachedCpPath))) {\n+                    out.writeInt(CP_CACHE_FORMAT_ID);\n+                    out.writeInt(localProject.getWorkspace().getId());\n+                    ObjectOutputStream obj = new ObjectOutputStream(out);\n+                    obj.writeObject(curationResult.getAppModel());\n+                } catch (Exception e) {\n+                    log.warn(\"Failed to write classpath cache\", e);\n+                }\n+            }\n+            return curationResult;\n+        } catch (Exception e) {\n+            throw new BootstrapException(\"Failed to create the application model for \" + localProject.getAppArtifact(), e);\n+        }\n+    }\n+\n+    /**\n+     * If no maven project is around do discovery based on the class path.\n+     *\n+     * This is used to run gradle tests, and allows them to run from both the IDE\n+     * and the gradle test task\n+     *\n+     */\n+    private CurationResult doClasspathDiscovery() {\n+        try {\n+            AppModelResolver resolver = getAppModelResolver();\n+\n+            Set<URL> urls = new HashSet<>();\n+            //this is pretty yuck, but under JDK11 the URLClassLoader trick does not work\n+            Enumeration<URL> manifests = Thread.currentThread().getContextClassLoader().getResources(\"META-INF/MANIFEST.MF\");\n+            while (manifests.hasMoreElements()) {\n+                URL url = manifests.nextElement();\n+                if (url.getProtocol().equals(\"jar\")) {\n+                    String path = url.getPath();\n+                    if (path.startsWith(\"file:\")) {\n+                        path = path.substring(5, path.lastIndexOf('!'));\n+                        urls.add(new File(URLDecoder.decode(path, StandardCharsets.UTF_8.name())).toURI().toURL());\n+                    }\n+                }\n+            }\n+            List<AppDependency> artifacts = new ArrayList<>();\n+            for (URL jarUrl : urls) {\n+                try (JarInputStream file = new JarInputStream(jarUrl.openConnection().getInputStream())) {\n+                    JarEntry entry = file.getNextJarEntry();\n+                    while (entry != null) {\n+                        if (entry.getName().endsWith(\"/pom.properties\") && entry.getName().startsWith(\"META-INF/maven\")) {\n+                            Properties p = new Properties();\n+                            p.load(file);\n+                            AppArtifact artifact = new AppArtifact(p.getProperty(\"groupId\"),\n+                                    p.getProperty(\"artifactId\"),\n+                                    p.getProperty(\"classifier\"),\n+                                    \"jar\",\n+                                    p.getProperty(\"version\"));\n+                            artifact.setPath(Paths.get(jarUrl.toURI()));\n+                            artifacts.add(\n+                                    new AppDependency(artifact, \"compile\"));\n+                        }\n+                        entry = file.getNextJarEntry();\n+                    }\n+                }\n+            }\n+\n+            //we now have our deployment time artifacts, lets resolve all their deps\n+            AppModel model = resolver.resolveManagedModel(appArtifact, artifacts, managingProject);", "originalCommit": "5616a758fac6a29df2ad5a052cafbc50fe47cfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4ODI3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r366988276", "bodyText": "Could you please change it to .log.debugf(...) instead?", "author": "aloubyansky", "createdAt": "2020-01-15T16:50:48Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -0,0 +1,522 @@\n+package io.quarkus.bootstrap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.net.URL;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.model.Model;\n+import org.eclipse.aether.repository.RepositoryPolicy;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CurationResult;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.bootstrap.model.AppDependency;\n+import io.quarkus.bootstrap.model.AppModel;\n+import io.quarkus.bootstrap.resolver.AppModelResolver;\n+import io.quarkus.bootstrap.resolver.AppModelResolverException;\n+import io.quarkus.bootstrap.resolver.BootstrapAppModelResolver;\n+import io.quarkus.bootstrap.resolver.maven.MavenArtifactResolver;\n+import io.quarkus.bootstrap.resolver.maven.workspace.LocalProject;\n+import io.quarkus.bootstrap.resolver.maven.workspace.ModelUtils;\n+import io.quarkus.bootstrap.resolver.update.DefaultUpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.DependenciesOrigin;\n+import io.quarkus.bootstrap.resolver.update.UpdateDiscovery;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdate;\n+import io.quarkus.bootstrap.resolver.update.VersionUpdateNumber;\n+import io.quarkus.bootstrap.util.ZipUtils;\n+\n+/**\n+ * The factory that creates the application dependency model.\n+ *\n+ * This is used to build the application class loader.\n+ */\n+public class BootstrapAppModelFactory {\n+\n+    private static final String QUARKUS = \"quarkus\";\n+    private static final String BOOTSTRAP = \"bootstrap\";\n+    private static final String DEPLOYMENT_CP = \"deployment.cp\";\n+\n+    public static final String CREATOR_APP_GROUP_ID = \"creator.app.groupId\";\n+    public static final String CREATOR_APP_ARTIFACT_ID = \"creator.app.artifactId\";\n+    public static final String CREATOR_APP_CLASSIFIER = \"creator.app.classifier\";\n+    public static final String CREATOR_APP_TYPE = \"creator.app.type\";\n+    public static final String CREATOR_APP_VERSION = \"creator.app.version\";\n+\n+    private static final int CP_CACHE_FORMAT_ID = 2;\n+\n+    private static final Logger log = Logger.getLogger(BootstrapAppModelFactory.class);\n+    private AppArtifact managingProject;\n+\n+    public static BootstrapAppModelFactory newInstance() {\n+        return new BootstrapAppModelFactory();\n+    }\n+\n+    private Path appClasses;\n+    private List<Path> appCp = new ArrayList<>(0);\n+    private boolean localProjectsDiscovery;\n+    private Boolean offline;\n+    private boolean enableClasspathCache = false;\n+    private boolean test;\n+    private boolean devMode;\n+    private AppModelResolver bootstrapAppModelResolver;\n+\n+    private VersionUpdateNumber versionUpdateNumber;\n+    private VersionUpdate versionUpdate;\n+    private DependenciesOrigin dependenciesOrigin;\n+    private AppArtifact appArtifact;\n+    private MavenArtifactResolver mavenArtifactResolver;\n+\n+    private BootstrapAppModelFactory() {\n+    }\n+\n+    public BootstrapAppModelFactory setTest(boolean test) {\n+        this.test = test;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDevMode(boolean devMode) {\n+        this.devMode = devMode;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppClasses(Path appClasses) {\n+        this.appClasses = appClasses;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory addToClassPath(Path path) {\n+        this.appCp.add(path);\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setLocalProjectsDiscovery(boolean localProjectsDiscovery) {\n+        this.localProjectsDiscovery = localProjectsDiscovery;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setOffline(Boolean offline) {\n+        this.offline = offline;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setEnableClasspathCache(boolean enable) {\n+        this.enableClasspathCache = enable;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setBootstrapAppModelResolver(AppModelResolver bootstrapAppModelResolver) {\n+        this.bootstrapAppModelResolver = bootstrapAppModelResolver;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdateNumber(VersionUpdateNumber versionUpdateNumber) {\n+        this.versionUpdateNumber = versionUpdateNumber;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setVersionUpdate(VersionUpdate versionUpdate) {\n+        this.versionUpdate = versionUpdate;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setDependenciesOrigin(DependenciesOrigin dependenciesOrigin) {\n+        this.dependenciesOrigin = dependenciesOrigin;\n+        return this;\n+    }\n+\n+    public BootstrapAppModelFactory setAppArtifact(AppArtifact appArtifact) {\n+        this.appArtifact = appArtifact;\n+        return this;\n+    }\n+\n+    public AppModelResolver getAppModelResolver() {\n+        try {\n+            if (bootstrapAppModelResolver != null) {\n+                return bootstrapAppModelResolver;\n+            }\n+            if (appClasses == null) {\n+                throw new IllegalArgumentException(\"Application classes path has not been set\");\n+            }\n+            if (!Files.isDirectory(appClasses)) {\n+                final MavenArtifactResolver mvn;\n+                if (mavenArtifactResolver == null) {\n+                    final MavenArtifactResolver.Builder mvnBuilder = MavenArtifactResolver.builder();\n+                    if (offline != null) {\n+                        mvnBuilder.setOffline(offline);\n+                    }\n+                    final LocalProject localProject = localProjectsDiscovery\n+                            ? LocalProject.loadWorkspace(Paths.get(\"\").normalize().toAbsolutePath(), false)\n+                            : null;\n+                    if (localProject != null) {\n+                        mvnBuilder.setWorkspace(localProject.getWorkspace());\n+                        if(managingProject == null) {\n+                            //TODO: big hack, all this needs to be cleaned up\n+                            managingProject = localProject.getAppArtifact();\n+                        }\n+                    }\n+                    mvn = mvnBuilder.build();\n+                } else {\n+                    mvn = mavenArtifactResolver;\n+                }\n+\n+                return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                        .setTest(test)\n+                        .setDevMode(devMode);\n+            }\n+\n+            final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+                    ? LocalProject.loadWorkspace(appClasses, false)\n+                    : LocalProject.load(appClasses, false);\n+\n+            final MavenArtifactResolver mvn;\n+            if(mavenArtifactResolver == null) {\n+                final MavenArtifactResolver.Builder builder = MavenArtifactResolver.builder();\n+                if (localProject != null) {\n+                    builder.setWorkspace(localProject.getWorkspace());\n+                }\n+                if (offline != null) {\n+                    builder.setOffline(offline);\n+                }\n+                mvn = builder.build();\n+            } else {\n+                mvn = mavenArtifactResolver;\n+            }\n+            return bootstrapAppModelResolver = new BootstrapAppModelResolver(mvn)\n+                    .setTest(test)\n+                    .setDevMode(devMode);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create resolver for \" + appClasses, e);\n+        }\n+    }\n+\n+    public CurationResult resolveAppModel() throws BootstrapException {\n+        if (appClasses == null) {\n+            throw new IllegalArgumentException(\"Application classes path has not been set\");\n+        }\n+\n+        if (!Files.isDirectory(appClasses)) {\n+            return createAppModelForJar(appClasses);\n+        }\n+        //        final LocalProject localProject = localProjectsDiscovery || enableClasspathCache\n+        //                ? LocalProject.loadWorkspace(appClasses)\n+        //                : LocalProject.load(appClasses);\n+        final LocalProject localProject = LocalProject.loadWorkspace(appClasses, false);\n+        if (localProject == null) {\n+            log.warn(\"Unable to locate maven project, falling back to classpath discovery\");\n+            return doClasspathDiscovery();\n+        }\n+        try {\n+            Path cachedCpPath = null;\n+            if (enableClasspathCache) {\n+                cachedCpPath = resolveCachedCpPath(localProject);\n+                if (Files.exists(cachedCpPath)) {\n+                    try (DataInputStream reader = new DataInputStream(Files.newInputStream(cachedCpPath))) {\n+                        if (reader.readInt() == CP_CACHE_FORMAT_ID) {\n+                            if (reader.readInt() == localProject.getWorkspace().getId()) {\n+                                ObjectInputStream in = new ObjectInputStream(reader);\n+                                return new CurationResult((AppModel) in.readObject(), () -> getAppModelResolver());\n+                            } else {\n+                                debug(\"Cached deployment classpath has expired for %s\", localProject.getAppArtifact());\n+                            }\n+                        } else {\n+                            debug(\"Unsupported classpath cache format in %s for %s\", cachedCpPath,\n+                                    localProject.getAppArtifact());\n+                        }\n+                    } catch (IOException e) {\n+                        log.warn(\"Failed to read deployment classpath cache from \" + cachedCpPath + \" for \"\n+                                + localProject.getAppArtifact(), e);\n+                    }\n+                }\n+            }\n+\n+            AppModelResolver appModelResolver = getAppModelResolver();\n+            CurationResult curationResult = new CurationResult(appModelResolver\n+                    .resolveManagedModel(localProject.getAppArtifact(), Collections.emptyList(), managingProject), new FixedSuppler<>(appModelResolver));\n+            if (cachedCpPath != null) {\n+                Files.createDirectories(cachedCpPath.getParent());\n+                try (DataOutputStream out = new DataOutputStream(Files.newOutputStream(cachedCpPath))) {\n+                    out.writeInt(CP_CACHE_FORMAT_ID);\n+                    out.writeInt(localProject.getWorkspace().getId());\n+                    ObjectOutputStream obj = new ObjectOutputStream(out);\n+                    obj.writeObject(curationResult.getAppModel());\n+                } catch (Exception e) {\n+                    log.warn(\"Failed to write classpath cache\", e);\n+                }\n+            }\n+            return curationResult;\n+        } catch (Exception e) {\n+            throw new BootstrapException(\"Failed to create the application model for \" + localProject.getAppArtifact(), e);\n+        }\n+    }\n+\n+    /**\n+     * If no maven project is around do discovery based on the class path.\n+     *\n+     * This is used to run gradle tests, and allows them to run from both the IDE\n+     * and the gradle test task\n+     *\n+     */\n+    private CurationResult doClasspathDiscovery() {\n+        try {\n+            AppModelResolver resolver = getAppModelResolver();\n+\n+            Set<URL> urls = new HashSet<>();\n+            //this is pretty yuck, but under JDK11 the URLClassLoader trick does not work\n+            Enumeration<URL> manifests = Thread.currentThread().getContextClassLoader().getResources(\"META-INF/MANIFEST.MF\");\n+            while (manifests.hasMoreElements()) {\n+                URL url = manifests.nextElement();\n+                if (url.getProtocol().equals(\"jar\")) {\n+                    String path = url.getPath();\n+                    if (path.startsWith(\"file:\")) {\n+                        path = path.substring(5, path.lastIndexOf('!'));\n+                        urls.add(new File(URLDecoder.decode(path, StandardCharsets.UTF_8.name())).toURI().toURL());\n+                    }\n+                }\n+            }\n+            List<AppDependency> artifacts = new ArrayList<>();\n+            for (URL jarUrl : urls) {\n+                try (JarInputStream file = new JarInputStream(jarUrl.openConnection().getInputStream())) {\n+                    JarEntry entry = file.getNextJarEntry();\n+                    while (entry != null) {\n+                        if (entry.getName().endsWith(\"/pom.properties\") && entry.getName().startsWith(\"META-INF/maven\")) {\n+                            Properties p = new Properties();\n+                            p.load(file);\n+                            AppArtifact artifact = new AppArtifact(p.getProperty(\"groupId\"),\n+                                    p.getProperty(\"artifactId\"),\n+                                    p.getProperty(\"classifier\"),\n+                                    \"jar\",\n+                                    p.getProperty(\"version\"));\n+                            artifact.setPath(Paths.get(jarUrl.toURI()));\n+                            artifacts.add(\n+                                    new AppDependency(artifact, \"compile\"));\n+                        }\n+                        entry = file.getNextJarEntry();\n+                    }\n+                }\n+            }\n+\n+            //we now have our deployment time artifacts, lets resolve all their deps\n+            AppModel model = resolver.resolveManagedModel(appArtifact, artifacts, managingProject);\n+            return new CurationResult(model, new FixedSuppler<>(resolver));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private CurationResult createAppModelForJar(Path appArtifactPath) {\n+        log.debug(\"provideOutcome depsOrigin=\" + dependenciesOrigin + \", versionUpdate=\" + versionUpdate\n+                + \", versionUpdateNumber=\"\n+                + versionUpdateNumber);", "originalCommit": "5616a758fac6a29df2ad5a052cafbc50fe47cfe7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMxOTE5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r367319196", "bodyText": "Wouldn't it be safer and perhaps more efficient to look for that file in appClasses? Now that the file is created in the classes dir, it will end up in the jar, right? Just wondering whether there could be multiple files on the classpath.", "author": "aloubyansky", "createdAt": "2020-01-16T09:43:11Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -212,6 +213,18 @@ public AppModelResolver getAppModelResolver() {\n     }\n \n     public CurationResult resolveAppModel() throws BootstrapException {\n+        if (test) {\n+            //gradle tests encode the result on the class path\n+\n+            try (InputStream existing = getClass().getResourceAsStream(BootstrapConstants.SERIALIZED_APP_MODEL)){", "originalCommit": "c4a1b4bcd6af89e6763f32af6d8fa8fe5ac5e8e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0MzQzNA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r367343434", "bodyText": "It is created in the test class directory, so it should not end up in the jar. It does stay on the file system though so if you attempt to run a test from the IDE after a build it should still be picked up.", "author": "stuartwdouglas", "createdAt": "2020-01-16T10:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMxOTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDgxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r367320819", "bodyText": "Is there a test or specific use-case this is fixing in our build or TS?", "author": "aloubyansky", "createdAt": "2020-01-16T09:46:40Z", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/classloading/QuarkusClassLoader.java", "diffHunk": "@@ -274,8 +274,17 @@ public InputStream getResourceAsStream(String nm) {\n                         data = handleTransform(name, data, transformers);\n                     }\n                     definePackage(name);\n-                    return defineClass(name, data, 0, data.length,\n-                            protectionDomains.computeIfAbsent(classPathElement, (ce) -> ce.getProtectionDomain(this)));\n+                    try {\n+                        return defineClass(name, data, 0, data.length,\n+                                protectionDomains.computeIfAbsent(classPathElement, (ce) -> ce.getProtectionDomain(this)));\n+                    } catch (LinkageError e) {\n+                        //TODO: is this a good idea?\n+                        //if we are already the initiating loader we might want to load this from the parent\n+                        if (!parentFirst) {\n+                            return parent.loadClass(name);\n+                        }", "originalCommit": "339719ec76c288e507c4d03c732d12cbd7c07b62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0Mjc3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r367342779", "bodyText": "This fixes some issues in the camel test suite that I am still investigating.", "author": "stuartwdouglas", "createdAt": "2020-01-16T10:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc2MjgyNA==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368762824", "bodyText": "I have removed this. The issue in Camel is that they are packaging parts of XML parsers, e.g. a jar contains a copy of QName but not the parser that is using it. This causes problems as the parser uses the JDK version of QName but the app sees the copy in the isolated ClassLoader.\nOnce this is in I am planning on working with the camel team to resolve it.", "author": "stuartwdouglas", "createdAt": "2020-01-21T00:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDgxOQ=="}], "type": "inlineReview"}, {"oid": "bcd4042d3071a4893936fe09b6309c3a6d04da14", "url": "https://github.com/quarkusio/quarkus/commit/bcd4042d3071a4893936fe09b6309c3a6d04da14", "message": "Class loading changes", "committedDate": "2020-01-17T03:00:17Z", "type": "forcePushed"}, {"oid": "2f44ba9be05411753d899d05d99f36d2e0208598", "url": "https://github.com/quarkusio/quarkus/commit/2f44ba9be05411753d899d05d99f36d2e0208598", "message": "Fix tests", "committedDate": "2020-01-20T05:06:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcyODcxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368728711", "bodyText": "#6663 updates to 5.6.0. It would be nice to rebase once that PR is merged", "author": "gastaldi", "createdAt": "2020-01-20T21:17:48Z", "path": "bom/runtime/pom.xml", "diffHunk": "@@ -114,7 +114,7 @@\n         <derby-jdbc.version>10.14.2.0</derby-jdbc.version>\n         <shrinkwrap.version>1.2.6</shrinkwrap.version>\n         <rest-assured.version>4.1.2</rest-assured.version>\n-        <junit.jupiter.version>5.5.2</junit.jupiter.version>\n+        <junit.jupiter.version>5.6.0-RC1</junit.jupiter.version>", "originalCommit": "2f44ba9be05411753d899d05d99f36d2e0208598", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "43421a909df132858e4eb8fcaf71810ad234c90a", "url": "https://github.com/quarkusio/quarkus/commit/43421a909df132858e4eb8fcaf71810ad234c90a", "message": "tmp", "committedDate": "2020-01-20T23:21:11Z", "type": "forcePushed"}, {"oid": "c17a597ff4e84ed48c408ca2b26f3873205dafb5", "url": "https://github.com/quarkusio/quarkus/commit/c17a597ff4e84ed48c408ca2b26f3873205dafb5", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-20T23:48:01Z", "type": "forcePushed"}, {"oid": "cab35894c61e5e1c727b4ffe8f507ac4ed3c332f", "url": "https://github.com/quarkusio/quarkus/commit/cab35894c61e5e1c727b4ffe8f507ac4ed3c332f", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-21T00:04:05Z", "type": "forcePushed"}, {"oid": "f4aa3ffa6f6bd629a997bb072c941be48e43327a", "url": "https://github.com/quarkusio/quarkus/commit/f4aa3ffa6f6bd629a997bb072c941be48e43327a", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-21T04:06:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MzY4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368863681", "bodyText": "Shouldn't it be deleted in the finally?", "author": "aloubyansky", "createdAt": "2020-01-21T08:28:50Z", "path": "core/deployment/src/main/java/io/quarkus/runner/bootstrap/GenerateConfigTask.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package io.quarkus.runner.bootstrap;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.builder.BuildChainBuilder;\n+import io.quarkus.builder.BuildExecutionBuilder;\n+import io.quarkus.builder.BuildResult;\n+import io.quarkus.deployment.builditem.ArchiveRootBuildItem;\n+import io.quarkus.deployment.builditem.ConfigDescriptionBuildItem;\n+\n+/**\n+ * This phase generates an example configuration file\n+ *\n+ * @author Stuart Douglas\n+ */\n+public class GenerateConfigTask {\n+\n+    private static final Logger log = Logger.getLogger(GenerateConfigTask.class);\n+\n+    private final Path configFile;\n+\n+    public GenerateConfigTask(Path configFile) {\n+        this.configFile = configFile;\n+    }\n+\n+    public Path run(CuratedApplication application) {\n+        //first lets look for some config, as it is not on the current class path\n+        //and we need to load it to run the build process\n+        try {\n+            Path temp = Files.createTempDirectory(\"empty\");\n+            AugmentActionImpl augmentAction = new AugmentActionImpl(application, Collections.emptyList());\n+            BuildResult buildResult = augmentAction.runCustomAction(new Consumer<BuildChainBuilder>() {\n+                @Override\n+                public void accept(BuildChainBuilder chainBuilder) {\n+                    chainBuilder.addFinal(ConfigDescriptionBuildItem.class);\n+                    chainBuilder.addInitial(ArchiveRootBuildItem.class);\n+                }\n+            }, new Consumer<BuildExecutionBuilder>() {\n+                @Override\n+                public void accept(BuildExecutionBuilder buildExecutionBuilder) {\n+                    buildExecutionBuilder.produce(new ArchiveRootBuildItem(temp));\n+                }\n+            });\n+\n+            List<ConfigDescriptionBuildItem> descriptions = buildResult.consumeMulti(ConfigDescriptionBuildItem.class);\n+            Collections.sort(descriptions);\n+\n+            String existing = \"\";\n+            if (Files.exists(configFile)) {\n+                existing = new String(Files.readAllBytes(configFile), StandardCharsets.UTF_8);\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            for (ConfigDescriptionBuildItem i : descriptions) {\n+                //we don't want to add these if they already exist\n+                //either in commended or uncommented form\n+                if (existing.contains(\"\\n\" + i.getPropertyName() + \"=\") ||\n+                        existing.contains(\"\\n#\" + i.getPropertyName() + \"=\")) {\n+                    continue;\n+                }\n+\n+                sb.append(\"\\n#\\n\");\n+                sb.append(formatDocs(i.getDocs()));\n+                sb.append(\"\\n#\\n#\");\n+                sb.append(i.getPropertyName() + \"=\" + i.getDefaultValue());\n+                sb.append(\"\\n\");\n+            }\n+\n+            Files.createDirectories(configFile.getParent());\n+            Files.write(configFile, sb.toString().getBytes(StandardCharsets.UTF_8),\n+                    Files.exists(configFile) ? new OpenOption[] { StandardOpenOption.APPEND } : new OpenOption[] {});\n+            Files.deleteIfExists(temp);", "originalCommit": "f4aa3ffa6f6bd629a997bb072c941be48e43327a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2NjM2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6411#discussion_r368866367", "bodyText": "Does it really have to be a Throwable? Swallowing throwables in a loop may go pretty bad.", "author": "aloubyansky", "createdAt": "2020-01-21T08:35:55Z", "path": "core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java", "diffHunk": "@@ -0,0 +1,170 @@\n+package io.quarkus.runner.bootstrap;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+import org.jboss.logging.Logger;\n+import org.objectweb.asm.ClassVisitor;\n+\n+import io.quarkus.bootstrap.app.CuratedApplication;\n+import io.quarkus.bootstrap.app.QuarkusBootstrap;\n+import io.quarkus.bootstrap.app.RunningQuarkusApplication;\n+import io.quarkus.bootstrap.app.StartupAction;\n+import io.quarkus.bootstrap.classloading.QuarkusClassLoader;\n+import io.quarkus.builder.BuildResult;\n+import io.quarkus.deployment.builditem.ApplicationClassNameBuildItem;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.DeploymentClassLoaderBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedClassBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.configuration.RunTimeConfigurationGenerator;\n+\n+public class StartupActionImpl implements StartupAction {\n+\n+    private static final Logger log = Logger.getLogger(StartupActionImpl.class);\n+\n+    static final String DEBUG_CLASSES_DIR = System.getProperty(\"quarkus.debug.generated-classes-dir\");\n+\n+    private final CuratedApplication curatedApplication;\n+    private final BuildResult buildResult;\n+\n+    public StartupActionImpl(CuratedApplication curatedApplication, BuildResult buildResult) {\n+        this.curatedApplication = curatedApplication;\n+        this.buildResult = buildResult;\n+    }\n+\n+    /**\n+     * Runs the application, and returns a handle that can be used to shut it down.\n+     */\n+    public RunningQuarkusApplication run(String... args) throws Exception {\n+        //first\n+        Map<String, List<BiFunction<String, ClassVisitor, ClassVisitor>>> bytecodeTransformers = extractTransformers();\n+        QuarkusClassLoader baseClassLoader = curatedApplication.getBaseRuntimeClassLoader();\n+        ClassLoader transformerClassLoader = buildResult.consume(DeploymentClassLoaderBuildItem.class).getClassLoader();\n+        QuarkusClassLoader runtimeClassLoader;\n+\n+        //so we have some differences between dev and test mode here.\n+        //test mode only has a single class loader, while dev uses a disposable runtime class loader\n+        //that is discarded between restarts\n+        if (curatedApplication.getQuarkusBootstrap().getMode() == QuarkusBootstrap.Mode.DEV) {\n+            baseClassLoader.reset(extractGeneratedResources(false), bytecodeTransformers, transformerClassLoader);\n+            runtimeClassLoader = curatedApplication.createRuntimeClassLoader(baseClassLoader,\n+                    bytecodeTransformers,\n+                    transformerClassLoader, extractGeneratedResources(true));\n+        } else {\n+            Map<String, byte[]> resources = new HashMap<>();\n+            resources.putAll(extractGeneratedResources(false));\n+            resources.putAll(extractGeneratedResources(true));\n+            baseClassLoader.reset(resources, bytecodeTransformers, transformerClassLoader);\n+            runtimeClassLoader = baseClassLoader;\n+        }\n+\n+        //we have our class loaders\n+        ClassLoader old = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(runtimeClassLoader);\n+            final String className = buildResult.consume(ApplicationClassNameBuildItem.class).getClassName();\n+            Class<?> appClass;\n+            try {\n+                // force init here\n+                appClass = Class.forName(className, true, runtimeClassLoader);\n+            } catch (Throwable t) {\n+                // todo: dev mode expects run time config to be available immediately even if static init didn't complete.\n+                try {\n+                    final Class<?> configClass = Class.forName(RunTimeConfigurationGenerator.CONFIG_CLASS_NAME, true,\n+                            runtimeClassLoader);\n+                    configClass.getDeclaredMethod(RunTimeConfigurationGenerator.C_CREATE_RUN_TIME_CONFIG.getName())\n+                            .invoke(null);\n+                } catch (Throwable t2) {\n+                    t.addSuppressed(t2);\n+                }\n+                throw t;\n+            }\n+\n+            Method start = appClass.getMethod(\"start\", String[].class);\n+            Object application = appClass.newInstance();\n+            start.invoke(application, (Object) args);\n+            Closeable closeTask = (Closeable) application;\n+            return new RunningQuarkusApplicationImpl(new Closeable() {\n+                @Override\n+                public void close() throws IOException {\n+                    try {\n+                        try {\n+                            closeTask.close();\n+                        } finally {\n+                            runtimeClassLoader.close();\n+                        }\n+                    } finally {\n+                        if (curatedApplication.getQuarkusBootstrap().getMode() == QuarkusBootstrap.Mode.TEST) {\n+                            //for tests we just always shut down the curated application, as it is only used once\n+                            //dev mode might be about to restart, so we leave it\n+                            curatedApplication.close();\n+                        }\n+                    }\n+                }\n+            }, runtimeClassLoader);\n+        } catch (InvocationTargetException e) {\n+            if (e.getCause() instanceof Exception) {\n+                throw (Exception) e.getCause();\n+            }\n+            throw new RuntimeException(\"Failed to start Quarkus\", e.getCause());\n+        } finally {\n+            Thread.currentThread().setContextClassLoader(old);\n+        }\n+\n+    }\n+\n+    private Map<String, List<BiFunction<String, ClassVisitor, ClassVisitor>>> extractTransformers() {\n+        Map<String, List<BiFunction<String, ClassVisitor, ClassVisitor>>> bytecodeTransformers = new HashMap<>();\n+        List<BytecodeTransformerBuildItem> transformers = buildResult.consumeMulti(BytecodeTransformerBuildItem.class);\n+        for (BytecodeTransformerBuildItem i : transformers) {\n+            List<BiFunction<String, ClassVisitor, ClassVisitor>> list = bytecodeTransformers.get(i.getClassToTransform());\n+            if (list == null) {\n+                bytecodeTransformers.put(i.getClassToTransform(), list = new ArrayList<>());\n+            }\n+            list.add(i.getVisitorFunction());\n+        }\n+        return bytecodeTransformers;\n+    }\n+\n+    private Map<String, byte[]> extractGeneratedResources(boolean applicationClasses) {\n+        Map<String, byte[]> data = new HashMap<>();\n+        for (GeneratedClassBuildItem i : buildResult.consumeMulti(GeneratedClassBuildItem.class)) {\n+            if (i.isApplicationClass() == applicationClasses) {\n+                data.put(i.getName().replace(\".\", \"/\") + \".class\", i.getClassData());\n+                if (DEBUG_CLASSES_DIR != null) {\n+                    try {\n+                        File debugPath = new File(DEBUG_CLASSES_DIR);\n+                        if (!debugPath.exists()) {\n+                            debugPath.mkdir();\n+                        }\n+                        File classFile = new File(debugPath, i.getName() + \".class\");\n+                        classFile.getParentFile().mkdirs();\n+                        try (FileOutputStream classWriter = new FileOutputStream(classFile)) {\n+                            classWriter.write(i.getClassData());\n+                        }\n+                        log.infof(\"Wrote %s\", classFile.getAbsolutePath());\n+                    } catch (Throwable t) {", "originalCommit": "f4aa3ffa6f6bd629a997bb072c941be48e43327a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1de60280b9b78b58da6db2443145712f6b7f4e38", "url": "https://github.com/quarkusio/quarkus/commit/1de60280b9b78b58da6db2443145712f6b7f4e38", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-21T10:51:01Z", "type": "forcePushed"}, {"oid": "1553a1df2d5fe7e780f70b607d925dcc56a4c94f", "url": "https://github.com/quarkusio/quarkus/commit/1553a1df2d5fe7e780f70b607d925dcc56a4c94f", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-21T11:46:46Z", "type": "forcePushed"}, {"oid": "ee8849718aad3bebc455f7eb2050accbd9ee67ab", "url": "https://github.com/quarkusio/quarkus/commit/ee8849718aad3bebc455f7eb2050accbd9ee67ab", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-21T11:51:12Z", "type": "forcePushed"}, {"oid": "42b150775c9759b5a3331628db73d593984232b6", "url": "https://github.com/quarkusio/quarkus/commit/42b150775c9759b5a3331628db73d593984232b6", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-21T20:34:22Z", "type": "forcePushed"}, {"oid": "06f1833edd00fe30def6576238a558031de8ee4a", "url": "https://github.com/quarkusio/quarkus/commit/06f1833edd00fe30def6576238a558031de8ee4a", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-22T00:42:41Z", "type": "forcePushed"}, {"oid": "751414c9ccc0ae6a3f34a868036461fbf24086a5", "url": "https://github.com/quarkusio/quarkus/commit/751414c9ccc0ae6a3f34a868036461fbf24086a5", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-22T04:36:29Z", "type": "forcePushed"}, {"oid": "a0d6e822c18bed8cf069999216ead48b1dac7747", "url": "https://github.com/quarkusio/quarkus/commit/a0d6e822c18bed8cf069999216ead48b1dac7747", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-22T07:39:14Z", "type": "forcePushed"}, {"oid": "9b735482b7dd3ca73f5dfa41ee90c7433748b3eb", "url": "https://github.com/quarkusio/quarkus/commit/9b735482b7dd3ca73f5dfa41ee90c7433748b3eb", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-22T10:34:17Z", "type": "forcePushed"}, {"oid": "b67491c1ffe76248d5f01bc3e29be94c2cdd56a4", "url": "https://github.com/quarkusio/quarkus/commit/b67491c1ffe76248d5f01bc3e29be94c2cdd56a4", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-22T12:30:44Z", "type": "commit"}, {"oid": "b67491c1ffe76248d5f01bc3e29be94c2cdd56a4", "url": "https://github.com/quarkusio/quarkus/commit/b67491c1ffe76248d5f01bc3e29be94c2cdd56a4", "message": "The big ClassLoader change\n\nThis changes the way Quarkus ClassLoading works,\nto allow for isolated class loaders.\n\nIt also unifies how Quarkus is launched, so every\ndifferent mode we support uses the same mechanism\nfor both curation and launch.\n\nTests are now run in an isolated ClassLoader, which\nmeans that a proxy is created that runs the tests\nfrom within the isolated ClassLoader. This currently\nhas a quirk where @BeforeAll methods are run twice,\nwhich will be fixed in the next JUnit release. This\ncan be worked around by using @QuarkusBeforeAll.", "committedDate": "2020-01-22T12:30:44Z", "type": "forcePushed"}]}