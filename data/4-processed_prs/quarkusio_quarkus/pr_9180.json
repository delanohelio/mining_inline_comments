{"pr_number": 9180, "pr_title": "Create picocli extension", "pr_createdAt": "2020-05-08T13:51:32Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9180", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNDIxMA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422214210", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n          \n          \n            \n            IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode reference guide] first.", "author": "gsmet", "createdAt": "2020-05-08T15:37:58Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNDY0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422214649", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n          \n          \n            \n            <2> All classes annotated with `picocli.CommandLine.Command` are registered as CDI beans.", "author": "gsmet", "createdAt": "2020-05-08T15:38:45Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNDg3MA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422214870", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n          \n          \n            \n            When multiple classes have the `picocli.CommandLine.Command` annotation, then one of them needs to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.", "author": "gsmet", "createdAt": "2020-05-08T15:39:08Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNDk4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422214981", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This can be overwritten with `quarkus.picocli.top-command` property.\n          \n          \n            \n            This can be overwritten with the `quarkus.picocli.top-command` property.", "author": "gsmet", "createdAt": "2020-05-08T15:39:19Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with `quarkus.picocli.top-command` property.", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNTIzMg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422215232", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can customize CommandLine classes used by `picocli` extension by producing your own bean instance:\n          \n          \n            \n            You can customize CommandLine classes used by the `picocli` extension by producing your own bean instance:", "author": "gsmet", "createdAt": "2020-05-08T15:39:45Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with `quarkus.picocli.top-command` property.\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@TopCommand\n+@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})\n+public class EntryCommand {\n+}\n+\n+@CommandLine.Command(name = \"hello\", description = \"Greet World!\")\n+class HelloCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Hello World!\");\n+    }\n+}\n+\n+@CommandLine.Command(name = \"goodbye\", description = \"Say goodbye to World!\")\n+class GoodByeCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Goodbye World!\");\n+    }\n+}\n+----\n+\n+== Customizing Picocli CommandLine instance\n+\n+You can customize CommandLine classes used by `picocli` extension by producing your own bean instance:", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNTQ4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422215489", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Picocli tool provides annotation processor which will generate a configuration for GraalVM Native images.\n          \n          \n            \n            The Picocli tool provides an annotation processor which will generate a configuration for GraalVM Native images.", "author": "gsmet", "createdAt": "2020-05-08T15:40:14Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with `quarkus.picocli.top-command` property.\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@TopCommand\n+@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})\n+public class EntryCommand {\n+}\n+\n+@CommandLine.Command(name = \"hello\", description = \"Greet World!\")\n+class HelloCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Hello World!\");\n+    }\n+}\n+\n+@CommandLine.Command(name = \"goodbye\", description = \"Say goodbye to World!\")\n+class GoodByeCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Goodbye World!\");\n+    }\n+}\n+----\n+\n+== Customizing Picocli CommandLine instance\n+\n+You can customize CommandLine classes used by `picocli` extension by producing your own bean instance:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.PicocliCommandLineFactory;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+@TopCommand\n+@CommandLine.Command\n+public class EntryCommand implements Runnable {\n+    @CommandLine.Spec\n+    CommandLine.Model.CommandSpec spec;\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"My name is: \" + spec.name());\n+    }\n+}\n+\n+@ApplicationScoped\n+class CustomConfiguration {\n+\n+    @Produces\n+    CommandLine customCommandLine(PicocliCommandLineFactory factory) { // <1>\n+        return factory.create().setCommandName(\"CustomizedName\");\n+    }\n+}\n+----\n+<1> `PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.\n+\n+== Native mode support\n+\n+Picocli tool provides annotation processor which will generate a configuration for GraalVM Native images.", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNTYzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422215639", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For gradle you need to add following in `dependencies` section of `build.gradle` file:\n          \n          \n            \n            For Gradle you need to add the following in the `dependencies` section of the `build.gradle` file:", "author": "gsmet", "createdAt": "2020-05-08T15:40:29Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with `quarkus.picocli.top-command` property.\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@TopCommand\n+@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})\n+public class EntryCommand {\n+}\n+\n+@CommandLine.Command(name = \"hello\", description = \"Greet World!\")\n+class HelloCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Hello World!\");\n+    }\n+}\n+\n+@CommandLine.Command(name = \"goodbye\", description = \"Say goodbye to World!\")\n+class GoodByeCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Goodbye World!\");\n+    }\n+}\n+----\n+\n+== Customizing Picocli CommandLine instance\n+\n+You can customize CommandLine classes used by `picocli` extension by producing your own bean instance:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.PicocliCommandLineFactory;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+@TopCommand\n+@CommandLine.Command\n+public class EntryCommand implements Runnable {\n+    @CommandLine.Spec\n+    CommandLine.Model.CommandSpec spec;\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"My name is: \" + spec.name());\n+    }\n+}\n+\n+@ApplicationScoped\n+class CustomConfiguration {\n+\n+    @Produces\n+    CommandLine customCommandLine(PicocliCommandLineFactory factory) { // <1>\n+        return factory.create().setCommandName(\"CustomizedName\");\n+    }\n+}\n+----\n+<1> `PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.\n+\n+== Native mode support\n+\n+Picocli tool provides annotation processor which will generate a configuration for GraalVM Native images.\n+To use this annotation processor you need to add following dependency to `pom.xml` file:\n+\n+[source,xml]\n+--\n+<dependency>\n+  <groupId>info.picocli</groupId>\n+  <artifactId>picocli-codegen</artifactId>\n+</dependency>\n+--\n+\n+For gradle you need to add following in `dependencies` section of `build.gradle` file:", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNTk2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422215962", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To use this annotation processor you need to add following dependency to `pom.xml` file:\n          \n          \n            \n            To use this annotation processor you need to add the following dependency to the `pom.xml` file:", "author": "gsmet", "createdAt": "2020-05-08T15:41:05Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with `quarkus.picocli.top-command` property.\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@TopCommand\n+@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})\n+public class EntryCommand {\n+}\n+\n+@CommandLine.Command(name = \"hello\", description = \"Greet World!\")\n+class HelloCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Hello World!\");\n+    }\n+}\n+\n+@CommandLine.Command(name = \"goodbye\", description = \"Say goodbye to World!\")\n+class GoodByeCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Goodbye World!\");\n+    }\n+}\n+----\n+\n+== Customizing Picocli CommandLine instance\n+\n+You can customize CommandLine classes used by `picocli` extension by producing your own bean instance:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.PicocliCommandLineFactory;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+@TopCommand\n+@CommandLine.Command\n+public class EntryCommand implements Runnable {\n+    @CommandLine.Spec\n+    CommandLine.Model.CommandSpec spec;\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"My name is: \" + spec.name());\n+    }\n+}\n+\n+@ApplicationScoped\n+class CustomConfiguration {\n+\n+    @Produces\n+    CommandLine customCommandLine(PicocliCommandLineFactory factory) { // <1>\n+        return factory.create().setCommandName(\"CustomizedName\");\n+    }\n+}\n+----\n+<1> `PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.\n+\n+== Native mode support\n+\n+Picocli tool provides annotation processor which will generate a configuration for GraalVM Native images.\n+To use this annotation processor you need to add following dependency to `pom.xml` file:", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNjMzNw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422216337", "bodyText": "Can't we generate this configuration as part of the Quarkus build? I reckon there might be some redundancy but that's the Quarkus way of doing things.", "author": "gsmet", "createdAt": "2020-05-08T15:41:51Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with `quarkus.picocli.top-command` property.\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@TopCommand\n+@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})\n+public class EntryCommand {\n+}\n+\n+@CommandLine.Command(name = \"hello\", description = \"Greet World!\")\n+class HelloCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Hello World!\");\n+    }\n+}\n+\n+@CommandLine.Command(name = \"goodbye\", description = \"Say goodbye to World!\")\n+class GoodByeCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Goodbye World!\");\n+    }\n+}\n+----\n+\n+== Customizing Picocli CommandLine instance\n+\n+You can customize CommandLine classes used by `picocli` extension by producing your own bean instance:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.PicocliCommandLineFactory;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+@TopCommand\n+@CommandLine.Command\n+public class EntryCommand implements Runnable {\n+    @CommandLine.Spec\n+    CommandLine.Model.CommandSpec spec;\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"My name is: \" + spec.name());\n+    }\n+}\n+\n+@ApplicationScoped\n+class CustomConfiguration {\n+\n+    @Produces\n+    CommandLine customCommandLine(PicocliCommandLineFactory factory) { // <1>\n+        return factory.create().setCommandName(\"CustomizedName\");\n+    }\n+}\n+----\n+<1> `PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.\n+\n+== Native mode support", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1NTEyMA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422255120", "bodyText": "Do you mean that we should have property like quarkus.picocli.command-name which would configure this? I can expose most of setters from CommandLine as properties, but there are many, optional, things which can be configured there only programmatically. So I would like to leave PicocliCommandLineFactory (maybe with different name) to allow easy reconfiguration of CommandLine.\nI'm also not sure which of CommandLine properties should be configured in runtime. This maybe not a real issue, but for example setting QUARKUS_PICOCLI_TRIM_QUOTES in env will change behavior of your command line application, e.g. it will start to reacting to arguments in different way.", "author": "mgorniew", "createdAt": "2020-05-08T16:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNjMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1ODM2MA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422258360", "bodyText": "No my comment was about the native mode. We shouldn't need an annotation processor to configure the native mode, everything should be done in the Quarkus processor via build items. We can for sure help with this!", "author": "gsmet", "createdAt": "2020-05-08T17:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNjMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2Nzk1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422267953", "bodyText": "I will try to port picocli-codegen code to build steps. Reflection and resource bundles should be straightforward. Not sure about dynamic proxies, but I think I saw code for this also in quarkus.", "author": "mgorniew", "createdAt": "2020-05-08T17:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNjMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNjUxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422216519", "bodyText": "You don't need the version here as it's in the BOM.", "author": "gsmet", "createdAt": "2020-05-08T15:42:13Z", "path": "extensions/picocli/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-picocli-deployment</artifactId>\n+    <name>Quarkus - Picocli - Deployment</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-picocli</artifactId>\n+            <version>${project.version}</version>", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNjc3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422216772", "bodyText": "Please move that one to the FeatureBuildItem with the other. They are sorted in alphabetical order.", "author": "gsmet", "createdAt": "2020-05-08T15:42:41Z", "path": "extensions/picocli/deployment/src/main/java/io/quarkus/picocli/deployment/PicocliProcessor.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package io.quarkus.picocli.deployment;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.ApplicationIndexBuildItem;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.IndexDependencyBuildItem;\n+import io.quarkus.deployment.builditem.QuarkusApplicationClassBuildItem;\n+import io.quarkus.picocli.runtime.PicocliRunner;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import io.quarkus.runtime.annotations.QuarkusMain;\n+import picocli.CommandLine;\n+\n+class PicocliProcessor {\n+\n+    private static final String FEATURE = \"picocli\";", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNzEwOA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422217108", "bodyText": "Maybe an IllegalStateException would be better?", "author": "gsmet", "createdAt": "2020-05-08T15:43:18Z", "path": "extensions/picocli/deployment/src/main/java/io/quarkus/picocli/deployment/PicocliProcessor.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package io.quarkus.picocli.deployment;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.ApplicationIndexBuildItem;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.IndexDependencyBuildItem;\n+import io.quarkus.deployment.builditem.QuarkusApplicationClassBuildItem;\n+import io.quarkus.picocli.runtime.PicocliRunner;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import io.quarkus.runtime.annotations.QuarkusMain;\n+import picocli.CommandLine;\n+\n+class PicocliProcessor {\n+\n+    private static final String FEATURE = \"picocli\";\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FEATURE);\n+    }\n+\n+    @BuildStep\n+    BeanDefiningAnnotationBuildItem commandBeanDefiningAnnotation() {\n+        return new BeanDefiningAnnotationBuildItem(DotName.createSimple(CommandLine.Command.class.getName()));\n+    }\n+\n+    @BuildStep\n+    IndexDependencyBuildItem picocliIndexDependency() {\n+        return new IndexDependencyBuildItem(\"info.picocli\", \"picocli\");\n+    }\n+\n+    @BuildStep\n+    void picocliRunner(ApplicationIndexBuildItem applicationIndex,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<AdditionalBeanBuildItem> additionalBean,\n+            BuildProducer<QuarkusApplicationClassBuildItem> quarkusApplicationClass,\n+            BuildProducer<AnnotationsTransformerBuildItem> annotationsTransformer) {\n+        IndexView index = combinedIndex.getIndex();\n+        Collection<DotName> topCommands = classesAnnotatedWith(index, TopCommand.class.getName());\n+        if (topCommands.size() > 1) {\n+            throw new RuntimeException(\"Multiple classes annotated with TopCommand: \" +", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNzUzMA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422217530", "bodyText": "Maybe Develop command line applications with Picocli would be better. This is the description you have on code.quarkus.io.", "author": "gsmet", "createdAt": "2020-05-08T15:44:02Z", "path": "extensions/picocli/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,64 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-picocli</artifactId>\n+    <name>Quarkus - Picocli - Runtime</name>\n+    <description>Command line mode with Picocli</description>", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNzc5NA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422217794", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This class need to be annotated with {@link picocli.CommandLine.Command}.\n          \n          \n            \n                 * This class needs to be annotated with {@link picocli.CommandLine.Command}.", "author": "gsmet", "createdAt": "2020-05-08T15:44:34Z", "path": "extensions/picocli/runtime/src/main/java/io/quarkus/picocli/runtime/PicocliConfiguration.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package io.quarkus.picocli.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class PicocliConfiguration {\n+    /**\n+     * Name of class which will be used as entry point for Picocli CommandLine instance.\n+     * This class need to be annotated with {@link picocli.CommandLine.Command}.", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxOTA3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422219079", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            --\n          \n          \n            \n            ----", "author": "gsmet", "createdAt": "2020-05-08T15:47:07Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with `quarkus.picocli.top-command` property.\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@TopCommand\n+@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})\n+public class EntryCommand {\n+}\n+\n+@CommandLine.Command(name = \"hello\", description = \"Greet World!\")\n+class HelloCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Hello World!\");\n+    }\n+}\n+\n+@CommandLine.Command(name = \"goodbye\", description = \"Say goodbye to World!\")\n+class GoodByeCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Goodbye World!\");\n+    }\n+}\n+----\n+\n+== Customizing Picocli CommandLine instance\n+\n+You can customize CommandLine classes used by `picocli` extension by producing your own bean instance:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.PicocliCommandLineFactory;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+@TopCommand\n+@CommandLine.Command\n+public class EntryCommand implements Runnable {\n+    @CommandLine.Spec\n+    CommandLine.Model.CommandSpec spec;\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"My name is: \" + spec.name());\n+    }\n+}\n+\n+@ApplicationScoped\n+class CustomConfiguration {\n+\n+    @Produces\n+    CommandLine customCommandLine(PicocliCommandLineFactory factory) { // <1>\n+        return factory.create().setCommandName(\"CustomizedName\");\n+    }\n+}\n+----\n+<1> `PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.\n+\n+== Native mode support\n+\n+Picocli tool provides annotation processor which will generate a configuration for GraalVM Native images.\n+To use this annotation processor you need to add following dependency to `pom.xml` file:\n+\n+[source,xml]\n+--", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxOTE1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422219155", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            --\n          \n          \n            \n            ----", "author": "gsmet", "createdAt": "2020-05-08T15:47:14Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with `quarkus.picocli.top-command` property.\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@TopCommand\n+@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})\n+public class EntryCommand {\n+}\n+\n+@CommandLine.Command(name = \"hello\", description = \"Greet World!\")\n+class HelloCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Hello World!\");\n+    }\n+}\n+\n+@CommandLine.Command(name = \"goodbye\", description = \"Say goodbye to World!\")\n+class GoodByeCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Goodbye World!\");\n+    }\n+}\n+----\n+\n+== Customizing Picocli CommandLine instance\n+\n+You can customize CommandLine classes used by `picocli` extension by producing your own bean instance:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.PicocliCommandLineFactory;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+@TopCommand\n+@CommandLine.Command\n+public class EntryCommand implements Runnable {\n+    @CommandLine.Spec\n+    CommandLine.Model.CommandSpec spec;\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"My name is: \" + spec.name());\n+    }\n+}\n+\n+@ApplicationScoped\n+class CustomConfiguration {\n+\n+    @Produces\n+    CommandLine customCommandLine(PicocliCommandLineFactory factory) { // <1>\n+        return factory.create().setCommandName(\"CustomizedName\");\n+    }\n+}\n+----\n+<1> `PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.\n+\n+== Native mode support\n+\n+Picocli tool provides annotation processor which will generate a configuration for GraalVM Native images.\n+To use this annotation processor you need to add following dependency to `pom.xml` file:\n+\n+[source,xml]\n+--\n+<dependency>\n+  <groupId>info.picocli</groupId>\n+  <artifactId>picocli-codegen</artifactId>\n+</dependency>\n+--", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwODk0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422408945", "bodyText": "It is important that the factory falls back to the picocli default factory: the default factory has logic to instantiate collections (Lists, Sets, Maps) that picocli relies on. How about something like this:\nclass PicocliBeansFactory implements CommandLine.IFactory {\n\n    private final IFactory defaultFactory = CommandLine.defaultFactory();\n\n    @Override\n    public <K> K create(Class<K> aClass) throws Exception {\n        Instance<K> instance = CDI.current().select(aClass);\n        if (instance.isResolvable()) {\n            // question: does Quarkus provide some internal logging facility?\n            //System.out.println(\"Got instance \" + instance + \" via \" + CDI.current());\n            return instance.get();\n        }\n        //System.out.println(\"Instantiating \" + aClass + \" via default picocli factory\");\n        return defaultFactory.create(aClass);\n    }\n}", "author": "remkop", "createdAt": "2020-05-08T22:46:25Z", "path": "extensions/picocli/runtime/src/main/java/io/quarkus/picocli/runtime/PicocliBeansFactory.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package io.quarkus.picocli.runtime;\n+\n+import javax.enterprise.inject.spi.CDI;\n+\n+import picocli.CommandLine;\n+\n+class PicocliBeansFactory implements CommandLine.IFactory {\n+    @Override\n+    public <K> K create(Class<K> aClass) {\n+        return CDI.current().select(aClass).get();", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODc4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422458789", "bodyText": "what is this fixing ? (I assume its unrelated to picocli support ?)", "author": "maxandersen", "createdAt": "2020-05-09T06:24:01Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/steps/MainClassBuildStep.java", "diffHunk": "@@ -300,17 +302,22 @@ public MainClassBuildItem mainClassBuildStep(BuildProducer<GeneratedClassBuildIt\n             mainClassName = quarkusMainAnnotations.get(\"\");\n         }\n         if (mainClassName.equals(MAIN_CLASS)) {\n-            //generate a main that just runs the app, the user has not supplied a main class\n-            ClassCreator file = new ClassCreator(new GeneratedClassGizmoAdaptor(generatedClass, true), MAIN_CLASS, null,\n-                    Object.class.getName());\n+            if (quarkusApplicationClass.isPresent()) {", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2ODY3MA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422468670", "bodyText": "We need this because MainClassBuildItem looks for QuarkusMain annotated classes in CombinedIndexBuildItem. Since PicocliRunner is part of picocli extension it won't be visible in index.", "author": "mgorniew", "createdAt": "2020-05-09T08:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc2Mzg3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422763875", "bodyText": "This makes sense to me", "author": "stuartwdouglas", "createdAt": "2020-05-11T03:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODg1NA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422458854", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Simple PicocliApplication with only one Command can be created as follows:\n          \n          \n            \n            Simple Picocli Application with only one Command can be created as follows:", "author": "maxandersen", "createdAt": "2020-05-09T06:25:08Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODk0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422458946", "bodyText": "not really fan of calling this \"Picocli Application\" it is still an Quarkus Application just enhanced with command line parsing done by picocli.", "author": "maxandersen", "createdAt": "2020-05-09T06:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MjE3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422462172", "bodyText": "How about something like this:\n\n== Standalone picocli-based command line application\nA standalone command line application with a single picocli command can be created as follows:\n\nI'm finding the term \"standalone\" command/application, useful when distinguishing from a \"command suite\" with subcommands.", "author": "remkop", "createdAt": "2020-05-09T07:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MTAyNw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422491027", "bodyText": "not really fan of calling this \"Picocli Application\" it is still an Quarkus Application just enhanced with command line parsing done by picocli.\n\n+1\n\nHow about something like this:\n\n== Standalone picocli-based command line application\nA standalone command line application with a single picocli command can be created as follows:\n\nI'm finding the term \"standalone\" command/application, useful when distinguishing from a \"command suite\" with subcommands.\n\nBut can't we also create subcommands with this extension? I think calling simply a command line application may be good enough", "author": "gastaldi", "createdAt": "2020-05-09T12:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MTkwOA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422491908", "bodyText": "But can't we also create subcommands with this extension?\n\nI was thinking to have a separate section in the documentation for a command with subcommands; both are common scenarios and it is helpful to have clear examples for both.", "author": "remkop", "createdAt": "2020-05-09T12:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTE2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422459167", "bodyText": "having @TopCommand does not feel right - could it not reuse @QuarkusMain logic or at least similar logic to pick the main one ?", "author": "maxandersen", "createdAt": "2020-05-09T06:28:56Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,178 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode Applications] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple Picocli Application with one Command\n+\n+Simple PicocliApplication with only one Command can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are register as beans in CDI.\n+\n+== Picocli Application with multiple Commands\n+\n+When multiple classes has `picocli.CommandLine.Command` annotation, then one of them need to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTQ1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422459457", "bodyText": "maybe just use @nAmed ?", "author": "maxandersen", "createdAt": "2020-05-09T06:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NDQyNA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422464424", "bodyText": "I also have mixed feelings about @TopCommand (but perhaps I just need to get used to it...)\nMy preference would be that applications would always get access to the CommandLine instance, so they can configure it as needed and explicitly call execute on it (or parseArgs if they want to).\nMy approach was to skip PicocliCommandLineFactory altogether and let application code look like this:\n@QuarkusMain\n@ApplicationScoped\n@Command(name = \"demo\", mixinStandardHelpOptions = true)\npublic class ExampleApp implements Runnable, QuarkusApplication {\n    @Inject\n    PicocliBeansFactory factory;\n\n    @Override\n    public void run() {\n        // business logic\n    }\n\n    @Override\n    public int run(String... args) throws Exception {\n        System.setProperty(\"quarkus.banner.enabled\", \"false\");\n        return new CommandLine(this, factory).execute(args);\n    }\n}", "author": "remkop", "createdAt": "2020-05-09T07:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NDY2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422484663", "bodyText": "@remkop Your example will work with current implementation. If user provide own QuarkusMain annotated class then picocli extension will not add PicocliRunner bean. I will add this to documentation.\nI wanted simplest Quarkus/Picocli application to look like basic REST example. One, Command annotated, class could be good start for simple command line application.\nAs for TopCommand:\n\nI don't think that I can reuse QuarkusMain here, without big changes in MainClassBuildStep. Command class may just be Object and don't need to implement QuarkusApplication\n@maxandersen Using Named doesn't fell right also, since any Object can be annotated with Command and Command itself is not Qualifier.\nWe could add name to TopCommand and have similar logic as in QuarkusMain. In fact there is already quarkus.picocli.top-command property which will work in similar way. It takes FQCN of class which will be used as entry point. Not sure if this property should be runtime or build time configuration. For now it is runtime.\nWe could drop TopCommand all together and add PicocliRunner if there is only one Command annotated class. In all other cases user would be forced to provided QuarkusMain on its own.\nOr just drop PicocliRunner entirely as @remkop suggested.", "author": "mgorniew", "createdAt": "2020-05-09T11:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc2NTczOA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422765738", "bodyText": "Personally I like the annotation based approach. I think you can make the @QuarkusMain integration work without major MainClassBuildStep changes by looking for classes that have both @QuarkusMain and @command. If one is found then make PicoliRunner use that class, and create a QuarkusApplicationClassBuildItem so that Quarkus won't look for the QuarkusMain class itself.", "author": "stuartwdouglas", "createdAt": "2020-05-11T03:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc5MjE3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422792172", "bodyText": "@stuartwdouglas, if I understand correctly, you propose that instead of introducing a new @TopCommand annotation, applications would use the combination of the @QuarkusMain and the @Command annotation to specify the top-level command in a command suite with subcommands. That makes sense to me.", "author": "remkop", "createdAt": "2020-05-11T05:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc5Mjc4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422792789", "bodyText": "Yea.\nThe only real downside to this is that it could create confusion, as it is a 3rd possible way to use @QuarkusMain, but it is still doing pretty much the same thing so I think it should be ok.", "author": "stuartwdouglas", "createdAt": "2020-05-11T05:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1NTAyMg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422855022", "bodyText": "@stuartwdouglas So picocli extension would need to have copy of logic for finding @QuarkusMain and if this Main is also annotated with Command then it would produce QuarkusApplicationClassBuildItem pointing to PicocliRunner. But, I think that with such approach PicocliRunner would need to be generated class. Both @QuarkusMain and @Command are not Qualifiers, so I'm not sure how to pass it to current PicocliRunner. This would also mean that QuarkusApplicationClassBuildItem has priority. If it exist then MainClassBuildStep will always use it.\nNote that current approach, with @TopCommand qualifiers, also allows things like this (after I add METHOD @Target):\n@ApplicationScoped\npublic class Config {\n\n    @Produces\n    @TopCommand\n    @IfBuildProfile(\"dev\")\n    public Object devCommand() {\n        // Since this is Object, it can be also Class<?>\n        // Instance will be created by CommandLine.IFactory\n        return DevCommand.class;\n    }\n\n    @Produces\n    @TopCommand\n    @IfBuildProfile(\"prod\")\n    public Object prodCommand() {\n        return ProdCommand.class;\n    }\n\n}", "author": "mgorniew", "createdAt": "2020-05-11T08:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQwNzc3MA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r423407770", "bodyText": "That is a good point that this allows for producer methods. It also allows for the 'Right click and run from IDE' use case, if you do Quarkus.run(PicocliRunner.class) in your main method, which my approach would not allow (we should probably document this).\nThinking about it I think that the current approach is probably best.", "author": "stuartwdouglas", "createdAt": "2020-05-12T01:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MDUxMg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r422490512", "bodyText": "You might want to add to the dependabot descriptor too", "author": "gastaldi", "createdAt": "2020-05-09T12:34:14Z", "path": "bom/runtime/pom.xml", "diffHunk": "@@ -191,6 +191,7 @@\n         <jib-core.version>0.13.1</jib-core.version>\n         <google-http-client.version>1.34.0</google-http-client.version>\n         <scram-client.version>2.1</scram-client.version>\n+        <picocli.version>4.2.0</picocli.version>", "originalCommit": "dadaf1cc3c87456d0e7029ba85f0ebe88d3fd82d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "75a7d3d5e309c60a79c1e3131f0c2c8a36262389", "url": "https://github.com/quarkusio/quarkus/commit/75a7d3d5e309c60a79c1e3131f0c2c8a36262389", "message": "Create picocli extension", "committedDate": "2020-05-10T00:45:49Z", "type": "forcePushed"}, {"oid": "0d4a33585dfe15668f9c97091d306da73f21cdd1", "url": "https://github.com/quarkusio/quarkus/commit/0d4a33585dfe15668f9c97091d306da73f21cdd1", "message": "Create picocli extension", "committedDate": "2020-05-10T01:04:47Z", "type": "forcePushed"}, {"oid": "578ca88d95c0b860861c8ba6559149645de60935", "url": "https://github.com/quarkusio/quarkus/commit/578ca88d95c0b860861c8ba6559149645de60935", "message": "Create picocli extension", "committedDate": "2020-05-10T12:49:44Z", "type": "forcePushed"}, {"oid": "cab293bbd3d890e199092c2257ac9927c774158a", "url": "https://github.com/quarkusio/quarkus/commit/cab293bbd3d890e199092c2257ac9927c774158a", "message": "Create picocli extension", "committedDate": "2020-05-11T09:39:53Z", "type": "forcePushed"}, {"oid": "0478762e8da217a908db1ad84765f9d1e6acfb94", "url": "https://github.com/quarkusio/quarkus/commit/0478762e8da217a908db1ad84765f9d1e6acfb94", "message": "Create picocli extension", "committedDate": "2020-05-12T11:57:26Z", "type": "forcePushed"}, {"oid": "e1f797215bfe713a9f39dd46d0d96fdcd95765d5", "url": "https://github.com/quarkusio/quarkus/commit/e1f797215bfe713a9f39dd46d0d96fdcd95765d5", "message": "Create picocli extension", "committedDate": "2020-05-13T12:11:58Z", "type": "forcePushed"}, {"oid": "73690f666c561037fea584223dcf226e518f1737", "url": "https://github.com/quarkusio/quarkus/commit/73690f666c561037fea584223dcf226e518f1737", "message": "Create picocli extension", "committedDate": "2020-05-15T09:13:53Z", "type": "forcePushed"}, {"oid": "f3946e8f8caa164c851f566645265fcc65d40ab2", "url": "https://github.com/quarkusio/quarkus/commit/f3946e8f8caa164c851f566645265fcc65d40ab2", "message": "Create picocli extension", "committedDate": "2020-05-15T09:56:17Z", "type": "forcePushed"}, {"oid": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "url": "https://github.com/quarkusio/quarkus/commit/7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "message": "Create picocli extension", "committedDate": "2020-05-15T17:35:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTIzMA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426151230", "bodyText": "I am a little hesitant about mentioning this TBH... Nowhere in any other extension are we telling users to add some additional process to get their GraalVM native image working.\nWe should strive to make everything work in native image and treat things that don't as bugs to be fixed here, instead of relying on an annotation processor.", "author": "geoand", "createdAt": "2020-05-16T12:54:30Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,238 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode reference guide] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple command line application\n+\n+Simple PicocliApplication with only one `Command` can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are registered as CDI beans.\n+\n+== Command line application with multiple Commands\n+\n+When multiple classes have the `picocli.CommandLine.Command` annotation, then one of them needs to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with the `quarkus.picocli.top-command` property.\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@TopCommand\n+@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})\n+public class EntryCommand {\n+}\n+\n+@CommandLine.Command(name = \"hello\", description = \"Greet World!\")\n+class HelloCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Hello World!\");\n+    }\n+}\n+\n+@CommandLine.Command(name = \"goodbye\", description = \"Say goodbye to World!\")\n+class GoodByeCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Goodbye World!\");\n+    }\n+}\n+----\n+\n+== Customizing Picocli CommandLine instance\n+\n+You can customize CommandLine classes used by the `picocli` extension by producing your own bean instance:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.PicocliCommandLineFactory;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+@TopCommand\n+@CommandLine.Command\n+public class EntryCommand implements Runnable {\n+    @CommandLine.Spec\n+    CommandLine.Model.CommandSpec spec;\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"My name is: \" + spec.name());\n+    }\n+}\n+\n+@ApplicationScoped\n+class CustomConfiguration {\n+\n+    @Produces\n+    CommandLine customCommandLine(PicocliCommandLineFactory factory) { // <1>\n+        return factory.create().setCommandName(\"CustomizedName\");\n+    }\n+}\n+----\n+<1> `PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.\n+\n+== Different entry command for each profile\n+\n+It is possible to create different entry command for each profile, using `@IfBuildProfile`:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Config {\n+\n+    @Produces\n+    @TopCommand\n+    @IfBuildProfile(\"dev\")\n+    public Object devCommand() {\n+        return DevCommand.class; // <1>\n+    }\n+\n+    @Produces\n+    @TopCommand\n+    @IfBuildProfile(\"prod\")\n+    public Object prodCommand() {\n+        return new ProdCommand(\"Configured by me!\");\n+    }\n+\n+}\n+----\n+<1> You can return instance of `java.lang.Class` here. In such case `CommandLine` will try to instantiate this class using `CommandLine.IFactory`.\n+\n+== Providing own QuarkusMain\n+\n+You can also provide your own application entry point annotated with `QuarkusMain` (as described in link:command-mode-reference[Command Mode reference guide]).\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.runtime.QuarkusApplication;\n+import io.quarkus.runtime.annotations.QuarkusMain;\n+import picocli.CommandLine;\n+\n+import javax.inject.Inject;\n+\n+@QuarkusMain\n+@CommandLine.Command(name = \"demo\", mixinStandardHelpOptions = true)\n+public class ExampleApp implements Runnable, QuarkusApplication {\n+    @Inject\n+    CommandLine.IFactory factory; // <1>\n+\n+    @Override\n+    public void run() {\n+        // business logic\n+    }\n+\n+    @Override\n+    public int run(String... args) throws Exception {\n+        return new CommandLine(this, factory).execute(args);\n+    }\n+}\n+----\n+<1> Quarkus-compatible `CommandLine.IFactory` bean created by `picocli` extension.\n+\n+== Native mode support\n+\n+GraalVM Native images should work out-of-box, but in case of any issues it is still possible to use annotation processor from `picocli` project.", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4ODY3MA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426188670", "bodyText": "I agree that if something doesn't work in native images created with buildsteps then it is a bug and must be fixed. But, if I understood @remkop correctly, picocli-codegen may have some improvements in future to make native images smaller by tweaking reflection configuration. With Quarkus, users won't be able to benefit from those improvements until they will be ported to buildsteps, which is more like feature and not bugfix.\nAs for now we probably can remove this property and decided what to do when improvements will be added to picocli-codegen.", "author": "mgorniew", "createdAt": "2020-05-16T20:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4ODg4OA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426188888", "bodyText": "Well, in my view if we want to tweak the native image stuff for picocli, then the best way to do that would be to have the proper hooks in picocli so that Quarkus could do it's own optimizations (much in the same way that is already the case for other extensions)", "author": "geoand", "createdAt": "2020-05-16T20:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MTEyNg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426191126", "bodyText": "I'm little lost here. Do you mean hooks in picocli extension or picocli library itself? Current implementation of buildsteps is quite aggressive in adding reflection to native image. For example all methods are added from @command annotated classes, even if they are not called by reflection in runtime. And @remkop also mentioned possible changes in picocli library itself.", "author": "mgorniew", "createdAt": "2020-05-16T21:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MTQxNA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426191414", "bodyText": "I mean that picocli could (might already ?) Have hooks that the Quarkus extension could use to optimize things (create bytecode for implementing interfaces for example).\nThis is of course something for future consideration", "author": "geoand", "createdAt": "2020-05-16T21:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5NzcwMw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426197703", "bodyText": "As for now we probably can remove this property and decided what to do when improvements will be added to picocli-codegen.\n\n\ud83d\ude2d  I had concerns with build steps replacing picocli-codegen because this potentially limits how picocli can evolve as a library (without breaking picocli in Quarkus). My concerns were addressed by adding this property.\nThe purpose of this property was to provide a fallback solution for any interim periods of time when picocli has evolved in an incompatible way, and the Quarkus picocli extension has not been updated yet.\nThe existence of this fallback mechanism is important to me.  Please reinstate it.\n\nI am a little hesitant about mentioning this TBH...\n\nNow, how this fallback mechanism is documented is a different matter.\nThe intention is certainly not to advertise this as canonical or normal usage.\nI am fine with very minimal documentation or even omitting this from the documentation.", "author": "remkop", "createdAt": "2020-05-16T22:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTM4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426151387", "bodyText": "As mentioned in my comment above, I am very reluctant about this...", "author": "geoand", "createdAt": "2020-05-16T12:56:49Z", "path": "extensions/picocli/deployment/src/main/java/io/quarkus/picocli/deployment/PicocliDeploymentConfiguration.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package io.quarkus.picocli.deployment;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(name = \"picocli\")\n+class PicocliDeploymentConfiguration {\n+\n+    /**\n+     * Whether or not a native image processing build steps should be enabled.\n+     * This should be set to false if `picocli-codegen` annotation processor is used.\n+     */\n+    @ConfigItem(name = \"native-image.processing.enable\", defaultValue = \"true\")\n+    boolean nativeImageProcessingEnabled;", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5NzcyMw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426197723", "bodyText": "As per my previous comment, the existence of this property is important to me. Please revert this change. \ud83d\ude4f", "author": "remkop", "createdAt": "2020-05-16T22:45:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxNjg2MA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426216860", "bodyText": "I think it's the wrong thing to do, but I won't fight it :). Feel free to add it again", "author": "geoand", "createdAt": "2020-05-17T04:45:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyNzYxNg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426227616", "bodyText": "Thank you!", "author": "remkop", "createdAt": "2020-05-17T07:23:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyNzg2OA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426227868", "bodyText": "No need to thank me \ud83d\ude0a. We are just trying to figure out what's best for users \ud83d\ude0e", "author": "geoand", "createdAt": "2020-05-17T07:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTUxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426151511", "bodyText": "I would urge to use Arc.container() here instead of CDI.current()", "author": "geoand", "createdAt": "2020-05-16T12:58:38Z", "path": "extensions/picocli/runtime/src/main/java/io/quarkus/picocli/runtime/PicocliBeansFactory.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package io.quarkus.picocli.runtime;\n+\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.spi.CDI;\n+\n+import picocli.CommandLine;\n+\n+class PicocliBeansFactory implements CommandLine.IFactory {\n+    private final CommandLine.IFactory defaultFactory = CommandLine.defaultFactory();\n+\n+    @Override\n+    public <K> K create(Class<K> aClass) throws Exception {\n+        Instance<K> instance = CDI.current().select(aClass);", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5NTU2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426195561", "bodyText": "Why use Arc.container() instead of CDI.current()? Isn't CDI the standard?", "author": "remkop", "createdAt": "2020-05-16T22:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5NjA2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426196061", "bodyText": "Yes, CDI.current() is the standard, but this is a Quarkus piece of code so let's go with the slightly more performant option that is also used heavily throughout the codebase", "author": "geoand", "createdAt": "2020-05-16T22:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5ODI5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426198295", "bodyText": "I see, thanks for the clarification!", "author": "remkop", "createdAt": "2020-05-16T22:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxNjgyMA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426216820", "bodyText": "You are welcome!", "author": "geoand", "createdAt": "2020-05-17T04:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTU3MA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426151570", "bodyText": "This is redundant since Arc knows to use the constructor even without the annotations", "author": "geoand", "createdAt": "2020-05-16T12:59:39Z", "path": "extensions/picocli/runtime/src/main/java/io/quarkus/picocli/runtime/PicocliCommandLineProducer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package io.quarkus.picocli.runtime;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.Produces;\n+import javax.enterprise.inject.literal.NamedLiteral;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.arc.DefaultBean;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@ApplicationScoped\n+public class PicocliCommandLineProducer {\n+\n+    private final Instance<Object> topCommand;\n+    private final PicocliConfiguration picocliConfiguration;\n+\n+    @Inject", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTY0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426151649", "bodyText": "Are users expected to be able to provide their own CommandLine.IFactory? If not, then there is no need to have this annotation.", "author": "geoand", "createdAt": "2020-05-16T13:00:39Z", "path": "extensions/picocli/runtime/src/main/java/io/quarkus/picocli/runtime/PicocliCommandLineProducer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package io.quarkus.picocli.runtime;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.Produces;\n+import javax.enterprise.inject.literal.NamedLiteral;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.arc.DefaultBean;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@ApplicationScoped\n+public class PicocliCommandLineProducer {\n+\n+    private final Instance<Object> topCommand;\n+    private final PicocliConfiguration picocliConfiguration;\n+\n+    @Inject\n+    public PicocliCommandLineProducer(@TopCommand Instance<Object> topCommand, PicocliConfiguration picocliConfiguration) {\n+        this.topCommand = topCommand;\n+        this.picocliConfiguration = picocliConfiguration;\n+    }\n+\n+    private Class<?> classForName(String name) {\n+        try {\n+            return Class.forName(name);\n+        } catch (ClassNotFoundException ex) {\n+            throw new IllegalArgumentException(ex);\n+        }\n+    }\n+\n+    @Produces\n+    @DefaultBean", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5NTUxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426195515", "bodyText": "I would say that normally, no, users would not provide their own factory. Also,  I can see no issue with the factory implementation in this extension.\nHowever, why take away the possibility for users to provide their own factory?\nThere may be some use case that we haven't thought of and then we will be happy if the @DefaultBean annotation is there so it is easy for users to provide their own.", "author": "remkop", "createdAt": "2020-05-16T22:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5NTk0OA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426195948", "bodyText": "I'm not opposed to it, just asking \ud83d\ude09", "author": "geoand", "createdAt": "2020-05-16T22:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5NjE0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426196149", "bodyText": "Won't users be able to overwrite this anyway with Alternative + Priority(1)?", "author": "mgorniew", "createdAt": "2020-05-16T22:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5NjMzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426196331", "bodyText": "Yes they can do that if needed.", "author": "geoand", "createdAt": "2020-05-16T22:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5ODYxNg==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426198616", "bodyText": "Won't users be able to overwrite this anyway with Alternative + Priority(1)?\n\nI see, that is good to know. In that case the difference is a bit academic and I am fine either way. \ud83d\ude09", "author": "remkop", "createdAt": "2020-05-16T23:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTY3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426151676", "bodyText": "Same here", "author": "geoand", "createdAt": "2020-05-16T13:00:48Z", "path": "extensions/picocli/runtime/src/main/java/io/quarkus/picocli/runtime/PicocliCommandLineProducer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package io.quarkus.picocli.runtime;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.Produces;\n+import javax.enterprise.inject.literal.NamedLiteral;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.arc.DefaultBean;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@ApplicationScoped\n+public class PicocliCommandLineProducer {\n+\n+    private final Instance<Object> topCommand;\n+    private final PicocliConfiguration picocliConfiguration;\n+\n+    @Inject\n+    public PicocliCommandLineProducer(@TopCommand Instance<Object> topCommand, PicocliConfiguration picocliConfiguration) {\n+        this.topCommand = topCommand;\n+        this.picocliConfiguration = picocliConfiguration;\n+    }\n+\n+    private Class<?> classForName(String name) {\n+        try {\n+            return Class.forName(name);\n+        } catch (ClassNotFoundException ex) {\n+            throw new IllegalArgumentException(ex);\n+        }\n+    }\n+\n+    @Produces\n+    @DefaultBean\n+    @Singleton\n+    public CommandLine.IFactory picocliFactory() {\n+        return new PicocliBeansFactory();\n+    }\n+\n+    @Produces\n+    @DefaultBean", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTcyNw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426151727", "bodyText": "We generally try to avoid using lamdbas in runtime code as much as possible, due to their non-zero (albeit very small) runtime overhead.", "author": "geoand", "createdAt": "2020-05-16T13:01:34Z", "path": "extensions/picocli/runtime/src/main/java/io/quarkus/picocli/runtime/PicocliCommandLineProducer.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package io.quarkus.picocli.runtime;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Instance;\n+import javax.enterprise.inject.Produces;\n+import javax.enterprise.inject.literal.NamedLiteral;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import io.quarkus.arc.DefaultBean;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@ApplicationScoped\n+public class PicocliCommandLineProducer {\n+\n+    private final Instance<Object> topCommand;\n+    private final PicocliConfiguration picocliConfiguration;\n+\n+    @Inject\n+    public PicocliCommandLineProducer(@TopCommand Instance<Object> topCommand, PicocliConfiguration picocliConfiguration) {\n+        this.topCommand = topCommand;\n+        this.picocliConfiguration = picocliConfiguration;\n+    }\n+\n+    private Class<?> classForName(String name) {\n+        try {\n+            return Class.forName(name);\n+        } catch (ClassNotFoundException ex) {\n+            throw new IllegalArgumentException(ex);\n+        }\n+    }\n+\n+    @Produces\n+    @DefaultBean\n+    @Singleton\n+    public CommandLine.IFactory picocliFactory() {\n+        return new PicocliBeansFactory();\n+    }\n+\n+    @Produces\n+    @DefaultBean\n+    public PicocliCommandLineFactory picocliCommandLineFactory(CommandLine.IFactory picocliFactory) {\n+        return () -> picocliConfiguration.topCommand", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MTg4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426151887", "bodyText": "Let's drop this annotation as it isn't needed when there is a single constuctor", "author": "geoand", "createdAt": "2020-05-16T13:03:28Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,238 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode reference guide] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple command line application\n+\n+Simple PicocliApplication with only one `Command` can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MjAxMA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426152010", "bodyText": "Is the 20min increase warranted by adding a single integration test?", "author": "geoand", "createdAt": "2020-05-16T13:05:32Z", "path": ".github/workflows/ci-actions.yml", "diffHunk": "@@ -467,9 +467,10 @@ jobs:\n             test-modules: >\n               kubernetes-client\n           - category: Misc4\n-            timeout: 10\n+            timeout: 30", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE3MzQ5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426173495", "bodyText": "Last run was close to 13 min. I will set this to 20.", "author": "mgorniew", "createdAt": "2020-05-16T17:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1MjE4MA==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426152180", "bodyText": "Very good idea to mention this!", "author": "geoand", "createdAt": "2020-05-16T13:07:33Z", "path": "docs/src/main/asciidoc/picocli.adoc", "diffHunk": "@@ -0,0 +1,238 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Command Mode with Picocli\n+:extension-status: experimental\n+\n+include::./attributes.adoc[]\n+\n+https://picocli.info/[Picocli] is an open source tool for creating rich command line applications.\n+\n+Quarkus provides support for using Picocli. This guide contains examples of `picocli` extension usage.\n+\n+include::./status-include.adoc[]\n+\n+IMPORTANT: If you are not familiar with the Quarkus Command Mode, consider reading the link:command-mode-reference[Command Mode reference guide] first.\n+\n+== Configuration\n+\n+Once you have your Quarkus project configured you can add the `picocli` extension\n+to your project by running the following command in your project base directory.\n+\n+[source,bash]\n+----\n+./mvnw quarkus:add-extension -Dextensions=\"picocli\"\n+----\n+\n+This will add the following to your pom.xml:\n+\n+[source,xml]\n+----\n+    <dependency>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-picocli</artifactId>\n+    </dependency>\n+----\n+\n+== Simple command line application\n+\n+Simple PicocliApplication with only one `Command` can be created as follows:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+\n+@CommandLine.Command // <1>\n+public class HelloCommand implements Runnable {\n+\n+    @CommandLine.Option(names = {\"-n\", \"--name\"}, description = \"Who will we greet?\", defaultValue = \"World\")\n+    String name;\n+\n+    private final GreetingService greetingService;\n+\n+    @Inject // <2>\n+    public HelloCommand(GreetingService greetingService) {\n+        this.greetingService = greetingService;\n+    }\n+\n+    @Override\n+    public void run() {\n+        greetingService.sayHello(name);\n+    }\n+}\n+\n+@Dependent\n+class GreetingService {\n+    void sayHello(String name) {\n+        System.out.println(\"Hello \" + name + \"!\");\n+    }\n+}\n+----\n+<1> If there is only one class annotated with `picocli.CommandLine.Command` it will be used as entry point to Picocli CommandLine.\n+<2> All classes annotated with `picocli.CommandLine.Command` are registered as CDI beans.\n+\n+== Command line application with multiple Commands\n+\n+When multiple classes have the `picocli.CommandLine.Command` annotation, then one of them needs to be also annotated with `io.quarkus.picocli.runtime.annotations.TopCommand`.\n+This can be overwritten with the `quarkus.picocli.top-command` property.\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+@TopCommand\n+@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})\n+public class EntryCommand {\n+}\n+\n+@CommandLine.Command(name = \"hello\", description = \"Greet World!\")\n+class HelloCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Hello World!\");\n+    }\n+}\n+\n+@CommandLine.Command(name = \"goodbye\", description = \"Say goodbye to World!\")\n+class GoodByeCommand implements Runnable {\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"Goodbye World!\");\n+    }\n+}\n+----\n+\n+== Customizing Picocli CommandLine instance\n+\n+You can customize CommandLine classes used by the `picocli` extension by producing your own bean instance:\n+\n+[source,java]\n+----\n+package com.acme.picocli;\n+\n+import io.quarkus.picocli.runtime.PicocliCommandLineFactory;\n+import io.quarkus.picocli.runtime.annotations.TopCommand;\n+import picocli.CommandLine;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+\n+@TopCommand\n+@CommandLine.Command\n+public class EntryCommand implements Runnable {\n+    @CommandLine.Spec\n+    CommandLine.Model.CommandSpec spec;\n+\n+    @Override\n+    public void run() {\n+        System.out.println(\"My name is: \" + spec.name());\n+    }\n+}\n+\n+@ApplicationScoped\n+class CustomConfiguration {\n+\n+    @Produces\n+    CommandLine customCommandLine(PicocliCommandLineFactory factory) { // <1>\n+        return factory.create().setCommandName(\"CustomizedName\");\n+    }\n+}\n+----\n+<1> `PicocliCommandLineFactory` will create an instance of CommandLine with `TopCommand` and `CommandLine.IFactory` injected.\n+\n+== Different entry command for each profile\n+\n+It is possible to create different entry command for each profile, using `@IfBuildProfile`:", "originalCommit": "7e70cd111caf44e959fb2836a0bcc323e8ea8e88", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "deb179c8a03ec3174257513c253fcdc3927b3792", "url": "https://github.com/quarkusio/quarkus/commit/deb179c8a03ec3174257513c253fcdc3927b3792", "message": "Create picocli extension", "committedDate": "2020-05-16T21:10:19Z", "type": "forcePushed"}, {"oid": "36b7a325e64dcc6c7e5167a29583880eb20e1370", "url": "https://github.com/quarkusio/quarkus/commit/36b7a325e64dcc6c7e5167a29583880eb20e1370", "message": "Create picocli extension", "committedDate": "2020-05-16T21:21:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwNjQ4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9180#discussion_r426206489", "bodyText": "The latest picocli version is now 4.3.2.", "author": "remkop", "createdAt": "2020-05-17T01:26:45Z", "path": "bom/runtime/pom.xml", "diffHunk": "@@ -195,6 +195,7 @@\n         <scram-client.version>2.1</scram-client.version>\n         <grpc-jprotoc.version>1.0.1</grpc-jprotoc.version>\n         <grpc.version>1.29.0</grpc.version>\n+        <picocli.version>4.2.0</picocli.version>", "originalCommit": "36b7a325e64dcc6c7e5167a29583880eb20e1370", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e510cf42edffd1d6243f2d2c3079f4be0ce832d8", "url": "https://github.com/quarkusio/quarkus/commit/e510cf42edffd1d6243f2d2c3079f4be0ce832d8", "message": "Create picocli extension", "committedDate": "2020-05-17T11:49:22Z", "type": "commit"}, {"oid": "e510cf42edffd1d6243f2d2c3079f4be0ce832d8", "url": "https://github.com/quarkusio/quarkus/commit/e510cf42edffd1d6243f2d2c3079f4be0ce832d8", "message": "Create picocli extension", "committedDate": "2020-05-17T11:49:22Z", "type": "forcePushed"}]}