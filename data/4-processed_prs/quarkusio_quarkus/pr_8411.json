{"pr_number": 8411, "pr_title": "Add Vault response wrapping support for client token auth and secret id in approle auth", "pr_createdAt": "2020-04-06T10:20:12Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8411", "timeline": [{"oid": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293", "url": "https://github.com/quarkusio/quarkus/commit/2c5d6bf86cf05c09ee37ee012572194f3d0c7293", "message": "Add Vault response wrapping support for client token auth and secret id in approle auth - Fixes #7900", "committedDate": "2020-04-06T09:55:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NTM2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404575361", "bodyText": "Can you add more info regarding the exception, as this is not a unwrapping problem per-se, but a problem on Thread management.", "author": "lordofthejars", "createdAt": "2020-04-07T06:53:34Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultAuthManager.java", "diffHunk": "@@ -118,6 +138,50 @@ private VaultToken login(VaultAuthenticationType type) {\n         return new VaultToken(auth.clientToken, auth.renewable, auth.leaseDurationSecs);\n     }\n \n+    private String getSecretId() {\n+\n+        Optional<String> secretIdOption = serverConfig.authentication.appRole.secretId;\n+        if (secretIdOption.isPresent()) {\n+            return secretIdOption.get();\n+        }\n+\n+        return unwrapWrappingTokenOnce(\"secret id\",\n+                serverConfig.authentication.appRole.secretIdWrappingToken.get(), unwrap -> unwrap.data.secretId,\n+                VaultAppRoleGenerateNewSecretID.class);\n+    }\n+\n+    private <T> String unwrapWrappingTokenOnce(String type, String wrappingToken,\n+            Function<T, String> f, Class<T> clazz) {\n+\n+        String wrappedValue = wrappedCache.get(wrappingToken);\n+        if (wrappedValue != null) {\n+            return wrappedValue;\n+        }\n+\n+        try {\n+            unwrapSem.acquire();\n+            try {\n+                // by the time we reach here, may be somebody has populated the cache\n+                wrappedValue = wrappedCache.get(wrappingToken);\n+                if (wrappedValue != null) {\n+                    return wrappedValue;\n+                }\n+\n+                T unwrap = vaultClient.unwrap(wrappingToken, clazz);\n+                wrappedValue = f.apply(unwrap);\n+                wrappedCache.put(wrappingToken, wrappedValue);\n+                String displayValue = serverConfig.logConfidentialityLevel.maskWithTolerance(wrappedValue, LOW);\n+                log.debug(\"unwrapped \" + type + \": \" + displayValue);\n+                return wrappedValue;\n+\n+            } finally {\n+                unwrapSem.release();\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"unable to unwrap \" + type);", "originalCommit": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NTQ0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404695446", "bodyText": "yes\nI have also set a timeout on sem acquire.\nin the catch block, do you know if this is a good practice to reinterrupt the thread, of the throw new RuntimeException is good enough.\nsomething like this:\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"unable to enter critical section when unwrapping \" + type, e);\n        }", "author": "vsevel", "createdAt": "2020-04-07T10:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NTM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMDIyMw==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404710223", "bodyText": "I am not sure how this works inside a Quarkus.", "author": "lordofthejars", "createdAt": "2020-04-07T10:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NTM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NjIwNw==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404576207", "bodyText": "If there is this logic inside the semaphore.acquire, do we really need it here?", "author": "lordofthejars", "createdAt": "2020-04-07T06:55:19Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultAuthManager.java", "diffHunk": "@@ -118,6 +138,50 @@ private VaultToken login(VaultAuthenticationType type) {\n         return new VaultToken(auth.clientToken, auth.renewable, auth.leaseDurationSecs);\n     }\n \n+    private String getSecretId() {\n+\n+        Optional<String> secretIdOption = serverConfig.authentication.appRole.secretId;\n+        if (secretIdOption.isPresent()) {\n+            return secretIdOption.get();\n+        }\n+\n+        return unwrapWrappingTokenOnce(\"secret id\",\n+                serverConfig.authentication.appRole.secretIdWrappingToken.get(), unwrap -> unwrap.data.secretId,\n+                VaultAppRoleGenerateNewSecretID.class);\n+    }\n+\n+    private <T> String unwrapWrappingTokenOnce(String type, String wrappingToken,\n+            Function<T, String> f, Class<T> clazz) {\n+\n+        String wrappedValue = wrappedCache.get(wrappingToken);", "originalCommit": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NjY4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404686686", "bodyText": "if the wrapped info is already in the cache, no need to go through semaphore acquisition\nthis will be faster, and that is the situation we will be in almost all the time", "author": "vsevel", "createdAt": "2020-04-07T09:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NjIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NzEwOA==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404577108", "bodyText": "If token has been already unwrapped (ie stolen) this method is going to throw an error, could we capture specifically the exception in this case and throw a specific RuntimeException and/or log as warning? Just to not provide the error a general error of Vault but something important that might affect the security of your app.", "author": "lordofthejars", "createdAt": "2020-04-07T06:57:19Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultAuthManager.java", "diffHunk": "@@ -118,6 +138,50 @@ private VaultToken login(VaultAuthenticationType type) {\n         return new VaultToken(auth.clientToken, auth.renewable, auth.leaseDurationSecs);\n     }\n \n+    private String getSecretId() {\n+\n+        Optional<String> secretIdOption = serverConfig.authentication.appRole.secretId;\n+        if (secretIdOption.isPresent()) {\n+            return secretIdOption.get();\n+        }\n+\n+        return unwrapWrappingTokenOnce(\"secret id\",\n+                serverConfig.authentication.appRole.secretIdWrappingToken.get(), unwrap -> unwrap.data.secretId,\n+                VaultAppRoleGenerateNewSecretID.class);\n+    }\n+\n+    private <T> String unwrapWrappingTokenOnce(String type, String wrappingToken,\n+            Function<T, String> f, Class<T> clazz) {\n+\n+        String wrappedValue = wrappedCache.get(wrappingToken);\n+        if (wrappedValue != null) {\n+            return wrappedValue;\n+        }\n+\n+        try {\n+            unwrapSem.acquire();\n+            try {\n+                // by the time we reach here, may be somebody has populated the cache\n+                wrappedValue = wrappedCache.get(wrappingToken);\n+                if (wrappedValue != null) {\n+                    return wrappedValue;\n+                }\n+\n+                T unwrap = vaultClient.unwrap(wrappingToken, clazz);", "originalCommit": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NTYzNA==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404695634", "bodyText": "done", "author": "vsevel", "createdAt": "2020-04-07T10:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NzEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3Nzc4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404577787", "bodyText": "Generally speaking I don't like passing nulls to constructors, can we provide an empty constructor which it specifically do this?", "author": "lordofthejars", "createdAt": "2020-04-07T06:58:47Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/client/OkHttpVaultClient.java", "diffHunk": "@@ -252,6 +254,18 @@ public VaultInitResponse init(int secretShares, int secretThreshold) {\n         return put(\"sys/init\", body, VaultInitResponse.class);\n     }\n \n+    public VaultWrapResult wrap(String token, long ttl, Object object) {\n+        Map<String, String> headers = new HashMap<>();\n+        headers.put(\"X-Vault-Wrap-TTL\", \"\" + ttl);\n+        return post(\"sys/wrapping/wrap\", token, headers, object, VaultWrapResult.class);\n+    }\n+\n+    @Override\n+    public <T> T unwrap(String wrappingToken, Class<T> resultClass) {\n+        VaultUnwrapBody body = new VaultUnwrapBody(null);", "originalCommit": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5NTg0OA==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404695848", "bodyText": "I just passed a null body, which is equivalent in this case", "author": "vsevel", "createdAt": "2020-04-07T10:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3Nzc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxNjg2NA==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404716864", "bodyText": "I know but from the point of view of clean code, I am not sure this is the best way to do it. I'd advocate for creating an empty constructor to hide the details.", "author": "lordofthejars", "createdAt": "2020-04-07T10:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3Nzc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNDAwNw==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404734007", "bodyText": "what I mean is this:\n    @Override\n    public <T> T unwrap(String wrappingToken, Class<T> resultClass) {\n        return post(\"sys/wrapping/unwrap\", wrappingToken, null, resultClass);\n    }\n\nare you ok with this, or are you advocating this:\n    @Override\n    public <T> T unwrap(String wrappingToken, Class<T> resultClass) {\n        return post(\"sys/wrapping/unwrap\", wrappingToken, new VaultUnwrapBody(), resultClass);\n    }", "author": "vsevel", "createdAt": "2020-04-07T11:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3Nzc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNjc2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404736761", "bodyText": "If am not wrong this calls happens inside the same class, although maybe I'd create a VaultUnwrapBody.EMPTY constant representing an empty VaultUnwrapBody that is empty, since it is an internal call a null might be ok. But a public constructor that can be used outside and in several places, I think it is better to not send a null as in my opinion it looks odd.", "author": "lordofthejars", "createdAt": "2020-04-07T11:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3Nzc4Nw=="}], "type": "inlineReview"}, {"oid": "c1a42c979bf3ac443532af6638e67f8e7e4c9760", "url": "https://github.com/quarkusio/quarkus/commit/c1a42c979bf3ac443532af6638e67f8e7e4c9760", "message": "review @lordofthejars", "committedDate": "2020-04-07T13:56:47Z", "type": "commit"}, {"oid": "116f63d4017eed835072dd7ee580d5b946a0c53c", "url": "https://github.com/quarkusio/quarkus/commit/116f63d4017eed835072dd7ee580d5b946a0c53c", "message": "support for userpass password-wrapping-token", "committedDate": "2020-04-09T08:49:17Z", "type": "commit"}]}