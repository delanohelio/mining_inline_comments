{"pr_number": 9442, "pr_title": "AWS SQS guide", "pr_createdAt": "2020-05-19T08:09:35Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9442", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI1ODk3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427258977", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n          \n          \n            \n            SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they were sent.", "author": "gsmet", "createdAt": "2020-05-19T12:22:46Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2MDY0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427260646", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n          \n          \n            \n            Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using the synchronous client.", "author": "gsmet", "createdAt": "2020-05-19T12:25:38Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2MTAwNA==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427261004", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n          \n          \n            \n            Because of the fact messages sent to the queue must be a `String`, we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.", "author": "gsmet", "createdAt": "2020-05-19T12:26:11Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2MTIxMw==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427261213", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.\n          \n          \n            \n            Now, create the `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from the `ColliderQueue` queue.", "author": "gsmet", "createdAt": "2020-05-19T12:26:33Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n+\n+Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2MTQ3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427261471", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Both SSS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n          \n          \n            \n            Both SQS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.", "author": "gsmet", "createdAt": "2020-05-19T12:26:58Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n+\n+Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public List<Quark> receive() {\n+        List<Message> messages = sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)).messages();\n+\n+        return messages.stream()\n+            .map(Message::body)\n+            .map(this::toQuark)\n+            .collect(Collectors.toList());\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+We are using here a Jackson's `ObjectReader` in order to deserialize queue messages into our `Quark` POJOs.\n+\n+== Configuring SQS clients\n+\n+Both SSS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2MTY2NA==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427261664", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n          \n          \n            \n            Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses the URL connection HTTP client, so", "author": "gsmet", "createdAt": "2020-05-19T12:27:16Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n+\n+Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public List<Quark> receive() {\n+        List<Message> messages = sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)).messages();\n+\n+        return messages.stream()\n+            .map(Message::body)\n+            .map(this::toQuark)\n+            .collect(Collectors.toList());\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+We are using here a Jackson's `ObjectReader` in order to deserialize queue messages into our `Quark` POJOs.\n+\n+== Configuring SQS clients\n+\n+Both SSS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2MjA1NA==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427262054", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - `quarkus.sqs.endpoint-override` - Override the SNS client to use a local instance instead of an AWS service\n          \n          \n            \n            - `quarkus.sqs.endpoint-override` - Override the SQS client to use a local instance instead of an AWS service", "author": "gsmet", "createdAt": "2020-05-19T12:27:50Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n+\n+Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public List<Quark> receive() {\n+        List<Message> messages = sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)).messages();\n+\n+        return messages.stream()\n+            .map(Message::body)\n+            .map(this::toQuark)\n+            .collect(Collectors.toList());\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+We are using here a Jackson's `ObjectReader` in order to deserialize queue messages into our `Quark` POJOs.\n+\n+== Configuring SQS clients\n+\n+Both SSS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n+you need to add a URL connection client dependency to the `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>url-connection-client</artifactId>\n+</dependency>\n+----\n+\n+If you want to use Apache HTTP client instead, configure it as follows:\n+[source,properties]\n+----\n+quarkus.sqs.sync-client.type=apache\n+----\n+\n+And add the following dependency to the application `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>apache-client</artifactId>\n+</dependency>\n+----\n+\n+If you're going to use a local SQS instance, configure it as follows:\n+\n+[source,properties]\n+----\n+quarkus.sqs.endpoint-override=http://localhost:8010\n+\n+quarkus.sqs.aws.region=us-east-1\n+quarkus.sqs.aws.credentials.type=static\n+quarkus.sqs.aws.credentials.static-provider.access-key-id=test-key\n+quarkus.sqs.aws.credentials.static-provider.secret-access-key=test-secret\n+----\n+\n+- `quarkus.sqs.aws.region` - It's required by the client, but since you're using a local SQS instance use `us-east-1` as it's a default region of localstack's SQS.\n+- `quarkus.sqs.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`\n+- `quarkus.sqs.endpoint-override` - Override the SNS client to use a local instance instead of an AWS service", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2MjE4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427262181", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you want to work with an AWS account, you can simply remove or comment out all SQS related properties. By default, SQS client extension\n          \n          \n            \n            If you want to work with an AWS account, you can simply remove or comment out all SQS related properties. By default, the SQS client extension", "author": "gsmet", "createdAt": "2020-05-19T12:28:04Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n+\n+Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public List<Quark> receive() {\n+        List<Message> messages = sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)).messages();\n+\n+        return messages.stream()\n+            .map(Message::body)\n+            .map(this::toQuark)\n+            .collect(Collectors.toList());\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+We are using here a Jackson's `ObjectReader` in order to deserialize queue messages into our `Quark` POJOs.\n+\n+== Configuring SQS clients\n+\n+Both SSS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n+you need to add a URL connection client dependency to the `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>url-connection-client</artifactId>\n+</dependency>\n+----\n+\n+If you want to use Apache HTTP client instead, configure it as follows:\n+[source,properties]\n+----\n+quarkus.sqs.sync-client.type=apache\n+----\n+\n+And add the following dependency to the application `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>apache-client</artifactId>\n+</dependency>\n+----\n+\n+If you're going to use a local SQS instance, configure it as follows:\n+\n+[source,properties]\n+----\n+quarkus.sqs.endpoint-override=http://localhost:8010\n+\n+quarkus.sqs.aws.region=us-east-1\n+quarkus.sqs.aws.credentials.type=static\n+quarkus.sqs.aws.credentials.static-provider.access-key-id=test-key\n+quarkus.sqs.aws.credentials.static-provider.secret-access-key=test-secret\n+----\n+\n+- `quarkus.sqs.aws.region` - It's required by the client, but since you're using a local SQS instance use `us-east-1` as it's a default region of localstack's SQS.\n+- `quarkus.sqs.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`\n+- `quarkus.sqs.endpoint-override` - Override the SNS client to use a local instance instead of an AWS service\n+\n+If you want to work with an AWS account, you can simply remove or comment out all SQS related properties. By default, SQS client extension", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2MjI5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427262299", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            will use `default` credentials provider chain that looks for credentials in this order:\n          \n          \n            \n            will use the `default` credentials provider chain that looks for credentials in this order:", "author": "gsmet", "createdAt": "2020-05-19T12:28:18Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n+\n+Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public List<Quark> receive() {\n+        List<Message> messages = sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)).messages();\n+\n+        return messages.stream()\n+            .map(Message::body)\n+            .map(this::toQuark)\n+            .collect(Collectors.toList());\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+We are using here a Jackson's `ObjectReader` in order to deserialize queue messages into our `Quark` POJOs.\n+\n+== Configuring SQS clients\n+\n+Both SSS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n+you need to add a URL connection client dependency to the `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>url-connection-client</artifactId>\n+</dependency>\n+----\n+\n+If you want to use Apache HTTP client instead, configure it as follows:\n+[source,properties]\n+----\n+quarkus.sqs.sync-client.type=apache\n+----\n+\n+And add the following dependency to the application `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>apache-client</artifactId>\n+</dependency>\n+----\n+\n+If you're going to use a local SQS instance, configure it as follows:\n+\n+[source,properties]\n+----\n+quarkus.sqs.endpoint-override=http://localhost:8010\n+\n+quarkus.sqs.aws.region=us-east-1\n+quarkus.sqs.aws.credentials.type=static\n+quarkus.sqs.aws.credentials.static-provider.access-key-id=test-key\n+quarkus.sqs.aws.credentials.static-provider.secret-access-key=test-secret\n+----\n+\n+- `quarkus.sqs.aws.region` - It's required by the client, but since you're using a local SQS instance use `us-east-1` as it's a default region of localstack's SQS.\n+- `quarkus.sqs.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`\n+- `quarkus.sqs.endpoint-override` - Override the SNS client to use a local instance instead of an AWS service\n+\n+If you want to work with an AWS account, you can simply remove or comment out all SQS related properties. By default, SQS client extension\n+will use `default` credentials provider chain that looks for credentials in this order:", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2MjY5MA==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427262690", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            And corresponding async receiver of the queue messages `org.acme.sqs.QuarksShieldAsyncResource`\n          \n          \n            \n            And the corresponding async receiver of the queue messages `org.acme.sqs.QuarksShieldAsyncResource`", "author": "gsmet", "createdAt": "2020-05-19T12:29:00Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n+\n+Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public List<Quark> receive() {\n+        List<Message> messages = sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)).messages();\n+\n+        return messages.stream()\n+            .map(Message::body)\n+            .map(this::toQuark)\n+            .collect(Collectors.toList());\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+We are using here a Jackson's `ObjectReader` in order to deserialize queue messages into our `Quark` POJOs.\n+\n+== Configuring SQS clients\n+\n+Both SSS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n+you need to add a URL connection client dependency to the `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>url-connection-client</artifactId>\n+</dependency>\n+----\n+\n+If you want to use Apache HTTP client instead, configure it as follows:\n+[source,properties]\n+----\n+quarkus.sqs.sync-client.type=apache\n+----\n+\n+And add the following dependency to the application `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>apache-client</artifactId>\n+</dependency>\n+----\n+\n+If you're going to use a local SQS instance, configure it as follows:\n+\n+[source,properties]\n+----\n+quarkus.sqs.endpoint-override=http://localhost:8010\n+\n+quarkus.sqs.aws.region=us-east-1\n+quarkus.sqs.aws.credentials.type=static\n+quarkus.sqs.aws.credentials.static-provider.access-key-id=test-key\n+quarkus.sqs.aws.credentials.static-provider.secret-access-key=test-secret\n+----\n+\n+- `quarkus.sqs.aws.region` - It's required by the client, but since you're using a local SQS instance use `us-east-1` as it's a default region of localstack's SQS.\n+- `quarkus.sqs.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`\n+- `quarkus.sqs.endpoint-override` - Override the SNS client to use a local instance instead of an AWS service\n+\n+If you want to work with an AWS account, you can simply remove or comment out all SQS related properties. By default, SQS client extension\n+will use `default` credentials provider chain that looks for credentials in this order:\n+- Java System Properties - `aws.accessKeyId` and `aws.secretKey`\n+* Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`\n+* Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI\n+* Credentials delivered through the Amazon EC2 container service if the `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the security manager has permission to access the variable,\n+* Instance profile credentials delivered through the Amazon EC2 metadata service\n+\n+And the region from your AWS CLI profile will be used.\n+\n+== Next steps\n+\n+=== Packaging\n+\n+Packaging your application is as simple as `./mvnw clean package`.\n+It can be run with `java -Dqueue.url=$QUEUE_URL -jar target/amazon-sqs-quickstart-1.0-SNAPSHOT-runner.jar`.\n+\n+With GraalVM installed, you can also create a native executable binary: `./mvnw clean package -Dnative`.\n+Depending on your system, that will take some time.\n+\n+=== Going asynchronous\n+\n+Thanks to the AWS SDK v2.x used by the Quarkus extension, you can use the asynchronous programming model out of the box.\n+\n+Create a `org.acme.sqs.QuarksCannonAsyncResource` REST resource that will be similar to our `QuarksCannonSyncResource` but using an asynchronous programming model.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import io.smallrye.mutiny.Uni;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsAsyncClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/async/cannon\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class QuarksCannonAsyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonAsyncResource.class);\n+\n+    @Inject\n+    SqsAsyncClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Uni<Response> sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        return Uni.createFrom()\n+            .completionStage(sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message)))\n+            .onItem().invoke(item -> LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin()))\n+            .onItem().apply(SendMessageResponse::messageId)\n+            .onItem().apply(id -> Response.ok().entity(id).build());\n+    }\n+}\n+----\n+We create `Uni` instances from the `CompletionStage` objects returned by the asynchronous SQS client, and then transform the emitted item.\n+\n+And corresponding async receiver of the queue messages `org.acme.sqs.QuarksShieldAsyncResource`", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2Mjc5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427262791", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            And we need to add Netty HTTP client dependency to the `pom.xml`:\n          \n          \n            \n            And we need to add the Netty HTTP client dependency to the `pom.xml`:", "author": "gsmet", "createdAt": "2020-05-19T12:29:10Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n+\n+Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public List<Quark> receive() {\n+        List<Message> messages = sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)).messages();\n+\n+        return messages.stream()\n+            .map(Message::body)\n+            .map(this::toQuark)\n+            .collect(Collectors.toList());\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+We are using here a Jackson's `ObjectReader` in order to deserialize queue messages into our `Quark` POJOs.\n+\n+== Configuring SQS clients\n+\n+Both SSS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n+you need to add a URL connection client dependency to the `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>url-connection-client</artifactId>\n+</dependency>\n+----\n+\n+If you want to use Apache HTTP client instead, configure it as follows:\n+[source,properties]\n+----\n+quarkus.sqs.sync-client.type=apache\n+----\n+\n+And add the following dependency to the application `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>apache-client</artifactId>\n+</dependency>\n+----\n+\n+If you're going to use a local SQS instance, configure it as follows:\n+\n+[source,properties]\n+----\n+quarkus.sqs.endpoint-override=http://localhost:8010\n+\n+quarkus.sqs.aws.region=us-east-1\n+quarkus.sqs.aws.credentials.type=static\n+quarkus.sqs.aws.credentials.static-provider.access-key-id=test-key\n+quarkus.sqs.aws.credentials.static-provider.secret-access-key=test-secret\n+----\n+\n+- `quarkus.sqs.aws.region` - It's required by the client, but since you're using a local SQS instance use `us-east-1` as it's a default region of localstack's SQS.\n+- `quarkus.sqs.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`\n+- `quarkus.sqs.endpoint-override` - Override the SNS client to use a local instance instead of an AWS service\n+\n+If you want to work with an AWS account, you can simply remove or comment out all SQS related properties. By default, SQS client extension\n+will use `default` credentials provider chain that looks for credentials in this order:\n+- Java System Properties - `aws.accessKeyId` and `aws.secretKey`\n+* Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`\n+* Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI\n+* Credentials delivered through the Amazon EC2 container service if the `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the security manager has permission to access the variable,\n+* Instance profile credentials delivered through the Amazon EC2 metadata service\n+\n+And the region from your AWS CLI profile will be used.\n+\n+== Next steps\n+\n+=== Packaging\n+\n+Packaging your application is as simple as `./mvnw clean package`.\n+It can be run with `java -Dqueue.url=$QUEUE_URL -jar target/amazon-sqs-quickstart-1.0-SNAPSHOT-runner.jar`.\n+\n+With GraalVM installed, you can also create a native executable binary: `./mvnw clean package -Dnative`.\n+Depending on your system, that will take some time.\n+\n+=== Going asynchronous\n+\n+Thanks to the AWS SDK v2.x used by the Quarkus extension, you can use the asynchronous programming model out of the box.\n+\n+Create a `org.acme.sqs.QuarksCannonAsyncResource` REST resource that will be similar to our `QuarksCannonSyncResource` but using an asynchronous programming model.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import io.smallrye.mutiny.Uni;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsAsyncClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/async/cannon\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class QuarksCannonAsyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonAsyncResource.class);\n+\n+    @Inject\n+    SqsAsyncClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Uni<Response> sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        return Uni.createFrom()\n+            .completionStage(sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message)))\n+            .onItem().invoke(item -> LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin()))\n+            .onItem().apply(SendMessageResponse::messageId)\n+            .onItem().apply(id -> Response.ok().entity(id).build());\n+    }\n+}\n+----\n+We create `Uni` instances from the `CompletionStage` objects returned by the asynchronous SQS client, and then transform the emitted item.\n+\n+And corresponding async receiver of the queue messages `org.acme.sqs.QuarksShieldAsyncResource`\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.smallrye.mutiny.Uni;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsAsyncClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+import software.amazon.awssdk.services.sqs.model.ReceiveMessageResponse;\n+\n+@Path(\"/async/shield\")\n+public class QuarksShieldAsyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldAsyncResource.class);\n+\n+    @Inject\n+    SqsAsyncClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Uni<List<Quark>> receive() {\n+        return Uni.createFrom()\n+            .completionStage(sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)))\n+            .onItem().apply(ReceiveMessageResponse::messages)\n+            .onItem().apply(m -> m.stream().map(Message::body).map(this::toQuark).collect(Collectors.toList()));\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+And we need to add Netty HTTP client dependency to the `pom.xml`:", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI2Mjg4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9442#discussion_r427262883", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            include::{generated-dir}/config/quarkus-amazon-sns.adoc[opts=optional, leveloffset=+1]\n          \n          \n            \n            include::{generated-dir}/config/quarkus-amazon-sqs.adoc[opts=optional, leveloffset=+1]", "author": "gsmet", "createdAt": "2020-05-19T12:29:20Z", "path": "docs/src/main/asciidoc/amazon-sqs.adoc", "diffHunk": "@@ -0,0 +1,463 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Amazon SQS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Queue Service (SQS) is a fully managed message queuing service.\n+Using SQS, you can send, store, and receive messages between software components at any volume, without losing messages or requiring other\n+services to be available.\n+SQS offers two types of message queues. Standard queues offer maximum throughput, best-effort ordering and at-least-once delivery.\n+SQS FIFO queues are designed to guarantee that messages are processes exactly once, on the exact order that they sent.\n+\n+You can find more information about SQS at https://aws.amazon.com/sws/[the Amazon SQS website].\n+\n+NOTE: The SQS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use SQS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SQS service\n+* Docker for your system to run SQS locally for testing purposes\n+\n+=== Set up SQS locally\n+\n+The easiest way to start working with SQS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run --rm --name local-sqs 8010:4576 -e SERVICES=sqs -e START_WEB=0 -d localstack/localstack:0.11.1\n+----\n+This starts a SQS instance that is accessible on port `8010`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+=== Create a SQS queue\n+\n+Create a SQS queue using AWS CLI and store in `QUEUE_URL` environment variable.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue --profile localstack --endpoint-url=http://localhost:8010`\n+----\n+\n+Or, if you want to use your SQS queue on your AWS account create a queue using your default profile\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+QUEUE_URL=`aws sqs create-queue --queue-name=ColliderQueue`\n+----\n+\n+== Solution\n+The application built here allows shooting an elementary particles (quarks) into a `ColliderQueue` queue of the AWS SQS.\n+Additionally, we create a resource that allows receiving those quarks from the `ColliderQueue` queue in the order they were sent.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sqs-quickstart` {quickstarts-tree-url}/amazon-sqs-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sqs-quickstart \\\n+    -DclassName=\"org.acme.sqs.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sqs,resteasy-mutiny\"\n+cd amazon-sqs-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SQS Client extensions.\n+After this, the `amazon-sqs` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that sends quarks via the queue. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sqs.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sqs.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SQS queue using synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        SendMessageResponse response = sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message));\n+        LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact messages send to the queue must be a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.\n+\n+Now, create `org.acme.QuarksShieldSyncResource` REST resources that provides an endpoint to read the messages from `ColliderQueue` queue.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    @Inject\n+    SqsClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public List<Quark> receive() {\n+        List<Message> messages = sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)).messages();\n+\n+        return messages.stream()\n+            .map(Message::body)\n+            .map(this::toQuark)\n+            .collect(Collectors.toList());\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+We are using here a Jackson's `ObjectReader` in order to deserialize queue messages into our `Quark` POJOs.\n+\n+== Configuring SQS clients\n+\n+Both SSS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n+you need to add a URL connection client dependency to the `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>url-connection-client</artifactId>\n+</dependency>\n+----\n+\n+If you want to use Apache HTTP client instead, configure it as follows:\n+[source,properties]\n+----\n+quarkus.sqs.sync-client.type=apache\n+----\n+\n+And add the following dependency to the application `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>apache-client</artifactId>\n+</dependency>\n+----\n+\n+If you're going to use a local SQS instance, configure it as follows:\n+\n+[source,properties]\n+----\n+quarkus.sqs.endpoint-override=http://localhost:8010\n+\n+quarkus.sqs.aws.region=us-east-1\n+quarkus.sqs.aws.credentials.type=static\n+quarkus.sqs.aws.credentials.static-provider.access-key-id=test-key\n+quarkus.sqs.aws.credentials.static-provider.secret-access-key=test-secret\n+----\n+\n+- `quarkus.sqs.aws.region` - It's required by the client, but since you're using a local SQS instance use `us-east-1` as it's a default region of localstack's SQS.\n+- `quarkus.sqs.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`\n+- `quarkus.sqs.endpoint-override` - Override the SNS client to use a local instance instead of an AWS service\n+\n+If you want to work with an AWS account, you can simply remove or comment out all SQS related properties. By default, SQS client extension\n+will use `default` credentials provider chain that looks for credentials in this order:\n+- Java System Properties - `aws.accessKeyId` and `aws.secretKey`\n+* Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`\n+* Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI\n+* Credentials delivered through the Amazon EC2 container service if the `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the security manager has permission to access the variable,\n+* Instance profile credentials delivered through the Amazon EC2 metadata service\n+\n+And the region from your AWS CLI profile will be used.\n+\n+== Next steps\n+\n+=== Packaging\n+\n+Packaging your application is as simple as `./mvnw clean package`.\n+It can be run with `java -Dqueue.url=$QUEUE_URL -jar target/amazon-sqs-quickstart-1.0-SNAPSHOT-runner.jar`.\n+\n+With GraalVM installed, you can also create a native executable binary: `./mvnw clean package -Dnative`.\n+Depending on your system, that will take some time.\n+\n+=== Going asynchronous\n+\n+Thanks to the AWS SDK v2.x used by the Quarkus extension, you can use the asynchronous programming model out of the box.\n+\n+Create a `org.acme.sqs.QuarksCannonAsyncResource` REST resource that will be similar to our `QuarksCannonSyncResource` but using an asynchronous programming model.\n+\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import io.smallrye.mutiny.Uni;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsAsyncClient;\n+import software.amazon.awssdk.services.sqs.model.SendMessageResponse;\n+\n+@Path(\"/async/cannon\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class QuarksCannonAsyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonAsyncResource.class);\n+\n+    @Inject\n+    SqsAsyncClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Uni<Response> sendMessage(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        return Uni.createFrom()\n+            .completionStage(sqs.sendMessage(m -> m.queueUrl(queueUrl).messageBody(message)))\n+            .onItem().invoke(item -> LOGGER.infov(\"Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin()))\n+            .onItem().apply(SendMessageResponse::messageId)\n+            .onItem().apply(id -> Response.ok().entity(id).build());\n+    }\n+}\n+----\n+We create `Uni` instances from the `CompletionStage` objects returned by the asynchronous SQS client, and then transform the emitted item.\n+\n+And corresponding async receiver of the queue messages `org.acme.sqs.QuarksShieldAsyncResource`\n+[source,java]\n+----\n+package org.acme.sqs;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import io.smallrye.mutiny.Uni;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import org.acme.sqs.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sqs.SqsAsyncClient;\n+import software.amazon.awssdk.services.sqs.model.Message;\n+import software.amazon.awssdk.services.sqs.model.ReceiveMessageResponse;\n+\n+@Path(\"/async/shield\")\n+public class QuarksShieldAsyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldAsyncResource.class);\n+\n+    @Inject\n+    SqsAsyncClient sqs;\n+\n+    @ConfigProperty(name = \"queue.url\")\n+    String queueUrl;\n+\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @GET\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Uni<List<Quark>> receive() {\n+        return Uni.createFrom()\n+            .completionStage(sqs.receiveMessage(m -> m.maxNumberOfMessages(10).queueUrl(queueUrl)))\n+            .onItem().apply(ReceiveMessageResponse::messages)\n+            .onItem().apply(m -> m.stream().map(Message::body).map(this::toQuark).collect(Collectors.toList()));\n+    }\n+\n+    private Quark toQuark(String message) {\n+        Quark quark = null;\n+        try {\n+            quark = QUARK_READER.readValue(message);\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error decoding message\", e);\n+            throw new RuntimeException(e);\n+        }\n+        return quark;\n+    }\n+}\n+----\n+\n+And we need to add Netty HTTP client dependency to the `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>netty-nio-client</artifactId>\n+</dependency>\n+----\n+\n+== Configuration Reference\n+\n+include::{generated-dir}/config/quarkus-amazon-sns.adoc[opts=optional, leveloffset=+1]", "originalCommit": "7ae1bac8b42f59cc14de935e07ed197e400b8856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3141987e93893d87f73c7f72e3f05e7faf19b2cb", "url": "https://github.com/quarkusio/quarkus/commit/3141987e93893d87f73c7f72e3f05e7faf19b2cb", "message": "AWS SQS guide", "committedDate": "2020-05-19T12:46:50Z", "type": "commit"}, {"oid": "3141987e93893d87f73c7f72e3f05e7faf19b2cb", "url": "https://github.com/quarkusio/quarkus/commit/3141987e93893d87f73c7f72e3f05e7faf19b2cb", "message": "AWS SQS guide", "committedDate": "2020-05-19T12:46:50Z", "type": "forcePushed"}]}