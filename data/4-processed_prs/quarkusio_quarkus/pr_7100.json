{"pr_number": 7100, "pr_title": "guide updates for knative quick start update", "pr_createdAt": "2020-02-09T13:44:55Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7100", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwMjg1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378502855", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * having access to a Kubernetes cluster. Minikube are valid options.\n          \n          \n            \n            * having access to a Kubernetes cluster. Minikube is a valid option.", "author": "gsmet", "createdAt": "2020-02-12T20:46:13Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -24,11 +23,9 @@ The OpenShift section leverages OpenShift build and route features which are not\n For this guide you need:\n \n * roughly 20 minutes\n-* having access to a Kubernetes and/or OpenShift cluster. Minikube and Minishift are valid options.\n-* having deployed Knative components on https://knative.dev/docs/install/knative-with-minikube/[Minikube]\n-or https://knative.dev/v0.6-docs/install/knative-with-minishift/[Minishift]\n-\n-\n+* having access to a Kubernetes cluster. Minikube are valid options.", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwMzA2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378503061", "bodyText": "Maybe let's remove the bullet list if you have only one item (and add a dot at the end of the sentence)?", "author": "gsmet", "createdAt": "2020-02-12T20:46:39Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -8,10 +8,9 @@ https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n include::./attributes.adoc[]\n :experimental:\n \n-\n This guide covers:\n \n-* The deployment of the application to Kubernetes\n+* The deployment of the application to Knative", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwMzMxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378503315", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Setup Kubernetes Cluster\n          \n          \n            \n            == Set up Kubernetes Cluster", "author": "gsmet", "createdAt": "2020-02-12T20:47:09Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwMzg1NA==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378503854", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <1> Make the current docker context to be that of minikube\n          \n          \n            \n            <1> Make the current Docker context to be that of minikube", "author": "gsmet", "createdAt": "2020-02-12T20:48:14Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwMzkxMg==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378503912", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Setup Nexus(Optional)\n          \n          \n            \n            == Set up Nexus (Optional)", "author": "gsmet", "createdAt": "2020-02-12T20:48:23Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwMzk5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378503991", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n          \n          \n            \n            Nexus is used for caching Maven artifacts so that Apache Maven builds are faster.", "author": "gsmet", "createdAt": "2020-02-12T20:48:34Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNDIxOA==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378504218", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n          \n          \n            \n            Wait for some time to have Nexus initialized and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch.", "author": "gsmet", "createdAt": "2020-02-12T20:49:05Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNDY3OA==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378504678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n          \n          \n            \n            As vanilla Kubernetes does not have an easy and developer friendly way to build and deploy applications to a local cluster without the need to push the image to an external container registry, we will be using Skaffold to help us build and deploy the Quarkus application onto Kubernetes.", "author": "gsmet", "createdAt": "2020-02-12T20:50:03Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNDkwNA==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378504904", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n          \n          \n            \n            The container image will not be pushed to a remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from an external container registry.", "author": "gsmet", "createdAt": "2020-02-12T20:50:30Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNTE5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378505193", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n          \n          \n            \n            To run Knative Quarkus applications, we need to use the multi-stage Docker build to build the Quarkus application container image and use it in the Kubernetes application deployment.", "author": "gsmet", "createdAt": "2020-02-12T20:51:01Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNTUyNw==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378505527", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.\n          \n          \n            \n            The following commands start a one time deployment of the Quarkus application and starts the Knative service after successfully building the container image.", "author": "gsmet", "createdAt": "2020-02-12T20:51:43Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n \n-| git.source.repo.url\n-| The GitHub repo url\n-| {quickstarts-clone-url}\n+The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNTc5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378505791", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you want to deploy Quarkus JVM image then run the following command before running skaffold:\n          \n          \n            \n            If you want to deploy a Quarkus JVM-based application then run the following command before running Skaffold:", "author": "gsmet", "createdAt": "2020-02-12T20:52:23Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n \n-| git.source.repo.url\n-| The GitHub repo url\n-| {quickstarts-clone-url}\n+The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.\n \n-| app.container.image\n-| The fully qualified name of the container image that will be pushed to the container registry after build\n-| docker.io/demo/quarkus-knative-quickstart\n-|===\n+[NOTE]\n+====\n+If you want to deploy Quarkus JVM image then run the following command before running skaffold:", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNTk5OA==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378505998", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you want to deploy Quarkus Native image then run the following command before running skaffold:\n          \n          \n            \n            If you want to deploy a Quarkus native executable (using GraalVM) then run the following command before running Skaffold:", "author": "gsmet", "createdAt": "2020-02-12T20:52:51Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n \n-| git.source.repo.url\n-| The GitHub repo url\n-| {quickstarts-clone-url}\n+The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.\n \n-| app.container.image\n-| The fully qualified name of the container image that will be pushed to the container registry after build\n-| docker.io/demo/quarkus-knative-quickstart\n-|===\n+[NOTE]\n+====\n+If you want to deploy Quarkus JVM image then run the following command before running skaffold:\n \n+[source,bash]\n+----\n+cp src/main/docker/Dockerfile.jvm Dockerfile\n+----\n \n-The following is the example command to generate the need knative resource files\n+If you want to deploy Quarkus Native image then run the following command before running skaffold:", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNjI1NA==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378506254", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It is very important to note that the Dockerfile in src/main/docker folder has been modified to support \n          \n          \n            \n            It is very important to note that the Dockerfile in the `src/main/docker` folder has been modified to support", "author": "gsmet", "createdAt": "2020-02-12T20:53:21Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n \n-| git.source.repo.url\n-| The GitHub repo url\n-| {quickstarts-clone-url}\n+The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.\n \n-| app.container.image\n-| The fully qualified name of the container image that will be pushed to the container registry after build\n-| docker.io/demo/quarkus-knative-quickstart\n-|===\n+[NOTE]\n+====\n+If you want to deploy Quarkus JVM image then run the following command before running skaffold:\n \n+[source,bash]\n+----\n+cp src/main/docker/Dockerfile.jvm Dockerfile\n+----\n \n-The following is the example command to generate the need knative resource files\n+If you want to deploy Quarkus Native image then run the following command before running skaffold:\n \n-[source, shell, subs=\"attributes+\"]\n+[source,bash]\n ----\n-mvn -Dgithub.deploy.key=$(cat ~/.ssh/quarkus-quickstarts | base64 -w 0) \\\n-    -Dgithub.keyscan=$(ssh-keyscan github.com | base64 -w 0) \\\n-    -Dcontainer.registry.url='https://quay.io/v2' \\\n-    -Dcontainer.registry.user='demo' \\\n-    -Dcontainer.registry.password='password' \\\n-    -Dgit.source.revision='master' \\\n-    -Dgit.source.repo.url='{quickstarts-clone-url}' \\ #<1>\n-    -Dapp.container.image='docker.io/demo/getting-started-knative' \\\n-    clean process-resources\n+cp src/main/docker/Dockerfile.native Dockerfile\n ----\n-<1> If your are using a private repo then you might need to use git ssh url\n \n-The above command will apply the property values to the Knative resources found in `${project.basedir}/src/main/knative`\n-and copy them to `${project.build.directory}/knative`\n-\n-Run the following command to create the Knative resources:\n+It is very important to note that the Dockerfile in src/main/docker folder has been modified to support ", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNjQxNw==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378506417", "bodyText": "to support what?", "author": "gsmet", "createdAt": "2020-02-12T20:53:40Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n \n-| git.source.repo.url\n-| The GitHub repo url\n-| {quickstarts-clone-url}\n+The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.\n \n-| app.container.image\n-| The fully qualified name of the container image that will be pushed to the container registry after build\n-| docker.io/demo/quarkus-knative-quickstart\n-|===\n+[NOTE]\n+====\n+If you want to deploy Quarkus JVM image then run the following command before running skaffold:\n \n+[source,bash]\n+----\n+cp src/main/docker/Dockerfile.jvm Dockerfile\n+----\n \n-The following is the example command to generate the need knative resource files\n+If you want to deploy Quarkus Native image then run the following command before running skaffold:\n \n-[source, shell, subs=\"attributes+\"]\n+[source,bash]\n ----\n-mvn -Dgithub.deploy.key=$(cat ~/.ssh/quarkus-quickstarts | base64 -w 0) \\\n-    -Dgithub.keyscan=$(ssh-keyscan github.com | base64 -w 0) \\\n-    -Dcontainer.registry.url='https://quay.io/v2' \\\n-    -Dcontainer.registry.user='demo' \\\n-    -Dcontainer.registry.password='password' \\\n-    -Dgit.source.revision='master' \\\n-    -Dgit.source.repo.url='{quickstarts-clone-url}' \\ #<1>\n-    -Dapp.container.image='docker.io/demo/getting-started-knative' \\\n-    clean process-resources\n+cp src/main/docker/Dockerfile.native Dockerfile\n ----\n-<1> If your are using a private repo then you might need to use git ssh url\n \n-The above command will apply the property values to the Knative resources found in `${project.basedir}/src/main/knative`\n-and copy them to `${project.build.directory}/knative`\n-\n-Run the following command to create the Knative resources:\n+It is very important to note that the Dockerfile in src/main/docker folder has been modified to support ", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNjU5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378506593", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As it will take few minutes for the build and deploy to be completed you can watch the status using:\n          \n          \n            \n            As it will take a few minutes for the build and deployment to complete, you can watch the status using:", "author": "gsmet", "createdAt": "2020-02-12T20:54:03Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n \n-| git.source.repo.url\n-| The GitHub repo url\n-| {quickstarts-clone-url}\n+The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.\n \n-| app.container.image\n-| The fully qualified name of the container image that will be pushed to the container registry after build\n-| docker.io/demo/quarkus-knative-quickstart\n-|===\n+[NOTE]\n+====\n+If you want to deploy Quarkus JVM image then run the following command before running skaffold:\n \n+[source,bash]\n+----\n+cp src/main/docker/Dockerfile.jvm Dockerfile\n+----\n \n-The following is the example command to generate the need knative resource files\n+If you want to deploy Quarkus Native image then run the following command before running skaffold:\n \n-[source, shell, subs=\"attributes+\"]\n+[source,bash]\n ----\n-mvn -Dgithub.deploy.key=$(cat ~/.ssh/quarkus-quickstarts | base64 -w 0) \\\n-    -Dgithub.keyscan=$(ssh-keyscan github.com | base64 -w 0) \\\n-    -Dcontainer.registry.url='https://quay.io/v2' \\\n-    -Dcontainer.registry.user='demo' \\\n-    -Dcontainer.registry.password='password' \\\n-    -Dgit.source.revision='master' \\\n-    -Dgit.source.repo.url='{quickstarts-clone-url}' \\ #<1>\n-    -Dapp.container.image='docker.io/demo/getting-started-knative' \\\n-    clean process-resources\n+cp src/main/docker/Dockerfile.native Dockerfile\n ----\n-<1> If your are using a private repo then you might need to use git ssh url\n \n-The above command will apply the property values to the Knative resources found in `${project.basedir}/src/main/knative`\n-and copy them to `${project.build.directory}/knative`\n-\n-Run the following command to create the Knative resources:\n+It is very important to note that the Dockerfile in src/main/docker folder has been modified to support \n+====\n \n-[source,shell]\n+[source,bash]\n ----\n-kubectl apply --recursive --filename target/knative\n+skaffold run\n ----\n \n-== Accessing your application\n+As it will take few minutes for the build and deploy to be completed you can watch the status using:", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNjY5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378506695", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: The deployment name could differ in your environment\n          \n          \n            \n            NOTE: The deployment name could differ in your environment.", "author": "gsmet", "createdAt": "2020-02-12T20:54:18Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n \n-| git.source.repo.url\n-| The GitHub repo url\n-| {quickstarts-clone-url}\n+The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.\n \n-| app.container.image\n-| The fully qualified name of the container image that will be pushed to the container registry after build\n-| docker.io/demo/quarkus-knative-quickstart\n-|===\n+[NOTE]\n+====\n+If you want to deploy Quarkus JVM image then run the following command before running skaffold:\n \n+[source,bash]\n+----\n+cp src/main/docker/Dockerfile.jvm Dockerfile\n+----\n \n-The following is the example command to generate the need knative resource files\n+If you want to deploy Quarkus Native image then run the following command before running skaffold:\n \n-[source, shell, subs=\"attributes+\"]\n+[source,bash]\n ----\n-mvn -Dgithub.deploy.key=$(cat ~/.ssh/quarkus-quickstarts | base64 -w 0) \\\n-    -Dgithub.keyscan=$(ssh-keyscan github.com | base64 -w 0) \\\n-    -Dcontainer.registry.url='https://quay.io/v2' \\\n-    -Dcontainer.registry.user='demo' \\\n-    -Dcontainer.registry.password='password' \\\n-    -Dgit.source.revision='master' \\\n-    -Dgit.source.repo.url='{quickstarts-clone-url}' \\ #<1>\n-    -Dapp.container.image='docker.io/demo/getting-started-knative' \\\n-    clean process-resources\n+cp src/main/docker/Dockerfile.native Dockerfile\n ----\n-<1> If your are using a private repo then you might need to use git ssh url\n \n-The above command will apply the property values to the Knative resources found in `${project.basedir}/src/main/knative`\n-and copy them to `${project.build.directory}/knative`\n-\n-Run the following command to create the Knative resources:\n+It is very important to note that the Dockerfile in src/main/docker folder has been modified to support \n+====\n \n-[source,shell]\n+[source,bash]\n ----\n-kubectl apply --recursive --filename target/knative\n+skaffold run\n ----\n \n-== Accessing your application\n+As it will take few minutes for the build and deploy to be completed you can watch the status using:\n+\n+[source,bash]\n+----\n+watch kubectl get pods \n+----\n \n-The application is now exposed as an internal service. If you are using `minikube` or `minishift`, you can access it using:\n+A successful Knative Service deployment will show the following pods in the current namespace:\n \n-[source,shell]\n+[source,bash]\n ----\n-INGRESSGATEWAY=istio-ingressgateway\n-IP_ADDRESS=\"$(minikube ip):$(kubectl get svc $INGRESSGATEWAY --namespace istio-system --output 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')\" #<1>\n+NAME                                     READY   STATUS    AGE\n+greeter-deployment-5749cc98fc-gs6zr      2/2     Running   10s\n+----\n+\n+NOTE: The deployment name could differ in your environment", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNjc1OA==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378506758", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A successful Knative Service deployment will show the following pods in the current namespace:\n          \n          \n            \n            A successful Knative service deployment will show the following pods in the current namespace:", "author": "gsmet", "createdAt": "2020-02-12T20:54:28Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n \n-| git.source.repo.url\n-| The GitHub repo url\n-| {quickstarts-clone-url}\n+The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.\n \n-| app.container.image\n-| The fully qualified name of the container image that will be pushed to the container registry after build\n-| docker.io/demo/quarkus-knative-quickstart\n-|===\n+[NOTE]\n+====\n+If you want to deploy Quarkus JVM image then run the following command before running skaffold:\n \n+[source,bash]\n+----\n+cp src/main/docker/Dockerfile.jvm Dockerfile\n+----\n \n-The following is the example command to generate the need knative resource files\n+If you want to deploy Quarkus Native image then run the following command before running skaffold:\n \n-[source, shell, subs=\"attributes+\"]\n+[source,bash]\n ----\n-mvn -Dgithub.deploy.key=$(cat ~/.ssh/quarkus-quickstarts | base64 -w 0) \\\n-    -Dgithub.keyscan=$(ssh-keyscan github.com | base64 -w 0) \\\n-    -Dcontainer.registry.url='https://quay.io/v2' \\\n-    -Dcontainer.registry.user='demo' \\\n-    -Dcontainer.registry.password='password' \\\n-    -Dgit.source.revision='master' \\\n-    -Dgit.source.repo.url='{quickstarts-clone-url}' \\ #<1>\n-    -Dapp.container.image='docker.io/demo/getting-started-knative' \\\n-    clean process-resources\n+cp src/main/docker/Dockerfile.native Dockerfile\n ----\n-<1> If your are using a private repo then you might need to use git ssh url\n \n-The above command will apply the property values to the Knative resources found in `${project.basedir}/src/main/knative`\n-and copy them to `${project.build.directory}/knative`\n-\n-Run the following command to create the Knative resources:\n+It is very important to note that the Dockerfile in src/main/docker folder has been modified to support \n+====\n \n-[source,shell]\n+[source,bash]\n ----\n-kubectl apply --recursive --filename target/knative\n+skaffold run\n ----\n \n-== Accessing your application\n+As it will take few minutes for the build and deploy to be completed you can watch the status using:\n+\n+[source,bash]\n+----\n+watch kubectl get pods \n+----\n \n-The application is now exposed as an internal service. If you are using `minikube` or `minishift`, you can access it using:\n+A successful Knative Service deployment will show the following pods in the current namespace:", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUwNzAwNw==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r378507007", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Once the Knative service is successfully running, you can call the service it using the script `./bin/call.sh`, which should return a response like `hello`. Allowing it to idle for approximately 60-65 seconds -- that is without any further requests --, you will see it automatically scales down to zero pods.\n          \n          \n            \n            Once the Knative service is successfully running, you can call the service using the script `./bin/call.sh`, which should return a response like `hello`. Allowing it to idle for approximately 60-65 seconds - that is without any further requests -, you will see it automatically scales down to zero pods.", "author": "gsmet", "createdAt": "2020-02-12T20:55:00Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -39,106 +36,95 @@ Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {q\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Setup Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Setup Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why skaffold ?\n \n-| container.registry.url\n-| the container registry url, NOTE: this should be a v2 container registry\n-| https://index.docker.io/v1/\n+As vanilla Kubernetes does not have a easy and developer friendly way to build and deploy application to local cluster, without the need to push the image to external container registry. We will be using skaffold to help us build and deploy the Quarkus application onto Kubernetes.\n \n-| container.registry.user\n-| The user name to authenticate with the container registry\n-|\n+== Build and deploy application\n \n-| container.registry.password\n-| The user password to authenticate with the container registry\n-|\n+[IMPORTANT]\n+====\n+The container image will not be pushed to remote container registry, and hence the container image url has to be `dev.local`, to make Knative deploy it without trying to pull it from external container registry.\n+====\n \n-| git.source.revision\n-| The revision of the source to checkout from GitHub\n-| master\n+To run Knative Quarkus application, we need to use the multi stage docker build; to build the quarkus application container image and use it in Kubernetes application deployment.\n \n-| git.source.repo.url\n-| The GitHub repo url\n-| {quickstarts-clone-url}\n+The following commands starts a one time deployment of Quarkus application and runs starts the Knative service after successful container image build.\n \n-| app.container.image\n-| The fully qualified name of the container image that will be pushed to the container registry after build\n-| docker.io/demo/quarkus-knative-quickstart\n-|===\n+[NOTE]\n+====\n+If you want to deploy Quarkus JVM image then run the following command before running skaffold:\n \n+[source,bash]\n+----\n+cp src/main/docker/Dockerfile.jvm Dockerfile\n+----\n \n-The following is the example command to generate the need knative resource files\n+If you want to deploy Quarkus Native image then run the following command before running skaffold:\n \n-[source, shell, subs=\"attributes+\"]\n+[source,bash]\n ----\n-mvn -Dgithub.deploy.key=$(cat ~/.ssh/quarkus-quickstarts | base64 -w 0) \\\n-    -Dgithub.keyscan=$(ssh-keyscan github.com | base64 -w 0) \\\n-    -Dcontainer.registry.url='https://quay.io/v2' \\\n-    -Dcontainer.registry.user='demo' \\\n-    -Dcontainer.registry.password='password' \\\n-    -Dgit.source.revision='master' \\\n-    -Dgit.source.repo.url='{quickstarts-clone-url}' \\ #<1>\n-    -Dapp.container.image='docker.io/demo/getting-started-knative' \\\n-    clean process-resources\n+cp src/main/docker/Dockerfile.native Dockerfile\n ----\n-<1> If your are using a private repo then you might need to use git ssh url\n \n-The above command will apply the property values to the Knative resources found in `${project.basedir}/src/main/knative`\n-and copy them to `${project.build.directory}/knative`\n-\n-Run the following command to create the Knative resources:\n+It is very important to note that the Dockerfile in src/main/docker folder has been modified to support \n+====\n \n-[source,shell]\n+[source,bash]\n ----\n-kubectl apply --recursive --filename target/knative\n+skaffold run\n ----\n \n-== Accessing your application\n+As it will take few minutes for the build and deploy to be completed you can watch the status using:\n+\n+[source,bash]\n+----\n+watch kubectl get pods \n+----\n \n-The application is now exposed as an internal service. If you are using `minikube` or `minishift`, you can access it using:\n+A successful Knative Service deployment will show the following pods in the current namespace:\n \n-[source,shell]\n+[source,bash]\n ----\n-INGRESSGATEWAY=istio-ingressgateway\n-IP_ADDRESS=\"$(minikube ip):$(kubectl get svc $INGRESSGATEWAY --namespace istio-system --output 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')\" #<1>\n+NAME                                     READY   STATUS    AGE\n+greeter-deployment-5749cc98fc-gs6zr      2/2     Running   10s\n+----\n+\n+NOTE: The deployment name could differ in your environment\n+\n+Once the Knative service is successfully running, you can call the service it using the script `./bin/call.sh`, which should return a response like `hello`. Allowing it to idle for approximately 60-65 seconds -- that is without any further requests --, you will see it automatically scales down to zero pods.", "originalCommit": "b6184970f518199e7efc0b2998a4b7d6a8724780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "df8f7a30432ec4371eadfada1393f894abcdc492", "url": "https://github.com/quarkusio/quarkus/commit/df8f7a30432ec4371eadfada1393f894abcdc492", "message": "(chore) review updates", "committedDate": "2020-02-13T03:06:52Z", "type": "forcePushed"}, {"oid": "c8ee8a3f1fea0bee2c26169838c58cba5627ad93", "url": "https://github.com/quarkusio/quarkus/commit/c8ee8a3f1fea0bee2c26169838c58cba5627ad93", "message": "documentation improvements", "committedDate": "2020-02-18T06:37:19Z", "type": "forcePushed"}, {"oid": "4df18731ffe9a923f7b597087ce93abbb5436958", "url": "https://github.com/quarkusio/quarkus/commit/4df18731ffe9a923f7b597087ce93abbb5436958", "message": "guide updates for knative quick start update", "committedDate": "2020-02-21T11:49:15Z", "type": "commit"}, {"oid": "4df18731ffe9a923f7b597087ce93abbb5436958", "url": "https://github.com/quarkusio/quarkus/commit/4df18731ffe9a923f7b597087ce93abbb5436958", "message": "guide updates for knative quick start update", "committedDate": "2020-02-21T11:49:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwMDQwMg==", "url": "https://github.com/quarkusio/quarkus/pull/7100#discussion_r382900402", "bodyText": "Why Skaffold? Shouldn't we offer an integral solution? Now that we have Jib support maybe the guide should be updated to use Jib? At least let's offer a single way of doing things to not confuse the users.", "author": "lordofthejars", "createdAt": "2020-02-22T09:41:20Z", "path": "docs/src/main/asciidoc/getting-started-knative.adoc", "diffHunk": "@@ -24,121 +23,107 @@ The OpenShift section leverages OpenShift build and route features which are not\n For this guide you need:\n \n * roughly 20 minutes\n-* having access to a Kubernetes and/or OpenShift cluster. Minikube and Minishift are valid options.\n-* having deployed Knative components on https://knative.dev/docs/install/knative-with-minikube/[Minikube]\n-or https://knative.dev/v0.6-docs/install/knative-with-minishift/[Minishift]\n-\n-\n+* having access to a Kubernetes cluster. Minikube is a valid option.\n+* having deployed Knative components on https://knative.dev/docs/install/knative-with-minikube/[minikube]\n+* having https://https://skaffold.dev/[Skaffold] CLI on your PATH\n \n == Solution\n \n-We recommend to follow the instructions in the next sections and build the application step by step.\n-However, you can go right to the completed example.\n+We recommend to follow the instructions in the next sections and build the application step by step. However, you can go right to the completed example.\n \n Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n \n The solution is located in the `getting-started-knative` directory.\n \n-== Deploying the application in Knative\n+== Set up Kubernetes Cluster\n \n-Before we deploy the application to Knative in Minikube or Minishift we need to create the following Kubernetes objects:\n+The following script will start minikube and deploy Knative.\n \n-- https://github.com/knative/docs/blob/master/docs/serving/deploying-with-private-registry.md#provide-container-registry-credentials-to-knative[Container registry secrets] :-\n-This is required to for the built container image to be pushed to the container registry of your choice\n-- https://developer.github.com/v3/guides/managing-deploy-keys/#deploy-keys[Deploy Key] :-\n-This is required only if you are going to pull the sources from private repository.\n-- https://github.com/knative/docs/tree/master/serving/samples/build-private-repo-go#setting-up-our-build-service-account[Build Service Account] :-\n-The Kubernetes Service Account that will have access to Container Registry secret and Deploy Key secret\n+[source,bash]\n+----\n+./bin/start-minikube.sh\n+eval $(minikube docker-env) #<1>\n+----\n \n-[NOTE]\n-====\n-If you are not using private GitHub repo then you dont need the `Deploy Key` created and added to the Build Service Account\n-====\n+<1> Make the current Docker context to be that of minikube\n \n-Run the following commands to kick start https://github.com/knative/build[Knative Build] which will build the quarkus application container image\n-using Dockerfile and https://github.com/GoogleContainerTools/kaniko[Kaniko].  After a successful build you will have the\n-Knative serving application deployed with the built container image.  You can watch the application build pods using the\n-command `kubectl get pods -w`. You can terminate the watch using the command kbd:[CTRL + c]\n+== Set up Nexus(Optional)\n \n-Since there are some parameters that you need to pass to the builds, which are right now configurable via maven properties,\n-you need to run the following maven command to make them passed to the Knative resource yamls.\n+Nexus is used for caching maven artifacts so that Apache Maven builds are faster.\n \n-.Maven Parameters\n-|===\n-|Name |Use |Example\n+[source,bash]\n+----\n+kubectl apply -f k8s/nexus.yaml\n+----\n \n-| github.deploy.key\n-| the base64 encoded private key that is configured to be used as the GitHub private repo Deploy key\n-| `cat ~/.ssh/quarkus-quickstarts \\| base64 -w 0`\n+Wait for some time to have Nexus initialize and run. You can watch the status via `kubectl get pods -w`, use kbd:[Ctrl+c] to terminate the watch.\n \n-| github.keyscan\n-| the base64 encoded value of `ssh-keyscan github.com`\n-| `ssh-keyscan github.com \\| base64 -w 0`\n+== Why Skaffold ?", "originalCommit": "4df18731ffe9a923f7b597087ce93abbb5436958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}