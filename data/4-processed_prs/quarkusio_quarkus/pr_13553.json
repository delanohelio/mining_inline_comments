{"pr_number": 13553, "pr_title": "Allow repeatable interceptor bindings", "pr_createdAt": "2020-11-30T09:15:47Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13553", "timeline": [{"oid": "70374a0c4491e2a0411cee9dc82d5a9d4d76f5e9", "url": "https://github.com/quarkusio/quarkus/commit/70374a0c4491e2a0411cee9dc82d5a9d4d76f5e9", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-11-30T10:24:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r532493327", "bodyText": "Isn't having multiple bindings of the same type (and all on class level) an error according to the specification?", "author": "manovotn", "createdAt": "2020-11-30T10:30:21Z", "path": "independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanInfo.java", "diffHunk": "@@ -449,9 +449,11 @@ private void putLifecycleInterceptors(Map<InterceptionType, InterceptionInfo> li\n \n     private void addClassLevelBindings(ClassInfo classInfo, Collection<AnnotationInstance> bindings) {\n         beanDeployment.getAnnotations(classInfo).stream()\n-                .filter(a -> beanDeployment.getInterceptorBinding(a.name()) != null\n-                        && bindings.stream().noneMatch(e -> e.name().equals(a.name())))\n-                .forEach(a -> bindings.add(a));\n+                .flatMap(a -> beanDeployment.extractInterceptorBindings(a).stream())\n+                // TODO this is weird -- either we allow multiple class-level interceptor bindings of the same type,", "originalCommit": "70374a0c4491e2a0411cee9dc82d5a9d4d76f5e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5NjMyNw==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r532496327", "bodyText": "That's how I read the spec, indeed -- but it doesn't look like we enforce it. (At least not yet.)", "author": "Ladicek", "createdAt": "2020-11-30T10:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxMzUyNA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r532513524", "bodyText": "As per Zulip conversation - this should be validated and the spec requires this because you can, for instance, declare the same binding with member on a class and on a stereotype that this class uses leading to a conflict.", "author": "manovotn", "createdAt": "2020-11-30T11:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNzk5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534137993", "bodyText": "+1 for validation and potentially a build failure, i.e. repeatable bindings are only allowed on methods which should be documented here https://quarkus.io/guides/cdi-reference#nonstandard_features", "author": "mkouba", "createdAt": "2020-12-02T12:44:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4MTYzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534181635", "bodyText": "OK, only supporting repeatable interceptor bindings on methods, that's an interesting proposition. @manovotn does perhaps Weld do the same? That would explain why there's no test for repeatable interceptor bindings on classes.", "author": "Ladicek", "createdAt": "2020-12-02T13:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE4MzUxMw==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534183513", "bodyText": "does perhaps Weld do the same? That would explain why there's no test for repeatable interceptor bindings on classes.\n\nWe should find out ;-)", "author": "mkouba", "createdAt": "2020-12-02T13:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI0NzUxOA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534247518", "bodyText": "Did you just volunteer to try that you? :-P", "author": "manovotn", "createdAt": "2020-12-02T15:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI1MTgwMg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534251802", "bodyText": "A quick remake of the existing Weld test shows me that interception happens even if I put repeatable annotation on a class-level of the bean.", "author": "manovotn", "createdAt": "2020-12-02T15:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI1NzA4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534257082", "bodyText": "Good to know. Doesn't necessarily mean we have to do the same, but I think the current behavior is actually pretty reasonable. (Once you make peace with the fact that whenever you put an interceptor binding on a method, all \"inherited\" interceptor bindings of the same type are ignored :-), which is the standard behavior for non-repeating interceptor bindings as well.)", "author": "Ladicek", "createdAt": "2020-12-02T15:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2MTcwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534261705", "bodyText": "Doesn't necessarily mean we have to do the same\n\nNo, but for most people familiar with CDI, it would then behave in an \"expected manner\". E.g. if they used it before, they likely did so on Weld and aligning it would provide consistency. So I'd be +1 for that.", "author": "manovotn", "createdAt": "2020-12-02T15:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ5MzMyNw=="}], "type": "inlineReview"}, {"oid": "78dafeffd811e28b668a41a0bf1f8eb6d04ba84e", "url": "https://github.com/quarkusio/quarkus/commit/78dafeffd811e28b668a41a0bf1f8eb6d04ba84e", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-11-30T10:40:47Z", "type": "forcePushed"}, {"oid": "62f40724e4bbe40ab316a8339e42c99a43d14700", "url": "https://github.com/quarkusio/quarkus/commit/62f40724e4bbe40ab316a8339e42c99a43d14700", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-12-01T10:54:23Z", "type": "forcePushed"}, {"oid": "8cbfd8787e5ad36249d093110530278b8cf0b91e", "url": "https://github.com/quarkusio/quarkus/commit/8cbfd8787e5ad36249d093110530278b8cf0b91e", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-12-01T14:10:03Z", "type": "forcePushed"}, {"oid": "00985a489ba1db4321c6537440c827c47e0adcda", "url": "https://github.com/quarkusio/quarkus/commit/00985a489ba1db4321c6537440c827c47e0adcda", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-12-01T14:23:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNjg4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534136882", "bodyText": "Shouldn't the expected value be 11 because ClassInterceptedBean#foo() declares @MyBinding(\"foo\") and @MyBinding(\"bar\") is inherited from the superclass?", "author": "mkouba", "createdAt": "2020-12-02T12:41:55Z", "path": "independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/interceptors/bindings/repeatable/InheritedRepeatableInterceptorBindingTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package io.quarkus.arc.test.interceptors.bindings.repeatable;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.test.ArcTestContainer;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InterceptorBinding;\n+import javax.interceptor.InvocationContext;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+/**\n+ * Tests usage of inherited repeating interceptor binding.\n+ */\n+public class InheritedRepeatableInterceptorBindingTest {\n+    @RegisterExtension\n+    public ArcTestContainer container = new ArcTestContainer(MyBinding.class, MyBinding.List.class,\n+            SuperclassWithMethodLevelBindings.class, MethodInterceptedBean.class,\n+            SuperclassWithClassLevelBindings.class, ClassInterceptedBean.class, IncrementingInterceptor.class);\n+\n+    @Test\n+    public void methodLevelInterceptor() {\n+        MethodInterceptedBean bean = Arc.container().instance(MethodInterceptedBean.class).get();\n+\n+        assertEquals(10, bean.foo());\n+        assertEquals(21, bean.foobar());\n+        assertEquals(30, bean.foobaz());\n+        assertEquals(41, bean.foobarbaz());\n+        assertEquals(50, bean.nonannotated());\n+    }\n+\n+    @Test\n+    public void classLevelInterceptor() {\n+        ClassInterceptedBean bean = Arc.container().instance(ClassInterceptedBean.class).get();\n+\n+        assertEquals(10, bean.foo());", "originalCommit": "00985a489ba1db4321c6537440c827c47e0adcda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzOTIxMw==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534139213", "bodyText": "Exactly the kind of feedback I was looking for!\nMy understanding is that if you declare an interceptor binding on a method, interceptor bindings of the same type coming from the class and all superclasses (and even stereotypes I think) are ignored.\nThis is per https://jakarta.ee/specifications/interceptors/2.0/interceptors-spec-2.0.html#binding_an_interceptor_to_a_component:\n\nAn interceptor binding declared on a method or constructor replaces an interceptor binding of the same type declared at class level or inherited from a superclass [7].", "author": "Ladicek", "createdAt": "2020-12-02T12:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNjg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0MjE1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534142153", "bodyText": "You're right but it's not very intuitive :-(. This interceptors rule is another one that was created before repeatable annotations were introduced...", "author": "mkouba", "createdAt": "2020-12-02T12:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNjg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0MzUwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534143501", "bodyText": "Yea I totally agree, the interceptors spec needs an update wrt repeatable annotations and default interface methods.", "author": "Ladicek", "createdAt": "2020-12-02T12:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNjg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0MzYwNA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534143604", "bodyText": "Yet another reason to ditch the support of the class-level repeatable bindings...", "author": "mkouba", "createdAt": "2020-12-02T12:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNjg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI1NzA3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534257071", "bodyText": "Agree. The test is \"correct\" per spec but it doesn't follow common sense.\nSince the specification is blurred in this regard (e.g. repeatable ann), we may IMO choose to go either way.\nFTR I did another quick test in Weld and Weld sides with Ladislav on this one as it also chooses not to inherit repeating annotation if declared on the current class.", "author": "manovotn", "createdAt": "2020-12-02T15:28:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzNjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzOTkzMA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534139930", "bodyText": "Hm, I don't think this should be supported. A stereotype with interceptor bindings is inherently a class-level-only concept and so I would expect the same limitations as with bindings declared on a class...", "author": "mkouba", "createdAt": "2020-12-02T12:47:11Z", "path": "independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/interceptors/bindings/repeatable/InheritedStereotypeWithRepeatableInterceptorBindingTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.arc.test.interceptors.bindings.repeatable;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.TYPE;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.test.ArcTestContainer;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import javax.enterprise.inject.Stereotype;\n+import javax.inject.Singleton;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InterceptorBinding;\n+import javax.interceptor.InvocationContext;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+/**\n+ * Tests usage of inherited stereotype containing a repeating interceptor binding.\n+ */\n+public class InheritedStereotypeWithRepeatableInterceptorBindingTest {\n+    @RegisterExtension\n+    public ArcTestContainer container = new ArcTestContainer(MyBinding.class, MyBinding.List.class, MyStereotype.class,\n+            MyBeanDefiningAnnotation.class, MySuperclass.class, MyBean.class, IncrementingInterceptor.class);\n+\n+    @Test\n+    @Disabled(\"ArC doesn't have stereotype inheritance yet\")\n+    public void test() {\n+        MyBean bean = Arc.container().instance(MyBean.class).get();\n+\n+        assertEquals(10, bean.foo());\n+        assertEquals(21, bean.foobar());\n+        assertEquals(30, bean.foobaz());\n+        assertEquals(41, bean.foobarbaz());\n+        assertEquals(51, bean.nonannotated());\n+    }\n+\n+    @Target({ ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR })\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Repeatable(MyBinding.List.class)\n+    @InterceptorBinding\n+    @interface MyBinding {\n+        String value();\n+\n+        @Target({ ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR })\n+        @Retention(RetentionPolicy.RUNTIME)\n+        @interface List {\n+            MyBinding[] value();\n+        }\n+    }\n+\n+    @MyBinding(\"foo\")\n+    @MyBinding(\"bar\")", "originalCommit": "00985a489ba1db4321c6537440c827c47e0adcda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0MjA5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534142096", "bodyText": "The stereotype is class-only.\nThe test also has methods with the same interceptor binding, verifying that if a method has an interceptor binding, other interceptor bindings (from the class, from superclasses, from stereotype) don't apply, but that's a valid case IMHO?", "author": "Ladicek", "createdAt": "2020-12-02T12:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzOTkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0MjM5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534142392", "bodyText": "(Ah and this test is @Disabled, because we don't do stereotype inheritance yet. But it's still valid to discuss I believe.)", "author": "Ladicek", "createdAt": "2020-12-02T12:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzOTkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE0NTQzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r534145431", "bodyText": "My point is that a stereotype with multiple bindings of the same type should probably result in a definition exception...", "author": "mkouba", "createdAt": "2020-12-02T12:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEzOTkzMA=="}], "type": "inlineReview"}, {"oid": "503e3067d8dfa9f6eaa0e60ecff1134f11b38122", "url": "https://github.com/quarkusio/quarkus/commit/503e3067d8dfa9f6eaa0e60ecff1134f11b38122", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-12-03T17:24:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2NDg0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r535964849", "bodyText": "Maybe we should clarify that repeatable interceptor bindings declared on interceptor classes are supported?", "author": "mkouba", "createdAt": "2020-12-04T09:39:33Z", "path": "docs/src/main/asciidoc/cdi-reference.adoc", "diffHunk": "@@ -734,6 +734,29 @@ class SharedService {\n <2> `@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`. \n <3> You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown.\n \n+=== Repeatable interceptor bindings\n+\n+Quarkus supports `@Repeatable` interceptor binding annotations, if they are declared on methods.\n+For example:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+class AllEncompassingService {\n+  @Cached(cacheName = \"foo\") // <1>\n+  @Cached(cacheName = \"bar\")\n+  BigData heavyComputation() {\n+    // ...\n+  }\n+}\n+----\n+<1> We have an imaginary interceptor that stores data to a cache.\n+The corresponding interceptor binding is called `@Cached` and is declared as `@Repeatable`.\n+In this example, the interceptor will store the method's return value in two caches, because we add `@Cached` twice.\n+\n+Repeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.", "originalCommit": "503e3067d8dfa9f6eaa0e60ecff1134f11b38122", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3MjMyMg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r535972322", "bodyText": "So this can get misleading pretty quickly IMHO. You always need to put an interceptor binding on two places:\n\non the interceptor class;\non the place that should be intercepted.\n\nI don't know if there's a good name for the 2nd item, because that's what we would need here.\nI don't think we should say anything like \"Repeatable interceptor bindings declared on classes are not supported, unless the class is an interceptor class\", because that conflates the two concepts.", "author": "Ladicek", "createdAt": "2020-12-04T09:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2NDg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NDQyMA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r535984420", "bodyText": "* on the interceptor class;\n\n\n-> Declaring Interceptor Bindings of an Interceptor\n\n* on the place that should be intercepted.\n\n\n-> Binding an Interceptor to a Component\nThis is the spec wording. So I think that we support \"Repeatable interceptor bindings declared on methods of component classes and interceptor classes\"...", "author": "mkouba", "createdAt": "2020-12-04T10:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2NDg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5NDQxNA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r535994414", "bodyText": "Gotcha, I'll try to figure something out.", "author": "Ladicek", "createdAt": "2020-12-04T10:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2NDg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxNTUwOA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r536015508", "bodyText": "WDYT about this?\n=== Repeatable interceptor bindings\n\nQuarkus has a limited support for `@Repeatable` interceptor binding annotations.\n\nWhen binding an interceptor to a component, you can declare multiple `@Repeatable` annotations on methods.\nRepeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.\nThis might be added in the future.\n\nAs an example, suppose we have an interceptor that stores method's return values into a cache.\nThe corresponding interceptor binding would be called `@Cached` and would be declared as `@Repeatable`.\nIf we wanted to store the return value into two caches at the same time, we would add `@Cached` twice:\n\n[source,java]\n----\n@ApplicationScoped\nclass AllEncompassingService {\n  @Cached(cacheName = \"foo\")\n  @Cached(cacheName = \"bar\")\n  BigData heavyComputation() {\n    // ...\n  }\n}\n----\n\nThis is how interceptors are used.\nWhat about creating an interceptor?\n\nWhen declaring interceptor bindings of an interceptor, you can add multiple `@Repeatable` annotations to the interceptor class as usual.\nThis is useless when the annotation members are `@Nonbinding`, as would be the case for the `@Cached` annotation, but is important otherwise.\n\nFor example, suppose we have an interceptor that can automatically log method invocations to certain targets.\nThe interceptor binding annotation `@Logged` would have a member called `target`, which specifies where to store the log.\nOur implementation could be restricted to console logging and file logging:\n\n[source,java]\n----\n@Interceptor\n@Logged(target = \"console\")\n@Logged(target = \"file\")\nclass NaiveLoggingInterceptor {\n  // ...\n}\n----\n\nOther interceptors could be provided to log method invocations to different targets.", "author": "Ladicek", "createdAt": "2020-12-04T10:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2NDg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5ODM0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r535998342", "bodyText": "The @Cached annotation example might be misleading since it's not part of the Quarkus annotations caching API. @CacheResult (from our API) would almost fit here, but it's not repeatable.\n@CacheInvalidate or @CacheInvalidateAll could be used here if this example should match a real-life situation.\nSee https://quarkus.io/guides/cache#caching-annotations for more details about the annotations caching API.\nBut maybe this is all OK since it's imaginary... \ud83d\ude04", "author": "gwenneg", "createdAt": "2020-12-04T10:31:29Z", "path": "docs/src/main/asciidoc/cdi-reference.adoc", "diffHunk": "@@ -734,6 +734,29 @@ class SharedService {\n <2> `@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`. \n <3> You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown.\n \n+=== Repeatable interceptor bindings\n+\n+Quarkus supports `@Repeatable` interceptor binding annotations, if they are declared on methods.\n+For example:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+class AllEncompassingService {\n+  @Cached(cacheName = \"foo\") // <1>\n+  @Cached(cacheName = \"bar\")", "originalCommit": "503e3067d8dfa9f6eaa0e60ecff1134f11b38122", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1NDcxMA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r540154710", "bodyText": "There's another reason why @Cached (even the imaginary version) might not be the best pick for that example: it doesn't really make sense to repeat an annotation aimed at retrieving data from a cache because having multiple caches on a single method would raise a lot of questions. That's probably why most (if not all) annotations-based caching API do not allow this.", "author": "gwenneg", "createdAt": "2020-12-10T13:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5ODM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1NTg2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r540155869", "bodyText": "Yea I know it's stupid. The other example too. If you have a better one, I'm all ears :-)", "author": "Ladicek", "createdAt": "2020-12-10T13:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5ODM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5ODQ5MA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r535998490", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Cached(cacheName = \"foo\") // <1>\n          \n          \n            \n              @Cached(cacheName = \"foo\") <1>", "author": "gwenneg", "createdAt": "2020-12-04T10:31:43Z", "path": "docs/src/main/asciidoc/cdi-reference.adoc", "diffHunk": "@@ -734,6 +734,29 @@ class SharedService {\n <2> `@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`. \n <3> You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown.\n \n+=== Repeatable interceptor bindings\n+\n+Quarkus supports `@Repeatable` interceptor binding annotations, if they are declared on methods.\n+For example:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+class AllEncompassingService {\n+  @Cached(cacheName = \"foo\") // <1>", "originalCommit": "503e3067d8dfa9f6eaa0e60ecff1134f11b38122", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAzNjc0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r536036745", "bodyText": "AsciiDoc actually understands // <1> and removes the //. Much better, since my IDE knows it's a Java code in that .adoc file and gives me syntax highlight and errors and everything -- I don't know why noone else does this! :-)", "author": "Ladicek", "createdAt": "2020-12-04T11:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5ODQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA2NTE1NA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r536065154", "bodyText": "That's good to know, thanks for the info!", "author": "gwenneg", "createdAt": "2020-12-04T12:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5ODQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAwMjU2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r536002567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * For most instances this will be a singleton instance (if given annotatation is an interceptor binding) or\n          \n          \n            \n                 * For most instances this will be a singleton instance (if given annotation is an interceptor binding) or", "author": "gwenneg", "createdAt": "2020-12-04T10:38:11Z", "path": "independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanDeployment.java", "diffHunk": "@@ -409,24 +412,42 @@ ClassInfo getQualifier(DotName name) {\n      * @return a collection of qualifiers or an empty collection\n      */\n     Collection<AnnotationInstance> extractQualifiers(AnnotationInstance annotation) {\n+        return extractAnnotations(annotation, qualifiers, repeatingQualifierAnnotations);\n+    }\n+\n+    ClassInfo getInterceptorBinding(DotName name) {\n+        return interceptorBindings.get(name);\n+    }\n+\n+    /**\n+     * Extracts interceptor bindings from given annotation instance.\n+     * This returns a collection because in case of repeating interceptor bindings there can be multiple.\n+     * For most instances this will be a singleton instance (if given annotatation is an interceptor binding) or", "originalCommit": "503e3067d8dfa9f6eaa0e60ecff1134f11b38122", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAzNzE4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r536037187", "bodyText": "Ah, I'll take a look at that, I copied the existing method without much thought :-)", "author": "Ladicek", "createdAt": "2020-12-04T11:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAwMjU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4ODAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r538188024", "bodyText": "Fixed this.", "author": "Ladicek", "createdAt": "2020-12-08T09:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAwMjU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAwMzAwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r536003009", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param annotation instance to be inspected\n          \n          \n            \n                 * @param annotation instance to be extracted", "author": "gwenneg", "createdAt": "2020-12-04T10:38:53Z", "path": "independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanDeployment.java", "diffHunk": "@@ -409,24 +412,42 @@ ClassInfo getQualifier(DotName name) {\n      * @return a collection of qualifiers or an empty collection\n      */\n     Collection<AnnotationInstance> extractQualifiers(AnnotationInstance annotation) {\n+        return extractAnnotations(annotation, qualifiers, repeatingQualifierAnnotations);\n+    }\n+\n+    ClassInfo getInterceptorBinding(DotName name) {\n+        return interceptorBindings.get(name);\n+    }\n+\n+    /**\n+     * Extracts interceptor bindings from given annotation instance.\n+     * This returns a collection because in case of repeating interceptor bindings there can be multiple.\n+     * For most instances this will be a singleton instance (if given annotatation is an interceptor binding) or\n+     * an empty list for cases where the annotation is not an interceptor binding.\n+     *\n+     * @param annotation instance to be inspected", "originalCommit": "503e3067d8dfa9f6eaa0e60ecff1134f11b38122", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4ODkwNA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r538188904", "bodyText": "It's either \"to be inspected\", or \"to be extracted from\". In my (arguably poor) understanding of English, \"instance to be extraced\" means it's already a result of the extraction process, which it's not; it's an input to the extraction process.", "author": "Ladicek", "createdAt": "2020-12-08T09:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAwMzAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1MzIyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r538453225", "bodyText": "You're right and on second thoughts I don't think there's a problem with this line. I'm fine with the current version.", "author": "gwenneg", "createdAt": "2020-12-08T14:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAwMzAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxNDk5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r536014992", "bodyText": "findContainerAnnotations could be renamed to better reflect the focus on @Repeatable annotations.", "author": "gwenneg", "createdAt": "2020-12-04T10:57:59Z", "path": "independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanDeployment.java", "diffHunk": "@@ -151,6 +153,7 @@\n                 }\n             }\n         }\n+        this.repeatingInterceptorBindingAnnotations = findContainerAnnotations(interceptorBindings, this.beanArchiveIndex);", "originalCommit": "503e3067d8dfa9f6eaa0e60ecff1134f11b38122", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAzNzI4MA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r536037280", "bodyText": "Thanks, I'll do that!", "author": "Ladicek", "createdAt": "2020-12-04T11:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxNDk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4NzA3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r538187072", "bodyText": "I'm looking at it again and I think this is a pretty good name. It takes annotation types and returns the containing annotation types (for each annotation in the original set that is @Repeatable). The term \"containing annotation type\" is what @Repeatable javadoc uses, so \"container annotation\" is fairly close.\nI could rename to findContainingAnnotationTypesForRepeatableAnnotationTypes or something similarly long, but I don't think that's necessary. I've just renamed the parameters and local variables, as the method was originally written only for qualifiers, but it's now used in another setting as well.", "author": "Ladicek", "createdAt": "2020-12-08T09:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxNDk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0NzYzNg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r538447636", "bodyText": "Now that I checked the Repeatable javadoc, I agree with you. The current name is good enough and I don't think the extra long and explicit version would improve the code readability. Let's leave it that way! :)", "author": "gwenneg", "createdAt": "2020-12-08T14:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAxNDk5Mg=="}], "type": "inlineReview"}, {"oid": "b5a13042d9440d58860638e08f367abef121b73c", "url": "https://github.com/quarkusio/quarkus/commit/b5a13042d9440d58860638e08f367abef121b73c", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-12-08T09:53:01Z", "type": "forcePushed"}, {"oid": "751efe38af09c45beb036bad215dd994e60a27db", "url": "https://github.com/quarkusio/quarkus/commit/751efe38af09c45beb036bad215dd994e60a27db", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-12-10T12:52:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTcwNg==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r540179706", "bodyText": "Here's a proposal which is really close from the current Quarkus caching API.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As an example, suppose we have an interceptor that stores method's return values into a cache.\n          \n          \n            \n            The corresponding interceptor binding would be called `@Cached` and would be declared as `@Repeatable`.\n          \n          \n            \n            If we wanted to store the return value into two caches at the same time, we would add `@Cached` twice:\n          \n          \n            \n            \n          \n          \n            \n            [source,java]\n          \n          \n            \n            ----\n          \n          \n            \n            @ApplicationScoped\n          \n          \n            \n            class AllEncompassingService {\n          \n          \n            \n              @Cached(cacheName = \"foo\")\n          \n          \n            \n              @Cached(cacheName = \"bar\")\n          \n          \n            \n              BigData heavyComputation() {\n          \n          \n            \n                // ...\n          \n          \n            \n              }\n          \n          \n            \n            As an example, suppose we have an interceptor that removes all entries from a cache.\n          \n          \n            \n            The corresponding interceptor binding would be called `@CacheInvalidateAll` and would be declared as `@Repeatable`.\n          \n          \n            \n            If we wanted to clear two caches at the same time, we would add `@CacheInvalidateAll` twice:\n          \n          \n            \n            \n          \n          \n            \n            [source,java]\n          \n          \n            \n            ----\n          \n          \n            \n            @ApplicationScoped\n          \n          \n            \n            class AllEncompassingService {\n          \n          \n            \n              @CacheInvalidateAll(cacheName = \"foo\")\n          \n          \n            \n              @CacheInvalidateAll(cacheName = \"bar\")\n          \n          \n            \n              void clearBothCaches() {\n          \n          \n            \n                // ...\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nWhen this PR is merged, @CacheInvalidateAll will even become an interceptor binding (it's a simple annotation right now).", "author": "gwenneg", "createdAt": "2020-12-10T13:45:29Z", "path": "docs/src/main/asciidoc/cdi-reference.adoc", "diffHunk": "@@ -735,6 +735,52 @@ class SharedService {\n <2> `@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`. \n <3> You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown.\n \n+=== Repeatable interceptor bindings\n+\n+Quarkus has limited support for `@Repeatable` interceptor binding annotations.\n+\n+When binding an interceptor to a component, you can declare multiple `@Repeatable` annotations on methods.\n+Repeatable interceptor bindings declared on classes and stereotypes are not supported, because there are some open questions around interactions with the Interceptors specification.\n+This might be added in the future.\n+\n+As an example, suppose we have an interceptor that stores method's return values into a cache.\n+The corresponding interceptor binding would be called `@Cached` and would be declared as `@Repeatable`.\n+If we wanted to store the return value into two caches at the same time, we would add `@Cached` twice:\n+\n+[source,java]\n+----\n+@ApplicationScoped\n+class AllEncompassingService {\n+  @Cached(cacheName = \"foo\")\n+  @Cached(cacheName = \"bar\")\n+  BigData heavyComputation() {\n+    // ...\n+  }", "originalCommit": "751efe38af09c45beb036bad215dd994e60a27db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4NTQwNA==", "url": "https://github.com/quarkusio/quarkus/pull/13553#discussion_r540185404", "bodyText": "OK, I didn't really want to use existing annotations, but this will do, thanks! :-)", "author": "Ladicek", "createdAt": "2020-12-10T13:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTcwNg=="}], "type": "inlineReview"}, {"oid": "efdc6a37ed410209680c6a1e69f4a3282a59f922", "url": "https://github.com/quarkusio/quarkus/commit/efdc6a37ed410209680c6a1e69f4a3282a59f922", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-12-10T14:10:21Z", "type": "forcePushed"}, {"oid": "a1cc18f40b83c5fb28422cfd5b4cb1a9fd04b6bb", "url": "https://github.com/quarkusio/quarkus/commit/a1cc18f40b83c5fb28422cfd5b4cb1a9fd04b6bb", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-12-10T15:54:21Z", "type": "commit"}, {"oid": "a1cc18f40b83c5fb28422cfd5b4cb1a9fd04b6bb", "url": "https://github.com/quarkusio/quarkus/commit/a1cc18f40b83c5fb28422cfd5b4cb1a9fd04b6bb", "message": "Allow repeatable interceptor bindings", "committedDate": "2020-12-10T15:54:21Z", "type": "forcePushed"}]}