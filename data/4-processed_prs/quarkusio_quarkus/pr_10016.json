{"pr_number": 10016, "pr_title": "Hibernate Reactive session and connection leaks", "pr_createdAt": "2020-06-15T14:14:41Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/10016", "timeline": [{"oid": "8b627340f00567a369e7d80355e9d20941b02615", "url": "https://github.com/quarkusio/quarkus/commit/8b627340f00567a369e7d80355e9d20941b02615", "message": "Hibernate Reactive session and connection leaks", "committedDate": "2020-06-15T15:42:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTk1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10016#discussion_r440285953", "bodyText": "I think this is a justifiable limitation of the Uni<Mutiny.Session> functionality, because CompletionStage<Stage.Session> behaves in the same way, so we make it cached and use the same session in the entire request.", "author": "FroMage", "createdAt": "2020-06-15T16:06:48Z", "path": "extensions/hibernate-reactive/runtime/src/main/java/io/quarkus/hibernate/reactive/runtime/ReactiveSessionProducer.java", "diffHunk": "@@ -34,7 +34,7 @@\n     @RequestScoped\n     @DefaultBean\n     public Uni<Mutiny.Session> mutinySession() {\n-        return mutinySessionFactory.openSession();\n+        return mutinySessionFactory.openSession().cache();", "originalCommit": "8b627340f00567a369e7d80355e9d20941b02615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0NjcyNg==", "url": "https://github.com/quarkusio/quarkus/pull/10016#discussion_r440746726", "bodyText": "It is not a limitation, it is a bug fix \ud83d\ude04\nThe purpose of a request scoped session producer is to have a single session for the request. But if you don't add the cache operator, another session will be created anytime someone subscribes to the Uni that is injected in the users beans.", "author": "tsegismont", "createdAt": "2020-06-16T10:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1NTA1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10016#discussion_r441155052", "bodyText": "so even if the uni gets subscribed to twice in the same request, that would trigger two different sessions by default? That seems rather confusing, but perhaps necessary since a subscription could happen after the original request has completed?", "author": "aguibert", "createdAt": "2020-06-16T21:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MzEyNA==", "url": "https://github.com/quarkusio/quarkus/pull/10016#discussion_r441383124", "bodyText": "Well, with .cache you would in fact get the same session, which is what makes the most sense in this context.", "author": "FroMage", "createdAt": "2020-06-17T08:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4Njg2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10016#discussion_r440286867", "bodyText": "At this point it could be interesting to figure out if the reactiveSession has already been subscribed to, because if not, it will never have been produced and doesn't need to be closed. We might be creating it just to close it.\nBut I'm pretty sure that the current implementation is based on CompletionStage so it's eager and will always be created, so we can forget this optimisation for now.", "author": "FroMage", "createdAt": "2020-06-15T16:08:22Z", "path": "extensions/hibernate-reactive/runtime/src/main/java/io/quarkus/hibernate/reactive/runtime/ReactiveSessionProducer.java", "diffHunk": "@@ -45,11 +45,7 @@ public void disposeStageSession(@Disposes CompletionStage<Stage.Session> reactiv\n     }\n \n     public void disposeMutinySession(@Disposes Uni<Mutiny.Session> reactiveSession) {\n-        // TODO: @AGG this is not working, need to check w/ Clement to figure out the proper way\n-        reactiveSession.on().termination((session, ex, cancelled) -> {\n-            if (session != null)\n-                session.close();\n-        });\n+        reactiveSession.subscribe().with(Mutiny.Session::close);", "originalCommit": "8b627340f00567a369e7d80355e9d20941b02615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0ODgxNw==", "url": "https://github.com/quarkusio/quarkus/pull/10016#discussion_r440748817", "bodyText": "Keep in mind that when you inject the stage version of the session, it will be eagerly created. So the Mutiny version is not less efficient.\nI had a look at the session implementation code. It seems that a connection is acquired as soon as the session is created. Perhaps this should be delayed until a connection is actually needed. But I don't know if this is possible in practice.", "author": "tsegismont", "createdAt": "2020-06-16T10:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4Njg2Nw=="}], "type": "inlineReview"}, {"oid": "67a3593102f81092315ed5b137ffbeba1f0d9828", "url": "https://github.com/quarkusio/quarkus/commit/67a3593102f81092315ed5b137ffbeba1f0d9828", "message": "Hibernate Reactive session and connection leaks", "committedDate": "2020-06-16T17:22:08Z", "type": "commit"}, {"oid": "67a3593102f81092315ed5b137ffbeba1f0d9828", "url": "https://github.com/quarkusio/quarkus/commit/67a3593102f81092315ed5b137ffbeba1f0d9828", "message": "Hibernate Reactive session and connection leaks", "committedDate": "2020-06-16T17:22:08Z", "type": "forcePushed"}]}