{"pr_number": 13402, "pr_title": "Split the configuration guide into \"introduction\" and \"reference\"", "pr_createdAt": "2020-11-20T12:40:46Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13402", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MTk4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527681982", "bodyText": "It should probably be noted that this file is used to determine properties using ENV VAR naming rules, not regular property naming rules.\nOf course it's mentioned below, just saying that it might be worth the quick mention.", "author": "geoand", "createdAt": "2020-11-20T13:13:57Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,772 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. System properties\n+2. Environment variables\n+3. A file named `.env` placed in the current working directory", "originalCommit": "0dbba4a2d119c017eb21a122c01919cb5fec02af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MzgxNA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527683814", "bodyText": "Yes, it is mentioned below in the detail section. This list should be short and concise. Maybe we should make all list items links to relevant detail sections?", "author": "mkouba", "createdAt": "2020-11-20T13:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NDY4MA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527684680", "bodyText": "I like the idea of linking", "author": "geoand", "createdAt": "2020-11-20T13:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MjY3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527682671", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control.\n          \n          \n            \n            For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.", "author": "geoand", "createdAt": "2020-11-20T13:15:16Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,772 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. System properties\n+2. Environment variables\n+3. A file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+5. An application configuration file, i.e. `src/main/resources/application.properties`\n+\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control.", "originalCommit": "0dbba4a2d119c017eb21a122c01919cb5fec02af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MzM0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527683341", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This behavior which differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n          \n          \n            \n            This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].", "author": "geoand", "createdAt": "2020-11-20T13:16:36Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,772 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. System properties\n+2. Environment variables\n+3. A file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+5. An application configuration file, i.e. `src/main/resources/application.properties`\n+\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+=== A configuration file placed in `$PWD/config/application.properties`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` features is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+=== An application configuration file: `src/main/resources/application.properties`\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior which differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].", "originalCommit": "0dbba4a2d119c017eb21a122c01919cb5fec02af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4MzY3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527683673", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown.\n          \n          \n            \n            So you can quickly know when your configuration is complete.\n          \n          \n            \n            NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.", "author": "geoand", "createdAt": "2020-11-20T13:17:14Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,772 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. System properties\n+2. Environment variables\n+3. A file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+5. An application configuration file, i.e. `src/main/resources/application.properties`\n+\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+=== A configuration file placed in `$PWD/config/application.properties`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` features is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+=== An application configuration file: `src/main/resources/application.properties`\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior which differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown.\n+So you can quickly know when your configuration is complete.", "originalCommit": "0dbba4a2d119c017eb21a122c01919cb5fec02af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NjQxMw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527686413", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            for its own configuration. For example to configure the HTTP server port you can set `quarkus.http.port` in\n          \n          \n            \n            for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in", "author": "geoand", "createdAt": "2020-11-20T13:22:18Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,772 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. System properties\n+2. Environment variables\n+3. A file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+5. An application configuration file, i.e. `src/main/resources/application.properties`\n+\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+=== A configuration file placed in `$PWD/config/application.properties`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` features is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+=== An application configuration file: `src/main/resources/application.properties`\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior which differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown.\n+So you can quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration. For example to configure the HTTP server port you can set `quarkus.http.port` in", "originalCommit": "0dbba4a2d119c017eb21a122c01919cb5fec02af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527687024", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            However, some extensions do define properties _overridable at runtime_.\n          \n          \n            \n            However, some extensions do define properties that are _overridable at runtime_.", "author": "geoand", "createdAt": "2020-11-20T13:23:28Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,771 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. System properties\n+2. Environment variables\n+3. A file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+5. An application configuration file, i.e. `src/main/resources/application.properties`\n+\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+=== A configuration file placed in `$PWD/config/application.properties`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` features is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+=== An application configuration file: `src/main/resources/application.properties`\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n+\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n+\n+However, some extensions do define properties _overridable at runtime_.", "originalCommit": "9f71aede594314e5030837e8e9bd979d87c5d332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4Nzg2OA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527687868", "bodyText": "Hm, I'll change this to \"However, some extensions do define properties that can be overriden at runtime.\"", "author": "mkouba", "createdAt": "2020-11-20T13:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4OTc2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527689763", "bodyText": "\ud83d\udc4d", "author": "geoand", "createdAt": "2020-11-20T13:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY4NzAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY5MTU4NA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r527691584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The list of runtime properties is therefore lean.\n          \n          \n            \n            The list of runtime properties is therefore intentionaly kept lean.", "author": "geoand", "createdAt": "2020-11-20T13:31:17Z", "path": "docs/src/main/asciidoc/config.adoc", "diffHunk": "@@ -365,470 +206,21 @@ therefore `quarkus.` should **never** be used as prefix for application specific\n In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n ====\n \n-=== List of all configuration properties\n-\n-All the Quarkus configuration properties are link:all-config[documented and searchable].\n-\n-=== Generating configuration for your application\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n \n-It is also possible to generate an example `application.properties` with all known configuration properties, to make\n-it easy to see what Quarkus configuration options are available. To do this, run:\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n \n-[source,bash]\n---\n-./mvnw quarkus:generate-config\n---\n-\n-This will create a `src/main/resources/application.properties.example` file that contains all the config options\n-exposed via the extensions you currently have installed. These options are commented out, and have their default value\n-when applicable. For example this HTTP port config entry will appear as:\n-\n-\n-[source,properties]\n---\n-#\n-# The HTTP port\n-#\n-#quarkus.http.port=8080\n---\n-\n-Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n-parameter:\n-\n-[source,bash]\n---\n-./mvnw quarkus:generate-config -Dfile=application.properties\n---\n-\n-If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n-adding an additional extension to see what additional options have been added.\n-\n-== Overriding properties at runtime\n-\n-Quarkus does much of its configuration and bootstrap at build time.\n-Most properties will then be read and set during the build time step.\n-To change them, make sure to repackage your application.\n-\n-[source,bash]\n---\n-./mvnw clean package\n---\n-\n-Extensions do define _some_ properties as overridable at runtime.\n+However, some extensions do define properties _overridable at runtime_.\n A canonical example is the database URL, username and password which is only known specifically in your target environment.\n-This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. The list of runtime properties is therefore lean.\n-\n-You can override these runtime properties with the following mechanisms (in decreasing priority):\n-\n-1. using system properties:\n-  * for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n-  * for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n-2. using environment variables:\n-  * for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n-  * for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n-3. using an environment file named `.env` placed in the current working directory containing the line `QUARKUS_DATASOURCE_PASSWORD=youshallnotpass` (for dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control)\n-4. using a configuration file placed in `$PWD/config/application.properties`\n-  * By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined\n-in that file will override the default configuration. Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n-_will also_ be taken into account.\n-  * This works in the same way for runner jar and the native executable\n-\n-NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n-\n-NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n-\n-NOTE: The `config/application.properties` features is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n-Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n-\n-=== Configuration Profiles\n-\n-Quarkus supports the notion of configuration profiles. These allow you to have multiple configuration in the same file and\n-select between them via a profile name.\n-\n-The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n-\n-[source,properties]\n-----\n-quarkus.http.port=9090\n-%dev.quarkus.http.port=8181\n-----\n-\n-The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n-\n-To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n-\n-[source,.env]\n-----\n-QUARKUS_HTTP_PORT=9090\n-_DEV_QUARKUS_HTTP_PORT=8181\n-----\n-\n-By default Quarkus has three profiles, although it is possible to use as many as you like. The default profiles are:\n-\n-* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n-* *test* - Activated when running tests\n-* *prod* - The default profile when not running in development or test mode\n-\n-There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n-environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n-define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n-name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port\n-I can add the following to `application.properties`:\n-\n-[source,properties]\n-----\n-quarkus.http.port=9090\n-%staging.quarkus.http.port=9999\n-----\n-\n-And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n-\n-[NOTE]\n-====\n-The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n-\n-Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n-====\n-\n-=== Using Property Expressions\n-\n-Quarkus supports the use of property expressions in the `application.properties` file.\n-\n-These expressions are resolved when the property is read.\n-So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n-If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n-\n-You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n-\n-Property expressions are defined this way: `${my-property-expression}`.\n-\n-For example, having the following property:\n-\n-[source,properties]\n-----\n-remote.host=quarkus.io\n-----\n-and another property defined as:\n-\n-[source,properties]\n-----\n-callable.url=https://${remote.host}/\n-----\n-\n-will result in the value of the `callable.url` property being set to:\n-\n-[source,properties]\n-----\n-callable.url=https://quarkus.io/\n-----\n-\n-Another example would be defining different database servers depending on the profile used:\n-\n-[source,properties]\n-----\n-%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n-quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n-----\n-\n-can be simplified by having:\n-\n-[source,properties]\n-----\n-%dev.application.server=localhost\n-application.server=remotehost\n-\n-quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n-----\n-\n-It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n-diminishing the possibility of typos and providing more flexibility in property definitions.\n-\n-[#combine-property-env-var]\n-=== Combining Property Expressions and Environment Variables\n-\n-Quarkus also supports the combination of both property expressions and environment variables.\n-\n-Let's assume you have following property defined in `application.properties`:\n-\n-[source,properties]\n-----\n-remote.host=quarkus.io\n-----\n-\n-You can combine environment variables and property expressions by having a property defined as follows:\n-\n-[source,properties]\n-----\n-application.host=${HOST:${remote.host}}\n-----\n-\n-This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n-\n-For the purpose of this section we used the property `remote.host` we defined previously.\n-It has to be noted that the value could have been a fixed one such as in:\n-\n-[source,properties]\n-----\n-application.host=${HOST:localhost}\n-----\n-\n-which will result in `localhost` as the default value if `HOST` is not set.\n-\n-=== Clearing properties\n-\n-Run time properties which are optional, and which have had values set at build time or which have a default value,\n-may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n-run time properties, and will _only_ work with properties whose values are not required.\n-\n-The property may be cleared by setting the corresponding `application.properties` property, setting the\n-corresponding system property, or setting the corresponding environment variable.\n-\n-==== Miscellaneous\n-The default Quarkus application runtime profile is set to the profile used to build the application.\n-For example:\n-[source,bash]\n-----\n-./mvnw package -Pnative -Dquarkus.profile=prod-aws\n-./target/my-app-1.0-runner // <1>\n-----\n-<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n-\n-== Custom Configuration\n-\n-=== Custom configuration sources\n-\n-You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To\n-do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource`\n-or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a\n-https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the\n-class and it will be detected and installed at application startup.\n-\n-=== Custom configuration converters\n-\n-You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`\n-and adding its fully qualified class name in the `META-INF/services/org.eclipse.microprofile.config.spi.Converter` file.\n-\n-Let us assume you have a custom type like this one:\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-public class MicroProfileCustomValue {\n-\n-    private final int number;\n-\n-    public MicroProfileCustomValue(int number) {\n-        this.number = number;\n-    }\n-\n-    public int getNumber() {\n-        return number;\n-    }\n-}\n-----\n-\n-The corresponding converter will look like the one below. Please note that your custom converter class must be `public` and must have\n-a `public` no-argument constructor. It also must not be `abstract`.\n-\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-import org.eclipse.microprofile.config.spi.Converter;\n-\n-public class MicroProfileCustomValueConverter implements Converter<MicroProfileCustomValue> {\n-\n-    @Override\n-    public MicroProfileCustomValue convert(String value) {\n-        return new MicroProfileCustomValue(Integer.valueOf(value));\n-    }\n-}\n-----\n-\n-Then you need to include the fully qualified class name of the converter in a service file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n-If you have more converters, simply add their class names in this file as well. Single fully qualified class name per line, for example:\n-\n-[source]\n-----\n-org.acme.config.MicroProfileCustomValueConverter\n-org.acme.config.SomeOtherConverter\n-org.acme.config.YetAnotherConverter\n-----\n-\n-Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for a demonstration. If you include in this file classes\n-which are not available at runtime, the converters loading will fail.\n-\n-After this is done you can use your custom type as a configuration value:\n-\n-[source,java]\n-----\n-@ConfigProperty(name = \"configuration.value.name\")\n-MicroProfileCustomValue value;\n-----\n-\n-==== Converter priority\n-\n-In some cases, you may want to use a custom converter to convert a type which is already converted\n-by a different converter. In such cases, you can use the `javax.annotation.Priority` annotation to\n-change converters precedence and make your custom converter of higher priority than the other\n-on the list.\n-\n-By default, if no `@Priority` can be found on a converter, it's registered with a priority of 100\n-and all Quarkus core converters are registered with a priority of 200, so depending on which\n-converter you would like to replace, you need to set a higher value.\n-\n-To demonstrate the idea let us implement a custom converter which will take precedence over\n-`MicroProfileCustomValueConverter` implemented in the previous example.\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-import javax.annotation.Priority;\n-import org.eclipse.microprofile.config.spi.Converter;\n-\n-@Priority(150)\n-public class MyCustomConverter implements Converter<MicroProfileCustomValue> {\n-\n-    @Override\n-    public MicroProfileCustomValue convert(String value) {\n-\n-        final int secretNumber;\n-        if (value.startsFrom(\"OBF:\")) {\n-            secretNumber = Integer.valueOf(SecretDecoder.decode(value));\n-        } else {\n-            secretNumber = Integer.valueOf(value);\n-        }\n-\n-        return new MicroProfileCustomValue(secretNumber);\n-    }\n-}\n-----\n-\n-Since it converts the same value type (namely `MicroProfileCustomValue`) and has a priority\n-of 150, it will be used instead of a `MicroProfileCustomValueConverter` which has a default\n-priority of 100.\n-\n-NOTE: This new converter also needs to be listed in a service file, i.e. `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n-\n-[[yaml]]\n-== YAML for Configuration\n-\n-=== Add YAML Config Support\n-\n-You might want to use YAML over properties for configuration.\n-Since link:https://github.com/smallrye/smallrye-config[SmallRye Config] brings support for YAML\n-configuration, Quarkus supports this as well.\n-\n-First you will need to add the YAML extension to your `pom.xml`:\n-\n-[source,xml]\n-----\n-<dependency>\n-    <groupId>io.quarkus</groupId>\n-    <artifactId>quarkus-config-yaml</artifactId>\n-</dependency>\n-----\n-\n-Or you can alternatively run this command in the directory containing your Quarkus project:\n-\n-[source,bash]\n-----\n-./mvnw quarkus:add-extension -Dextensions=\"config-yaml\"\n-----\n-\n-Now Quarkus can read YAML configuration files.\n-The config directories and priorities are the same as before.\n-\n-NOTE: Quarkus will choose an `application.yaml` over an `application.properties`.\n-YAML files are just an alternative way to configure your application.\n-You should decide and keep one configuration type to avoid errors.\n-\n-==== Configuration Examples\n-[source,yaml]\n-----\n-# YAML supports comments\n-quarkus:\n-  datasource:\n-    db-kind: postgresql\n-    jdbc:\n-      url: jdbc:postgresql://localhost:5432/some-database\n-    username: quarkus\n-    password: quarkus\n-\n-# REST Client configuration property\n-org:\n-  acme:\n-    restclient:\n-      CountriesService/mp-rest/url: https://restcountries.eu/rest\n-\n-# For configuration property names that use quotes, do not split the string inside the quotes.\n-quarkus:\n-  log:\n-    category:\n-      \"io.quarkus.category\":\n-        level: INFO\n-----\n-\n-[NOTE]\n-====\n-Quarkus also supports using `application.yml` as the name of the YAML file. The same rules apply for this file as for `application.yaml`.\n-====\n-\n-=== Profile dependent configuration\n-\n-Providing profile dependent configuration with YAML is done like with properties.\n-Just add the `%profile` wrapped in quotation marks before defining the key-value pairs:\n-\n-[source,yaml]\n-----\n-\"%dev\":\n-  quarkus:\n-    datasource:\n-      db-kind: postgresql\n-      jdbc:\n-        url: jdbc:postgresql://localhost:5432/some-database\n-      username: quarkus\n-      password: quarkus\n-----\n-\n-=== Configuration key conflicts\n-\n-The MicroProfile Configuration specification defines configuration keys as an arbitrary `.`-delimited string.\n-However, structured formats like YAML naively only support a subset of the possible configuration namespace.\n-For example, consider the two configuration properties `quarkus.http.cors` and `quarkus.http.cors.methods`.\n-One property is the prefix of another, so it may not be immediately evident how to specify both keys in your YAML configuration.\n-\n-This is solved by using a `null` key (normally represented by `~`) for any YAML property which is a prefix of another one.  Here's an example:\n-\n-.An example YAML configuration resolving prefix-related key name conflicts\n-[source,yaml]\n-----\n-quarkus:\n-  http:\n-    cors:\n-      ~: true\n-      methods: GET,PUT,POST\n-----\n-\n-In general, `null` YAML keys are not included in assembly of the configuration property name, allowing them to be used to\n-any level for disambiguating configuration keys.\n-\n-== More info on how to configure\n-\n-Quarkus relies on SmallRye Config and inherits its features.\n-\n-SmallRye Config provides:\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore lean.", "originalCommit": "9f71aede594314e5030837e8e9bd979d87c5d332", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2Mjg1MA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528362850", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n          \n          \n            \n            NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile Config].", "author": "gsmet", "createdAt": "2020-11-22T16:59:55Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2MzE3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528363176", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <1> This is a user-defind configuration property.\n          \n          \n            \n            <1> This is a user-defined configuration property.", "author": "gsmet", "createdAt": "2020-11-22T17:02:46Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2MzQ2OA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528363468", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <2> `!` will be the default value if `greeting.suffix` is not set\n          \n          \n            \n            <2> `!` will be the default value if `greeting.suffix` is not set.", "author": "gsmet", "createdAt": "2020-11-22T17:05:17Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2MzY5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528363697", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n          \n          \n            \n            <1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions.", "author": "gsmet", "createdAt": "2020-11-22T17:06:43Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NDAxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528364019", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            By default Quarkus has three profiles, although it is possible to use as many as you like. \n          \n          \n            \n            By default, Quarkus has three profiles, although it is possible to use as many as you like.", "author": "gsmet", "createdAt": "2020-11-22T17:09:37Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. ", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NDMwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528364309", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's assume you have following property defined in `application.properties`:\n          \n          \n            \n            Let's assume you have the following property defined in `application.properties`:", "author": "gsmet", "createdAt": "2020-11-22T17:12:10Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NDQ2MA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528364460", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n          \n          \n            \n            As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and its extensions.", "author": "gsmet", "createdAt": "2020-11-22T17:13:34Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NDQ4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528364487", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            therefore `quarkus.` should **never** be used as prefix for application specific properties.\n          \n          \n            \n            Therefore `quarkus.` should **never** be used as prefix for application specific properties.", "author": "gsmet", "createdAt": "2020-11-22T17:13:44Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NDYwMw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528364603", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n          \n          \n            \n            Quarkus does much of its configuration and bootstrap at build time and some configuration properties are read and used during the build.", "author": "gsmet", "createdAt": "2020-11-22T17:14:45Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NDY4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528364686", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A canonical example is the database URL, username and password which is only known specifically in your target environment.\n          \n          \n            \n            A canonical example is the database URL, username and password which are only known specifically in your target environment.", "author": "gsmet", "createdAt": "2020-11-22T17:15:17Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n+\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n+\n+However, some extensions do define properties that can be _overriden at runtime_.\n+A canonical example is the database URL, username and password which is only known specifically in your target environment.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NDg4OA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528364888", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            run time properties, and will _only_ work with properties whose values are not required.\n          \n          \n            \n            runtime properties, and will _only_ work with properties whose values are not required.", "author": "gsmet", "createdAt": "2020-11-22T17:16:55Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n+\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n+\n+However, some extensions do define properties that can be _overriden at runtime_.\n+A canonical example is the database URL, username and password which is only known specifically in your target environment.\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore lean.\n+You can override these runtime properties with the following mechanisms (in decreasing priority) using:\n+\n+1. System properties\n+2. Environment variables\n+3. An environment file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+\n+See <<configuration_sources>> for more details.\n+\n+== Generating configuration for your application\n+\n+It is also possible to generate an example `application.properties` with all known configuration properties, to make\n+it easy to see what Quarkus configuration options are available. To do this, run:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config\n+--\n+\n+This will create a `src/main/resources/application.properties.example` file that contains all the config options\n+exposed via the extensions you currently have installed. These options are commented out, and have their default value\n+when applicable. For example this HTTP port config entry will appear as:\n+\n+\n+[source,properties]\n+--\n+#\n+# The HTTP port\n+#\n+#quarkus.http.port=8080\n+--\n+\n+Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n+parameter:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config -Dfile=application.properties\n+--\n+\n+If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n+adding an additional extension to see what additional options have been added.\n+\n+== Clearing properties\n+\n+Run time properties which are optional, and which have had values set at build time or which have a default value,\n+may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n+run time properties, and will _only_ work with properties whose values are not required.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NjEyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528366125", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`\n          \n          \n            \n            You can also use your custom types for configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`", "author": "gsmet", "createdAt": "2020-11-22T17:27:16Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n+\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n+\n+However, some extensions do define properties that can be _overriden at runtime_.\n+A canonical example is the database URL, username and password which is only known specifically in your target environment.\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore lean.\n+You can override these runtime properties with the following mechanisms (in decreasing priority) using:\n+\n+1. System properties\n+2. Environment variables\n+3. An environment file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+\n+See <<configuration_sources>> for more details.\n+\n+== Generating configuration for your application\n+\n+It is also possible to generate an example `application.properties` with all known configuration properties, to make\n+it easy to see what Quarkus configuration options are available. To do this, run:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config\n+--\n+\n+This will create a `src/main/resources/application.properties.example` file that contains all the config options\n+exposed via the extensions you currently have installed. These options are commented out, and have their default value\n+when applicable. For example this HTTP port config entry will appear as:\n+\n+\n+[source,properties]\n+--\n+#\n+# The HTTP port\n+#\n+#quarkus.http.port=8080\n+--\n+\n+Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n+parameter:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config -Dfile=application.properties\n+--\n+\n+If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n+adding an additional extension to see what additional options have been added.\n+\n+== Clearing properties\n+\n+Run time properties which are optional, and which have had values set at build time or which have a default value,\n+may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n+run time properties, and will _only_ work with properties whose values are not required.\n+\n+The property may be cleared by setting the corresponding `application.properties` property, setting the\n+corresponding system property, or setting the corresponding environment variable.\n+\n+[[custom_configuration]]\n+== Custom Configuration\n+\n+=== Custom configuration sources\n+\n+You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To\n+do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource`\n+or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a\n+https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the\n+class and it will be detected and installed at application startup.\n+\n+=== Custom configuration converters\n+\n+You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NjIyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528366221", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you have more converters, simply add their class names in this file as well. Single fully qualified class name per line, for example:\n          \n          \n            \n            If you have more converters, simply add their class names in this file as well. One fully qualified class name per line, for example:", "author": "gsmet", "createdAt": "2020-11-22T17:28:21Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n+\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n+\n+However, some extensions do define properties that can be _overriden at runtime_.\n+A canonical example is the database URL, username and password which is only known specifically in your target environment.\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore lean.\n+You can override these runtime properties with the following mechanisms (in decreasing priority) using:\n+\n+1. System properties\n+2. Environment variables\n+3. An environment file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+\n+See <<configuration_sources>> for more details.\n+\n+== Generating configuration for your application\n+\n+It is also possible to generate an example `application.properties` with all known configuration properties, to make\n+it easy to see what Quarkus configuration options are available. To do this, run:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config\n+--\n+\n+This will create a `src/main/resources/application.properties.example` file that contains all the config options\n+exposed via the extensions you currently have installed. These options are commented out, and have their default value\n+when applicable. For example this HTTP port config entry will appear as:\n+\n+\n+[source,properties]\n+--\n+#\n+# The HTTP port\n+#\n+#quarkus.http.port=8080\n+--\n+\n+Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n+parameter:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config -Dfile=application.properties\n+--\n+\n+If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n+adding an additional extension to see what additional options have been added.\n+\n+== Clearing properties\n+\n+Run time properties which are optional, and which have had values set at build time or which have a default value,\n+may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n+run time properties, and will _only_ work with properties whose values are not required.\n+\n+The property may be cleared by setting the corresponding `application.properties` property, setting the\n+corresponding system property, or setting the corresponding environment variable.\n+\n+[[custom_configuration]]\n+== Custom Configuration\n+\n+=== Custom configuration sources\n+\n+You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To\n+do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource`\n+or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a\n+https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the\n+class and it will be detected and installed at application startup.\n+\n+=== Custom configuration converters\n+\n+You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`\n+and adding its fully qualified class name in the `META-INF/services/org.eclipse.microprofile.config.spi.Converter` file.\n+\n+Let us assume you have a custom type like this one:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+public class MicroProfileCustomValue {\n+\n+    private final int number;\n+\n+    public MicroProfileCustomValue(int number) {\n+        this.number = number;\n+    }\n+\n+    public int getNumber() {\n+        return number;\n+    }\n+}\n+----\n+\n+The corresponding converter will look like the one below. Please note that your custom converter class must be `public` and must have\n+a `public` no-argument constructor. It also must not be `abstract`.\n+\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import org.eclipse.microprofile.config.spi.Converter;\n+\n+public class MicroProfileCustomValueConverter implements Converter<MicroProfileCustomValue> {\n+\n+    @Override\n+    public MicroProfileCustomValue convert(String value) {\n+        return new MicroProfileCustomValue(Integer.valueOf(value));\n+    }\n+}\n+----\n+\n+Then you need to include the fully qualified class name of the converter in a service file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n+If you have more converters, simply add their class names in this file as well. Single fully qualified class name per line, for example:", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NjMwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528366305", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for a demonstration. If you include in this file classes\n          \n          \n            \n            Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for demonstration purposes. If you include in this file classes", "author": "gsmet", "createdAt": "2020-11-22T17:29:13Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n+\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n+\n+However, some extensions do define properties that can be _overriden at runtime_.\n+A canonical example is the database URL, username and password which is only known specifically in your target environment.\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore lean.\n+You can override these runtime properties with the following mechanisms (in decreasing priority) using:\n+\n+1. System properties\n+2. Environment variables\n+3. An environment file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+\n+See <<configuration_sources>> for more details.\n+\n+== Generating configuration for your application\n+\n+It is also possible to generate an example `application.properties` with all known configuration properties, to make\n+it easy to see what Quarkus configuration options are available. To do this, run:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config\n+--\n+\n+This will create a `src/main/resources/application.properties.example` file that contains all the config options\n+exposed via the extensions you currently have installed. These options are commented out, and have their default value\n+when applicable. For example this HTTP port config entry will appear as:\n+\n+\n+[source,properties]\n+--\n+#\n+# The HTTP port\n+#\n+#quarkus.http.port=8080\n+--\n+\n+Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n+parameter:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config -Dfile=application.properties\n+--\n+\n+If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n+adding an additional extension to see what additional options have been added.\n+\n+== Clearing properties\n+\n+Run time properties which are optional, and which have had values set at build time or which have a default value,\n+may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n+run time properties, and will _only_ work with properties whose values are not required.\n+\n+The property may be cleared by setting the corresponding `application.properties` property, setting the\n+corresponding system property, or setting the corresponding environment variable.\n+\n+[[custom_configuration]]\n+== Custom Configuration\n+\n+=== Custom configuration sources\n+\n+You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To\n+do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource`\n+or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a\n+https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the\n+class and it will be detected and installed at application startup.\n+\n+=== Custom configuration converters\n+\n+You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`\n+and adding its fully qualified class name in the `META-INF/services/org.eclipse.microprofile.config.spi.Converter` file.\n+\n+Let us assume you have a custom type like this one:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+public class MicroProfileCustomValue {\n+\n+    private final int number;\n+\n+    public MicroProfileCustomValue(int number) {\n+        this.number = number;\n+    }\n+\n+    public int getNumber() {\n+        return number;\n+    }\n+}\n+----\n+\n+The corresponding converter will look like the one below. Please note that your custom converter class must be `public` and must have\n+a `public` no-argument constructor. It also must not be `abstract`.\n+\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import org.eclipse.microprofile.config.spi.Converter;\n+\n+public class MicroProfileCustomValueConverter implements Converter<MicroProfileCustomValue> {\n+\n+    @Override\n+    public MicroProfileCustomValue convert(String value) {\n+        return new MicroProfileCustomValue(Integer.valueOf(value));\n+    }\n+}\n+----\n+\n+Then you need to include the fully qualified class name of the converter in a service file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n+If you have more converters, simply add their class names in this file as well. Single fully qualified class name per line, for example:\n+\n+[source]\n+----\n+org.acme.config.MicroProfileCustomValueConverter\n+org.acme.config.SomeOtherConverter\n+org.acme.config.YetAnotherConverter\n+----\n+\n+Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for a demonstration. If you include in this file classes", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NjM1MA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528366350", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            After this is done you can use your custom type as a configuration value:\n          \n          \n            \n            After this is done, you can use your custom type as a configuration value:", "author": "gsmet", "createdAt": "2020-11-22T17:29:34Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n+\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n+\n+However, some extensions do define properties that can be _overriden at runtime_.\n+A canonical example is the database URL, username and password which is only known specifically in your target environment.\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore lean.\n+You can override these runtime properties with the following mechanisms (in decreasing priority) using:\n+\n+1. System properties\n+2. Environment variables\n+3. An environment file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+\n+See <<configuration_sources>> for more details.\n+\n+== Generating configuration for your application\n+\n+It is also possible to generate an example `application.properties` with all known configuration properties, to make\n+it easy to see what Quarkus configuration options are available. To do this, run:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config\n+--\n+\n+This will create a `src/main/resources/application.properties.example` file that contains all the config options\n+exposed via the extensions you currently have installed. These options are commented out, and have their default value\n+when applicable. For example this HTTP port config entry will appear as:\n+\n+\n+[source,properties]\n+--\n+#\n+# The HTTP port\n+#\n+#quarkus.http.port=8080\n+--\n+\n+Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n+parameter:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config -Dfile=application.properties\n+--\n+\n+If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n+adding an additional extension to see what additional options have been added.\n+\n+== Clearing properties\n+\n+Run time properties which are optional, and which have had values set at build time or which have a default value,\n+may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n+run time properties, and will _only_ work with properties whose values are not required.\n+\n+The property may be cleared by setting the corresponding `application.properties` property, setting the\n+corresponding system property, or setting the corresponding environment variable.\n+\n+[[custom_configuration]]\n+== Custom Configuration\n+\n+=== Custom configuration sources\n+\n+You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To\n+do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource`\n+or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a\n+https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the\n+class and it will be detected and installed at application startup.\n+\n+=== Custom configuration converters\n+\n+You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`\n+and adding its fully qualified class name in the `META-INF/services/org.eclipse.microprofile.config.spi.Converter` file.\n+\n+Let us assume you have a custom type like this one:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+public class MicroProfileCustomValue {\n+\n+    private final int number;\n+\n+    public MicroProfileCustomValue(int number) {\n+        this.number = number;\n+    }\n+\n+    public int getNumber() {\n+        return number;\n+    }\n+}\n+----\n+\n+The corresponding converter will look like the one below. Please note that your custom converter class must be `public` and must have\n+a `public` no-argument constructor. It also must not be `abstract`.\n+\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import org.eclipse.microprofile.config.spi.Converter;\n+\n+public class MicroProfileCustomValueConverter implements Converter<MicroProfileCustomValue> {\n+\n+    @Override\n+    public MicroProfileCustomValue convert(String value) {\n+        return new MicroProfileCustomValue(Integer.valueOf(value));\n+    }\n+}\n+----\n+\n+Then you need to include the fully qualified class name of the converter in a service file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n+If you have more converters, simply add their class names in this file as well. Single fully qualified class name per line, for example:\n+\n+[source]\n+----\n+org.acme.config.MicroProfileCustomValueConverter\n+org.acme.config.SomeOtherConverter\n+org.acme.config.YetAnotherConverter\n+----\n+\n+Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for a demonstration. If you include in this file classes\n+which are not available at runtime, the converters loading will fail.\n+\n+After this is done you can use your custom type as a configuration value:", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NjQyNw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528366427", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            on the list.\n          \n          \n            \n            in the list.", "author": "gsmet", "createdAt": "2020-11-22T17:29:57Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n+\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n+\n+However, some extensions do define properties that can be _overriden at runtime_.\n+A canonical example is the database URL, username and password which is only known specifically in your target environment.\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore lean.\n+You can override these runtime properties with the following mechanisms (in decreasing priority) using:\n+\n+1. System properties\n+2. Environment variables\n+3. An environment file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+\n+See <<configuration_sources>> for more details.\n+\n+== Generating configuration for your application\n+\n+It is also possible to generate an example `application.properties` with all known configuration properties, to make\n+it easy to see what Quarkus configuration options are available. To do this, run:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config\n+--\n+\n+This will create a `src/main/resources/application.properties.example` file that contains all the config options\n+exposed via the extensions you currently have installed. These options are commented out, and have their default value\n+when applicable. For example this HTTP port config entry will appear as:\n+\n+\n+[source,properties]\n+--\n+#\n+# The HTTP port\n+#\n+#quarkus.http.port=8080\n+--\n+\n+Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n+parameter:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config -Dfile=application.properties\n+--\n+\n+If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n+adding an additional extension to see what additional options have been added.\n+\n+== Clearing properties\n+\n+Run time properties which are optional, and which have had values set at build time or which have a default value,\n+may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n+run time properties, and will _only_ work with properties whose values are not required.\n+\n+The property may be cleared by setting the corresponding `application.properties` property, setting the\n+corresponding system property, or setting the corresponding environment variable.\n+\n+[[custom_configuration]]\n+== Custom Configuration\n+\n+=== Custom configuration sources\n+\n+You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To\n+do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource`\n+or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a\n+https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the\n+class and it will be detected and installed at application startup.\n+\n+=== Custom configuration converters\n+\n+You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`\n+and adding its fully qualified class name in the `META-INF/services/org.eclipse.microprofile.config.spi.Converter` file.\n+\n+Let us assume you have a custom type like this one:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+public class MicroProfileCustomValue {\n+\n+    private final int number;\n+\n+    public MicroProfileCustomValue(int number) {\n+        this.number = number;\n+    }\n+\n+    public int getNumber() {\n+        return number;\n+    }\n+}\n+----\n+\n+The corresponding converter will look like the one below. Please note that your custom converter class must be `public` and must have\n+a `public` no-argument constructor. It also must not be `abstract`.\n+\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import org.eclipse.microprofile.config.spi.Converter;\n+\n+public class MicroProfileCustomValueConverter implements Converter<MicroProfileCustomValue> {\n+\n+    @Override\n+    public MicroProfileCustomValue convert(String value) {\n+        return new MicroProfileCustomValue(Integer.valueOf(value));\n+    }\n+}\n+----\n+\n+Then you need to include the fully qualified class name of the converter in a service file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n+If you have more converters, simply add their class names in this file as well. Single fully qualified class name per line, for example:\n+\n+[source]\n+----\n+org.acme.config.MicroProfileCustomValueConverter\n+org.acme.config.SomeOtherConverter\n+org.acme.config.YetAnotherConverter\n+----\n+\n+Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for a demonstration. If you include in this file classes\n+which are not available at runtime, the converters loading will fail.\n+\n+After this is done you can use your custom type as a configuration value:\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"configuration.value.name\")\n+MicroProfileCustomValue value;\n+----\n+\n+==== Converter priority\n+\n+In some cases, you may want to use a custom converter to convert a type which is already converted\n+by a different converter. In such cases, you can use the `javax.annotation.Priority` annotation to\n+change converters precedence and make your custom converter of higher priority than the other\n+on the list.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NjU3NA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528366574", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            First you will need to add the YAML extension to your `pom.xml`:\n          \n          \n            \n            First you will need to add the Config YAML extension to your `pom.xml`:", "author": "gsmet", "createdAt": "2020-11-22T17:30:57Z", "path": "docs/src/main/asciidoc/config-reference.adoc", "diffHunk": "@@ -0,0 +1,778 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Configuration Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this reference guide we're going to describe various aspects of Quarkus configuration.\n+A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] API.\n+Quarkus configuration is based on https://github.com/smallrye/smallrye-config[SmallRye Config], an implementation of the MicroProfile Config specification.\n+All of the standard features are supported.\n+Moreover, there are several additional features which are made available by the SmallRye Config project as well as by Quarkus itself.\n+\n+TIP: If you're looking for information how to make a Quarkus extension configurable then see the <<writing-extensions.adoc#configuration,Writing Your Own Extension>> guide.\n+\n+[[configuration_sources]]\n+== Configuration Sources\n+\n+By default, Quarkus reads configuration properties from several sources (in decreasing priority):\n+\n+1. <<system_properties,System properties>>\n+2. <<environment_variables,Environment variables>>\n+3. <<env_file,File named `.env`>> placed in the current working directory\n+4. <<pwd_config_application_file,`application.properties` file placed in the `$PWD/config/` directory>>\n+5. <<application_properties_file,An application configuration file>>, i.e. `src/main/resources/application.properties`\n+\n+[[system_properties]]\n+=== System properties\n+\n+* for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n+* for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n+\n+[[environment_variables]]\n+=== Environment variables\n+\n+* for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n+* for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n+\n+NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n+\n+[[env_file]]\n+=== File named `.env` placed in the current working directory\n+\n+.Example `.env` file\n+[source,properties]\n+----\n+QUARKUS_DATASOURCE_PASSWORD=youshallnotpass <1>\n+----\n+<1> The name `QUARKUS_DATASOURCE_PASSWORD` is converted using the same rules as for <<environment_variables>>.\n+\n+For dev mode, this file can be placed in the root of the project, but it is advised to **not** check it in to version control.\n+\n+NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n+\n+[[pwd_config_application_file]]\n+=== An `application.properties` file placed in `$PWD/config/`\n+\n+By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined in that file will override the default configuration. \n+Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n+_will also_ be taken into account.\n+This works in the same way for runner jar and the native executable.\n+\n+NOTE: The `config/application.properties` feature is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n+Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n+\n+[[application_properties_file]]\n+=== An application configuration file\n+\n+This is the main application configuration file located in `src/main/resources/application.properties`.\n+\n+.Example `application.properties` file\n+[source,properties]\n+----\n+greeting.message=hello <1>\n+quarkus.http.port=9090 <2>\n+----\n+<1> This is a user-defind configuration property.\n+<2> This is a configuration property consumed by the `quarkus-vertx-http` extension.\n+\n+TIP: Quarkus supports the use of <<using_property_expressions,property expressions>> in the `application.properties` file.\n+\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n+\n+NOTE: If the application attempts to inject a configuration property that is not set, an error is thrown, thus allowing you to quickly know when your configuration is complete.\n+\n+.More `@ConfigProperty` Examples\n+[source,java]\n+----\n+@ConfigProperty(name = \"greeting.message\") <1>\n+String message;\n+\n+@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") <2>\n+String suffix;\n+\n+@ConfigProperty(name = \"greeting.name\")\n+Optional<String> name; <3>\n+----\n+<1> If you do not provide a value for this property, the application startup fails with `javax.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message`.\n+<2> The default value is injected if the configuration does not provide a value for `greeting.suffix`.\n+<3> This property is optional - an empty `Optional` is injected if the configuration does not provide a value for `greeting.name`.\n+\n+== Programmatically access the configuration\n+\n+You can also access the configuration programmatically.\n+It can be handy to achieve dynamic lookup, or retrieve configured values from classes that are neither CDI beans or JAX-RS resources.\n+\n+You can access the configuration programmatically using `org.eclipse.microprofile.config.ConfigProvider.getConfig()` such as in:\n+\n+[source,java]\n+----\n+String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", String.class);\n+Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n+----\n+\n+[[using_configproperties]]\n+== Using @ConfigProperties\n+\n+As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n+users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n+\n+For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\") <1>\n+public class GreetingConfiguration {\n+\n+    private String message;\n+    private String suffix = \"!\"; <2>\n+    private Optional<String> name;\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public void setMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    public void setSuffix(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public Optional<String> getName() {\n+        return name;\n+    }\n+\n+    public void setName(Optional<String> name) {\n+        this.name = name;\n+    }\n+}\n+----\n+<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n+<2> `!` will be the default value if `greeting.suffix` is not set\n+\n+This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n+\n+[source,java]\n+----\n+@Inject\n+GreetingConfiguration greetingConfiguration;\n+----\n+\n+Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import io.quarkus.arc.config.ConfigProperties;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import java.util.Optional;\n+\n+@ConfigProperties(prefix = \"greeting\")\n+public interface GreetingConfiguration {\n+\n+    @ConfigProperty(name = \"message\") <1>\n+    String message();\n+\n+    @ConfigProperty(defaultValue = \"!\")\n+    String getSuffix(); <2>\n+\n+    Optional<String> getName(); <3>\n+}\n+----\n+<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n+<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n+<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n+\n+When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n+This does not apply to `Optional` fields and fields with a default value.\n+\n+=== Additional notes on @ConfigProperties\n+\n+When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n+Having simple public non-final fields is valid as well.\n+\n+Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n+of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    public String message;\n+    public String suffix = \"!\";\n+    public Optional<String> name;\n+    public ContentConfig content; <1>\n+\n+    public static class ContentConfig {\n+        public Integer prizeAmount;\n+        public List<String> recipients;\n+    }\n+}\n+----\n+<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n+\n+Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+\n+[source,properties]\n+----\n+greeting.message = hello\n+greeting.name = quarkus\n+greeting.content.prize-amount=10\n+greeting.content.recipients=Jane,John\n+----\n+\n+Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n+\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n+\n+If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n+\n+In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n+the entire interface hierarchy are used to bind properties.\n+\n+=== Using same ConfigProperties with different prefixes\n+\n+Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n+Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n+In that case the code would look like so:\n+\n+`GreetingConfiguration.java`\n+[source,java]\n+----\n+@ConfigProperties(prefix = \"greeting\")\n+public class GreetingConfiguration {\n+\n+    @Size(min = 20)\n+    public String message;\n+    public String suffix = \"!\";\n+\n+}\n+----\n+\n+`SomeBean.java`\n+[source,java]\n+----\n+@ApplicationScoped\n+public class SomeBean {\n+\n+    @Inject <1>\n+    GreetingConfiguration greetingConfiguration;\n+\n+    @ConfigPrefix(\"other\") <2>\n+    GreetingConfiguration otherConfiguration;\n+\n+}\n+----\n+<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n+<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+\n+[[configuration_profiles]]\n+== Configuration Profiles\n+\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configurations in the same file and select between them via a profile name.\n+\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n+----\n+\n+The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n+\n+To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n+\n+[source,.env]\n+----\n+QUARKUS_HTTP_PORT=9090\n+_DEV_QUARKUS_HTTP_PORT=8181\n+----\n+\n+By default Quarkus has three profiles, although it is possible to use as many as you like. \n+The default profiles are:\n+\n+* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n+* *test* - Activated when running tests\n+* *prod* - The default profile when not running in development or test mode\n+\n+There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n+environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n+define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n+name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port I can add the following to `application.properties`:\n+\n+[source,properties]\n+----\n+quarkus.http.port=9090\n+%staging.quarkus.http.port=9999\n+----\n+\n+And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n+\n+[NOTE]\n+====\n+The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n+\n+Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n+====\n+\n+=== Default Runtime Profile\n+\n+The default Quarkus application runtime profile is set to the profile used to build the application.\n+For example:\n+[source,bash]\n+----\n+./mvnw package -Pnative -Dquarkus.profile=prod-aws\n+./target/my-app-1.0-runner // <1>\n+----\n+<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n+\n+\n+[[using_property_expressions]]\n+== Using Property Expressions\n+\n+Quarkus supports the use of property expressions in the `application.properties` file.\n+\n+These expressions are resolved when the property is read.\n+So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n+If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n+\n+You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n+\n+Property expressions are defined this way: `${my-property-expression}`.\n+\n+For example, having the following property:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+and another property defined as:\n+\n+[source,properties]\n+----\n+callable.url=https://${remote.host}/\n+----\n+\n+will result in the value of the `callable.url` property being set to:\n+\n+[source,properties]\n+----\n+callable.url=https://quarkus.io/\n+----\n+\n+Another example would be defining different database servers depending on the profile used:\n+\n+[source,properties]\n+----\n+%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n+quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n+----\n+\n+can be simplified by having:\n+\n+[source,properties]\n+----\n+%dev.application.server=localhost\n+application.server=remotehost\n+\n+quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n+----\n+\n+It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n+diminishing the possibility of typos and providing more flexibility in property definitions.\n+\n+\n+[#combine-property-env-var]\n+== Combining Property Expressions and Environment Variables\n+\n+Quarkus also supports the combination of both property expressions and environment variables.\n+\n+Let's assume you have following property defined in `application.properties`:\n+\n+[source,properties]\n+----\n+remote.host=quarkus.io\n+----\n+\n+You can combine environment variables and property expressions by having a property defined as follows:\n+\n+[source,properties]\n+----\n+application.host=${HOST:${remote.host}}\n+----\n+\n+This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n+\n+For the purpose of this section we used the property `remote.host` we defined previously.\n+It has to be noted that the value could have been a fixed one such as in:\n+\n+[source,properties]\n+----\n+application.host=${HOST:localhost}\n+----\n+\n+which will result in `localhost` as the default value if `HOST` is not set.\n+\n+[[configuring_quarkus]]\n+== Configuring Quarkus\n+\n+Quarkus itself is configured via the same mechanism as your application. Quarkus reserves the `quarkus.` namespace\n+for its own configuration and the configuration of all of its extensions. For example to configure the HTTP server port you can set `quarkus.http.port` in\n+`application.properties`. All the Quarkus configuration properties are link:all-config[documented and searchable].\n+\n+[IMPORTANT]\n+====\n+As mentioned above, properties prefixed with `quarkus.` are effectively reserved for configuring Quarkus itself and\n+therefore `quarkus.` should **never** be used as prefix for application specific properties.\n+\n+In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n+====\n+\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n+\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n+\n+However, some extensions do define properties that can be _overriden at runtime_.\n+A canonical example is the database URL, username and password which is only known specifically in your target environment.\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore lean.\n+You can override these runtime properties with the following mechanisms (in decreasing priority) using:\n+\n+1. System properties\n+2. Environment variables\n+3. An environment file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n+\n+See <<configuration_sources>> for more details.\n+\n+== Generating configuration for your application\n+\n+It is also possible to generate an example `application.properties` with all known configuration properties, to make\n+it easy to see what Quarkus configuration options are available. To do this, run:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config\n+--\n+\n+This will create a `src/main/resources/application.properties.example` file that contains all the config options\n+exposed via the extensions you currently have installed. These options are commented out, and have their default value\n+when applicable. For example this HTTP port config entry will appear as:\n+\n+\n+[source,properties]\n+--\n+#\n+# The HTTP port\n+#\n+#quarkus.http.port=8080\n+--\n+\n+Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n+parameter:\n+\n+[source,bash]\n+--\n+./mvnw quarkus:generate-config -Dfile=application.properties\n+--\n+\n+If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n+adding an additional extension to see what additional options have been added.\n+\n+== Clearing properties\n+\n+Run time properties which are optional, and which have had values set at build time or which have a default value,\n+may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n+run time properties, and will _only_ work with properties whose values are not required.\n+\n+The property may be cleared by setting the corresponding `application.properties` property, setting the\n+corresponding system property, or setting the corresponding environment variable.\n+\n+[[custom_configuration]]\n+== Custom Configuration\n+\n+=== Custom configuration sources\n+\n+You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To\n+do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource`\n+or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a\n+https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the\n+class and it will be detected and installed at application startup.\n+\n+=== Custom configuration converters\n+\n+You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`\n+and adding its fully qualified class name in the `META-INF/services/org.eclipse.microprofile.config.spi.Converter` file.\n+\n+Let us assume you have a custom type like this one:\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+public class MicroProfileCustomValue {\n+\n+    private final int number;\n+\n+    public MicroProfileCustomValue(int number) {\n+        this.number = number;\n+    }\n+\n+    public int getNumber() {\n+        return number;\n+    }\n+}\n+----\n+\n+The corresponding converter will look like the one below. Please note that your custom converter class must be `public` and must have\n+a `public` no-argument constructor. It also must not be `abstract`.\n+\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import org.eclipse.microprofile.config.spi.Converter;\n+\n+public class MicroProfileCustomValueConverter implements Converter<MicroProfileCustomValue> {\n+\n+    @Override\n+    public MicroProfileCustomValue convert(String value) {\n+        return new MicroProfileCustomValue(Integer.valueOf(value));\n+    }\n+}\n+----\n+\n+Then you need to include the fully qualified class name of the converter in a service file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n+If you have more converters, simply add their class names in this file as well. Single fully qualified class name per line, for example:\n+\n+[source]\n+----\n+org.acme.config.MicroProfileCustomValueConverter\n+org.acme.config.SomeOtherConverter\n+org.acme.config.YetAnotherConverter\n+----\n+\n+Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for a demonstration. If you include in this file classes\n+which are not available at runtime, the converters loading will fail.\n+\n+After this is done you can use your custom type as a configuration value:\n+\n+[source,java]\n+----\n+@ConfigProperty(name = \"configuration.value.name\")\n+MicroProfileCustomValue value;\n+----\n+\n+==== Converter priority\n+\n+In some cases, you may want to use a custom converter to convert a type which is already converted\n+by a different converter. In such cases, you can use the `javax.annotation.Priority` annotation to\n+change converters precedence and make your custom converter of higher priority than the other\n+on the list.\n+\n+By default, if no `@Priority` can be found on a converter, it's registered with a priority of 100\n+and all Quarkus core converters are registered with a priority of 200, so depending on which\n+converter you would like to replace, you need to set a higher value.\n+\n+To demonstrate the idea let us implement a custom converter which will take precedence over\n+`MicroProfileCustomValueConverter` implemented in the previous example.\n+\n+[source,java]\n+----\n+package org.acme.config;\n+\n+import javax.annotation.Priority;\n+import org.eclipse.microprofile.config.spi.Converter;\n+\n+@Priority(150)\n+public class MyCustomConverter implements Converter<MicroProfileCustomValue> {\n+\n+    @Override\n+    public MicroProfileCustomValue convert(String value) {\n+\n+        final int secretNumber;\n+        if (value.startsFrom(\"OBF:\")) {\n+            secretNumber = Integer.valueOf(SecretDecoder.decode(value));\n+        } else {\n+            secretNumber = Integer.valueOf(value);\n+        }\n+\n+        return new MicroProfileCustomValue(secretNumber);\n+    }\n+}\n+----\n+\n+Since it converts the same value type (namely `MicroProfileCustomValue`) and has a priority\n+of 150, it will be used instead of a `MicroProfileCustomValueConverter` which has a default\n+priority of 100.\n+\n+NOTE: This new converter also needs to be listed in a service file, i.e. `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n+\n+[[yaml]]\n+== YAML for Configuration\n+\n+=== Add YAML Config Support\n+\n+You might want to use YAML over properties for configuration.\n+Since link:https://github.com/smallrye/smallrye-config[SmallRye Config] brings support for YAML\n+configuration, Quarkus supports this as well.\n+\n+First you will need to add the YAML extension to your `pom.xml`:", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2Njg0MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528366841", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This behavior which differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].\n          \n          \n            \n            This behavior differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].", "author": "gsmet", "createdAt": "2020-11-22T17:33:29Z", "path": "docs/src/main/asciidoc/config.adoc", "diffHunk": "@@ -51,19 +53,34 @@ It generates:\n * an `org.acme.config.GreetingResource` resource\n * an associated test\n \n-== Injecting configuration value\n+== Create the configuration\n+\n+By default, Quarkus reads configuration properties from <<config-reference.adoc#configuration_sources,several sources>>.\n+For the purpose of this guide, we will use an application configuration file located in `src/main/resources/application.properties`.\n+Edit the file with the following content:\n+\n+[source,properties]\n+----\n+# Your configuration properties\n+greeting.message = hello\n+greeting.name = quarkus\n+----\n \n-Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] to inject the configuration in the application.\n-The injection uses the `@ConfigProperty` annotation.\n+== Injecting configuration properties\n+\n+Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.\n \n [source,java]\n ----\n-@ConfigProperty(name = \"greeting.message\")\n+@ConfigProperty(name = \"greeting.message\") <1>\n String message;\n ----\n+<1> You can use `@Inject @ConfigProperty` or just `@ConfigProperty`.\n+The `@Inject` annotation is not necessary for members annotated with `@ConfigProperty`.\n+This behavior which differs from https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config].", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2Njg3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528366877", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            TIP: As an alternative to injecting multiple related configuration values you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together. \n          \n          \n            \n            TIP: As an alternative to injecting multiple related configuration values, you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.", "author": "gsmet", "createdAt": "2020-11-22T17:33:52Z", "path": "docs/src/main/asciidoc/config.adoc", "diffHunk": "@@ -114,15 +118,14 @@ $ curl http://localhost:8080/greeting\n hello quarkus!\n ----\n \n-TIP: If the application requires configuration values and these values are not set, an error is thrown.\n-So you can quickly know when your configuration is complete.\n+TIP: As an alternative to injecting multiple related configuration values you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together. ", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2Njk1NA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528366954", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n          \n          \n            \n            Quarkus does much of its configuration and bootstrap at build time and some configuration properties are read and used during the build.", "author": "gsmet", "createdAt": "2020-11-22T17:34:33Z", "path": "docs/src/main/asciidoc/config.adoc", "diffHunk": "@@ -365,470 +206,21 @@ therefore `quarkus.` should **never** be used as prefix for application specific\n In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n ====\n \n-=== List of all configuration properties\n-\n-All the Quarkus configuration properties are link:all-config[documented and searchable].\n-\n-=== Generating configuration for your application\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NzA3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528367073", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The list of runtime properties is therefore intentionaly kept lean.\n          \n          \n            \n            The list of runtime properties is therefore intentionally kept lean.", "author": "gsmet", "createdAt": "2020-11-22T17:35:17Z", "path": "docs/src/main/asciidoc/config.adoc", "diffHunk": "@@ -365,470 +206,21 @@ therefore `quarkus.` should **never** be used as prefix for application specific\n In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n ====\n \n-=== List of all configuration properties\n-\n-All the Quarkus configuration properties are link:all-config[documented and searchable].\n-\n-=== Generating configuration for your application\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n \n-It is also possible to generate an example `application.properties` with all known configuration properties, to make\n-it easy to see what Quarkus configuration options are available. To do this, run:\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n \n-[source,bash]\n---\n-./mvnw quarkus:generate-config\n---\n-\n-This will create a `src/main/resources/application.properties.example` file that contains all the config options\n-exposed via the extensions you currently have installed. These options are commented out, and have their default value\n-when applicable. For example this HTTP port config entry will appear as:\n-\n-\n-[source,properties]\n---\n-#\n-# The HTTP port\n-#\n-#quarkus.http.port=8080\n---\n-\n-Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n-parameter:\n-\n-[source,bash]\n---\n-./mvnw quarkus:generate-config -Dfile=application.properties\n---\n-\n-If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n-adding an additional extension to see what additional options have been added.\n-\n-== Overriding properties at runtime\n-\n-Quarkus does much of its configuration and bootstrap at build time.\n-Most properties will then be read and set during the build time step.\n-To change them, make sure to repackage your application.\n-\n-[source,bash]\n---\n-./mvnw clean package\n---\n-\n-Extensions do define _some_ properties as overridable at runtime.\n+However, some extensions do define properties _overridable at runtime_.\n A canonical example is the database URL, username and password which is only known specifically in your target environment.\n-This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. The list of runtime properties is therefore lean.\n-\n-You can override these runtime properties with the following mechanisms (in decreasing priority):\n-\n-1. using system properties:\n-  * for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n-  * for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n-2. using environment variables:\n-  * for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n-  * for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n-3. using an environment file named `.env` placed in the current working directory containing the line `QUARKUS_DATASOURCE_PASSWORD=youshallnotpass` (for dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control)\n-4. using a configuration file placed in `$PWD/config/application.properties`\n-  * By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined\n-in that file will override the default configuration. Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n-_will also_ be taken into account.\n-  * This works in the same way for runner jar and the native executable\n-\n-NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n-\n-NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n-\n-NOTE: The `config/application.properties` features is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n-Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n-\n-=== Configuration Profiles\n-\n-Quarkus supports the notion of configuration profiles. These allow you to have multiple configuration in the same file and\n-select between them via a profile name.\n-\n-The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n-\n-[source,properties]\n-----\n-quarkus.http.port=9090\n-%dev.quarkus.http.port=8181\n-----\n-\n-The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n-\n-To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n-\n-[source,.env]\n-----\n-QUARKUS_HTTP_PORT=9090\n-_DEV_QUARKUS_HTTP_PORT=8181\n-----\n-\n-By default Quarkus has three profiles, although it is possible to use as many as you like. The default profiles are:\n-\n-* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n-* *test* - Activated when running tests\n-* *prod* - The default profile when not running in development or test mode\n-\n-There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n-environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n-define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n-name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port\n-I can add the following to `application.properties`:\n-\n-[source,properties]\n-----\n-quarkus.http.port=9090\n-%staging.quarkus.http.port=9999\n-----\n-\n-And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n-\n-[NOTE]\n-====\n-The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n-\n-Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n-====\n-\n-=== Using Property Expressions\n-\n-Quarkus supports the use of property expressions in the `application.properties` file.\n-\n-These expressions are resolved when the property is read.\n-So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n-If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n-\n-You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n-\n-Property expressions are defined this way: `${my-property-expression}`.\n-\n-For example, having the following property:\n-\n-[source,properties]\n-----\n-remote.host=quarkus.io\n-----\n-and another property defined as:\n-\n-[source,properties]\n-----\n-callable.url=https://${remote.host}/\n-----\n-\n-will result in the value of the `callable.url` property being set to:\n-\n-[source,properties]\n-----\n-callable.url=https://quarkus.io/\n-----\n-\n-Another example would be defining different database servers depending on the profile used:\n-\n-[source,properties]\n-----\n-%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n-quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n-----\n-\n-can be simplified by having:\n-\n-[source,properties]\n-----\n-%dev.application.server=localhost\n-application.server=remotehost\n-\n-quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n-----\n-\n-It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n-diminishing the possibility of typos and providing more flexibility in property definitions.\n-\n-[#combine-property-env-var]\n-=== Combining Property Expressions and Environment Variables\n-\n-Quarkus also supports the combination of both property expressions and environment variables.\n-\n-Let's assume you have following property defined in `application.properties`:\n-\n-[source,properties]\n-----\n-remote.host=quarkus.io\n-----\n-\n-You can combine environment variables and property expressions by having a property defined as follows:\n-\n-[source,properties]\n-----\n-application.host=${HOST:${remote.host}}\n-----\n-\n-This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n-\n-For the purpose of this section we used the property `remote.host` we defined previously.\n-It has to be noted that the value could have been a fixed one such as in:\n-\n-[source,properties]\n-----\n-application.host=${HOST:localhost}\n-----\n-\n-which will result in `localhost` as the default value if `HOST` is not set.\n-\n-=== Clearing properties\n-\n-Run time properties which are optional, and which have had values set at build time or which have a default value,\n-may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n-run time properties, and will _only_ work with properties whose values are not required.\n-\n-The property may be cleared by setting the corresponding `application.properties` property, setting the\n-corresponding system property, or setting the corresponding environment variable.\n-\n-==== Miscellaneous\n-The default Quarkus application runtime profile is set to the profile used to build the application.\n-For example:\n-[source,bash]\n-----\n-./mvnw package -Pnative -Dquarkus.profile=prod-aws\n-./target/my-app-1.0-runner // <1>\n-----\n-<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n-\n-== Custom Configuration\n-\n-=== Custom configuration sources\n-\n-You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To\n-do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource`\n-or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a\n-https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the\n-class and it will be detected and installed at application startup.\n-\n-=== Custom configuration converters\n-\n-You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`\n-and adding its fully qualified class name in the `META-INF/services/org.eclipse.microprofile.config.spi.Converter` file.\n-\n-Let us assume you have a custom type like this one:\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-public class MicroProfileCustomValue {\n-\n-    private final int number;\n-\n-    public MicroProfileCustomValue(int number) {\n-        this.number = number;\n-    }\n-\n-    public int getNumber() {\n-        return number;\n-    }\n-}\n-----\n-\n-The corresponding converter will look like the one below. Please note that your custom converter class must be `public` and must have\n-a `public` no-argument constructor. It also must not be `abstract`.\n-\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-import org.eclipse.microprofile.config.spi.Converter;\n-\n-public class MicroProfileCustomValueConverter implements Converter<MicroProfileCustomValue> {\n-\n-    @Override\n-    public MicroProfileCustomValue convert(String value) {\n-        return new MicroProfileCustomValue(Integer.valueOf(value));\n-    }\n-}\n-----\n-\n-Then you need to include the fully qualified class name of the converter in a service file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n-If you have more converters, simply add their class names in this file as well. Single fully qualified class name per line, for example:\n-\n-[source]\n-----\n-org.acme.config.MicroProfileCustomValueConverter\n-org.acme.config.SomeOtherConverter\n-org.acme.config.YetAnotherConverter\n-----\n-\n-Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for a demonstration. If you include in this file classes\n-which are not available at runtime, the converters loading will fail.\n-\n-After this is done you can use your custom type as a configuration value:\n-\n-[source,java]\n-----\n-@ConfigProperty(name = \"configuration.value.name\")\n-MicroProfileCustomValue value;\n-----\n-\n-==== Converter priority\n-\n-In some cases, you may want to use a custom converter to convert a type which is already converted\n-by a different converter. In such cases, you can use the `javax.annotation.Priority` annotation to\n-change converters precedence and make your custom converter of higher priority than the other\n-on the list.\n-\n-By default, if no `@Priority` can be found on a converter, it's registered with a priority of 100\n-and all Quarkus core converters are registered with a priority of 200, so depending on which\n-converter you would like to replace, you need to set a higher value.\n-\n-To demonstrate the idea let us implement a custom converter which will take precedence over\n-`MicroProfileCustomValueConverter` implemented in the previous example.\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-import javax.annotation.Priority;\n-import org.eclipse.microprofile.config.spi.Converter;\n-\n-@Priority(150)\n-public class MyCustomConverter implements Converter<MicroProfileCustomValue> {\n-\n-    @Override\n-    public MicroProfileCustomValue convert(String value) {\n-\n-        final int secretNumber;\n-        if (value.startsFrom(\"OBF:\")) {\n-            secretNumber = Integer.valueOf(SecretDecoder.decode(value));\n-        } else {\n-            secretNumber = Integer.valueOf(value);\n-        }\n-\n-        return new MicroProfileCustomValue(secretNumber);\n-    }\n-}\n-----\n-\n-Since it converts the same value type (namely `MicroProfileCustomValue`) and has a priority\n-of 150, it will be used instead of a `MicroProfileCustomValueConverter` which has a default\n-priority of 100.\n-\n-NOTE: This new converter also needs to be listed in a service file, i.e. `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n-\n-[[yaml]]\n-== YAML for Configuration\n-\n-=== Add YAML Config Support\n-\n-You might want to use YAML over properties for configuration.\n-Since link:https://github.com/smallrye/smallrye-config[SmallRye Config] brings support for YAML\n-configuration, Quarkus supports this as well.\n-\n-First you will need to add the YAML extension to your `pom.xml`:\n-\n-[source,xml]\n-----\n-<dependency>\n-    <groupId>io.quarkus</groupId>\n-    <artifactId>quarkus-config-yaml</artifactId>\n-</dependency>\n-----\n-\n-Or you can alternatively run this command in the directory containing your Quarkus project:\n-\n-[source,bash]\n-----\n-./mvnw quarkus:add-extension -Dextensions=\"config-yaml\"\n-----\n-\n-Now Quarkus can read YAML configuration files.\n-The config directories and priorities are the same as before.\n-\n-NOTE: Quarkus will choose an `application.yaml` over an `application.properties`.\n-YAML files are just an alternative way to configure your application.\n-You should decide and keep one configuration type to avoid errors.\n-\n-==== Configuration Examples\n-[source,yaml]\n-----\n-# YAML supports comments\n-quarkus:\n-  datasource:\n-    db-kind: postgresql\n-    jdbc:\n-      url: jdbc:postgresql://localhost:5432/some-database\n-    username: quarkus\n-    password: quarkus\n-\n-# REST Client configuration property\n-org:\n-  acme:\n-    restclient:\n-      CountriesService/mp-rest/url: https://restcountries.eu/rest\n-\n-# For configuration property names that use quotes, do not split the string inside the quotes.\n-quarkus:\n-  log:\n-    category:\n-      \"io.quarkus.category\":\n-        level: INFO\n-----\n-\n-[NOTE]\n-====\n-Quarkus also supports using `application.yml` as the name of the YAML file. The same rules apply for this file as for `application.yaml`.\n-====\n-\n-=== Profile dependent configuration\n-\n-Providing profile dependent configuration with YAML is done like with properties.\n-Just add the `%profile` wrapped in quotation marks before defining the key-value pairs:\n-\n-[source,yaml]\n-----\n-\"%dev\":\n-  quarkus:\n-    datasource:\n-      db-kind: postgresql\n-      jdbc:\n-        url: jdbc:postgresql://localhost:5432/some-database\n-      username: quarkus\n-      password: quarkus\n-----\n-\n-=== Configuration key conflicts\n-\n-The MicroProfile Configuration specification defines configuration keys as an arbitrary `.`-delimited string.\n-However, structured formats like YAML naively only support a subset of the possible configuration namespace.\n-For example, consider the two configuration properties `quarkus.http.cors` and `quarkus.http.cors.methods`.\n-One property is the prefix of another, so it may not be immediately evident how to specify both keys in your YAML configuration.\n-\n-This is solved by using a `null` key (normally represented by `~`) for any YAML property which is a prefix of another one.  Here's an example:\n-\n-.An example YAML configuration resolving prefix-related key name conflicts\n-[source,yaml]\n-----\n-quarkus:\n-  http:\n-    cors:\n-      ~: true\n-      methods: GET,PUT,POST\n-----\n-\n-In general, `null` YAML keys are not included in assembly of the configuration property name, allowing them to be used to\n-any level for disambiguating configuration keys.\n-\n-== More info on how to configure\n-\n-Quarkus relies on SmallRye Config and inherits its features.\n-\n-SmallRye Config provides:\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore intentionaly kept lean.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NzEyNA==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528367124", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            See the <<config-reference.adoc#configuring_quarkus,configuration reference guide>> for more information.\n          \n          \n            \n            See the <<config-reference.adoc#configuring_quarkus,Configuration Reference Guide>> for more information.", "author": "gsmet", "createdAt": "2020-11-22T17:35:45Z", "path": "docs/src/main/asciidoc/config.adoc", "diffHunk": "@@ -365,470 +206,21 @@ therefore `quarkus.` should **never** be used as prefix for application specific\n In the previous examples using `quarkus.message` instead of `greeting.message` would result in unexpected behavior.\n ====\n \n-=== List of all configuration properties\n-\n-All the Quarkus configuration properties are link:all-config[documented and searchable].\n-\n-=== Generating configuration for your application\n+Quarkus does much of its configuration and bootstrap at build time and most configuration properties are read and used during the build.\n+These properties are _fixed at build time_ and it's not possible to change them at runtime.\n+You always need to repackage your application in order to reflect changes of such properties.\n \n-It is also possible to generate an example `application.properties` with all known configuration properties, to make\n-it easy to see what Quarkus configuration options are available. To do this, run:\n+TIP: The properties fixed at build time are marked with a lock icon (icon:lock[]) in the link:all-config[list of all configuration options].\n \n-[source,bash]\n---\n-./mvnw quarkus:generate-config\n---\n-\n-This will create a `src/main/resources/application.properties.example` file that contains all the config options\n-exposed via the extensions you currently have installed. These options are commented out, and have their default value\n-when applicable. For example this HTTP port config entry will appear as:\n-\n-\n-[source,properties]\n---\n-#\n-# The HTTP port\n-#\n-#quarkus.http.port=8080\n---\n-\n-Rather than generating an example config file, you can also add these to you actual config file by setting the `-Dfile`\n-parameter:\n-\n-[source,bash]\n---\n-./mvnw quarkus:generate-config -Dfile=application.properties\n---\n-\n-If a config option is already present (commented or not) it will not be added, so it is safe to run this after\n-adding an additional extension to see what additional options have been added.\n-\n-== Overriding properties at runtime\n-\n-Quarkus does much of its configuration and bootstrap at build time.\n-Most properties will then be read and set during the build time step.\n-To change them, make sure to repackage your application.\n-\n-[source,bash]\n---\n-./mvnw clean package\n---\n-\n-Extensions do define _some_ properties as overridable at runtime.\n+However, some extensions do define properties _overridable at runtime_.\n A canonical example is the database URL, username and password which is only known specifically in your target environment.\n-This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. The list of runtime properties is therefore lean.\n-\n-You can override these runtime properties with the following mechanisms (in decreasing priority):\n-\n-1. using system properties:\n-  * for a runner jar: `java -Dquarkus.datasource.password=youshallnotpass -jar target/myapp-runner.jar`\n-  * for a native executable: `./target/myapp-runner -Dquarkus.datasource.password=youshallnotpass`\n-2. using environment variables:\n-  * for a runner jar: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; java -jar target/myapp-runner.jar`\n-  * for a native executable: `export QUARKUS_DATASOURCE_PASSWORD=youshallnotpass ; ./target/myapp-runner`\n-3. using an environment file named `.env` placed in the current working directory containing the line `QUARKUS_DATASOURCE_PASSWORD=youshallnotpass` (for dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control)\n-4. using a configuration file placed in `$PWD/config/application.properties`\n-  * By placing an `application.properties` file inside a directory named `config` which resides in the directory where the application runs, any runtime properties defined\n-in that file will override the default configuration. Furthermore any runtime properties added to this file that were not part of the original `application.properties` file\n-_will also_ be taken into account.\n-  * This works in the same way for runner jar and the native executable\n-\n-NOTE: Environment variables names are following the conversion rules of link:https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources[Eclipse MicroProfile]\n-\n-NOTE: Environment variables without a configuration profile defined in `.env` file will overwrite all its related profiles in `application.properties`, e.g. `%test.application.value` is overwritten by `APPLICATION_VALUE` in `.env` file.\n-\n-NOTE: The `config/application.properties` features is available in development mode as well. To make use of it, `config/application.properties` needs to be placed inside the build tool's output directory (`target` for Maven and `build/classes/java/main` for Gradle).\n-Keep in mind however that any cleaning operation from the build tool like `mvn clean` or `gradle clean` will remove the `config` directory as well.\n-\n-=== Configuration Profiles\n-\n-Quarkus supports the notion of configuration profiles. These allow you to have multiple configuration in the same file and\n-select between them via a profile name.\n-\n-The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n-\n-[source,properties]\n-----\n-quarkus.http.port=9090\n-%dev.quarkus.http.port=8181\n-----\n-\n-The Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n-\n-To use profiles in the `.env` file, you can follow a `_{PROFILE}_CONFIG_KEY=value` pattern. An equivalent of the above example in an `.env` file would be:\n-\n-[source,.env]\n-----\n-QUARKUS_HTTP_PORT=9090\n-_DEV_QUARKUS_HTTP_PORT=8181\n-----\n-\n-By default Quarkus has three profiles, although it is possible to use as many as you like. The default profiles are:\n-\n-* *dev* - Activated when in development mode (i.e. `quarkus:dev`)\n-* *test* - Activated when running tests\n-* *prod* - The default profile when not running in development or test mode\n-\n-There are two ways to set a custom profile, either via the `quarkus.profile` system property or the `QUARKUS_PROFILE`\n-environment variable. If both are set the system property takes precedence. Note that it is not necessary to\n-define the names of these profiles anywhere, all that is necessary is to create a config property with the profile\n-name, and then set the current profile to that name. For example if I want a `staging` profile with a different HTTP port\n-I can add the following to `application.properties`:\n-\n-[source,properties]\n-----\n-quarkus.http.port=9090\n-%staging.quarkus.http.port=9999\n-----\n-\n-And then set the `QUARKUS_PROFILE` environment variable to `staging` to activate my profile.\n-\n-[NOTE]\n-====\n-The proper way to check the active profile programmatically is to use the `getActiveProfile` method of `io.quarkus.runtime.configuration.ProfileManager`.\n-\n-Using `@ConfigProperty(\"quarkus.profile\")` will *not* work properly.\n-====\n-\n-=== Using Property Expressions\n-\n-Quarkus supports the use of property expressions in the `application.properties` file.\n-\n-These expressions are resolved when the property is read.\n-So if your configuration property is a build time configuration property, the property expression will be resolved at build time.\n-If your configuration property is overridable at runtime, the property expression will be resolved at runtime.\n-\n-You can use property expressions both for the Quarkus configuration or for your own configuration properties.\n-\n-Property expressions are defined this way: `${my-property-expression}`.\n-\n-For example, having the following property:\n-\n-[source,properties]\n-----\n-remote.host=quarkus.io\n-----\n-and another property defined as:\n-\n-[source,properties]\n-----\n-callable.url=https://${remote.host}/\n-----\n-\n-will result in the value of the `callable.url` property being set to:\n-\n-[source,properties]\n-----\n-callable.url=https://quarkus.io/\n-----\n-\n-Another example would be defining different database servers depending on the profile used:\n-\n-[source,properties]\n-----\n-%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:3306/mydatabase?useSSL=false\n-quarkus.datasource.jdbc.url=jdbc:mysql://remotehost:3306/mydatabase?useSSL=false\n-----\n-\n-can be simplified by having:\n-\n-[source,properties]\n-----\n-%dev.application.server=localhost\n-application.server=remotehost\n-\n-quarkus.datasource.jdbc.url=jdbc:mysql://${application.server}:3306/mydatabase?useSSL=false\n-----\n-\n-It does result in one more line in this example but the value of `application.server` can be reused in other properties,\n-diminishing the possibility of typos and providing more flexibility in property definitions.\n-\n-[#combine-property-env-var]\n-=== Combining Property Expressions and Environment Variables\n-\n-Quarkus also supports the combination of both property expressions and environment variables.\n-\n-Let's assume you have following property defined in `application.properties`:\n-\n-[source,properties]\n-----\n-remote.host=quarkus.io\n-----\n-\n-You can combine environment variables and property expressions by having a property defined as follows:\n-\n-[source,properties]\n-----\n-application.host=${HOST:${remote.host}}\n-----\n-\n-This will expand the `HOST` environment variable and use the value of the property `remote.host` as the default value if `HOST` is not set.\n-\n-For the purpose of this section we used the property `remote.host` we defined previously.\n-It has to be noted that the value could have been a fixed one such as in:\n-\n-[source,properties]\n-----\n-application.host=${HOST:localhost}\n-----\n-\n-which will result in `localhost` as the default value if `HOST` is not set.\n-\n-=== Clearing properties\n-\n-Run time properties which are optional, and which have had values set at build time or which have a default value,\n-may be explicitly cleared by assigning an empty string to the property.  Note that this will _only_ affect\n-run time properties, and will _only_ work with properties whose values are not required.\n-\n-The property may be cleared by setting the corresponding `application.properties` property, setting the\n-corresponding system property, or setting the corresponding environment variable.\n-\n-==== Miscellaneous\n-The default Quarkus application runtime profile is set to the profile used to build the application.\n-For example:\n-[source,bash]\n-----\n-./mvnw package -Pnative -Dquarkus.profile=prod-aws\n-./target/my-app-1.0-runner // <1>\n-----\n-<1> The command will run with the `prod-aws` profile. This can be overridden using the `quarkus.profile` system property.\n-\n-== Custom Configuration\n-\n-=== Custom configuration sources\n-\n-You can also introduce custom configuration sources in the standard MicroProfile Config manner.  To\n-do this, you must provide a class which implements either `org.eclipse.microprofile.config.spi.ConfigSource`\n-or `org.eclipse.microprofile.config.spi.ConfigSourceProvider`.  Create a\n-https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html[service file] for the\n-class and it will be detected and installed at application startup.\n-\n-=== Custom configuration converters\n-\n-You can also use your custom types as a configuration values. This can be done by implementing `org.eclipse.microprofile.config.spi.Converter<T>`\n-and adding its fully qualified class name in the `META-INF/services/org.eclipse.microprofile.config.spi.Converter` file.\n-\n-Let us assume you have a custom type like this one:\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-public class MicroProfileCustomValue {\n-\n-    private final int number;\n-\n-    public MicroProfileCustomValue(int number) {\n-        this.number = number;\n-    }\n-\n-    public int getNumber() {\n-        return number;\n-    }\n-}\n-----\n-\n-The corresponding converter will look like the one below. Please note that your custom converter class must be `public` and must have\n-a `public` no-argument constructor. It also must not be `abstract`.\n-\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-import org.eclipse.microprofile.config.spi.Converter;\n-\n-public class MicroProfileCustomValueConverter implements Converter<MicroProfileCustomValue> {\n-\n-    @Override\n-    public MicroProfileCustomValue convert(String value) {\n-        return new MicroProfileCustomValue(Integer.valueOf(value));\n-    }\n-}\n-----\n-\n-Then you need to include the fully qualified class name of the converter in a service file `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n-If you have more converters, simply add their class names in this file as well. Single fully qualified class name per line, for example:\n-\n-[source]\n-----\n-org.acme.config.MicroProfileCustomValueConverter\n-org.acme.config.SomeOtherConverter\n-org.acme.config.YetAnotherConverter\n-----\n-\n-Please note that `SomeOtherConverter` and `YetAnotherConverter` were added just for a demonstration. If you include in this file classes\n-which are not available at runtime, the converters loading will fail.\n-\n-After this is done you can use your custom type as a configuration value:\n-\n-[source,java]\n-----\n-@ConfigProperty(name = \"configuration.value.name\")\n-MicroProfileCustomValue value;\n-----\n-\n-==== Converter priority\n-\n-In some cases, you may want to use a custom converter to convert a type which is already converted\n-by a different converter. In such cases, you can use the `javax.annotation.Priority` annotation to\n-change converters precedence and make your custom converter of higher priority than the other\n-on the list.\n-\n-By default, if no `@Priority` can be found on a converter, it's registered with a priority of 100\n-and all Quarkus core converters are registered with a priority of 200, so depending on which\n-converter you would like to replace, you need to set a higher value.\n-\n-To demonstrate the idea let us implement a custom converter which will take precedence over\n-`MicroProfileCustomValueConverter` implemented in the previous example.\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-import javax.annotation.Priority;\n-import org.eclipse.microprofile.config.spi.Converter;\n-\n-@Priority(150)\n-public class MyCustomConverter implements Converter<MicroProfileCustomValue> {\n-\n-    @Override\n-    public MicroProfileCustomValue convert(String value) {\n-\n-        final int secretNumber;\n-        if (value.startsFrom(\"OBF:\")) {\n-            secretNumber = Integer.valueOf(SecretDecoder.decode(value));\n-        } else {\n-            secretNumber = Integer.valueOf(value);\n-        }\n-\n-        return new MicroProfileCustomValue(secretNumber);\n-    }\n-}\n-----\n-\n-Since it converts the same value type (namely `MicroProfileCustomValue`) and has a priority\n-of 150, it will be used instead of a `MicroProfileCustomValueConverter` which has a default\n-priority of 100.\n-\n-NOTE: This new converter also needs to be listed in a service file, i.e. `META-INF/services/org.eclipse.microprofile.config.spi.Converter`.\n-\n-[[yaml]]\n-== YAML for Configuration\n-\n-=== Add YAML Config Support\n-\n-You might want to use YAML over properties for configuration.\n-Since link:https://github.com/smallrye/smallrye-config[SmallRye Config] brings support for YAML\n-configuration, Quarkus supports this as well.\n-\n-First you will need to add the YAML extension to your `pom.xml`:\n-\n-[source,xml]\n-----\n-<dependency>\n-    <groupId>io.quarkus</groupId>\n-    <artifactId>quarkus-config-yaml</artifactId>\n-</dependency>\n-----\n-\n-Or you can alternatively run this command in the directory containing your Quarkus project:\n-\n-[source,bash]\n-----\n-./mvnw quarkus:add-extension -Dextensions=\"config-yaml\"\n-----\n-\n-Now Quarkus can read YAML configuration files.\n-The config directories and priorities are the same as before.\n-\n-NOTE: Quarkus will choose an `application.yaml` over an `application.properties`.\n-YAML files are just an alternative way to configure your application.\n-You should decide and keep one configuration type to avoid errors.\n-\n-==== Configuration Examples\n-[source,yaml]\n-----\n-# YAML supports comments\n-quarkus:\n-  datasource:\n-    db-kind: postgresql\n-    jdbc:\n-      url: jdbc:postgresql://localhost:5432/some-database\n-    username: quarkus\n-    password: quarkus\n-\n-# REST Client configuration property\n-org:\n-  acme:\n-    restclient:\n-      CountriesService/mp-rest/url: https://restcountries.eu/rest\n-\n-# For configuration property names that use quotes, do not split the string inside the quotes.\n-quarkus:\n-  log:\n-    category:\n-      \"io.quarkus.category\":\n-        level: INFO\n-----\n-\n-[NOTE]\n-====\n-Quarkus also supports using `application.yml` as the name of the YAML file. The same rules apply for this file as for `application.yaml`.\n-====\n-\n-=== Profile dependent configuration\n-\n-Providing profile dependent configuration with YAML is done like with properties.\n-Just add the `%profile` wrapped in quotation marks before defining the key-value pairs:\n-\n-[source,yaml]\n-----\n-\"%dev\":\n-  quarkus:\n-    datasource:\n-      db-kind: postgresql\n-      jdbc:\n-        url: jdbc:postgresql://localhost:5432/some-database\n-      username: quarkus\n-      password: quarkus\n-----\n-\n-=== Configuration key conflicts\n-\n-The MicroProfile Configuration specification defines configuration keys as an arbitrary `.`-delimited string.\n-However, structured formats like YAML naively only support a subset of the possible configuration namespace.\n-For example, consider the two configuration properties `quarkus.http.cors` and `quarkus.http.cors.methods`.\n-One property is the prefix of another, so it may not be immediately evident how to specify both keys in your YAML configuration.\n-\n-This is solved by using a `null` key (normally represented by `~`) for any YAML property which is a prefix of another one.  Here's an example:\n-\n-.An example YAML configuration resolving prefix-related key name conflicts\n-[source,yaml]\n-----\n-quarkus:\n-  http:\n-    cors:\n-      ~: true\n-      methods: GET,PUT,POST\n-----\n-\n-In general, `null` YAML keys are not included in assembly of the configuration property name, allowing them to be used to\n-any level for disambiguating configuration keys.\n-\n-== More info on how to configure\n-\n-Quarkus relies on SmallRye Config and inherits its features.\n-\n-SmallRye Config provides:\n+This is a tradeoff as the more runtime properties are available, the less build time prework Quarkus can do. \n+The list of runtime properties is therefore intentionaly kept lean.\n+You can override these runtime properties with the following mechanisms (in decreasing priority) using:\n \n-* Additional Config Sources\n-* Additional Converters\n-* Interceptors for configuration value resolution\n-* Relocate Configuration Properties\n-* Fallback Configuration Properties\n-* Logging\n-* Hide Secrets\n+1. System properties\n+2. Environment variables\n+3. An environment file named `.env` placed in the current working directory\n+4. A configuration file placed in `$PWD/config/application.properties`\n \n-For more information, please check the\n-link:https://smallrye.io/docs/smallrye-config/index.html[SmallRye Config documentation].\n+See the <<config-reference.adoc#configuring_quarkus,configuration reference guide>> for more information.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NzE1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528367153", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            See the <<config-reference.adoc#using_configproperties,configuration reference guide>> for more information.\n          \n          \n            \n            See the <<config-reference.adoc#using_configproperties,Configuration Reference Guide>> for more information.", "author": "gsmet", "createdAt": "2020-11-22T17:36:05Z", "path": "docs/src/main/asciidoc/config.adoc", "diffHunk": "@@ -114,15 +118,14 @@ $ curl http://localhost:8080/greeting\n hello quarkus!\n ----\n \n-TIP: If the application requires configuration values and these values are not set, an error is thrown.\n-So you can quickly know when your configuration is complete.\n+TIP: As an alternative to injecting multiple related configuration values you can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together. \n+See the <<config-reference.adoc#using_configproperties,configuration reference guide>> for more information.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM2NzE5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13402#discussion_r528367193", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            See the <<config-reference.adoc#configuration_profiles,configuration reference guide>> for more information about configuration profiles.\n          \n          \n            \n            See the <<config-reference.adoc#configuration_profiles,Configuration Reference Guide>> for more information about configuration profiles.", "author": "gsmet", "createdAt": "2020-11-22T17:36:21Z", "path": "docs/src/main/asciidoc/config.adoc", "diffHunk": "@@ -172,190 +175,28 @@ String databaseName = ConfigProvider.getConfig().getValue(\"database.name\", Strin\n Optional<String> maybeDatabaseName = ConfigProvider.getConfig().getOptionalValue(\"database.name\", String.class);\n ----\n \n-== Using @ConfigProperties\n-\n-As an alternative to injecting multiple related configuration values in the way that was shown in the previous example,\n-users can also use the `@io.quarkus.arc.config.ConfigProperties` annotation to group these properties together.\n-\n-For the greeting properties above, a `GreetingConfiguration` class could be created like so:\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-import io.quarkus.arc.config.ConfigProperties;\n-import java.util.Optional;\n-\n-@ConfigProperties(prefix = \"greeting\") <1>\n-public class GreetingConfiguration {\n-\n-    private String message;\n-    private String suffix = \"!\"; <2>\n-    private Optional<String> name;\n-\n-    public String getMessage() {\n-        return message;\n-    }\n-\n-    public void setMessage(String message) {\n-        this.message = message;\n-    }\n-\n-    public String getSuffix() {\n-        return suffix;\n-    }\n-\n-    public void setSuffix(String suffix) {\n-        this.suffix = suffix;\n-    }\n-\n-    public Optional<String> getName() {\n-        return name;\n-    }\n-\n-    public void setName(Optional<String> name) {\n-        this.name = name;\n-    }\n-}\n-----\n-<1> `prefix` is optional. If not set then the prefix to be used will be determined by the class name. In this case it would still be `greeting` (since the `Configuration` suffix is removed). If the class were named `GreetingExtraConfiguration` then the resulting default prefix would be `greeting-extra`.\n-<2> `!` will be the default value if `greeting.suffix` is not set\n-\n-This class could then be injected into the `GreetingResource` using the familiar CDI `@Inject` annotation like so:\n-\n-[source,java]\n-----\n-@Inject\n-GreetingConfiguration greetingConfiguration;\n-----\n-\n-Another alternative style provided by Quarkus is to create `GreetingConfiguration` as an interface like so:\n-\n-[source,java]\n-----\n-package org.acme.config;\n-\n-import io.quarkus.arc.config.ConfigProperties;\n-import org.eclipse.microprofile.config.inject.ConfigProperty;\n-import java.util.Optional;\n-\n-@ConfigProperties(prefix = \"greeting\")\n-public interface GreetingConfiguration {\n-\n-    @ConfigProperty(name = \"message\") <1>\n-    String message();\n-\n-    @ConfigProperty(defaultValue = \"!\")\n-    String getSuffix(); <2>\n-\n-    Optional<String> getName(); <3>\n-}\n-----\n-<1> The `@ConfigProperty` annotation is needed because the name of the configuration property that the method corresponds to doesn't follow the getter method naming conventions\n-<2> In this case since `name` was not set, the corresponding property will be `greeting.suffix`.\n-<3> It is unnecessary to specify the `@ConfigProperty` annotation because the method name follows the getter method naming conventions (`greeting.name` being the corresponding property) and no default value is needed.\n-\n-When using `@ConfigProperties` on a class or an interface, if the value of one of its fields is not provided, the application startup will fail and a `javax.enterprise.inject.spi.DeploymentException` indicating the missing value information will be thrown.\n-This does not apply to `Optional` fields and fields with a default value.\n+== Configuration Profiles\n \n-=== Additional notes on @ConfigProperties\n+Quarkus supports the notion of configuration profiles. \n+These allow you to have multiple configuration values in the same file and select between them via a profile name.\n \n-When using a regular class annotated with `@ConfigProperties` the class doesn't necessarily have to declare getters and setters.\n-Having simple public non-final fields is valid as well.\n-\n-Furthermore, the configuration classes support nested object configuration. Suppose there was a need to have an extra layer\n-of greeting configuration named `content` that would contain a few fields. This could be achieved like so:\n-\n-[source,java]\n-----\n-@ConfigProperties(prefix = \"greeting\")\n-public class GreetingConfiguration {\n-\n-    public String message;\n-    public String suffix = \"!\";\n-    public Optional<String> name;\n-    public ContentConfig content; <1>\n-\n-    public static class ContentConfig {\n-        public Integer prizeAmount;\n-        public List<String> recipients;\n-    }\n-}\n-----\n-<1> The name of the field (not the class name) will determine the name of the properties that are bound to the object.\n-\n-Setting the properties would occur in the normal manner, for example in `application.properties` one could have:\n+The syntax for this is `%{profile}.config.key=value`. For example if I have the following:\n \n [source,properties]\n ----\n-greeting.message = hello\n-greeting.name = quarkus\n-greeting.content.prize-amount=10\n-greeting.content.recipients=Jane,John\n-----\n-\n-Furthermore, classes annotated with `@ConfigProperties` can be annotated with Bean Validation annotations similar to the following example:\n-\n-[source,java]\n-----\n-@ConfigProperties(prefix = \"greeting\")\n-public class GreetingConfiguration {\n-\n-    @Size(min = 20)\n-    public String message;\n-    public String suffix = \"!\";\n-\n-}\n-----\n-\n-WARNING: For validation to work, the `quarkus-hibernate-validator` extension needs to be present.\n-\n-If the validation fails with the given configuration, the application will fail to start and indicate the corresponding validation errors in the log.\n-\n-In the case of an interface being annotated with `@ConfigProperties`, the interface is allowed to extend other interfaces and methods from\n-the entire interface hierarchy are used to bind properties.\n-\n-=== Using same ConfigProperties with different prefixes\n-\n-Quarkus also supports the use of the same `@ConfigProperties` object with different prefixes for each injection point using the `io.quarkus.arc.config.@ConfigPrefix` annotation.\n-Say for example that `GreetingConfiguration` from above needs to be used for both the `greeting` prefix and the `other` prefix.\n-In that case the code would look like so:\n-\n-`GreetingConfiguration.java`\n-[source,java]\n-----\n-@ConfigProperties(prefix = \"greeting\")\n-public class GreetingConfiguration {\n-\n-    @Size(min = 20)\n-    public String message;\n-    public String suffix = \"!\";\n-\n-}\n-----\n-\n-`SomeBean.java`\n-[source,java]\n+quarkus.http.port=9090\n+%dev.quarkus.http.port=8181\n ----\n-@ApplicationScoped\n-public class SomeBean {\n \n-    @Inject <1>\n-    GreetingConfiguration greetingConfiguration;\n+Then the Quarkus HTTP port will be 9090, unless the `dev` profile is active, in which case it will be 8181.\n \n-    @ConfigPrefix(\"other\") <2>\n-    GreetingConfiguration otherConfiguration;\n-\n-}\n-----\n-<1> At this injection point `greetingConfiguration` will use the `greeting` prefix since that is what has been defined on `@ConfigProperties`.\n-<2> At this injection point `otherConfiguration` will use the `other` prefix from `@ConfigPrefix` instead of the `greeting` prefix. Notice that in this case `@Inject` is not required.\n+See the <<config-reference.adoc#configuration_profiles,configuration reference guide>> for more information about configuration profiles.", "originalCommit": "8db2a006915902929439f7b14ff4b7c998e5fd1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8c5569f88fe083f4265c45ffd7e027aa5322a734", "url": "https://github.com/quarkusio/quarkus/commit/8c5569f88fe083f4265c45ffd7e027aa5322a734", "message": "Split the configuration guide into \"introduction\" and \"reference\"\n\n- resolves #13359\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>", "committedDate": "2020-11-23T07:46:40Z", "type": "forcePushed"}, {"oid": "480b75e9866b971954a64bebe0ce5488e8be27bb", "url": "https://github.com/quarkusio/quarkus/commit/480b75e9866b971954a64bebe0ce5488e8be27bb", "message": "Split the configuration guide into \"introduction\" and \"reference\"\n\n- resolves #13359\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>", "committedDate": "2020-11-23T07:47:48Z", "type": "forcePushed"}, {"oid": "41d109587596b043dbeb38cac2d2ceeab2cf3af3", "url": "https://github.com/quarkusio/quarkus/commit/41d109587596b043dbeb38cac2d2ceeab2cf3af3", "message": "Split the configuration guide into \"introduction\" and \"reference\"\n\n- resolves #13359\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>", "committedDate": "2020-11-23T10:02:45Z", "type": "commit"}, {"oid": "41d109587596b043dbeb38cac2d2ceeab2cf3af3", "url": "https://github.com/quarkusio/quarkus/commit/41d109587596b043dbeb38cac2d2ceeab2cf3af3", "message": "Split the configuration guide into \"introduction\" and \"reference\"\n\n- resolves #13359\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>", "committedDate": "2020-11-23T10:02:45Z", "type": "forcePushed"}]}