{"pr_number": 9172, "pr_title": "Amazon SNS + SQS extensions", "pr_createdAt": "2020-05-08T08:31:59Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9172", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA3OTI1NA==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423079254", "bodyText": "Please no new line between the comment and the title. I don't know why but the website generator is very sensitive to that...", "author": "gsmet", "createdAt": "2020-05-11T14:26:40Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwODg4OA==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r424208888", "bodyText": "fixed also dynamo & s3 guides as they had same issue", "author": "marcinczeczko", "createdAt": "2020-05-13T06:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA3OTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA3OTY3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423079673", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n          \n          \n            \n            You can find more information about SNS at https://aws.amazon.com/sns/[the Amazon SNS website].", "author": "gsmet", "createdAt": "2020-05-11T14:27:16Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MDEwNg==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423080106", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n          \n          \n            \n            In this guide, we see how you can get your REST services to use SNS locally and on AWS.", "author": "gsmet", "createdAt": "2020-05-11T14:27:51Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MDM0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423080347", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            === Setup SNS locally\n          \n          \n            \n            === Set up SNS locally", "author": "gsmet", "createdAt": "2020-05-11T14:28:10Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MDc0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423080749", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.\n          \n          \n            \n            Additionally, we create a resource that allows to subscribe to the `QuarksCollider` topic in order to receive published quarks.", "author": "gsmet", "createdAt": "2020-05-11T14:28:47Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally\n+\n+The easiest way to start working with SNS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run -it --publish 8009:4575 -e SERVICES=sns -e START_WEB=0 localstack/localstack\n+----\n+This starts a SNS instance that is accessible on port `8009`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+== Solution\n+The application built here allows to shoot elementary particles (quarks) into a `QuarksCollider` topic of the AWS SNS.\n+Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MTc0MA==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423081740", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot with quarks into the to SNS topic via the SNS synchronous client.\n          \n          \n            \n            Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot quarks into the SNS topic via the SNS synchronous client.", "author": "gsmet", "createdAt": "2020-05-11T14:30:01Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally\n+\n+The easiest way to start working with SNS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run -it --publish 8009:4575 -e SERVICES=sns -e START_WEB=0 localstack/localstack\n+----\n+This starts a SNS instance that is accessible on port `8009`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+== Solution\n+The application built here allows to shoot elementary particles (quarks) into a `QuarksCollider` topic of the AWS SNS.\n+Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sns-quickstart` {quickstarts-tree-url}/amazon-sns-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sns-quickstart \\\n+    -DclassName=\"org.acme.sns.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sns,resteasy-mutiny\"\n+cd amazon-sns-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SNS Client extensions.\n+After this, the `amazon-sns` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that allows to publish quarks. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sns.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot with quarks into the to SNS topic via the SNS synchronous client.", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MjAxOA==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423082018", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Because of the fact that messages published must be simply a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into the `String`.\n          \n          \n            \n            Because of the fact that messages published must be simply a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into a `String`.", "author": "gsmet", "createdAt": "2020-05-11T14:30:23Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally\n+\n+The easiest way to start working with SNS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run -it --publish 8009:4575 -e SERVICES=sns -e START_WEB=0 localstack/localstack\n+----\n+This starts a SNS instance that is accessible on port `8009`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+== Solution\n+The application built here allows to shoot elementary particles (quarks) into a `QuarksCollider` topic of the AWS SNS.\n+Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sns-quickstart` {quickstarts-tree-url}/amazon-sns-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sns-quickstart \\\n+    -DclassName=\"org.acme.sns.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sns,resteasy-mutiny\"\n+cd amazon-sns-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SNS Client extensions.\n+After this, the `amazon-sns` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that allows to publish quarks. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sns.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot with quarks into the to SNS topic via the SNS synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.PublishResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response publish(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        PublishResponse response = sns.publish(p -> p.topicArn(topicArn).message(message));\n+        LOGGER.infov(\"[SYNC] Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact that messages published must be simply a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into the `String`.", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MjQwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423082409", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: Keep in mind, that AWS SNS supports multiple types of subcribers (that is, web servers, email addresses, AWS SQS queues, AWS Lambda functions, and many more), but for the sake of the\n          \n          \n            \n            NOTE: Keep in mind that AWS SNS supports multiple types of subscribers (that is web servers, email addresses, AWS SQS queues, AWS Lambda functions, and many more), but for the sake of the", "author": "gsmet", "createdAt": "2020-05-11T14:30:55Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally\n+\n+The easiest way to start working with SNS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run -it --publish 8009:4575 -e SERVICES=sns -e START_WEB=0 localstack/localstack\n+----\n+This starts a SNS instance that is accessible on port `8009`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+== Solution\n+The application built here allows to shoot elementary particles (quarks) into a `QuarksCollider` topic of the AWS SNS.\n+Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sns-quickstart` {quickstarts-tree-url}/amazon-sns-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sns-quickstart \\\n+    -DclassName=\"org.acme.sns.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sns,resteasy-mutiny\"\n+cd amazon-sns-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SNS Client extensions.\n+After this, the `amazon-sns` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that allows to publish quarks. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sns.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot with quarks into the to SNS topic via the SNS synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.PublishResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response publish(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        PublishResponse response = sns.publish(p -> p.topicArn(topicArn).message(message));\n+        LOGGER.infov(\"[SYNC] Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact that messages published must be simply a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into the `String`.\n+\n+The missing piece is the subscriber that will receive the messages published to our topic. Create `org.acme.QuarksShieldSyncResource` that provides APIs to:\n+- Subscribe to our SNS topic\n+- Unsubscribe from the SNS topic\n+- Receive notifications from the subscribed SNS topic\n+\n+NOTE: Keep in mind, that AWS SNS supports multiple types of subcribers (that is, web servers, email addresses, AWS SQS queues, AWS Lambda functions, and many more), but for the sake of the", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MjUyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423082529", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            quickstart we will show how to subscribe HTTP endpoint served by our application.\n          \n          \n            \n            quickstart we will show how to subscribe an HTTP endpoint served by our application.", "author": "gsmet", "createdAt": "2020-05-11T14:31:05Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally\n+\n+The easiest way to start working with SNS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run -it --publish 8009:4575 -e SERVICES=sns -e START_WEB=0 localstack/localstack\n+----\n+This starts a SNS instance that is accessible on port `8009`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+== Solution\n+The application built here allows to shoot elementary particles (quarks) into a `QuarksCollider` topic of the AWS SNS.\n+Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sns-quickstart` {quickstarts-tree-url}/amazon-sns-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sns-quickstart \\\n+    -DclassName=\"org.acme.sns.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sns,resteasy-mutiny\"\n+cd amazon-sns-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SNS Client extensions.\n+After this, the `amazon-sns` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that allows to publish quarks. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sns.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot with quarks into the to SNS topic via the SNS synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.PublishResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response publish(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        PublishResponse response = sns.publish(p -> p.topicArn(topicArn).message(message));\n+        LOGGER.infov(\"[SYNC] Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact that messages published must be simply a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into the `String`.\n+\n+The missing piece is the subscriber that will receive the messages published to our topic. Create `org.acme.QuarksShieldSyncResource` that provides APIs to:\n+- Subscribe to our SNS topic\n+- Unsubscribe from the SNS topic\n+- Receive notifications from the subscribed SNS topic\n+\n+NOTE: Keep in mind, that AWS SNS supports multiple types of subcribers (that is, web servers, email addresses, AWS SQS queues, AWS Lambda functions, and many more), but for the sake of the\n+quickstart we will show how to subscribe HTTP endpoint served by our application.", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MzA2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423083069", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            3. `notificationEndpoint()` is called by the SNS on new message if endpoint is subscribed.\n          \n          \n            \n            3. `notificationEndpoint()` is called by SNS on new message if endpoint is subscribed.", "author": "gsmet", "createdAt": "2020-05-11T14:31:51Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally\n+\n+The easiest way to start working with SNS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run -it --publish 8009:4575 -e SERVICES=sns -e START_WEB=0 localstack/localstack\n+----\n+This starts a SNS instance that is accessible on port `8009`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+== Solution\n+The application built here allows to shoot elementary particles (quarks) into a `QuarksCollider` topic of the AWS SNS.\n+Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sns-quickstart` {quickstarts-tree-url}/amazon-sns-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sns-quickstart \\\n+    -DclassName=\"org.acme.sns.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sns,resteasy-mutiny\"\n+cd amazon-sns-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SNS Client extensions.\n+After this, the `amazon-sns` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that allows to publish quarks. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sns.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot with quarks into the to SNS topic via the SNS synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.PublishResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response publish(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        PublishResponse response = sns.publish(p -> p.topicArn(topicArn).message(message));\n+        LOGGER.infov(\"[SYNC] Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact that messages published must be simply a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into the `String`.\n+\n+The missing piece is the subscriber that will receive the messages published to our topic. Create `org.acme.QuarksShieldSyncResource` that provides APIs to:\n+- Subscribe to our SNS topic\n+- Unsubscribe from the SNS topic\n+- Receive notifications from the subscribed SNS topic\n+\n+NOTE: Keep in mind, that AWS SNS supports multiple types of subcribers (that is, web servers, email addresses, AWS SQS queues, AWS Lambda functions, and many more), but for the sake of the\n+quickstart we will show how to subscribe HTTP endpoint served by our application.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.acme.sns.model.SnsNotification;\n+import org.acme.sns.model.SnsSubscriptionConfirmation;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.SubscribeResponse;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    private static final String NOTIFICATION_TYPE = \"Notification\";\n+    private static final String SUBSCRIPTION_CONFIRMATION_TYPE = \"SubscriptionConfirmation\";\n+    private static final String UNSUBSCRIPTION_CONFIRMATION_TYPE = \"UnsubscribeConfirmation\";\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    @ConfigProperty(name = \"quarks.shield.base.url\")\n+    String quarksShieldBaseUrl;\n+\n+    private String subscriptionArn;\n+\n+    static ObjectReader NOTIFICATION_READER = new ObjectMapper().readerFor(SnsNotification.class);\n+    static ObjectReader SUBSCRIPTION_READER = new ObjectMapper().readerFor(SnsSubscriptionConfirmation.class);\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @POST\n+    @Consumes({MediaType.TEXT_PLAIN})\n+    public Response notificationEndpoint(@HeaderParam(\"x-amz-sns-message-type\") String messageType, String message) throws JsonProcessingException {\n+        if (messageType == null) {\n+            return Response.status(400).build();\n+        }\n+\n+        if (messageType.equals(NOTIFICATION_TYPE)) {\n+            SnsNotification notification = NOTIFICATION_READER.readValue(message);\n+            Quark quark = QUARK_READER.readValue(notification.getMessage());\n+            LOGGER.infov(\"[SYNC] Quark[{0}, {1}] collision with the shield.\", quark.getFlavor(), quark.getSpin());\n+        } else if (messageType.equals(SUBSCRIPTION_CONFIRMATION_TYPE)) {\n+            SnsSubscriptionConfirmation subConf = SUBSCRIPTION_READER.readValue(message);\n+            sns.confirmSubscription(cs -> cs.topicArn(topicArn).token(subConf.getToken()));\n+            LOGGER.info(\"[SYNC] Subscription confirmed\");\n+        } else if (messageType.equals(UNSUBSCRIPTION_CONFIRMATION_TYPE)) {\n+            LOGGER.info(\"[SYNC] We are unsubscribed\");\n+        } else {\n+            return Response.status(400).entity(\"[SYNC] Unknown messageType\").build();\n+        }\n+\n+        return Response.ok().build();\n+    }\n+\n+    @POST\n+    @Path(\"/subscribe\")\n+    public Response subscribe() {\n+        SubscribeResponse response = sns.subscribe(s -> s.topicArn(topicArn).protocol(\"http\").endpoint(notificationEndpoint()));\n+        subscriptionArn = response.subscriptionArn();\n+        LOGGER.infov(\"[SYNC] Subscribed Quarks shield with id = {0} \", response.subscriptionArn());\n+        return Response.ok().entity(response.subscriptionArn()).build();\n+    }\n+\n+    @POST\n+    @Path(\"/unsubscribe\")\n+    public Response unsubscribe() {\n+        if (subscriptionArn != null) {\n+            sns.unsubscribe(s -> s.subscriptionArn(subscriptionArn));\n+            LOGGER.infov(\"[SYNC] Unsubscribed quarks shield for id = {0}\", subscriptionArn);\n+            return Response.ok().build();\n+        } else {\n+            LOGGER.info(\"[SYNC] Not subscribed yet\");\n+            return Response.status(400).entity(\"Not subscribed yet\").build();\n+        }\n+    }\n+\n+    private String notificationEndpoint() {\n+        return quarksShieldBaseUrl + \"/sync/shield\";\n+    }\n+}\n+----\n+\n+1. `subscribe()` endpoint subscribes to our topic by providing the URL to the POST endpoint receiving SNS notification requests.\n+2. `unsubscribe()` simply removes our subscription, so any messages published to the topic will not be routed to our endpoint anymore\n+3. `notificationEndpoint()` is called by the SNS on new message if endpoint is subscribed.", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MzM0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423083346", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Additionally, you need to added to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n          \n          \n            \n            Additionally, you need to add to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so", "author": "gsmet", "createdAt": "2020-05-11T14:32:15Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally\n+\n+The easiest way to start working with SNS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run -it --publish 8009:4575 -e SERVICES=sns -e START_WEB=0 localstack/localstack\n+----\n+This starts a SNS instance that is accessible on port `8009`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+== Solution\n+The application built here allows to shoot elementary particles (quarks) into a `QuarksCollider` topic of the AWS SNS.\n+Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sns-quickstart` {quickstarts-tree-url}/amazon-sns-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sns-quickstart \\\n+    -DclassName=\"org.acme.sns.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sns,resteasy-mutiny\"\n+cd amazon-sns-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SNS Client extensions.\n+After this, the `amazon-sns` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that allows to publish quarks. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sns.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot with quarks into the to SNS topic via the SNS synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.PublishResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response publish(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        PublishResponse response = sns.publish(p -> p.topicArn(topicArn).message(message));\n+        LOGGER.infov(\"[SYNC] Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact that messages published must be simply a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into the `String`.\n+\n+The missing piece is the subscriber that will receive the messages published to our topic. Create `org.acme.QuarksShieldSyncResource` that provides APIs to:\n+- Subscribe to our SNS topic\n+- Unsubscribe from the SNS topic\n+- Receive notifications from the subscribed SNS topic\n+\n+NOTE: Keep in mind, that AWS SNS supports multiple types of subcribers (that is, web servers, email addresses, AWS SQS queues, AWS Lambda functions, and many more), but for the sake of the\n+quickstart we will show how to subscribe HTTP endpoint served by our application.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.acme.sns.model.SnsNotification;\n+import org.acme.sns.model.SnsSubscriptionConfirmation;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.SubscribeResponse;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    private static final String NOTIFICATION_TYPE = \"Notification\";\n+    private static final String SUBSCRIPTION_CONFIRMATION_TYPE = \"SubscriptionConfirmation\";\n+    private static final String UNSUBSCRIPTION_CONFIRMATION_TYPE = \"UnsubscribeConfirmation\";\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    @ConfigProperty(name = \"quarks.shield.base.url\")\n+    String quarksShieldBaseUrl;\n+\n+    private String subscriptionArn;\n+\n+    static ObjectReader NOTIFICATION_READER = new ObjectMapper().readerFor(SnsNotification.class);\n+    static ObjectReader SUBSCRIPTION_READER = new ObjectMapper().readerFor(SnsSubscriptionConfirmation.class);\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @POST\n+    @Consumes({MediaType.TEXT_PLAIN})\n+    public Response notificationEndpoint(@HeaderParam(\"x-amz-sns-message-type\") String messageType, String message) throws JsonProcessingException {\n+        if (messageType == null) {\n+            return Response.status(400).build();\n+        }\n+\n+        if (messageType.equals(NOTIFICATION_TYPE)) {\n+            SnsNotification notification = NOTIFICATION_READER.readValue(message);\n+            Quark quark = QUARK_READER.readValue(notification.getMessage());\n+            LOGGER.infov(\"[SYNC] Quark[{0}, {1}] collision with the shield.\", quark.getFlavor(), quark.getSpin());\n+        } else if (messageType.equals(SUBSCRIPTION_CONFIRMATION_TYPE)) {\n+            SnsSubscriptionConfirmation subConf = SUBSCRIPTION_READER.readValue(message);\n+            sns.confirmSubscription(cs -> cs.topicArn(topicArn).token(subConf.getToken()));\n+            LOGGER.info(\"[SYNC] Subscription confirmed\");\n+        } else if (messageType.equals(UNSUBSCRIPTION_CONFIRMATION_TYPE)) {\n+            LOGGER.info(\"[SYNC] We are unsubscribed\");\n+        } else {\n+            return Response.status(400).entity(\"[SYNC] Unknown messageType\").build();\n+        }\n+\n+        return Response.ok().build();\n+    }\n+\n+    @POST\n+    @Path(\"/subscribe\")\n+    public Response subscribe() {\n+        SubscribeResponse response = sns.subscribe(s -> s.topicArn(topicArn).protocol(\"http\").endpoint(notificationEndpoint()));\n+        subscriptionArn = response.subscriptionArn();\n+        LOGGER.infov(\"[SYNC] Subscribed Quarks shield with id = {0} \", response.subscriptionArn());\n+        return Response.ok().entity(response.subscriptionArn()).build();\n+    }\n+\n+    @POST\n+    @Path(\"/unsubscribe\")\n+    public Response unsubscribe() {\n+        if (subscriptionArn != null) {\n+            sns.unsubscribe(s -> s.subscriptionArn(subscriptionArn));\n+            LOGGER.infov(\"[SYNC] Unsubscribed quarks shield for id = {0}\", subscriptionArn);\n+            return Response.ok().build();\n+        } else {\n+            LOGGER.info(\"[SYNC] Not subscribed yet\");\n+            return Response.status(400).entity(\"Not subscribed yet\").build();\n+        }\n+    }\n+\n+    private String notificationEndpoint() {\n+        return quarksShieldBaseUrl + \"/sync/shield\";\n+    }\n+}\n+----\n+\n+1. `subscribe()` endpoint subscribes to our topic by providing the URL to the POST endpoint receiving SNS notification requests.\n+2. `unsubscribe()` simply removes our subscription, so any messages published to the topic will not be routed to our endpoint anymore\n+3. `notificationEndpoint()` is called by the SNS on new message if endpoint is subscribed.\n+See https://docs.aws.amazon.com/sns/latest/dg/sns-message-and-json-formats.html[Amazon SNS message and JSON formats] for details about the format of the messages SNS can submit.\n+\n+\n+== Configuring SNS clients\n+\n+Both SNS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to added to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4MzU2NA==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423083564", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            And add following dependency to the application `pom.xml`:\n          \n          \n            \n            And add the following dependency to the application `pom.xml`:", "author": "gsmet", "createdAt": "2020-05-11T14:32:32Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally\n+\n+The easiest way to start working with SNS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run -it --publish 8009:4575 -e SERVICES=sns -e START_WEB=0 localstack/localstack\n+----\n+This starts a SNS instance that is accessible on port `8009`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+== Solution\n+The application built here allows to shoot elementary particles (quarks) into a `QuarksCollider` topic of the AWS SNS.\n+Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sns-quickstart` {quickstarts-tree-url}/amazon-sns-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sns-quickstart \\\n+    -DclassName=\"org.acme.sns.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sns,resteasy-mutiny\"\n+cd amazon-sns-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SNS Client extensions.\n+After this, the `amazon-sns` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that allows to publish quarks. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sns.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot with quarks into the to SNS topic via the SNS synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.PublishResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response publish(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        PublishResponse response = sns.publish(p -> p.topicArn(topicArn).message(message));\n+        LOGGER.infov(\"[SYNC] Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact that messages published must be simply a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into the `String`.\n+\n+The missing piece is the subscriber that will receive the messages published to our topic. Create `org.acme.QuarksShieldSyncResource` that provides APIs to:\n+- Subscribe to our SNS topic\n+- Unsubscribe from the SNS topic\n+- Receive notifications from the subscribed SNS topic\n+\n+NOTE: Keep in mind, that AWS SNS supports multiple types of subcribers (that is, web servers, email addresses, AWS SQS queues, AWS Lambda functions, and many more), but for the sake of the\n+quickstart we will show how to subscribe HTTP endpoint served by our application.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.acme.sns.model.SnsNotification;\n+import org.acme.sns.model.SnsSubscriptionConfirmation;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.SubscribeResponse;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    private static final String NOTIFICATION_TYPE = \"Notification\";\n+    private static final String SUBSCRIPTION_CONFIRMATION_TYPE = \"SubscriptionConfirmation\";\n+    private static final String UNSUBSCRIPTION_CONFIRMATION_TYPE = \"UnsubscribeConfirmation\";\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    @ConfigProperty(name = \"quarks.shield.base.url\")\n+    String quarksShieldBaseUrl;\n+\n+    private String subscriptionArn;\n+\n+    static ObjectReader NOTIFICATION_READER = new ObjectMapper().readerFor(SnsNotification.class);\n+    static ObjectReader SUBSCRIPTION_READER = new ObjectMapper().readerFor(SnsSubscriptionConfirmation.class);\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @POST\n+    @Consumes({MediaType.TEXT_PLAIN})\n+    public Response notificationEndpoint(@HeaderParam(\"x-amz-sns-message-type\") String messageType, String message) throws JsonProcessingException {\n+        if (messageType == null) {\n+            return Response.status(400).build();\n+        }\n+\n+        if (messageType.equals(NOTIFICATION_TYPE)) {\n+            SnsNotification notification = NOTIFICATION_READER.readValue(message);\n+            Quark quark = QUARK_READER.readValue(notification.getMessage());\n+            LOGGER.infov(\"[SYNC] Quark[{0}, {1}] collision with the shield.\", quark.getFlavor(), quark.getSpin());\n+        } else if (messageType.equals(SUBSCRIPTION_CONFIRMATION_TYPE)) {\n+            SnsSubscriptionConfirmation subConf = SUBSCRIPTION_READER.readValue(message);\n+            sns.confirmSubscription(cs -> cs.topicArn(topicArn).token(subConf.getToken()));\n+            LOGGER.info(\"[SYNC] Subscription confirmed\");\n+        } else if (messageType.equals(UNSUBSCRIPTION_CONFIRMATION_TYPE)) {\n+            LOGGER.info(\"[SYNC] We are unsubscribed\");\n+        } else {\n+            return Response.status(400).entity(\"[SYNC] Unknown messageType\").build();\n+        }\n+\n+        return Response.ok().build();\n+    }\n+\n+    @POST\n+    @Path(\"/subscribe\")\n+    public Response subscribe() {\n+        SubscribeResponse response = sns.subscribe(s -> s.topicArn(topicArn).protocol(\"http\").endpoint(notificationEndpoint()));\n+        subscriptionArn = response.subscriptionArn();\n+        LOGGER.infov(\"[SYNC] Subscribed Quarks shield with id = {0} \", response.subscriptionArn());\n+        return Response.ok().entity(response.subscriptionArn()).build();\n+    }\n+\n+    @POST\n+    @Path(\"/unsubscribe\")\n+    public Response unsubscribe() {\n+        if (subscriptionArn != null) {\n+            sns.unsubscribe(s -> s.subscriptionArn(subscriptionArn));\n+            LOGGER.infov(\"[SYNC] Unsubscribed quarks shield for id = {0}\", subscriptionArn);\n+            return Response.ok().build();\n+        } else {\n+            LOGGER.info(\"[SYNC] Not subscribed yet\");\n+            return Response.status(400).entity(\"Not subscribed yet\").build();\n+        }\n+    }\n+\n+    private String notificationEndpoint() {\n+        return quarksShieldBaseUrl + \"/sync/shield\";\n+    }\n+}\n+----\n+\n+1. `subscribe()` endpoint subscribes to our topic by providing the URL to the POST endpoint receiving SNS notification requests.\n+2. `unsubscribe()` simply removes our subscription, so any messages published to the topic will not be routed to our endpoint anymore\n+3. `notificationEndpoint()` is called by the SNS on new message if endpoint is subscribed.\n+See https://docs.aws.amazon.com/sns/latest/dg/sns-message-and-json-formats.html[Amazon SNS message and JSON formats] for details about the format of the messages SNS can submit.\n+\n+\n+== Configuring SNS clients\n+\n+Both SNS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to added to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n+you need to add a URL connection client dependency to the `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>url-connection-client</artifactId>\n+</dependency>\n+----\n+\n+If you want to use Apache HTTP client instead, configure it as follows:\n+[source,properties]\n+----\n+quarkus.sns.sync-client.type=apache\n+----\n+\n+And add following dependency to the application `pom.xml`:", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NDYzMA==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423084630", "bodyText": "Could we have that one first? It seems more level than the Java implementation?", "author": "gsmet", "createdAt": "2020-05-11T14:33:56Z", "path": "docs/src/main/asciidoc/amazon-sns.adoc", "diffHunk": "@@ -0,0 +1,445 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+\n+= Quarkus - Amazon SNS Client\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+Amazon Simple Notification Service (SNS) is a highly available and fully managed pub/sub messaging service.\n+It provides topics for high-throughput, push-based, many-to-many messaging. Messages can fan out to a large number of subscriber endpoints for\n+parallel processing, including Amazon SQS queues, AWS Lambda functions, and HTTP/S webhooks. Additionally, SNS can be used\n+to fan out notifications to end users using mobile push, SMS and email.\n+\n+You can find more information about DynamoDB at https://aws.amazon.com/sns/[the Amazon SNS website].\n+\n+NOTE: The SNS extension is based on https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/welcome.html[AWS Java SDK 2.x].\n+It's a major rewrite of the 1.x code base that offers two programming models (Blocking & Async).\n+\n+include::./status-include.adoc[]\n+\n+The Quarkus extension supports two programming models:\n+\n+* Blocking access using URL Connection HTTP client (by default) or the Apache HTTP Client\n+* https://docs.aws.amazon.com/sdk-for-java/v2/developer-guide/basics-async.html[Asynchronous programming] based on JDK's `CompletableFuture` objects and the Netty HTTP client.\n+\n+In this guide, we see how you can get your REST services to use the SNS locally and on AWS.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* an IDE\n+* Apache Maven {maven-version}\n+* An AWS Account to access the SNS service\n+* Optionally, Docker for your system to run SNS locally for testing purposes\n+\n+=== Setup SNS locally\n+\n+The easiest way to start working with SNS is to run a local instance as a container.\n+\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+docker run -it --publish 8009:4575 -e SERVICES=sns -e START_WEB=0 localstack/localstack\n+----\n+This starts a SNS instance that is accessible on port `8009`.\n+\n+Create an AWS profile for your local instance using AWS CLI:\n+[source,shell,subs=\"verbatim,attributes\"]\n+----\n+$ aws configure --profile localstack\n+AWS Access Key ID [None]: test-key\n+AWS Secret Access Key [None]: test-secret\n+Default region name [None]: us-east-1\n+Default output format [None]:\n+----\n+\n+== Solution\n+The application built here allows to shoot elementary particles (quarks) into a `QuarksCollider` topic of the AWS SNS.\n+Additionally, we create a resource that allows to subscribe to `QuarksCollider` topic in order to receive published quarks.\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `amazon-sns-quickstart` {quickstarts-tree-url}/amazon-sns-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=amazon-sns-quickstart \\\n+    -DclassName=\"org.acme.sns.QuarksCannonSyncResource\" \\\n+    -Dpath=\"/sync-cannon\" \\\n+    -Dextensions=\"resteasy-jsonb,amazon-sns,resteasy-mutiny\"\n+cd amazon-sns-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Mutiny and Amazon SNS Client extensions.\n+After this, the `amazon-sns` extension has been added to your `pom.xml` as well as the Mutiny support for RESTEasy.\n+\n+== Creating JSON REST service\n+\n+In this example, we will create an application that allows to publish quarks. The example application will demonstrate the two programming models supported by the extension.\n+\n+First, let's create the `Quark` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.sns.model;\n+\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+import java.util.Objects;\n+\n+@RegisterForReflection\n+public class Quark {\n+\n+    private String flavor;\n+    private String spin;\n+\n+    public Quark() {\n+    }\n+\n+    public String getFlavor() {\n+        return flavor;\n+    }\n+\n+    public void setFlavor(String flavor) {\n+        this.flavor = flavor;\n+    }\n+\n+    public String getSpin() {\n+        return spin;\n+    }\n+\n+    public void setSpin(String spin) {\n+        this.spin = spin;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof Quark)) {\n+            return false;\n+        }\n+\n+        Quark other = (Quark) obj;\n+\n+        return Objects.equals(other.flavor, this.flavor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(this.flavor);\n+    }\n+}\n+----\n+Then, create a `org.acme.sns.QuarksCannonSyncResource` that will provide an API to shoot with quarks into the to SNS topic via the SNS synchronous client.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.PublishResponse;\n+\n+@Path(\"/sync/cannon\")\n+@Produces(MediaType.TEXT_PLAIN)\n+public class QuarksCannonSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksCannonSyncResource.class);\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Response publish(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        PublishResponse response = sns.publish(p -> p.topicArn(topicArn).message(message));\n+        LOGGER.infov(\"[SYNC] Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin());\n+        return Response.ok().entity(response.messageId()).build();\n+    }\n+}\n+----\n+\n+Because of the fact that messages published must be simply a `String` we're using Jackson's `ObjectWriter` in order to serialize our `Quark` objects into the `String`.\n+\n+The missing piece is the subscriber that will receive the messages published to our topic. Create `org.acme.QuarksShieldSyncResource` that provides APIs to:\n+- Subscribe to our SNS topic\n+- Unsubscribe from the SNS topic\n+- Receive notifications from the subscribed SNS topic\n+\n+NOTE: Keep in mind, that AWS SNS supports multiple types of subcribers (that is, web servers, email addresses, AWS SQS queues, AWS Lambda functions, and many more), but for the sake of the\n+quickstart we will show how to subscribe HTTP endpoint served by our application.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.acme.sns.model.SnsNotification;\n+import org.acme.sns.model.SnsSubscriptionConfirmation;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsClient;\n+import software.amazon.awssdk.services.sns.model.SubscribeResponse;\n+\n+@Path(\"/sync/shield\")\n+public class QuarksShieldSyncResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksShieldSyncResource.class);\n+\n+    private static final String NOTIFICATION_TYPE = \"Notification\";\n+    private static final String SUBSCRIPTION_CONFIRMATION_TYPE = \"SubscriptionConfirmation\";\n+    private static final String UNSUBSCRIPTION_CONFIRMATION_TYPE = \"UnsubscribeConfirmation\";\n+\n+    @Inject\n+    SnsClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    @ConfigProperty(name = \"quarks.shield.base.url\")\n+    String quarksShieldBaseUrl;\n+\n+    private String subscriptionArn;\n+\n+    static ObjectReader NOTIFICATION_READER = new ObjectMapper().readerFor(SnsNotification.class);\n+    static ObjectReader SUBSCRIPTION_READER = new ObjectMapper().readerFor(SnsSubscriptionConfirmation.class);\n+    static ObjectReader QUARK_READER = new ObjectMapper().readerFor(Quark.class);\n+\n+    @POST\n+    @Consumes({MediaType.TEXT_PLAIN})\n+    public Response notificationEndpoint(@HeaderParam(\"x-amz-sns-message-type\") String messageType, String message) throws JsonProcessingException {\n+        if (messageType == null) {\n+            return Response.status(400).build();\n+        }\n+\n+        if (messageType.equals(NOTIFICATION_TYPE)) {\n+            SnsNotification notification = NOTIFICATION_READER.readValue(message);\n+            Quark quark = QUARK_READER.readValue(notification.getMessage());\n+            LOGGER.infov(\"[SYNC] Quark[{0}, {1}] collision with the shield.\", quark.getFlavor(), quark.getSpin());\n+        } else if (messageType.equals(SUBSCRIPTION_CONFIRMATION_TYPE)) {\n+            SnsSubscriptionConfirmation subConf = SUBSCRIPTION_READER.readValue(message);\n+            sns.confirmSubscription(cs -> cs.topicArn(topicArn).token(subConf.getToken()));\n+            LOGGER.info(\"[SYNC] Subscription confirmed\");\n+        } else if (messageType.equals(UNSUBSCRIPTION_CONFIRMATION_TYPE)) {\n+            LOGGER.info(\"[SYNC] We are unsubscribed\");\n+        } else {\n+            return Response.status(400).entity(\"[SYNC] Unknown messageType\").build();\n+        }\n+\n+        return Response.ok().build();\n+    }\n+\n+    @POST\n+    @Path(\"/subscribe\")\n+    public Response subscribe() {\n+        SubscribeResponse response = sns.subscribe(s -> s.topicArn(topicArn).protocol(\"http\").endpoint(notificationEndpoint()));\n+        subscriptionArn = response.subscriptionArn();\n+        LOGGER.infov(\"[SYNC] Subscribed Quarks shield with id = {0} \", response.subscriptionArn());\n+        return Response.ok().entity(response.subscriptionArn()).build();\n+    }\n+\n+    @POST\n+    @Path(\"/unsubscribe\")\n+    public Response unsubscribe() {\n+        if (subscriptionArn != null) {\n+            sns.unsubscribe(s -> s.subscriptionArn(subscriptionArn));\n+            LOGGER.infov(\"[SYNC] Unsubscribed quarks shield for id = {0}\", subscriptionArn);\n+            return Response.ok().build();\n+        } else {\n+            LOGGER.info(\"[SYNC] Not subscribed yet\");\n+            return Response.status(400).entity(\"Not subscribed yet\").build();\n+        }\n+    }\n+\n+    private String notificationEndpoint() {\n+        return quarksShieldBaseUrl + \"/sync/shield\";\n+    }\n+}\n+----\n+\n+1. `subscribe()` endpoint subscribes to our topic by providing the URL to the POST endpoint receiving SNS notification requests.\n+2. `unsubscribe()` simply removes our subscription, so any messages published to the topic will not be routed to our endpoint anymore\n+3. `notificationEndpoint()` is called by the SNS on new message if endpoint is subscribed.\n+See https://docs.aws.amazon.com/sns/latest/dg/sns-message-and-json-formats.html[Amazon SNS message and JSON formats] for details about the format of the messages SNS can submit.\n+\n+\n+== Configuring SNS clients\n+\n+Both SNS clients (sync and async) are configurable via the `application.properties` file that can be provided in the `src/main/resources` directory.\n+Additionally, you need to added to the classpath a proper implementation of the sync client. By default the extension uses URL connection HTTP client, so\n+you need to add a URL connection client dependency to the `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>url-connection-client</artifactId>\n+</dependency>\n+----\n+\n+If you want to use Apache HTTP client instead, configure it as follows:\n+[source,properties]\n+----\n+quarkus.sns.sync-client.type=apache\n+----\n+\n+And add following dependency to the application `pom.xml`:\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>apache-client</artifactId>\n+</dependency>\n+----\n+\n+If you're going to use a local SNS instance, configure it as follows:\n+\n+[source,properties]\n+----\n+quarkus.sns.endpoint-override=http://localhost:8009\n+\n+quarkus.sns.aws.region=us-east-1\n+quarkus.sns.aws.credentials.type=static\n+quarkus.sns.aws.credentials.static-provider.access-key-id=test-key\n+quarkus.sns.aws.credentials.static-provider.secret-access-key=test-secret\n+----\n+\n+- `quarkus.sns.aws.region` - It's required by the client, but since you're using a local SNS instance you can pick any valid AWS region.\n+- `quarkus.sns.aws.credentials.type` - Set `static` credentials provider with any values for `access-key-id` and `secret-access-key`\n+- `quarkus.sns.endpoint-override` - Override the SNS client to use a local instance instead of an AWS service\n+\n+If you want to work with an AWS account, you'd need to set it with:\n+[source,properties]\n+----\n+quarkus.sns.aws.region=<YOUR_REGION>\n+quarkus.sns.aws.credentials.type=default\n+----\n+\n+- `quarkus.sns.aws.region` you should set it to the region where you provisioned the SNS table,\n+- `quarkus.sns.aws.credentials.type` - use the `default` credentials provider chain that looks for credentials in this order:\n+- Java System Properties - `aws.accessKeyId` and `aws.secretKey`\n+* Environment Variables - `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`\n+* Credential profiles file at the default location (`~/.aws/credentials`) shared by all AWS SDKs and the AWS CLI\n+* Credentials delivered through the Amazon EC2 container service if the `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI` environment variable is set and the security manager has permission to access the variable,\n+* Instance profile credentials delivered through the Amazon EC2 metadata service\n+\n+== Next steps\n+\n+=== Packaging\n+\n+Packaging your application is as simple as `./mvnw clean package`.\n+It can be run with `java -jar target/amazon-sns-quickstart-1.0-SNAPSHOT-runner.jar`.\n+\n+With GraalVM installed, you can also create a native executable binary: `./mvnw clean package -Dnative`.\n+Depending on your system, that will take some time.\n+\n+=== Going asynchronous\n+\n+Thanks to the AWS SDK v2.x used by the Quarkus extension, you can use the asynchronous programming model out of the box.\n+\n+Create a `org.acme.sns.QuarksAsyncResource` REST resource that will be similar to our `QuarksSyncResource` but using an asynchronous programming model.\n+\n+[source,java]\n+----\n+package org.acme.sns;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import io.smallrye.mutiny.Uni;\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import org.acme.sns.model.Quark;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+import org.jboss.logging.Logger;\n+import software.amazon.awssdk.services.sns.SnsAsyncClient;\n+import software.amazon.awssdk.services.sns.model.PublishResponse;\n+\n+@Path(\"/async/cannon\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class QuarksAsyncCannonResource {\n+\n+    private static final Logger LOGGER = Logger.getLogger(QuarksAsyncCannonResource.class);\n+\n+    @Inject\n+    SnsAsyncClient sns;\n+\n+    @ConfigProperty(name = \"topic.arn\")\n+    String topicArn;\n+\n+    static ObjectWriter QUARK_WRITER = new ObjectMapper().writerFor(Quark.class);\n+\n+    @POST\n+    @Path(\"/shoot\")\n+    @Consumes(MediaType.APPLICATION_JSON)\n+    public Uni<Response> publish(Quark quark) throws Exception {\n+        String message = QUARK_WRITER.writeValueAsString(quark);\n+        return Uni.createFrom()\n+            .completionStage(sns.publish(p -> p.topicArn(topicArn).message(message)))\n+            .onItem().invoke(item -> LOGGER.infov(\"[SYNC] Fired Quark[{0}, {1}}]\", quark.getFlavor(), quark.getSpin()))\n+            .onItem().apply(PublishResponse::messageId)\n+            .onItem().apply(id -> Response.ok().entity(id).build());\n+    }\n+}\n+----\n+We create `Uni` instances from the `CompletionStage` objects returned by the asynchronous SNS client, and then transform the emitted item.\n+\n+And add Netty HTTP client dependency to the `pom.xml`:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>software.amazon.awssdk</groupId>\n+    <artifactId>netty-nio-client</artifactId>\n+</dependency>\n+----", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxMjMzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r424212339", "bodyText": "What do you mean by that ?", "author": "marcinczeczko", "createdAt": "2020-05-13T06:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NDYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NDkzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423084931", "bodyText": "AFAICS, this one is duplicated.", "author": "gsmet", "createdAt": "2020-05-11T14:34:21Z", "path": "extensions/amazon-services/sns/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,81 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-amazon-sns-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-amazon-sns-deployment</artifactId>\n+    <name>Quarkus - Amazon Services - SNS - Deployment</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-netty-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-amazon-common-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-amazon-sns</artifactId>\n+        </dependency>\n+\n+        <!-- Test dependencies -->\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-junit5-internal</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.rest-assured</groupId>\n+            <artifactId>rest-assured</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>netty-nio-client</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>software.amazon.awssdk</groupId>\n+            <artifactId>url-connection-client</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-amazon-sns</artifactId>", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNDA3NA==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r424214074", "bodyText": "fixed", "author": "marcinczeczko", "createdAt": "2020-05-13T07:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NDkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NjEzMA==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423086130", "bodyText": "We need a description for the runtime artifacts.", "author": "gsmet", "createdAt": "2020-05-11T14:35:59Z", "path": "extensions/amazon-services/sns/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,78 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-amazon-sns-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-amazon-sns</artifactId>\n+    <name>Quarkus - Amazon Services - SNS - Runtime</name>", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNTM5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r424215392", "bodyText": "fixed.", "author": "marcinczeczko", "createdAt": "2020-05-13T07:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4NjEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4Njk2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r423086965", "bodyText": "We need a description for the runtime artifact.", "author": "gsmet", "createdAt": "2020-05-11T14:37:10Z", "path": "extensions/amazon-services/sqs/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,78 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-amazon-sqs-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-amazon-sqs</artifactId>\n+    <name>Quarkus - Amazon Services - SQS - Runtime</name>", "originalCommit": "17bf0377b6e683fb2d55b33575ecfb5b6e74b372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxNTQzNg==", "url": "https://github.com/quarkusio/quarkus/pull/9172#discussion_r424215436", "bodyText": "Fixed", "author": "marcinczeczko", "createdAt": "2020-05-13T07:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA4Njk2NQ=="}], "type": "inlineReview"}, {"oid": "4159b98c0d771a9a99d030ab13c549c27c3bea27", "url": "https://github.com/quarkusio/quarkus/commit/4159b98c0d771a9a99d030ab13c549c27c3bea27", "message": "SNS guide fixes\n\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>", "committedDate": "2020-05-13T06:59:05Z", "type": "forcePushed"}, {"oid": "f30380cbb020e429b0d638a42c9c42459c86d050", "url": "https://github.com/quarkusio/quarkus/commit/f30380cbb020e429b0d638a42c9c42459c86d050", "message": "Amazon SNS + SQS extensions", "committedDate": "2020-05-14T14:03:51Z", "type": "forcePushed"}, {"oid": "e5d6befa2788e5b9fe5e78f0a489aab94390a2a7", "url": "https://github.com/quarkusio/quarkus/commit/e5d6befa2788e5b9fe5e78f0a489aab94390a2a7", "message": "Amazon SNS + SQS extensions", "committedDate": "2020-05-14T21:18:55Z", "type": "forcePushed"}, {"oid": "d8a59bdadf60c5d8099ce8b4985b25586f3a56c8", "url": "https://github.com/quarkusio/quarkus/commit/d8a59bdadf60c5d8099ce8b4985b25586f3a56c8", "message": "Amazon SNS + SQS extensions", "committedDate": "2020-05-14T22:23:57Z", "type": "commit"}, {"oid": "d8a59bdadf60c5d8099ce8b4985b25586f3a56c8", "url": "https://github.com/quarkusio/quarkus/commit/d8a59bdadf60c5d8099ce8b4985b25586f3a56c8", "message": "Amazon SNS + SQS extensions", "committedDate": "2020-05-14T22:23:57Z", "type": "forcePushed"}]}