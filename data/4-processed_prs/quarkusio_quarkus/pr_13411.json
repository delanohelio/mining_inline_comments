{"pr_number": 13411, "pr_title": "Enable the RequestScope on gRPC service invocations", "pr_createdAt": "2020-11-21T08:20:01Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13411", "timeline": [{"oid": "366d0c55b98231de7c7f52d2696b503a23618988", "url": "https://github.com/quarkusio/quarkus/commit/366d0c55b98231de7c7f52d2696b503a23618988", "message": "Enable the RequestScope on gRPC service invocations", "committedDate": "2020-11-22T17:48:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUxNjQ4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r528516486", "bodyText": "why is this variable called managed?", "author": "michalszynkiewicz", "createdAt": "2020-11-23T07:51:14Z", "path": "extensions/grpc/runtime/src/main/java/io/quarkus/grpc/runtime/supports/RequestScopeHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package io.quarkus.grpc.runtime.supports;\n+\n+import io.grpc.ForwardingServerCall;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.Status;\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.ManagedContext;\n+\n+public class RequestScopeHandlerInterceptor implements ServerInterceptor {\n+\n+    private final ManagedContext reqContext;\n+\n+    public RequestScopeHandlerInterceptor() {\n+        reqContext = Arc.container().requestContext();\n+    }\n+\n+    @Override\n+    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call,\n+            Metadata headers,\n+            ServerCallHandler<ReqT, RespT> next) {\n+\n+        boolean managed = !reqContext.isActive();", "originalCommit": "366d0c55b98231de7c7f52d2696b503a23618988", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyNjg1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r528526855", "bodyText": "because I suck at naming. It just means that the request scope is \"managed\" by the interceptor (and not be enabled beforehand)", "author": "cescoffier", "createdAt": "2020-11-23T08:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUxNjQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r528529968", "bodyText": "@cescoffier Do you expect this to be called from a different thread than the one that called reqContext.activate()?", "author": "mkouba", "createdAt": "2020-11-23T08:21:35Z", "path": "extensions/grpc/runtime/src/main/java/io/quarkus/grpc/runtime/supports/RequestScopeHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package io.quarkus.grpc.runtime.supports;\n+\n+import io.grpc.ForwardingServerCall;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.Status;\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.ManagedContext;\n+\n+public class RequestScopeHandlerInterceptor implements ServerInterceptor {\n+\n+    private final ManagedContext reqContext;\n+\n+    public RequestScopeHandlerInterceptor() {\n+        reqContext = Arc.container().requestContext();\n+    }\n+\n+    @Override\n+    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(ServerCall<ReqT, RespT> call,\n+            Metadata headers,\n+            ServerCallHandler<ReqT, RespT> next) {\n+\n+        boolean managed = !reqContext.isActive();\n+        if (managed) {\n+            reqContext.activate();\n+        }\n+\n+        return next.startCall(new ForwardingServerCall.SimpleForwardingServerCall<ReqT, RespT>(call) {\n+            @Override\n+            public void close(Status status, Metadata trailers) {\n+                super.close(status, trailers);\n+                if (managed) {\n+                    reqContext.deactivate();", "originalCommit": "366d0c55b98231de7c7f52d2696b503a23618988", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMjQzMw==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r528622433", "bodyText": "It could be the case if the method is annotated with @Blocking or if the implementation calls \"onComplete\" or \"onError\" from another thread.", "author": "cescoffier", "createdAt": "2020-11-23T11:03:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYzMTE0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r528631147", "bodyText": "Well, I don't have enough knowledge about gRPC and its interceptors but deactivate() should be always called on the same thread (to cleanup the thread locals) and we should also call destroy() to destroy the beans correctly when the request processing is over. In reactive routes we capture the state and add an end handler: https://github.com/quarkusio/quarkus/blob/master/extensions/vertx-web/runtime/src/main/java/io/quarkus/vertx/web/runtime/RouteHandler.java#L46-L52", "author": "mkouba", "createdAt": "2020-11-23T11:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcxODg3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r528718879", "bodyText": "Hum... that is a bit tricky, I need another approach as we cannot guarantee this.\nEven if I capture the context, that context may be used by another invocation, which may even complete before the first call (and so destroy the beans created for the first call).\nThere is no \"routing context\" in gRPC which makes things a bit more tricky.\nI'm wondering how you handle the context reuse in reactive routes?", "author": "cescoffier", "createdAt": "2020-11-23T13:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc0OTMxNA==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r528749314", "bodyText": "I'm wondering how you handle the context reuse in reactive routes?\n\nWhat exactly do you mean? In any case, the question should be \"how do we handle the context reuse...\" ;-)", "author": "mkouba", "createdAt": "2020-11-23T14:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4MTc3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r528781771", "bodyText": "If I understand correctly, the request scope is thread dependant, which means that it stored in a thread-local attached to the thread \"activating\" it. As a consequence, deactivation should be done from the same thread, so clean up everything.\nEverything work when the thread is used to handle a single concurrent call.\nBut it may not be the case in the reactive world.\nFor example in the reactive routes, your method is called on the IO thread (event loop). That thread may be used to handle multiple concurrent requests. If one of these requests enables the request scope, what does it means for the other requests handled (concurrently) on the same event loop?  If two concurrent requests both enable the request scope, and one terminates before the other one, how can you be sure that it does not close the request scope of the other (still progressing) request?\nI just found a way to have something similar to the routing context in gRPC, but I need to be sure that we would not step on other's toes.", "author": "cescoffier", "createdAt": "2020-11-23T15:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI1MjAyMA==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r529252020", "bodyText": "If I understand correctly, the request scope is thread dependant, which means that it stored in a thread-local attached to the thread \"activating\" it.\n\nYes.\n\nBut it may not be the case in the reactive world.\n\nYes, that's why MP Context Propagation was created (although it does not cover all possible use cases).\n\nFor example in the reactive routes, your method is called on the IO thread (event loop). That thread may be used to handle multiple concurrent requests.\n\nThe request context is deactivated (thread local removed) right after a route method completes so it should not be a problem (a IO thread may not execute multiple route methods at the same time). If you do some async inside the route method MP CP makes a snapshot of the context before the async action is performed and this snapshot is propagated further.", "author": "mkouba", "createdAt": "2020-11-24T07:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzNDYyMw==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r529434623", "bodyText": "Ok, so it requires MP Context propagation in these cases, or you got things messed up.\nSo, I should be able to use the same machinery and restore the right (execution) context. I just need to store it and propagate it.", "author": "cescoffier", "createdAt": "2020-11-24T10:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ5NjYwMg==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r529496602", "bodyText": "Ok, so it requires MP Context propagation in these cases, or you got things messed up.\n\nYes, if you need the context to be propagated. In fact, you can leverage the ArC APIs directly but that's not something I would recommend ;-).\n\nSo, I should be able to use the same machinery...\n\nI think so.", "author": "mkouba", "createdAt": "2020-11-24T12:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1NzkwNw==", "url": "https://github.com/quarkusio/quarkus/pull/13411#discussion_r539457907", "bodyText": "I'm happy to say that I've found a simple solution -> Just capturing the context.", "author": "cescoffier", "createdAt": "2020-12-09T16:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUyOTk2OA=="}], "type": "inlineReview"}, {"oid": "d87deb29610b3473084e8b2f94c51a10ced98b35", "url": "https://github.com/quarkusio/quarkus/commit/d87deb29610b3473084e8b2f94c51a10ced98b35", "message": "Enable the RequestScope on gRPC service invocations", "committedDate": "2020-12-09T16:31:22Z", "type": "forcePushed"}, {"oid": "1b8190e2683e70b61904abfc58d9f7f3ea97ca33", "url": "https://github.com/quarkusio/quarkus/commit/1b8190e2683e70b61904abfc58d9f7f3ea97ca33", "message": "Enable the RequestScope on gRPC service invocations", "committedDate": "2021-01-04T18:48:43Z", "type": "commit"}, {"oid": "1b8190e2683e70b61904abfc58d9f7f3ea97ca33", "url": "https://github.com/quarkusio/quarkus/commit/1b8190e2683e70b61904abfc58d9f7f3ea97ca33", "message": "Enable the RequestScope on gRPC service invocations", "committedDate": "2021-01-04T18:48:43Z", "type": "forcePushed"}]}