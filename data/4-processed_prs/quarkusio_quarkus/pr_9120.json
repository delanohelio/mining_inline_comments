{"pr_number": 9120, "pr_title": "Move the gRPC support to the main Quarkus repository", "pr_createdAt": "2020-05-06T13:08:57Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9120", "timeline": [{"oid": "4c92e8416fffd56878f3737deb1d45a249e83e60", "url": "https://github.com/quarkusio/quarkus/commit/4c92e8416fffd56878f3737deb1d45a249e83e60", "message": "Add the gRPC support documentation\n\nCo-authored-by: Michal Szynkiewicz <michal.l.szynkiewicz@gmail.com>", "committedDate": "2020-05-06T13:11:24Z", "type": "forcePushed"}, {"oid": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "url": "https://github.com/quarkusio/quarkus/commit/9fa26b12cf318f23be1bccdf1466e0588c8b832e", "message": "Add the gRPC support documentation\n\nCo-authored-by: Michal Szynkiewicz <michal.l.szynkiewicz@gmail.com>", "committedDate": "2020-05-06T13:31:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg3ODQ2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420878463", "bodyText": "This one is not in the Vert.x bom we include?", "author": "gsmet", "createdAt": "2020-05-06T15:22:12Z", "path": "bom/runtime/pom.xml", "diffHunk": "@@ -2418,6 +2425,11 @@\n                 <artifactId>vertx-web-common</artifactId>\n                 <version>${vertx.version}</version>\n             </dependency>\n+            <dependency>\n+                <groupId>io.vertx</groupId>\n+                <artifactId>vertx-grpc</artifactId>\n+                <version>${vertx.version}</version>", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg5NzgyMA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420897820", "bodyText": "It is! Good point.", "author": "cescoffier", "createdAt": "2020-05-06T15:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg3ODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ4Nzc3OA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r421487778", "bodyText": "Fixed, I've also removed some other dependencies that should not have been there (for the same reason)", "author": "cescoffier", "createdAt": "2020-05-07T13:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg3ODQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg3OTIyOA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420879228", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            = Getting Started with Quarkus gRPC\n          \n          \n            \n            = Getting Started with gRPC", "author": "gsmet", "createdAt": "2020-05-06T15:23:19Z", "path": "docs/src/main/asciidoc/grpc-getting-started.adoc", "diffHunk": "@@ -0,0 +1,318 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Getting Started with Quarkus gRPC", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg3OTQwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420879405", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This page explains how to start using Quarkus gRPC.\n          \n          \n            \n            This page explains how to start using gRPC in your Quarkus application.", "author": "gsmet", "createdAt": "2020-05-06T15:23:34Z", "path": "docs/src/main/asciidoc/grpc-getting-started.adoc", "diffHunk": "@@ -0,0 +1,318 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Getting Started with Quarkus gRPC\n+\n+include::./attributes.adoc[]\n+\n+This page explains how to start using Quarkus gRPC.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MDA2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420880063", "bodyText": "This is annoying because you can't just add the extension.", "author": "gsmet", "createdAt": "2020-05-06T15:24:27Z", "path": "docs/src/main/asciidoc/grpc-getting-started.adoc", "diffHunk": "@@ -0,0 +1,318 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Getting Started with Quarkus gRPC\n+\n+include::./attributes.adoc[]\n+\n+This page explains how to start using Quarkus gRPC.\n+While this page describes how to configure it with Maven, it is also possible to use Gradle.\n+\n+Let's imagine you have a regular Quarkus project, generated from the https://code.quarkus.io[Quarkus project generator].\n+The default configuration is enough, but you can also select some extensions if you want.\n+\n+== Configuring your project\n+\n+Edit the `pom.xml` file to add the quarkus gRPC extension dependency and the JSR 305 (just under `<dependencies>`):\n+\n+[source, xml]\n+----\n+<dependency>\n+  <groupId>io.quarkus</groupId>\n+  <artifactId>quarkus-grpc</artifactId>\n+</dependency>\n+<dependency>\n+ <groupId>com.google.code.findbugs</groupId>\n+ <artifactId>jsr305</artifactId>\n+ <scope>provided</scope>", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ4ODM2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r421488363", "bodyText": "It's an ongoing discussion with @michalszynkiewicz . I hope that we would be able to remove it from there. Because I agree... should not be required.", "author": "cescoffier", "createdAt": "2020-05-07T13:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MDA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUxNTQ1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r421515452", "bodyText": "I agree that requiring users to add a dependency is not the way to go.\nLet's drop the ban for jsr305 (at least for now)", "author": "michalszynkiewicz", "createdAt": "2020-05-07T13:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MDA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUyMzAwNw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r422523007", "bodyText": "Fixed.", "author": "cescoffier", "createdAt": "2020-05-09T17:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MDA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MTA5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420881092", "bodyText": "Looks like they should be callouts? At least that's what I suppose from how the sentences are worded?", "author": "gsmet", "createdAt": "2020-05-06T15:25:46Z", "path": "docs/src/main/asciidoc/grpc-getting-started.adoc", "diffHunk": "@@ -0,0 +1,318 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Getting Started with Quarkus gRPC\n+\n+include::./attributes.adoc[]\n+\n+This page explains how to start using Quarkus gRPC.\n+While this page describes how to configure it with Maven, it is also possible to use Gradle.\n+\n+Let's imagine you have a regular Quarkus project, generated from the https://code.quarkus.io[Quarkus project generator].\n+The default configuration is enough, but you can also select some extensions if you want.\n+\n+== Configuring your project\n+\n+Edit the `pom.xml` file to add the quarkus gRPC extension dependency and the JSR 305 (just under `<dependencies>`):\n+\n+[source, xml]\n+----\n+<dependency>\n+  <groupId>io.quarkus</groupId>\n+  <artifactId>quarkus-grpc</artifactId>\n+</dependency>\n+<dependency>\n+ <groupId>com.google.code.findbugs</groupId>\n+ <artifactId>jsr305</artifactId>\n+ <scope>provided</scope>\n+</dependency>\n+----\n+\n+NOTE: The jsr305 is only used to compile the generated classes. It is not required at runtime.\n+\n+In the `<properties>` section, define the 2 following properties:\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<grpc.version>{grpc-version}</grpc.version>\n+<protoc.version>{protoc-version}</protoc.version>\n+----\n+\n+They configure the gRPC version and the `protoc` version.\n+\n+Finally, add to the `build` section the `os-maven-plugin` extension and the `protobuf-maven-plugin` configuration.\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<build>\n+    <extensions>\n+        <extension>\n+            <groupId>kr.motd.maven</groupId>\n+            <artifactId>os-maven-plugin</artifactId>\n+            <version>{os-maven-plugin-version}</version>\n+        </extension>\n+    </extensions>\n+\n+    <plugins>\n+        <plugin>\n+            <groupId>org.xolstice.maven.plugins</groupId>\n+            <artifactId>protobuf-maven-plugin</artifactId>\n+            <version>{protobuf-maven-plugin-version}</version>\n+            <configuration>\n+                <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>\n+                <pluginId>grpc-java</pluginId>\n+                <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>\n+                <protocPlugins>\n+                    <protocPlugin>\n+                        <id>quarkus-grpc-protoc-plugin</id>\n+                        <groupId>io.quarkus</groupId>\n+                        <artifactId>quarkus-grpc-protoc-plugin</artifactId>\n+                        <version>999-SNAPSHOT</version>\n+                        <mainClass>io.quarkus.grpc.protoc.plugin.MutinyGrpcGenerator</mainClass>\n+                    </protocPlugin>\n+                </protocPlugins>\n+            </configuration>\n+            <executions>\n+                <execution>\n+                    <id>compile</id>\n+                    <goals>\n+                        <goal>compile</goal>\n+                        <goal>compile-custom</goal>\n+                    </goals>\n+                </execution>\n+                <execution>\n+                    <id>test-compile</id>\n+                    <goals>\n+                        <goal>test-compile</goal>\n+                        <goal>test-compile-custom</goal>\n+                    </goals>\n+                </execution>\n+            </executions>\n+        </plugin>\n+\n+        <!-- ... -->\n+    </plugins>\n+</build>\n+----\n+\n+The `protobuf-maven-plugin` that generates stub classes from your gRPC service definition (`proto` files).\n+The class generation uses a tool named `protoc`, which is OS-specific.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5OTAxMg==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r421499012", "bodyText": "Fixed.", "author": "cescoffier", "createdAt": "2020-05-07T13:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MjAwMA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420882000", "bodyText": "How does it work with hot reload?", "author": "gsmet", "createdAt": "2020-05-06T15:26:58Z", "path": "docs/src/main/asciidoc/grpc-getting-started.adoc", "diffHunk": "@@ -0,0 +1,318 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Getting Started with Quarkus gRPC\n+\n+include::./attributes.adoc[]\n+\n+This page explains how to start using Quarkus gRPC.\n+While this page describes how to configure it with Maven, it is also possible to use Gradle.\n+\n+Let's imagine you have a regular Quarkus project, generated from the https://code.quarkus.io[Quarkus project generator].\n+The default configuration is enough, but you can also select some extensions if you want.\n+\n+== Configuring your project\n+\n+Edit the `pom.xml` file to add the quarkus gRPC extension dependency and the JSR 305 (just under `<dependencies>`):\n+\n+[source, xml]\n+----\n+<dependency>\n+  <groupId>io.quarkus</groupId>\n+  <artifactId>quarkus-grpc</artifactId>\n+</dependency>\n+<dependency>\n+ <groupId>com.google.code.findbugs</groupId>\n+ <artifactId>jsr305</artifactId>\n+ <scope>provided</scope>\n+</dependency>\n+----\n+\n+NOTE: The jsr305 is only used to compile the generated classes. It is not required at runtime.\n+\n+In the `<properties>` section, define the 2 following properties:\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<grpc.version>{grpc-version}</grpc.version>\n+<protoc.version>{protoc-version}</protoc.version>\n+----\n+\n+They configure the gRPC version and the `protoc` version.\n+\n+Finally, add to the `build` section the `os-maven-plugin` extension and the `protobuf-maven-plugin` configuration.\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<build>\n+    <extensions>\n+        <extension>\n+            <groupId>kr.motd.maven</groupId>\n+            <artifactId>os-maven-plugin</artifactId>\n+            <version>{os-maven-plugin-version}</version>\n+        </extension>\n+    </extensions>\n+\n+    <plugins>\n+        <plugin>\n+            <groupId>org.xolstice.maven.plugins</groupId>\n+            <artifactId>protobuf-maven-plugin</artifactId>\n+            <version>{protobuf-maven-plugin-version}</version>\n+            <configuration>\n+                <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>\n+                <pluginId>grpc-java</pluginId>\n+                <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>\n+                <protocPlugins>\n+                    <protocPlugin>\n+                        <id>quarkus-grpc-protoc-plugin</id>\n+                        <groupId>io.quarkus</groupId>\n+                        <artifactId>quarkus-grpc-protoc-plugin</artifactId>\n+                        <version>999-SNAPSHOT</version>\n+                        <mainClass>io.quarkus.grpc.protoc.plugin.MutinyGrpcGenerator</mainClass>\n+                    </protocPlugin>\n+                </protocPlugins>\n+            </configuration>\n+            <executions>\n+                <execution>\n+                    <id>compile</id>\n+                    <goals>\n+                        <goal>compile</goal>\n+                        <goal>compile-custom</goal>\n+                    </goals>\n+                </execution>\n+                <execution>\n+                    <id>test-compile</id>\n+                    <goals>\n+                        <goal>test-compile</goal>\n+                        <goal>test-compile-custom</goal>\n+                    </goals>\n+                </execution>\n+            </executions>\n+        </plugin>\n+\n+        <!-- ... -->\n+    </plugins>\n+</build>\n+----\n+\n+The `protobuf-maven-plugin` that generates stub classes from your gRPC service definition (`proto` files).\n+The class generation uses a tool named `protoc`, which is OS-specific.\n+That's why we use the `os-maven-plugin` to target the executable compatible with the operating system.\n+\n+NOTE: This configuration instructs the `protobuf-maven-plugin` to generate the default gRPC classes and classes using Mutiny to fit with the Quarkus development experience.\n+\n+With this configuration, you can put your service and message definitions in the `src/main/proto` directory.\n+Let's start with a simple _Hello_ service.\n+Create the `src/main/proto/helloworld.proto` file with the following content:\n+\n+[source]\n+----\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"io.quarkus.example\";\n+option java_outer_classname = \"HelloWorldProto\";\n+\n+package helloworld;\n+\n+// The greeting service definition.\n+service Greeter {\n+    // Sends a greeting\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+\n+// The request message containing the user's name.\n+message HelloRequest {\n+    string name = 1;\n+}\n+\n+// The response message containing the greetings\n+message HelloReply {\n+    string message = 1;\n+}\n+----\n+\n+This `proto` file defines a simple service interface with a single method (`SayHello`), and the exchanged messages (`HelloRequest` containing the name and `HelloReply` containing the greeting message).\n+\n+Before coding, we need to generate the classes used to implement and consume gRPC services.\n+In a terminal, run:\n+\n+[source, bash]\n+----\n+$ mvn compile\n+----\n+\n+Once generated, you can look at the `target/generated-sources/protobuf` directory:\n+\n+[source, txt]\n+----\n+target/generated-sources/protobuf\n+\u251c\u2500\u2500 grpc-java\n+\u2502   \u2514\u2500\u2500 io\n+\u2502       \u2514\u2500\u2500 quarkus\n+\u2502           \u2514\u2500\u2500 example\n+\u2502               \u2514\u2500\u2500 GreeterGrpc.java\n+\u2514\u2500\u2500 java\n+    \u2514\u2500\u2500 io\n+        \u2514\u2500\u2500 quarkus\n+            \u2514\u2500\u2500 example\n+                \u251c\u2500\u2500 HelloReply.java\n+                \u251c\u2500\u2500 HelloReplyOrBuilder.java\n+                \u251c\u2500\u2500 HelloRequest.java\n+                \u251c\u2500\u2500 HelloRequestOrBuilder.java\n+                \u251c\u2500\u2500 HelloWorldProto.java\n+                \u2514\u2500\u2500 MutinyGreeterGrpc.java\n+----\n+\n+These are the classes we are going to use.\n+\n+IMPORTANT: Every time you update the `proto` files, you need to re-generate the classes (using `mvn compile`).", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg5ODY4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420898689", "bodyText": "It does not work yet, @michalszynkiewicz is looking into that. The issue is that your code depends on these classes, so it must be done before the compilation.", "author": "cescoffier", "createdAt": "2020-05-06T15:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MjAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MjQxNw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420882417", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            With Quarkus gRPC, implementing a service requires to _extend_ the generated service base implementation and exposes it as a `@Singleton` CDI bean.\n          \n          \n            \n            With Quarkus, implementing a service requires to _extend_ the generated service base implementation and expose it as a `@Singleton` CDI bean.", "author": "gsmet", "createdAt": "2020-05-06T15:27:34Z", "path": "docs/src/main/asciidoc/grpc-getting-started.adoc", "diffHunk": "@@ -0,0 +1,318 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Getting Started with Quarkus gRPC\n+\n+include::./attributes.adoc[]\n+\n+This page explains how to start using Quarkus gRPC.\n+While this page describes how to configure it with Maven, it is also possible to use Gradle.\n+\n+Let's imagine you have a regular Quarkus project, generated from the https://code.quarkus.io[Quarkus project generator].\n+The default configuration is enough, but you can also select some extensions if you want.\n+\n+== Configuring your project\n+\n+Edit the `pom.xml` file to add the quarkus gRPC extension dependency and the JSR 305 (just under `<dependencies>`):\n+\n+[source, xml]\n+----\n+<dependency>\n+  <groupId>io.quarkus</groupId>\n+  <artifactId>quarkus-grpc</artifactId>\n+</dependency>\n+<dependency>\n+ <groupId>com.google.code.findbugs</groupId>\n+ <artifactId>jsr305</artifactId>\n+ <scope>provided</scope>\n+</dependency>\n+----\n+\n+NOTE: The jsr305 is only used to compile the generated classes. It is not required at runtime.\n+\n+In the `<properties>` section, define the 2 following properties:\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<grpc.version>{grpc-version}</grpc.version>\n+<protoc.version>{protoc-version}</protoc.version>\n+----\n+\n+They configure the gRPC version and the `protoc` version.\n+\n+Finally, add to the `build` section the `os-maven-plugin` extension and the `protobuf-maven-plugin` configuration.\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<build>\n+    <extensions>\n+        <extension>\n+            <groupId>kr.motd.maven</groupId>\n+            <artifactId>os-maven-plugin</artifactId>\n+            <version>{os-maven-plugin-version}</version>\n+        </extension>\n+    </extensions>\n+\n+    <plugins>\n+        <plugin>\n+            <groupId>org.xolstice.maven.plugins</groupId>\n+            <artifactId>protobuf-maven-plugin</artifactId>\n+            <version>{protobuf-maven-plugin-version}</version>\n+            <configuration>\n+                <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>\n+                <pluginId>grpc-java</pluginId>\n+                <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>\n+                <protocPlugins>\n+                    <protocPlugin>\n+                        <id>quarkus-grpc-protoc-plugin</id>\n+                        <groupId>io.quarkus</groupId>\n+                        <artifactId>quarkus-grpc-protoc-plugin</artifactId>\n+                        <version>999-SNAPSHOT</version>\n+                        <mainClass>io.quarkus.grpc.protoc.plugin.MutinyGrpcGenerator</mainClass>\n+                    </protocPlugin>\n+                </protocPlugins>\n+            </configuration>\n+            <executions>\n+                <execution>\n+                    <id>compile</id>\n+                    <goals>\n+                        <goal>compile</goal>\n+                        <goal>compile-custom</goal>\n+                    </goals>\n+                </execution>\n+                <execution>\n+                    <id>test-compile</id>\n+                    <goals>\n+                        <goal>test-compile</goal>\n+                        <goal>test-compile-custom</goal>\n+                    </goals>\n+                </execution>\n+            </executions>\n+        </plugin>\n+\n+        <!-- ... -->\n+    </plugins>\n+</build>\n+----\n+\n+The `protobuf-maven-plugin` that generates stub classes from your gRPC service definition (`proto` files).\n+The class generation uses a tool named `protoc`, which is OS-specific.\n+That's why we use the `os-maven-plugin` to target the executable compatible with the operating system.\n+\n+NOTE: This configuration instructs the `protobuf-maven-plugin` to generate the default gRPC classes and classes using Mutiny to fit with the Quarkus development experience.\n+\n+With this configuration, you can put your service and message definitions in the `src/main/proto` directory.\n+Let's start with a simple _Hello_ service.\n+Create the `src/main/proto/helloworld.proto` file with the following content:\n+\n+[source]\n+----\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"io.quarkus.example\";\n+option java_outer_classname = \"HelloWorldProto\";\n+\n+package helloworld;\n+\n+// The greeting service definition.\n+service Greeter {\n+    // Sends a greeting\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+\n+// The request message containing the user's name.\n+message HelloRequest {\n+    string name = 1;\n+}\n+\n+// The response message containing the greetings\n+message HelloReply {\n+    string message = 1;\n+}\n+----\n+\n+This `proto` file defines a simple service interface with a single method (`SayHello`), and the exchanged messages (`HelloRequest` containing the name and `HelloReply` containing the greeting message).\n+\n+Before coding, we need to generate the classes used to implement and consume gRPC services.\n+In a terminal, run:\n+\n+[source, bash]\n+----\n+$ mvn compile\n+----\n+\n+Once generated, you can look at the `target/generated-sources/protobuf` directory:\n+\n+[source, txt]\n+----\n+target/generated-sources/protobuf\n+\u251c\u2500\u2500 grpc-java\n+\u2502   \u2514\u2500\u2500 io\n+\u2502       \u2514\u2500\u2500 quarkus\n+\u2502           \u2514\u2500\u2500 example\n+\u2502               \u2514\u2500\u2500 GreeterGrpc.java\n+\u2514\u2500\u2500 java\n+    \u2514\u2500\u2500 io\n+        \u2514\u2500\u2500 quarkus\n+            \u2514\u2500\u2500 example\n+                \u251c\u2500\u2500 HelloReply.java\n+                \u251c\u2500\u2500 HelloReplyOrBuilder.java\n+                \u251c\u2500\u2500 HelloRequest.java\n+                \u251c\u2500\u2500 HelloRequestOrBuilder.java\n+                \u251c\u2500\u2500 HelloWorldProto.java\n+                \u2514\u2500\u2500 MutinyGreeterGrpc.java\n+----\n+\n+These are the classes we are going to use.\n+\n+IMPORTANT: Every time you update the `proto` files, you need to re-generate the classes (using `mvn compile`).\n+\n+== Implementing a gRPC service\n+\n+Now that we have the generated classes let's implement our _hello_ service.\n+\n+With Quarkus gRPC, implementing a service requires to _extend_ the generated service base implementation and exposes it as a `@Singleton` CDI bean.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MzExOA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420883118", "bodyText": "maybe add what Mutiny is in 3 words?", "author": "gsmet", "createdAt": "2020-05-06T15:28:28Z", "path": "docs/src/main/asciidoc/grpc-getting-started.adoc", "diffHunk": "@@ -0,0 +1,318 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Getting Started with Quarkus gRPC\n+\n+include::./attributes.adoc[]\n+\n+This page explains how to start using Quarkus gRPC.\n+While this page describes how to configure it with Maven, it is also possible to use Gradle.\n+\n+Let's imagine you have a regular Quarkus project, generated from the https://code.quarkus.io[Quarkus project generator].\n+The default configuration is enough, but you can also select some extensions if you want.\n+\n+== Configuring your project\n+\n+Edit the `pom.xml` file to add the quarkus gRPC extension dependency and the JSR 305 (just under `<dependencies>`):\n+\n+[source, xml]\n+----\n+<dependency>\n+  <groupId>io.quarkus</groupId>\n+  <artifactId>quarkus-grpc</artifactId>\n+</dependency>\n+<dependency>\n+ <groupId>com.google.code.findbugs</groupId>\n+ <artifactId>jsr305</artifactId>\n+ <scope>provided</scope>\n+</dependency>\n+----\n+\n+NOTE: The jsr305 is only used to compile the generated classes. It is not required at runtime.\n+\n+In the `<properties>` section, define the 2 following properties:\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<grpc.version>{grpc-version}</grpc.version>\n+<protoc.version>{protoc-version}</protoc.version>\n+----\n+\n+They configure the gRPC version and the `protoc` version.\n+\n+Finally, add to the `build` section the `os-maven-plugin` extension and the `protobuf-maven-plugin` configuration.\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<build>\n+    <extensions>\n+        <extension>\n+            <groupId>kr.motd.maven</groupId>\n+            <artifactId>os-maven-plugin</artifactId>\n+            <version>{os-maven-plugin-version}</version>\n+        </extension>\n+    </extensions>\n+\n+    <plugins>\n+        <plugin>\n+            <groupId>org.xolstice.maven.plugins</groupId>\n+            <artifactId>protobuf-maven-plugin</artifactId>\n+            <version>{protobuf-maven-plugin-version}</version>\n+            <configuration>\n+                <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>\n+                <pluginId>grpc-java</pluginId>\n+                <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>\n+                <protocPlugins>\n+                    <protocPlugin>\n+                        <id>quarkus-grpc-protoc-plugin</id>\n+                        <groupId>io.quarkus</groupId>\n+                        <artifactId>quarkus-grpc-protoc-plugin</artifactId>\n+                        <version>999-SNAPSHOT</version>\n+                        <mainClass>io.quarkus.grpc.protoc.plugin.MutinyGrpcGenerator</mainClass>\n+                    </protocPlugin>\n+                </protocPlugins>\n+            </configuration>\n+            <executions>\n+                <execution>\n+                    <id>compile</id>\n+                    <goals>\n+                        <goal>compile</goal>\n+                        <goal>compile-custom</goal>\n+                    </goals>\n+                </execution>\n+                <execution>\n+                    <id>test-compile</id>\n+                    <goals>\n+                        <goal>test-compile</goal>\n+                        <goal>test-compile-custom</goal>\n+                    </goals>\n+                </execution>\n+            </executions>\n+        </plugin>\n+\n+        <!-- ... -->\n+    </plugins>\n+</build>\n+----\n+\n+The `protobuf-maven-plugin` that generates stub classes from your gRPC service definition (`proto` files).\n+The class generation uses a tool named `protoc`, which is OS-specific.\n+That's why we use the `os-maven-plugin` to target the executable compatible with the operating system.\n+\n+NOTE: This configuration instructs the `protobuf-maven-plugin` to generate the default gRPC classes and classes using Mutiny to fit with the Quarkus development experience.\n+\n+With this configuration, you can put your service and message definitions in the `src/main/proto` directory.\n+Let's start with a simple _Hello_ service.\n+Create the `src/main/proto/helloworld.proto` file with the following content:\n+\n+[source]\n+----\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"io.quarkus.example\";\n+option java_outer_classname = \"HelloWorldProto\";\n+\n+package helloworld;\n+\n+// The greeting service definition.\n+service Greeter {\n+    // Sends a greeting\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+\n+// The request message containing the user's name.\n+message HelloRequest {\n+    string name = 1;\n+}\n+\n+// The response message containing the greetings\n+message HelloReply {\n+    string message = 1;\n+}\n+----\n+\n+This `proto` file defines a simple service interface with a single method (`SayHello`), and the exchanged messages (`HelloRequest` containing the name and `HelloReply` containing the greeting message).\n+\n+Before coding, we need to generate the classes used to implement and consume gRPC services.\n+In a terminal, run:\n+\n+[source, bash]\n+----\n+$ mvn compile\n+----\n+\n+Once generated, you can look at the `target/generated-sources/protobuf` directory:\n+\n+[source, txt]\n+----\n+target/generated-sources/protobuf\n+\u251c\u2500\u2500 grpc-java\n+\u2502   \u2514\u2500\u2500 io\n+\u2502       \u2514\u2500\u2500 quarkus\n+\u2502           \u2514\u2500\u2500 example\n+\u2502               \u2514\u2500\u2500 GreeterGrpc.java\n+\u2514\u2500\u2500 java\n+    \u2514\u2500\u2500 io\n+        \u2514\u2500\u2500 quarkus\n+            \u2514\u2500\u2500 example\n+                \u251c\u2500\u2500 HelloReply.java\n+                \u251c\u2500\u2500 HelloReplyOrBuilder.java\n+                \u251c\u2500\u2500 HelloRequest.java\n+                \u251c\u2500\u2500 HelloRequestOrBuilder.java\n+                \u251c\u2500\u2500 HelloWorldProto.java\n+                \u2514\u2500\u2500 MutinyGreeterGrpc.java\n+----\n+\n+These are the classes we are going to use.\n+\n+IMPORTANT: Every time you update the `proto` files, you need to re-generate the classes (using `mvn compile`).\n+\n+== Implementing a gRPC service\n+\n+Now that we have the generated classes let's implement our _hello_ service.\n+\n+With Quarkus gRPC, implementing a service requires to _extend_ the generated service base implementation and exposes it as a `@Singleton` CDI bean.\n+\n+IMPORTANT: Don't use `@ApplicationScoped` as the gRPC service implementation cannot be proxied.\n+\n+=== Implementing a service\n+\n+Create the `src/main/java/org/acme/HelloService.java` file with the following content:\n+\n+[source, java]\n+----\n+package org.acme;\n+\n+import io.grpc.stub.StreamObserver;\n+import io.quarkus.example.GreeterGrpc;\n+import io.quarkus.example.HelloReply;\n+import io.quarkus.example.HelloRequest;\n+\n+import javax.inject.Singleton;\n+\n+@Singleton                                                                                    // <1>\n+public class HelloService extends GreeterGrpc.GreeterImplBase {                               // <2>\n+\n+    @Override\n+    public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) { // <3>\n+        String name = request.getName();\n+        String message = \"Hello \" + name;\n+        responseObserver.onNext(HelloReply.newBuilder().setMessage(message).build());         // <4>\n+        responseObserver.onCompleted();                                                       // <5>\n+    }\n+}\n+\n+----\n+1. Expose your implementation as bean\n+2. Extends the `ImplBase` class. This is a generated class.\n+3. Implement the methods defined in the service definition (here we have a single method)\n+4. Build and send the response\n+5. Close the response\n+\n+Quarkus also provides an additional model with Mutiny.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5OTMxNA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r421499314", "bodyText": "Fixed. I also linked the getting-started-with-reactive guide.", "author": "cescoffier", "createdAt": "2020-05-07T13:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4MzExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4NDIxNg==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420884216", "bodyText": "How is this property mapped? If it's some magic Quarkus config, I would prefer we have some proper quarkus. config.", "author": "gsmet", "createdAt": "2020-05-06T15:29:55Z", "path": "docs/src/main/asciidoc/grpc-getting-started.adoc", "diffHunk": "@@ -0,0 +1,318 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Getting Started with Quarkus gRPC\n+\n+include::./attributes.adoc[]\n+\n+This page explains how to start using Quarkus gRPC.\n+While this page describes how to configure it with Maven, it is also possible to use Gradle.\n+\n+Let's imagine you have a regular Quarkus project, generated from the https://code.quarkus.io[Quarkus project generator].\n+The default configuration is enough, but you can also select some extensions if you want.\n+\n+== Configuring your project\n+\n+Edit the `pom.xml` file to add the quarkus gRPC extension dependency and the JSR 305 (just under `<dependencies>`):\n+\n+[source, xml]\n+----\n+<dependency>\n+  <groupId>io.quarkus</groupId>\n+  <artifactId>quarkus-grpc</artifactId>\n+</dependency>\n+<dependency>\n+ <groupId>com.google.code.findbugs</groupId>\n+ <artifactId>jsr305</artifactId>\n+ <scope>provided</scope>\n+</dependency>\n+----\n+\n+NOTE: The jsr305 is only used to compile the generated classes. It is not required at runtime.\n+\n+In the `<properties>` section, define the 2 following properties:\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<grpc.version>{grpc-version}</grpc.version>\n+<protoc.version>{protoc-version}</protoc.version>\n+----\n+\n+They configure the gRPC version and the `protoc` version.\n+\n+Finally, add to the `build` section the `os-maven-plugin` extension and the `protobuf-maven-plugin` configuration.\n+\n+[source, xml, subs=\"verbatim,attributes\"]\n+----\n+<build>\n+    <extensions>\n+        <extension>\n+            <groupId>kr.motd.maven</groupId>\n+            <artifactId>os-maven-plugin</artifactId>\n+            <version>{os-maven-plugin-version}</version>\n+        </extension>\n+    </extensions>\n+\n+    <plugins>\n+        <plugin>\n+            <groupId>org.xolstice.maven.plugins</groupId>\n+            <artifactId>protobuf-maven-plugin</artifactId>\n+            <version>{protobuf-maven-plugin-version}</version>\n+            <configuration>\n+                <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>\n+                <pluginId>grpc-java</pluginId>\n+                <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>\n+                <protocPlugins>\n+                    <protocPlugin>\n+                        <id>quarkus-grpc-protoc-plugin</id>\n+                        <groupId>io.quarkus</groupId>\n+                        <artifactId>quarkus-grpc-protoc-plugin</artifactId>\n+                        <version>999-SNAPSHOT</version>\n+                        <mainClass>io.quarkus.grpc.protoc.plugin.MutinyGrpcGenerator</mainClass>\n+                    </protocPlugin>\n+                </protocPlugins>\n+            </configuration>\n+            <executions>\n+                <execution>\n+                    <id>compile</id>\n+                    <goals>\n+                        <goal>compile</goal>\n+                        <goal>compile-custom</goal>\n+                    </goals>\n+                </execution>\n+                <execution>\n+                    <id>test-compile</id>\n+                    <goals>\n+                        <goal>test-compile</goal>\n+                        <goal>test-compile-custom</goal>\n+                    </goals>\n+                </execution>\n+            </executions>\n+        </plugin>\n+\n+        <!-- ... -->\n+    </plugins>\n+</build>\n+----\n+\n+The `protobuf-maven-plugin` that generates stub classes from your gRPC service definition (`proto` files).\n+The class generation uses a tool named `protoc`, which is OS-specific.\n+That's why we use the `os-maven-plugin` to target the executable compatible with the operating system.\n+\n+NOTE: This configuration instructs the `protobuf-maven-plugin` to generate the default gRPC classes and classes using Mutiny to fit with the Quarkus development experience.\n+\n+With this configuration, you can put your service and message definitions in the `src/main/proto` directory.\n+Let's start with a simple _Hello_ service.\n+Create the `src/main/proto/helloworld.proto` file with the following content:\n+\n+[source]\n+----\n+syntax = \"proto3\";\n+\n+option java_multiple_files = true;\n+option java_package = \"io.quarkus.example\";\n+option java_outer_classname = \"HelloWorldProto\";\n+\n+package helloworld;\n+\n+// The greeting service definition.\n+service Greeter {\n+    // Sends a greeting\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+\n+// The request message containing the user's name.\n+message HelloRequest {\n+    string name = 1;\n+}\n+\n+// The response message containing the greetings\n+message HelloReply {\n+    string message = 1;\n+}\n+----\n+\n+This `proto` file defines a simple service interface with a single method (`SayHello`), and the exchanged messages (`HelloRequest` containing the name and `HelloReply` containing the greeting message).\n+\n+Before coding, we need to generate the classes used to implement and consume gRPC services.\n+In a terminal, run:\n+\n+[source, bash]\n+----\n+$ mvn compile\n+----\n+\n+Once generated, you can look at the `target/generated-sources/protobuf` directory:\n+\n+[source, txt]\n+----\n+target/generated-sources/protobuf\n+\u251c\u2500\u2500 grpc-java\n+\u2502   \u2514\u2500\u2500 io\n+\u2502       \u2514\u2500\u2500 quarkus\n+\u2502           \u2514\u2500\u2500 example\n+\u2502               \u2514\u2500\u2500 GreeterGrpc.java\n+\u2514\u2500\u2500 java\n+    \u2514\u2500\u2500 io\n+        \u2514\u2500\u2500 quarkus\n+            \u2514\u2500\u2500 example\n+                \u251c\u2500\u2500 HelloReply.java\n+                \u251c\u2500\u2500 HelloReplyOrBuilder.java\n+                \u251c\u2500\u2500 HelloRequest.java\n+                \u251c\u2500\u2500 HelloRequestOrBuilder.java\n+                \u251c\u2500\u2500 HelloWorldProto.java\n+                \u2514\u2500\u2500 MutinyGreeterGrpc.java\n+----\n+\n+These are the classes we are going to use.\n+\n+IMPORTANT: Every time you update the `proto` files, you need to re-generate the classes (using `mvn compile`).\n+\n+== Implementing a gRPC service\n+\n+Now that we have the generated classes let's implement our _hello_ service.\n+\n+With Quarkus gRPC, implementing a service requires to _extend_ the generated service base implementation and exposes it as a `@Singleton` CDI bean.\n+\n+IMPORTANT: Don't use `@ApplicationScoped` as the gRPC service implementation cannot be proxied.\n+\n+=== Implementing a service\n+\n+Create the `src/main/java/org/acme/HelloService.java` file with the following content:\n+\n+[source, java]\n+----\n+package org.acme;\n+\n+import io.grpc.stub.StreamObserver;\n+import io.quarkus.example.GreeterGrpc;\n+import io.quarkus.example.HelloReply;\n+import io.quarkus.example.HelloRequest;\n+\n+import javax.inject.Singleton;\n+\n+@Singleton                                                                                    // <1>\n+public class HelloService extends GreeterGrpc.GreeterImplBase {                               // <2>\n+\n+    @Override\n+    public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) { // <3>\n+        String name = request.getName();\n+        String message = \"Hello \" + name;\n+        responseObserver.onNext(HelloReply.newBuilder().setMessage(message).build());         // <4>\n+        responseObserver.onCompleted();                                                       // <5>\n+    }\n+}\n+\n+----\n+1. Expose your implementation as bean\n+2. Extends the `ImplBase` class. This is a generated class.\n+3. Implement the methods defined in the service definition (here we have a single method)\n+4. Build and send the response\n+5. Close the response\n+\n+Quarkus also provides an additional model with Mutiny.\n+A Mutiny implementation of this service would be:\n+\n+[source, java]\n+----\n+package org.acme;\n+\n+import io.quarkus.example.HelloReply;\n+import io.quarkus.example.HelloRequest;\n+import io.quarkus.example.MutinyGreeterGrpc;\n+import io.smallrye.mutiny.Uni;\n+\n+import javax.inject.Singleton;\n+\n+@Singleton\n+public class ReactiveHelloService extends MutinyGreeterGrpc.GreeterImplBase {\n+\n+    @Override\n+    public Uni<HelloReply> sayHello(HelloRequest request) {\n+        return Uni.createFrom().item(() ->\n+                HelloReply.newBuilder().setMessage(\"Hello \" + request.getName()).build()\n+        );\n+    }\n+}\n+----\n+\n+The main differences are the following:\n+\n+* it extends the `ImplBase` from `MutinyGreeterGrpc` instead of `GreeterGrpc`\n+* the signature of the method is using Mutiny types\n+\n+=== The gRPC server\n+\n+The services are _served_ by a _server_.\n+Available services (_CDI beans_) are automatically registered and exposed.\n+\n+By default, the server is exposed on `localhost:9000`, and uses _plain-text_ (so no TLS).\n+\n+Run the application using: `mvn quarkus:dev`.\n+\n+== Consuming a gRPC service\n+\n+In this section, we are going to consume the service we expose.\n+To simplify, we are going to consume the service from the same application, which in the real world, does not make sense.\n+\n+Open the existing `org.acme.ExampleResource` class, and edit the content to become:\n+\n+[source, java]\n+----\n+package org.acme;\n+\n+import io.quarkus.example.GreeterGrpc;\n+import io.quarkus.example.HelloRequest;\n+import io.quarkus.grpc.runtime.annotations.GrpcService;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/hello\")\n+public class ExampleResource {\n+\n+    @Inject\n+    @GrpcService(\"hello\")                     // <1>\n+    GreeterGrpc.GreeterBlockingStub client;   // <2>\n+\n+    @GET\n+    @Produces(MediaType.TEXT_PLAIN)\n+    public String hello() {\n+        return \"hello\";\n+    }\n+\n+    @GET\n+    @Path(\"/{name}\")\n+    public String hello(@PathParam(\"name\") String name) {\n+        return client.sayHello(HelloRequest.newBuilder().setName(name).build()).getMessage();  // <3>\n+    }\n+}\n+----\n+1. Inject the service and configure its name. This name is used in the application configuration\n+2. Use the _blocking_ stub (also a generated class)\n+3. Invoke the service\n+\n+We need to configure the application to indicate where is the `hello` service.\n+In the `src/main/resources/application.properties` file, add the following property:\n+\n+[source, text]\n+----\n+hello.host=localhost", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg5OTczMw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420899733", "bodyText": "I will have a look tomorrow. When I tried it was not working because it was all made at runtime. But we revisited that, so should work now.", "author": "cescoffier", "createdAt": "2020-05-06T15:50:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4NDIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ4ODgyNA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r421488824", "bodyText": "Done.", "author": "cescoffier", "createdAt": "2020-05-07T13:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4NDIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4NTQ3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420885477", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * mutiny stubs\n          \n          \n            \n            * reactive stubs based on Mutiny", "author": "gsmet", "createdAt": "2020-05-06T15:31:24Z", "path": "docs/src/main/asciidoc/grpc-service-consumption.adoc", "diffHunk": "@@ -0,0 +1,208 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Consuming a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC services can be injected in your application code.\n+\n+IMPORTANT: Consuming gRPC services requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Stubs and Injection\n+\n+gRPC generation provides several stubs, providing different way to consume a service.\n+Quarkus gRPC can inject:\n+\n+* blocking stubs\n+* mutiny stubs", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4NTc5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420885792", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In addition, it also can inject the gRPC `io.grpc.Channel`, that let you create other types of stubs.\n          \n          \n            \n            In addition, it also can inject the gRPC `io.grpc.Channel`, that lets you create other types of stubs.", "author": "gsmet", "createdAt": "2020-05-06T15:31:37Z", "path": "docs/src/main/asciidoc/grpc-service-consumption.adoc", "diffHunk": "@@ -0,0 +1,208 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Consuming a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC services can be injected in your application code.\n+\n+IMPORTANT: Consuming gRPC services requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Stubs and Injection\n+\n+gRPC generation provides several stubs, providing different way to consume a service.\n+Quarkus gRPC can inject:\n+\n+* blocking stubs\n+* mutiny stubs\n+\n+In addition, it also can inject the gRPC `io.grpc.Channel`, that let you create other types of stubs.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4NTk5NA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420885994", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The stub class names is computed from the service name.\n          \n          \n            \n            The stub class names are computed from the service name.", "author": "gsmet", "createdAt": "2020-05-06T15:31:52Z", "path": "docs/src/main/asciidoc/grpc-service-consumption.adoc", "diffHunk": "@@ -0,0 +1,208 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Consuming a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC services can be injected in your application code.\n+\n+IMPORTANT: Consuming gRPC services requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Stubs and Injection\n+\n+gRPC generation provides several stubs, providing different way to consume a service.\n+Quarkus gRPC can inject:\n+\n+* blocking stubs\n+* mutiny stubs\n+\n+In addition, it also can inject the gRPC `io.grpc.Channel`, that let you create other types of stubs.\n+\n+[source, java]\n+----\n+@Inject @GrpcService(\"hello-service\")\n+MutinyGreeterGrpc.MutinyGreeterStub mutiny;\n+\n+@Inject @GrpcService(\"hello-service\")\n+GreeterGrpc.GreeterBlockingStub blocking;\n+\n+@Inject @GrpcService(\"hello-service\")\n+Channel channel;\n+----\n+\n+The stub class names is computed from the service name.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4Njg5OA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420886898", "bodyText": "OK, I have my answer and I don't like that. We should use proper Quarkus config. First it will avoid conflicting with other things, then it will be automatically documented.", "author": "gsmet", "createdAt": "2020-05-06T15:33:06Z", "path": "docs/src/main/asciidoc/grpc-service-consumption.adoc", "diffHunk": "@@ -0,0 +1,208 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Consuming a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC services can be injected in your application code.\n+\n+IMPORTANT: Consuming gRPC services requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Stubs and Injection\n+\n+gRPC generation provides several stubs, providing different way to consume a service.\n+Quarkus gRPC can inject:\n+\n+* blocking stubs\n+* mutiny stubs\n+\n+In addition, it also can inject the gRPC `io.grpc.Channel`, that let you create other types of stubs.\n+\n+[source, java]\n+----\n+@Inject @GrpcService(\"hello-service\")\n+MutinyGreeterGrpc.MutinyGreeterStub mutiny;\n+\n+@Inject @GrpcService(\"hello-service\")\n+GreeterGrpc.GreeterBlockingStub blocking;\n+\n+@Inject @GrpcService(\"hello-service\")\n+Channel channel;\n+----\n+\n+The stub class names is computed from the service name.\n+For example, if you use `Greeter` as service name as in:\n+\n+[source]\n+----\n+service Greeter {\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+----\n+\n+The Mutiny stub name is: `MutinyGreeterGrpc.MutinyGreeterStub`\n+The blocking stub name is: `GreeterGrpc.GreeterBlockingStub`\n+\n+Client injection must be qualified using `@GrpcService`.\n+This annotation indicates the configuration prefix used to configure the service.\n+For example, if you set it to `hello-service`, configuring the host of the service is done using `hello-service.host`.\n+\n+== Examples\n+\n+=== Using a blocking and mutiny stubs\n+\n+[source, java]\n+----\n+@Inject @GrpcService(\"hello\") GreeterGrpc.GreeterBlockingStub blockingHelloService;\n+@Inject @GrpcService(\"hello\") MutinyGreeterGrpc.MutinyGreeterStub mutinyHelloService;\n+\n+@GET\n+@Path(\"/blocking/{name}\")\n+public String helloBlocking(@PathParam(\"name\") String name) {\n+    return blockingHelloService.sayHello(HelloRequest.newBuilder().setName(name).build()).getMessage();\n+}\n+\n+@GET\n+@Path(\"/mutiny/{name}\")\n+public Uni<String> helloMutiny(@PathParam(\"name\") String name) {\n+    return mutinyHelloService.sayHello(HelloRequest.newBuilder().setName(name).build())\n+            .onItem().apply(HelloReply::getMessage);\n+}\n+----\n+\n+Note that in this example, the `hello.host` property must be set.\n+\n+=== Handling streams\n+\n+gRPC allows sending and receiving streams:\n+\n+[source]\n+----\n+service Streaming {\n+    rpc Source(Empty) returns (stream Item) {} // Returns a stream\n+    rpc Sink(stream Item) returns (Empty) {}   // Reads a stream\n+    rpc Pipe(stream Item) returns (stream Item) {}  // Reads a streams and return a streams\n+}\n+----\n+\n+Using the Mutiny stub, you can interact with these as follows:\n+\n+[source, java]\n+----\n+package io.quarkus.grpc.example.streaming;\n+\n+import io.grpc.examples.streaming.Empty;\n+import io.grpc.examples.streaming.Item;\n+import io.grpc.examples.streaming.MutinyStreamingGrpc;\n+import io.quarkus.grpc.runtime.annotations.GrpcService;\n+import io.smallrye.mutiny.Multi;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/streaming\")\n+@Produces(MediaType.APPLICATION_JSON)\n+public class StreamingEndpoint {\n+\n+    @Inject @GrpcService(\"streaming\") MutinyStreamingGrpc.MutinyStreamingStub client;\n+\n+    @GET\n+    public Multi<String> invokeSource() {\n+        // Retrieve a stream\n+        return client.source(Empty.newBuilder().build())\n+                .onItem().apply(Item::getValue);\n+    }\n+\n+    @GET\n+    @Path(\"sink/{max}\")\n+    public Uni<Void> invokeSink(@PathParam(\"max\") int max) {\n+        // Send a stream and wait for completion\n+        Multi<Item> inputs = Multi.createFrom().range(0, max)\n+                .map(i -> Integer.toString(i))\n+                .map(i -> Item.newBuilder().setValue(i).build());\n+        return client.sink(inputs).onItem().ignore().andContinueWithNull();\n+    }\n+\n+    @GET\n+    @Path(\"/{max}\")\n+    public Multi<String> invokePipe(@PathParam(\"max\") int max) {\n+        // Send a stream and retrieve a stream\n+        Multi<Item> inputs = Multi.createFrom().range(0, max)\n+                .map(i -> Integer.toString(i))\n+                .map(i -> Item.newBuilder().setValue(i).build());\n+        return client.pipe(inputs).onItem().apply(Item::getValue);\n+    }\n+\n+}\n+\n+----\n+\n+== Client configuration\n+\n+IMPORTANT: Client configuration is controlled with the `@GrpcService` annotation.\n+\n+For a given `$NAME` (value set in the `@GrpcService` annotation) , the following configuration properties are supported:", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ4OTAyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r421489021", "bodyText": "Fixed. It's now using a Map<String, GrpcClientConfiguration>", "author": "cescoffier", "createdAt": "2020-05-07T13:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4Njg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4NzE3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420887172", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            gRPC service implementations exposed as bean are automatically registered and served by quarkus-grpc.\n          \n          \n            \n            gRPC service implementations exposed as beans are automatically registered and served by quarkus-grpc.", "author": "gsmet", "createdAt": "2020-05-06T15:33:28Z", "path": "docs/src/main/asciidoc/grpc-service-implementation.adoc", "diffHunk": "@@ -0,0 +1,242 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Implementing a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC service implementations exposed as bean are automatically registered and served by quarkus-grpc.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4NzcwNg==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420887706", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then, overrides the methods defined in the service interface.\n          \n          \n            \n            Then, override the methods defined in the service interface.", "author": "gsmet", "createdAt": "2020-05-06T15:34:08Z", "path": "docs/src/main/asciidoc/grpc-service-implementation.adoc", "diffHunk": "@@ -0,0 +1,242 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Implementing a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC service implementations exposed as bean are automatically registered and served by quarkus-grpc.\n+\n+IMPORTANT: Implementing a gRPC service requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Implementation base\n+\n+The generation has created 2 implementation bases:\n+\n+1. One using the default gRPC API\n+2. One using the Mutiny API\n+\n+The first classname is structured as follows: `${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+The second classname is structured as follows: `Mutiny${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+\n+For example, if you use `Greeter` as service name as in:\n+\n+[source]\n+----\n+service Greeter {\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+----\n+\n+The regular implementation base is: `GreeterGrpc.GreeterImplBase`.\n+The second implementation base is: `MutinyGreeterGrpc.GreeterImplBase`.\n+\n+Note that these classes are not interfaces but regular classes.\n+When extending them, you need to override the service methods defined in the service definition.\n+\n+== Implementing a service with the default gRPC API\n+\n+To implement a gRPC service using the default gRPC API, create a class extending the default implementation base.\n+Then, overrides the methods defined in the service interface.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4NzgwMw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420887803", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Finally, exposes the service as a CDI bean using the `@Singleton` annotation:\n          \n          \n            \n            Finally, expose the service as a CDI bean using the `@Singleton` annotation:", "author": "gsmet", "createdAt": "2020-05-06T15:34:16Z", "path": "docs/src/main/asciidoc/grpc-service-implementation.adoc", "diffHunk": "@@ -0,0 +1,242 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Implementing a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC service implementations exposed as bean are automatically registered and served by quarkus-grpc.\n+\n+IMPORTANT: Implementing a gRPC service requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Implementation base\n+\n+The generation has created 2 implementation bases:\n+\n+1. One using the default gRPC API\n+2. One using the Mutiny API\n+\n+The first classname is structured as follows: `${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+The second classname is structured as follows: `Mutiny${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+\n+For example, if you use `Greeter` as service name as in:\n+\n+[source]\n+----\n+service Greeter {\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+----\n+\n+The regular implementation base is: `GreeterGrpc.GreeterImplBase`.\n+The second implementation base is: `MutinyGreeterGrpc.GreeterImplBase`.\n+\n+Note that these classes are not interfaces but regular classes.\n+When extending them, you need to override the service methods defined in the service definition.\n+\n+== Implementing a service with the default gRPC API\n+\n+To implement a gRPC service using the default gRPC API, create a class extending the default implementation base.\n+Then, overrides the methods defined in the service interface.\n+Finally, exposes the service as a CDI bean using the `@Singleton` annotation:", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4Nzk2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420887969", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then, overrides the methods defined in the service interface.\n          \n          \n            \n            Then, override the methods defined in the service interface.", "author": "gsmet", "createdAt": "2020-05-06T15:34:30Z", "path": "docs/src/main/asciidoc/grpc-service-implementation.adoc", "diffHunk": "@@ -0,0 +1,242 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Implementing a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC service implementations exposed as bean are automatically registered and served by quarkus-grpc.\n+\n+IMPORTANT: Implementing a gRPC service requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Implementation base\n+\n+The generation has created 2 implementation bases:\n+\n+1. One using the default gRPC API\n+2. One using the Mutiny API\n+\n+The first classname is structured as follows: `${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+The second classname is structured as follows: `Mutiny${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+\n+For example, if you use `Greeter` as service name as in:\n+\n+[source]\n+----\n+service Greeter {\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+----\n+\n+The regular implementation base is: `GreeterGrpc.GreeterImplBase`.\n+The second implementation base is: `MutinyGreeterGrpc.GreeterImplBase`.\n+\n+Note that these classes are not interfaces but regular classes.\n+When extending them, you need to override the service methods defined in the service definition.\n+\n+== Implementing a service with the default gRPC API\n+\n+To implement a gRPC service using the default gRPC API, create a class extending the default implementation base.\n+Then, overrides the methods defined in the service interface.\n+Finally, exposes the service as a CDI bean using the `@Singleton` annotation:\n+\n+[source, java]\n+----\n+import javax.inject.Singleton;\n+\n+@Singleton\n+public class HelloService extends GreeterGrpc.GreeterImplBase {\n+\n+    @Override\n+    public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {\n+        String name = request.getName();\n+        String message = \"Hello \" + name;\n+        responseObserver.onNext(HelloReply.newBuilder().setMessage(message).build());\n+        responseObserver.onCompleted();\n+    }\n+}\n+----\n+\n+== Implementing a service with the Mutiny API\n+\n+To implement a gRPC service using the Mutiny gRPC API, create a class extending the Mutiny implementation base.\n+Then, overrides the methods defined in the service interface.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4ODA5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420888095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Finally, exposes the service as a CDI bean using the `@Singleton` annotation:\n          \n          \n            \n            Finally, expose the service as a CDI bean using the `@Singleton` annotation:", "author": "gsmet", "createdAt": "2020-05-06T15:34:40Z", "path": "docs/src/main/asciidoc/grpc-service-implementation.adoc", "diffHunk": "@@ -0,0 +1,242 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Implementing a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC service implementations exposed as bean are automatically registered and served by quarkus-grpc.\n+\n+IMPORTANT: Implementing a gRPC service requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Implementation base\n+\n+The generation has created 2 implementation bases:\n+\n+1. One using the default gRPC API\n+2. One using the Mutiny API\n+\n+The first classname is structured as follows: `${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+The second classname is structured as follows: `Mutiny${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+\n+For example, if you use `Greeter` as service name as in:\n+\n+[source]\n+----\n+service Greeter {\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+----\n+\n+The regular implementation base is: `GreeterGrpc.GreeterImplBase`.\n+The second implementation base is: `MutinyGreeterGrpc.GreeterImplBase`.\n+\n+Note that these classes are not interfaces but regular classes.\n+When extending them, you need to override the service methods defined in the service definition.\n+\n+== Implementing a service with the default gRPC API\n+\n+To implement a gRPC service using the default gRPC API, create a class extending the default implementation base.\n+Then, overrides the methods defined in the service interface.\n+Finally, exposes the service as a CDI bean using the `@Singleton` annotation:\n+\n+[source, java]\n+----\n+import javax.inject.Singleton;\n+\n+@Singleton\n+public class HelloService extends GreeterGrpc.GreeterImplBase {\n+\n+    @Override\n+    public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {\n+        String name = request.getName();\n+        String message = \"Hello \" + name;\n+        responseObserver.onNext(HelloReply.newBuilder().setMessage(message).build());\n+        responseObserver.onCompleted();\n+    }\n+}\n+----\n+\n+== Implementing a service with the Mutiny API\n+\n+To implement a gRPC service using the Mutiny gRPC API, create a class extending the Mutiny implementation base.\n+Then, overrides the methods defined in the service interface.\n+These methods are using Mutiny types.\n+Finally, exposes the service as a CDI bean using the `@Singleton` annotation:", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4ODg2Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420888862", "bodyText": "This should use our automatic doc generation.", "author": "gsmet", "createdAt": "2020-05-06T15:35:44Z", "path": "docs/src/main/asciidoc/grpc-service-implementation.adoc", "diffHunk": "@@ -0,0 +1,242 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Implementing a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC service implementations exposed as bean are automatically registered and served by quarkus-grpc.\n+\n+IMPORTANT: Implementing a gRPC service requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Implementation base\n+\n+The generation has created 2 implementation bases:\n+\n+1. One using the default gRPC API\n+2. One using the Mutiny API\n+\n+The first classname is structured as follows: `${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+The second classname is structured as follows: `Mutiny${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase`.\n+\n+For example, if you use `Greeter` as service name as in:\n+\n+[source]\n+----\n+service Greeter {\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+----\n+\n+The regular implementation base is: `GreeterGrpc.GreeterImplBase`.\n+The second implementation base is: `MutinyGreeterGrpc.GreeterImplBase`.\n+\n+Note that these classes are not interfaces but regular classes.\n+When extending them, you need to override the service methods defined in the service definition.\n+\n+== Implementing a service with the default gRPC API\n+\n+To implement a gRPC service using the default gRPC API, create a class extending the default implementation base.\n+Then, overrides the methods defined in the service interface.\n+Finally, exposes the service as a CDI bean using the `@Singleton` annotation:\n+\n+[source, java]\n+----\n+import javax.inject.Singleton;\n+\n+@Singleton\n+public class HelloService extends GreeterGrpc.GreeterImplBase {\n+\n+    @Override\n+    public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {\n+        String name = request.getName();\n+        String message = \"Hello \" + name;\n+        responseObserver.onNext(HelloReply.newBuilder().setMessage(message).build());\n+        responseObserver.onCompleted();\n+    }\n+}\n+----\n+\n+== Implementing a service with the Mutiny API\n+\n+To implement a gRPC service using the Mutiny gRPC API, create a class extending the Mutiny implementation base.\n+Then, overrides the methods defined in the service interface.\n+These methods are using Mutiny types.\n+Finally, exposes the service as a CDI bean using the `@Singleton` annotation:\n+\n+[source, java]\n+----\n+import javax.inject.Singleton;\n+\n+@Singleton\n+public class ReactiveHelloService extends MutinyGreeterGrpc.GreeterImplBase {\n+\n+    @Override\n+    public Uni<HelloReply> sayHello(HelloRequest request) {\n+        return Uni.createFrom().item(() ->\n+                HelloReply.newBuilder().setMessage(\"Hello \" + request.getName()).build()\n+        );\n+    }\n+}\n+----\n+\n+== Handling streams\n+\n+gRPC allows receiving and returning streams:\n+\n+[source]\n+----\n+service Streaming {\n+    rpc Source(Empty) returns (stream Item) {} // Returns a stream\n+    rpc Sink(stream Item) returns (Empty) {}   // Reads a stream\n+    rpc Pipe(stream Item) returns (stream Item) {}  // Reads a streams and return a streams\n+}\n+----\n+\n+Using Mutiny, you can implement these as follows:\n+\n+[source, java]\n+----\n+@Singleton\n+public class StreamingService extends MutinyStreamingGrpc.StreamingImplBase {\n+\n+    @Override\n+    public Multi<Item> source(Empty request) {\n+        // Just returns a stream emitting an item every 2ms and stopping after 10 items.\n+        return Multi.createFrom().ticks().every(Duration.ofMillis(2))\n+                .transform().byTakingFirstItems(10)\n+                .map(l -> Item.newBuilder().setValue(Long.toString(l)).build());\n+    }\n+\n+    @Override\n+    public Uni<Empty> sink(Multi<Item> request) {\n+        // Reads the incoming streams, consume all the items.\n+        return request\n+                .map(Item::getValue)\n+                .map(Long::parseLong)\n+                .collectItems().last()\n+                .map(l -> Empty.newBuilder().build());\n+    }\n+\n+    @Override\n+    public Multi<Item> pipe(Multi<Item> request) {\n+        // Reads the incoming stream, compute a sum and return the cumulative results\n+        // in the outbound stream.\n+        return request\n+                .map(Item::getValue)\n+                .map(Long::parseLong)\n+                .onItem().scan(() -> 0L, Long::sum)\n+                .onItem().apply(l -> Item.newBuilder().setValue(Long.toString(l)).build());\n+    }\n+}\n+----\n+\n+== Health check\n+For the exposed services, Quarkus gRPC exposes health information in the following format:\n+[source,protobuf]\n+----\n+syntax = \"proto3\";\n+\n+package grpc.health.v1;\n+\n+message HealthCheckRequest {\n+  string service = 1;\n+}\n+\n+message HealthCheckResponse {\n+  enum ServingStatus {\n+    UNKNOWN = 0;\n+    SERVING = 1;\n+    NOT_SERVING = 2;\n+  }\n+  ServingStatus status = 1;\n+}\n+\n+service Health {\n+  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);\n+\n+  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);\n+}\n+----\n+\n+Clients can specify the fully qualified service name to get the health status of a specific service\n+or skip specifying the service name to get the general status of the gRPC server.\n+\n+For more details, check out the\n+https://github.com/grpc/grpc/blob/v1.28.1/doc/health-checking.md[gRPC documentation]\n+\n+Additionally, if Quarkus SmallRye Health is added to the application, a readiness check for\n+the state of the gRPC services will be added to the MicroProfile Health endpoint response, that is `/health`.\n+\n+== Reflection Service\n+\n+Quarkus gRPC Server implements the https://github.com/grpc/grpc/blob/master/doc/server-reflection.md[reflection service].\n+This service allows tools like https://github.com/fullstorydev/grpcurl[grpcurl] or https://github.com/gusaul/grpcox[grpcox] to interact with your services.\n+\n+The reflection service is enabled by default in _dev_ mode.\n+In test or production mode, you need to enable it explicitly by setting `quarkus.grpc-server.enable-reflection-service` to `true`.\n+\n+== Server configuration\n+\n+By default, the server is exposed on `localhost:9000` and uses `plain-text`.\n+\n+The following configuration properties are supported:\n+\n+|===\n+|Property |Description |Default Value\n+\n+|quarkus.grpc-server.enable-reflection-service | Enables the reflection service  | `false` (`true` in dev mode)", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkwMDkxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420900911", "bodyText": "Yes, I need to try to understand why it was not working from the other repo. Maybe now it is going to work.", "author": "cescoffier", "createdAt": "2020-05-06T15:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4ODg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkwMjM3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420902376", "bodyText": "It was not working for external repos, @machi1990 worked on fixing that but having it in the main repo should make it work anyway. If not, please ping @machi1990 and me, we will help!", "author": "gsmet", "createdAt": "2020-05-06T15:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4ODg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ4ODU1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r421488553", "bodyText": "Fixed!", "author": "cescoffier", "createdAt": "2020-05-07T13:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4ODg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg4OTQyOA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r420889428", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Quarkus gRPC extensions integrate gRPC in Quarkus application.\n          \n          \n            \n            The Quarkus gRPC extension integrate gRPC in Quarkus application.", "author": "gsmet", "createdAt": "2020-05-06T15:36:31Z", "path": "docs/src/main/asciidoc/grpc.adoc", "diffHunk": "@@ -0,0 +1,29 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus gRPC\n+\n+include::./attributes.adoc[]\n+\n+https://grpc.io/[gRPC] is a high-performance RPC framework.\n+It can efficiently connect services implemented using various languages and frameworks.\n+It is also applicable in the last mile of distributed computing to connect devices, mobile applications, and browsers to backend services.\n+\n+In general, gRPC uses HTTP/2, TLS, and https://developers.google.com/protocol-buffers[Protobuf (Protocol Buffers)].\n+In a microservice architecture, gRPC is an efficient, type-safe alternative to HTTP.\n+\n+The Quarkus gRPC extensions integrate gRPC in Quarkus application.", "originalCommit": "9fa26b12cf318f23be1bccdf1466e0588c8b832e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "23d06566ebd49c8762472fa10b8d104c25581b90", "url": "https://github.com/quarkusio/quarkus/commit/23d06566ebd49c8762472fa10b8d104c25581b90", "message": "Remove explicit Vert.x dependencies from the bom as they are imported from the Vert.x Bom", "committedDate": "2020-05-07T12:59:34Z", "type": "forcePushed"}, {"oid": "4b9235509d0a77cfb34cb4da44cb89b683d3cf1f", "url": "https://github.com/quarkusio/quarkus/commit/4b9235509d0a77cfb34cb4da44cb89b683d3cf1f", "message": "Remove explicit Vert.x dependencies from the bom as they are imported from the Vert.x Bom", "committedDate": "2020-05-07T13:21:03Z", "type": "forcePushed"}, {"oid": "6b7e85a2c268cd0d15208857cff4b6adf6046984", "url": "https://github.com/quarkusio/quarkus/commit/6b7e85a2c268cd0d15208857cff4b6adf6046984", "message": "Remove explicit Vert.x dependencies from the bom as they are imported from the Vert.x Bom", "committedDate": "2020-05-09T12:00:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3OTc0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r423179749", "bodyText": "Those were not converted to Quarkus configuration. Is it normal?", "author": "gsmet", "createdAt": "2020-05-11T16:53:07Z", "path": "docs/src/main/asciidoc/grpc-service-consumption.adoc", "diffHunk": "@@ -0,0 +1,181 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Consuming a gRPC Service\n+\n+include::./attributes.adoc[]\n+\n+gRPC services can be injected in your application code.\n+\n+IMPORTANT: Consuming gRPC services requires the gRPC classes to be generated.\n+Place your `proto` files in `src/main/proto` and run `mvn compile`.\n+\n+== Stubs and Injection\n+\n+gRPC generation provides several stubs, providing different way to consume a service.\n+Quarkus gRPC can inject:\n+\n+* blocking stubs\n+* reactive stubs based on Mutiny\n+\n+In addition, it also can inject the gRPC `io.grpc.Channel`, that lets you create other types of stubs.\n+\n+[source, java]\n+----\n+@Inject @GrpcService(\"hello-service\")\n+MutinyGreeterGrpc.MutinyGreeterStub mutiny;\n+\n+@Inject @GrpcService(\"hello-service\")\n+GreeterGrpc.GreeterBlockingStub blocking;\n+\n+@Inject @GrpcService(\"hello-service\")\n+Channel channel;\n+----\n+\n+The stub class names are computed from the service name.\n+For example, if you use `Greeter` as service name as in:\n+\n+[source]\n+----\n+service Greeter {\n+    rpc SayHello (HelloRequest) returns (HelloReply) {}\n+}\n+----\n+\n+The Mutiny stub name is: `MutinyGreeterGrpc.MutinyGreeterStub`\n+The blocking stub name is: `GreeterGrpc.GreeterBlockingStub`\n+\n+Client injection must be qualified using `@GrpcService`.\n+This annotation indicates the configuration prefix used to configure the service.\n+For example, if you set it to `hello-service`, configuring the host of the service is done using `hello-service.host`.\n+\n+== Examples\n+\n+=== Using a blocking and mutiny stubs\n+\n+[source, java]\n+----\n+@Inject @GrpcService(\"hello\") GreeterGrpc.GreeterBlockingStub blockingHelloService;\n+@Inject @GrpcService(\"hello\") MutinyGreeterGrpc.MutinyGreeterStub mutinyHelloService;\n+\n+@GET\n+@Path(\"/blocking/{name}\")\n+public String helloBlocking(@PathParam(\"name\") String name) {\n+    return blockingHelloService.sayHello(HelloRequest.newBuilder().setName(name).build()).getMessage();\n+}\n+\n+@GET\n+@Path(\"/mutiny/{name}\")\n+public Uni<String> helloMutiny(@PathParam(\"name\") String name) {\n+    return mutinyHelloService.sayHello(HelloRequest.newBuilder().setName(name).build())\n+            .onItem().apply(HelloReply::getMessage);\n+}\n+----\n+\n+Note that in this example, the `grpc.quarkus.clients.hello.host` property must be set.\n+\n+=== Handling streams\n+\n+gRPC allows sending and receiving streams:\n+\n+[source]\n+----\n+service Streaming {\n+    rpc Source(Empty) returns (stream Item) {} // Returns a stream\n+    rpc Sink(stream Item) returns (Empty) {}   // Reads a stream\n+    rpc Pipe(stream Item) returns (stream Item) {}  // Reads a streams and return a streams\n+}\n+----\n+\n+Using the Mutiny stub, you can interact with these as follows:\n+\n+[source, java]\n+----\n+package io.quarkus.grpc.example.streaming;\n+\n+import io.grpc.examples.streaming.Empty;\n+import io.grpc.examples.streaming.Item;\n+import io.grpc.examples.streaming.MutinyStreamingGrpc;\n+import io.quarkus.grpc.runtime.annotations.GrpcService;\n+import io.smallrye.mutiny.Multi;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+@Path(\"/streaming\")\n+@Produces(MediaType.APPLICATION_JSON)\n+public class StreamingEndpoint {\n+\n+    @Inject @GrpcService(\"streaming\") MutinyStreamingGrpc.MutinyStreamingStub client;\n+\n+    @GET\n+    public Multi<String> invokeSource() {\n+        // Retrieve a stream\n+        return client.source(Empty.newBuilder().build())\n+                .onItem().apply(Item::getValue);\n+    }\n+\n+    @GET\n+    @Path(\"sink/{max}\")\n+    public Uni<Void> invokeSink(@PathParam(\"max\") int max) {\n+        // Send a stream and wait for completion\n+        Multi<Item> inputs = Multi.createFrom().range(0, max)\n+                .map(i -> Integer.toString(i))\n+                .map(i -> Item.newBuilder().setValue(i).build());\n+        return client.sink(inputs).onItem().ignore().andContinueWithNull();\n+    }\n+\n+    @GET\n+    @Path(\"/{max}\")\n+    public Multi<String> invokePipe(@PathParam(\"max\") int max) {\n+        // Send a stream and retrieve a stream\n+        Multi<Item> inputs = Multi.createFrom().range(0, max)\n+                .map(i -> Integer.toString(i))\n+                .map(i -> Item.newBuilder().setValue(i).build());\n+        return client.pipe(inputs).onItem().apply(Item::getValue);\n+    }\n+\n+}\n+\n+----\n+\n+== Client configuration\n+\n+For each gRPC service you inject in your application, you can configure the following attributes:\n+\n+include::{generated-dir}/config/quarkus-grpc-config-group-config-grpc-client-configuration.adoc[opts=optional, leveloffset=+1]\n+\n+The `service-name` is the name set in the `@GrpcService`.\n+\n+== Example of configuration\n+\n+=== Enabling TLS\n+\n+To enable TLS, use the following configuration:\n+\n+[source]\n+----\n+hello.host=localhost\n+hello.ssl.trust-store=src/main/resources/tls/ca.pem", "originalCommit": "be8d50a22441812b4783309c9a9a2e8185fa5ad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2NDY0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r423464645", "bodyText": "Definitely No! Good catch.", "author": "cescoffier", "createdAt": "2020-05-12T05:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3OTc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5MjExNw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r423192117", "bodyText": "Shouldn't it be in the serialization category instead? I don't think we want a category for one extension?", "author": "gsmet", "createdAt": "2020-05-11T17:13:01Z", "path": "extensions/grpc/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,9 @@\n+---\n+name: \"gRPC\"\n+metadata:\n+  keywords:\n+    - \"gRPC\"\n+  categories:\n+    - \"grpc\"", "originalCommit": "be8d50a22441812b4783309c9a9a2e8185fa5ad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3MjYzMw==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r423472633", "bodyText": "Protobuf would be serialization. Here we have a server and a client mechanism, not just a format.\nI looked at other categories and I would propose:\n\nreactive\nweb (netty, for example, is in web, as well as the rest client)\nserialization (because of protobuf)", "author": "cescoffier", "createdAt": "2020-05-12T05:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5MjExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2MDM5NA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r423560394", "bodyText": "Yes, these categories look good.", "author": "gsmet", "createdAt": "2020-05-12T08:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5MjExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5Mjc2OA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r423192768", "bodyText": "This should a sentence starting with a verb as it's what we will have on code.quarkus.io (\"Serialize...\" \"Connect to...\")", "author": "gsmet", "createdAt": "2020-05-11T17:14:08Z", "path": "extensions/grpc/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,169 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <artifactId>quarkus-grpc-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <properties>\n+        <vertx.version>3.9.0</vertx.version>\n+    </properties>\n+\n+    <artifactId>quarkus-grpc</artifactId>\n+    <name>Quarkus - gRPC - Runtime</name>\n+    <description>gRPC support for Quarkus</description>", "originalCommit": "be8d50a22441812b4783309c9a9a2e8185fa5ad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3MzE2MA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r423473160", "bodyText": "Let's go with \"Serve and consume gRPC services\"", "author": "cescoffier", "createdAt": "2020-05-12T05:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5Mjc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NDA5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r423194095", "bodyText": "We don't include it in a binary at all? (just to be extra sure)", "author": "gsmet", "createdAt": "2020-05-11T17:16:06Z", "path": "extensions/grpc/deployment/src/test/proto/test.proto", "diffHunk": "@@ -0,0 +1,89 @@\n+// Copyright 2015, Google Inc.\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.", "originalCommit": "be8d50a22441812b4783309c9a9a2e8185fa5ad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ3NDIwNA==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r423474204", "bodyText": "So no. It's only used in tests and it's part of the gRPC \"kind of TCK\". Zipping the sources is not considered as a binary form. We do the same on Vert.x (and gRPC Java does also the same).\nHowever, we need to keep this copyright in the source form (which explains why it's there).", "author": "cescoffier", "createdAt": "2020-05-12T05:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NDA5NQ=="}], "type": "inlineReview"}, {"oid": "364a0854df33d3d0e9428c82b7eb5cb26a28097e", "url": "https://github.com/quarkusio/quarkus/commit/364a0854df33d3d0e9428c82b7eb5cb26a28097e", "message": "Refine the gRPC extension description and categorisation", "committedDate": "2020-05-12T05:43:47Z", "type": "forcePushed"}, {"oid": "44b29f98c6bc67422a9a80b91aa7e75029dd06db", "url": "https://github.com/quarkusio/quarkus/commit/44b29f98c6bc67422a9a80b91aa7e75029dd06db", "message": "Workaround missing ALPN on Java 8 242-", "committedDate": "2020-05-12T13:51:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1Mjg1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/9120#discussion_r424252852", "bodyText": "This is incorrect. And should be moved to FeatureBuildItem. The client one should be moved to FeatureBuildItem too.", "author": "gsmet", "createdAt": "2020-05-13T08:12:02Z", "path": "extensions/grpc/deployment/src/main/java/io/quarkus/grpc/deployment/GrpcServerProcessor.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package io.quarkus.grpc.deployment;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.grpc.internal.DnsNameResolverProvider;\n+import io.grpc.internal.PickFirstLoadBalancerProvider;\n+import io.grpc.netty.NettyChannelProvider;\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.IsNormal;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.ServiceStartBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.grpc.runtime.GrpcContainer;\n+import io.quarkus.grpc.runtime.GrpcServerRecorder;\n+import io.quarkus.grpc.runtime.config.GrpcConfiguration;\n+import io.quarkus.grpc.runtime.config.GrpcServerBuildTimeConfig;\n+import io.quarkus.grpc.runtime.health.GrpcHealthEndpoint;\n+import io.quarkus.grpc.runtime.health.GrpcHealthStorage;\n+import io.quarkus.kubernetes.spi.KubernetesPortBuildItem;\n+import io.quarkus.smallrye.health.deployment.spi.HealthBuildItem;\n+import io.quarkus.vertx.deployment.VertxBuildItem;\n+\n+public class GrpcServerProcessor {\n+\n+    private static final Logger logger = Logger.getLogger(GrpcServerProcessor.class);\n+\n+    public static final String GRPC_SERVER = \"/reactive\";", "originalCommit": "44b29f98c6bc67422a9a80b91aa7e75029dd06db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5edddec81b5373f0fbee0fceebf92678f172eabe", "url": "https://github.com/quarkusio/quarkus/commit/5edddec81b5373f0fbee0fceebf92678f172eabe", "message": "Move the gRPC extension to the main Quarkus repository\n\nThis commit contains the extension code and also update the boms and build parents with the required dependencies.\nIt changed the ban strategy for Findbugs JSR 305 as some annotation are required by the classes generated by protoc.\n\nCo-authored-by: Michal Szynkiewicz <michal.l.szynkiewicz@gmail.com>", "committedDate": "2020-05-13T09:01:33Z", "type": "commit"}, {"oid": "274b7a671174cf1879638aba8d9cf36686449e3d", "url": "https://github.com/quarkusio/quarkus/commit/274b7a671174cf1879638aba8d9cf36686449e3d", "message": "Add gRPC integration tests\n\nAdds ITs for plain-text, TLS, mutual auth, interceptors, streaming, health support and proto v2\n\nCo-authored-by: Michal Szynkiewicz <michal.l.szynkiewicz@gmail.com>", "committedDate": "2020-05-13T09:01:34Z", "type": "commit"}, {"oid": "72b42ea37d6bd063896b3d491adb7c865d3ce685", "url": "https://github.com/quarkusio/quarkus/commit/72b42ea37d6bd063896b3d491adb7c865d3ce685", "message": "Add the gRPC support documentation\n\nCo-authored-by: Michal Szynkiewicz <michal.l.szynkiewicz@gmail.com>", "committedDate": "2020-05-13T09:01:34Z", "type": "commit"}, {"oid": "afbd2b84ae92ca37eba62434a2c5bd10d53eabc4", "url": "https://github.com/quarkusio/quarkus/commit/afbd2b84ae92ca37eba62434a2c5bd10d53eabc4", "message": "gRPC extension - Change configuration format to align with the rest of Quarkus\n\n* quarkus.grpc root\n* quarkus.grpc.service -> server configuration\n* quarkus.grpc.clients.client_name -> client configuration", "committedDate": "2020-05-13T09:08:58Z", "type": "commit"}, {"oid": "2765ed08c7ea2c0d2e2f9527e350d5c3ddf63146", "url": "https://github.com/quarkusio/quarkus/commit/2765ed08c7ea2c0d2e2f9527e350d5c3ddf63146", "message": "Remove the ban on the jsr 305 dependency", "committedDate": "2020-05-13T09:09:03Z", "type": "commit"}, {"oid": "bf8d70c8c442bb4300cc4c7d77c9ce4cecf3b822", "url": "https://github.com/quarkusio/quarkus/commit/bf8d70c8c442bb4300cc4c7d77c9ce4cecf3b822", "message": "Workaround missing ALPN on Java 8 242-", "committedDate": "2020-05-13T09:09:03Z", "type": "commit"}, {"oid": "bf8d70c8c442bb4300cc4c7d77c9ce4cecf3b822", "url": "https://github.com/quarkusio/quarkus/commit/bf8d70c8c442bb4300cc4c7d77c9ce4cecf3b822", "message": "Workaround missing ALPN on Java 8 242-", "committedDate": "2020-05-13T09:09:03Z", "type": "forcePushed"}]}