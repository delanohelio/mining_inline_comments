{"pr_number": 10936, "pr_title": "Implement container-managed concurrency for beans", "pr_createdAt": "2020-07-23T13:18:37Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/10936", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2NjQzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459566439", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Or let the container to control concurrent access to the bean instance. \n          \n          \n            \n            Or let the container control concurrent access to the bean instance.", "author": "gastaldi", "createdAt": "2020-07-23T16:12:36Z", "path": "docs/src/main/asciidoc/cdi-reference.adoc", "diffHunk": "@@ -661,6 +661,38 @@ This situation is very common when trying to use CDI with alternative JVM langua\n \n Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value).\n \n+=== Container-managed Concurrency\n+\n+There is no standard concurrency control mechanism for CDI beans.\n+However, bean instances can be shared.\n+In that case, the instances may be accessed concurrently and therefore should be thread-safe.\n+A bean author can protect the bean state using the standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.).\n+Or let the container to control concurrent access to the bean instance. ", "originalCommit": "1c6b4b40d038908e14c100f7380b4b6f398de0c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3ac43377eab8d69308bdbc2c7839946677feea2f", "url": "https://github.com/quarkusio/quarkus/commit/3ac43377eab8d69308bdbc2c7839946677feea2f", "message": "Implement container-managed concurrency for beans\n\n- resolves #10923", "committedDate": "2020-07-23T19:19:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NDcwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459774705", "bodyText": "If this throws InterruptedException then locked will be true but the lock will not have been acquired, and the finally block will attempt to unlock a lock it does not hold.", "author": "stuartwdouglas", "createdAt": "2020-07-23T23:03:02Z", "path": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/LockInterceptor.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.arc.impl;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+import io.quarkus.arc.ArcInvocationContext;\n+import io.quarkus.arc.Lock;\n+import io.quarkus.arc.LockException;\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Priority;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+@Lock\n+@Interceptor\n+@Priority(PLATFORM_BEFORE)\n+public class LockInterceptor {\n+\n+    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n+\n+    @AroundInvoke\n+    Object lock(InvocationContext ctx) throws Exception {\n+        Lock lock = getLock(ctx);\n+        switch (lock.value()) {\n+            case WRITE:\n+                return writeLock(lock, ctx);\n+            case READ:\n+                return readLock(lock, ctx);\n+            case NONE:\n+                return ctx.proceed();\n+        }\n+        throw new LockException(\"Unsupported @Lock type found on business method \" + ctx.getMethod());\n+    }\n+\n+    private Object writeLock(Lock lock, InvocationContext ctx) throws Exception {\n+        boolean locked = true;\n+        long time = lock.time();\n+        try {\n+            if (time > 0) {\n+                locked = readWriteLock.writeLock().tryLock(time, lock.unit());", "originalCommit": "3ac43377eab8d69308bdbc2c7839946677feea2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTI4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459865286", "bodyText": "I see. In that case locked should be initialized with false and set to true after the lock is acquired sucessfully.", "author": "mkouba", "createdAt": "2020-07-24T05:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NDcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg3NTAwOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459875009", "bodyText": "Should be fixed now..", "author": "mkouba", "createdAt": "2020-07-24T06:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NDcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NDc1OA==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459774758", "bodyText": "Same problem here.", "author": "stuartwdouglas", "createdAt": "2020-07-23T23:03:14Z", "path": "independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/LockInterceptor.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.arc.impl;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+import io.quarkus.arc.ArcInvocationContext;\n+import io.quarkus.arc.Lock;\n+import io.quarkus.arc.LockException;\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Priority;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+@Lock\n+@Interceptor\n+@Priority(PLATFORM_BEFORE)\n+public class LockInterceptor {\n+\n+    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n+\n+    @AroundInvoke\n+    Object lock(InvocationContext ctx) throws Exception {\n+        Lock lock = getLock(ctx);\n+        switch (lock.value()) {\n+            case WRITE:\n+                return writeLock(lock, ctx);\n+            case READ:\n+                return readLock(lock, ctx);\n+            case NONE:\n+                return ctx.proceed();\n+        }\n+        throw new LockException(\"Unsupported @Lock type found on business method \" + ctx.getMethod());\n+    }\n+\n+    private Object writeLock(Lock lock, InvocationContext ctx) throws Exception {\n+        boolean locked = true;\n+        long time = lock.time();\n+        try {\n+            if (time > 0) {\n+                locked = readWriteLock.writeLock().tryLock(time, lock.unit());\n+                if (!locked) {\n+                    throw new LockException(\"Write lock not acquired in \" + lock.unit().toMillis(time) + \" ms\");\n+                }\n+            } else {\n+                readWriteLock.writeLock().lock();\n+            }\n+            return ctx.proceed();\n+        } finally {\n+            if (locked) {\n+                readWriteLock.writeLock().unlock();\n+            }\n+        }\n+    }\n+\n+    private Object readLock(Lock lock, InvocationContext ctx) throws Exception {\n+        boolean locked = true;\n+        long time = lock.time();\n+        try {\n+            if (time > 0) {\n+                locked = readWriteLock.readLock().tryLock(time, lock.unit());", "originalCommit": "3ac43377eab8d69308bdbc2c7839946677feea2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTAxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459839015", "bodyText": "Should we include a note mentioning what the default timeout is for such locks?", "author": "jaikiran", "createdAt": "2020-07-24T03:45:54Z", "path": "docs/src/main/asciidoc/cdi-reference.adoc", "diffHunk": "@@ -661,6 +661,38 @@ This situation is very common when trying to use CDI with alternative JVM langua\n \n Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value).\n \n+=== Container-managed Concurrency\n+\n+There is no standard concurrency control mechanism for CDI beans.\n+Nevertheless, a bean instance can be shared and accessed concurrently from multiple threads.\n+In that case it should be thread-safe.\n+You can use standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.) or let the container control the concurrent access. \n+\n+.Container-managed Concurrency Example\n+[source,java]\n+----\n+import io.quarkus.arc.Lock;\n+\n+@Lock <1>\n+@ApplicationScoped\n+class SharedService {\n+\n+  void addAmount(BigDecimal amout) {\n+    // ...changes some internal state of the bean\n+  }\n+  \n+  @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS) <2> <3>\n+  BigDecimal getAmount() {\n+    // ...it is safe to read the value concurrently\n+  }\n+}\n+----\n+<1> `@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class instructs the container to lock the bean instance for any invocation of any business method, i.e. the client has \"exclusive access\" and no concurrent invocations will be allowed.", "originalCommit": "3ac43377eab8d69308bdbc2c7839946677feea2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MzM4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459863381", "bodyText": "AFAIK there is no timeout by default...", "author": "mkouba", "createdAt": "2020-07-24T05:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTYyMQ==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459839621", "bodyText": "@mkouba, I don't have knowledge about CDI, so this might be a basic question - Assuming this @Lock is declared on a request scoped bean, do such beans have more than one (bean) instance at any given time? If yes, then does this locking mechanism apply per bean instance (i.e. a WRITE lock on bean instance1 would still allow a WRITE access on bean instance2 of the same bean type)? Or is the lock applicable for all instances of the same bean type?", "author": "jaikiran", "createdAt": "2020-07-24T03:49:33Z", "path": "docs/src/main/asciidoc/cdi-reference.adoc", "diffHunk": "@@ -661,6 +661,38 @@ This situation is very common when trying to use CDI with alternative JVM langua\n \n Quarkus however, can overcome these limitations when `quarkus.arc.transform-unproxyable-classes` is set to `true` (which is the default value).\n \n+=== Container-managed Concurrency\n+\n+There is no standard concurrency control mechanism for CDI beans.\n+Nevertheless, a bean instance can be shared and accessed concurrently from multiple threads.\n+In that case it should be thread-safe.\n+You can use standard Java constructs (`volatile`, `synchronized`, `ReadWriteLock`, etc.) or let the container control the concurrent access. \n+\n+.Container-managed Concurrency Example\n+[source,java]\n+----\n+import io.quarkus.arc.Lock;\n+\n+@Lock <1>\n+@ApplicationScoped\n+class SharedService {\n+\n+  void addAmount(BigDecimal amout) {\n+    // ...changes some internal state of the bean\n+  }\n+  \n+  @Lock(value = Lock.Type.READ, time = 1, unit = TimeUnit.SECONDS) <2> <3>\n+  BigDecimal getAmount() {\n+    // ...it is safe to read the value concurrently\n+  }\n+}\n+----\n+<1> `@Lock` (which maps to `@Lock(Lock.Type.WRITE)`) declared on the class instructs the container to lock the bean instance for any invocation of any business method, i.e. the client has \"exclusive access\" and no concurrent invocations will be allowed.\n+<2> `@Lock(Lock.Type.READ)` overrides the value specified at class level. It means that any number of clients can invoke the method concurrently, unless the bean instance is locked by `@Lock(Lock.Type.WRITE)`. \n+<3> You can also specify the \"wait time\". If it's not possible to acquire the lock in the given time a `LockException` is thrown.\n+\n+TIP: `io.quarkus.arc.Lock` is a regular interceptor binding and as such can be used for any bean with any scope. However, it is especially useful for \"shared\" scopes, e.g. `@Singleton` and `@ApplicationScoped`.", "originalCommit": "3ac43377eab8d69308bdbc2c7839946677feea2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NDYzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459864635", "bodyText": "If yes, then does this locking mechanism apply per bean instance (i.e. a WRITE lock on bean instance1 would still allow a WRITE access on bean instance2 of the same bean type)?\n\nYes, each bean instance has a separate lock.", "author": "mkouba", "createdAt": "2020-07-24T05:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2ODMwMA==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459868300", "bodyText": "Do you think we should expand this part of the documentation to state that request scoped beans won't share the lock instances?", "author": "jaikiran", "createdAt": "2020-07-24T06:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg3MzcwOA==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459873708", "bodyText": "Well, I can try to change the wording a bit. But @Lock is not a good match for @RequestScoped because there is exactly one bean instance per thread for @RequestScoped. In other words, you should not need locking there...", "author": "mkouba", "createdAt": "2020-07-24T06:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg3NzgyMA==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459877820", "bodyText": "Do endpoints (like this random example[1]) get marked (implicitly) as (request scoped) CDI beans? The use case that I am imagining, that might need clarity in the documentation, is something like this:\n@Path(\"/hello\")\npublic class HelloResource {\n\n    @POST\n    @Lock\n    public String addCredit() {\n        // some write operation\n    }\n}\n\nand then the @Lock wouldn't work in such cases (for multiple simulatenous requests)?\n[1] https://github.com/quarkusio/quarkus/blob/master/extensions/rest-client-jaxb/deployment/src/test/java/io/quarkus/restclient/jaxb/deployment/HelloResource.java", "author": "jaikiran", "createdAt": "2020-07-24T06:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4NDk5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459884993", "bodyText": "I see. Well, JAX-RS resources are @Singleton by default in Quarkus. Of course, you can annotate them with @RequestScoped or set quarkus.resteasy.singleton-resources=false. In any case, I don't think it's a good idea to lock a resource method like this.", "author": "mkouba", "createdAt": "2020-07-24T07:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4OTM3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459889375", "bodyText": "Well, JAX-RS resources are @singleton by default in Quarkus.\n\nThank you for that detail.\n\nOf course, you can annotate them with @RequestScoped or set quarkus.resteasy.singleton-resources=false. In any case, I don't think it's a good idea to lock a resource method like this.\n\nGiven that the regular/common use case doesn't create an implicit @RequestScoped, as you explained, I think the current documentation is good enough. I believe people adding @RequestScoped will be knowing what that means semantically.\nThank you for answering the questions.", "author": "jaikiran", "createdAt": "2020-07-24T07:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5MDA0OA==", "url": "https://github.com/quarkusio/quarkus/pull/10936#discussion_r459890048", "bodyText": "You're welcome ;-)", "author": "mkouba", "createdAt": "2020-07-24T07:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzOTYyMQ=="}], "type": "inlineReview"}, {"oid": "29db695d30256cb5bc23245a20c0fa7eae8c7a07", "url": "https://github.com/quarkusio/quarkus/commit/29db695d30256cb5bc23245a20c0fa7eae8c7a07", "message": "Implement container-managed concurrency for beans\n\n- resolves #10923", "committedDate": "2020-07-24T06:34:53Z", "type": "commit"}, {"oid": "29db695d30256cb5bc23245a20c0fa7eae8c7a07", "url": "https://github.com/quarkusio/quarkus/commit/29db695d30256cb5bc23245a20c0fa7eae8c7a07", "message": "Implement container-managed concurrency for beans\n\n- resolves #10923", "committedDate": "2020-07-24T06:34:53Z", "type": "forcePushed"}]}