{"pr_number": 8615, "pr_title": "Add Quarkus Vault Authentication Guide", "pr_createdAt": "2020-04-16T10:30:45Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8615", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczNzMwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409737305", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n          \n          \n            \n            * Start using Vault using the client token, within the limits of what is allowed by the policies associated with the token\n          \n      \n    \n    \n  \n\n?", "author": "gsmet", "createdAt": "2020-04-16T17:44:13Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczODI0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409738247", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n          \n          \n            \n            * For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (Minishift, K3s, Docker Desktop, \u2026\u200b)", "author": "gsmet", "createdAt": "2020-04-16T17:45:52Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczODM0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409738347", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n          \n          \n            \n            We assume there is a Vault container and a PostgreSQL container running from the {base-guide}, and the root token is known.", "author": "gsmet", "createdAt": "2020-04-16T17:46:01Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczODcyMw==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409738723", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Create a token for policy `vault-quickstart-policy`:\n          \n          \n            \n            Create a token for the `vault-quickstart-policy` policy:", "author": "gsmet", "createdAt": "2020-04-16T17:46:38Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczOTAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409739024", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access\n          \n          \n            \n            One drawback of this approach is that you expose a secret piece of information (i.e. the token) that can give access", "author": "gsmet", "createdAt": "2020-04-16T17:47:10Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -policy=vault-quickstart-policy\n+Key                  Value\n+---                  -----\n+token                {client-token}\n+token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n+token_duration       768h\n+token_renewable      true\n+token_policies       [\"default\" \"vault-quickstart-policy\"]\n+identity_policies    []\n+policies             [\"default\" \"vault-quickstart-policy\"]\n+----\n+\n+Now use the generated client token in the application configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token={client-token}\n+----\n+\n+Compile and start the application:\n+[source, shell, subs=attributes+]\n+----\n+./mvnw clean install\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Finally test the application endpoint:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+=== Client Token using Response Wrapping\n+\n+One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczOTY3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409739673", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a ttl of 1 minute:\n          \n          \n            \n            With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a TTL of 1 minute:", "author": "gsmet", "createdAt": "2020-04-16T17:48:11Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -policy=vault-quickstart-policy\n+Key                  Value\n+---                  -----\n+token                {client-token}\n+token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n+token_duration       768h\n+token_renewable      true\n+token_policies       [\"default\" \"vault-quickstart-policy\"]\n+identity_policies    []\n+policies             [\"default\" \"vault-quickstart-policy\"]\n+----\n+\n+Now use the generated client token in the application configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token={client-token}\n+----\n+\n+Compile and start the application:\n+[source, shell, subs=attributes+]\n+----\n+./mvnw clean install\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Finally test the application endpoint:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+=== Client Token using Response Wrapping\n+\n+One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access\n+to sensitive data in Vault. This requires ensuring that the application\u2019s configuration stays secure at all time.\n+If an intruder was to access the client token, it would be able to start calling Vault on all endpoints permitted\n+by the policy.\n+\n+This risk can be mitigated using an approach called\n+https://www.vaultproject.io/docs/concepts/response-wrapping[Response Wrapping] (which used to be known as\n+_Cubbyhole Authentication_ in older versions of Vault). This principle is simple: instead of configuring the\n+client token itself, we hide it inside a _Wrapping Token_, which we provide to the application. Upon startup,\n+the application will unwrap the _Wrapping Token_, and fetch the real token from within. The additional level of\n+security comes from the fact that the _Wrapping Token_ is short lived (from a few seconds to a few minutes;\n+basically just enough to start and unwrap the token), and can be unwrapped *only once*.\n+If the _Wrapping Token_ gets stolen and unwrapped, we will notice immediately because the legitimate application\n+will get an error saying that the token is invalid.\n+\n+With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a ttl of 1 minute:", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczOTkzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409739931", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Stop the application, and execute tests with `./mvnw test`. They should fail with error:\n          \n          \n            \n            Stop the application, and execute tests with `./mvnw test`. They should fail with the following error:", "author": "gsmet", "createdAt": "2020-04-16T17:48:37Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -policy=vault-quickstart-policy\n+Key                  Value\n+---                  -----\n+token                {client-token}\n+token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n+token_duration       768h\n+token_renewable      true\n+token_policies       [\"default\" \"vault-quickstart-policy\"]\n+identity_policies    []\n+policies             [\"default\" \"vault-quickstart-policy\"]\n+----\n+\n+Now use the generated client token in the application configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token={client-token}\n+----\n+\n+Compile and start the application:\n+[source, shell, subs=attributes+]\n+----\n+./mvnw clean install\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Finally test the application endpoint:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+=== Client Token using Response Wrapping\n+\n+One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access\n+to sensitive data in Vault. This requires ensuring that the application\u2019s configuration stays secure at all time.\n+If an intruder was to access the client token, it would be able to start calling Vault on all endpoints permitted\n+by the policy.\n+\n+This risk can be mitigated using an approach called\n+https://www.vaultproject.io/docs/concepts/response-wrapping[Response Wrapping] (which used to be known as\n+_Cubbyhole Authentication_ in older versions of Vault). This principle is simple: instead of configuring the\n+client token itself, we hide it inside a _Wrapping Token_, which we provide to the application. Upon startup,\n+the application will unwrap the _Wrapping Token_, and fetch the real token from within. The additional level of\n+security comes from the fact that the _Wrapping Token_ is short lived (from a few seconds to a few minutes;\n+basically just enough to start and unwrap the token), and can be unwrapped *only once*.\n+If the _Wrapping Token_ gets stolen and unwrapped, we will notice immediately because the legitimate application\n+will get an error saying that the token is invalid.\n+\n+With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a ttl of 1 minute:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -wrap-ttl=60s -policy=vault-quickstart-policy\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {client-token-wrapping-token}\n+wrapping_accessor:               ojvbOtmLzB5D47SzXGo9b3sR\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:05:20.990240428 +0000 UTC\n+wrapping_token_creation_path:    auth/token/create\n+wrapped_accessor:                a4ITYQNnQtwCOUmV5DJMpCiG\n+----\n+\n+Now let\u2019s use this wrapping token in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token-wrapping-token={client-token-wrapping-token}\n+----\n+\n+Compile and run the application *without the tests*, you should be able now to curl the private key `{private-key}` as before.\n+\n+Stop the application, and execute tests with `./mvnw test`. They should fail with error:", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0MDU3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409740571", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            unsual to use this approach as response wrapping typically involves a technical workflow,\n          \n          \n            \n            unusual to use this approach as response wrapping typically involves a technical workflow,\n          \n      \n    \n    \n  \n\nor usual? but I would say the former.", "author": "gsmet", "createdAt": "2020-04-16T17:49:31Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -policy=vault-quickstart-policy\n+Key                  Value\n+---                  -----\n+token                {client-token}\n+token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n+token_duration       768h\n+token_renewable      true\n+token_policies       [\"default\" \"vault-quickstart-policy\"]\n+identity_policies    []\n+policies             [\"default\" \"vault-quickstart-policy\"]\n+----\n+\n+Now use the generated client token in the application configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token={client-token}\n+----\n+\n+Compile and start the application:\n+[source, shell, subs=attributes+]\n+----\n+./mvnw clean install\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Finally test the application endpoint:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+=== Client Token using Response Wrapping\n+\n+One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access\n+to sensitive data in Vault. This requires ensuring that the application\u2019s configuration stays secure at all time.\n+If an intruder was to access the client token, it would be able to start calling Vault on all endpoints permitted\n+by the policy.\n+\n+This risk can be mitigated using an approach called\n+https://www.vaultproject.io/docs/concepts/response-wrapping[Response Wrapping] (which used to be known as\n+_Cubbyhole Authentication_ in older versions of Vault). This principle is simple: instead of configuring the\n+client token itself, we hide it inside a _Wrapping Token_, which we provide to the application. Upon startup,\n+the application will unwrap the _Wrapping Token_, and fetch the real token from within. The additional level of\n+security comes from the fact that the _Wrapping Token_ is short lived (from a few seconds to a few minutes;\n+basically just enough to start and unwrap the token), and can be unwrapped *only once*.\n+If the _Wrapping Token_ gets stolen and unwrapped, we will notice immediately because the legitimate application\n+will get an error saying that the token is invalid.\n+\n+With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a ttl of 1 minute:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -wrap-ttl=60s -policy=vault-quickstart-policy\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {client-token-wrapping-token}\n+wrapping_accessor:               ojvbOtmLzB5D47SzXGo9b3sR\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:05:20.990240428 +0000 UTC\n+wrapping_token_creation_path:    auth/token/create\n+wrapped_accessor:                a4ITYQNnQtwCOUmV5DJMpCiG\n+----\n+\n+Now let\u2019s use this wrapping token in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token-wrapping-token={client-token-wrapping-token}\n+----\n+\n+Compile and run the application *without the tests*, you should be able now to curl the private key `{private-key}` as before.\n+\n+Stop the application, and execute tests with `./mvnw test`. They should fail with error:\n+[source, shell, subs=attributes+]\n+----\n+ERROR: Failed to start application\n+io.quarkus.vault.VaultException: wrapping token is not valid or does not exist; this means that the token has already expired (if so you can increase the ttl on the wrapping token) or has been consumed by somebody else (potentially indicating that the wrapping token has been stolen)\n+----\n+\n+== Userpass Authentication\n+\n+Normally the `userpass` auth method should already be enabled from the {base-guide}.\n+\n+Simply specify the username and password for the user configured in Vault during setup:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.userpass.username=bob\n+quarkus.vault.authentication.userpass.password=sinclair\n+----\n+\n+Test the application endpoint after compiling and starting the application again:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+[NOTE]\n+====\n+Userpass supports response wrapping as well for the `password` property, although it is more\n+unsual to use this approach as response wrapping typically involves a technical workflow,", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0MTEzNA==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409741134", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Kubernetes jwt token located in `/var/run/secrets/kubernetes.io/serviceaccount`.\n          \n          \n            \n            Kubernetes JWT token located in `/var/run/secrets/kubernetes.io/serviceaccount`.", "author": "gsmet", "createdAt": "2020-04-16T17:50:27Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -policy=vault-quickstart-policy\n+Key                  Value\n+---                  -----\n+token                {client-token}\n+token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n+token_duration       768h\n+token_renewable      true\n+token_policies       [\"default\" \"vault-quickstart-policy\"]\n+identity_policies    []\n+policies             [\"default\" \"vault-quickstart-policy\"]\n+----\n+\n+Now use the generated client token in the application configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token={client-token}\n+----\n+\n+Compile and start the application:\n+[source, shell, subs=attributes+]\n+----\n+./mvnw clean install\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Finally test the application endpoint:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+=== Client Token using Response Wrapping\n+\n+One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access\n+to sensitive data in Vault. This requires ensuring that the application\u2019s configuration stays secure at all time.\n+If an intruder was to access the client token, it would be able to start calling Vault on all endpoints permitted\n+by the policy.\n+\n+This risk can be mitigated using an approach called\n+https://www.vaultproject.io/docs/concepts/response-wrapping[Response Wrapping] (which used to be known as\n+_Cubbyhole Authentication_ in older versions of Vault). This principle is simple: instead of configuring the\n+client token itself, we hide it inside a _Wrapping Token_, which we provide to the application. Upon startup,\n+the application will unwrap the _Wrapping Token_, and fetch the real token from within. The additional level of\n+security comes from the fact that the _Wrapping Token_ is short lived (from a few seconds to a few minutes;\n+basically just enough to start and unwrap the token), and can be unwrapped *only once*.\n+If the _Wrapping Token_ gets stolen and unwrapped, we will notice immediately because the legitimate application\n+will get an error saying that the token is invalid.\n+\n+With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a ttl of 1 minute:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -wrap-ttl=60s -policy=vault-quickstart-policy\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {client-token-wrapping-token}\n+wrapping_accessor:               ojvbOtmLzB5D47SzXGo9b3sR\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:05:20.990240428 +0000 UTC\n+wrapping_token_creation_path:    auth/token/create\n+wrapped_accessor:                a4ITYQNnQtwCOUmV5DJMpCiG\n+----\n+\n+Now let\u2019s use this wrapping token in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token-wrapping-token={client-token-wrapping-token}\n+----\n+\n+Compile and run the application *without the tests*, you should be able now to curl the private key `{private-key}` as before.\n+\n+Stop the application, and execute tests with `./mvnw test`. They should fail with error:\n+[source, shell, subs=attributes+]\n+----\n+ERROR: Failed to start application\n+io.quarkus.vault.VaultException: wrapping token is not valid or does not exist; this means that the token has already expired (if so you can increase the ttl on the wrapping token) or has been consumed by somebody else (potentially indicating that the wrapping token has been stolen)\n+----\n+\n+== Userpass Authentication\n+\n+Normally the `userpass` auth method should already be enabled from the {base-guide}.\n+\n+Simply specify the username and password for the user configured in Vault during setup:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.userpass.username=bob\n+quarkus.vault.authentication.userpass.password=sinclair\n+----\n+\n+Test the application endpoint after compiling and starting the application again:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+[NOTE]\n+====\n+Userpass supports response wrapping as well for the `password` property, although it is more\n+unsual to use this approach as response wrapping typically involves a technical workflow,\n+which is better suited for `approle`.\n+====\n+\n+== Approle Authentication\n+\n+_Approle_ is an authentication method suited for technical workflows. It relies on 2 pieces of information:\n+\n+* role id can be compared to the user name in _Userpass_\n+* secret id plays the role of the `password`\n+\n+To set up _Approle_ you need to enable the `approle` auth method, create an app role,\n+and generate a role id and secret id:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault auth enable approle\n+/ # vault write auth/approle/role/myapprole policies=vault-quickstart-policy\n+\n+/ # vault read auth/approle/role/myapprole/role-id\n+Key        Value\n+---        -----\n+role_id    {role-id}\n+\n+/ # vault write -f auth/approle/role/myapprole/secret-id\n+Key                   Value\n+---                   -----\n+secret_id             {secret-id}\n+secret_id_accessor    2acff656-d049-c4b3-a752-6125e69210ba\n+----\n+\n+Add the appropriate properties:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.role-id={role-id}\n+quarkus.vault.authentication.app-role.secret-id={secret-id}\n+----\n+\n+After compiling and running the application you should be able to curl it on the\n+`private-key` endpoint to see the secret information `{private-key}` as usual.\n+\n+=== Approle using Response Wrapping\n+\n+Similarly to direct client token authentication, it is possible to wrap the `secret-id`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault write -wrap-ttl=60s -f auth/approle/role/myapprole/secret-id\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {secret-id-wrapping-token}\n+wrapping_accessor:               u5EPZOnqyIJN8mT44od67WMS\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:59:25.482352967 +0000 UTC\n+wrapping_token_creation_path:    auth/approle/role/myapprole/secret-id\n+----\n+\n+Replace the `secret-id` property with `secret-id-wrapping-token` in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.secret-id-wrapping-token={secret-id-wrapping-token}\n+----\n+\n+Finally, recompile the application without tests (otherwise you are going to consume the wrapping token),\n+launch it and curl the `private-key` endpoint. As usual, you should see `{private-key}`.\n+\n+== Kubernetes Authentication\n+\n+Vault provides an integration with Kubernetes to allow containers to authenticate with Vault using their\n+Kubernetes jwt token located in `/var/run/secrets/kubernetes.io/serviceaccount`.", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0MTM1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409741359", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            to the master api to be able to validate the jwt token that the application will authenticate with.\n          \n          \n            \n            to the master API to be able to validate the JWT token that the application will authenticate with.", "author": "gsmet", "createdAt": "2020-04-16T17:50:52Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -policy=vault-quickstart-policy\n+Key                  Value\n+---                  -----\n+token                {client-token}\n+token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n+token_duration       768h\n+token_renewable      true\n+token_policies       [\"default\" \"vault-quickstart-policy\"]\n+identity_policies    []\n+policies             [\"default\" \"vault-quickstart-policy\"]\n+----\n+\n+Now use the generated client token in the application configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token={client-token}\n+----\n+\n+Compile and start the application:\n+[source, shell, subs=attributes+]\n+----\n+./mvnw clean install\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Finally test the application endpoint:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+=== Client Token using Response Wrapping\n+\n+One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access\n+to sensitive data in Vault. This requires ensuring that the application\u2019s configuration stays secure at all time.\n+If an intruder was to access the client token, it would be able to start calling Vault on all endpoints permitted\n+by the policy.\n+\n+This risk can be mitigated using an approach called\n+https://www.vaultproject.io/docs/concepts/response-wrapping[Response Wrapping] (which used to be known as\n+_Cubbyhole Authentication_ in older versions of Vault). This principle is simple: instead of configuring the\n+client token itself, we hide it inside a _Wrapping Token_, which we provide to the application. Upon startup,\n+the application will unwrap the _Wrapping Token_, and fetch the real token from within. The additional level of\n+security comes from the fact that the _Wrapping Token_ is short lived (from a few seconds to a few minutes;\n+basically just enough to start and unwrap the token), and can be unwrapped *only once*.\n+If the _Wrapping Token_ gets stolen and unwrapped, we will notice immediately because the legitimate application\n+will get an error saying that the token is invalid.\n+\n+With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a ttl of 1 minute:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -wrap-ttl=60s -policy=vault-quickstart-policy\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {client-token-wrapping-token}\n+wrapping_accessor:               ojvbOtmLzB5D47SzXGo9b3sR\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:05:20.990240428 +0000 UTC\n+wrapping_token_creation_path:    auth/token/create\n+wrapped_accessor:                a4ITYQNnQtwCOUmV5DJMpCiG\n+----\n+\n+Now let\u2019s use this wrapping token in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token-wrapping-token={client-token-wrapping-token}\n+----\n+\n+Compile and run the application *without the tests*, you should be able now to curl the private key `{private-key}` as before.\n+\n+Stop the application, and execute tests with `./mvnw test`. They should fail with error:\n+[source, shell, subs=attributes+]\n+----\n+ERROR: Failed to start application\n+io.quarkus.vault.VaultException: wrapping token is not valid or does not exist; this means that the token has already expired (if so you can increase the ttl on the wrapping token) or has been consumed by somebody else (potentially indicating that the wrapping token has been stolen)\n+----\n+\n+== Userpass Authentication\n+\n+Normally the `userpass` auth method should already be enabled from the {base-guide}.\n+\n+Simply specify the username and password for the user configured in Vault during setup:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.userpass.username=bob\n+quarkus.vault.authentication.userpass.password=sinclair\n+----\n+\n+Test the application endpoint after compiling and starting the application again:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+[NOTE]\n+====\n+Userpass supports response wrapping as well for the `password` property, although it is more\n+unsual to use this approach as response wrapping typically involves a technical workflow,\n+which is better suited for `approle`.\n+====\n+\n+== Approle Authentication\n+\n+_Approle_ is an authentication method suited for technical workflows. It relies on 2 pieces of information:\n+\n+* role id can be compared to the user name in _Userpass_\n+* secret id plays the role of the `password`\n+\n+To set up _Approle_ you need to enable the `approle` auth method, create an app role,\n+and generate a role id and secret id:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault auth enable approle\n+/ # vault write auth/approle/role/myapprole policies=vault-quickstart-policy\n+\n+/ # vault read auth/approle/role/myapprole/role-id\n+Key        Value\n+---        -----\n+role_id    {role-id}\n+\n+/ # vault write -f auth/approle/role/myapprole/secret-id\n+Key                   Value\n+---                   -----\n+secret_id             {secret-id}\n+secret_id_accessor    2acff656-d049-c4b3-a752-6125e69210ba\n+----\n+\n+Add the appropriate properties:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.role-id={role-id}\n+quarkus.vault.authentication.app-role.secret-id={secret-id}\n+----\n+\n+After compiling and running the application you should be able to curl it on the\n+`private-key` endpoint to see the secret information `{private-key}` as usual.\n+\n+=== Approle using Response Wrapping\n+\n+Similarly to direct client token authentication, it is possible to wrap the `secret-id`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault write -wrap-ttl=60s -f auth/approle/role/myapprole/secret-id\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {secret-id-wrapping-token}\n+wrapping_accessor:               u5EPZOnqyIJN8mT44od67WMS\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:59:25.482352967 +0000 UTC\n+wrapping_token_creation_path:    auth/approle/role/myapprole/secret-id\n+----\n+\n+Replace the `secret-id` property with `secret-id-wrapping-token` in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.secret-id-wrapping-token={secret-id-wrapping-token}\n+----\n+\n+Finally, recompile the application without tests (otherwise you are going to consume the wrapping token),\n+launch it and curl the `private-key` endpoint. As usual, you should see `{private-key}`.\n+\n+== Kubernetes Authentication\n+\n+Vault provides an integration with Kubernetes to allow containers to authenticate with Vault using their\n+Kubernetes jwt token located in `/var/run/secrets/kubernetes.io/serviceaccount`.\n+\n+The setup is more involved than with the other auth methods because we need to allow Vault to talk\n+to the master api to be able to validate the jwt token that the application will authenticate with.", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0MTUwMw==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409741503", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            role that Vault will use to communicate with the master api.\n          \n          \n            \n            role that Vault will use to communicate with the master API.", "author": "gsmet", "createdAt": "2020-04-16T17:51:04Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -policy=vault-quickstart-policy\n+Key                  Value\n+---                  -----\n+token                {client-token}\n+token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n+token_duration       768h\n+token_renewable      true\n+token_policies       [\"default\" \"vault-quickstart-policy\"]\n+identity_policies    []\n+policies             [\"default\" \"vault-quickstart-policy\"]\n+----\n+\n+Now use the generated client token in the application configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token={client-token}\n+----\n+\n+Compile and start the application:\n+[source, shell, subs=attributes+]\n+----\n+./mvnw clean install\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Finally test the application endpoint:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+=== Client Token using Response Wrapping\n+\n+One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access\n+to sensitive data in Vault. This requires ensuring that the application\u2019s configuration stays secure at all time.\n+If an intruder was to access the client token, it would be able to start calling Vault on all endpoints permitted\n+by the policy.\n+\n+This risk can be mitigated using an approach called\n+https://www.vaultproject.io/docs/concepts/response-wrapping[Response Wrapping] (which used to be known as\n+_Cubbyhole Authentication_ in older versions of Vault). This principle is simple: instead of configuring the\n+client token itself, we hide it inside a _Wrapping Token_, which we provide to the application. Upon startup,\n+the application will unwrap the _Wrapping Token_, and fetch the real token from within. The additional level of\n+security comes from the fact that the _Wrapping Token_ is short lived (from a few seconds to a few minutes;\n+basically just enough to start and unwrap the token), and can be unwrapped *only once*.\n+If the _Wrapping Token_ gets stolen and unwrapped, we will notice immediately because the legitimate application\n+will get an error saying that the token is invalid.\n+\n+With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a ttl of 1 minute:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -wrap-ttl=60s -policy=vault-quickstart-policy\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {client-token-wrapping-token}\n+wrapping_accessor:               ojvbOtmLzB5D47SzXGo9b3sR\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:05:20.990240428 +0000 UTC\n+wrapping_token_creation_path:    auth/token/create\n+wrapped_accessor:                a4ITYQNnQtwCOUmV5DJMpCiG\n+----\n+\n+Now let\u2019s use this wrapping token in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token-wrapping-token={client-token-wrapping-token}\n+----\n+\n+Compile and run the application *without the tests*, you should be able now to curl the private key `{private-key}` as before.\n+\n+Stop the application, and execute tests with `./mvnw test`. They should fail with error:\n+[source, shell, subs=attributes+]\n+----\n+ERROR: Failed to start application\n+io.quarkus.vault.VaultException: wrapping token is not valid or does not exist; this means that the token has already expired (if so you can increase the ttl on the wrapping token) or has been consumed by somebody else (potentially indicating that the wrapping token has been stolen)\n+----\n+\n+== Userpass Authentication\n+\n+Normally the `userpass` auth method should already be enabled from the {base-guide}.\n+\n+Simply specify the username and password for the user configured in Vault during setup:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.userpass.username=bob\n+quarkus.vault.authentication.userpass.password=sinclair\n+----\n+\n+Test the application endpoint after compiling and starting the application again:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+[NOTE]\n+====\n+Userpass supports response wrapping as well for the `password` property, although it is more\n+unsual to use this approach as response wrapping typically involves a technical workflow,\n+which is better suited for `approle`.\n+====\n+\n+== Approle Authentication\n+\n+_Approle_ is an authentication method suited for technical workflows. It relies on 2 pieces of information:\n+\n+* role id can be compared to the user name in _Userpass_\n+* secret id plays the role of the `password`\n+\n+To set up _Approle_ you need to enable the `approle` auth method, create an app role,\n+and generate a role id and secret id:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault auth enable approle\n+/ # vault write auth/approle/role/myapprole policies=vault-quickstart-policy\n+\n+/ # vault read auth/approle/role/myapprole/role-id\n+Key        Value\n+---        -----\n+role_id    {role-id}\n+\n+/ # vault write -f auth/approle/role/myapprole/secret-id\n+Key                   Value\n+---                   -----\n+secret_id             {secret-id}\n+secret_id_accessor    2acff656-d049-c4b3-a752-6125e69210ba\n+----\n+\n+Add the appropriate properties:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.role-id={role-id}\n+quarkus.vault.authentication.app-role.secret-id={secret-id}\n+----\n+\n+After compiling and running the application you should be able to curl it on the\n+`private-key` endpoint to see the secret information `{private-key}` as usual.\n+\n+=== Approle using Response Wrapping\n+\n+Similarly to direct client token authentication, it is possible to wrap the `secret-id`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault write -wrap-ttl=60s -f auth/approle/role/myapprole/secret-id\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {secret-id-wrapping-token}\n+wrapping_accessor:               u5EPZOnqyIJN8mT44od67WMS\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:59:25.482352967 +0000 UTC\n+wrapping_token_creation_path:    auth/approle/role/myapprole/secret-id\n+----\n+\n+Replace the `secret-id` property with `secret-id-wrapping-token` in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.secret-id-wrapping-token={secret-id-wrapping-token}\n+----\n+\n+Finally, recompile the application without tests (otherwise you are going to consume the wrapping token),\n+launch it and curl the `private-key` endpoint. As usual, you should see `{private-key}`.\n+\n+== Kubernetes Authentication\n+\n+Vault provides an integration with Kubernetes to allow containers to authenticate with Vault using their\n+Kubernetes jwt token located in `/var/run/secrets/kubernetes.io/serviceaccount`.\n+\n+The setup is more involved than with the other auth methods because we need to allow Vault to talk\n+to the master api to be able to validate the jwt token that the application will authenticate with.\n+\n+=== auth-delegator\n+\n+The first step involves creating a `vault-auth-sa` service account with `auth-delegator`\n+role that Vault will use to communicate with the master api.", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0MTY4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409741682", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Once the objects are created, we need to capture the jwt token of this service account,\n          \n          \n            \n            Once the objects are created, we need to capture the JWT token of this service account,", "author": "gsmet", "createdAt": "2020-04-16T17:51:21Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -policy=vault-quickstart-policy\n+Key                  Value\n+---                  -----\n+token                {client-token}\n+token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n+token_duration       768h\n+token_renewable      true\n+token_policies       [\"default\" \"vault-quickstart-policy\"]\n+identity_policies    []\n+policies             [\"default\" \"vault-quickstart-policy\"]\n+----\n+\n+Now use the generated client token in the application configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token={client-token}\n+----\n+\n+Compile and start the application:\n+[source, shell, subs=attributes+]\n+----\n+./mvnw clean install\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Finally test the application endpoint:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+=== Client Token using Response Wrapping\n+\n+One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access\n+to sensitive data in Vault. This requires ensuring that the application\u2019s configuration stays secure at all time.\n+If an intruder was to access the client token, it would be able to start calling Vault on all endpoints permitted\n+by the policy.\n+\n+This risk can be mitigated using an approach called\n+https://www.vaultproject.io/docs/concepts/response-wrapping[Response Wrapping] (which used to be known as\n+_Cubbyhole Authentication_ in older versions of Vault). This principle is simple: instead of configuring the\n+client token itself, we hide it inside a _Wrapping Token_, which we provide to the application. Upon startup,\n+the application will unwrap the _Wrapping Token_, and fetch the real token from within. The additional level of\n+security comes from the fact that the _Wrapping Token_ is short lived (from a few seconds to a few minutes;\n+basically just enough to start and unwrap the token), and can be unwrapped *only once*.\n+If the _Wrapping Token_ gets stolen and unwrapped, we will notice immediately because the legitimate application\n+will get an error saying that the token is invalid.\n+\n+With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a ttl of 1 minute:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -wrap-ttl=60s -policy=vault-quickstart-policy\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {client-token-wrapping-token}\n+wrapping_accessor:               ojvbOtmLzB5D47SzXGo9b3sR\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:05:20.990240428 +0000 UTC\n+wrapping_token_creation_path:    auth/token/create\n+wrapped_accessor:                a4ITYQNnQtwCOUmV5DJMpCiG\n+----\n+\n+Now let\u2019s use this wrapping token in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token-wrapping-token={client-token-wrapping-token}\n+----\n+\n+Compile and run the application *without the tests*, you should be able now to curl the private key `{private-key}` as before.\n+\n+Stop the application, and execute tests with `./mvnw test`. They should fail with error:\n+[source, shell, subs=attributes+]\n+----\n+ERROR: Failed to start application\n+io.quarkus.vault.VaultException: wrapping token is not valid or does not exist; this means that the token has already expired (if so you can increase the ttl on the wrapping token) or has been consumed by somebody else (potentially indicating that the wrapping token has been stolen)\n+----\n+\n+== Userpass Authentication\n+\n+Normally the `userpass` auth method should already be enabled from the {base-guide}.\n+\n+Simply specify the username and password for the user configured in Vault during setup:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.userpass.username=bob\n+quarkus.vault.authentication.userpass.password=sinclair\n+----\n+\n+Test the application endpoint after compiling and starting the application again:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+[NOTE]\n+====\n+Userpass supports response wrapping as well for the `password` property, although it is more\n+unsual to use this approach as response wrapping typically involves a technical workflow,\n+which is better suited for `approle`.\n+====\n+\n+== Approle Authentication\n+\n+_Approle_ is an authentication method suited for technical workflows. It relies on 2 pieces of information:\n+\n+* role id can be compared to the user name in _Userpass_\n+* secret id plays the role of the `password`\n+\n+To set up _Approle_ you need to enable the `approle` auth method, create an app role,\n+and generate a role id and secret id:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault auth enable approle\n+/ # vault write auth/approle/role/myapprole policies=vault-quickstart-policy\n+\n+/ # vault read auth/approle/role/myapprole/role-id\n+Key        Value\n+---        -----\n+role_id    {role-id}\n+\n+/ # vault write -f auth/approle/role/myapprole/secret-id\n+Key                   Value\n+---                   -----\n+secret_id             {secret-id}\n+secret_id_accessor    2acff656-d049-c4b3-a752-6125e69210ba\n+----\n+\n+Add the appropriate properties:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.role-id={role-id}\n+quarkus.vault.authentication.app-role.secret-id={secret-id}\n+----\n+\n+After compiling and running the application you should be able to curl it on the\n+`private-key` endpoint to see the secret information `{private-key}` as usual.\n+\n+=== Approle using Response Wrapping\n+\n+Similarly to direct client token authentication, it is possible to wrap the `secret-id`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault write -wrap-ttl=60s -f auth/approle/role/myapprole/secret-id\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {secret-id-wrapping-token}\n+wrapping_accessor:               u5EPZOnqyIJN8mT44od67WMS\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:59:25.482352967 +0000 UTC\n+wrapping_token_creation_path:    auth/approle/role/myapprole/secret-id\n+----\n+\n+Replace the `secret-id` property with `secret-id-wrapping-token` in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.secret-id-wrapping-token={secret-id-wrapping-token}\n+----\n+\n+Finally, recompile the application without tests (otherwise you are going to consume the wrapping token),\n+launch it and curl the `private-key` endpoint. As usual, you should see `{private-key}`.\n+\n+== Kubernetes Authentication\n+\n+Vault provides an integration with Kubernetes to allow containers to authenticate with Vault using their\n+Kubernetes jwt token located in `/var/run/secrets/kubernetes.io/serviceaccount`.\n+\n+The setup is more involved than with the other auth methods because we need to allow Vault to talk\n+to the master api to be able to validate the jwt token that the application will authenticate with.\n+\n+=== auth-delegator\n+\n+The first step involves creating a `vault-auth-sa` service account with `auth-delegator`\n+role that Vault will use to communicate with the master api.\n+\n+First create file `vault-auth-k8s.yml`:\n+[source, yaml, subs=attributes+]\n+----\n+---\n+apiVersion: v1\n+kind: ServiceAccount\n+metadata:\n+name: vault-auth-sa\n+---\n+kind: ClusterRoleBinding\n+apiVersion: rbac.authorization.k8s.io/v1\n+metadata:\n+name: vault-auth-delegator\n+subjects:\n+- kind: User\n+name: vault-auth-sa\n+namespace: default\n+roleRef:\n+kind: ClusterRole\n+name: system:auth-delegator\n+apiGroup: rbac.authorization.k8s.io\n+----\n+\n+And apply it: `kubectl apply -f vault-auth-k8s.yml`.\n+\n+Once the objects are created, we need to capture the jwt token of this service account,", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc0MjEwMg==", "url": "https://github.com/quarkusio/quarkus/pull/8615#discussion_r409742102", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            plus replace `<host>` by the ip or name of the local host that is running the Vault and PostgresQL containers,\n          \n          \n            \n            plus replace `<host>` by the ip or name of the local host that is running the Vault and PostgreSQL containers,", "author": "gsmet", "createdAt": "2020-04-16T17:52:00Z", "path": "docs/src/main/asciidoc/vault-auth.adoc", "diffHunk": "@@ -0,0 +1,433 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Working with HashiCorp Vault\u2019s Authentication\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+:base-guide: link:vault[Vault guide]\n+:root-token: s.5VUS8pte13RqekCB2fmMT3u2\n+:client-token: s.s93BVzJPzBiIGuYJHBTkG8Uw\n+:private-key: 123456\n+:client-token: s.JqMeE1UEyUb19F6zmMW0SWx6\n+:client-token-wrapping-token: s.2cLMBoKhelDK6W3uAFT2umXu\n+:role-id: b15460ff-fea0-43fc-1002-a045fb60dfc4\n+:secret-id: d2f13e1f-f32a-f60a-86d8-0b5cdaeb821b\n+:secret-id-wrapping-token: s.aSq7tcRqfeboZqLMPfa5gkXJ\n+\n+Working with Vault is typically a 2 step process:\n+\n+* Logging in, which returns a client token\n+* Start using Vault using the client token, within the limits of what is allowed in policies associated with the token\n+\n+There are several Vault authentication methods supported in Quarkus today, namely:\n+\n+* https://www.vaultproject.io/docs/auth/token[Token]: whenever you already have a token\n+* https://www.vaultproject.io/docs/auth/userpass[Userpass]: authenticate with a username and a password\n+* https://www.vaultproject.io/docs/auth/approle[AppRole]: authenticate with a role id and a secret id (which can\n+be seen as a _Userpass_ for automated workflows - machines and services)\n+* https://www.vaultproject.io/docs/auth/kubernetes[Kubernetes], which is applicable to workloads deployed into Kubernetes\n+\n+This guide aims at providing examples for each of those authentication methods.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* to complete the {base-guide}\n+* roughly 30 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Docker installed\n+* For the Kubernetes authentication: A Kubernetes distribution to deploy the Quarkus application (minishift, k3s, docker desktop, \u2026\u200b)\n+\n+== Token Authentication\n+\n+We assume there is a Vault container and a PostgresQL container running from the {base-guide}, and the root token is known.\n+\n+First, create a new shell, `docker exec` into the container and set the root token:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+/ # export VAULT_TOKEN={root-token}\n+----\n+\n+Create a token for policy `vault-quickstart-policy`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -policy=vault-quickstart-policy\n+Key                  Value\n+---                  -----\n+token                {client-token}\n+token_accessor       q1ynY9T7FDgbMKd3uST7RzLy\n+token_duration       768h\n+token_renewable      true\n+token_policies       [\"default\" \"vault-quickstart-policy\"]\n+identity_policies    []\n+policies             [\"default\" \"vault-quickstart-policy\"]\n+----\n+\n+Now use the generated client token in the application configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token={client-token}\n+----\n+\n+Compile and start the application:\n+[source, shell, subs=attributes+]\n+----\n+./mvnw clean install\n+java -jar target/vault-quickstart-1.0-SNAPSHOT-runner.jar\n+----\n+\n+Finally test the application endpoint:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+=== Client Token using Response Wrapping\n+\n+One drawback of this approach is that you expose a secret piece of information (.i.e the token) that can give access\n+to sensitive data in Vault. This requires ensuring that the application\u2019s configuration stays secure at all time.\n+If an intruder was to access the client token, it would be able to start calling Vault on all endpoints permitted\n+by the policy.\n+\n+This risk can be mitigated using an approach called\n+https://www.vaultproject.io/docs/concepts/response-wrapping[Response Wrapping] (which used to be known as\n+_Cubbyhole Authentication_ in older versions of Vault). This principle is simple: instead of configuring the\n+client token itself, we hide it inside a _Wrapping Token_, which we provide to the application. Upon startup,\n+the application will unwrap the _Wrapping Token_, and fetch the real token from within. The additional level of\n+security comes from the fact that the _Wrapping Token_ is short lived (from a few seconds to a few minutes;\n+basically just enough to start and unwrap the token), and can be unwrapped *only once*.\n+If the _Wrapping Token_ gets stolen and unwrapped, we will notice immediately because the legitimate application\n+will get an error saying that the token is invalid.\n+\n+With that in mind, let\u2019s create a new token and wrap it inside a _Wrapping Token_ with a ttl of 1 minute:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault token create -wrap-ttl=60s -policy=vault-quickstart-policy\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {client-token-wrapping-token}\n+wrapping_accessor:               ojvbOtmLzB5D47SzXGo9b3sR\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:05:20.990240428 +0000 UTC\n+wrapping_token_creation_path:    auth/token/create\n+wrapped_accessor:                a4ITYQNnQtwCOUmV5DJMpCiG\n+----\n+\n+Now let\u2019s use this wrapping token in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.client-token-wrapping-token={client-token-wrapping-token}\n+----\n+\n+Compile and run the application *without the tests*, you should be able now to curl the private key `{private-key}` as before.\n+\n+Stop the application, and execute tests with `./mvnw test`. They should fail with error:\n+[source, shell, subs=attributes+]\n+----\n+ERROR: Failed to start application\n+io.quarkus.vault.VaultException: wrapping token is not valid or does not exist; this means that the token has already expired (if so you can increase the ttl on the wrapping token) or has been consumed by somebody else (potentially indicating that the wrapping token has been stolen)\n+----\n+\n+== Userpass Authentication\n+\n+Normally the `userpass` auth method should already be enabled from the {base-guide}.\n+\n+Simply specify the username and password for the user configured in Vault during setup:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.userpass.username=bob\n+quarkus.vault.authentication.userpass.password=sinclair\n+----\n+\n+Test the application endpoint after compiling and starting the application again:\n+[source, shell, subs=attributes+]\n+----\n+curl http://localhost:8080/hello/private-key\n+----\n+\n+You should see: `{private-key}`.\n+\n+[NOTE]\n+====\n+Userpass supports response wrapping as well for the `password` property, although it is more\n+unsual to use this approach as response wrapping typically involves a technical workflow,\n+which is better suited for `approle`.\n+====\n+\n+== Approle Authentication\n+\n+_Approle_ is an authentication method suited for technical workflows. It relies on 2 pieces of information:\n+\n+* role id can be compared to the user name in _Userpass_\n+* secret id plays the role of the `password`\n+\n+To set up _Approle_ you need to enable the `approle` auth method, create an app role,\n+and generate a role id and secret id:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault auth enable approle\n+/ # vault write auth/approle/role/myapprole policies=vault-quickstart-policy\n+\n+/ # vault read auth/approle/role/myapprole/role-id\n+Key        Value\n+---        -----\n+role_id    {role-id}\n+\n+/ # vault write -f auth/approle/role/myapprole/secret-id\n+Key                   Value\n+---                   -----\n+secret_id             {secret-id}\n+secret_id_accessor    2acff656-d049-c4b3-a752-6125e69210ba\n+----\n+\n+Add the appropriate properties:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.role-id={role-id}\n+quarkus.vault.authentication.app-role.secret-id={secret-id}\n+----\n+\n+After compiling and running the application you should be able to curl it on the\n+`private-key` endpoint to see the secret information `{private-key}` as usual.\n+\n+=== Approle using Response Wrapping\n+\n+Similarly to direct client token authentication, it is possible to wrap the `secret-id`:\n+[source, shell, subs=attributes+]\n+----\n+/ # vault write -wrap-ttl=60s -f auth/approle/role/myapprole/secret-id\n+Key                              Value\n+---                              -----\n+wrapping_token:                  {secret-id-wrapping-token}\n+wrapping_accessor:               u5EPZOnqyIJN8mT44od67WMS\n+wrapping_token_ttl:              1m\n+wrapping_token_creation_time:    2020-04-14 16:59:25.482352967 +0000 UTC\n+wrapping_token_creation_path:    auth/approle/role/myapprole/secret-id\n+----\n+\n+Replace the `secret-id` property with `secret-id-wrapping-token` in the configuration:\n+[source, properties, subs=attributes+]\n+----\n+quarkus.vault.authentication.app-role.secret-id-wrapping-token={secret-id-wrapping-token}\n+----\n+\n+Finally, recompile the application without tests (otherwise you are going to consume the wrapping token),\n+launch it and curl the `private-key` endpoint. As usual, you should see `{private-key}`.\n+\n+== Kubernetes Authentication\n+\n+Vault provides an integration with Kubernetes to allow containers to authenticate with Vault using their\n+Kubernetes jwt token located in `/var/run/secrets/kubernetes.io/serviceaccount`.\n+\n+The setup is more involved than with the other auth methods because we need to allow Vault to talk\n+to the master api to be able to validate the jwt token that the application will authenticate with.\n+\n+=== auth-delegator\n+\n+The first step involves creating a `vault-auth-sa` service account with `auth-delegator`\n+role that Vault will use to communicate with the master api.\n+\n+First create file `vault-auth-k8s.yml`:\n+[source, yaml, subs=attributes+]\n+----\n+---\n+apiVersion: v1\n+kind: ServiceAccount\n+metadata:\n+name: vault-auth-sa\n+---\n+kind: ClusterRoleBinding\n+apiVersion: rbac.authorization.k8s.io/v1\n+metadata:\n+name: vault-auth-delegator\n+subjects:\n+- kind: User\n+name: vault-auth-sa\n+namespace: default\n+roleRef:\n+kind: ClusterRole\n+name: system:auth-delegator\n+apiGroup: rbac.authorization.k8s.io\n+----\n+\n+And apply it: `kubectl apply -f vault-auth-k8s.yml`.\n+\n+Once the objects are created, we need to capture the jwt token of this service account,\n+and grab the public certificate of the cluster:\n+[source, shell, subs=attributes+]\n+----\n+secret_name=$(kubectl get sa vault-auth-sa -o json | jq -r '.secrets[0].name')\n+token=$(kubectl get secret $secret_name -o json | jq -r '.data.token' | base64 --decode)\n+echo token=$token\n+kubectl get secret $secret_name -o json | jq -r '.data.\"ca.crt\"' | base64 -D > /tmp/ca.crt\n+----\n+\n+=== Vault\n+\n+The next step requires to exec interactively with the root token into the Vault container\n+to configure the Kubernetes auth method:\n+[source, shell, subs=attributes+]\n+----\n+docker exec -it dev-vault sh\n+export VAULT_TOKEN={root-token}\n+----\n+\n+Once inside the pod, set the token variable to the value that was just printed in the console before, and\n+recreate `ca.crt` with the same content as `/tmp/ca.crt` outside the container. Finally use `kubectl config view`\n+to assess the url of your Kubernetes cluster:\n+[source, shell, subs=attributes+]\n+----\n+token=...       => set the value printed in the console just before\n+vi ca.crt       => copy/paste /tmp/ca.crt from outside the container\n+kubernetes_host => url from the kubectl config view (e.g. https://kubernetes.docker.internal:6443)\n+----\n+\n+Now we have all the information we need to configure Vault:\n+[source, shell, subs=attributes+]\n+----\n+vault auth enable kubernetes\n+\n+# configure master api access from Vault\n+vault write auth/kubernetes/config \\\n+    token_reviewer_jwt=$token \\\n+    kubernetes_host=$kubernetes_host \\\n+    kubernetes_ca_cert=@ca.crt\n+\n+# create vault-quickstart-role role\n+vault write auth/kubernetes/role/vault-quickstart-role \\\n+    bound_service_account_names=vault-quickstart-sa \\\n+    bound_service_account_namespaces=default \\\n+    policies=vault-quickstart-policy \\\n+    ttl=1h\n+----\n+\n+=== Deploy the application\n+\n+Add the following properties to the application (and remove any other authentication Vault property,\n+plus replace `<host>` by the ip or name of the local host that is running the Vault and PostgresQL containers,", "originalCommit": "f5ea58e58bcb5b252e849325b0dc42ea9cc9fb65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "532d33ed422d84b6378078005b1bc95e5edefb45", "url": "https://github.com/quarkusio/quarkus/commit/532d33ed422d84b6378078005b1bc95e5edefb45", "message": "Quarkus Vault Authentication Guide - Fixes #4846", "committedDate": "2020-04-16T19:05:44Z", "type": "commit"}, {"oid": "532d33ed422d84b6378078005b1bc95e5edefb45", "url": "https://github.com/quarkusio/quarkus/commit/532d33ed422d84b6378078005b1bc95e5edefb45", "message": "Quarkus Vault Authentication Guide - Fixes #4846", "committedDate": "2020-04-16T19:05:44Z", "type": "forcePushed"}]}