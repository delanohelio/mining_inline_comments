{"pr_number": 10619, "pr_title": "Fix Spring Data JPA Query Methods for big hierarchy", "pr_createdAt": "2020-07-09T20:07:08Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/10619", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NjQzMg==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453446432", "bodyText": "I think the entire contents of this if could be moved to a dedicated method.", "author": "geoand", "createdAt": "2020-07-13T05:44:56Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {", "originalCommit": "a28a523ed5f19d28b4c6280f9f21504348c77aec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0Njg1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453446852", "bodyText": "As it seems that indexView.getClassByName((entityClass.superClassType().name()) and indexView.getClassByName((fieldInfo.type().name()) are used a few times, best move them to a variable with a proper name", "author": "geoand", "createdAt": "2020-07-13T05:46:13Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {\n+                StringBuilder finalName = new StringBuilder(fieldName);\n+\n+                Set<String> childFields = new HashSet<>();\n+\n+                childFields.addAll(entityClass.fields().stream()\n+                        .map(FieldInfo::name)\n+                        .collect(Collectors.toList()));\n+\n+                // Collecting the current class fields\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null) {\n+                    childFields.addAll(\n+                            indexView.getClassByName(fieldInfo.type().name()).fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name)\n+                                    .collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclass of the actual class\n+                if (entityClass.superClassType().name() != null &&", "originalCommit": "a28a523ed5f19d28b4c6280f9f21504348c77aec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NzI1Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453447252", "bodyText": "Can we have a comment explaining this please?", "author": "geoand", "createdAt": "2020-07-13T05:47:47Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {\n+                StringBuilder finalName = new StringBuilder(fieldName);\n+\n+                Set<String> childFields = new HashSet<>();\n+\n+                childFields.addAll(entityClass.fields().stream()\n+                        .map(FieldInfo::name)\n+                        .collect(Collectors.toList()));\n+\n+                // Collecting the current class fields\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null) {\n+                    childFields.addAll(\n+                            indexView.getClassByName(fieldInfo.type().name()).fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name)\n+                                    .collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclass of the actual class\n+                if (entityClass.superClassType().name() != null &&\n+                        indexView.getClassByName(entityClass.superClassType().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null) {\n+\n+                    childFields.addAll(indexView.getClassByName(entityClass.superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+\n+                    childFields.addAll(indexView.getClassByName(\n+                            indexView.getClassByName(fieldInfo.type().name()).superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclasses of the attributes\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null &&\n+                        indexView.getClassByName(\n+                                indexView.getClassByName(fieldInfo.type().name()).superClassType().name()) != null) {\n+\n+                    childFields.addAll(\n+                            indexView.getClassByName(indexView.getClassByName(fieldInfo.type().name())\n+                                    .superClassType()\n+                                    .name())\n+                                    .fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                for (String fieldInf : childFields) {\n+                    if (StringUtils.containsIgnoreCase(fieldName, fieldInf)) {\n+                        String newValue = finalName.toString()\n+                                .replaceAll(\"(?i)\" + fieldInf, lowerFirstLetter(fieldInf) + \".\");\n+                        finalName.delete(0, finalName.length());\n+                        finalName.append(newValue);\n+                    }\n+                }\n+\n+                if (finalName.toString().charAt(finalName.length() - 1) == '.') {", "originalCommit": "a28a523ed5f19d28b4c6280f9f21504348c77aec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NzM0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453447342", "bodyText": "A comment on what this section does would be nice", "author": "geoand", "createdAt": "2020-07-13T05:48:06Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {\n+                StringBuilder finalName = new StringBuilder(fieldName);\n+\n+                Set<String> childFields = new HashSet<>();\n+\n+                childFields.addAll(entityClass.fields().stream()\n+                        .map(FieldInfo::name)\n+                        .collect(Collectors.toList()));\n+\n+                // Collecting the current class fields\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null) {\n+                    childFields.addAll(\n+                            indexView.getClassByName(fieldInfo.type().name()).fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name)\n+                                    .collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclass of the actual class\n+                if (entityClass.superClassType().name() != null &&\n+                        indexView.getClassByName(entityClass.superClassType().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null) {\n+\n+                    childFields.addAll(indexView.getClassByName(entityClass.superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+\n+                    childFields.addAll(indexView.getClassByName(\n+                            indexView.getClassByName(fieldInfo.type().name()).superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclasses of the attributes\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null &&\n+                        indexView.getClassByName(\n+                                indexView.getClassByName(fieldInfo.type().name()).superClassType().name()) != null) {\n+\n+                    childFields.addAll(\n+                            indexView.getClassByName(indexView.getClassByName(fieldInfo.type().name())\n+                                    .superClassType()\n+                                    .name())\n+                                    .fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                for (String fieldInf : childFields) {", "originalCommit": "a28a523ed5f19d28b4c6280f9f21504348c77aec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODExMQ==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453588111", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // In some cases; the built hierarchy is ending by a joining point. so we need to remove it\n          \n          \n            \n                    // In some cases, the built hierarchy is ending by a joining point. so we need to remove it", "author": "geoand", "createdAt": "2020-07-13T11:38:13Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -366,6 +375,74 @@ public Result parse(MethodInfo methodInfo) {\n                 topCount);\n     }\n \n+    private String handleFieldsHierarchy(String fieldName, FieldInfo currentField) {\n+        StringBuilder finalName = new StringBuilder(fieldName);\n+\n+        Set<String> childFields = new HashSet<>();\n+\n+        childFields.addAll(entityClass.fields().stream()\n+                .map(FieldInfo::name)\n+                .collect(Collectors.toList()));\n+\n+        // Collecting the current class fields\n+        ClassInfo currentClassInfo = indexView.getClassByName(currentField.type().name());\n+\n+        if (currentClassInfo != null) {\n+            childFields.addAll(\n+                    currentClassInfo.fields()\n+                            .stream()\n+                            .map(FieldInfo::name)\n+                            .collect(Collectors.toList()));\n+        }\n+\n+        // Collecting the inherited fields from the superclass of the actual class\n+        DotName superClassName = entityClass.superClassType().name();\n+        ClassInfo superClassInfo = indexView.getClassByName(superClassName);\n+\n+        ClassInfo classByName;\n+\n+        if (superClassName != null && superClassInfo != null && currentClassInfo != null &&\n+                currentClassInfo.superClassType() != null &&\n+                (classByName = indexView.getClassByName(currentClassInfo.superClassType().name())) != null) {\n+\n+            childFields.addAll(superClassInfo.fields()\n+                    .stream()\n+                    .map(FieldInfo::name).collect(Collectors.toList()));\n+\n+            childFields.addAll(classByName.fields()\n+                    .stream()\n+                    .map(FieldInfo::name).collect(Collectors.toList()));\n+        }\n+\n+        // Collecting the inherited fields from the superclasses of the attributes\n+        if (currentClassInfo != null && currentClassInfo.superClassType() != null\n+                && (classByName = indexView.getClassByName(currentClassInfo.superClassType().name())) != null) {\n+\n+            childFields.addAll(\n+                    classByName.fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+        }\n+\n+        // Building the fieldName from the members classes and their superclasses\n+        for (String fieldInf : childFields) {\n+            if (StringUtils.containsIgnoreCase(fieldName, fieldInf)) {\n+                String newValue = finalName.toString()\n+                        .replaceAll(\"(?i)\" + fieldInf, lowerFirstLetter(fieldInf) + \".\");\n+                finalName.delete(0, finalName.length());\n+                finalName.append(newValue);\n+            }\n+        }\n+\n+        // In some cases; the built hierarchy is ending by a joining point. so we need to remove it", "originalCommit": "e309f711d078fc641c975bb84d2cb5922b8a614f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODIxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453588219", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // we need to split the camelcase format and grap the first item\n          \n          \n            \n                    // we need to split the camelcase format and grab the first item", "author": "geoand", "createdAt": "2020-07-13T11:38:28Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -488,7 +565,13 @@ private boolean entityContainsField(String fieldName) {\n     }\n \n     private FieldInfo getField(String fieldName) {\n+        // Before validating the fieldInfo,\n+        // we need to split the camelcase format and grap the first item", "originalCommit": "e309f711d078fc641c975bb84d2cb5922b8a614f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453588645", "bodyText": "Perhaps add comment about how this works? Regex can be daunting when coming back to them after not having seen them for a while :)", "author": "geoand", "createdAt": "2020-07-13T11:39:22Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -516,10 +599,13 @@ private FieldInfo getField(String fieldName) {\n                 superClassType = parameterizedType.owner();\n             }\n         }\n-        if (mappedSuperClassInfos.size() > 0) {\n-            return mappedSuperClassInfos;\n-        }\n-        return Collections.emptyList();\n+        return mappedSuperClassInfoElements;\n+    }\n+\n+    private static List<String> splitCamelCaseString(String s) {\n+        List<String> result = new ArrayList<>();\n+        Collections.addAll(result, s.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\"));", "originalCommit": "e309f711d078fc641c975bb84d2cb5922b8a614f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5MTIzNA==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453591234", "bodyText": "Do we have a \"policy\" regarding pre-compiling Pattern? Or is ok here if it is re-compiled every time since it probably won't be thousands of invocations and it is \"just\" deployment code?\nhttps://www.baeldung.com/java-regex-pre-compile", "author": "famod", "createdAt": "2020-07-13T11:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5OTU2OA==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453599568", "bodyText": "We don't really have one, but in this case it's very unlikely we will run into a bottleneck due to the very small number of methods this case handles.", "author": "geoand", "createdAt": "2020-07-13T12:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMTIxNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453601215", "bodyText": "@geoand I thought the name of the method was explicit \ud83d\ude05  I will add a comment anyway..\n@famod yes it's a code executed only once..", "author": "nebrass", "createdAt": "2020-07-13T12:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMTk4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453601985", "bodyText": "It is, I just want an explanation of the regex itself if possible \ud83d\ude0e", "author": "geoand", "createdAt": "2020-07-13T12:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYzMzQ3OQ==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453633479", "bodyText": "@geoand I found a better choice.. in the apache commons there is the same method StringUtils.splitByCharacterTypeCamelCase() \ud83d\ude01", "author": "nebrass", "createdAt": "2020-07-13T13:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY0ODYzMA==", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453648630", "bodyText": "Even better!", "author": "geoand", "createdAt": "2020-07-13T13:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}], "type": "inlineReview"}, {"oid": "55e397830dda63913b87fe0110f7e57cce7ec10c", "url": "https://github.com/quarkusio/quarkus/commit/55e397830dda63913b87fe0110f7e57cce7ec10c", "message": "Fix Spring Data JPA Query Methods for big hierarchy", "committedDate": "2020-07-13T13:05:46Z", "type": "commit"}]}