{"pr_number": 6387, "pr_title": "Add JSON-B and Jackson serialization to the Kafka guide", "pr_createdAt": "2020-01-03T09:15:03Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/6387", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDExOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754119", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Quarkus has built-in capabilities to deals with JSON Kafka messages.\n          \n          \n            \n            Quarkus has built-in capabilities to deal with JSON Kafka messages.", "author": "gsmet", "createdAt": "2020-01-03T09:55:04Z", "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.", "originalCommit": "b07574a9589794cafb098c722b60096916ab0dcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDE4NA==", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754184", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Imagine we have a `Fruit` pojo as following:\n          \n          \n            \n            Imagine we have a `Fruit` pojo as follows:", "author": "gsmet", "createdAt": "2020-01-03T09:55:18Z", "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:", "originalCommit": "b07574a9589794cafb098c722b60096916ab0dcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDQ5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754496", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n          \n          \n            \n            First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed).", "author": "gsmet", "createdAt": "2020-01-03T09:56:17Z", "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).", "originalCommit": "b07574a9589794cafb098c722b60096916ab0dcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDc0OA==", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754748", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n          \n          \n            \n            Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo.", "author": "gsmet", "createdAt": "2020-01-03T09:57:10Z", "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !", "originalCommit": "b07574a9589794cafb098c722b60096916ab0dcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDgyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754829", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n          \n          \n            \n            First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-jackson-jsonb` extension, this is not needed).", "author": "gsmet", "createdAt": "2020-01-03T09:57:27Z", "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).", "originalCommit": "b07574a9589794cafb098c722b60096916ab0dcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDk2NA==", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754964", "bodyText": "Let's get rid of the blank lines.", "author": "gsmet", "createdAt": "2020-01-03T09:57:54Z", "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+\n+", "originalCommit": "b07574a9589794cafb098c722b60096916ab0dcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc3Mzg5Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362773897", "bodyText": "done", "author": "loicmathieu", "createdAt": "2020-01-03T11:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NTAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362755024", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now, your Kafka messages will contains a Jackson serialized representation of your Fruit pojo !\n          \n          \n            \n            Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo.", "author": "gsmet", "createdAt": "2020-01-03T09:58:06Z", "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+\n+\n+----\n+\n+Now, your Kafka messages will contains a Jackson serialized representation of your Fruit pojo !", "originalCommit": "b07574a9589794cafb098c722b60096916ab0dcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "788f76461826f85dddfa1e529c35a40f96bc2f2b", "url": "https://github.com/quarkusio/quarkus/commit/788f76461826f85dddfa1e529c35a40f96bc2f2b", "message": "Add JSON-B and Jackson serialization to the Kafka guide", "committedDate": "2020-01-03T11:04:01Z", "type": "forcePushed"}, {"oid": "400475b22bd9e783faa7f4a788779ecf1e3dd96d", "url": "https://github.com/quarkusio/quarkus/commit/400475b22bd9e783faa7f4a788779ecf1e3dd96d", "message": "Add JSON-B and Jackson serialization to the Kafka guide", "committedDate": "2020-01-03T11:19:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc5NTc2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362795765", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you want Resteasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events,\n          \n          \n            \n            If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events,", "author": "gsmet", "createdAt": "2020-01-03T12:40:37Z", "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,197 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deal with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as follows:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo.\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-jackson-jsonb` extension, this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+----\n+\n+Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo.\n+\n+=== Sending JSON Server-Sent Events (SSE)\n+\n+If you want Resteasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events,", "originalCommit": "400475b22bd9e783faa7f4a788779ecf1e3dd96d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c90d46af2eb26883e393a40a5c06fa1f3784e2b2", "url": "https://github.com/quarkusio/quarkus/commit/c90d46af2eb26883e393a40a5c06fa1f3784e2b2", "message": "Add JSON-B and Jackson serialization to the Kafka guide", "committedDate": "2020-01-03T12:55:25Z", "type": "commit"}, {"oid": "c90d46af2eb26883e393a40a5c06fa1f3784e2b2", "url": "https://github.com/quarkusio/quarkus/commit/c90d46af2eb26883e393a40a5c06fa1f3784e2b2", "message": "Add JSON-B and Jackson serialization to the Kafka guide", "committedDate": "2020-01-03T12:55:25Z", "type": "forcePushed"}]}