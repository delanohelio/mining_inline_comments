{"pr_number": 8545, "pr_title": "Hibernate ORM Multitenancy", "pr_createdAt": "2020-04-13T07:30:57Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8545", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI5NjQ0NA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r410296444", "bodyText": "Great example! thanks a lot", "author": "Sanne", "createdAt": "2020-04-17T15:24:50Z", "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,216 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:", "originalCommit": "a24a32087d6f107eb5fe4fff8f757a1baf928850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEzMzAwNw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415133007", "bodyText": "Tnx. The enhanced doc is combined with a new quickstart that can be merged right after this pull request: quarkusio/quarkus-quickstarts#525\nIt has an additional dropdown to select the tenant for every request. It shows in detail how to use this feature and it works quite well.", "author": "michael-schnell", "createdAt": "2020-04-25T19:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI5NjQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI5NjY0NA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r410296644", "bodyText": "Shouldn't this have a @Transactional as well?", "author": "Sanne", "createdAt": "2020-04-17T15:25:09Z", "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,216 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.persistence.EntityManager;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+\n+@ApplicationScoped\n+@Produces(\"application/json\")\n+@Consumes(\"application/json\")\n+@Path(\"/{tenant}\")\n+public class FruitResource {\n+\n+    @Inject\n+    EntityManager entityManager;\n+\n+    @GET\n+    @Path(\"fruits\")\n+    public Fruit[] getFruits() {", "originalCommit": "a24a32087d6f107eb5fe4fff8f757a1baf928850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEzMTMyNA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415131324", "bodyText": "I don't think it is necessary for the reads. The description is besically just a copy of the quickstart example FruitResource.java that has been copied from the orginal Hibernate ORM Quickstart.", "author": "michael-schnell", "createdAt": "2020-04-25T19:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI5NjY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r410300880", "bodyText": "I'm not sure about exposing the RoutingContext component on the TenantResolver API. Do we possibly have better alternatives? Ideally something that could directly take the /{tenant} variable from the @Path annotation on the endpoint?\n@FroMage as someone knowing well both Hibernate , REST and vertx.. maybe you have a better idea of how this should look like?", "author": "Sanne", "createdAt": "2020-04-17T15:32:03Z", "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,216 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.persistence.EntityManager;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+\n+@ApplicationScoped\n+@Produces(\"application/json\")\n+@Consumes(\"application/json\")\n+@Path(\"/{tenant}\")\n+public class FruitResource {\n+\n+    @Inject\n+    EntityManager entityManager;\n+\n+    @GET\n+    @Path(\"fruits\")\n+    public Fruit[] getFruits() {\n+        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n+                .getResultList().toArray(new Fruit[0]);\n+    }\n+    \n+}\n+----\n+\n+In order to resolve the tenant from incoming requests and map it to a specific tenant configuration, you need to create an implementation for the `io.quarkus.hibernate.orm.runtime.tenant.TenantResolver` interface.\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.Unremovable;\n+import io.quarkus.hibernate.orm.runtime.tenant.TenantResolver;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@ApplicationScoped\n+@Unremovable\n+public class CustomTenantResolver implements TenantResolver {\n+\n+    @Override\n+    public String getDefaultHibernateOrmTenantId() {\n+        return \"base\";\n+    }\n+    \n+    @Override\n+    public String resolveHibernateOrmTenantId(RoutingContext context) {", "originalCommit": "a24a32087d6f107eb5fe4fff8f757a1baf928850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMTMyNA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r410301324", "bodyText": "(it especially bothers me that the user code needs to validate/split/parse the request path again)", "author": "Sanne", "createdAt": "2020-04-17T15:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEzMjcyNA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415132724", "bodyText": "I think the routing context is a good choice. That's why I have taken the idea from the ODIC Multitenant implementation: CustomTenantResolver.java.\nYou would normally need to get some information from the incoming request to decide which tenant is targeted with the request. The information could be taken from path (as in the example) or maybe also from the request header.\nIt is also very likely that the two parts Hibernate & ODIC multitenancy will be used in combination. You can simply create a single class that shares some code between the two. Unfortunately it was not really possible to use exactly the same signature. The ODIC multitenancy relies on the fact that NULL is considered as the value for the default tenant. Hibernate does not allow a NULL value for the tenant id.", "author": "michael-schnell", "createdAt": "2020-04-25T19:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwNDYyMw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415804623", "bodyText": "I'm not eager to require a dependency on the vertx module: it needs to be possible to use the Hibernate ORM extension even in an application which doesn't have any web endpoint.\nI think there's some options:\n\nExpose a different type, something like TenantId, or MultitenancyContext, and leave it to the developer to have a bean which performs the conversion - possibly making it easy such as having a CDI Factory.\nMove your TenantResolver approach into a dedicated module / extension\nMake sure that TenantResolver is one way out of several options - making the binding to the VertX module optional.\n\nI suppose we can mix these approaches; for example my favourite is 1# in terms of clean design, but you could have a default factory (2#) provided for user's convenience. This could initially like in this same module (3#) and later be broken out as a future improvement.\nOr maybe you have a better idea?", "author": "Sanne", "createdAt": "2020-04-27T13:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4NjI3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415986275", "bodyText": "OK, I think this is not a big problem. I will just rewrite the TenantResolver like this:\npublic interface TenantResolver {\n    String getDefaultTenantId();\n    String resolveTenantId();\n}\nThe implementation by the user then is:\n@RequestScoped\npublic class CustomTenantResolver implements TenantResolver {\n    \n    @Inject\n    RoutingContext context;\n    \n    public String getDefaultTenantId() {\n        return \"base\";\n    }\n    public String resolveTenantId() {\n        ...\n    }\n}\nSo there is no longer a dependency in the Hibernate ORM extension to vertx, only in the user's implementation.\nTo be noted: The resolver is now request scoped. This has influence on the other topic raised. It must be resolved via Arc because it cannot be done at startup time in the config.", "author": "michael-schnell", "createdAt": "2020-04-27T16:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyODk5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416128992", "bodyText": "Thanks!\nThe new TenantResolver interface looks good; question: wouldn't it be better to not have a defaultTenantId ?\nIf you don't force one, I would expect implementors can still choose to return a default - should other options fail. But it might also be clearer to them when the default would be used (since it's their own code), which I would find more reassuring.\nRegarding the implementaiton, I do like this example but I believe it should be possible as well to not need Arc. Shouldn't the CustomTenantResolver rather have the option to lookup an Arc component?", "author": "Sanne", "createdAt": "2020-04-27T20:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzNzM0OA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416537348", "bodyText": "The new TenantResolver interface looks good; question: wouldn't it be better to not have a defaultTenantId ?\nIf you don't force one, I would expect implementors can still choose to return a default - should other options fail. But it might also be clearer to them when the default would be used (since it's their own code), which I would find more reassuring.\n\nI did that first, but unfortunately Hibernate does not allow a null value for a tenantId. This means we would still have to create an artifical default value internally to use it with the Hibernate settings. Then we have to translate that back to the null value for the TenantConnectionResolver, because the user expects now also a null tenantId over there:\npublic interface TenantConnectionResolver {\n    ConnectionProvider resolve(String tenantId);\n}\nAt the end I think it is easier to understand if you say \"You need to define a default value for the tenantId and it cannot be null\". That is what is expressed in the interface. That also matches the Hibernate philosophy which does not allow null.\nLast important point: It is needed for HibernateMultiTenantConnectionProvider.getAnyConnectionProvider() method. In case Hibernate asks \"give me any connection provider\", we will use the one returned by \"getDefaultTenantId()\".\n\nRegarding the implementaiton, I do like this example but I believe it should be possible as well to not need Arc. Shouldn't the CustomTenantResolver rather have the option to lookup an Arc component?\n\nWhat exactly do you mean here? I think I explained this in the other comment stream.", "author": "michael-schnell", "createdAt": "2020-04-28T11:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzY3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416553671", "bodyText": "Regarding the default tenantId : ok, if you prefer so that's fine. Just making sure we're understanding the implications: don't you think it's generally a possible design error from the user's part to ever return null?\nIn such cases we normally prefer to throw an explict exception rather than silently and sneakily change semantics; I suspect that just requiring a tenantId would make for more robust end user systems.\nRegarding the Arc puzzle:\nI meant it could be the user's implementation of TenantConnectionResolver to explicitly have some code like\nArc.container().instance(RoutingContext.class);\n\nshould he/she want to base the decision on the routing - or anything else.\nIt's not a suggestion though, I'm not an expert of CDI nor ArC - just wondering if that's not conceptually a clean solution so to not need users to specify multiple configuration properties.", "author": "Sanne", "createdAt": "2020-04-28T11:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415831016", "bodyText": "Resolving the reference to the right TenantResolver via Arc is not necessary and actually a problem as we want to be able to start multiple instances of Hibernate ORM, which could be configured differently.\nYou should be able to simply inject the HibernateCurrentTenantIdentifierResolver instance into the ORM configuration; for example this should work:\nconfiguration.put( org.hibernate.cfg.AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, new HibernateCurrentTenantIdentifierResolver( tenantResolver ) );\n\nThis way you can store the tenant into a final field, properly and simply initialized in its constructor.", "author": "Sanne", "createdAt": "2020-04-27T13:52:21Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateCurrentTenantIdentifierResolver.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantResolver} to the Hibernate {@link CurrentTenantIdentifierResolver} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateCurrentTenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateCurrentTenantIdentifierResolver.class);\n+\n+    @Override\n+    public String resolveCurrentTenantIdentifier() {\n+\n+        TenantResolver resolver = tenantResolver();\n+\n+        // Make sure that we're in a request or return default tenant\n+        if (!Arc.container().requestContext().isActive()) {\n+            return resolver.getDefaultHibernateOrmTenantId();\n+        }\n+\n+        RoutingContext routingContext = routingContext();\n+        String tenantId = resolver.resolveHibernateOrmTenantId(routingContext);\n+        if (tenantId == null) {\n+            throw new IllegalStateException(\"Method 'CurrentTenantIdentifierResolver.\"\n+                    + \"resolveHibernateOrmTenantId(RoutingContext)' returned a null value. \"\n+                    + \"Unfortunately Hibernate ORM does not allow null for tenant identifiers. \"\n+                    + \"Please use a non-null value!\");\n+        }\n+        LOG.debugv(\"resolveCurrentTenantIdentifier(): {0}\", tenantId);\n+        return tenantId;\n+\n+    }\n+\n+    @Override\n+    public boolean validateExistingCurrentSessions() {\n+        return jpaConfig().isValidateTenantInCurrentSessions();\n+    }\n+\n+    /**\n+     * Returns the singleton JPA configuration instance.\n+     * \n+     * @return JPA configuration.\n+     */\n+    private static JPAConfig jpaConfig() {\n+        InstanceHandle<JPAConfig> jpaConfigInstance = Arc.container().instance(JPAConfig.class);\n+        if (!jpaConfigInstance.isAvailable()) {\n+            throw new IllegalStateException(\"No instance of JPAConfig found\");\n+        }\n+        return jpaConfigInstance.get();\n+    }\n+\n+    /**\n+     * Retrieves the routing context or fails if it is not available.\n+     * \n+     * @return Current routing context.\n+     */\n+    private static RoutingContext routingContext() {\n+        InstanceHandle<RoutingContext> routingContextInstance = Arc.container().instance(RoutingContext.class);\n+        if (!routingContextInstance.isAvailable()) {\n+            throw new IllegalStateException(\"No instance of \" + RoutingContext.class.getName() + \" was found.\");\n+        }\n+        return routingContextInstance.get();\n+    }\n+\n+    /**\n+     * Retrieves the tenant resolver or fails if it is not available.\n+     * \n+     * @return Current tenant resolver.\n+     */\n+    private static TenantResolver tenantResolver() {\n+        InstanceHandle<TenantResolver> resolverInstance = Arc.container().instance(TenantResolver.class);", "originalCommit": "a24a32087d6f107eb5fe4fff8f757a1baf928850", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5Mzc0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415893743", "bodyText": "Which \" ORM configuration\" do you exactly refer to?", "author": "michael-schnell", "createdAt": "2020-04-27T15:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk0NjAyNA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415946024", "bodyText": "It's the cfg Map variable you can see in io.quarkus.hibernate.orm.runtime.boot.FastBootMetadataBuilder#mergeSettings, were we set most other automatically inferred configuration properties.", "author": "Sanne", "createdAt": "2020-04-27T16:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxMDAwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416010001", "bodyText": "OK, I guess it is then not the \"FastBootMetadataBuilder\", but the FastBootEntityManagerFactoryBuilder as the instance of HibernateCurrentTenantIdentifierResolver is created there.\nBut I assume this will not work as the \"FastBootEntityManagerFactoryBuilder\" will be created at startup (maybe application scope), but the \"TenantResolver\" needs to be resolved within a request scope.\nIs there really a need to support multiple instances of Hibernate ORM with multiple different implementations of the \"TenantResolver\"? This will get much more complicated. I guess the only way then would be to configure the class name of the actual \"TenantResolver\" per Hibernate ORM instance. But how do I configure multiple instances of Hibernate ORM? I haven't seen such a feature anywhere in the docs.", "author": "michael-schnell", "createdAt": "2020-04-27T17:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTc1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416131751", "bodyText": "Is there really a need to support multiple instances of Hibernate ORM with multiple different implementations of the \"TenantResolver\"?\n\nI'm afraid so: if we take such shortcuts it would all get confusing to use.\n\nBut how do I configure multiple instances of Hibernate ORM? I haven't seen such a feature anywhere in the docs.\n\nWe don't have the capability yet but it is in high demand; the problem is that as lots of people keep adding features and changes that make it conceptually harder we'll never be able to complete that.. which is why I please need some help in making sure all newly merged code at least take the requirement into account.\nI do understand it gets a little bit more complicated but I just want to make sure the design will make it possible at a conceptual level - not asking you to actually implement it.\nThanks!", "author": "Sanne", "createdAt": "2020-04-27T20:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMzODMzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416338331", "bodyText": "OK, let's assume we have multiple instances of Hibernate ORM. Then we will need to distinguish multiple instances of the tenant resolver and the resolvers may have different types. This could be achieved using CDI qualifiers and explicitly naming the resolver class.\nThen the solution would have two parts:\n\nDefine the type of the resolver by having it's fully qualified class name in the config\nDefine a qualifier in the config that maps somehow to the Hibernate ORM instance\n\nExample:\nquarkus.hibernate-orm.one.multitenant=SCHEMA\nquarkus.hibernate-orm.one.multitenancy-resolver=a.b.c.MyResolver // Implements TenantResolver\nquarkus.hibernate-orm.one.multitenancy-qualifier=one // Qualifier\nquarkus.hibernate-orm.two.multitenant=DATABASE\nquarkus.hibernate-orm.two.multitenancy-resolver=a.b.c.OtherResolver // Implements TenantResolver\nquarkus.hibernate-orm.two.multitenancy-qualifier=two // Qualifier\n\nCurrently we don't have multiple instances and we don't want to bother the user with such edge case configurations. The \"95% case\" will simply be one instance. Therefore we need a way to keep it still simple. This is exactly how it is implemented now and it is open to above future design.\nIn the FastBootEntityManagerFactoryBuilder the HibernateCurrentTenantIdentifierResolver instance is created and might use some configuration options later on, that are not needed now:\nif (strategy != null && strategy != MultiTenancyStrategy.NONE) {\n    options.applyMultiTenancyStrategy(strategy);\n    options.applyCurrentTenantIdentifierResolver(new HibernateCurrentTenantIdentifierResolver());\n}\nIn the HibernateCurrentTenantIdentifierResolver class we still resolve the TenantResolver dynamically (using Arc), because it is RequestScoped and we cannot create it at boot time in the FastBootEntityManagerFactoryBuilder:\nprivate static TenantResolver tenantResolver() {\n    InstanceHandle<TenantResolver> resolverInstance = Arc.container().instance(TenantResolver.class);\n    ....\n}\nLater on, when multiple Hibernate ORM instances are available you could use the qualifier and class from the configuration similar to this one:\nprivate static TenantResolver tenantResolver(Class<TenantResolver> resolverClass, String qualifierName) {\n    InstanceHandle<TenantResolver> resolverInstance = Arc.container().instance(resolverClass,\n            new AnnotationLiteral() {\n                public String value() {\n                    return qualifierName;\n                };\n            });\n      ...\nOne thing we could indeed move into the FastBootEntityManagerFactoryBuilder is the JPAConfig.\nSummary\nIf we do the changes you proposed in regard to the vertx module dependency and make the TenantResolver request scoped (as suggested above), the HibernateCurrentTenantIdentifierResolver can stay as it is now. JPAConfig will be passed to HibernateCurrentTenantIdentifierResolver as constructor parameter.\nIf you are OK with that, I will commit and squash my changes accordingly.", "author": "michael-schnell", "createdAt": "2020-04-28T05:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1OTMxNw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416559317", "bodyText": "Currently we don't have multiple instances and we don't want to bother the user with such edge case configurations. The \"95% case\" will simply be one instance. Therefore we need a way to keep it still simple. This is exactly how it is implemented now and it is open to above future design.\n\nI like what you're saying here and totally agree that we should keep it simple for the 95% of users.\nReferring to your example:\nI might be missing something since I've never used CDI, but wouldn't we conceptually need the user to just specify either the qualifier or the class? I would expect it to be possible to only need to express a \"single choice\".\nFurther more, consider that via the Jandex index we have a full analysis of the application; this implies that we can enumerate the implementations of, for example, a TenantResolver implementation and choose it as default when only a single implementation is found.\n(should we go with a single TenantResolver implementation and use qualifiers instead - assuming it's possible to use only one approach as mention in the previous paragraph - then resolving the default bean rather than using qualifiers should come even more natural?)\nThat would be sweet as it means the components could be bound correctly without any configuration at all; requiring configuration only for multiple persistence units which require to differentiate their settings.\n@manovotn / @mkouba would you have some time to review and correct my ramblings about ArC? I'd really hope we could keep this both flexible and straight forward to use :)\nThanks!", "author": "Sanne", "createdAt": "2020-04-28T12:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY0OTE1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416649155", "bodyText": "I have quite limited understanding of what you're trying to achieve and might need some more context, but broadly speaking - if you want to have multiple implementations of, say, TenantResolver, then you will end up with ambiguity if you try to just inject it based on type TenantResolver. You'd have to either use qualifiers, or resolve it based on the implementing class.\nAs for simple cases and having one TenantResolver by default, that's doable, you just have to have a singular existing bean with that type and without CDI qualifiers. From the above comments I understood that this is something you already have.\nIf the impl of TenantResolver is something that user defines, then they can define the qualifiers used with it as well. And if you then need to retrieve all impls of TenantResolver via CDI (regardless of qualifiers) you can do that too with (for instance) Arc.container().instance(TenantResolver.class, Any.Literal.INSTANCE) and then iterate over them.", "author": "manovotn", "createdAt": "2020-04-28T14:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjY1MDQ2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416650467", "bodyText": "If I am blabbering about something else then what you wanted to know, then please give me some more info and I'll try to help some more :-)", "author": "manovotn", "createdAt": "2020-04-28T14:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcwMzQxMA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r416703410", "bodyText": "At the end I just wanted to show that using \"Arc.container().instance(..)\" is not \"evil\" here. It is required, because we need to resolve a request scoped bean and therefore we cannot do it at boot time. In addition to that it allows us in a later stage to change this as needed in HibernateCurrentTenantIdentifierResolver. But no need to do it now as we don't have multiple Hibernate ORM instances yet. So no need for qualifiers and other stuff now, but a way to go in the future.\nI already tested the new classes with the new Hibernate ORM multitenancy quickstart and it still works finr with the changes above. I will now commit them to continue here with the next review steps.", "author": "michael-schnell", "createdAt": "2020-04-28T15:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTk1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423881953", "bodyText": "Returning null here is illegal. Is this were you plan to use getDefaultTenantId() ?\nPerhaps an runtime exception is more suited?", "author": "Sanne", "createdAt": "2020-05-12T16:46:13Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateCurrentTenantIdentifierResolver.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantResolver} to the Hibernate {@link CurrentTenantIdentifierResolver} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateCurrentTenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateCurrentTenantIdentifierResolver.class);\n+\n+    private final JPAConfig jpaConfig;\n+\n+    public HibernateCurrentTenantIdentifierResolver(final JPAConfig jpaConfig) {\n+        super();\n+        this.jpaConfig = jpaConfig;\n+    }\n+\n+    @Override\n+    public String resolveCurrentTenantIdentifier() {\n+\n+        // Make sure that we're in a request\n+        if (!Arc.container().requestContext().isActive()) {\n+            return null;", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMDIxMg==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426220212", "bodyText": "It is actually OK here. I checked this with the Hibernate source and it is not required to have a non-null value. The case is caused by calls to this method during early startup phase. At that time there is no request context so the only chance is to return null. For Hibernate there is in this case simply no tenant information available, which is fine.", "author": "michael-schnell", "createdAt": "2020-05-17T05:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4Mzk0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423883946", "bodyText": "It seems this is the only use for the jpaConfig object. Does this stricly need some lazy initialization, or could you read the field earlier and store only an immutable boolean field rather than keeping a reference to the bootstrap proxy?", "author": "Sanne", "createdAt": "2020-05-12T16:49:16Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateCurrentTenantIdentifierResolver.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantResolver} to the Hibernate {@link CurrentTenantIdentifierResolver} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateCurrentTenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateCurrentTenantIdentifierResolver.class);\n+\n+    private final JPAConfig jpaConfig;\n+\n+    public HibernateCurrentTenantIdentifierResolver(final JPAConfig jpaConfig) {\n+        super();\n+        this.jpaConfig = jpaConfig;\n+    }\n+\n+    @Override\n+    public String resolveCurrentTenantIdentifier() {\n+\n+        // Make sure that we're in a request\n+        if (!Arc.container().requestContext().isActive()) {\n+            return null;\n+        }\n+\n+        TenantResolver resolver = tenantResolver();\n+        String tenantId = resolver.resolveTenantId();\n+        if (tenantId == null) {\n+            throw new IllegalStateException(\"Method 'TenantResolver.resolveTenantId()' returned a null value. \"\n+                    + \"Unfortunately Hibernate ORM does not allow null for tenant identifiers. \"\n+                    + \"Please use a non-null value!\");\n+        }\n+        LOG.debugv(\"resolveCurrentTenantIdentifier(): {0}\", tenantId);\n+        return tenantId;\n+\n+    }\n+\n+    @Override\n+    public boolean validateExistingCurrentSessions() {\n+        return jpaConfig.isValidateTenantInCurrentSessions();", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyNjUwMw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426226503", "bodyText": "Already removed when removing config 'ValidateTenantInCurrentSessions'.", "author": "michael-schnell", "createdAt": "2020-05-17T07:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4Mzk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4NDYzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423884635", "bodyText": "this should be safe to remove; we generally don't use Serialization, and when we do we prefer to not declare serial version ids as constants.", "author": "Sanne", "createdAt": "2020-05-12T16:50:11Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateMultiTenantConnectionProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;\n+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantConnectionResolver} to the {@link HibernateMultiTenantConnectionProvider} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateMultiTenantConnectionProvider extends AbstractMultiTenantConnectionProvider {\n+\n+    private static final long serialVersionUID = 1L;", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMDMzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426220335", "bodyText": "I removed it", "author": "michael-schnell", "createdAt": "2020-05-17T05:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4NDYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5MDcwOA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423890708", "bodyText": "Why is this static ? Let's try to avoid that, especially as this Service doesn't have any stop/destroy facility.\nFYI there's the option to implement org.hibernate.service.spi.Stoppable if you need a callback, but I believe removing the static should be done as well.", "author": "Sanne", "createdAt": "2020-05-12T16:59:12Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateMultiTenantConnectionProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;\n+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantConnectionResolver} to the {@link HibernateMultiTenantConnectionProvider} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateMultiTenantConnectionProvider extends AbstractMultiTenantConnectionProvider {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateMultiTenantConnectionProvider.class);\n+\n+    private static final Map<String, ConnectionProvider> PROVIDER_MAP = new ConcurrentHashMap<>();", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMDU4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426220586", "bodyText": "You're right, I changed it This was a leftover from setting the provider statically as a kind of singleton.", "author": "michael-schnell", "createdAt": "2020-05-17T05:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5MDcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5Mzg5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423893891", "bodyText": "I'd prefer if you could use an \"old fashioned get\" here first, only falling back to a computeIfAbsent operation if your local cache doesn't have it so to avoid contention in the implementation of ConcurrentHashMap#computeIfAbsent since there is no need to have contention.", "author": "Sanne", "createdAt": "2020-05-12T17:04:24Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateMultiTenantConnectionProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;\n+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantConnectionResolver} to the {@link HibernateMultiTenantConnectionProvider} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateMultiTenantConnectionProvider extends AbstractMultiTenantConnectionProvider {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateMultiTenantConnectionProvider.class);\n+\n+    private static final Map<String, ConnectionProvider> PROVIDER_MAP = new ConcurrentHashMap<>();\n+\n+    @Override\n+    protected ConnectionProvider getAnyConnectionProvider() {\n+        String tenantId = tenantResolver().getDefaultTenantId();\n+        if (tenantId == null) {\n+            throw new IllegalStateException(\"Method 'TenantResolver.getDefaultTenantId()' returned a null value. \"\n+                    + \"This violates the contract of the interface!\");\n+        }\n+        return selectConnectionProvider(tenantId);\n+    }\n+\n+    @Override\n+    protected ConnectionProvider selectConnectionProvider(String tenantIdentifier) {\n+        LOG.debugv(\"selectConnectionProvider({0})\", tenantIdentifier);\n+\n+        return PROVIDER_MAP.computeIfAbsent(tenantIdentifier, tid -> {", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMDkxNA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426220914", "bodyText": "OK, I changed it", "author": "michael-schnell", "createdAt": "2020-05-17T05:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5Mzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTMyMA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423899320", "bodyText": "I'm wondering if it wouldn't be better to refrain from exposing this option. AFAIR Quarkus we don't expose org.hibernate.context.spi.CurrentSessionContext, which makes this check useless?\nI'd prefer to omit this, as less is more - especially when it's easy to add things, but never easy to remove something.\nAlso, removing this configuration option would resolve a couple more comments I had :)", "author": "Sanne", "createdAt": "2020-05-12T17:13:08Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfig.java", "diffHunk": "@@ -101,6 +101,33 @@\n     @ConfigItem\n     Optional<String> implicitNamingStrategy;\n \n+    /**\n+     * Defines the method for multi-tenancy (DATABASE, NONE, SCHEMA). The complete list of allowed values is available in the\n+     * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/MultiTenancyStrategy.html[Hibernate ORM JavaDoc].\n+     * The type DISCRIMINATOR is currently not supported.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenant;\n+\n+    /**\n+     * Defines the name of the data source to use in case of SCHEMA approach. The default data source will be used if not set.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenantSchemaDatasource;\n+\n+    /**\n+     * Defines if the tenant identifier of the \"current sessions\" should be validated every time the tenant identifier is", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMTM5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426221392", "bodyText": "OK, I removed it", "author": "michael-schnell", "createdAt": "2020-05-17T06:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTYwMw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423899603", "bodyText": "Could you also clarify that NONE is the default?", "author": "Sanne", "createdAt": "2020-05-12T17:13:35Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfig.java", "diffHunk": "@@ -101,6 +101,33 @@\n     @ConfigItem\n     Optional<String> implicitNamingStrategy;\n \n+    /**\n+     * Defines the method for multi-tenancy (DATABASE, NONE, SCHEMA). The complete list of allowed values is available in the\n+     * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/MultiTenancyStrategy.html[Hibernate ORM JavaDoc].\n+     * The type DISCRIMINATOR is currently not supported.", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyMjg5NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426222895", "bodyText": "OK, I added a hint for the default.", "author": "michael-schnell", "createdAt": "2020-05-17T06:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNjY1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423906655", "bodyText": "Could you avoid registering this bean as \"unremovable\" when multitenancy is not being used?", "author": "Sanne", "createdAt": "2020-05-12T17:25:09Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java", "diffHunk": "@@ -405,7 +417,7 @@ void registerBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans, Combi\n \n         additionalBeans.produce(AdditionalBeanBuildItem.builder().setUnremovable()\n                 .addBeanClasses(JPAConfig.class, TransactionEntityManagers.class,\n-                        RequestScopedEntityManagerHolder.class)\n+                        RequestScopedEntityManagerHolder.class, DataSourceTenantConnectionResolver.class)", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyNTQ4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426225482", "bodyText": "OK, I changed it.", "author": "michael-schnell", "createdAt": "2020-05-17T06:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxMDQ2OA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423910468", "bodyText": "So assuming I set it to \"schema\" approach, why would I ever want to set this to a different value than what I'm configuring Hiberante ORM to use in the database.defaultSchema setting?\nI would prefer to imply (and enforce) a reasonable default rather than exposing another configuration option. Unless I'm missing something of course.", "author": "Sanne", "createdAt": "2020-05-12T17:31:19Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfig.java", "diffHunk": "@@ -101,6 +101,33 @@\n     @ConfigItem\n     Optional<String> implicitNamingStrategy;\n \n+    /**\n+     * Defines the method for multi-tenancy (DATABASE, NONE, SCHEMA). The complete list of allowed values is available in the\n+     * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/MultiTenancyStrategy.html[Hibernate ORM JavaDoc].\n+     * The type DISCRIMINATOR is currently not supported.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenant;\n+\n+    /**\n+     * Defines the name of the data source to use in case of SCHEMA approach. The default data source will be used if not set.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenantSchemaDatasource;", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyNTk3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426225976", "bodyText": "This could be helpful if you for example want to separate the default database from the one used for tenant schemas. I would prefer to leave it as it is, to allow separation in case this is needed. We also have  a good default if the user does not set it. But there is now still the option to separate the tenant stuff from the default data source.", "author": "michael-schnell", "createdAt": "2020-05-17T07:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxMDQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNjYyOA==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423916628", "bodyText": "you're suggesting that the interface exists, but not how one creates one. Should it suggest also that we'll look for a CDI bean having such an interface?", "author": "Sanne", "createdAt": "2020-05-12T17:41:10Z", "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,219 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.persistence.EntityManager;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+\n+@ApplicationScoped\n+@Produces(\"application/json\")\n+@Consumes(\"application/json\")\n+@Path(\"/{tenant}\")\n+public class FruitResource {\n+\n+    @Inject\n+    EntityManager entityManager;\n+\n+    @GET\n+    @Path(\"fruits\")\n+    public Fruit[] getFruits() {\n+        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n+                .getResultList().toArray(new Fruit[0]);\n+    }\n+    \n+}\n+----\n+\n+In order to resolve the tenant from incoming requests and map it to a specific tenant configuration, you need to create an implementation for the `io.quarkus.hibernate.orm.runtime.tenant.TenantResolver` interface.\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.Unremovable;\n+import io.quarkus.hibernate.orm.runtime.tenant.TenantResolver;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@@RequestScoped\n+@Unremovable\n+public class CustomTenantResolver implements TenantResolver {\n+\n+    @Inject\n+    RoutingContext context;\n+\n+    @Override\n+    public String getDefaultTenantId() {\n+        return \"base\";\n+    }\n+    \n+    @Override\n+    public String resolveTenantId() {\n+        String path = context.request().path();\n+        String[] parts = path.split(\"/\");\n+\n+        if (parts.length == 0) {\n+            // resolve to default tenant config\n+            return getDefaultTenantId();\n+        }\n+\n+        return parts[1];\n+    }\n+    \n+}\n+----\n+\n+From the implementation above, tenants are resolved from the request path so that in case no tenant could be inferred, the default tenant identifier is returned.\n+\n+=== Configuring the application\n+\n+In general it is not possible to use the Hibernate ORM database generation feature in conjunction with a multitenancy setup.\n+Therefore you have to disable it and you need to make sure that the tables are created per schema. \n+The following setup will use the link:https://quarkus.io/guides/flyway[Flyway] extension to achieve this goal.\n+\n+==== SCHEMA approach\n+\n+The same data source will be used for all tenants and a schema has to be created for every tenant inside that data source. \n+\n+[source,properties]\n+----\n+# Disable generation\n+quarkus.hibernate-orm.database.generation=none\n+\n+# Enable SCHEMA approach and use default schema\n+quarkus.hibernate-orm.multitenant=SCHEMA\n+# You could use a non-default schema by using the following setting \n+# quarkus.hibernate-orm.multitenant-schema-datasource=other\n+\n+# The default data source used for all tenant schemas\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_test\n+\n+# Enable Flyway configuration to create schemas\n+quarkus.flyway.schemas=base,mycompany\n+quarkus.flyway.locations=classpath:schema\n+quarkus.flyway.migrate-at-start=true\n+----\n+\n+Here is an example of the Flyway SQL (`V1.0.0__create_fruits.sql`) to be created in the configured folder `src/main/resources/schema`.\n+\n+[source,sql]\n+----\n+CREATE SEQUENCE base.known_fruits_id_seq;\n+SELECT setval('base.\"known_fruits_id_seq\"', 3);\n+CREATE TABLE base.known_fruits\n+(\n+  id   INT,\n+  name VARCHAR(40)\n+);\n+INSERT INTO base.known_fruits(id, name) VALUES (1, 'Cherry');\n+INSERT INTO base.known_fruits(id, name) VALUES (2, 'Apple');\n+INSERT INTO base.known_fruits(id, name) VALUES (3, 'Banana');\n+\n+CREATE SEQUENCE mycompany.known_fruits_id_seq;\n+SELECT setval('mycompany.\"known_fruits_id_seq\"', 3);\n+CREATE TABLE mycompany.known_fruits\n+(\n+  id   INT,\n+  name VARCHAR(40)\n+);\n+INSERT INTO mycompany.known_fruits(id, name) VALUES (1, 'Avocado');\n+INSERT INTO mycompany.known_fruits(id, name) VALUES (2, 'Apricots');\n+INSERT INTO mycompany.known_fruits(id, name) VALUES (3, 'Blackberries');\n+----\n+\n+\n+\n+==== DATABASE approach\n+\n+For every tenant you need to create a named data source with the same identifier that is returned by the `TenantResolver`. \n+\n+[source,properties]\n+----\n+# Disable generation\n+quarkus.hibernate-orm.database.generation=none\n+\n+# Enable DATABASE approach\n+quarkus.hibernate-orm.multitenant=DATABASE\n+\n+# Default tenant 'base'\n+quarkus.datasource.base.db-kind=postgresql\n+quarkus.datasource.base.username=quarkus_test\n+quarkus.datasource.base.password=quarkus_test\n+quarkus.datasource.base.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_test\n+\n+# Tenant 'mycompany'\n+quarkus.datasource.mycompany.db-kind=postgresql\n+quarkus.datasource.mycompany.username=mycompany\n+quarkus.datasource.mycompany.password=mycompany\n+quarkus.datasource.mycompany.jdbc.url=jdbc:postgresql://localhost:5433/mycompany\n+\n+# Flyway configuration for the default datasource\n+quarkus.flyway.locations=classpath:database/default\n+quarkus.flyway.migrate-at-start=true\n+\n+# Flyway configuration for the mycompany datasource\n+quarkus.flyway.mycompany.locations=classpath:database/mycompany\n+quarkus.flyway.mycompany.migrate-at-start=true\n+----\n+\n+Following are examples of the Flyway SQL files to be created in the configured folder `src/main/resources/database`.\n+\n+Default schema (`src/main/resources/database/default/V1.0.0__create_fruits.sql`):\n+\n+[source,sql]\n+----\n+CREATE SEQUENCE known_fruits_id_seq;\n+SELECT setval('known_fruits_id_seq', 3);\n+CREATE TABLE known_fruits\n+(\n+  id   INT,\n+  name VARCHAR(40)\n+);\n+INSERT INTO known_fruits(id, name) VALUES (1, 'Cherry');\n+INSERT INTO known_fruits(id, name) VALUES (2, 'Apple');\n+INSERT INTO known_fruits(id, name) VALUES (3, 'Banana');\n+----\n+\n+Mycompany schema (`src/main/resources/database/mycompany/V1.0.0__create_fruits.sql`):\n+\n+[source,sql]\n+----\n+CREATE SEQUENCE known_fruits_id_seq;\n+SELECT setval('known_fruits_id_seq', 3);\n+CREATE TABLE known_fruits\n+(\n+  id   INT,\n+  name VARCHAR(40)\n+);\n+INSERT INTO known_fruits(id, name) VALUES (1, 'Avocado');\n+INSERT INTO known_fruits(id, name) VALUES (2, 'Apricots');\n+INSERT INTO known_fruits(id, name) VALUES (3, 'Blackberries');\n+----\n+\n+=== Programmatically Resolving Tenants Connections\n+\n+If you need a more dynamic configuration for the different tenants you want to support and don't want to end up with multiple\n+entries in your configuration file, you can use the `io.quarkus.hibernate.orm.runtime.tenant.TenantConnectionResolver`.\n+\n+This interface allows you to dynamically create tenant connections at runtime.", "originalCommit": "280564264ba45877df7d15ad285cc1caf588b73d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxODU0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426218547", "bodyText": "you're suggesting that the interface exists, but not how one creates one. Should it suggest also that we'll look for a CDI bean having such an interface?\n\nI enhanced the doc for the custom tenant resolver.", "author": "michael-schnell", "createdAt": "2020-05-17T05:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNjYyOA=="}], "type": "inlineReview"}, {"oid": "24b81ab92d3d927cc666dc2685d803188015aa3a", "url": "https://github.com/quarkusio/quarkus/commit/24b81ab92d3d927cc666dc2685d803188015aa3a", "message": "Hibernate ORM Multitenancy", "committedDate": "2020-05-17T07:15:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI5OTE1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426299153", "bodyText": "this property no longer exists", "author": "Sanne", "createdAt": "2020-05-17T20:03:12Z", "path": "integration-tests/hibernate-tenancy/src/main/resources/application.properties", "diffHunk": "@@ -0,0 +1,38 @@\n+# Hibernate ORM settings \n+quarkus.hibernate-orm.database.generation=none\n+quarkus.hibernate-orm.multitenant=DATABASE\n+quarkus.hibernate-orm.validate-tenant-in-current-sessions=false", "originalCommit": "24b81ab92d3d927cc666dc2685d803188015aa3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc2MzU2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426763569", "bodyText": "Fixed with #9423", "author": "michael-schnell", "createdAt": "2020-05-18T16:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI5OTE1Mw=="}], "type": "inlineReview"}]}